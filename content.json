{"meta":{"title":"gentryhuang‘s blog","subtitle":"blog","description":"博客","author":"gentryhuang","url":"https://gentryhuang.com","root":"/"},"pages":[{"title":"关于我","date":"2020-08-09T08:58:11.880Z","updated":"2020-08-09T08:58:11.880Z","comments":false,"path":"about/index.html","permalink":"https://gentryhuang.com/about/index.html","excerpt":"","text":"123456789101112131415161718&#x2F;**** * ┏┓ ┏┓ * ┃ ┃ + +* ┃ ━ ┃ ++ + + +* ████━████┃ 🚂🚂🚂-&lt;-&lt; 欢迎访问我的博客* ┃ ┃ + * ┃ ┻ ┃ + + * ┃ ┃ * ┗━┓ ┏━┛Code is far away from bug with the animal protecting * ┃ ┃ 神兽护体，永无bug * ┃ ┃ +* ┃ ┗━━━┓+* ┃ ┣┓ 📬 联系我：gentryhuang.xw@gmail.com* ┃ ┏┛ + + * ┗┓┓┏━┳┓┏┛ +* ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ *&#x2F;"},{"title":"分类","date":"2020-07-03T15:03:26.305Z","updated":"2020-07-03T15:03:26.305Z","comments":false,"path":"categories/index.html","permalink":"https://gentryhuang.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-07-05T10:07:05.047Z","updated":"2020-07-03T15:03:37.362Z","comments":true,"path":"links/index.html","permalink":"https://gentryhuang.com/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2020-07-06T16:29:08.229Z","updated":"2020-07-06T16:29:08.229Z","comments":false,"path":"repository/index.html","permalink":"https://gentryhuang.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-03T15:03:56.993Z","updated":"2020-07-03T15:03:56.993Z","comments":false,"path":"tags/index.html","permalink":"https://gentryhuang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis原理 - 链表","slug":"redis_theory/data_structure/链表","date":"2020-07-08T11:33:59.000Z","updated":"2020-08-14T08:57:43.413Z","comments":false,"path":"posts/2362a8ea/","link":"","permalink":"https://gentryhuang.com/posts/2362a8ea/","excerpt":"","text":"链表 redis中的链表 链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置这中数据结构，所以redis构建了自己的链表实现。 redis链表节点的结构 12345678typedef struct listNode&#123; // 前置节点 struct listNode *prev; // 后置节点 struct listNode *next; // 节点的值 (可用于保存各种不同类型的值) void *value&#125;listNode; redis链表结构 123456789101112131415161718192021typedef struct list &#123; // 表头节点 listNode *head; // 表尾节点 listNode *tail; // 节点值复制函数，用于复制链表节点所保存的值 void *(*dup)(void *ptr); // 节点值释放函数，用于释放链表节点所保存的值 void (*free)(void *ptr); // 节点值对比函数，用于对比链表节点所保存的值和其他值是否相等 int (*match)(void *ptr, void *key); // 链表所包含的节点数量 unsigned long len;&#125; list; redis链表的特点 12345- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点- 带表头和表尾指针：使用list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)- 带链表长度计数器：程序使用list结构的len属性标记链表中节点的个数，程序获取链表中节点个数的复杂度为O(1)- 多态：链表可以保存各种不同类型的值 链表在redis中的应用 链表被广泛用于实现redis的各种功能，如：列表键、发布与订阅、慢查询、监视器，redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://gentryhuang.com/categories/Redis/"}],"tags":[{"name":"Redis数据结构","slug":"Redis数据结构","permalink":"https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Redis原理 - 简单动态字符串","slug":"redis_theory/data_structure/简单动态字符串","date":"2020-07-08T11:00:50.000Z","updated":"2020-08-14T08:57:43.411Z","comments":false,"path":"posts/aa1d8127/","link":"","permalink":"https://gentryhuang.com/posts/aa1d8127/","excerpt":"","text":"简单动态字符串 初识动态字符串 redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS作为redis的默认字符串表示。 在redis中，c字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如日志。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，redis就会使用SDS来表示字符串值。 值的注意的是，对于redis中的key都是使用SDS来实现的。此外，SDS除了用来保存Redis数据库中的字符串值之外，SDS还被用作缓冲区（buffer）: AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区。 sds的结构 12345678struct sdshdr&#123; // 记录buf数组中已使用字节的数量等价于sds所保存字符串的长度 int len; // 记录buf数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[];&#125; 注意： sds遵循c字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在sds的len属性中，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由sds函数自动完成的。遵循空字符结尾的好处是，sds可以直接使用一部分C字符串函数库里面的函数。 sds与c字符串的区别 c语言使用的简单字符串表示方式，并不能满足redis对字符串在安全性、效率以及功能方面的要求。 3.1 常数复杂度获取字符串长度 因为c字符串并不记录自身的长度信息，所以要获取长度就必须遍历整个字符串，故获取字符串长度的复杂度为O(N)。而redis的sds结构中通过len属性记录了sds的长度，故获取字符串长度的复杂度为O(1)。注意，设置和更新sds长度的工作是由sds的API在执行时自动完成的，使用sds无须进行任何手动修改长度的操作。 3.2 避免缓冲区溢出 c字符串不记录自身长度，很容易造成缓冲区溢出。与c字符串不同，sds的空间分配策略完全杜绝了发生缓冲区溢出的可能性，当sds api需要对sds进行修改时，api会先检查sds的空间是否满足需要，如果不满足的话，api会自动将sds的空间扩展至执行所需的大小，然后才执行实际的修改操作，因此使用sds既不需要手动修改sds的空间大小，也不会出现c字符串中可能出现的缓冲区溢出问题。 1234567891011121314151617sds sdscatlen(sds s, const void *t, size_t len) &#123; size_t curlen = sdslen(s); //追加时先进行扩容，后面详细说明 s = sdsMakeRoomFor(s,len); if (s == NULL) return NULL; //拼接字符串 memcpy(s+curlen, t, len); sdssetlen(s, curlen+len); s[curlen+len] = '\\0'; return s;&#125;// s:原数组 //strlen(t) 需拼接的目标数组的长度sds sdscat(sds s, const char *t) &#123; return sdscatlen(s, t, strlen(t));&#125;​ 3.3 内存分配与释放 因为c字符串的长度和底层数组的长度之间存在着关联性，所以每次增加或者缩短一个c字符串，程序都总要对保存这个c字符串的数字进行一次分配操作，但是内存分配操作涉及到复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，为了避免c字符串的这种缺陷，sds通过未使用空间解除了字符串长度和底层数组长度之间的关联，通过未使用空间，sds实现了空间预分配和惰性空间释放两种优化策略。 空间预分配 空间预分配用于优化sds的字符串增长操作：当sds的api对一个sds进行修改，并且需要对sds进行空间扩展的时候，程序不仅会为sds分配修改所必须要的空间，还会为sds分配额外的未使用空间。通过空间预分配策略，redis可以减少连续执行字符串增长操作所需的内存重新分配次数，在扩展sds空间之前，sds api 会先检查未使用空间是否足够，如果足够就直接使用未使用空间，而不需要执行内存重新分配。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// redis 扩容源码/* * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后， * buf 至少会有 addlen + 1 长度的空余空间 * （额外的 1 字节是为 \\0 准备的） * * 返回值 * sds ：扩展成功返回扩展后的 sds * 扩展失败返回 NULL * * 复杂度 * T = O(N) */sds sdsMakeRoomFor(sds s, size_t addlen) &#123; struct sdshdr *sh, *newsh; // 获取 s 目前的空余空间长度 size_t free = sdsavail(s); size_t len, newlen; // s 目前的空余空间已经足够，无须再进行扩展，直接返回 if (free &gt;= addlen) return s; // 获取 s 目前已占用空间的长度 len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); // s 最少需要的长度 newlen = (len+addlen); // 根据新长度，为 s 分配新空间所需的大小 if (newlen &lt; SDS_MAX_PREALLOC) // 如果新长度小于 SDS_MAX_PREALLOC // 那么为它分配两倍于所需长度的空间 newlen *= 2; else // 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC newlen += SDS_MAX_PREALLOC; // T = O(N) newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1); // 内存不足，分配失败，返回 if (newsh == NULL) return NULL; // 更新 sds 的空余长度 newsh-&gt;free = newlen - len; // 返回 sds return newsh-&gt;buf;&#125; 额外分配未使用空间数量的计算策略： 对sds修改后，sds的长度（即len属性的值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时sds的len属性的值将和free属性的值相同。例如：修改后sds的len变成10字节，那么程序也会分配10字节的未使用空间，sds的buf数组的实际长度：10 + 10 + 1 = 21字节 对sds修改后，sds的长度大于等于1MB，那么程序会分配1MB的未使用空间。例如：修改后sds的len变成30MB，那么程序会分配1MB的未使用空间，sds的buf数组的时间长度：30MB + 1MB + 1byte 惰性空间释放 惰性空间释放用于优化sds的字符串缩短操作：当sds的api需要缩短sds保存的字符串时，程序并不立即使用内存重分配来回收缩短后多来的字节，而是使用free属性将这些字节的数量纪录起来，用于将来对sds进行增长操作时，这些未使用空间可能就派上用场了。注意，sds也提供了相应的api，可以真正地释放sds的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。 3.4 二进制安全 c字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里不能包含空字符，否则在读取的时候会被默认为结束字符，这些限制使得c字符串只能保存文本数据，不能保存图片、音视频、压缩文件这类的二进制数据。sds的api都是二进制安全的，所有的sds api都会以二进制的方式处理sds存放在buf数组里的数据,程序不会对其中的数据做任何限制、过滤，数据写入时是什么样，它被读取时就是什么样。这也是将sds的buf属性称为字节数组的原因，redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。 c字符串和sds之间的区别 123456 C字符串 SDS- 获取字符串长度的复杂度为O（n） 获取字符串长度的复杂度O（1）- API是不安全的，可能造成缓冲区溢出 API是安全的- 修改字符串长度N次，必然要执行N次内存重分配 修改字符长度N次，最多执行N次内存重分配- 只能保存文本数据 可以保存文本或者二进制数据- 可使用&lt;string.h&gt;库中的函数 可使用一部分&lt;string.h&gt;库中的函数 sds更多的api可参考源码","categories":[{"name":"Redis","slug":"Redis","permalink":"https://gentryhuang.com/categories/Redis/"}],"tags":[{"name":"Redis数据结构","slug":"Redis数据结构","permalink":"https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Dubbo源码分析 - 优雅停机","slug":"rpc/优雅停机","date":"2020-05-09T16:00:00.000Z","updated":"2020-09-03T01:23:40.728Z","comments":false,"path":"posts/ef4cfe7a/","link":"","permalink":"https://gentryhuang.com/posts/ef4cfe7a/","excerpt":"","text":"概述优雅停机仅存在于服务重启、下线这样的部署阶段，优雅停机是一个应用生命周期的一部分，它保障了应用的健壮性。dubbo是通过jdk的ShutdownHook来完成优雅停机的，所以如果用户使用 kill -9 pid 等强制关闭指令，是不会执行优雅停机的，只有通过 kill pid 即正常退出进程，才会执行。 基本要求 优雅停机的服务端有正在处理中的请求，不能被停机指令中断，除非超时 优雅停机的消费端不应该再发起新的请求 消费端不应该请求已经下线的服务提供者 意义应用的重新启动、停机等操作，避免了对业务的连续性造成影响，如：集群中的某个应用存在逻辑上的bug，需要修改程序，这时候就可以使用优雅停机平滑下线，不会造成调用方异常问题。 原理 dubbo中实现优雅停机主要包含以下步骤 收到kill 9 进程退出信号时，spring容器会触发容器销毁事件 (其实是spring注册的jvm钩子程序执行的，后面会看到) provider端会取消注册服务元数据信息 consumer端会收到最新地址列表（准备停机地址不在该地址列表中） dubbo协议会发送readonly事件报文通知consumer服务不可用 服务端等待已经执行的任务结束并不再处理新的请求 说明 上图中的流程是使用spring构建的dubbo应用 上图中的流程没有体现出优雅停机的消费端角色，该角色做的工作相对简单，主要是不再发起新的调用请求和等待响应返回，超时才会强制关闭 注册中心已经通知了最新服务列表，发送readonly事件主要考虑到注册中心推送服务有网络延迟以及客户端计算服务列表也需要时间。消费端收到后会设置对应的provider为不可用状态，下次负载均衡就不会调用这个下线的服务 方案dubbo对优雅停机的实现在不同的版本中有所差异，下面从2.5.x、2.6.x以及2.7.x这三个版本分别分析。 2.5.x的优雅停机注册shutdown hook 12345678910111213141516171819public abstract class AbstractConfig implements Serializable &#123; // 省略其它代码 static &#123; Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() &#123; public void run() &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Run shutdown hook now.\"); &#125; /** * 销毁资源 * 1 注册中心数据销毁： 删除注册中心中本节点对应的提供者地址以及订阅数据 * 2 协议流程数据销毁： 取消该协议所有已经暴露和引用的服务，释放协议所占用的所有资源，比如连接和端口 */ ProtocolConfig.destroyAll(); &#125; &#125;, \"DubboShutdownHook\")); &#125; 说明 ProtocolConfig.destroyAll()方法是用来释放资源的，由于dubbo支持多注册中心和多协议，因此具体销毁实现细节取决于具体的注册中心和具体的协议，这里不再展开说明。 2.6.x的优雅停机 spring也依赖shutdown hook完成优雅停机，其注册jvm钩子的方法如下： 12345678910111213141516171819202122232425/** * Register a shutdown hook with the JVM runtime, closing this context * on JVM shutdown unless it has already been closed at that time. * &lt;p&gt;Delegates to &#123;@code doClose()&#125; for the actual closing procedure. * @see Runtime#addShutdownHook * @see #close() * @see #doClose() */@Overridepublic void registerShutdownHook() &#123; if (this.shutdownHook == null) &#123; // No shutdown hook registered yet. this.shutdownHook = new Thread() &#123; @Override public void run() &#123; synchronized (startupShutdownMonitor) &#123; doClose(); &#125; &#125; &#125;; // 注册jvm钩子 Runtime.getRuntime().addShutdownHook(this.shutdownHook); &#125;&#125; spring的shutdownhook具体任务如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Actually performs context closing: publishes a ContextClosedEvent and * destroys the singletons in the bean factory of this application context. * &lt;p&gt;Called by both &#123;@code close()&#125; and a JVM shutdown hook, if any. * @see org.springframework.context.event.ContextClosedEvent * @see #destroyBeans() * @see #close() * @see #registerShutdownHook() */protected void doClose() &#123; if (this.active.get() &amp;&amp; this.closed.compareAndSet(false, true)) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Closing \" + this); &#125; LiveBeansView.unregisterApplicationContext(this); try &#123; // Publish shutdown event // 注意容器关系事件的发布 publishEvent(new ContextClosedEvent(this)); &#125; catch (Throwable ex) &#123; logger.warn(\"Exception thrown from ApplicationListener handling ContextClosedEvent\", ex); &#125; // Stop all Lifecycle beans, to avoid delays during individual destruction. if (this.lifecycleProcessor != null) &#123; try &#123; this.lifecycleProcessor.onClose(); &#125; catch (Throwable ex) &#123; logger.warn(\"Exception thrown from LifecycleProcessor on context close\", ex); &#125; &#125; // Destroy all cached singletons in the context's BeanFactory. destroyBeans(); // Close the state of this context itself. closeBeanFactory(); // Let subclasses do some final clean-up if they wish... onClose(); this.active.set(false); &#125; &#125; dubbo2.6.x支持使用spring构建dubbo应用时，能够安全使用优雅停机。由于dubbo注册了jvm停止的钩子， spring可能 也注册了jvm停机的钩子，这种情况下两个并发执行的线程可能引用已经销毁的资源，导致优雅停机失效。比如，dubbo正在执行的任务需要引用spring中的bean，但此时spring钩子已经关闭spring上下文，导致访问spring资源都会报错。因此对于这种情况，dubbo在2.6.3中新增ShutdownHookListener 类用来解决并发问题，该类实现了ApplicationListener接口，当进程退出时jvm钩子会被触发，此时spring和dubbo注册的jvm钩子都会被回调，spring注册的jvm钩子程序中spring发出容器关闭事件，ShutdownHookListener接收到关闭事件后执行dubbo的jvm钩子程序进行资源的释放，这样就避免使用无效spring bean的问题，从而完成优雅停机。 ShutdownHookListener 1234567891011private static class ShutdownHookListener implements ApplicationListener &#123; @Override public void onApplicationEvent(ApplicationEvent event) &#123; if (event instanceof ContextClosedEvent) &#123; // 使用spring框架时也不应该删除dubbo shutdown hook，因为spring可能没有注册ContextClosed 事件 DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook(); shutdownHook.destroyAll(); &#125; &#125;&#125; AbstractConfig中依然保留JVM停止钩子 12345678910111213141516171819202122232425public abstract class AbstractConfig implements Serializable &#123; // 省略无关代码... static &#123; legacyProperties.put(\"dubbo.protocol.name\", \"dubbo.service.protocol\"); legacyProperties.put(\"dubbo.protocol.host\", \"dubbo.service.server.host\"); legacyProperties.put(\"dubbo.protocol.port\", \"dubbo.service.server.port\"); legacyProperties.put(\"dubbo.protocol.threads\", \"dubbo.service.max.thread.pool.size\"); legacyProperties.put(\"dubbo.consumer.timeout\", \"dubbo.service.invoke.timeout\"); legacyProperties.put(\"dubbo.consumer.retries\", \"dubbo.service.max.retry.providers\"); legacyProperties.put(\"dubbo.consumer.check\", \"dubbo.service.allow.no.provider\"); legacyProperties.put(\"dubbo.service.url\", \"dubbo.service.address\"); // this is only for compatibility /** * Dubbo 的优雅停机 ShutdownHook 在 AstractConfig 的静态代码块中，这保证了ShutdownHook能够给被初始化。 * 说明： * 1 Dubbo 是 通过 JDK的ShutdownHook来完成优雅停机的 * 2 ShutdownHook本质上是一个线程，任务体在对应的run方法中 */ Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook()); &#125; &#125; DubboShutdownHook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class DubboShutdownHook extends Thread &#123; private static final Logger logger = LoggerFactory.getLogger(DubboShutdownHook.class); /** * ShutdownHook,类属性 */ private static final DubboShutdownHook dubboShutdownHook = new DubboShutdownHook(\"DubboShutdownHook\"); public static DubboShutdownHook getDubboShutdownHook() &#123; return dubboShutdownHook; &#125; /** * Has it already been destroyed or not? * &lt;p&gt; * 是否已经被销毁标识 */ private final AtomicBoolean destroyed; private DubboShutdownHook(String name) &#123; super(name); this.destroyed = new AtomicBoolean(false); &#125; /** * ShutdownHook的任务体 */ @Override public void run() &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Run shutdown hook now.\"); &#125; destroyAll(); &#125; /** * Destroy all the resources, including registries and protocols. * &lt;p&gt; * 销毁所有的资源，包括 Registry相关 和 Protocol相关 */ public void destroyAll() &#123; //如果已经销毁则忽略 if (!destroyed.compareAndSet(false, true)) &#123; return; &#125; // 销毁所有的 Registry,取消应用程序中的服务提供者和消费者的订阅与注册 AbstractRegistryFactory.destroyAll(); /** * 销毁所有的 Protocol * * 说明： * 这里的Protocol比较多，大体上可以分两类： * 1 和Registry相关的Protocol，RegistryProtocol关注服务的注册 * 2 具体协议，如 DubboProtocol、httpProtocol等,关注服务的暴露和引用 */ ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol.class); for (String protocolName : loader.getLoadedExtensions()) &#123; try &#123; Protocol protocol = loader.getLoadedExtension(protocolName); if (protocol != null) &#123; protocol.destroy(); &#125; &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125;&#125; DubboShutdownHook与protocol、registry的关系图 图解(以dubbo协议和zookeeper注册中心为例) Registry相关 AbstractRegistryFactory#destroyAll方法，遍历所有的Registry并调用Registry#destroy方法。然后清空Registry缓存集合。 AbstractRegistry 实现了公用的销毁逻辑：取消注册和订阅。服务提供者和消费者都会执行注册和订阅，因此都需要进行取消。 FailbackRegistry实现销毁公用的重试任务 ZookeeperRegistry销毁其对应的客户端连接 Protocol相关 AbstractProtocol#destroy方法，销毁协议对应的服务消费者拥有的Invoker， 销毁协议对应的服务提供者的所有Exporter。 DubboProtocol销毁所有通信 ExchangeClient 和 ExchangeServer 小结 dubbo2.6.3在spring环境中注册两个钩子的情况，ShutdownHookListener解决了并发执行问题 使用ShutdownHookListener也不能移除调dubbo注册的jvm钩子，因为不能保证应用中一定会注册spring的shutdown hook 2.7.x优雅停机从dubbo的2.6.3版本开始，解决了使用spring构建的dubbo可能发生优雅停机并发执行shutdown hook的问题。但是还是存在一个问题，那就是如果在spring环境下没有注册spring的jvm钩子，虽然没有大问题，但是还是有不完整的。dubbo2.7.x进行显示地注册spring的jvm钩子，并且移除dubbo的jvm钩子，解决了当前问题。 12345678910111213141516171819202122232425262728293031public class SpringExtensionFactory implements ExtensionFactory &#123; // 省略其它代码... private static final Set&lt;ApplicationContext&gt; CONTEXTS = new ConcurrentHashSet&lt;ApplicationContext&gt;(); private static final ApplicationListener SHUTDOWN_HOOK_LISTENER = new ShutdownHookListener(); public static void addApplicationContext(ApplicationContext context) &#123; CONTEXTS.add(context); if (context instanceof ConfigurableApplicationContext) &#123; // 显示注册spring的jvm钩子 ((ConfigurableApplicationContext) context).registerShutdownHook(); // 显示移除dubbo的jvm钩子 DubboShutdownHook.getDubboShutdownHook().unregister(); &#125; BeanFactoryUtils.addApplicationListener(context, SHUTDOWN_HOOK_LISTENER); &#125; private static class ShutdownHookListener implements ApplicationListener &#123; @Override public void onApplicationEvent(ApplicationEvent event) &#123; if (event instanceof ContextClosedEvent) &#123; DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook(); shutdownHook.doDestroy(); &#125; &#125; &#125;&#125; 说明 dubbo2.7.x优雅停机的实现，解决了spring环境下两个钩子并发的问题，并且显示注册spring的jvm钩子。 总结优雅停机并不是java中的概念，也不是只有dubbo框架进行了扩展实现，springboot、docker等都有涉及到优雅停机。dubbo中的优雅停机是不断优化的，2.5.x中的存在一定的问题，2.6.x在一般场景下是没有问题的，2.7.x是对之前版本的完善和优化。如果 ShutdownHook 不能生效，可以在需要的时机自行调用DubboShutdownHook.destroyAll()。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"JDK","slug":"JDK","permalink":"https://gentryhuang.com/tags/JDK/"},{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Spring","slug":"Spring","permalink":"https://gentryhuang.com/tags/Spring/"}]},{"title":"Dubbo源码分析 - Zookeeper客户端","slug":"rpc/注册中心之Zookeeper客户端","date":"2020-04-19T16:00:00.000Z","updated":"2020-09-09T15:10:14.787Z","comments":false,"path":"posts/817d6a19/","link":"","permalink":"https://gentryhuang.com/posts/817d6a19/","excerpt":"","text":"前言在 Dubbo源码分析 - Zookeeper注册中心 中介绍的是 Dubbo 的 Zookeeper 注册中心实现，但是并没有涉及到 Zookeeper 客户端的操作，下面我们介绍 Zookeeper 在 Dubbo 框架中具体实现。 概述 上图的 UML 描述了 Dubbo 封装的 Zookeeper 注册中心和 Zookeeper 相关实现的关系。 Dubbo 对 Zookeeper 客户端的封装是在 dubbo-remoting-zookeeper 模块中，该模块对 Zookeeper 客户端接口进行了抽象。 目前支持 ZkClient 和 Curator 两种 Zookeeper 客户端实现： Curator 实现 1&lt;dubbo:registry ... client=\"curator\" /&gt; ZkClient 实现 1&lt;dubbo:registry ... client=\"zkclient\" /&gt; 注意: 在2.7.x的版本中已经移除了zkclient的实现,如果要使用zkclient客户端,需要显示配置。下面分析上图的 UML 中涉及的接口和实现类。 ZookeeperTransporter12345678910111213@SPI(\"curator\")public interface ZookeeperTransporter &#123; /** * 连接创建 ZookeeperClient 对象 * * @param url 注册中心地址 * @return ZookeeperClient 对象 */ @Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;) ZookeeperClient connect(URL url);&#125; 该接口是 Dubbo 的扩展点，是 Zookeeper 客户端工厂，默认是使用 CuratorZookeeperTransporter 创建 ZookeeperClient ，后面会详细分析 ZookeeperClient 继承体系。 StateListener123456789101112131415161718192021public interface StateListener &#123; /** * 已断开 */ int DISCONNECTED = 0; /** * 已连接 */ int CONNECTED = 1; /** * 已重连 */ int RECONNECTED = 2; /** * 状态变更回调方法 * * @param connected 状态 */ void stateChanged(int connected);&#125; 该接口不是真正意义上的监听器，它的实现是一个匿名内部类，在 ZookeeperRegistry 的构造方法中，作为 ZookeeperClient 的状态变化（会话）的回调，具体调用入口是 AbstractZookeeperClient#stateChanged(int) 。 12345678910111213141516171819202122public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) &#123; // 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter，由SPI确定具体的实例。创建好Zookeeper客户端，意味着注册中心的创建完成【Zookeeper服务端必需先启动，Dubbo应用作为Zookeeper的客户端进行连接，然后操作Zookeeper】 zkClient = zookeeperTransporter.connect(url); /** * 添加 StateListener 状态监听器，该监听器在重连时，调用恢复方法 recover()，重新发起注册和订阅【将之前已经注册和订阅的数据进行重试】 * 注意： * StateListener 不是真正意义上的监听器，这里就是创建了一个匿名对象，其中的 #stateChanged 方法触发需要主动调用该匿名对象的该方法 &#123;@link AbstractZookeeperClient#stateChanged(int)&#125; */ zkClient.addStateListener(new StateListener() &#123; @Override public void stateChanged(int state) &#123; if (state == RECONNECTED) &#123; try &#123; recover(); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; &#125; &#125;); &#125; ChildListener1234567891011public interface ChildListener &#123; /** * 子节点发生变化的回调 * * @param path 节点 * @param children 最新的子节点列表 */ void childChanged(String path, List&lt;String&gt; children);&#125; 该接口只是一个普通的接口，具体实现是一个匿名内部类，入口在 ZookeeperRegistry 实现类的 doSubscribe 方法中，该接口的对象最终会用于 Zookeeper 客户端的某个节点下子节点变化的回调方法中，下面我们再分析两种客户端的不同实现。 ZookeeperClient123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public interface ZookeeperClient &#123; /** * 创建节点 * * @param path 节点路径 * @param ephemeral 是否临时节点 */ void create(String path, boolean ephemeral); /** * 删除节点 * * @param path 节点路径 */ void delete(String path); /** * 获取子节点路径 * @param path * @return */ List&lt;String&gt; getChildren(String path); /** * 添加 ChildListener * * @param path 节点路径 * @param listener 监听器 * @return 子节点列表 */ List&lt;String&gt; addChildListener(String path, ChildListener listener); /** * 移除 ChildListener * * @param path 节点路径 * @param listener 监听器 */ void removeChildListener(String path, ChildListener listener); /** * 添加 StateListener * * @param listener 监听器 */ void addStateListener(StateListener listener); /** * 移除 StateListener * * @param listener 监听器 */ void removeStateListener(StateListener listener); /** * @return 是否连接 */ boolean isConnected(); /** * 关闭 */ void close(); /** * @return 获得注册中心 URL */ URL getUrl();&#125; ZookeeperClient 接口是对 Zookeeper 客户端接口的抽象，定义了一系列的操作方法，它的具体子类中封装了 Zookeeper 的客户端对象。 AbstractZookeeperClientZookeeperClient 接口的抽象类，主要实现了通用的逻辑，如，创建节点 12345678910111213141516171819202122232425262728293031323334353637383940/** * 实现 ZookeeperClient 接口，Zookeeper 客户端抽象类，实现通用的逻辑。 * * @param &lt;TargetChildListener&gt; 泛型 */public abstract class AbstractZookeeperClient&lt;TargetChildListener&gt; implements ZookeeperClient &#123; protected static final Logger logger = LoggerFactory.getLogger(AbstractZookeeperClient.class); /** * 注册中心 URL */ private final URL url; /** * StateListener 状态监听器集合 */ private final Set&lt;StateListener&gt; stateListeners = new CopyOnWriteArraySet&lt;StateListener&gt;(); /** * ChildListener 集合 * &lt;p&gt; * key1：节点路径 * key2：ChildListener 对象 * value ：监听器具体对象，不同 Zookeeper 客户端，实现会不同。CuratorZookeeperClient的是CuratorWatcher;ZkclientZookeeperClient 的是 IZkChildListener */ private final ConcurrentMap&lt;String, ConcurrentMap&lt;ChildListener, TargetChildListener&gt;&gt; childListeners = new ConcurrentHashMap&lt;String, ConcurrentMap&lt;ChildListener, TargetChildListener&gt;&gt;(); /** * 是否关闭 */ private volatile boolean closed = false; public AbstractZookeeperClient(URL url) &#123; this.url = url; &#125; // $&#123;省略其他代码&#125;&#125; 该抽象类中的属性主要四个，其中 stateListeners 属性是当 Zookeeper的状态变化时要通知的对象，childListeners 属性比较关键，是节点路径到其子节点监听器的映射。 create 创建节点1234567891011121314151617181920212223242526272829public abstract class AbstractZookeeperClient&lt;TargetChildListener&gt; implements ZookeeperClient &#123; // $&#123;省略其他代码&#125; @Override public void create(String path, boolean ephemeral) &#123; if (!ephemeral) &#123; // 如果要创建的节点类型非临时节点，那么这里要检测节点是否存在。临时节点有序号，不需要考虑覆盖问题 if (checkExists(path)) &#123; return; &#125; &#125; int i = path.lastIndexOf('/'); if (i &gt; 0) &#123; // 递归创建上一级路径 create(path.substring(0, i), false); &#125; // 根据 ephemeral 的值创建临时或持久节点 if (ephemeral) &#123; createEphemeral(path); &#125; else &#123; createPersistent(path); &#125; &#125; // $&#123;省略其他代码&#125;&#125; StateListener 操作方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546public abstract class AbstractZookeeperClient&lt;TargetChildListener&gt; implements ZookeeperClient &#123; // $&#123;省略其他代码&#125; /** * 加入 StateListener 到缓存 * * @param listener StateListener */ @Override public void addStateListener(StateListener listener) &#123; stateListeners.add(listener); &#125; /** * 移除缓存中的 StateListener * * @param listener 监听器 */ @Override public void removeStateListener(StateListener listener) &#123; stateListeners.remove(listener); &#125; /** * 获取缓存中的 StateListener * @return */ public Set&lt;StateListener&gt; getSessionListeners() &#123; return stateListeners; &#125; /** * 遍历StateListener 数组，回调 * * @param state 状态 */ protected void stateChanged(int state) &#123; for (StateListener sessionListener : getSessionListeners()) &#123; sessionListener.stateChanged(state); &#125; &#125; // $&#123;省略其他代码&#125;&#125; StateListener 操作方法很简单，需要注意的是 addStateListener 和 stateChanged 方法，前者是在 ZookeeperRegistry 构造方法中被调用，前文已经说明。后者是当 Zookeeper 客户端的会话变化时会主动调用，下文会说明。 addChildListener12345678910111213141516171819202122232425262728293031323334353637383940public abstract class AbstractZookeeperClient&lt;TargetChildListener&gt; implements ZookeeperClient &#123; // $&#123;省略其他代码&#125; /** * * @param path 订阅url 映射的目录，如 .../providers * @param listener 订阅url 映射的目录下子节点变化时执行回调的对象 */ @Override public List&lt;String&gt; addChildListener(String path, final ChildListener listener) &#123; // 1 获取/创建：ConcurrentMap&lt;categorypath, ConcurrentMap&lt;ZookeeperRegistry的内部类ChildListener实例, TargetChildListener&gt;&gt; childListeners，这里主要是创建TargetChildListener ConcurrentMap&lt;ChildListener, TargetChildListener&gt; listeners = childListeners.get(path); if (listeners == null) &#123; childListeners.putIfAbsent(path, new ConcurrentHashMap&lt;ChildListener, TargetChildListener&gt;()); listeners = childListeners.get(path); &#125; // 获得是否已经有该监听器 TargetChildListener targetListener = listeners.get(listener); // zk监听器对象不存在，进行创建 if (targetListener == null) &#123; /** * 1 创建一个监听path下子节点的watcher【CuratorZookeeperClient实现】或 IZkChildListener 【ZkclientZookeeperClient实现】 * 2 当path下有子节点变化时，调用listener（即传入的ZookeeperRegistry的内部类ChildListener实例的childChanged(String parentPath, List&lt;String&gt; currentChilds)方法） */ listeners.putIfAbsent(listener, createTargetChildListener(path, listener)); targetListener = listeners.get(listener); &#125; // 向 Zookeeper ，真正发起订阅，即为 path添加TargetChildListener监听器实例 return addTargetChildListener(path, targetListener); &#125; // $&#123;省略其他代码&#125;&#125; 该方法的核心就是为订阅 URL 映射的节点绑定一个子节点监听器，子节点发生变化时会被子节点监听器捕捉到，然后将变化的数据信息通过 ChildListener 匿名对象的方法传递出去，下面会结合具体的 Zookeeper 客户端说明。 removeChildListener12345678910111213141516171819public abstract class AbstractZookeeperClient&lt;TargetChildListener&gt; implements ZookeeperClient &#123; // $&#123;省略其他代码&#125; @Override public void removeChildListener(String path, ChildListener listener) &#123; ConcurrentMap&lt;ChildListener, TargetChildListener&gt; listeners = childListeners.get(path); if (listeners != null) &#123; TargetChildListener targetListener = listeners.remove(listener); if (targetListener != null) &#123; // 向 Zookeeper ，真正发起取消订阅 removeTargetChildListener(path, targetListener); &#125; &#125; &#125; // $&#123;省略其他代码&#125;&#125; 该方法用于解除 path 目录的子节点变化监听器。 目录的子节点变化监听器操作123456789101112131415161718192021222324252627282930313233public abstract class AbstractZookeeperClient&lt;TargetChildListener&gt; implements ZookeeperClient &#123; // $&#123;省略其他代码&#125; /** * 抽象方法，创建真正的 ChildListener 对象。因为，每个 Zookeeper 的库，实现不同。 * * @param path * @param listener * @return */ protected abstract TargetChildListener createTargetChildListener(String path, ChildListener listener); /** * 向 Zookeeper ，真正发起订阅 * * @param path * @param listener * @return */ protected abstract List&lt;String&gt; addTargetChildListener(String path, TargetChildListener listener); /** * 向 Zookeeper ，真正发起取消订阅 * * @param path * @param listener */ protected abstract void removeTargetChildListener(String path, TargetChildListener listener); // $&#123;省略其他代码&#125;&#125; 上面三个方法是用来对 path 目录下的子节点的监听器进行操作的，具体逻辑交给子类实现。下面我们详细分析 AbstractZookeeperClient 的两个具体实现类。 CuratorZookeeperClient属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class CuratorZookeeperClient extends AbstractZookeeperClient&lt;CuratorWatcher&gt; &#123; /** * Zookeeper 的 Curator 客户端对象 */ private final CuratorFramework client; /** * CuratorZookeeperClient 构造方法主要用于创建和启动 CuratorFramework 实例 * * @param url */ public CuratorZookeeperClient(URL url) &#123; super(url); try &#123; // 创建 CuratorFramework 构造器 CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder() // 连接地址 .connectString(url.getBackupAddress()) // 重试策略: 重试次数：1，每次重试间隔： 1000 ms .retryPolicy(new RetryNTimes(1, 1000)) // 连接超时时间 .connectionTimeoutMs(5000); String authority = url.getAuthority(); if (authority != null &amp;&amp; authority.length() &gt; 0) &#123; builder = builder.authorization(\"digest\", authority.getBytes()); &#125; // 构建 CuratorFramework 实例 client = builder.build(); // 添加连接监听器。在连接状态发生变化时，调用#stateChange(state)方法，进行StateListener的回调 client.getConnectionStateListenable().addListener(new ConnectionStateListener() &#123; /** * 在连接状态发生变化时，调用 #stateChange(state) 方法，进行 StateListener 的回调。 * @param client * @param state */ @Override public void stateChanged(CuratorFramework client, ConnectionState state) &#123; if (state == ConnectionState.LOST) &#123; CuratorZookeeperClient.this.stateChanged(StateListener.DISCONNECTED); &#125; else if (state == ConnectionState.CONNECTED) &#123; CuratorZookeeperClient.this.stateChanged(StateListener.CONNECTED); &#125; else if (state == ConnectionState.RECONNECTED) &#123; CuratorZookeeperClient.this.stateChanged(StateListener.RECONNECTED); &#125; &#125; &#125;); // 启动客户端 (当连接不上zk服务时，默认将一直重试) client.start(); &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; // $&#123;省略其他代码&#125;&#125; 从 CuratorZookeeperClient 的属性中，可以得到上文中的一个答案，stateChanged 方法调用的入口，CuratorZookeeperClient 构造方法执行完毕，Zookeeper 的 Curator 客户端连接创建完毕。 操作节点方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class CuratorZookeeperClient extends AbstractZookeeperClient&lt;CuratorWatcher&gt; &#123; // $&#123;省略其他代码&#125; /** * 创建 path 持久节点 * * @param path */ @Override public void createPersistent(String path) &#123; try &#123; client.create().forPath(path); &#125; catch (NodeExistsException e) &#123; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; /** * 创建 path 临时节点 * * @param path */ @Override public void createEphemeral(String path) &#123; try &#123; client.create().withMode(CreateMode.EPHEMERAL).forPath(path); &#125; catch (NodeExistsException e) &#123; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; /** * 删除 path 节点 * * @param path 节点路径 */ @Override public void delete(String path) &#123; try &#123; client.delete().forPath(path); &#125; catch (NoNodeException e) &#123; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; /** * 获取 path 节点下的子节点列表 * * @param path * @return */ @Override public List&lt;String&gt; getChildren(String path) &#123; try &#123; return client.getChildren().forPath(path); &#125; catch (NoNodeException e) &#123; return null; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; /** * 检查 path 节点是否存在 * * @param path * @return */ @Override public boolean checkExists(String path) &#123; try &#123; if (client.checkExists().forPath(path) != null) &#123; return true; &#125; &#125; catch (Exception e) &#123; &#125; return false; &#125; /** * 连接是否已经关闭 * * @return */ @Override public boolean isConnected() &#123; return client.getZookeeperClient().isConnected(); &#125; /** * 关闭连接 */ @Override public void doClose() &#123; client.close(); &#125; // $&#123;省略其他代码&#125;&#125; CuratorZookeeperClient 中的操作节点的方法很简单，直接调用 Curator 的 API 即可。 子节点监听器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class CuratorZookeeperClient extends AbstractZookeeperClient&lt;CuratorWatcher&gt; &#123; // $&#123;省略其他代码&#125; /** * 创建一个监听path子节点的watcher 注意：这里只是创建一个CuratorWatcher监听器，并没有对节点进行绑定 * * @param path * @param listener * @return */ @Override public CuratorWatcher createTargetChildListener(String path, ChildListener listener) &#123; return new CuratorWatcherImpl(listener); &#125; /** * 为path节点绑定CuratorWatcher监听器，并返回path的子路径列表 * * @param path * @param listener * @return */ @Override public List&lt;String&gt; addTargetChildListener(String path, CuratorWatcher listener) &#123; try &#123; return client.getChildren().usingWatcher(listener).forPath(path); &#125; catch (NoNodeException e) &#123; return null; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; /** * 移除监听器 * * @param path * @param listener */ @Override public void removeTargetChildListener(String path, CuratorWatcher listener) &#123; ((CuratorWatcherImpl) listener).unwatch(); &#125; /** * 实现CuratorWatcher接口，实现监听器功能 */ private class CuratorWatcherImpl implements CuratorWatcher &#123; /** * ChildListener 匿名对象 */ private volatile ChildListener listener; public CuratorWatcherImpl(ChildListener listener) &#123; this.listener = listener; &#125; public void unwatch() &#123; this.listener = null; &#125; /** * 1 当path节点下的子节点发生变化的时候，会首先调用TargetChildListener的process(WatchedEvent event)方法， * 2 在该方法中又会调用ChildListener实例的childChanged(String parentPath, List&lt;String&gt; currentChilds)方法 * * @param event * @throws Exception */ @Override public void process(WatchedEvent event) throws Exception &#123; if (listener != null) &#123; String path = event.getPath() == null ? \"\" : event.getPath(); // 主动调用ChildListener 匿名对象的方法 listener.childChanged(path, // if path is null, curator using watcher will throw NullPointerException. // if client connect or disconnect to server, zookeeper will queue // watched event(Watcher.Event.EventType.None, .., path = null). StringUtils.isNotEmpty(path) ? client.getChildren().usingWatcher(this).forPath(path) // 重新发起连接，并传入最新的子节点列表 : Collections.&lt;String&gt;emptyList()); &#125; &#125; &#125; // $&#123;省略其他代码&#125;&#125; 子节点监听器，核心是实现 CuratorWatcher 接口，实现监听器功能，当监听的节点下的子节点发生变化时，会在监听器的回调方法中主动调用 ChildListener 匿名对象的 childChanged 方法，这是 Dubbo 中订阅的核心点。 ZkclientZookeeperClientZkclientZookeeperClient 并没有直接封装 ZkClient 对象，而是通过 ZkClientWrapper 封装了 ZkClient 对象，我们先来分析 ZkClientWrapper。 ZkClientWrapper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177public class ZkClientWrapper &#123; Logger logger = LoggerFactory.getLogger(ZkClientWrapper.class); /** * 超时时间 */ private long timeout; /** * Zookeeper 的 ZkClient 客户端 */ private ZkClient client; /** * 状态 */ private volatile KeeperState state; /** * FutureTask */ private ListenableFutureTask&lt;ZkClient&gt; listenableFutureTask; /** * 是否开始 */ private volatile boolean started = false; /** * @param serverAddr Zookeeper 服务端地址 * @param timeout 超时时间 */ public ZkClientWrapper(final String serverAddr, long timeout) &#123; this.timeout = timeout; listenableFutureTask = ListenableFutureTask.create(new Callable&lt;ZkClient&gt;() &#123; /** * 通过回调创建 Zookeeper 的 ZkClient 客户端 * @return * @throws Exception */ @Override public ZkClient call() throws Exception &#123; return new ZkClient(serverAddr, Integer.MAX_VALUE); &#125; &#125;); &#125; /** * 创建Z ookeeper 的 ZkClient 客户端 */ public void start() &#123; if (!started) &#123; Thread connectThread = new Thread(listenableFutureTask); connectThread.setName(\"DubboZkclientConnector\"); connectThread.setDaemon(true); connectThread.start(); try &#123; client = listenableFutureTask.get(timeout, TimeUnit.MILLISECONDS); &#125; catch (Throwable t) &#123; logger.error(\"Timeout! zookeeper server can not be connected in : \" + timeout + \"ms!\", t); &#125; started = true; &#125; else &#123; logger.warn(\"Zkclient has already been started!\"); &#125; &#125; /** * 设置客户端监听器 * * @param listener */ public void addListener(final IZkStateListener listener) &#123; listenableFutureTask.addListener(new Runnable() &#123; @Override public void run() &#123; try &#123; client = listenableFutureTask.get(); client.subscribeStateChanges(listener); &#125; catch (InterruptedException e) &#123; logger.warn(Thread.currentThread().getName() + \" was interrupted unexpectedly, which may cause unpredictable exception!\"); &#125; catch (ExecutionException e) &#123; logger.error(\"Got an exception when trying to create zkclient instance, can not connect to zookeeper server, please check!\", e); &#125; &#125; &#125;); &#125; /** * ZkClient 是否处理连接状态 * * @return */ public boolean isConnected() &#123; return client != null &amp;&amp; state == KeeperState.SyncConnected; &#125; /** * 使用 ZkClient AIP 创建持久节点 * * @param path */ public void createPersistent(String path) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); client.createPersistent(path, true); &#125; /** * 使用 ZkClient AIP 创建临时节点 * * @param path */ public void createEphemeral(String path) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); client.createEphemeral(path); &#125; /** * 使用 ZkClient AIP 删除节点 * * @param path */ public void delete(String path) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); client.delete(path); &#125; /** * 使用 ZkClient AIP 获取 path 节点下的子节点列表 * * @param path * @return */ public List&lt;String&gt; getChildren(String path) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); return client.getChildren(path); &#125; /** * 使用 ZkClient AIP 判断是否存在 path 节点 * * @param path * @return */ public boolean exists(String path) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); return client.exists(path); &#125; /** * 断开 Zookeeper 连接 */ public void close() &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); client.close(); &#125; /** * 为 path 节点绑定其子节点的监听器，用于监听 path 节点下子节点的变化 * * @param path * @param listener * @return */ public List&lt;String&gt; subscribeChildChanges(String path, final IZkChildListener listener) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); return client.subscribeChildChanges(path, listener); &#125; /** * 删除 path 节点的子节点监听器 * * @param path * @param listener */ public void unsubscribeChildChanges(String path, IZkChildListener listener) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); client.unsubscribeChildChanges(path, listener); &#125;&#125; ZkClientWrapper 用来创建 Zookeeper 的 ZkClient 客户端，并调用 ZkClient API 操作节点以及绑定监听器，代码已经详细注释。下面我们继续看 ZkclientZookeeperClient 实现类。 属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ZkclientZookeeperClient extends AbstractZookeeperClient&lt;IZkChildListener&gt; &#123; /** * 封装了 Zookeeper 的 ZkClient 对象 */ private final ZkClientWrapper client; /** * 状态对象 */ private volatile KeeperState state = KeeperState.SyncConnected; /** * ZkclientZookeeperClient 构造方法主要用于创建和启动 ZkClient 实例 * * @param url */ public ZkclientZookeeperClient(URL url) &#123; super(url); // 创建 ZkClientWrapper 【包装了ZkClient,实现监听】 client = new ZkClientWrapper(url.getBackupAddress(), 30000); // 添加监听器到 ZkClient 对象 client.addListener(new IZkStateListener() &#123; /** * 处理状态变化 * @param state * @throws Exception */ @Override public void handleStateChanged(KeeperState state) throws Exception &#123; ZkclientZookeeperClient.this.state = state; /** * 状态变更进行回调 &#123;@link StateListener#stateChanged(int)&#125; */ if (state == KeeperState.Disconnected) &#123; stateChanged(StateListener.DISCONNECTED); &#125; else if (state == KeeperState.SyncConnected) &#123; stateChanged(StateListener.CONNECTED); &#125; &#125; /** * 处理新会话 （处理失败重连），最终会回调&#123;@link StateListener#stateChanged(int)&#125; * @throws Exception */ @Override public void handleNewSession() throws Exception &#123; stateChanged(StateListener.RECONNECTED); &#125; &#125;); // 创建客户端 client.start(); &#125; // $&#123;省略其他代码&#125;&#125; client 属性对应的 ZkClientWrapper 中封装了 ZkClient 客户端对象，构造方法主要做了两件事，创建 ZkClient 并为其绑定状态监听器。 操作节点方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ZkclientZookeeperClient extends AbstractZookeeperClient&lt;IZkChildListener&gt; &#123; // $&#123;省略其他代码&#125; /** * 调用 ZkClientWrapper 的 createPersistent 方法，以下同理 * * @param path */ @Override public void createPersistent(String path) &#123; try &#123; client.createPersistent(path); &#125; catch (ZkNodeExistsException e) &#123; &#125; &#125; @Override public void createEphemeral(String path) &#123; try &#123; client.createEphemeral(path); &#125; catch (ZkNodeExistsException e) &#123; &#125; &#125; @Override public void delete(String path) &#123; try &#123; client.delete(path); &#125; catch (ZkNoNodeException e) &#123; &#125; &#125; @Override public List&lt;String&gt; getChildren(String path) &#123; try &#123; return client.getChildren(path); &#125; catch (ZkNoNodeException e) &#123; return null; &#125; &#125; @Override public boolean checkExists(String path) &#123; try &#123; return client.exists(path); &#125; catch (Throwable t) &#123; &#125; return false; &#125; @Override public boolean isConnected() &#123; return state == KeeperState.SyncConnected; &#125; @Override public void doClose() &#123; client.close(); &#125; // $&#123;省略其他代码&#125;&#125; 子节点监听器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ZkclientZookeeperClient extends AbstractZookeeperClient&lt;IZkChildListener&gt; &#123; // $&#123;省略其他代码&#125; /** * 创建节点监听器 * * @param path * @param listener * @return */ @Override public IZkChildListener createTargetChildListener(String path, final ChildListener listener) &#123; return new IZkChildListener() &#123; /** * 监听的子节点发生变化会回调该方法，方法主动调用 ChildListener的匿名对象的方法 * @param parentPath 父节点 * @param currentChilds 子节点列表 * @throws Exception */ @Override public void handleChildChange(String parentPath, List&lt;String&gt; currentChilds) throws Exception &#123; listener.childChanged(parentPath, currentChilds); &#125; &#125;; &#125; /** * 为 path 节点绑定子节点监听器 * * @param path * @param listener path的子节点监听器 * @return */ @Override public List&lt;String&gt; addTargetChildListener(String path, final IZkChildListener listener) &#123; return client.subscribeChildChanges(path, listener); &#125; /** * 移除 path 节点绑定的子节点监听器 * * @param path * @param listener path的子节点监听器 */ @Override public void removeTargetChildListener(String path, IZkChildListener listener) &#123; client.unsubscribeChildChanges(path, listener); &#125; // $&#123;省略其他代码&#125;&#125; 实现上和 Curator 客户端有所差别，但本质上是相同的。 小结Dubbo 中的 Zookeeper 客户端主要两部分操作，节点的操作和节点监听器的操作，节点的操作主要是注册服务的元数据信息，节点监听器的操作主要是用于订阅通知，订阅通知依赖服务节点的元数据变化信息，这正是监听器来完成的。","categories":[],"tags":[]},{"title":"Dubbo源码分析 - Zookeeper注册中心","slug":"rpc/注册中心之Zookeeper","date":"2020-04-16T16:00:00.000Z","updated":"2020-09-09T15:01:57.349Z","comments":false,"path":"posts/f70c2f2e/","link":"","permalink":"https://gentryhuang.com/posts/f70c2f2e/","excerpt":"","text":"前言注册中心总览 中介绍了 Dubbo 的注册中心抽象层，包括注册中心及其工厂。本篇文章将介绍 Dubbo 的 Zookeeper 注册中心及其工厂。 UML 图中 ZookeeperRegistryFactory 中有个 ZookeeperTransporter 属性，该属性就是创建 Zookeeper 客户端的关键对象，下一篇文章会详细介绍 Dubbo 对 Zookeeper 客户端的封装。 Dubbo 中的 ZookeeperZookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。下图是 Dubbo 使用 Zookeeper 作为注册中心的元数据信息： 节点路径说明 Root 层：Zookeeper的根目录，默认是 dubbo ，也可以进行设置 Service 层：服务接口的全路径名 Type 层：目录，对于 Dubbo 而言就是分类，目前 Dubbo 有 4 个分类，服务提供者列表（providers）、服务消费者列表（consumers）、路由规则列表（routers）和 配置规则列表(configurators) URL 层：可以是服务提供者 URL、服务消费者 URL、路由规则 URL、以及配置规则 URL，具体哪类，看在哪个 Type 层下 流程简单说明： 服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址 服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址 监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址 注意，上面描述的并不是完整的流程，只是根据图进行简单说明，比如，服务提供者不仅写入了自己的 URL 地址，还订阅了 configurators 目录下的 URL 地址，消费者除了订阅 providers 目录下的 URL 地址，还订阅了 routers 和 configurators 目录下的 URL 地址。 支持但不限于以下功能： 当提供者出现断电等异常停机时，注册中心能自动删除提供者信息 当注册中心重启时，能自动恢复注册数据，以及订阅请求 当会话过期时，能自动恢复注册数据，以及订阅请求 当设置 &lt;dubbo:registry check=”false” /&gt; 时，记录失败注册和订阅请求，后台定时重试 可通过 &lt;dubbo:registry username=”admin” password=”1234” /&gt; 设置 zookeeper 登录信息 可通过 &lt;dubbo:registry group=”dubbo” /&gt; 设置 zookeeper 的根节点，不配置将使用默认的根节点。 支持 * 号通配符 &lt;dubbo:reference group=”*” version=”*” /&gt;，可订阅服务的所有分组和所有版本的提供者 ZookeeperRegistryFactory实现 AbstractRegistryFactory 抽象类，ZookeeperRegistry 的工厂。 12345678910111213141516171819202122public class ZookeeperRegistryFactory extends AbstractRegistryFactory &#123; /** * zookeeperTransporter 由 SPI 在运行时注入，类型为 ZookeeperTransporter$Adaptive。 是Zookeeper的客户端工厂 */ private ZookeeperTransporter zookeeperTransporter; /** * 设置Zookeeper客户端 工厂，该方法通过Dubbo IOC 注入 * * @param zookeeperTransporter */ public void setZookeeperTransporter(ZookeeperTransporter zookeeperTransporter) &#123; this.zookeeperTransporter = zookeeperTransporter; &#125; @Override public Registry createRegistry(URL url) &#123; // 创建 ZookeeperRegistry return new ZookeeperRegistry(url, zookeeperTransporter); &#125;&#125; ZookeeperRegistryFactory 就是用来创建 ZookeeperRegistry 对象的，而 ZookeeperRegistry 对象需要依赖创建 Zookeeper 客户端的 ZookeeperTransporter 对象，该对象是通过 Dubbo IOC 注入的，详细可参考 Dubbo SPI 。 下面我们来看看 ZookeeperRegistry 的实现。 ZookeeperRegistry该类继承抽象类 FailbackRegistry ，具有重试功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * ZookeeperRegistry */public class ZookeeperRegistry extends FailbackRegistry &#123; private final static Logger logger = LoggerFactory.getLogger(ZookeeperRegistry.class); /** * Zookeeper 默认端口 */ private final static int DEFAULT_ZOOKEEPER_PORT = 2181; /** * Dubbo 元数据写入Zookeeper上的根节点，默认值是 dubbo */ private final static String DEFAULT_ROOT = \"dubbo\"; /** * Zookeeper 根节点 */ private final String root; /** * Service 接口全名集合。该属性适合用于监控中心，订阅整个Service层，因为Service层是动态的 */ private final Set&lt;String&gt; anyServices = new ConcurrentHashSet&lt;String&gt;(); /** * 监听器集合，建立NotifyListener和ChildListener的映射关系，k1为订阅URL,k2为监听器,value为ChildListener【真正起作用的对象】 */ private final ConcurrentMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt; zkListeners = new ConcurrentHashMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt;(); /** * Zookeeper 客户端 */ private final ZookeeperClient zkClient; public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) &#123; super(url); if (url.isAnyHost()) &#123; throw new IllegalStateException(\"registry address == null\"); &#125; // 获取组名，默认为 'dubbo'，url.parameters.group 参数值，即Zookeeper的根节点 String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT); if (!group.startsWith(Constants.PATH_SEPARATOR)) &#123; // 订正路径： group = \"/\" + group; group = Constants.PATH_SEPARATOR + group; &#125; // 确定根路径，以组名作为根路径 this.root = group; // 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter，由SPI确定具体的实例。创建好Zookeeper客户端，意味着注册中心的创建完成【Zookeeper服务端必需先启动，Dubbo应用作为Zookeeper的客户端进行连接，然后操作Zookeeper】 zkClient = zookeeperTransporter.connect(url); /** * 添加 StateListener 状态监听器，该监听器在重连时，调用恢复方法 recover()，重新发起注册和订阅【将之前已经注册和订阅的数据进行重试】 * 注意： * StateListener 不是真正意义上的监听器，这里就是创建了一个匿名对象，其中的 #stateChanged 方法触发需要主动调用该匿名对象的该方法 &#123;@link AbstractZookeeperClient#stateChanged(int)&#125; */ zkClient.addStateListener(new StateListener() &#123; @Override public void stateChanged(int state) &#123; if (state == RECONNECTED) &#123; try &#123; recover(); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; &#125; &#125;); &#125; // $&#123;省略其他代码&#125;&#125; doRegister 注册12345678910111213141516171819202122232425262728/** * ZookeeperRegistry */public class ZookeeperRegistry extends FailbackRegistry &#123; // $&#123;省略其他代码&#125; /** * 调用Zookeeper客户端创建服务节点 * * @param url */ @Override protected void doRegister(URL url) &#123; try &#123; /** * 1 通过 Zookeeper 客户端创建节点，节点路径由 toUrlPath 方法生成，路径格式如下: /$&#123;group&#125;/$&#123;serviceInterface&#125;/&#123;Type&#125;/$&#123;url&#125; * 比如： /dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F127.0.0.1...... * 2 url.parameters.dynamic ,是否动态数据。若为false，该数据为持久数据，当注册方退出时，数据仍然保存在注册中心 */ zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true)); &#125; catch (Throwable e) &#123; throw new RpcException(\"Failed to register \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; // $&#123;省略其他代码&#125; 该方法是实现了其父类 FailbackRegistry 的模版方法，使用 Zookeeper 客户端进行节点的创建。 doUnregister 取消注册12345678910111213141516171819202122/** * ZookeeperRegistry */public class ZookeeperRegistry extends FailbackRegistry &#123; // $&#123;省略其他代码&#125; /** * 取消注册，删除节点 * * @param url */ @Override protected void doUnregister(URL url) &#123; try &#123; zkClient.delete(toUrlPath(url)); &#125; catch (Throwable e) &#123; throw new RpcException(\"Failed to unregister \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; // $&#123;省略其他代码&#125; 该方法是实现了其父类 FailbackRegistry 的模版方法，使用 Zookeeper 客户端进行节点的删除。 doSubscribe 订阅订阅有两种情况，第一种是订阅根节点下的Service层数据，如监控中心订阅，第二种是订阅Service层的某个数据。 订阅所有Service层节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class ZookeeperRegistry extends FailbackRegistry &#123; // $&#123;省略其他代码&#125; @Override protected void doSubscribe(final URL url, final NotifyListener listener) &#123; try &#123; // ----------------- 订阅所有Service层的节点，例如监控中心的订阅 if (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; // service 层是 * // 根据节点 String root = toRootPath(); // 获的订阅的url 对应的监听器集合 ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url); // 不存在，进行创建 if (listeners == null) &#123; zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;()); listeners = zkListeners.get(url); &#125; ChildListener zkListener = listeners.get(listener); // 不存在ChildListener 对象，进行创建ChildListener对象 if (zkListener == null) &#123; listeners.putIfAbsent(listener, new ChildListener() &#123; /** * 节点变化回调，这里是根节点下的子节点有变化就回调 * @param parentPath 根节点 * @param currentChilds 根节点下的 service 层节点列表 */ @Override public void childChanged(String parentPath, List&lt;String&gt; currentChilds) &#123; // 遍历 service 层节点列表 for (String child : currentChilds) &#123; // 解码 child = URL.decode(child); // 新增Service接口，即新增服务，则发起该Service层的订阅，走另一个分支 if (!anyServices.contains(child)) &#123; anyServices.add(child); // 处理 service 订阅 subscribe(url.setPath(child).addParameters(Constants.INTERFACE_KEY, child, Constants.CHECK_KEY, String.valueOf(false)), listener); &#125; &#125; &#125; &#125;); zkListener = listeners.get(listener); &#125; // 创建Service 节点，该节点为持久化节点 zkClient.create(root, false); // 向Zookeeper service节点发起订阅 List&lt;String&gt; services = zkClient.addChildListener(root, zkListener); // 首次全量数据获取完成时，循环Service接口全名数组，发起该Service 层的订阅，调用subscribe(url,listener) if (services != null &amp;&amp; !services.isEmpty()) &#123; for (String service : services) &#123; service = URL.decode(service); anyServices.add(service); subscribe(url.setPath(service).addParameters(Constants.INTERFACE_KEY, service, Constants.CHECK_KEY, String.valueOf(false)), listener); &#125; &#125; &#125; else &#123; // $&#123;某个Service 层订阅&#125; &#125; // $&#123;省略其他代码&#125; &#125; 该分支是订阅根节点下的所有Service层数据，当Service层发生变更时，若变更的有新增Service接口，即新增服务，则调用subscribe(url,listener)方法发起订阅，走处理指定Service层节点的逻辑。 订阅指定Service层节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ZookeeperRegistry extends FailbackRegistry &#123; // $&#123;省略其他代码&#125; @Override protected void doSubscribe(final URL url, final NotifyListener listener) &#123; try &#123; //----------------- 订阅所有Service层的节点，例如监控中心的订阅 if (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; // service 层是 * // $&#123;所有Service 层订阅&#125; &#125; else &#123; /** * ConcurrentMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt; zkListeners * 1 根据url获取ConcurrentMap&lt;NotifyListener, ChildListener&gt;，没有就创建 * 2 根据listener从ConcurrentMap&lt;NotifyListener, ChildListener&gt;获取ChildListener，没有就创建 * 3 创建path持久化节点 * 4 创建path子节点监听器 */ // 子节点数据数组 List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); // 循环分类数组，其中，调用toCategoriesPath(url)方法，解析订阅url获得分类数组，如：/dubbo/com.alibaba.dubbo.demo.DemoService/configurators for (String path : toCategoriesPath(url)) &#123; // 获得分类路径（由订阅的url得到的） 对应的监听器映射 ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url); // 不存在，进行创建 if (listeners == null) &#123; zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;()); listeners = zkListeners.get(url); &#125; /** * 获得listener(NotifyListener)对应的ChildListener对象，没有就会创建。注意：ChildListener的childChanged方法实际上就是 * 当parentPath[即toCategoriesPath方法处理后的path]下的currentChilds发生变化时回调的方法，该方法内部又会回调NotifyListener#notify方法 */ ChildListener zkListener = listeners.get(listener); if (zkListener == null) &#123; listeners.putIfAbsent(listener, new ChildListener() &#123; @Override public void childChanged(String parentPath, List&lt;String&gt; currentChilds) &#123; // 变更时，调用 notity方法，回调 NotifyListener ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds)); &#125; &#125;); zkListener = listeners.get(listener); &#125; // 创建 Type 节点，该节点为持久节点，如： /dubbo/com.alibaba.dubbo.demo.DemoService/configurators zkClient.create(path, false); /** * 向Zookeeper path节点发起订阅， */ List&lt;String&gt; children = zkClient.addChildListener(path, zkListener); // 添加到urls 中 if (children != null) &#123; urls.addAll(toUrlsWithEmpty(url, path, children)); &#125; &#125; /** * 首次全量数据获取完成时，调用NofityListener#notify(url,listener,currentChilds)方法，回调NotifyListener的逻辑 */ notify(url, listener, urls); &#125; // $&#123;省略其他代码&#125; &#125; 订阅时涉及到的绑定监听器以及 ChildListener 匿名对象方法回调，会在下一章节 Zookeeper 客户端详细说明。订阅的核心是为指定的类目绑定监听器，该监听器用于监听类目下的子节点变化，发生变化则会调用 ChildListener 匿名对象方法，传递类目下变更后的子节点列表，有个这个新的子节点列表，就可以根据需要进行服务的重新暴露、服务目录重新生成等。 doUnsubscribe 取消订阅1234567891011121314151617181920212223242526272829303132/** * ZookeeperRegistry */public class ZookeeperRegistry extends FailbackRegistry &#123; // $&#123;省略其他代码&#125; /** * 真正取消订阅的逻辑，删除对应的监听器 * * @param url * @param listener */ @Override protected void doUnsubscribe(URL url, NotifyListener listener) &#123; ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url); if (listeners != null) &#123; ChildListener zkListener = listeners.get(listener); if (zkListener != null) &#123; if (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; String root = toRootPath(); zkClient.removeChildListener(root, zkListener); &#125; else &#123; for (String path : toCategoriesPath(url)) &#123; zkClient.removeChildListener(path, zkListener); &#125; &#125; &#125; &#125; &#125; // $&#123;省略其他代码&#125; 该方法是实现了其父类 FailbackRegistry 的模版方法，使用 Zookeeper 客户端删除订阅 URL 对应的监听器。 订阅时辅助方法获取Root层路径123456789101112131415161718192021/** * 获得根目录 * root * * @return */ private String toRootDir() &#123; if (root.equals(Constants.PATH_SEPARATOR)) &#123; return root; &#125; return root + Constants.PATH_SEPARATOR; &#125; /** * Root * * @return 根路径 */ private String toRootPath() &#123; return root; &#125; 获取Service层路径12345678910111213/** * 获得服务路径 ， Root + service * * @param url * @return */ private String toServicePath(URL url) &#123; String name = url.getServiceInterface(); if (Constants.ANY_VALUE.equals(name)) &#123; return toRootPath(); &#125; return toRootDir() + URL.encode(name); &#125; 获得分类路径123456789/** * 获得分类路径 如： 到 providers/consumers/routes/configurations 的路径 * * @param url URL * @return 分类路径 */private String toCategoryPath(URL url) &#123; return toServicePath(url) + Constants.PATH_SEPARATOR + url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);&#125; 获得URL路径12345678910111213/** * 获得URL 路径，即 要注册到注册中心上的完整路径 * &lt;p&gt; * Root + Service + Type + URL * &lt;p&gt; * 被 &#123;@link #doRegister(URL)&#125; 和 &#123;@link #doUnregister(URL)&#125; 调用 * * @param url URL * @return 路径 */ private String toUrlPath(URL url) &#123; return toCategoryPath(url) + Constants.PATH_SEPARATOR + URL.encode(url.toFullString()); &#125; URL匹配12345678910111213141516171819202122232425262728293031/** * 获得providers 中，和consumer 匹配的URL数组 * * @param consumer 订阅URL 如：provider://10.1.22.101:20880/com.alibaba.dubbo.demo.DemoService?key=value&amp;... * @param providers 订阅URL映射的路径的子路径集合 * @return 匹配的URL数组 */ private List&lt;URL&gt; toUrlsWithoutEmpty(URL consumer, List&lt;String&gt; providers) &#123; List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); if (providers != null &amp;&amp; !providers.isEmpty()) &#123; // 遍历子路径 for (String provider : providers) &#123; // 解码 provider = URL.decode(provider); // 是URL的路径才会处理 if (provider.contains(\"://\")) &#123; // 将字符串转为URL URL url = URL.valueOf(provider); // 子路径URL是否匹配订阅URL，以关键属性进行匹配，如服务接口名、类目、服务group、服务version等 if (UrlUtils.isMatch(consumer, url)) &#123; urls.add(url); &#125; &#125; &#125; &#125; return urls; &#125; 筛选URL12345678910111213141516171819202122232425/** * 1 从providers中筛选和consumer匹配的URL集合 * 2 如果URL集合不为空，直接返回这个集合 * 3 如果URL集合为空，首先从path中获取category的值，然后将consumer的协议换成empty并添加参数category=path中的category的值。 * 形式：'empty://' 的URL返回，通过这样的方式，可以处理类似服务提供者为空的情况 * * @param consumer 订阅URL 如：provider://10.1.22.101:20880/com.alibaba.dubbo.demo.DemoService?key=value&amp;... * @param path 订阅URL映射的路径 如：/dubbo/com.alibaba.dubbo.demo.DemoService/configurators * @param providers 订阅URL映射的路径的子路径集合 * @return */ private List&lt;URL&gt; toUrlsWithEmpty(URL consumer, String path, List&lt;String&gt; providers) &#123; // 从providers中筛选和consumer 匹配的URL数组 List&lt;URL&gt; urls = toUrlsWithoutEmpty(consumer, providers); // 如果不存在匹配的，则创建 'empty://' 的URL返回 if (urls == null || urls.isEmpty()) &#123; int i = path.lastIndexOf('/'); String category = i &lt; 0 ? path : path.substring(i + 1); URL empty = consumer.setProtocol(Constants.EMPTY_PROTOCOL).addParameter(Constants.CATEGORY_KEY, category); urls.add(empty); &#125; return urls; &#125; 获得Type层路径1234567891011121314151617181920212223242526272829303132333435/** * 获得分类路径数组 * Root + Service + Type * * @param url 订阅URL * @return 分类路径数组 */ private String[] toCategoriesPath(URL url) &#123; String[] categories; // 如果category的值为 * ，表示分别订阅：providers,consumers,routers,configurators if (Constants.ANY_VALUE.equals(url.getParameter(Constants.CATEGORY_KEY))) &#123; categories = new String[]&#123; Constants.PROVIDERS_CATEGORY, Constants.CONSUMERS_CATEGORY, Constants.ROUTERS_CATEGORY, Constants.CONFIGURATORS_CATEGORY &#125;; &#125; else &#123; // 如果category的值不为 * ，就取出 category的值，如果没有值，就把providers作为默认值。注意，当category的值不为空时会使用 ',' 分割category的值，为数组 categories = url.getParameter(Constants.CATEGORY_KEY, new String[]&#123;Constants.DEFAULT_CATEGORY&#125;); &#125; // 获得分类路径数组 String[] paths = new String[categories.length]; for (int i = 0; i &lt; categories.length; i++) &#123; // 构建分类路径 paths[i] = toServicePath(url) + Constants.PATH_SEPARATOR + categories[i]; &#125; return paths; &#125; 销毁方法12345678910111213141516171819/** * ZookeeperRegistry */public class ZookeeperRegistry extends FailbackRegistry &#123; // $&#123;省略其他代码&#125; @Override public void destroy() &#123; super.destroy(); try &#123; // 关闭 Zookeeper 客户端连接 zkClient.close(); &#125; catch (Exception e) &#123; logger.warn(\"Failed to close zookeeper client \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; // $&#123;省略其他代码&#125; 重写了父类 FailbackRegistry 的销毁方法，使用 Zookeeper 客户端关闭会话，该方法会先调用父类的销毁方法。 小结本篇文章主要介绍了 Dubbo 封装的 ZookeeperRegistry，该注册中心类将具体操作任务交给内部封装的 Zookeeper 客户端去完成，自己本身只是处理 Zookeeper 客户端操作前的逻辑，如调用父类方法、解析URL的所属类目等，其中创建 Zookeeper 客户端的直接入口就在该类的构造方法中。此外，该类中的一些方法没有分析到，它们和订阅与通知相关，会和订阅通知一起分析。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://gentryhuang.com/tags/Zookeeper/"}]},{"title":"Dubbo源码分析 - 注册中心总览","slug":"rpc/注册中心总览","date":"2020-04-12T16:00:00.000Z","updated":"2020-09-08T04:40:46.418Z","comments":false,"path":"posts/dafcd048/","link":"","permalink":"https://gentryhuang.com/posts/dafcd048/","excerpt":"","text":"前言在 Dubbo 体系中，注册中心是核心组件之一。Dubbo 通过注册中心实现了分布式环境中各服务之间的注册与发现，是各个分布式节点之间的纽带。主要作用如下： 动态加入。服务提供方通过注册中心记录自己的信息并动态地把自己暴露给其他消费者。 动态发现。一个消费者可以动态地感知新的配置、路由规则、新的服务，无需重新启动服务。 动态调整。注册中心支持参数的动态调整，新参数自动更新到相关服务节点。 工作流程 服务提供者启动时，会向注册中心写入自己的元数据信息，并订阅配置元数据信息。 消费者启动时，也会向注册中心写入自己的元数据信息，并订阅服务提供者、路由会配置元数据信息。 服务治理中心(dubbo-admin)启动时，会同时订阅所有服务提供者、服务消费者、路由和配置元数据信息。 服务提供者下线或新的服务提供者加入时，注册中心服务提供者目录会发生变化，变化信息会动态通知给消费者、服务治理中心。 消费方发起服务调用时，会异步将调用、统计信息等上报给监控中心。 注册中心抽象APIDubbo服务暴露、服务引用以及服务调用等几乎都会使用到注册中心，这篇文章对Dubbo 的注册中心抽象API进行说明。 上图是Dubbo的注册中心抽象API代码结构图，红框中的代码都是抽象API的基础代码，黄框是具体的注册中心抽象API。 注册中心核心抽象API的UML UML图非常清楚，注册中心核心抽象API中主要有三个角色，注册中心、注册中心工厂、注册中心的监听器。它们之间采用继承、组合、以及工厂的方式联系在一起，需要注意的是该图中的 ZookeeperRegistry 注册中心实现没有涉及到具体的客户端，关于 Dubbo 的 Zookeeper 客户端会单独写一篇文章进行详细说明。从UML图可以看出当前 Dubbo 版本支持四种注册中心的实现。Zookeeper 是官方推荐的注册中心，在生产环境中有过实际使用。Redis 注册中心并没有经过长时间运行的可靠性验证，其稳定性依赖 Redis 本身。Simple 注册中心是一个简单的基于内存的注册中心实现，它本身就是一个标准的PRC服务，不支持集群。Multicast 模块则不需要启动任何注册中心，只要通过广播地址，就可以互相发现，不推荐生产环境使用。下面分别介绍该UML图中涉及到的组件。 Node12345678910111213141516171819202122public interface Node &#123; /** * 获取URL * * @return url. */ URL getUrl(); /** * 是否可用 * * @return available. */ boolean isAvailable(); /** * 销毁 */ void destroy();&#125; Node 接口是一个顶级接口，Dubbo 中的核心组件几乎都继承该接口，只封装了三个和节点相关的方法。 RegistryService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface RegistryService &#123; /** * 注册数据，如：提供者地址，消费者地址，路由规则，覆盖规则等数据 * * @param url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin */ void register(URL url); /** * 取消注册数据 * * @param url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin */ void unregister(URL url); /** * 订阅符合条件的已注册数据，当有注册数据变更时自动推送。在 URL的category 属性上，表示订阅的数据分类。目前有四种类型： * 1 consumers 服务消费者列表 * 2 providers 服务提供者列表 * 3 routers 路由规则列表 * 4 configurations 配置规则列表 * * @param url Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @param listener A listener of the change event, not allowed to be empty * */ void subscribe(URL url, NotifyListener listener); /** * 取消订阅 * * @param url Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @param listener A listener of the change event, not allowed to be empty * */ void unsubscribe(URL url, NotifyListener listener); /** * 查询符合条件的已注册数据 * * @param url Query condition, is not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @return The registered information list, which may be empty, the meaning is the same as the parameters of &#123;@link com.alibaba.dubbo.registry.NotifyListener#notify(List&lt;URL&gt;)&#125;. * @see com.alibaba.dubbo.registry.NotifyListener#notify(List) */ List&lt;URL&gt; lookup(URL url);&#125; RegistryService 接口也是一个顶级接口，是注册中心服务接口，定义了节点的注册/反注册、订阅/反订阅以及查询三种操作方法。 Registry12345678/** * Registry. (SPI, Prototype, ThreadSafe) * * @see com.alibaba.dubbo.registry.RegistryFactory#getRegistry(com.alibaba.dubbo.common.URL) * @see com.alibaba.dubbo.registry.support.AbstractRegistry */public interface Registry extends Node, RegistryService &#123;&#125; 注册中心接口，该接口中没有定义方法只是继承了 Node 和 RegistryService 接口，因此具备了注册、订阅、查询等操作，注册中心具体实现都要继承该接口。 AbstractRegistryRegistry 的抽象类，实现了通用的注册、订阅、查询以及通知等方法。其中，实现了注册数据持久化到文件，该文件主要用于当消费者无法从注册中心拉取服务提供者列表信息时就从该文件中获取，支持了即使注册中心宕机消费者仍然可以和提供者通信。 属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public abstract class AbstractRegistry implements Registry &#123; // Log output protected final Logger logger = LoggerFactory.getLogger(getClass()); // URL地址分割符，用于文件缓存中，分割URL private static final char URL_SEPARATOR = ' '; // URL地址分隔正则表达式，用于解析文件缓存中URL列表 private static final String URL_SPLIT = \"\\\\s+\"; /** * 本地磁盘缓存 * 1 其中特殊的 key值 .registries 记录注册中心列表， 其他的均为&#123;@link #notified&#125; 服务提供者列表 * 2 数据流向： 创建注册中心实例时从file读取数据到 properties中；监听到注册中心数据发生变更时，修改properties对应的值，并写入file * 3 数据的键-值对 * （1）大多数情况下，键为订阅者的服务键 &#123;@link URL#getServiceKey()&#125;,值为服务提供者列表/路由规则列表/配置规则列表 * （2）特殊情况下是 .registries */ // Local disk cache, where the special key value.registies records the list of registry centers, and the others are the list of notified service providers private final Properties properties = new Properties(); /** * 注册中心数据缓存线程池 */ private final ExecutorService registryCacheExecutor = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"DubboSaveRegistryCache\", true)); /** * properties发生变更时，是否同步写入文件 */ private final boolean syncSaveFile; /** * 数据版本号 &#123;@link #properties&#125;，用于并发处理 */ private final AtomicLong lastCacheChanged = new AtomicLong(); /** * 已注册 URL 集合 */ private final Set&lt;URL&gt; registered = new ConcurrentHashSet&lt;URL&gt;(); /** * 订阅 URL 的监听器集合 */ private final ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; subscribed = new ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(); /** * 通知的URL到监听器监听到数据变化后的 结果URL集合 * key1: 订阅的URL，例如消费者的URL，和 &#123;@link #subscribed&#125; 的键一致 * key2: 分类，如： providers,consumers,routes,configurators。【一般是无consumers,因为消费者不会去订阅另外的消费者的列表 * value: 新的URL集合 */ private final ConcurrentMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt; notified = new ConcurrentHashMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt;(); /** * 注册中心 URL */ private URL registryUrl; /** * 缓存数据的磁盘文件 */ private File file; /** * 构造方法，每次创建注册中心都会同步磁盘文件数据到缓存中 * @param url */ public AbstractRegistry(URL url) &#123; setUrl(url); /** * 可以指定注册中心磁盘缓存文件，配置方式： * 1 使用file属性指定 &lt;dubbo:registry address=\"xxx\" file=\"/opt/xxx\"/&gt; * 2 使用save.file属性指定 &lt;dubbo:registry address=\"xxx\" save.file=\"/opt/xxx\"/&gt; * 3 不显示指定的话，使用默认值：System.getProperty(\"user.home\") + \"/.dubbo/dubbo-registry-\" + 应用名 + \"-\" + url.getAddress() + \".cache\" */ // Start file save timer syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, false); // 获得 file String filename = url.getParameter(Constants.FILE_KEY, System.getProperty(\"user.home\") + \"/.dubbo/dubbo-registry-\" + url.getParameter(Constants.APPLICATION_KEY) + \"-\" + url.getAddress() + \".cache\"); File file = null; if (ConfigUtils.isNotEmpty(filename)) &#123; file = new File(filename); if (!file.exists() &amp;&amp; file.getParentFile() != null &amp;&amp; !file.getParentFile().exists()) &#123; if (!file.getParentFile().mkdirs()) &#123; throw new IllegalArgumentException(\"Invalid registry store file \" + file + \", cause: Failed to create directory \" + file.getParentFile() + \"!\"); &#125; &#125; &#125; this.file = file; // 加载本地磁盘缓存文件到内存缓存，即 properties.load(in)，到properties属性中 loadProperties(); // 通知监听器，URL 变化结果 。 为什么构造方法要通知，zk连接都没有建立，监听器更没有注册，即 subscribed 里面还没有值 notify(url.getBackupUrls()); &#125; // $&#123;省略其他代码&#125;&#125; AbstractRegistry 抽象类中的属性大致有四类，注册的URL、缓存数据相关的、订阅URL的监听器、通知URL对应的变更URL。其中构造方法会加载本地磁盘缓存文件到内存中。 注册/反注册123456789101112131415161718192021222324252627282930313233343536373839public abstract class AbstractRegistry implements Registry &#123; // $&#123;省略其他代码&#125; /** * 先添加到 registered 缓存中，进行状态的维护。再由子类 FailbackRegistry类 真正注册 * * @param url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin */ @Override public void register(URL url) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"register url == null\"); &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Register: \" + url); &#125; registered.add(url); &#125; /** * 先从 registered 缓存中移除，再由子类 FailbackRegistry 真正取消注册 * * @param url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin */ @Override public void unregister(URL url) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"unregister url == null\"); &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Unregister: \" + url); &#125; registered.remove(url); &#125; // $&#123;省略其他代码&#125;&#125; AbstractRegistry 抽象类中的注册和反注册方法只是操作缓存，真正的实现交给子类 FailbackRegistry 完成。 订阅/反订阅1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public abstract class AbstractRegistry implements Registry &#123; // $&#123;省略其他代码&#125; /** * 先缓存到 subscribed 中，再通过子类 FailbackRegistry 具体执行订阅逻辑 * * @param url 订阅条件，不允许为空，如：consumer://10.10.10.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @param listener 变更事件监听器，不允许为空 */ @Override public void subscribe(URL url, NotifyListener listener) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"subscribe url == null\"); &#125; if (listener == null) &#123; throw new IllegalArgumentException(\"subscribe listener == null\"); &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Subscribe: \" + url); &#125; /** * 1 从ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; subscribed中获取key为url的集合Set&lt;NotifyListener&gt; * 2 如果该集合存在，直接将当前的NotifyListener实例存入该集合,如果集合不存在，先创建，之后放入subscribed中，并将当前的NotifyListener实例存入刚刚创建的集合 */ Set&lt;NotifyListener&gt; listeners = subscribed.get(url); if (listeners == null) &#123; subscribed.putIfAbsent(url, new ConcurrentHashSet&lt;NotifyListener&gt;()); listeners = subscribed.get(url); &#125; listeners.add(listener); &#125; /** * 先从缓存中移除，再通过子类 FailbackRegistry 具体执行取消订阅的逻辑 * * @param url Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @param listener A listener of the change event, not allowed to be empty */ @Override public void unsubscribe(URL url, NotifyListener listener) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"unsubscribe url == null\"); &#125; if (listener == null) &#123; throw new IllegalArgumentException(\"unsubscribe listener == null\"); &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Unsubscribe: \" + url); &#125; Set&lt;NotifyListener&gt; listeners = subscribed.get(url); if (listeners != null) &#123; listeners.remove(listener); &#125; &#125; // $&#123;省略其他代码&#125;&#125; AbstractRegistry 抽象类中的订阅和反订阅方法只是操作缓存，真正的实现交给子类 FailbackRegistry 完成。 断线重连12345678910111213141516171819202122232425262728293031323334353637public abstract class AbstractRegistry implements Registry &#123; // $&#123;省略其他代码&#125; /** * 和注册中心断开，重连成功会调用该方法，恢复注册和订阅 * * @throws Exception */ protected void recover() throws Exception &#123; // register Set&lt;URL&gt; recoverRegistered = new HashSet&lt;URL&gt;(getRegistered()); if (!recoverRegistered.isEmpty()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Recover register url \" + recoverRegistered); &#125; for (URL url : recoverRegistered) &#123; // 放入缓存 register(url); &#125; &#125; // subscribe Map&lt;URL, Set&lt;NotifyListener&gt;&gt; recoverSubscribed = new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed()); if (!recoverSubscribed.isEmpty()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Recover subscribe url \" + recoverSubscribed.keySet()); &#125; for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : recoverSubscribed.entrySet()) &#123; URL url = entry.getKey(); for (NotifyListener listener : entry.getValue()) &#123; subscribe(url, listener); &#125; &#125; &#125; &#125; // $&#123;省略其他代码&#125; AbstractRegistry 抽象类中的断线重连逻辑是，与注册中心断开后重新连接时会从缓存中取出已经注册的URL集合，然后放入缓存，订阅同理。 通知1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public abstract class AbstractRegistry implements Registry &#123; // $&#123;省略其他代码&#125; /* * 订阅URL映射的节点对应的子节点发生变化时，通知监听器 * @param url 订阅URL * @param listener 监听器 * @param urls 订阅URL映射的路径下的子路径集合（全量数据） */ protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"notify url == null\"); &#125; if (listener == null) &#123; throw new IllegalArgumentException(\"notify listener == null\"); &#125; if ((urls == null || urls.isEmpty()) &amp;&amp; !Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; logger.warn(\"Ignore empty notify urls for subscribe url \" + url); return; &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Notify urls for subscribe url \" + url + \", urls: \" + urls); &#125; // 1 将 `urls` 按照 URL中的 'category` 参数进行分类，添加到Map集合result中 Map&lt;String, List&lt;URL&gt;&gt; result = new HashMap&lt;String, List&lt;URL&gt;&gt;(); // 遍历 for (URL u : urls) &#123; // 子路径URL是否匹配订阅URL if (UrlUtils.isMatch(url, u)) &#123; // 获取分类，默认为 providers String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY); // 加入到结果集 List&lt;URL&gt; categoryList = result.get(category); if (categoryList == null) &#123; categoryList = new ArrayList&lt;URL&gt;(); result.put(category, categoryList); &#125; categoryList.add(u); &#125; &#125; if (result.size() == 0) &#123; return; &#125; // 获得订阅URL对应的缓存`notified`,即通知的 URL 变化结果（全量数据），会把result中的值放入到 categoryNotified中 Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url); if (categoryNotified == null) &#123; notified.putIfAbsent(url, new ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;()); categoryNotified = notified.get(url); &#125; // 处理通知的 URL 变化结果（全量数据），即按照分类，循环处理通知的URL变化结果（全量数据） for (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123; // 获得分类名 String category = entry.getKey(); // 获得分类名对应的通知ULR列表 List&lt;URL&gt; categoryList = entry.getValue(); // 1 将result 覆盖到 `notified`缓存【更新notified集合中的通知ULR列表】，需要注意：当某个分类的数据为空时，会依然有URL，如 empty://...` ，通过这种方式统一处理所有订阅URL对应的数据为空的情况。 categoryNotified.put(category, categoryList); // 2 保存订阅url对应的被通知的URL到 properties和文件 中 // 在循环中的保存的原因是，订阅url对应的通知url可能是变动的，上一步的操作会更新notified集合，为了让 properties和文件中的 订阅-通知关系正确就需要不断更新。 saveProperties(url); // 3 调用传入的listener的notify()方法 listener.notify(categoryList); &#125; &#125; // $&#123;省略其他代码&#125; 需要说明的是，向注册中心发起订阅后，会获取到订阅URL所对应的全量数据，接着调用该上述方法；当注册中心监控的数据发生变更时，会调用上述方法，虽然变化的是增量的，但是从注册中心拉取的是全量的数据，即最新的数据。该方法的使用主要在服务暴露过程中服务提供者订阅配置信息，便于配置发生改变时通过监听器进行捕捉然后回调该方法，最终完成服务重新暴露。在服务引用过程中消费者订阅服务信息、配置信息等最终完成服务引用。该方法在 Dubbo 整个生命周期内发挥重要的作用，在分析完服务暴露和服务引用后会单独写一篇文章详细说明。 销毁12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public abstract class AbstractRegistry implements Registry &#123; // $&#123;省略其他代码&#125; @Override public void destroy() &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Destroy registry:\" + getUrl()); &#125; // 取消注册逻辑 Set&lt;URL&gt; destroyRegistered = new HashSet&lt;URL&gt;(getRegistered()); if (!destroyRegistered.isEmpty()) &#123; for (URL url : new HashSet&lt;URL&gt;(getRegistered())) &#123; if (url.getParameter(Constants.DYNAMIC_KEY, true)) &#123; try &#123; // 取消注册，操作缓存，具体实现交给子类 unregister(url); if (logger.isInfoEnabled()) &#123; logger.info(\"Destroy unregister url \" + url); &#125; &#125; catch (Throwable t) &#123; logger.warn(\"Failed to unregister url \" + url + \" to registry \" + getUrl() + \" on destroy, cause: \" + t.getMessage(), t); &#125; &#125; &#125; &#125; // 取消订阅，操作缓存，具体实现交给子类 Map&lt;URL, Set&lt;NotifyListener&gt;&gt; destroySubscribed = new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed()); if (!destroySubscribed.isEmpty()) &#123; for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : destroySubscribed.entrySet()) &#123; // 订阅URL URL url = entry.getKey(); // 订阅URL对应的监听器列表 for (NotifyListener listener : entry.getValue()) &#123; try &#123; // 取消订阅 unsubscribe(url, listener); if (logger.isInfoEnabled()) &#123; logger.info(\"Destroy unsubscribe url \" + url); &#125; &#125; catch (Throwable t) &#123; logger.warn(\"Failed to unsubscribe url \" + url + \" to registry \" + getUrl() + \" on destroy, cause: \" + t.getMessage(), t); &#125; &#125; &#125; &#125; &#125; // $&#123;省略其他代码&#125; 主要是取消注册和订阅。需要注意的是，无论是服务提供者还是消费者，都会向Registry发起注册和订阅，所以在JVM关闭示，都要进行取消。 保存订阅变更数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class AbstractRegistry implements Registry &#123; // $&#123;省略其他代码&#125; /** * * @param url 订阅URL */ private void saveProperties(URL url) &#123; if (file == null) &#123; return; &#125; try &#123; StringBuilder buf = new StringBuilder(); // notified 缓存的值： 订阅URL 对应的映射集合，只要订阅URL关联的路径下有节点变化，就会不断刷新，最新最全数据。 Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url); if (categoryNotified != null) &#123; for (List&lt;URL&gt; us : categoryNotified.values()) &#123; for (URL u : us) &#123; if (buf.length() &gt; 0) &#123; buf.append(URL_SEPARATOR); &#125; buf.append(u.toFullString()); &#125; &#125; &#125; properties.setProperty(url.getServiceKey(), buf.toString()); // 版本号，使用CAS long version = lastCacheChanged.incrementAndGet(); // 保存变更数据到磁盘文件 if (syncSaveFile) &#123; doSaveProperties(version); &#125; else &#123; registryCacheExecutor.execute(new SaveProperties(version)); &#125; &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; // $&#123;省略其他代码&#125; 该方法用于保存订阅URL对应的变更数据先到内存中的 Properties 中，然后在同步或异步保存到磁盘文件中，同步或异步根据 syncSaveFile 参数值。接着分析保存变更数据到磁盘文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public abstract class AbstractRegistry implements Registry &#123; // $&#123;省略其他代码&#125; /** * @param version 版本号 */ public void doSaveProperties(long version) &#123; /** * 安全措施： * 1 CAS判断： * 在saveProperties(URL url)方法中执行了long version = lastCacheChanged.incrementAndGet(); * 这里进行if (version &lt; lastCacheChanged.get())判断，如果满足这个条件，说明当前线程在进行doSaveProperties(long version)时， * 已经有其他线程执行了saveProperties(URL url)，马上就要执行doSaveProperties(long version)，所以当前线程放弃操作，让后边的这个线程来做保存操作。 * 2 文件锁 FileLock： * FileLock 是进程文件锁，用于进程间并发，控制不同程序（JVM）对同一文件的并发访问，文件锁可以解决多个进程并发访问、可以通过对一个可写文件加锁，保证同时只有一个进程可以拿到文件锁，这个进程从而可以对文件进行操作， * 而其它拿不到锁的进程要么被挂起等待，要么可以去做一些其它事情，这种机制保证了进程间文件的并发安全操作。修改同一个文件的问题，但不能解决多线程并发访问、修改同一文件的问题。FileLock 文件锁的效果是与操作系统相关的，是由操作系统底层来实现。 */ if (version &lt; lastCacheChanged.get()) &#123; return; &#125; if (file == null) &#123; return; &#125; // Save try &#123; File lockfile = new File(file.getAbsolutePath() + \".lock\"); if (!lockfile.exists()) &#123; lockfile.createNewFile(); &#125; RandomAccessFile raf = new RandomAccessFile(lockfile, \"rw\"); try &#123; FileChannel channel = raf.getChannel(); try &#123; // 对文件加锁，默认为排它锁，没有获取到锁的进程阻塞等待 FileLock lock = channel.tryLock(); if (lock == null) &#123; throw new IOException(\"Can not lock the registry cache file \" + file.getAbsolutePath() + \", ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties\"); &#125; // Save try &#123; if (!file.exists()) &#123; file.createNewFile(); &#125; FileOutputStream outputFile = new FileOutputStream(file); try &#123; properties.store(outputFile, \"Dubbo Registry Cache\"); &#125; finally &#123; outputFile.close(); &#125; // 释放文件锁 &#125; finally &#123; lock.release(); &#125; &#125; finally &#123; channel.close(); &#125; &#125; finally &#123; raf.close(); &#125; &#125; catch (Throwable e) &#123; if (version &lt; lastCacheChanged.get()) &#123; return; &#125; else &#123; registryCacheExecutor.execute(new SaveProperties(lastCacheChanged.incrementAndGet())); &#125; logger.warn(\"Failed to save registry store file, cause: \" + e.getMessage(), e); &#125; &#125; // $&#123;省略其他代码&#125; 该方法用于将 Properties 文件中的变更数据保存到磁盘文件中，在保存的时候做了并发处理操作，详细见代码注释。 加载变更数据到内存12345678910111213141516171819202122232425262728public abstract class AbstractRegistry implements Registry &#123; // $&#123;省略其他代码&#125; private void loadProperties() &#123; if (file != null &amp;&amp; file.exists()) &#123; InputStream in = null; try &#123; in = new FileInputStream(file); properties.load(in); if (logger.isInfoEnabled()) &#123; logger.info(\"Load registry store file \" + file + \", data: \" + properties); &#125; &#125; catch (Throwable e) &#123; logger.warn(\"Failed to load registry store file \" + file, e); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; &#125; &#125; &#125; // $&#123;省略其他代码&#125; 该方法用于将磁盘文件中的变更数据加载到内存中的 Properties 中。 获取订阅URL对应的变更URL列表1234567891011121314151617181920212223242526272829303132public abstract class AbstractRegistry implements Registry &#123; // $&#123;省略其他代码&#125; /** * @param url 订阅URL * @return */ public List&lt;URL&gt; getCacheUrls(URL url) &#123; for (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123; // 映射URL String key = (String) entry.getKey(); // 映射URL 对应的 通知URL串 String value = (String) entry.getValue(); if (key != null &amp;&amp; key.length() &gt; 0 &amp;&amp; key.equals(url.getServiceKey()) &amp;&amp; (Character.isLetter(key.charAt(0)) || key.charAt(0) == '_') &amp;&amp; value != null &amp;&amp; value.length() &gt; 0) &#123; // 对通知的URL串 以 '空格' 进行分割成字符串 String[] arr = value.trim().split(URL_SPLIT); List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); for (String u : arr) &#123; // 解析URL串 urls.add(URL.valueOf(u)); &#125; return urls; &#125; &#125; return null; &#125; // $&#123;省略其他代码&#125; FailbackRegistry继承了 AbstractRegistry 抽闲类，支持失败重试的 Registry 抽象类。AbstractRegistry 中的注册、订阅操作更多的是操作缓存，并没有和注册中心交互。FailbackRegistry 在 AbstractRegistry 的基础上提供了注册和订阅的模版方法由具体子类去实现逻辑，并支持失败重试操作。 属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337public abstract class FailbackRegistry extends AbstractRegistry &#123; /** * 定时任务执行器 */ private final ScheduledExecutorService retryExecutor = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"DubboRegistryFailedRetryTimer\", true)); /** * 失败重试ScheduledFuture，定时检查是否有请求失败，如有，无限次重试 */ private final ScheduledFuture&lt;?&gt; retryFuture; /** * 注册失败的URL集合 */ private final Set&lt;URL&gt; failedRegistered = new ConcurrentHashSet&lt;URL&gt;(); /** * 取消注册失败的URL集合 */ private final Set&lt;URL&gt; failedUnregistered = new ConcurrentHashSet&lt;URL&gt;(); /** * 订阅失败的监听器集合 key: 订阅URL value: 监听器 */ private final ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; failedSubscribed = new ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(); /** * 取消订阅失败的监听器集合 key: 订阅URL value: 监听器 */ private final ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; failedUnsubscribed = new ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(); /** * 通知失败的URL集合 key1: 订阅URL key2: 监听器 value: 订阅URL对应的变更数据 */ private final ConcurrentMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt; failedNotified = new ConcurrentHashMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt;(); /** * The time in milliseconds the retryExecutor will wait // 重试频率 */ private final int retryPeriod; public FailbackRegistry(URL url) &#123; /** * 执行父类构造方法， 加载本地磁盘缓存文件到内存缓存，即 properties.load(in)，到properties属性中。 * 说明： * 这个很重要，注册中心宕机的情况下，依赖缓存文件中的信息可以构建Invoker，不影响服务的调用，只是不能调用新的服务了。 */ super(url); // 重试频率，单位 毫秒 this.retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD); // 创建失败重试定时器【就是将一堆失败记录进行对应的重试操作】 this.retryFuture = retryExecutor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; // Check and connect to the registry try &#123; // 执行重试操作 retry(); &#125; catch (Throwable t) &#123; // Defensive fault tolerance logger.error(\"Unexpected error occur at failed retry, cause: \" + t.getMessage(), t); &#125; &#125; &#125;, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS); &#125; // $&#123;省略其它代码&#125; // ==== Template method ==== protected abstract void doRegister(URL url); protected abstract void doUnregister(URL url); protected abstract void doSubscribe(URL url, NotifyListener listener); protected abstract void doUnsubscribe(URL url, NotifyListener listener);&#125;``` 该抽象类主要维护了注册/取消注册失败、订阅/取消订阅失败、通知失败的缓存，以及提供者了注册/取消注册、订阅/取消订阅的模版方法。进行注册或订阅操作时，会先调用其父类 AbstractRegistry 中的方法进行缓存操作，然后再调用其具体子类的方法。### register```java public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;省略其它代码&#125; @Override public void register(URL url) &#123; // 调用父类操作缓存的方法 super.register(url); failedRegistered.remove(url); failedUnregistered.remove(url); try &#123; // 发起注册请求到注册中心服务器，具体由子类实现，通过注册中心客户端连接到服务端 doRegister(url); &#125; catch (Exception e) &#123; Throwable t = e; // 如果开启了启动时检测，则直接抛出异常 boolean check = getUrl().getParameter(Constants.CHECK_KEY, true) &amp;&amp; url.getParameter(Constants.CHECK_KEY, true) &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol()); boolean skipFailback = t instanceof SkipFailbackWrapperException; if (check || skipFailback) &#123; if (skipFailback) &#123; t = t.getCause(); &#125; throw new IllegalStateException(\"Failed to register \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t); &#125; else &#123; logger.error(\"Failed to register \" + url + \", waiting for retry, cause: \" + t.getMessage(), t); &#125; // 记录注册失败的URL到注册失败的列表中，为了以后定时重试 failedRegistered.add(url); &#125; &#125; // $&#123;省略其它代码&#125;&#125;``` ### unregister```java public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;省略其它代码&#125; @Override public void unregister(URL url) &#123; // 调用父类操作缓存的方法 super.unregister(url); failedRegistered.remove(url); failedUnregistered.remove(url); try &#123; // 发起取消注册请求到注册中心服务器，具体由子类实现，通过注册中心客户端连接到服务端 doUnregister(url); &#125; catch (Exception e) &#123; Throwable t = e; // If the startup detection is opened, the Exception is thrown directly. boolean check = getUrl().getParameter(Constants.CHECK_KEY, true) &amp;&amp; url.getParameter(Constants.CHECK_KEY, true) &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol()); boolean skipFailback = t instanceof SkipFailbackWrapperException; if (check || skipFailback) &#123; if (skipFailback) &#123; t = t.getCause(); &#125; throw new IllegalStateException(\"Failed to unregister \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t); &#125; else &#123; logger.error(\"Failed to uregister \" + url + \", waiting for retry, cause: \" + t.getMessage(), t); &#125; // Record a failed registration request to a failed list, retry regularly failedUnregistered.add(url); &#125; &#125; // $&#123;省略其它代码&#125;&#125;``` ### subscribe```java public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;省略其它代码&#125; @Override public void subscribe(URL url, NotifyListener listener) &#123; /** 调用父类 将listener实例加入到url所对应的监听器集合中 &#123;@link #subscribed &#125; 中 */ super.subscribe(url, listener); // 将listener从failedSubscribed/failedUnsubscribed中删除 ，接着从failedNotified获取当前url的通知失败Map&lt;NotifyListener, List&lt;URL&gt;&gt;，然后从中 删除掉listener 到 需要通知的所有url 的映射 removeFailedSubscribed(url, listener); try &#123; // 向服务端发送订阅请求,具体请求处理由子类实现 doSubscribe(url, listener); /** 如果在订阅的过程抛出异常，那么尝试获取缓存url，如果有缓存url，则进行失败通知。之后“将失败的订阅请求记录到失败列表，定时重试”，如果没有缓存url， * 若开启了启动时检测或者直接抛出的异常是SkipFailbackWrapperException，则直接抛出异常，不会“将失败的订阅请求记录到失败列表，定时重试” */ &#125; catch (Exception e) &#123; Throwable t = e; /** * * 从Properties缓存文件中取出通知URL集合 * 【注意：这些URL是由注册中心维护的，每次订阅方请求订阅时，注册中心都会把对应的要通知的URL列表记录到properties文件中，然后写入磁盘，注意 empty://的情况】 */ List&lt;URL&gt; urls = getCacheUrls(url); if (urls != null &amp;&amp; !urls.isEmpty()) &#123; notify(url, listener, urls); logger.error(\"Failed to subscribe \" + url + \", Using cached list: \" + urls + \" from cache file: \" + getUrl().getParameter(Constants.FILE_KEY, System.getProperty(\"user.home\") + \"/dubbo-registry-\" + url.getHost() + \".cache\") + \", cause: \" + t.getMessage(), t); &#125; else &#123; // 如果开启了启动时检测check=true,则直接抛出异常 boolean check = getUrl().getParameter(Constants.CHECK_KEY, true) &amp;&amp; url.getParameter(Constants.CHECK_KEY, true); boolean skipFailback = t instanceof SkipFailbackWrapperException; if (check || skipFailback) &#123; if (skipFailback) &#123; t = t.getCause(); &#125; throw new IllegalStateException(\"Failed to subscribe \" + url + \", cause: \" + t.getMessage(), t); &#125; else &#123; logger.error(\"Failed to subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t); &#125; &#125; // 将失败的订阅请求记录到失败列表，定时重试 addFailedSubscribed(url, listener); &#125; &#125; // $&#123;省略其它代码&#125;&#125;``` 该方法中向服务端发送订阅请求会交给子类处理，失败时会进入到 `catch` 块中的逻辑，注册中心维护的通知URL列表用在了这里，即当订阅发生异常时，会取出缓存中的通知ULR列表，调用 notify 方法进行通知。该逻辑也解释了即使注册中心宕机了，无论是消费方在注册中心宕机前启动完成还是宕机后启动，只要消费方缓存中的服务提供者可用，就可以实现服务调用。### unsubscribe```java public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;省略其它代码&#125; /** * 取消订阅，移除相关的缓存。真正的取消订阅由子类执行 * * @param url Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @param listener A listener of the change event, not allowed to be empty */ @Override public void unsubscribe(URL url, NotifyListener listener) &#123; // 调用父类方法，移除url对应的listener实例 super.unsubscribe(url, listener); // 移除相关的 订阅/取消订阅失败缓存，以及失败通知缓存 removeFailedSubscribed(url, listener); try &#123; // 向服务端发送取消订阅请求,具体请求处理由子类实现 doUnsubscribe(url, listener); &#125; catch (Exception e) &#123; Throwable t = e; // If the startup detection is opened, the Exception is thrown directly. boolean check = getUrl().getParameter(Constants.CHECK_KEY, true) &amp;&amp; url.getParameter(Constants.CHECK_KEY, true); boolean skipFailback = t instanceof SkipFailbackWrapperException; if (check || skipFailback) &#123; if (skipFailback) &#123; t = t.getCause(); &#125; throw new IllegalStateException(\"Failed to unsubscribe \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t); &#125; else &#123; logger.error(\"Failed to unsubscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t); &#125; // 记录取消订阅，便于重试 Set&lt;NotifyListener&gt; listeners = failedUnsubscribed.get(url); if (listeners == null) &#123; failedUnsubscribed.putIfAbsent(url, new ConcurrentHashSet&lt;NotifyListener&gt;()); listeners = failedUnsubscribed.get(url); &#125; listeners.add(listener); &#125; &#125; // $&#123;省略其它代码&#125;&#125;``` ### notify```java public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;省略其它代码&#125; /** * @param url 订阅URL * @param listener 监听器 * @param urls 通知的URL变化结果（全量数据）【注意：全量指的是至少要是一个分类的全量[动态类型的]，而不一定是全部数据】 */ @Override protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"notify url == null\"); &#125; if (listener == null) &#123; throw new IllegalArgumentException(\"notify listener == null\"); &#125; try &#123; // 进行通知 doNotify(url, listener, urls); &#125; catch (Exception t) &#123; // 将失败的通知请求记录到失败列表中，定时重试 Map&lt;NotifyListener, List&lt;URL&gt;&gt; listeners = failedNotified.get(url); if (listeners == null) &#123; failedNotified.putIfAbsent(url, new ConcurrentHashMap&lt;NotifyListener, List&lt;URL&gt;&gt;()); listeners = failedNotified.get(url); &#125; listeners.put(listener, urls); logger.error(\"Failed to notify for subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t); &#125; &#125; /** * 会调用父类的通知方法 * * @param url 订阅URL * @param listener 监听器 * @param urls 订阅URL映射路径 下的子路径集合 */ protected void doNotify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123; super.notify(url, listener, urls); &#125; // $&#123;省略其它代码&#125;&#125; FailbackRegistry 中的 notify方法 本质上还是调用 AbstractRegistry 中的 notify 方法，区别在于 FailbackRegistry 会收集失败通知请求并记录到缓存中，便于重试。 断线重连1234567891011121314151617181920212223242526272829303132333435363738public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;省略其它代码&#125; /** * * @throws Exception */ @Override protected void recover() throws Exception &#123; // register Set&lt;URL&gt; recoverRegistered = new HashSet&lt;URL&gt;(getRegistered()); if (!recoverRegistered.isEmpty()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Recover register url \" + recoverRegistered); &#125; for (URL url : recoverRegistered) &#123; failedRegistered.add(url); &#125; &#125; // subscribe Map&lt;URL, Set&lt;NotifyListener&gt;&gt; recoverSubscribed = new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed()); if (!recoverSubscribed.isEmpty()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Recover subscribe url \" + recoverSubscribed.keySet()); &#125; for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : recoverSubscribed.entrySet()) &#123; URL url = entry.getKey(); for (NotifyListener listener : entry.getValue()) &#123; addFailedSubscribed(url, listener); &#125; &#125; &#125; &#125; // $&#123;省略其它代码&#125;&#125; FailbackRegistry 完全覆写父类方法(即不像前几个方法，会调用父类的方法)，将已注册和订阅的URL添加到 {@link #failedRegistered} ,{@link #failedSubscribed} 属性中，这样在{@link #retry()}方法中会进行重试。 重试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;省略其它代码&#125; protected void retry() &#123; //重新注册没有注册成功的URL集合 if (!failedRegistered.isEmpty()) &#123; Set&lt;URL&gt; failed = new HashSet&lt;URL&gt;(failedRegistered); if (failed.size() &gt; 0) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Retry register \" + failed); &#125; try &#123; for (URL url : failed) &#123; try &#123; doRegister(url); failedRegistered.remove(url); &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry register \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry register \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; // 重新取消注册没有取消注册成功的URL集合 if (!failedUnregistered.isEmpty()) &#123; Set&lt;URL&gt; failed = new HashSet&lt;URL&gt;(failedUnregistered); if (!failed.isEmpty()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Retry unregister \" + failed); &#125; try &#123; for (URL url : failed) &#123; try &#123; doUnregister(url); failedUnregistered.remove(url); &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry unregister \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry unregister \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; /** * * 重新订阅 之前订阅失败的URL *1 把要订阅的URL映射的路径与监听器绑定 *2 创建该监听器关联的ChildListener，底层又会使用TargetChildListener去包裹ChildListener，注意，TargetChildListener的实现会有不同 *3 TargetChildListener直接监听订阅的URL映射路径的子路径，当子路径有变化，先触发TargetChildListener的方法，然后该方法会调用ChildListener的childChanged方法，接着调用监听的notify方法 * * TargetChildListener */ if (!failedSubscribed.isEmpty()) &#123; Map&lt;URL, Set&lt;NotifyListener&gt;&gt; failed = new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failedSubscribed); for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failed).entrySet()) &#123; if (entry.getValue() == null || entry.getValue().size() == 0) &#123; failed.remove(entry.getKey()); &#125; &#125; if (failed.size() &gt; 0) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Retry subscribe \" + failed); &#125; try &#123; for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : failed.entrySet()) &#123; URL url = entry.getKey(); Set&lt;NotifyListener&gt; listeners = entry.getValue(); for (NotifyListener listener : listeners) &#123; try &#123; doSubscribe(url, listener); listeners.remove(listener); &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry subscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry subscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; // 重新移除URL映射路径下的子路径关联的监听器 if (!failedUnsubscribed.isEmpty()) &#123; Map&lt;URL, Set&lt;NotifyListener&gt;&gt; failed = new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failedUnsubscribed); for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failed).entrySet()) &#123; if (entry.getValue() == null || entry.getValue().isEmpty()) &#123; failed.remove(entry.getKey()); &#125; &#125; if (failed.size() &gt; 0) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Retry unsubscribe \" + failed); &#125; try &#123; for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : failed.entrySet()) &#123; URL url = entry.getKey(); Set&lt;NotifyListener&gt; listeners = entry.getValue(); for (NotifyListener listener : listeners) &#123; try &#123; doUnsubscribe(url, listener); listeners.remove(listener); &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry unsubscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry unsubscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; // 重新通知【看通知的URL列表（发生改变的URL列表）和原始的URL列表对比，看是否改变，改变了就需要重新暴露服务】 if (!failedNotified.isEmpty()) &#123; Map&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt; failed = new HashMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt;(failedNotified); for (Map.Entry&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt; entry : new HashMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt;(failed).entrySet()) &#123; if (entry.getValue() == null || entry.getValue().size() == 0) &#123; failed.remove(entry.getKey()); &#125; &#125; if (failed.size() &gt; 0) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Retry notify \" + failed); &#125; try &#123; for (Map&lt;NotifyListener, List&lt;URL&gt;&gt; values : failed.values()) &#123; for (Map.Entry&lt;NotifyListener, List&lt;URL&gt;&gt; entry : values.entrySet()) &#123; try &#123; NotifyListener listener = entry.getKey(); List&lt;URL&gt; urls = entry.getValue(); listener.notify(urls); values.remove(listener); &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry notify \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry notify \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; &#125; // $&#123;省略其它代码&#125;&#125; 重试方法就是遍历缓存中五个 failedXxx属性，重试对应的操作，很清晰。 销毁12345678910111213141516171819202122public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;省略其它代码&#125; @Override public void destroy() &#123; // 调用父方法，取消注册和订阅 super.destroy(); try &#123; // 取消重试任务 retryFuture.cancel(true); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; // 优雅关闭线程池 ExecutorUtil.gracefulShutdown(retryExecutor, retryPeriod); &#125; // $&#123;省略其它代码&#125;&#125; 取消注册和订阅，并关闭重试任务。取消注册和订阅还是调用其父类 AbstractRegistry 的 destroy 的方法，在父类基础上增加了对任务取消操作以及关闭重试线程池。 RegistryFactory1234567891011121314151617/** * RegistryFactory. (SPI, Singleton, ThreadSafe) 注册中心工厂接口，创建的注册中心，包含注册中心客户端。注意和注册中心客户端工厂的区别。 * * @see com.alibaba.dubbo.registry.support.AbstractRegistryFactory */@SPI(\"dubbo\")public interface RegistryFactory &#123; /** * 获取注册中心 * * @param url 注册中心地址，不允许为空 * @return 注册中心引用，总不返回空 */ @Adaptive(&#123;\"protocol\"&#125;) Registry getRegistry(URL url);&#125; 注册中心工厂，它是一个 Dubbo 的扩展点，默认扩展名是 dubbo ，即默认的扩展实现是 DubboRegistryFactory 。 AbstractRegistryFactory1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * AbstractRegistryFactory. (SPI, Singleton, ThreadSafe) * * @see com.alibaba.dubbo.registry.RegistryFactory */public abstract class AbstractRegistryFactory implements RegistryFactory &#123; // Log output private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRegistryFactory.class); /** * LOCK 锁，用于 #destroyAll() 和 #getRegistry(url) 方法，处理对 REGISTRIES 属性访问的竞争。 */ private static final ReentrantLock LOCK = new ReentrantLock(); /** * Registry 集合 */ private static final Map&lt;String, Registry&gt; REGISTRIES = new ConcurrentHashMap&lt;String, Registry&gt;(); /** * Get all registries * * @return all registries */ public static Collection&lt;Registry&gt; getRegistries() &#123; return Collections.unmodifiableCollection(REGISTRIES.values()); &#125; /** * 销毁所有的Registry对象 */ public static void destroyAll() &#123; if (LOGGER.isInfoEnabled()) &#123; LOGGER.info(\"Close all registries \" + getRegistries()); &#125; // 获得锁 // Lock up the registry shutdown process LOCK.lock(); try &#123; // 循环调用 destroy() 方法 for (Registry registry : getRegistries()) &#123; try &#123; // AbstractRegistry 实现了公用的销毁逻辑，取消注册和订阅 registry.destroy(); &#125; catch (Throwable e) &#123; LOGGER.error(e.getMessage(), e); &#125; &#125; // 清空缓存 REGISTRIES.clear(); &#125; finally &#123; // Release the lock LOCK.unlock(); &#125; &#125; @Override public Registry getRegistry(URL url) &#123; url = url.setPath(RegistryService.class.getName()) .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName()) // 设置interface 属性在后来的订阅通知很有用 .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY); String key = url.toServiceString(); // Lock the registry access process to ensure a single instance of the registry LOCK.lock(); try &#123; // 访问缓存 Registry registry = REGISTRIES.get(key); if (registry != null) &#123; return registry; &#125; // 缓存未命中，创建Registry 实例，交给具体子类实现 registry = createRegistry(url); if (registry == null) &#123; throw new IllegalStateException(\"Can not create registry \" + url); &#125; // 写入缓存 REGISTRIES.put(key, registry); return registry; &#125; finally &#123; // Release the lock LOCK.unlock(); &#125; &#125; /** * 创建注册中心的模版方法，由具体子类实现，过程包括： * 1 创建注册中心客户端 * 2 启动客户端 * * @param url 注册中心地址 * @return Registry 对象 */ protected abstract Registry createRegistry(URL url);&#125; 实现 RegistryFactory 接口，是RegistryFactory 抽象类，主要两个工作，将获取的注册中心放入到缓存和实现了实现了公用的销毁逻辑，取消注册和订阅。 NotifyListener1234567891011121314/** * NotifyListener. (API, Prototype, ThreadSafe) 通知监听器 * * @see com.alibaba.dubbo.registry.RegistryService#subscribe(URL, NotifyListener) */public interface NotifyListener &#123; /** * 当收到订阅URL对应的数据发生变化，通知触发 * * @param urls 已注册信息列表，总不为空 */ void notify(List&lt;URL&gt; urls);&#125; 该接口的实现类主要分为两大类，RegistryDirectory 和 匿名类内部类，具体的作用在订阅通知章节说明。 小结本章主要介绍了注册的抽象层，接下来的文章会分析 Zookeeper 和 Redis 的实现，其他两种不做分析。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubbo源码分析 - 服务容器","slug":"rpc/服务容器","date":"2020-04-09T16:00:00.000Z","updated":"2020-09-04T07:39:03.454Z","comments":false,"path":"posts/714ea63d/","link":"","permalink":"https://gentryhuang.com/posts/714ea63d/","excerpt":"","text":"前言前面的 Dubbo SPI、Dubbo配置等文章描述的几乎都只是服务暴露、服务引用、服务调用之前的准备工作，有了这些准备工作后，下面介绍Dubbo的服务容器，通过Dubbo服务容器可以非常方便启动一个Dubbo服务。 Dubbo服务容器Dubbo的服务容器只是一个简单的Main，类似SpringBoot,负责初始化和启动不同功能的 Container ，如果说dubbo的服务容器是一个简单的Main方法，那么承载不同功能的Container就是服务容器的具体实现，可以有不同的类型。uml关系图如下： 容器扩展点123456789101112131415161718/** * Container. (SPI, Singleton, ThreadSafe) * * 服务容器接口，Dubbo的扩展点，默认为 spring */@SPI(\"spring\")public interface Container &#123; /** * start. 启动容器 */ void start(); /** * stop. 体制容器 */ void stop();&#125; 启动器Main123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class Main &#123; private static final Logger logger = LoggerFactory.getLogger(Main.class); /** * Container的配置项，如 dubbo.container=spring,log4j */ public static final String CONTAINER_KEY = \"dubbo.container\"; /** * Dubbo 优雅停机配置项，如 dubbo.shutdown.hook=true */ public static final String SHUTDOWN_HOOK_KEY = \"dubbo.shutdown.hook\"; /** * Container扩展点的加载器 */ private static final ExtensionLoader&lt;Container&gt; loader = ExtensionLoader.getExtensionLoader(Container.class); /** * 锁 */ private static final ReentrantLock LOCK = new ReentrantLock(); /** * 锁的条件 */ private static final Condition STOP = LOCK.newCondition(); /** * @param args 启动参数，可以在启动时指定要加载的容器，如 java com.alibaba.dubbo.container.Main spring log4j */ public static void main(String[] args) &#123; try &#123; // 如果 main 方法的参数没有传入值，则从配置中加载。如果获取不到就使用Container 默认扩展 spring if (args == null || args.length == 0) &#123; String config = ConfigUtils.getProperty(CONTAINER_KEY, loader.getDefaultExtensionName()); args = Constants.COMMA_SPLIT_PATTERN.split(config); &#125; final List&lt;Container&gt; containers = new ArrayList&lt;Container&gt;(); for (int i = 0; i &lt; args.length; i++) &#123; // 使用Dubbo SPI 加载 Container ,并把加载的Container 放入到List中 containers.add(loader.getExtension(args[i])); &#125; logger.info(\"Use container type(\" + Arrays.toString(args) + \") to run dubbo serivce.\"); // 当配置JVM启动参数带有 -Ddubbo.shutdown.hook=true时，添加关闭的ShutdownHook if (\"true\".equals(System.getProperty(SHUTDOWN_HOOK_KEY))) &#123; // 优雅停机 Runtime.getRuntime().addShutdownHook(new Thread(\"dubbo-container-shutdown-hook\") &#123; @Override public void run() &#123; for (Container container : containers) &#123; try &#123; // 关闭容器 container.stop(); logger.info(\"Dubbo \" + container.getClass().getSimpleName() + \" stopped!\"); &#125; catch (Throwable t) &#123; logger.error(t.getMessage(), t); &#125; try &#123; // 获得 ReentrantLock LOCK.lock(); // 唤醒 Main 主线程的等待 STOP.signal(); &#125; finally &#123; // 释放 LOCK LOCK.unlock(); &#125; &#125; &#125; &#125;); &#125; // 启动容器 for (Container container : containers) &#123; container.start(); logger.info(\"Dubbo \" + container.getClass().getSimpleName() + \" started!\"); &#125; System.out.println(new SimpleDateFormat(\"[yyyy-MM-dd HH:mm:ss]\").format(new Date()) + \" Dubbo service server started!\"); // 发生异常，打印错误日志，并JVM退出 &#125; catch (RuntimeException e) &#123; e.printStackTrace(); logger.error(e.getMessage(), e); System.exit(1); &#125; try &#123; // 获得 LOCK 锁 LOCK.lock(); /** * 释放锁，进入等待，直到被唤醒 * 作用：线程不结束，不触发JVM退出，这样Dubbo就不会退出。如果不等待，main方法执行完成，就会触发JVM退出，导致Dubbo服务退出 */ STOP.await(); &#125; catch (InterruptedException e) &#123; logger.warn(\"Dubbo service server stopped, interrupted by other thread!\", e); &#125; finally &#123; // 释放 LOCK LOCK.unlock(); &#125; &#125;&#125; 说明 dubbo服务容器只是一个简单Main 方法，默认情况下只会加载一个简单的Spring容器，用于暴露服务。Dubbo服务容器的加载内容可以扩展，即可通过容器扩展点进行扩展，如：spring、logback等。 dubbo服务容器是dubbo服务的启动器，它的本质是启动时加载dubbo的相关内容【通过spring配置，log4j配置等体现】然后启动Container。但是 实际生产中，一般不会直接使用dubbo的服务容器，更多主流的是使用Spring或者SpringBoot SpringContainer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * SpringContainer. (SPI, Singleton, ThreadSafe) * 实现Container接口，Spring容器实现类 */public class SpringContainer implements Container &#123; private static final Logger logger = LoggerFactory.getLogger(SpringContainer.class); /** * Spring 配置属性 */ public static final String SPRING_CONFIG = \"dubbo.spring.config\"; /** * 默认配置文件地址 */ public static final String DEFAULT_SPRING_CONFIG = \"classpath*:META-INF/spring/*.xml\"; /** * Spring 上下文 ，静态属性，全局唯一 */ static ClassPathXmlApplicationContext context; public static ClassPathXmlApplicationContext getContext() &#123; return context; &#125; @Override public void start() &#123; // 获得Spring 配置文件的地址【先优先从JVM参数中取，没有再从dubbo.properties文件中取】 String configPath = ConfigUtils.getProperty(SPRING_CONFIG); // 如果没有配置就使用默认路径下的配置文件 if (configPath == null || configPath.length() == 0) &#123; configPath = DEFAULT_SPRING_CONFIG; &#125; // 创建Spring 上下文 context = new ClassPathXmlApplicationContext(configPath.split(\"[,\\\\s]+\"), false); // 添加监听器 [dubbo服务暴露、服务销毁以及优雅停机的关键] context.addApplicationListener(new DubboApplicationListener()); // 监听容器关闭 [注册优雅停机钩子] context.registerShutdownHook(); // 刷新Spring容器 context.refresh(); // 启动Spring容器，加载Dubbo的配置，从而启动Dubbo 服务 context.start(); &#125; @Override public void stop() &#123; try &#123; if (context != null) &#123; // 停止上下文，会触发 ContextStoppedEvent 事件 context.stop(); // 关闭上下文，会触发 ContextClosedEvent 事件 context.close(); // 置空，便于被回收 context = null; &#125; &#125; catch (Throwable e) &#123; logger.error(e.getMessage(), e); &#125; &#125;&#125; 说明 DubboApplicationListener实现了ApplicationListener接口，用于监听Spring容器的起停，在启动和销毁的时候分别执行服务暴露和取消服务暴露以及执行优雅停机 创建DubboApplicationListener对象的时候，都会创建DubboBootstrap对象，该对象主要完成服务暴露、取消服务暴露、注册与移除jdk shutdownhook 在创建DubboBootstrap对象时，会为该类注入DubboShutdownHook对象，该对象继承了Thread，将释放资源的方法作为任务体，该对象是真正要注册到系统中的钩子，当JVM退出时该钩子会回调它的任务体 关系图如下 DubboApplicationListener1234567891011121314151617181920212223242526272829303132333435/** * An application listener that listens the ContextClosedEvent. * Upon the event, this listener will do the necessary clean up to avoid memory leak. */public class DubboApplicationListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123; /** * Dubbo引导程序 */ private DubboBootstrap dubboBootstrap; public DubboApplicationListener() &#123; // 创建DubboBootstrap dubboBootstrap = new DubboBootstrap(false); &#125; public DubboApplicationListener(DubboBootstrap dubboBootstrap) &#123; this.dubboBootstrap = dubboBootstrap; &#125; /** * 监听spring事件 * @param applicationEvent */ @Override public void onApplicationEvent(ApplicationEvent applicationEvent) &#123; // spring容器刷新完成 if (applicationEvent instanceof ContextRefreshedEvent) &#123; dubboBootstrap.start(); // spring容器销毁 &#125; else if (applicationEvent instanceof ContextClosedEvent) &#123; dubboBootstrap.stop(); &#125; &#125;&#125; DubboBootstrap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * A bootstrap class to easily start and stop Dubbo via programmatic API. * The bootstrap class will be responsible to cleanup the resources during stop. */public class DubboBootstrap &#123; /** * 服务配置对象列表 */ private List&lt;ServiceConfig&gt; serviceConfigList; /** * 启动期间是否注册 钩子 */ private final boolean registerShutdownHookOnStart; /** * 在嵌入式环境下[Main方法]运行Dubbo时使用的 钩子 */ private DubboShutdownHook shutdownHook; public DubboBootstrap() &#123; // 获取DubboShutdownHook，并注入到该类中 this(true, DubboShutdownHook.getDubboShutdownHook()); &#125; public DubboBootstrap(boolean registerShutdownHookOnStart) &#123; // 获取DubboShutdownHook，并注入到该类中 this(registerShutdownHookOnStart, DubboShutdownHook.getDubboShutdownHook()); &#125; public DubboBootstrap(boolean registerShutdownHookOnStart, DubboShutdownHook shutdownHook) &#123; this.serviceConfigList = new ArrayList&lt;ServiceConfig&gt;(); this.shutdownHook = shutdownHook; this.registerShutdownHookOnStart = registerShutdownHookOnStart; &#125; /** * Register service config to bootstrap, which will be called during &#123;@link DubboBootstrap#stop()&#125; * @param serviceConfig the service * @return the bootstrap instance */ public DubboBootstrap registerServiceConfig(ServiceConfig serviceConfig) &#123; serviceConfigList.add(serviceConfig); return this; &#125; /** * dubbo引导程序 - start * 1 是否注册shutdown hook * 2 服务暴露 */ public void start() &#123; // 启动期间是否注册过shutdown hook if (registerShutdownHookOnStart) &#123; registerShutdownHook(); &#125; else &#123; // 如果DubboShutdown hook 已经注册到系统中，需要移除掉 removeShutdownHook(); &#125; // 循环服务配置对象，依次进行服务暴露 for (ServiceConfig serviceConfig: serviceConfigList) &#123; serviceConfig.export(); &#125; &#125; /** * dubbo引导程序 - stop * 1 取消服务暴露 * 2 */ public void stop() &#123; for (ServiceConfig serviceConfig: serviceConfigList) &#123; serviceConfig.unexport(); &#125; // 执行 shutdown hook 释放资源 shutdownHook.destroyAll(); // 如果启动期已经注册过，则从系统中移除 todo ??? 为什么还要注册到系统，直接根据spring销毁事件然后执行释放任务不就可以了吗？ if (registerShutdownHookOnStart) &#123; removeShutdownHook(); &#125; &#125; /** * 注册 shutdown hook */ public void registerShutdownHook() &#123; Runtime.getRuntime().addShutdownHook(shutdownHook); &#125; /** * 移除 shutdown hook */ public void removeShutdownHook() &#123; try &#123; Runtime.getRuntime().removeShutdownHook(shutdownHook); &#125; catch (IllegalStateException ex) &#123; // ignore - VM is already shutting down &#125; &#125;&#125; DubboShutdownHook123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * The shutdown hook thread to do the clean up stuff. * This is a singleton in order to ensure there is only one shutdown hook registered. * Because &#123;@link ApplicationShutdownHooks&#125; use &#123;@link java.util.IdentityHashMap&#125; * to store the shutdown hooks. */public class DubboShutdownHook extends Thread &#123; private static final Logger logger = LoggerFactory.getLogger(DubboShutdownHook.class); /** * ShutdownHook,类属性 */ private static final DubboShutdownHook dubboShutdownHook = new DubboShutdownHook(\"DubboShutdownHook\"); public static DubboShutdownHook getDubboShutdownHook() &#123; return dubboShutdownHook; &#125; /** * Has it already been destroyed or not? * &lt;p&gt; * 是否已经被销毁标识 */ private final AtomicBoolean destroyed; private DubboShutdownHook(String name) &#123; super(name); this.destroyed = new AtomicBoolean(false); &#125; /** * ShutdownHook的任务体 */ @Override public void run() &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Run shutdown hook now.\"); &#125; destroyAll(); &#125; /** * Destroy all the resources, including registries and protocols. * &lt;p&gt; * 销毁所有的资源，包括 Registry相关 和 Protocol相关 */ public void destroyAll() &#123; //如果已经销毁则忽略 if (!destroyed.compareAndSet(false, true)) &#123; return; &#125; // 销毁所有的 Registry,取消应用程序中的服务提供者和消费者的订阅与注册 AbstractRegistryFactory.destroyAll(); /** * 销毁所有的 Protocol * * 说明： * 这里的Protocol比较多，大体上可以分两类： * 1 和Registry相关的Protocol，RegistryProtocol关注服务的注册 * 2 具体协议，如 DubboProtocol、httpProtocol等,关注服务的暴露和引用 */ ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol.class); for (String protocolName : loader.getLoadedExtensions()) &#123; try &#123; Protocol protocol = loader.getLoadedExtension(protocolName); if (protocol != null) &#123; protocol.destroy(); &#125; &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125;&#125; LogbackContainer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * LogbackContainer. (SPI, Singleton, ThreadSafe) * 实现 Container 接口，Logback 容器实现类 */public class LogbackContainer implements Container &#123; /** * 日志文件路径 */ public static final String LOGBACK_FILE = \"dubbo.logback.file\"; /** * 日志文件级别 */ public static final String LOGBACK_LEVEL = \"dubbo.logback.level\"; /** * 日志保留天数 */ public static final String LOGBACK_MAX_HISTORY = \"dubbo.logback.maxhistory\"; /** * 默认日志级别 */ public static final String DEFAULT_LOGBACK_LEVEL = \"ERROR\"; @Override public void start() &#123; // 获得 logback 配置的日志文件路径 String file = ConfigUtils.getProperty(LOGBACK_FILE); if (file != null &amp;&amp; file.length() &gt; 0) &#123; // 获得日志级别 String level = ConfigUtils.getProperty(LOGBACK_LEVEL); if (level == null || level.length() == 0) &#123; level = DEFAULT_LOGBACK_LEVEL; &#125; // 获得日志保留天数，如果是0则永久保留 int maxHistory = StringUtils.parseInteger(ConfigUtils.getProperty(LOGBACK_MAX_HISTORY)); // 初始化 logback doInitializer(file, level, maxHistory); &#125; &#125; /** * 停止为空，因为不需要关闭 */ @Override public void stop() &#123; &#125; /** * 初始化 logback * * @param file 日志文件路径 * @param level 日志级别 * @param maxHistory 日志保留天数 */ private void doInitializer(String file, String level, int maxHistory) &#123; // 获取日志工厂 LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory(); // 通过工厂获取Logger Logger rootLogger = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME); rootLogger.detachAndStopAllAppenders(); // 创建日志追加器 RollingFileAppender&lt;ILoggingEvent&gt; fileAppender = new RollingFileAppender&lt;ILoggingEvent&gt;(); fileAppender.setContext(loggerContext); fileAppender.setName(\"application\"); fileAppender.setFile(file); fileAppender.setAppend(true); // 创建滚动策略 TimeBasedRollingPolicy&lt;ILoggingEvent&gt; policy = new TimeBasedRollingPolicy&lt;ILoggingEvent&gt;(); policy.setContext(loggerContext); policy.setMaxHistory(maxHistory); policy.setFileNamePattern(file + \".%d&#123;yyyy-MM-dd&#125;\"); policy.setParent(fileAppender); policy.start(); fileAppender.setRollingPolicy(policy); // 格式 PatternLayoutEncoder encoder = new PatternLayoutEncoder(); encoder.setContext(loggerContext); encoder.setPattern(\"%date [%thread] %-5level %logger (%file:%line\\\\) - %msg%n\"); encoder.start(); fileAppender.setEncoder(encoder); fileAppender.start(); rootLogger.addAppender(fileAppender); rootLogger.setLevel(Level.toLevel(level)); rootLogger.setAdditive(false); &#125;&#125; Log4jContainer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * Log4jContainer. (SPI, Singleton, ThreadSafe) * 实现Container接口，Log4j容器实现类 */public class Log4jContainer implements Container &#123; /** * 日志文件路径配置，如 dubbo.log4j.file=/opt/log/access.log */ public static final String LOG4J_FILE = \"dubbo.log4j.file\"; /** * 日志级别 如： dubbo.log4j.level=WARN */ public static final String LOG4J_LEVEL = \"dubbo.log4j.level\"; /** * 日志子路径配置 */ public static final String LOG4J_SUBDIRECTORY = \"dubbo.log4j.subdirectory\"; /** * 默认日志级别 */ public static final String DEFAULT_LOG4J_LEVEL = \"ERROR\"; /** * 自动配置log4j */ @Override @SuppressWarnings(\"unchecked\") public void start() &#123; // 获得 log4j 配置的日志文件路径 String file = ConfigUtils.getProperty(LOG4J_FILE); // 获取日志级别 if (file != null &amp;&amp; file.length() &gt; 0) &#123; String level = ConfigUtils.getProperty(LOG4J_LEVEL); if (level == null || level.length() == 0) &#123; level = DEFAULT_LOG4J_LEVEL; &#125; // 创建PropertyConfigurator所需的 Properties 对象， Properties properties = new Properties(); properties.setProperty(\"log4j.rootLogger\", level + \",application\"); properties.setProperty(\"log4j.appender.application\", \"org.apache.log4j.DailyRollingFileAppender\"); properties.setProperty(\"log4j.appender.application.File\", file); properties.setProperty(\"log4j.appender.application.Append\", \"true\"); properties.setProperty(\"log4j.appender.application.DatePattern\", \"'.'yyyy-MM-dd\"); properties.setProperty(\"log4j.appender.application.layout\", \"org.apache.log4j.PatternLayout\"); properties.setProperty(\"log4j.appender.application.layout.ConversionPattern\", \"%d [%t] %-5p %C&#123;6&#125; (%F:%L) - %m%n\"); PropertyConfigurator.configure(properties); &#125; // 获得日志子目录，用于多进程启动时，避免冲突 String subdirectory = ConfigUtils.getProperty(LOG4J_SUBDIRECTORY); if (subdirectory != null &amp;&amp; subdirectory.length() &gt; 0) &#123; // 获取 Logger 列表 Enumeration&lt;org.apache.log4j.Logger&gt; ls = LogManager.getCurrentLoggers(); while (ls.hasMoreElements()) &#123; org.apache.log4j.Logger l = ls.nextElement(); if (l != null) &#123; // 拿到当前Logger 的追加器 Enumeration&lt;Appender&gt; as = l.getAllAppenders(); while (as.hasMoreElements()) &#123; Appender a = as.nextElement(); if (a instanceof FileAppender) &#123; FileAppender fa = (FileAppender) a; String f = fa.getFile(); if (f != null &amp;&amp; f.length() &gt; 0) &#123; int i = f.replace('\\\\', '/').lastIndexOf('/'); String path; if (i == -1) &#123; path = subdirectory; &#125; else &#123; path = f.substring(0, i); if (!path.endsWith(subdirectory)) &#123; path = path + \"/\" + subdirectory; &#125; f = f.substring(i + 1); &#125; // 设置新的文件名 fa.setFile(path + \"/\" + f); // 生效配置 fa.activateOptions(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; /** * 空方法，无需关闭 */ @Override public void stop() &#123; &#125;&#125; 容器启动 通过加载properties配置文件加载目标容器 1dubbo.container&#x3D;spring,logback,log4j 缺省只加载spring容器 1java org.apache.dubbo.container.Main 通过main方法参数传入要加载的容器 1java org.apache.dubbo.container.Main spring logback log4j 通过 JVM 启动参数传入要加载的容器 1java org.apache.dubbo.container.Main -Ddubbo.container&#x3D;spring,jetty,log4j 小结虽然实际生产中一般不会直接使用dubbo的服务容器，但是它的实现机制我们可以学习下。了解了Dubbo服务容器后，我们从源码层面上重新认识了Dubbo的启停流程，从下一篇文章开始正式进入到Dubbo的核心模块源码分析阶段。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Spring","slug":"Spring","permalink":"https://gentryhuang.com/tags/Spring/"}]},{"title":"Dubbo源码分析 - 注解配置","slug":"rpc/注解配置","date":"2020-04-01T16:00:00.000Z","updated":"2020-09-04T07:15:55.737Z","comments":false,"path":"posts/1a889dcd/","link":"","permalink":"https://gentryhuang.com/posts/1a889dcd/","excerpt":"","text":"前言在 Dubbo源码分析 - XML配置 中，详细介绍了Dubbo的XML配置方式，本篇文章介绍Dubbo注解配置方式，使用示例见 Dubbo示例 - 注解配置。 示例说明1234567891011121314151617181920212223242526272829/** * AnnotationProvider * * Java Config + 注解的方式 */public class AnnotationProvider &#123; public static void main(String[] args) throws Exception &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ProviderConfiguration.class); context.start(); System.in.read(); &#125; @Configuration @EnableDubbo(scanBasePackages = \"com.alibaba.dubbo.examples.annotation.impl\") @PropertySource(\"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-provider.properties\") static public class ProviderConfiguration &#123; /** * 这里通过Java Config显示组装Bean，会注入给Dubbo服务，即标注有@Service的类。如果不显示装配，Dubbo会默认创建内置的配置类定义，创建内置的配置类定义的前提是配置了相关的属性，否则不会创建。其他配置类似。 */ @Bean public ProviderConfig providerConfig() &#123; ProviderConfig providerConfig = new ProviderConfig(); providerConfig.setTimeout(5000); return providerConfig; &#125; &#125;&#125; 这里使用 Dubbo示例 - 注解配置 中的提供者配置进行说明。当Spring启动后，会先获取配置类上的 @PropertySource 注解，把外部配置进行解析然后放入Spring环境中，为之后流程中的Dubbo配置类的对象进行属性赋值。Spring会递归获取配置类的 @Import 注解，即搜集配置相关的所有@Import注解，以获取使用该注解引入的Selector或Registrar类，这些类是用来给Spring容器导入组件的。Dubbo的注解实现包括两大部分，一个是外部化配置，另一个是注解驱动，它们的能力是由Selector或Registrar类导入所需组件实现的，笔者调试这块花了很多时间，细节点还是挺多的，由于这些都是Spring源码的知识点就不进行分析了。 注解配置代码结构 在 Dubbo 2.5.7之前的版本 ，Dubbo 提供了两个核心注解 @Service 以及 @Reference，分别用于Dubbo 服务提供和 Dubbo 服务引用。@Service 作为 XML配置&lt;dubbo:service&gt;的替代，与 Spring Framework @Service 类似，用于服务暴露。@Reference 则是替代&lt;dubbo:reference &gt; ，类似于 Spring 中的 @Autowired，引用服务。但2.5.7之前Dubbo注解是基于AnnotationBean实现的，主要存在以下几个问题： 注解支持不充分，需要XML配置&lt;dubbo:annotation&gt; @Service 不支持Spring AOP @Reference 不支持字段继承性 基于原来实现思路的基础上无法解决历史遗留问题，从2.5.7开始Dubbo的注解实现已经完全重写，AnnotationBean已经被废弃。 设计原则Spring Framework 3.1 引入了 @ComponentScan 完全替代了 XML 元素 &lt;context:component-scan&gt; 。同样地， @DubboComponentScan 作为 Dubbo 2.5.7 新增的 Annotation，也是XML 元素 &lt;dubbo:annotation&gt; 的替代方案，与注解驱动相关。 @DubboComponentScan 相对比较繁重，原因在于处理Dubbo @Service 标注的类暴露Dubbo服务外，还要支持Spring Bean的 @Reference 字段或方法注入Dubbo服务代理，即 @DubboComponentScan 除了扫描 Dubbo @Service 组件以外，还需要处理 @Reference注入。需要注意的是，如果 @Reference 字段或方法所在的类不是 Spring Bean 的话， @DubboComponentScan 不会处理 @Reference 注入，其原理与 Spring @Autowired 一致。@EnableDubboConfig 用于支持Dubbo的外部化配置，常用于显示指定Dubbo的配置。需要注意的是Dubbo框架中的dubbo.properties从某种意义上来说是特殊的Dubbo的外部化配置，框架默认情况下会加载类路径下的该配置文件，详细参见 属性配置。 注解介绍@Service 注解@Service 用来配置Dubbo的服务提供方，通过 @Service 上提供的属性，可以进一步的定制化 Dubbo 的服务提供者。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Inheritedpublic @interface Service &#123; Class&lt;?&gt; interfaceClass() default void.class; String interfaceName() default \"\"; String version() default \"\"; String group() default \"\"; String path() default \"\"; boolean export() default false; String token() default \"\"; boolean deprecated() default false; boolean dynamic() default false; String accesslog() default \"\"; int executes() default 0; boolean register() default true; int weight() default 0; String document() default \"\"; int delay() default 0; String local() default \"\"; String stub() default \"\"; String cluster() default \"\"; String proxy() default \"\"; int connections() default 0; int callbacks() default 0; String onconnect() default \"\"; String ondisconnect() default \"\"; String owner() default \"\"; String layer() default \"\"; int retries() default 0; String loadbalance() default \"\"; boolean async() default false; int actives() default 0; boolean sent() default false; String mock() default \"\"; String validation() default \"\"; int timeout() default 0; String cache() default \"\"; String[] filter() default &#123;&#125;; String[] listener() default &#123;&#125;; String[] parameters() default &#123;&#125;; String application() default \"\"; String module() default \"\"; String provider() default \"\"; String[] protocol() default &#123;&#125;; String monitor() default \"\"; String[] registry() default &#123;&#125;;&#125; @Service定义在一个类上，表示一个服务的具体实现，比较重要的属性： interfaceClass：指定服务提供方实现的 interface 的类 interfaceName：指定服务提供方实现的 interface 的类名 version：指定服务的版本号 group：指定服务的分组 export：是否暴露服务 registry：是否向注册中心注册服务 application：应用配置 module：模块配置 provider：服务提供方配置 protocol：协议配置 monitor：监控中心配置 registry：注册中心配置 其中，application、module、provider、protocol、monitor、registry属性需要提供的是对应的Spring Bean的名字，Bean组装方式可以通过XML配置，也可以通过Java Config配置。 @Reference 注解@Reference 用来配置Dubbo的服务消费方，通过 @Reference 上提供的属性，可以进一步的定制化 Dubbo 的服务消费方。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Reference * * @export */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)public @interface Reference &#123; Class&lt;?&gt; interfaceClass() default void.class; String interfaceName() default \"\"; String version() default \"\"; String group() default \"\"; String url() default \"\"; String client() default \"\"; boolean generic() default false; boolean injvm() default false; boolean check() default true; boolean init() default false; boolean lazy() default false; boolean stubevent() default false; String reconnect() default \"\"; boolean sticky() default false; String proxy() default \"\"; String stub() default \"\"; String cluster() default \"\"; int connections() default 0; int callbacks() default 0; String onconnect() default \"\"; String ondisconnect() default \"\"; String owner() default \"\"; String layer() default \"\"; int retries() default 2; String loadbalance() default \"\"; boolean async() default false; int actives() default 0; boolean sent() default false; String mock() default \"\"; String validation() default \"\"; int timeout() default 0; String cache() default \"\"; String[] filter() default &#123;&#125;; String[] listener() default &#123;&#125;; String[] parameters() default &#123;&#125;; String application() default \"\"; String module() default \"\"; String consumer() default \"\"; String monitor() default \"\"; String[] registry() default &#123;&#125;;&#125; @Reference 可以定义在类中的一个字段上，也可以定义在一个方法上，甚至可以用来修饰另一个 annotation，表示一个服务引用。一般多把@Reference 定义在一个字段上，该注解有以下重要属性： interfaceClass：指定服务的 interface 的类 interfaceName：指定服务的 interface 的类名 version：指定服务的版本号 group：指定服务的分组 url：通过指定服务提供方的 URL 地址直接绕过注册中心发起调用 application：应用配置 module：模块配置 consumer：服务消费方配置 protocol：协议配置 monitor：监控中心配置 registry：注册中心配置 其中，application、module、consumer、protocol、monitor、registry属性需要提供的是对应的Spring Bean的名字，Bean组装方式可以通过XML配置，也可以通过Java Config配置。 @EnableDubbo 注解@EnableDubbo 注解是 @EnableDubboConfig 和 @DubboComponentScan 两者组合的便捷表达方式。与注解驱动相关的是 @DubboComponentScan，与外部化配置相关的是 @EnableDubboConfig 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented@EnableDubboConfig // 开启Dubbo Config 【DubboConfig对象的创建和DubboConfig中的属性设置】@DubboComponentScan // 扫描Dubbo 的@Service 和 @Reference 注解的包或者类，从而创建Bean对象public @interface EnableDubbo &#123; /** * * 配置@DubboComponentScan 注解 扫描的包 * * Base packages to scan for annotated @Service classes. * &lt;p&gt; * Use &#123;@link #scanBasePackageClasses()&#125; for a type-safe alternative to String-based * package names. * * @return the base packages to scan * @see DubboComponentScan#basePackages() */ @AliasFor(annotation = DubboComponentScan.class, attribute = \"basePackages\") String[] scanBasePackages() default &#123;&#125;; /** * * 配置 @DubboComponentScan 注解 扫描的类 * * Type-safe alternative to &#123;@link #scanBasePackages()&#125; for specifying the packages to * scan for annotated @Service classes. The package of each class specified will be * scanned. * * @return classes from the base packages to scan * @see DubboComponentScan#basePackageClasses */ @AliasFor(annotation = DubboComponentScan.class, attribute = \"basePackageClasses\") Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;; /** * 配置 @EnableDubboConfig 注解，是否将配置属性绑定到多个Spring Bean 上 * * It indicates whether &#123;@link AbstractConfig&#125; binding to multiple Spring Beans. * * @return the default value is &lt;code&gt;false&lt;/code&gt; * @see EnableDubboConfig#multiple() */ @AliasFor(annotation = EnableDubboConfig.class, attribute = \"multiple\") boolean multipleConfig() default false;&#125; @EnableDubbo 可以通过 scanBasePackages属性 指定要扫描的包，通过 scanBasePackageClasses属性 指定要扫描的类[最后还是会转为扫描包的方式]，进而扫描Dubbo 的服务提供者（以 @Service 标注）以及 Dubbo 的服务消费者（以 Reference 标注）。扫描到 Dubbo 的服务提供方和消费者之后，对其做相应的组装并初始化，并最终完成服务暴露或者引用的工作。如果不使用外部化配置的话，也可以直接使用 @DubboComponentScan。 @EnableDubboConfig 注解该注解用于开启Dubbo配置，支持外部化配置。 1234567891011121314151617181920212223242526272829/** * As a convenient and multiple &#123;@link EnableDubboConfigBinding&#125; * * @see EnableDubboConfigBinding * @see DubboConfigConfiguration * @see DubboConfigConfigurationSelector * @since 2.5.8 * * 开启Dubbo配置 * */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented@Import(DubboConfigConfigurationSelector.class) public @interface EnableDubboConfig &#123; /** * 配置是否绑定到多个Spring Bean上，即表示是否支持多Dubbo配置Bean的绑定，默认值为false，即单Dubbo 配置Bean的绑定。 * * It indicates whether binding to multiple Spring Beans. * * @return the default value is &lt;code&gt;false&lt;/code&gt; * @revised 2.5.9 */ boolean multiple() default false;&#125; 该注解有一个核心的属性，multiple 属性用于支持多Dubbo配置Bean的数据绑定。@Import 的value属性值 DubboConfigConfigurationSelector 用于给Spring容器导入组件，导入的组件是 DubboConfigConfiguration.Single 或 DubboConfigConfiguration.Multiple，具体导入哪个组件取决于 multiple 的值。 DubboConfigConfigurationSelector1234567891011121314151617181920212223242526272829303132public class DubboConfigConfigurationSelector implements ImportSelector, Ordered &#123; /** * @param importingClassMetadata @Import(DubboConfigConfigurationSelector.class) 所标注的注解信息 * @return */ @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; // 获得 @EnableDubboConfig注解的属性 AnnotationAttributes attributes = AnnotationAttributes.fromMap( importingClassMetadata.getAnnotationAttributes(EnableDubboConfig.class.getName())); //获得multiple属性 boolean multiple = attributes.getBoolean(\"multiple\"); // 如果为true，则注册 DubboConfigConfiguration.Multiple Bean对象 if (multiple) &#123; return of(DubboConfigConfiguration.Multiple.class.getName()); &#125; else &#123; // 如果为false，则注册 DubboConfigConfiguration.Single Bean对象 return of(DubboConfigConfiguration.Single.class.getName()); &#125; &#125; private static &lt;T&gt; T[] of(T... values) &#123; return values; &#125; @Override public int getOrder() &#123; return HIGHEST_PRECEDENCE; &#125;&#125; 该类实现了Spring的ImportSelector接口，功能如下： 利用ImportSelector要导入哪些组件，只需要返回要导入组件的全限定类名，即 selectImports方法返回值。 如果selectImports方法返回值对应的类，它里面有使用@Bean注解的方法，那么此时给容器中导入的不只有当前返回值对应类的实例，还有该类型中加了@Bean对应的实例。 给容器导入的不是 DubboConfigConfigurationSelector，因为它实现了ImportSelector接口，导入的是该类的selectImports方法中返回的值对应的类。 通过以上规则可以知道，该类就是给Spring容器导入 DubboConfigConfiguration.Single 或 DubboConfigConfiguration.Multiple 组件。可以看出它们都是 DubboConfigConfiguration 类的内部类，下面我们看下该类的具体信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Dubbo &#123;@link AbstractConfig Config&#125; &#123;@link Configuration&#125; * * @see Configuration * @see EnableDubboConfigBindings * @see EnableDubboConfigBinding * @see ApplicationConfig * @see ModuleConfig * @see RegistryConfig * @see ProtocolConfig * @see MonitorConfig * @see ProviderConfig * @see ConsumerConfig * @since 2.5.8 */public class DubboConfigConfiguration &#123; /** * Single Dubbo &#123;@link AbstractConfig Config&#125; Bean Binding * @EnableDubboConfigBinding 注解 prefix 都是单数 */ @EnableDubboConfigBindings(&#123; @EnableDubboConfigBinding(prefix = \"dubbo.application\", type = ApplicationConfig.class), @EnableDubboConfigBinding(prefix = \"dubbo.module\", type = ModuleConfig.class), @EnableDubboConfigBinding(prefix = \"dubbo.registry\", type = RegistryConfig.class), @EnableDubboConfigBinding(prefix = \"dubbo.protocol\", type = ProtocolConfig.class), @EnableDubboConfigBinding(prefix = \"dubbo.monitor\", type = MonitorConfig.class), @EnableDubboConfigBinding(prefix = \"dubbo.provider\", type = ProviderConfig.class), @EnableDubboConfigBinding(prefix = \"dubbo.consumer\", type = ConsumerConfig.class) &#125;) public static class Single &#123; &#125; /** * Multiple Dubbo &#123;@link AbstractConfig Config&#125; Bean Binding * @EnableDubboConfigBinding 注解 prefix 都是复数 */ @EnableDubboConfigBindings(&#123; @EnableDubboConfigBinding(prefix = \"dubbo.applications\", type = ApplicationConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = \"dubbo.modules\", type = ModuleConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = \"dubbo.registries\", type = RegistryConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = \"dubbo.protocols\", type = ProtocolConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = \"dubbo.monitors\", type = MonitorConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = \"dubbo.providers\", type = ProviderConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = \"dubbo.consumers\", type = ConsumerConfig.class, multiple = true) &#125;) public static class Multiple &#123; &#125;&#125; DubboConfigConfiguration 类中没有属性和方法，只有两个静态内部类，具体导入哪个类上面已经介绍过了，下面我们来详介绍下 @EnableDubboConfigBindings 和 @EnableDubboConfigBinding 注解。 @EnableDubboConfigBindings 注解12345678910111213141516171819/** * Multiple &#123;@link EnableDubboConfigBinding&#125; &#123;@link Annotation&#125; * * @since 2.5.8 * @see EnableDubboConfigBinding */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(DubboConfigBindingsRegistrar.class) public @interface EnableDubboConfigBindings &#123; /** * The value of &#123;@link EnableDubboConfigBindings&#125; * * @return non-null */ EnableDubboConfigBinding[] value();&#125; 该注解有一个value属性，类型是 EnableDubboConfigBinding[] ，即 @EnableDubboConfigBinding 数组。该注解上使用 @Import 注解，使用DubboConfigBindingsRegistrar 类给Spring容器导入组件，下面我们继续跟进，看下具体导入哪些组件。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * &#123;@link AbstractConfig Dubbo Config&#125; binding Bean registrar for &#123;@link EnableDubboConfigBindings&#125; * * @see EnableDubboConfigBindings * @see DubboConfigBindingRegistrar * @since 2.5.8 */public class DubboConfigBindingsRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; private ConfigurableEnvironment environment; /** * * @param importingClassMetadata 标注类注解信息 * @param registry Bean定义注册表 */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; /** * 获得 EnableDubboConfigBindings 注解 */ AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings.class.getName())); // 获得EnableDubboConfigBindings 注解的value 属性值（这里是 EnableDubboConfigBinding 注解数组） AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray(\"value\"); // 创建DubboConfigBindignRegistrar 对象，并设置环境变量 DubboConfigBindingRegistrar registrar = new DubboConfigBindingRegistrar(); registrar.setEnvironment(environment); // 依次遍历 EnableDubboConfigBinding 注解集合，调用 DubboConfigBindingRegistrar的注册Bean方法进行组件注册 for (AnnotationAttributes element : annotationAttributes) &#123; // 根据 EnableDubboConfigBinding 注解信息，进行对应组件的注册 registrar.registerBeanDefinitions(element, registry); &#125; &#125; @Override public void setEnvironment(Environment environment) &#123; Assert.isInstanceOf(ConfigurableEnvironment.class, environment); this.environment = (ConfigurableEnvironment) environment; &#125;&#125; 上面的类主要做了三件事情： 获取 @EnableDubboConfigBindings 注解信息，并获取该注解的value属性值，即获取的是 @EnableDubboConfigBinding 注解数组。 创建 DubboConfigBindingRegistrar对象。 遍历@EnableDubboConfigBinding 注解数组，调用DubboConfigBindingRegistrar对象的 registerBeanDefinitions方法。 我们可以发现，@EnableDubboConfigBindings利用DubboConfigBindingsRegistrar导入组件逻辑很简单，因为整个导入逻辑都封装在了DubboConfigBindingRegistrar对象的 registerBeanDefinitions方法中。我们接着分析DubboConfigBindingsRegistrar类，需要说明的是@EnableDubboConfigBinding注解就是通过@Import注解使用该类。 1234567891011121314151617181920212223public class DubboConfigBindingRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; // $&#123;其他代码&#125; /** * @param attributes @EnableDubboConfigBinding注解信息 * @param registry Bean定义注册表 */ protected void registerBeanDefinitions(AnnotationAttributes attributes, BeanDefinitionRegistry registry) &#123; // 获得prefix 属性（因为有可能有占位符，需要要解析） String prefix = environment.resolvePlaceholders(attributes.getString(\"prefix\")); // 获得type属性，即AbstractConfig的实现类，这就是要导入的组件。需要特别说明的是，使用注解方式创建Dubbo的配置Bean，Dubbo Config 都是固定写在@EnableDubboConfigBinding注解属性中。 Class&lt;? extends AbstractConfig&gt; configClass = attributes.getClass(\"type\"); // 获的multiple属性，决定配置是否用于多BeanDefinition boolean multiple = attributes.getBoolean(\"multiple\"); // 注册Dubbo Config Bean registerDubboConfigBeans(prefix, configClass, multiple, registry); &#125; // $&#123;其他代码&#125;&#125; 由代码可以看出DubboConfigBindingsRegistrar就是使用 DubboConfigBindingRegistrar 对象解析@EnableDubboConfigBinding 注解信息，即配置属性的前缀和配置属性对应的Dubbo Config类，接着调用registerDubboConfigBeans 方法执行注册Bean定义逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class DubboConfigBindingRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; // $&#123;省略其他代码&#125; /** * 注册dubbo Config Bean对象 * * @param prefix 配置属性前缀 * @param configClass 配置类 * @param multiple 是否支持多Bean配置 * @param registry Spring注册表 */ private void registerDubboConfigBeans(String prefix, Class&lt;? extends AbstractConfig&gt; configClass, boolean multiple, BeanDefinitionRegistry registry) &#123; // 获得prefix 开头的配置属性，以map形式返回 【environment.getPropertySources() 获得是系统属性、系统变量和@ResourceProperty注解导入的propertis配置属性】 Map&lt;String, Object&gt; properties = getSubProperties(environment.getPropertySources(), prefix); // 配置类没有配置相关属性，则不创建对应的BeanDefinition if (CollectionUtils.isEmpty(properties)) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"There is no property for binding to dubbo config class [\" + configClass.getName() + \"] within prefix [\" + prefix + \"]\"); &#125; return; &#125; // 获得配置类的Bean名称，Bean名称生成规则取决与 multiple 的值 Set&lt;String&gt; beanNames = multiple ? resolveMultipleBeanNames(properties) : Collections.singleton(resolveSingleBeanName(properties, configClass, registry)); // 遍历Bean名字集合 for (String beanName : beanNames) &#123; // 1. 注册Dubbo Config的Bean 对象【没有设置属性值】 registerDubboConfigBean(beanName, configClass, registry); // 2. 注册Dubbo Config的Bean对象对应的DubboConfigBindingBeanPostProcessor对象，即Dubbo配置属性绑定的后置处理器【注意，每一个Dubbo Config的Bean对象都对应一个绑定配置的后置处理器】 registerDubboConfigBindingBeanPostProcessor(prefix, beanName, multiple, registry); &#125; &#125; /** * 注册Dubbo ConfigBean对象 * * @param beanName Bean的名称 * @param configClass 配置类 * @param registry 注册表 */ private void registerDubboConfigBean(String beanName, Class&lt;? extends AbstractConfig&gt; configClass, BeanDefinitionRegistry registry) &#123; // 创建 configClass对应的Bean定义Builder [该过程Bean定义已经创建] BeanDefinitionBuilder builder = rootBeanDefinition(configClass); // 由 Bean定义Builder 获取Bean定义 AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); // 注册到 Spring 的注册表中 registry.registerBeanDefinition(beanName, beanDefinition); if (log.isInfoEnabled()) &#123; log.info(\"The dubbo config bean definition [name : \" + beanName + \", class : \" + configClass.getName() + \"] has been registered.\"); &#125; &#125; /** * 创建的Dubbo Config的Bean对象的DubboConfigBindingBeanPostProcessor对象 【目的：实现对Dubbo Config的Bean对象的配置属性设置】 * * @param prefix 配置属性前缀 * @param beanName Bean的名称 * @param multiple 是否支持多Bean * @param registry Spring注册表 */ private void registerDubboConfigBindingBeanPostProcessor(String prefix, String beanName, boolean multiple, BeanDefinitionRegistry registry) &#123; // 创建Dubbo配置绑定 Bean后置处理器对应的BeanDefinitionBuilder对象 Class&lt;?&gt; processorClass = DubboConfigBindingBeanPostProcessor.class; BeanDefinitionBuilder builder = rootBeanDefinition(processorClass); /** * 构造方法的参数为 actualPrefix 和 beanName，即创建DubboConfigBindingBeanPostProcessor对象需要这两个参数，后面属性绑定会用到这两个属性。 * @see DubboConfigBindingBeanPostProcessor#DubboConfigBindingBeanPostProcessor(java.lang.String, java.lang.String) */ String actualPrefix = multiple ? normalizePrefix(prefix) + beanName : prefix; builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName); // 获得 DubboConfigBindingBeanPostProcessor 的 BeanDefinition 对象 AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); // 设置rol属性 beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); // 注册到注册表 registerWithGeneratedName(beanDefinition, registry); if (log.isInfoEnabled()) &#123; log.info(\"The BeanPostProcessor bean definition [\" + processorClass.getName() + \"] for dubbo config bean [name : \" + beanName + \"] has been registered.\"); &#125; &#125; // $&#123;省略代码&#125; &#125; registerDubboConfigBeans 方法主要完成了两个核心的工作，创建Dubbo Config的Bean定义和Dubbo Config的属性绑定后置处理器。Dubbo Config是约定好的配置类，具体约定的配置类可以参见 DubboConfigConfiguration，并且指定了这些配置类的外部配置属性的前缀。这个过程还涉及到Dubbo Config的Bean定义的名称生成，我们来看下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class DubboConfigBindingRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; // $&#123;省略其他代码&#125; /** * 获得配置类对应的Bean 名称的集合。配置用于多个Bean的情况 * &lt;p&gt; * 例如： dubbo.application.$&#123;beanName&#125;.name=dubbo-demo-annotation-provider，$&#123;beanName&#125;就是配置类对应的Bean的名称 * * @param properties 配置属性集合 * @return */ private Set&lt;String&gt; resolveMultipleBeanNames(Map&lt;String, Object&gt; properties) &#123; Set&lt;String&gt; beanNames = new LinkedHashSet&lt;String&gt;(); for (String propertyName : properties.keySet()) &#123; // 获取$&#123;beanName&#125; 字符串 int index = propertyName.indexOf(\".\"); if (index &gt; 0) &#123; String beanName = propertyName.substring(0, index); beanNames.add(beanName); &#125; &#125; return beanNames; &#125; /** * 获得配置类对应的Bean 名称 * 例如： dubbo.application.name=dubbo-demo-annotation-provider * * @param properties * @param configClass * @param registry * @return */ private String resolveSingleBeanName(Map&lt;String, Object&gt; properties, Class&lt;? extends AbstractConfig&gt; configClass, BeanDefinitionRegistry registry) &#123; // 获得Bean的名称 String beanName = (String) properties.get(\"id\"); // 没有没有定义，就基于Spring提供的机制生成对应的Bean的名字。 如： org.apache.dubbo.config.ApplicationConfig#0 if (!StringUtils.hasText(beanName)) &#123; BeanDefinitionBuilder builder = rootBeanDefinition(configClass); beanName = BeanDefinitionReaderUtils.generateBeanName(builder.getRawBeanDefinition(), registry); &#125; return beanName; &#125; // $&#123;省略其他代码&#125;&#125; 由上面的代码可以看出，配置用于多个Bean的时候Bean的名称直接从配置属性值中获取，即获取${beanName} 的值作为Bean名称，Bean的名称可能会有多个。配置用于单个Bean的时候Bean的名称先尝试使用id属性值，没有配置id属性就自动生成。这两种情况可能一下子不好理解，下文还会详细说明。上面的过程中Bean定义是注册到了注册表中，但是Bean的属性还没有设置，下面我们来分析 DubboConfigBindingBeanPostProcessor 是如何进行属性绑定的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/** * Dubbo Config Binding &#123;@link BeanPostProcessor&#125; * * @see EnableDubboConfigBinding * @see DubboConfigBindingRegistrar * @since 2.5.8 * &lt;p&gt; * 处理Dubbo AbstractConfig Bean的配置属性注入 */public class DubboConfigBindingBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware, InitializingBean &#123; private final Log log = LogFactory.getLog(getClass()); /** * 属性配置前缀 */ private final String prefix; /** * Binding Bean Name // Bean的名字，每个配置类的Bean都有自己的名称 */ private final String beanName; /** * Dubbo 配置属性绑定器 ，用来绑定配置属性到Dubbo Config中 （内部使用Spring DataBinder完成属性绑定） */ private DubboConfigBinder dubboConfigBinder; /** * 应用上下文 */ private ApplicationContext applicationContext; /** * 是否忽略未知的属性 */ private boolean ignoreUnknownFields = true; /** * 是否忽略类型不对的属性 */ private boolean ignoreInvalidFields = true; /** * 构造方法，属性前缀和配置类的Bean是通过构造方法传入进来的。 * * @param prefix the prefix of Configuration Properties * @param beanName the binding Bean Name */ public DubboConfigBindingBeanPostProcessor(String prefix, String beanName) &#123; Assert.notNull(prefix, \"The prefix of Configuration Properties must not be null\"); Assert.notNull(beanName, \"The name of bean must not be null\"); this.prefix = prefix; this.beanName = beanName; &#125; /** * Bean后处理器的 前置处理方法。将配置属性绑定到Dubbo Config中 * * @param bean * @param beanName * @return * @throws BeansException */ @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; // 选择bean的名称是 this.beanName【针对注解机制创建Bean定义，其他方式创建的Bean定义不符合条件】，并且是AbstractConfig类型的 Bean定义 if (beanName.equals(this.beanName) &amp;&amp; bean instanceof AbstractConfig) &#123; AbstractConfig dubboConfig = (AbstractConfig) bean; // 设置prefix开头的配置属性到 DubboConfig中 dubboConfigBinder.bind(prefix, dubboConfig); if (log.isInfoEnabled()) &#123; log.info(\"The properties of bean [name : \" + beanName + \"] have been binding by prefix of \" + \"configuration properties : \" + prefix); &#125; &#125; return bean; &#125; /** * Bean后处理器的后置处理方法，这里直接返回Dubbo Config的Bean对象，不做其他的处理 * * @param bean * @param beanName * @return * @throws BeansException */ @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; /** * 设置 Dubbo 配置属性绑定器，注意它的触发时机。 * * @throws Exception */ @Override public void afterPropertiesSet() throws Exception &#123; // 获得DubboConfigBinder对象 if (dubboConfigBinder == null) &#123; try &#123; dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class); &#125; catch (BeansException ignored) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"DubboConfigBinder Bean can't be found in ApplicationContext.\"); &#125; // Use Default implementation // 创建默认的配置绑定器 dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment()); &#125; &#125; // 设置 是否忽略未知/无效的属性 dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields); dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields); &#125; /** * Create &#123;@link DubboConfigBinder&#125; instance. * * @param environment * @return &#123;@link DefaultDubboConfigBinder&#125; */ protected DubboConfigBinder createDubboConfigBinder(Environment environment) &#123; // 创建DefaultDubboConfigBinder对象 DefaultDubboConfigBinder defaultDubboConfigBinder = new DefaultDubboConfigBinder(); // 设置environment属性 defaultDubboConfigBinder.setEnvironment(environment); return defaultDubboConfigBinder; &#125; public boolean isIgnoreUnknownFields() &#123; return ignoreUnknownFields; &#125; public void setIgnoreUnknownFields(boolean ignoreUnknownFields) &#123; this.ignoreUnknownFields = ignoreUnknownFields; &#125; public boolean isIgnoreInvalidFields() &#123; return ignoreInvalidFields; &#125; public void setIgnoreInvalidFields(boolean ignoreInvalidFields) &#123; this.ignoreInvalidFields = ignoreInvalidFields; &#125; public DubboConfigBinder getDubboConfigBinder() &#123; return dubboConfigBinder; &#125; public void setDubboConfigBinder(DubboConfigBinder dubboConfigBinder) &#123; this.dubboConfigBinder = dubboConfigBinder; &#125;&#125; Dubbo Config的属性绑定后置处理器逻辑不算复杂，就是从Spring环境中获取配置属性，然后利用Spring的数据绑定器DataBinder完成Dubbo Config的Bean属性的绑定，逻辑如下： 12345678910111213141516171819202122/** * Default &#123;@link DubboConfigBinder&#125; implementation based on Spring &#123;@link DataBinder&#125; * &lt;p&gt; * 使用Spring DataBinder，将配置属性设置到Dubbo Config对象中 */public class DefaultDubboConfigBinder extends AbstractDubboConfigBinder &#123; @Override public &lt;C extends AbstractConfig&gt; void bind(String prefix, C dubboConfig) &#123; // 将Dubbo Config包装成 DataBinder对象 DataBinder dataBinder = new DataBinder(dubboConfig); // 是否忽略无效和未知属性 dataBinder.setIgnoreInvalidFields(isIgnoreInvalidFields()); dataBinder.setIgnoreUnknownFields(isIgnoreUnknownFields()); // 从PropertySources中获取prefix开头的配置属性 [getPropertySources() : 系统属性，系统环境和@ProperSources的属性k-v] Map&lt;String, Object&gt; properties = getSubProperties(getPropertySources(), prefix); // 根据配置属性集合 创建 MutablePropertyValues对象 MutablePropertyValues propertyValues = new MutablePropertyValues(properties); // 绑定配置属性到 Dubbo的配置对象中 dataBinder.bind(propertyValues); &#125;&#125; 在Spring的后置处理器的方法中会调用 DefaultDubboConfigBinder#bind方法进行Dubbo Config的Bean的属性设置，本质是使用Spring的DataBinder完成属性设置。至此，@EnableDubboConfigBindings涉及的处理逻辑分析完毕，这个过程创建了Dubbo Config的Bean，并且创建了该Bean对应的属性绑定Bean后置处理器，在Spring的生命周期中该Bean后置处理器会回调对应的方法以完成属性的绑定。接下来我们再来分析 @EnableDubboConfigBinding 注解，该注解是 @EnableDubboConfigBindings 注解的属性数组的类型， @EnableDubboConfigBindings 注解的逻辑处理基本就是 @EnableDubboConfigBinding 注解的逻辑处理。 @EnableDubboConfigBinding 注解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Enables Spring's annotation-driven &#123;@link AbstractConfig Dubbo Config&#125; from &#123;@link PropertySources properties&#125;. * &lt;p&gt; * Default , &#123;@link #prefix()&#125; associates with a prefix of &#123;@link PropertySources properties&#125;, e,g. \"dubbo.application.\" * or \"dubbo.application\" * &lt;pre class=\"code\"&gt; * &lt;/pre&gt; * * @see DubboConfigBindingRegistrar * @see DubboConfigBindingBeanPostProcessor * @see EnableDubboConfigBindings * @since 2.5.8 */@Target(&#123;ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(DubboConfigBindingRegistrar.class)public @interface EnableDubboConfigBinding &#123; /** * 配置属性的前缀，用于映射到 AbstractConfig 中的属性 * &lt;p&gt; * The name prefix of the properties that are valid to bind to &#123;@link AbstractConfig Dubbo Config&#125;. * * @return the name prefix of the properties to bind */ String prefix(); /** * Dubbo Config 配置类，这是一个约定，Dubbo Config配置类有哪些是固定的，这个配置必须是AbstractConfig的实现子类。 * * @return The binding type of &#123;@link AbstractConfig Dubbo Config&#125;. * @see AbstractConfig * @see ApplicationConfig * @see ModuleConfig * @see RegistryConfig */ Class&lt;? extends AbstractConfig&gt; type(); /** * 是否支持配置用于多个Bean * * It indicates whether &#123;@link #prefix()&#125; binding to multiple Spring Beans. * * @return the default value is &lt;code&gt;false&lt;/code&gt; */ boolean multiple() default false;&#125; 该注解有三个属性，每个属性的作用已经注释过了，我们直接来看 @Import(DubboConfigBindingRegistrar.class)，DubboConfigBindingRegistrar的主要逻辑已经在上面分析过了，我们在简单看下没有分析到的代码。 12345678910111213141516171819202122232425262728/** * &#123;@link AbstractConfig Dubbo Config&#125; binding Bean registrar * * @see EnableDubboConfigBinding * @see DubboConfigBindingBeanPostProcessor * @since 2.5.8 * &lt;p&gt; * 处理 @EnableDubboConfigBinding 注解，注册相应的 Dubbo AbstractConfig 到Spring 容器 */public class DubboConfigBindingRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; private final Log log = LogFactory.getLog(getClass()); private ConfigurableEnvironment environment; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; // 获得 @EnableDubboConfigBinding注解信息 AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBinding.class.getName())); // 根据 @EnableDubboConfigBinding注解信息 注册配置对应的 BeanDefinition 对象 registerBeanDefinitions(attributes, registry); &#125; // $&#123;省略其他代码&#125;&#125; 至此，@EnableDubboConfig 注解已经分析完了，该注解就是用于开启Dubbo的配置，创建Dubbo框架内置的配置类的Bean，并且创建配置类的Bean对应的属性绑定Bean后置处理器，Spring应用上下文启动后，就可以实现配置对象的创建与初始化。但是需要注意的是，并不是指定了配置类就会创建对应的Bean，只有当规约的外部配置存在时，配置类才会提升为Spring Bean。 Dubbo配置Bean绑定及自定义配置Bean绑定这块内容还是不少的，这里就不详细说明了。我们直接看 Dubbo PMC 的文章 Dubbo 新编程模型之外部化配置，里面详细介绍了多配置Bean的属性绑定以及自定义Bean的属性绑定。 @DubboComponentScan 注解该注解用于配置要扫描 @Service 和 @Reference 注解的包或类，进而创建对应的Bean对象。注解扫描是委托给Spring的，本质上使用ASM库进行字节码扫描注解元数据。当用户使用注解 @DubboComponentScan 时，会激活 DubboComponentScanRegistrar，这个类就是实现服务提供者通过注解 @Service 进行服务暴露的，对消费者通过注解 @Reference 进行服务引用的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Dubbo Component Scan &#123;@link Annotation&#125;,scans the classpath for annotated components that will be auto-registered as * Spring beans. Dubbo-provided &#123;@link Service&#125; and &#123;@link Reference&#125;. * * @see Service * @see Reference * @since 2.5.7 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(DubboComponentScanRegistrar.class)public @interface DubboComponentScan &#123; /** * Alias for the &#123;@link #basePackages()&#125; attribute. Allows for more concise annotation * declarations e.g.: &#123;@code @DubboComponentScan(\"org.my.pkg\")&#125; instead of * &#123;@code @DubboComponentScan(basePackages=\"org.my.pkg\")&#125;. * * @return the base packages to scan * * 和 basePackages 等价 * */ String[] value() default &#123;&#125;; /** * Base packages to scan for annotated @Service classes. &#123;@link #value()&#125; is an * alias for (and mutually exclusive with) this attribute. * &lt;p&gt; * Use &#123;@link #basePackageClasses()&#125; for a type-safe alternative to String-based * package names. * * @return the base packages to scan * * 要扫描包的数组 * */ String[] basePackages() default &#123;&#125;; /** * Type-safe alternative to &#123;@link #basePackages()&#125; for specifying the packages to * scan for annotated @Service classes. The package of each class specified will be * scanned. * * @return classes from the base packages to scan * * 要扫描的类的数组 * */ Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;&#125; 该注解的属性作用已经注释，我们重点关注下@Import的value属性值 DubboComponentScanRegistrar ，它用于处理DubboComponentScan注解，为Spring容器注册ServiceAnnotation和ReferenceAnnotation的Bean后置处理器，进而创建ServiceBean和ReferenceBean对象。下面我们就来详细分析Dubbo注解实现的这个核心类。 DubboComponentScanRegistrar1234567891011121314151617181920212223242526272829303132333435/** * Dubbo &#123;@link DubboComponentScan&#125; Bean Registrar * * @see Service * @see DubboComponentScan * @see ImportBeanDefinitionRegistrar * @see ServiceAnnotationBeanPostProcessor * @see ReferenceAnnotationBeanPostProcessor * @since 2.5.7 * */public class DubboComponentScanRegistrar implements ImportBeanDefinitionRegistrar &#123; /** * @param importingClassMetadata @DubboComponentScan 注解的信息 * @param registry Bean定义注册表 */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; /** * 1. 获得要扫描的包 */ Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata); /** * 2. 创建 ServiceAnnotationBeanPostProcessor Bean 对象，后续扫描 `@Service` 注解的类，创建对应的 Service Bean 对象 */ registerServiceAnnotationBeanPostProcessor(packagesToScan, registry); /** * 3. 创建 ReferenceAnnotationBeanPostProcessor Bean 对象，后续扫描 `@Reference` 注解的类，创建对应的 Reference Bean 对象 */ registerReferenceAnnotationBeanPostProcessor(registry); &#125; // $&#123;省略其他的代码&#125;&#125; DubboComponentScanRegistrar 实现 ImportBeanDefinitionRegistrar接口，用来处理 @DubboComponentScan注解，注册 ServiceAnnotationBeanPostProcessor 和 ReferenceAnnotationBeanPostProcessor 到Spring容器，Spring应用上下文启动后，就可以实现Service Bean对象和Reference Bean对象的创建。下面我们依次分析以上三个步骤的具体逻辑。 获取要扫描的包123456789101112131415161718192021222324252627282930313233343536373839public class DubboComponentScanRegistrar implements ImportBeanDefinitionRegistrar &#123; // $&#123;省略其他代码&#125; /** * 获得 DubboComponentScan注解扫描的包 * * @param metadata * @return */ private Set&lt;String&gt; getPackagesToScan(AnnotationMetadata metadata) &#123; // 获得 @DubboComponentScan 注解 AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(DubboComponentScan.class.getName())); // 获得basePackages 属性值 String[] basePackages = attributes.getStringArray(\"basePackages\"); // 获得basePackageClasses属性值 Class&lt;?&gt;[] basePackageClasses = attributes.getClassArray(\"basePackageClasses\"); // 获得默认属性（basePackages的默认属性） String[] value = attributes.getStringArray(\"value\"); // 将属性添加到 packagesToScan 集合中 Set&lt;String&gt; packagesToScan = new LinkedHashSet&lt;String&gt;(Arrays.asList(value)); packagesToScan.addAll(Arrays.asList(basePackages)); // 处理 扫描的类的数组 ，得到每个类的包名，然后添加到 包路径数组中 for (Class&lt;?&gt; basePackageClass : basePackageClasses) &#123; packagesToScan.add(ClassUtils.getPackageName(basePackageClass)); &#125; // packagesToScan 为空的话，则默认使用DubboComponentScan注解类所在的包做为扫描包 if (packagesToScan.isEmpty()) &#123; return Collections.singleton(ClassUtils.getPackageName(metadata.getClassName())); &#125; return packagesToScan; &#125; // $&#123;省略其他代码&#125;&#125; 获取要扫描的包逻辑还是很直观的，将配置的扫描包路径和配置的扫描类对应的包路径聚合在一起作为目标包路径，需要注意的是当配置扫描类时需要获取扫描类的包名，即还是会转为包扫描。如果没有配置扫描包及扫描类，那么就是使用DubboComponentScan注解类所在的包做为扫描包。 创建扫描 @Service 注解的后置处理器1234567891011121314151617181920212223242526272829public class DubboComponentScanRegistrar implements ImportBeanDefinitionRegistrar &#123; // $&#123;省略其他代码&#125; /** * Registers &#123;@link ServiceAnnotationBeanPostProcessor&#125; * * @param packagesToScan packages to scan without resolving placeholders * @param registry &#123;@link BeanDefinitionRegistry&#125; * @since 2.5.8 * &lt;p&gt; * 创建 ServiceAnnotationBeanPostProcessor Bean 对象，后续扫描 @Service 注解的类，创建对应的 Service Bean 对象 */ private void registerServiceAnnotationBeanPostProcessor(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry) &#123; // 创建ServiceAnnotationBeanPostProcessor的BeanDefinitionBuilder 对象 BeanDefinitionBuilder builder = rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class); // 设置构造方法参数为 packagesToScan builder.addConstructorArgValue(packagesToScan); // 设置 role 属性 builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); // 获得 AbstractBeanDefinition 对象 AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); // 注册到注册表中 BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry); &#125; // $&#123;省略其他代码&#125;&#125; 创建扫描 @Service 注解的类的后置处理器逻辑很简单，就是创建一个Bean定义然后注册到注册表中。下面我们重点分析这个后置处理的逻辑，看它是如何将 @Service 标注的类提升为Spring Bean的。 ServiceAnnotationBeanPostProcessor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * &#123;@link Service&#125; Annotation * &#123;@link BeanDefinitionRegistryPostProcessor Bean Definition Registry Post Processor&#125; * * @since 2.5.8 */public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; private final Logger logger = LoggerFactory.getLogger(getClass()); /** * 要扫描的包的集合，通过构造方法进行设置 */ private final Set&lt;String&gt; packagesToScan; /** * 环境 */ private Environment environment; /** * 资源加载器 */ private ResourceLoader resourceLoader; /** * 类加载器 */ private ClassLoader classLoader; public ServiceAnnotationBeanPostProcessor(String... packagesToScan) &#123; this(Arrays.asList(packagesToScan)); &#125; public ServiceAnnotationBeanPostProcessor(Collection&lt;String&gt; packagesToScan) &#123; this(new LinkedHashSet&lt;String&gt;(packagesToScan)); &#125; public ServiceAnnotationBeanPostProcessor(Set&lt;String&gt; packagesToScan) &#123; this.packagesToScan = packagesToScan; &#125; // $&#123;省略其他逻辑代码&#125; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; &#125; @Override public void setEnvironment(Environment environment) &#123; this.environment = environment; &#125; @Override public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; @Override public void setBeanClassLoader(ClassLoader classLoader) &#123; this.classLoader = classLoader; &#125; ServiceAnnotationBeanPostProcessor 实现 BeanDefinitionRegistryPostProcessor、EnvironmentAware、ResourceLoaderAware、BeanClassLoaderAware 接口，具备了Spring的特定功能，如Spring容器中所有Bean注册之后回调 postProcessBeanDefinitionRegistry 方法。该类主要是将 @Service 标注的类提升为Spring Bean，主要的逻辑如下： 解析扫描包集合，处理存在占位符的包名。 创建DubboClassPathBeanDefinitionScanner对象，用于扫描指定包下的 @Service 标注的类并注册该类的Bean定义到注册表。 为每个@Service标注的类创建对应的 ServiceBean，并注册到注册表。 解析扫描包集合 123456789101112131415161718192021222324252627public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; // $&#123;省略其他代码&#125; /** * * @param registry 注册表 * @throws BeansException */ @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123; // 解析 packagesToScan集合，包名可能存在占位符的情况 Set&lt;String&gt; resolvedPackagesToScan = resolvePackagesToScan(packagesToScan); if (!CollectionUtils.isEmpty(resolvedPackagesToScan)) &#123; // 扫描 packagesToScan 包，创建对应的 Spring BeanDefinition 对象，从而触发 Dubbo ServiceBean 定义和注册 registerServiceBeans(resolvedPackagesToScan, registry); &#125; else &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"packagesToScan is empty , ServiceBean registry will be ignored!\"); &#125; &#125; &#125; // $&#123;省略其他代码&#125;&#125; 上面的代码主要处理包名存在占位符的情况，同时上面的方法也是Spring的Bean后处理器的回调方法，在Spring的生命周期内进行回调。接下我们看扫描Dubbo的 @Service 注解的逻辑。 扫描Dubbo的 @Service 注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; // $&#123;省略其他代码&#125; /** * 扫描 packagesToScan 包，创建对应的 Spring BeanDefinition 对象，从而创建 Dubbo Service Bean 对象 * &lt;p&gt; * Registers Beans whose classes was annotated &#123;@link Service&#125; * * @param packagesToScan 要扫描的包集合 * @param registry 注册表 */ private void registerServiceBeans(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry) &#123; // 创建 Dubbo的类路径Bean定义扫描对象，该类继承了Spring的 ClassPathBeanDefinitionScanner，即用于扫描指定包下符合条件的类，将符合条件的类创建对应的BeanDefinition对象 DubboClassPathBeanDefinitionScanner scanner = new DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader); // 获得 BeanNameGenerator 对象，并设置 beanNameGenerator 到 scanner 中 BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry); scanner.setBeanNameGenerator(beanNameGenerator); // 指定扫描器扫描带有Dubbo的@Service注解的类，不会扫描Spring的@Service注解 scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class)); // 遍历扫描的包集合 for (String packageToScan : packagesToScan) &#123; // 执行扫描，并注册目标类的Bean定义到注册表，使用beanNameGenerator生成Bean的名称 scanner.scan(packageToScan); // 创建每个被扫描的类的BeanDefinitionHolder对象，返回BeanDefinitionHolder集合，用于生成ServiceBean定义【注意，这里也会创建扫描的类的Bean定义，也是使用 beanNameGenerator 生成名称，但没有注册到注册表】 Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders = findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator); // 为每个@Service标注的类创建对应的 ServiceBean，并注册到注册表。 if (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123; for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123; registerServiceBean(beanDefinitionHolder, registry, scanner); &#125; if (logger.isInfoEnabled()) &#123; logger.info(beanDefinitionHolders.size() + \" annotated Dubbo's @Service Components &#123; \" + beanDefinitionHolders + \" &#125; were scanned under package[\" + packageToScan + \"]\"); &#125; &#125; else &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"No Spring Bean annotating Dubbo's @Service was found under package[\" + packageToScan + \"]\"); &#125; &#125; &#125; &#125; // $&#123;省略其他代码&#125;&#125; 上面代码主要做了四件事情，如下： 创建类路径扫描器 DubboClassPathBeanDefinitionScanner，指定扫描的注解包含Dubbo的@Service注解。 获取BeanNameGenerator对象，用于 @Service 标注类的Bean定义名称。 使用扫描器扫描包，提升@Service标注的类为Spring Bean，并注册到注册表中。 获取第3步的Spring Bean的BeanDefinitionHolder集合，将用于创建Dubbo的ServiceBean对象。 代码中的主要逻辑已经详细标注，胖友自己瞅瞅，下面我们简单分析下扫描器的原理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105ClassPathBeanDefinitionScanner#scan(String... basePackages) &#123; int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); // 扫描逻辑 doScan(basePackages); // Register annotation config processors, if necessary. if (this.includeAnnotationConfig) &#123; AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); &#125; return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart); &#125; // 扫描包逻辑 protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, \"At least one base package must be specified\"); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) &#123; // 从包中获取候选BeanDefinition Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) &#123; ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); // 使用beanNameGenerator 生成BeanDefinition的名称 String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); &#125; // 是否是候选BeanDefinition if (checkCandidate(beanName, candidate)) &#123; BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // 注册到注册表 registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; return beanDefinitions; &#125; /** * 从包中获取BeanDefinition集合 * * Scan the class path for candidate components. * @param basePackage the package to check for annotated classes * @return a corresponding Set of autodetected bean definitions */ public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) &#123; Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try &#123; // 类路径下的指定包下的所有.class文件 （如：classpath*:com/code/resource/reading/consumer/annotation/consumer/**/*.class） String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) &#123; if (traceEnabled) &#123; logger.trace(\"Scanning \" + resource); &#125; if (resource.isReadable()) &#123; try &#123; MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); // 是否是候选 BeanDefinition if (isCandidateComponent(metadataReader)) &#123; // 创建 BeanDefinition ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (isCandidateComponent(sbd)) &#123; if (debugEnabled) &#123; logger.debug(\"Identified candidate component class: \" + resource); &#125; candidates.add(sbd); &#125; else &#123; if (debugEnabled) &#123; logger.debug(\"Ignored because not a concrete top-level class: \" + resource); &#125; &#125; &#125; else &#123; if (traceEnabled) &#123; logger.trace(\"Ignored because not matching any filter: \" + resource); &#125; &#125; &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException( \"Failed to read candidate component class: \" + resource, ex); &#125; &#125; else &#123; if (traceEnabled) &#123; logger.trace(\"Ignored because not readable: \" + resource); &#125; &#125; &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex); &#125; return candidates; &#125; 我们只要大致了解下扫描器是怎么把指定包下的注解标注的类提升为Spring Bean就可以了。有了目标类的Bean定义，接下来我们分析Dubbo是如何创建该目标类对应的ServiceBean对象的。 创建ServiceBean并注册到注册表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; // $&#123;省略其他代码&#125;/** * Registers &#123;@link ServiceBean&#125; from new annotated &#123;@link Service&#125; &#123;@link BeanDefinition&#125; * * @param beanDefinitionHolder @Service标注的类的BeanDefinitionHolder * @param registry 注册表 * @param scanner 扫描器 * @see ServiceBean * @see BeanDefinition */ private void registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry, DubboClassPathBeanDefinitionScanner scanner) &#123; // 从holder中取出BeanDefinition，并解析出对应的类 Class&lt;?&gt; beanClass = resolveClass(beanDefinitionHolder); // 获得@Service 注解 Service service = findAnnotation(beanClass, Service.class); // 获得注解标注类的接口 Class&lt;?&gt; interfaceClass = resolveServiceInterfaceClass(beanClass, service); // 获得Bean的名字 String annotatedServiceBeanName = beanDefinitionHolder.getBeanName(); // 创建AbstractBeanDefinition 对象 ，这里真正创建ServiceBean AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName); // 重新生成Bean 的名字 【格式：ServiceBean:$&#123;interfaceClassName&#125;:$&#123;version&#125;:$&#123;group&#125;】，重新创建的ServiceBean名称是把上面的BeanDefinition注册到注册表中，需要一个名称 String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName); // 校验在 注册表 中是否已经存在beanName，若不存在则进行注册 if (scanner.checkCandidate(beanName, serviceBeanDefinition)) &#123; // 注册 registry.registerBeanDefinition(beanName, serviceBeanDefinition); if (logger.isInfoEnabled()) &#123; logger.warn(\"The BeanDefinition[\" + serviceBeanDefinition + \"] of ServiceBean has been registered with name : \" + beanName); &#125; &#125; else &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"The Duplicated BeanDefinition[\" + serviceBeanDefinition + \"] of ServiceBean[ bean name : \" + beanName + \"] was be found , Did @DubboComponentScan scan to same package in many times?\"); &#125; &#125; &#125; // $&#123;省略其他代码&#125;&#125; 上面的方法主要是为创建ServiceBean提供条件，如：获取Dubbo的@Service标注类的Class及接口、获取@Service信息、获取Dubbo的@Service标注类的Bean定义的名称。有了这些信息，就可以创建目标服务类（Dubbo的@Service标注的类）的ServiceBean。在分析创建ServiceBean之前，我们先来看下目标服务类的接口获取逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; // $&#123;省略其他代码&#125; /** * 获得@Service 注解的类的接口 * * @param annotatedServiceBeanClass * @param service * @return */ private Class&lt;?&gt; resolveServiceInterfaceClass(Class&lt;?&gt; annotatedServiceBeanClass, Service service) &#123; // 从注解属性中获取 Class&lt;?&gt; interfaceClass = service.interfaceClass(); if (void.class.equals(interfaceClass)) &#123; interfaceClass = null; // 获得@Service 注解的interfaceName 属性 String interfaceClassName = service.interfaceName(); // 如果存在，获得其对应的类 if (StringUtils.hasText(interfaceClassName)) &#123; if (ClassUtils.isPresent(interfaceClassName, classLoader)) &#123; interfaceClass = resolveClassName(interfaceClassName, classLoader); &#125; &#125; &#125; //从注解属性中获得不到，则从被注解的类上获得其实现的第一个接口 if (interfaceClass == null) &#123; // 获取接口列表 Class&lt;?&gt;[] allInterfaces = annotatedServiceBeanClass.getInterfaces(); // 存在的话取第一个接口 if (allInterfaces.length &gt; 0) &#123; interfaceClass = allInterfaces[0]; &#125; &#125; Assert.notNull(interfaceClass,\"@Service interfaceClass() or interfaceName() or interface class must be present!\"); Assert.isTrue(interfaceClass.isInterface(),\"The type that was annotated @Service is not an interface!\"); return interfaceClass; &#125; // $&#123;省略其他代码&#125;&#125; 获取目标服务类的接口规则是先从@Service注解属性中取，没有设置再获取目标服务类的第一个实现接口。下面我们来分析下ServiceBean的定义如何生成，可以对比下XML配置的生成规则。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; // $&#123;省略其他代码&#125;/** * 创建AbstraceBeanDefinition对象 * * @param service @Service 注解 * @param interfaceClass 目标服务类的接口 * @param annotatedServiceBeanName 目标服务类的Bean定义的名称 * @return */ private AbstractBeanDefinition buildServiceBeanDefinition(Service service, Class&lt;?&gt; interfaceClass, String annotatedServiceBeanName) &#123; // 创建ServiceBean的BeanDefinitionBuilder对象 BeanDefinitionBuilder builder = rootBeanDefinition(ServiceBean.class); // 获得ServiceBean的AbstractBeanDefinition 对象 AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); // 获得 MutablePropertyValues对象，后续可以通过它为ServiceBean添加属性 MutablePropertyValues propertyValues = beanDefinition.getPropertyValues(); // 创建AnnotationPropertyValuesAdapter 对象，添加到propertyValues中。注意是将注解上的属性设置到PropertyValues中，并且指定哪些属性要忽略。被忽略的属性会单独设置。 String[] ignoreAttributeNames = of(\"provider\", \"monitor\", \"application\", \"module\", \"registry\", \"protocol\", \"interface\"); propertyValues.addPropertyValues(new AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames)); // 设置ServiceBean ref 属性，即@Service标注的类的Bean定义名称 addPropertyReference(builder, \"ref\", annotatedServiceBeanName); // 设置ServiceBean的 interface 属性 builder.addPropertyValue(\"interface\", interfaceClass.getName()); // 添加ServiceBean的 provider 属性 String providerConfigBeanName = service.provider(); if (StringUtils.hasText(providerConfigBeanName)) &#123; addPropertyReference(builder, \"provider\", providerConfigBeanName); &#125; // 添加ServiceBean的monitor属性 String monitorConfigBeanName = service.monitor(); if (StringUtils.hasText(monitorConfigBeanName)) &#123; addPropertyReference(builder, \"monitor\", monitorConfigBeanName); &#125; // 添加ServiceBean 的 application 属性 String applicationConfigBeanName = service.application(); if (StringUtils.hasText(applicationConfigBeanName)) &#123; addPropertyReference(builder, \"application\", applicationConfigBeanName); &#125; // 添加ServiceBean的 module 属性对应的 ModuleConfig Bean 对象 String moduleConfigBeanName = service.module(); if (StringUtils.hasText(moduleConfigBeanName)) &#123; addPropertyReference(builder, \"module\", moduleConfigBeanName); &#125; //-------------- 下面两个属性和上面的不一样，因为可能会有多个 ，即多注册中心，多协议的情况-------------------/ // 添加ServiceBean的 registries 属性 String[] registryConfigBeanNames = service.registry(); List&lt;RuntimeBeanReference&gt; registryRuntimeBeanReferences = toRuntimeBeanReferences(registryConfigBeanNames); if (!registryRuntimeBeanReferences.isEmpty()) &#123; builder.addPropertyValue(\"registries\", registryRuntimeBeanReferences); &#125; // 添加ServiceBean的 protocols 属性 String[] protocolConfigBeanNames = service.protocol(); List&lt;RuntimeBeanReference&gt; protocolRuntimeBeanReferences = toRuntimeBeanReferences(protocolConfigBeanNames); if (!protocolRuntimeBeanReferences.isEmpty()) &#123; builder.addPropertyValue(\"protocols\", protocolRuntimeBeanReferences); &#125; return builder.getBeanDefinition(); &#125; // $&#123;省略其他代码&#125;&#125; 上面的代码就是为ServiceBean设置简单属性值和引用类型的值，当ServiceBean的属性是引用类型时，解析器会依据依赖bean的name创建一个RuntimeBeanReference对像，将这个对像放入ServiceBean的BeanDefinition的MutablePropertyValues中。ServiceBean的Bean定义创建完成后，接着就把该Bean定义注册到注册表中。至此，扫描 @Service 注解的Bean后置处理器逻辑已经分析完毕。下面我们开始分析扫描 @Reference 注解的后置处理器。 创建扫描 @Reference 注解的后置处理器123456789101112131415161718public class DubboComponentScanRegistrar implements ImportBeanDefinitionRegistrar &#123; // $&#123;省略其他代码&#125; /** * Registers &#123;@link ReferenceAnnotationBeanPostProcessor&#125; into &#123;@link BeanFactory&#125; * * @param registry &#123;@link BeanDefinitionRegistry&#125; */ private void registerReferenceAnnotationBeanPostProcessor(BeanDefinitionRegistry registry) &#123; // Register @Reference Annotation Bean Processor BeanRegistrar.registerInfrastructureBean(registry, ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor.class); &#125; // $&#123;省略其他代码&#125;&#125; 创建扫描 @Reference 注解的后置处理器需要注意该Bean定义的名称是 referenceAnnotationBeanPostProcessor，是常量维护的。下面我们开始分析ReferenceAnnotationBeanPostProcessor的逻辑，看它又是如何为 @Reference 注解的属性或方法引入代理对象。 ReferenceAnnotationBeanPostProcessor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * &#123;@link org.springframework.beans.factory.config.BeanPostProcessor&#125; implementation * that Consumer service &#123;@link Reference&#125; annotated fields * @since 2.5.7 */public class ReferenceAnnotationBeanPostProcessor extends AnnotationInjectedBeanPostProcessor&lt;Reference&gt; implements ApplicationContextAware, ApplicationListener &#123; /** * The bean name of &#123;@link ReferenceAnnotationBeanPostProcessor&#125; */ public static final String BEAN_NAME = \"referenceAnnotationBeanPostProcessor\"; /** * Cache size */ private static final int CACHE_SIZE = Integer.getInteger(BEAN_NAME + \".cache.size\", 32); /** * ReferenceBean 缓存 Map,key:Reference Bean 的名字 */ private final ConcurrentMap&lt;String, ReferenceBean&lt;?&gt;&gt; referenceBeanCache = new ConcurrentHashMap&lt;String, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE); /** * ReferenceBeanInvocationHandler 缓存 Map，key：Reference Bean的名字 */ private final ConcurrentHashMap&lt;String, ReferenceBeanInvocationHandler&gt; localReferenceBeanInvocationHandlerCache = new ConcurrentHashMap&lt;String, ReferenceBeanInvocationHandler&gt;(CACHE_SIZE); /** * 使用属性进行注入的 @Reference Bean 的缓存 Map。（这种方式使用的较多） */ private final ConcurrentMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; injectedFieldReferenceBeanCache = new ConcurrentHashMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE); /** * 使用方法进行注入的 @Reference Bean 的缓存 Map */ private final ConcurrentMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; injectedMethodReferenceBeanCache = new ConcurrentHashMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE); /** * 应用上下文 */ private ApplicationContext applicationContext; /** * Gets all beans of &#123;@link ReferenceBean&#125; * * @return non-null read-only &#123;@link Collection&#125; * @since 2.5.9 */ public Collection&lt;ReferenceBean&lt;?&gt;&gt; getReferenceBeans() &#123; return referenceBeanCache.values(); &#125; /** * Get &#123;@link ReferenceBean&#125; &#123;@link Map&#125; in injected field. * * @return non-null &#123;@link Map&#125; * @since 2.5.11 */ public Map&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; getInjectedFieldReferenceBeanMap() &#123; return Collections.unmodifiableMap(injectedFieldReferenceBeanCache); &#125; /** * Get &#123;@link ReferenceBean&#125; &#123;@link Map&#125; in injected method. * * @return non-null &#123;@link Map&#125; * @since 2.5.11 */ public Map&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; getInjectedMethodReferenceBeanMap() &#123; return Collections.unmodifiableMap(injectedMethodReferenceBeanCache); &#125; // $&#123;省略其他代码&#125;&#125; 上面代码是扫描 @Reference 注解的后置处理器的属性信息，该类继承了AnnotationInjectedBeanPostProcessor抽象类，该类中有几个很重要的方法和类，它们属于Spring源码的知识点，为了使整个逻辑完整我们还是一起来看看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public abstract class AnnotationInjectedBeanPostProcessor&lt;A extends Annotation&gt; extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware, BeanClassLoaderAware, EnvironmentAware, DisposableBean &#123; // $&#123;省略其他的代码&#125; // 1. Bean后置处理器的回调方法 @Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123; if (beanType != null) &#123; // 获取BeanType中的字段和方法上的注解，即对于Dubbo框架来说就是查找Bean所有标注了@Reference的字段和方法。 InjectionMetadata metadata = findInjectionMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); &#125; &#125; // 5. 创建Bean对象的过程中需要填充Bean对象的属性值，会调用该方法。即在Spring的Bean初始化前会触发该方法。 @Override public PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException &#123; // 获取Bean对象的类中的字段和方法的注解对象 - AnnotatedInjectionMetadata，即对于Dubbo框架来说就是查找Bean所有标注了@Reference的字段和方法。 InjectionMetadata metadata = findInjectionMetadata(beanName, bean.getClass(), pvs); try &#123; // 调用AnnotatedInjectionMetadata的inject方法，对字段或方法进行反射绑定 metadata.inject(bean, beanName, pvs); &#125; catch (BeanCreationException ex) &#123; throw ex; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, \"Injection of @\" + getAnnotationType().getName() + \" dependencies is failed\", ex); &#125; return pvs; &#125; /** * 4. 属性和方法注解包装对象 * &#123;@link A&#125; &#123;@link InjectionMetadata&#125; implementation */ private class AnnotatedInjectionMetadata extends InjectionMetadata &#123; // 字段注解对象集合 private final Collection&lt;AnnotatedFieldElement&gt; fieldElements; // 方法注解对象集合 private final Collection&lt;AnnotatedMethodElement&gt; methodElements; public AnnotatedInjectionMetadata(Class&lt;?&gt; targetClass, Collection&lt;AnnotatedFieldElement&gt; fieldElements, Collection&lt;AnnotatedMethodElement&gt; methodElements) &#123; super(targetClass, combine(fieldElements, methodElements)); this.fieldElements = fieldElements; this.methodElements = methodElements; &#125; public Collection&lt;AnnotatedFieldElement&gt; getFieldElements() &#123; return fieldElements; &#125; public Collection&lt;AnnotatedMethodElement&gt; getMethodElements() &#123; return methodElements; &#125; &#125; /** * 3. 方法注解 * &#123;@link A&#125; &#123;@link Method&#125; &#123;@link InjectionMetadata.InjectedElement&#125; */ private class AnnotatedMethodElement extends InjectionMetadata.InjectedElement &#123; // 方法对象 private final Method method; // 注解 private final A annotation; private volatile Object object; protected AnnotatedMethodElement(Method method, PropertyDescriptor pd, A annotation) &#123; super(method, pd); this.method = method; this.annotation = annotation; &#125; @Override protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable &#123; // 获取属性类型 Class&lt;?&gt; injectedType = pd.getPropertyType(); // H偶去依赖 Object injectedObject = getInjectedObject(annotation, bean, beanName, injectedType, this); // 设置可访问 ReflectionUtils.makeAccessible(method); // 反射注入依赖 method.invoke(bean, injectedObject); &#125; &#125; /** * 2. 属性注解 * &#123;@link A&#125; &#123;@link Field&#125; &#123;@link InjectionMetadata.InjectedElement&#125; */ public class AnnotatedFieldElement extends InjectionMetadata.InjectedElement &#123; // 属性对象 private final Field field; // 注解 private final A annotation; private volatile Object bean; protected AnnotatedFieldElement(Field field, A annotation) &#123; super(field, null); this.field = field; this.annotation = annotation; &#125; @Override protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable &#123; // 获取属性类型 Class&lt;?&gt; injectedType = field.getType(); // 获取依赖 Object injectedObject = getInjectedObject(annotation, bean, beanName, injectedType, this); // 设置可访问 ReflectionUtils.makeAccessible(field); // 反射设置值 field.set(bean, injectedObject); &#125; &#125;&#125;public class InjectionMetadata &#123; // $&#123;省略其他代码&#125; // 3. 遍历注入元素对象（可能是字段，也可能是方法），完成注入 public void inject(Object target, String beanName, PropertyValues pvs) throws Throwable &#123; // Collection&lt;InjectedElement&gt; elementsToIterate = (this.checkedElements != null ? this.checkedElements : this.injectedElements); if (!elementsToIterate.isEmpty()) &#123; boolean debug = logger.isDebugEnabled(); for (InjectedElement element : elementsToIterate) &#123; if (debug) &#123; logger.debug(\"Processing injected element of bean '\" + beanName + \"': \" + element); &#125; element.inject(target, beanName, pvs); &#125; &#125; &#125;&#125; 上面的代码执行的顺序已经标注，执行顺序比较粗略，先查找服务引用的字段或方法，然后触发字段或方法值的反射注入。但是目的已经达到了，从代码中我们可以看出注解信息已经收集完毕，接下来就是获取依赖对象了，找到依赖对象就可以通过反射注入，对于@Reference注解而言，获取依赖的方法就是 ReferenceAnnotationBeanPostProcessor#doGetInjectedBean。下面我们开始分析 ReferenceAnnotationBeanPostProcessor 中的逻辑。 获取要注入的依赖Bean 123456789101112131415161718192021222324252627282930313233343536373839public class ReferenceAnnotationBeanPostProcessor extends AnnotationInjectedBeanPostProcessor&lt;Reference&gt; implements ApplicationContextAware, ApplicationListener &#123; // $&#123;省略代码&#125; /** * 获得要注入的 依赖 * * @param reference @Reference注解 * @param bean @Reference注解标注属性或方法所在的类的对象 * @param beanName @Reference注解标注属性或方法所在的类的对象名称 * @param injectedType 要注入依赖的类型 * @param injectedElement 注入元信息 * @return * @throws Exception */ @Override protected Object doGetInjectedBean(Reference reference, Object bean, String beanName, Class&lt;?&gt; injectedType, InjectionMetadata.InjectedElement injectedElement) throws Exception &#123; // 1 获得要注入依赖的名字 String referencedBeanName = buildReferencedBeanName(reference, injectedType); // 2 创建ReferenceBean 对象 [比较复杂] ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referencedBeanName, reference, injectedType, getClassLoader()); // 3 缓存到 injectedFieldReferenceBeanCache 或 injectedMethodReferenceBeanCache cacheInjectedReferenceBean(referenceBean, injectedElement); // 4 创建 Proxy 代理 Object proxy = buildProxy(referencedBeanName, referenceBean, injectedType); return proxy; &#125;// $&#123;省略代码&#125;&#125; doGetInjectedBean 方法主要完成以上4个流程，我们重点分析创建ReferenceBean和Proxy代理流程。 创建ReferenceBean对象 123456789101112131415161718192021222324252627282930313233343536public class ReferenceAnnotationBeanPostProcessor extends AnnotationInjectedBeanPostProcessor&lt;Reference&gt; implements ApplicationContextAware, ApplicationListener &#123; // $&#123;省略代码&#125;/** * 获得 ReferenceBean 对象 * * @param referencedBeanName * @param reference * @param referencedType * @param classLoader * @return * @throws Exception */ private ReferenceBean buildReferenceBeanIfAbsent(String referencedBeanName, Reference reference, Class&lt;?&gt; referencedType, ClassLoader classLoader) throws Exception &#123; // 先从缓存中获得referencedBeanName 对应的 ReferenceBean 对象 ReferenceBean&lt;?&gt; referenceBean = referenceBeanCache.get(referencedBeanName); // 如果不存在，则进行创建，然后添加到缓存中 if (referenceBean == null) &#123; ReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder .create(reference, classLoader, applicationContext) // 引用类型作为接口类型 .interfaceClass(referencedType); // 创建ReferenceBean【1. 创建ReferenceBean对象 2.ReferenceBean 配置】 referenceBean = beanBuilder.build(); referenceBeanCache.put(referencedBeanName, referenceBean); &#125; return referenceBean; &#125;// $&#123;省略代码&#125;&#125; buildReferenceBeanIfAbsent 方法基本没有核心逻辑，所有的逻辑都封装在了 ReferenceBeanBuilder 中，它是ReferenceBean的构建器，我们继续跟进该类。 ReferenceBean对象的构建器 12345678910111213141516171819202122232425262728class ReferenceBeanBuilder extends AbstractAnnotationConfigBeanBuilder&lt;Reference, ReferenceBean&gt; &#123; /** * 将注解的属性设置到ReferenceBean，忽略以下属性，这些属性会单独处理 */ static final String[] IGNORE_FIELD_NAMES = of(\"application\", \"module\", \"consumer\", \"monitor\", \"registry\"); private ReferenceBeanBuilder(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext) &#123; super(annotation, classLoader, applicationContext); &#125; // $&#123;省略其他代码&#125; /** * 创建ReferenceBeanBuilder * * @param annotation * @param classLoader * @param applicationContext * @return */ public static ReferenceBeanBuilder create(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext) &#123; // 创建 ReferenceBean 的构建器 return new ReferenceBeanBuilder(annotation, classLoader, applicationContext); &#125;&#125;` 由于很多属性都在其父类 AbstractAnnotationConfigBeanBuilder 中，如上面的interfaceClass，以及很重要的build方法。我们再分析下该类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950abstract class AbstractAnnotationConfigBeanBuilder&lt;A extends Annotation, B extends AbstractInterfaceConfig&gt; &#123; protected final Log logger = LogFactory.getLog(getClass()); /** * 注解 */ protected final A annotation; /** * 应用上下文 */ protected final ApplicationContext applicationContext; /** * 类加载器 */ protected final ClassLoader classLoader; /** * Bean 对象 */ protected Object bean; /** * 接口 */ protected Class&lt;?&gt; interfaceClass; // 构造方法 protected AbstractAnnotationConfigBeanBuilder(A annotation, ClassLoader classLoader, ApplicationContext applicationContext) &#123; Assert.notNull(annotation, \"The Annotation must not be null!\"); Assert.notNull(classLoader, \"The ClassLoader must not be null!\"); Assert.notNull(applicationContext, \"The ApplicationContext must not be null!\"); this.annotation = annotation; this.applicationContext = applicationContext; this.classLoader = classLoader; &#125; public &lt;T extends AbstractAnnotationConfigBeanBuilder&lt;A, B&gt;&gt; T bean(Object bean) &#123; this.bean = bean; return (T) this; &#125; // 设置接口 public &lt;T extends AbstractAnnotationConfigBeanBuilder&lt;A, B&gt;&gt; T interfaceClass(Class&lt;?&gt; interfaceClass) &#123; this.interfaceClass = interfaceClass; return (T) this; &#125; // $&#123;省略其他代码&#125; &#125; 以上代码比较简单，只需注意设置的接口即可，下面我们分析创建ReferenceBean的build方法。 123456789101112131415161718192021222324252627282930313233abstract class AbstractAnnotationConfigBeanBuilder&lt;A extends Annotation, B extends AbstractInterfaceConfig&gt; &#123; // $&#123;省略其他代码&#125; /** * Build &#123;@link B&#125; 构造泛型B对象，此处就是构造ReferenceBean对象 * * @return non-null * @throws Exception */ public final B build() throws Exception &#123; /** * 1. 校验依赖，目前是个空方法 */ checkDependencies(); // 2. 创建 Bean 对象，具体实现交给子类 B bean = doBuild(); // 3. 配置Bean 对象 configureBean(bean); if (logger.isInfoEnabled()) &#123; logger.info(\"The bean[type:\" + bean.getClass().getSimpleName() + \"] has been built.\"); &#125; return bean; &#125; // $&#123;省略其他代码&#125;&#125; 以上代码使用了模版方法模式，我们先看doBuild()方法的具体实现，然后再分析配置Bean对象的逻辑。 123456789101112131415161718class ReferenceBeanBuilder extends AbstractAnnotationConfigBeanBuilder&lt;Reference, ReferenceBean&gt; &#123; // $&#123;省略其他代码&#125; /** * ReferenceBeanBuilder#build的方法调用，用来创建Reference对象。【对父类方法的重写】 * * @return */ @Override protected ReferenceBean doBuild() &#123; // 创建 ReferenceBean对象 return new ReferenceBean&lt;Object&gt;(); &#125; // $&#123;省略其他代码&#125;&#125; 一行代码就搞定了，直接创建ReferenceBean对象，我们接着分析配置Bean逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243abstract class AbstractAnnotationConfigBeanBuilder&lt;A extends Annotation, B extends AbstractInterfaceConfig&gt; &#123; // $&#123;省略其他代码&#125; /** * 配置ReferenceBean对象 * @param bean * @throws Exception */ protected void configureBean(B bean) throws Exception &#123; /** * 前置配置Bean逻辑，具体实现交给子类 */ preConfigureBean(annotation, bean); /** * 尝试从Spring中获取@Reference注解中配置的registry属性值对应的RegistryConfig对象集合，然后设置到的ReferenceBean对象的registries属性中 */ configureRegistryConfigs(bean); /** * 设置ReferenceBean的monitor属性，原理同上 */ configureMonitorConfig(bean); /** * 设置ReferenceBean的application属性，原理同上 */ configureApplicationConfig(bean); /** * 设置 ReferenceBean的module属性，原理同上 */ configureModuleConfig(bean); /** * 后置配置Bean逻辑，具体实现交给子类 */ postConfigureBean(annotation, bean); &#125; // $&#123;省略其他代码&#125;&#125; 上面代码也是使用模版方法模式，其中ReferenceBean的registries、monitor、application、module属性的值是通过该方法进行设置的，前置配置Bean和后置配置Bean的逻辑是由子类实现的，我们继续跟进去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class ReferenceBeanBuilder extends AbstractAnnotationConfigBeanBuilder&lt;Reference, ReferenceBean&gt; &#123; // $&#123;省略其他代码&#125; /** * ReferenceBean 的前置配置 * @param reference * @param referenceBean */ @Override protected void preConfigureBean(Reference reference, ReferenceBean referenceBean) &#123; Assert.notNull(interfaceClass, \"The interface class must set first!\"); // 创建DataBinder对象,将ReferenceBean包装成DataBinder,进行属性绑定，绑定到的对象就是ReferenceBean DataBinder dataBinder = new DataBinder(referenceBean); // Register CustomEditors for special fields // 注册指定属性的自定义Editor dataBinder.registerCustomEditor(String.class, \"filter\", new StringTrimmerEditor(true)); dataBinder.registerCustomEditor(String.class, \"listener\", new StringTrimmerEditor(true)); dataBinder.registerCustomEditor(Map.class, \"parameters\", new PropertyEditorSupport() &#123; public void setAsText(String text) throws java.lang.IllegalArgumentException &#123; // Trim all whitespace String content = StringUtils.trimAllWhitespace(text); if (!StringUtils.hasText(content)) &#123; // No content , ignore directly return; &#125; // replace \"=\" to \",\" content = StringUtils.replace(content, \"=\", \",\"); // replace \":\" to \",\" content = StringUtils.replace(content, \":\", \",\"); // String[] to Map Map&lt;String, String&gt; parameters = CollectionUtils.toStringMap(commaDelimitedListToStringArray(content)); setValue(parameters); &#125; &#125;); /** Bind annotation attributes 将注解的属性设置到ReferenceBean中，排除 &#123;@link IGNORE_FIELD_NAMES&#125; 属性，这些属性后续单独处理 &#123;@link AbstractAnnotationConfigBeanBuilder#configureBean(com.alibaba.dubbo.config.AbstractInterfaceConfig) */ dataBinder.bind(new AnnotationPropertyValuesAdapter(reference, applicationContext.getEnvironment(), IGNORE_FIELD_NAMES)); &#125; /** * ReferenceBean 的后置配置 * * @param annotation * @param bean * @throws Exception */ @Override protected void postConfigureBean(Reference annotation, ReferenceBean bean) throws Exception &#123; // 设置 Spring 上下文到 ReferenceBean 中，并且 将 Dubbo 和 Spring容器打通，即 设置SpringExtensionFactory中的上下文 bean.setApplicationContext(applicationContext); // 配置服务接口 configureInterface(annotation, bean); // 尝试从Spring中获取@Reference注解中配置的consumer属性值对应的ConsumerConfig对象，然后设置到的ReferenceBean对象的consumer属性中 configureConsumerConfig(annotation, bean); // 主动触发 ReferenceBean 的 afterPropertiesSet 方法 bean.afterPropertiesSet(); &#125; // $&#123;省略其他代码&#125;&#125; 至此，创建ReferenceBean对象分析完毕，我们再回过头分析 ReferenceAnnotationBeanPostProcessor#doGetInjectedBean 方法中的创建 Proxy 对象的逻辑。 创建Proxy对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ReferenceAnnotationBeanPostProcessor extends AnnotationInjectedBeanPostProcessor&lt;Reference&gt; implements ApplicationContextAware, ApplicationListener &#123; // $&#123;省略代码&#125; /** * 创建Proxy代理对象 * * @param referencedBeanName * @param referenceBean * @param injectedType * @return */ private Object buildProxy(String referencedBeanName, ReferenceBean referenceBean, Class&lt;?&gt; injectedType) &#123; // 1. 创建ReferenceBeanInvocationHandler对象 InvocationHandler handler = buildInvocationHandler(referencedBeanName, referenceBean); // 2. 使用JDK的动态代理创建服务接口的代理对象 Object proxy = Proxy.newProxyInstance(getClassLoader(), new Class[]&#123;injectedType&#125;, handler); return proxy; &#125; /** * 创建ReferenceBeanInvocationHandler对象 * * @param referencedBeanName 注入依赖的名字，即服务的名称 * @param referenceBean ReferenceBean对象 * @return */ private InvocationHandler buildInvocationHandler(String referencedBeanName, ReferenceBean referenceBean) &#123; // 从缓存中获取对应的 handler对象 ReferenceBeanInvocationHandler handler = localReferenceBeanInvocationHandlerCache.get(referencedBeanName); // 不存在则创建ReferenceBean的 InvocationHandler 对象 if (handler == null) &#123; handler = new ReferenceBeanInvocationHandler(referenceBean); &#125; // 如果应用上下文中已经初始化了，说明引入的服务是本地的@Service Bean ，则将引入的Dubbo服务的InvocationHandler添加到本地缓存中，不进行初始化（要想初始化，引入的服务必须是已经暴露的状态） if (applicationContext.containsBean(referencedBeanName)) &#123; // ReferenceBeanInvocationHandler's initialization has to wait for current local @Service Bean has been exported. localReferenceBeanInvocationHandlerCache.put(referencedBeanName, handler); &#125; else &#123; // 如果应用上下文中没有，则说明是引入的是远程的服务对象，则立即初始化 handler.init(); &#125; return handler; &#125;// $&#123;省略代码&#125;&#125; 以上代码只做了一件事情，为服务接口创建一个代理对象，创建代理对象是使用JDK的动态代理。其中代理对象的执行逻辑封装在ReferenceBeanInvocationHandler对象中，下面我们就来详细分析该Handler。 ReferenceBeanInvocationHandler 1234567891011121314151617181920212223242526272829303132/** * 实现了 Dubbo 的 InvocationHandler接口 */ private static class ReferenceBeanInvocationHandler implements InvocationHandler &#123; /** * ReferenceBean对象 */ private final ReferenceBean referenceBean; /** * Bean 对象(引用的服务) */ private Object bean; private ReferenceBeanInvocationHandler(ReferenceBean referenceBean) &#123; this.referenceBean = referenceBean; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 调用 Bean 的对应的方法 return method.invoke(bean, args); &#125; /** * 1 通过初始化方法，获得 ReferenceBean.ref (引用的服务)，即代理对象 * 2 调用ReferenceBean#get()方法，进行引用的Bean的初始化，最后返回服务接口代理对象 */ private void init() &#123; this.bean = referenceBean.get(); &#125; &#125; ReferenceBeanInvocationHandler是ReferenceAnnotationBeanPostProcessor的静态内部类，实现了InvocationHander接口。其中referenceBean属性值是通过构造方法设置的，bean属性的值就是引用的服务，即服务接口代理对象。invoke方法是回调方法，当消费方通过创建的proxy调用服务方法就会回调。至此，@Reference 所需要的依赖已经创建完毕，通过反射设置到所需组件中即可。 Dubbo注解配置流程总结 前面已经详细分析Dubbo注解配置的流程，这里进行小结。Dubbo的注解解析机制主要依赖上图中的核心组件。如果用户使用了配置文件，则Dubbo框架按需生成对应的Bean。Dubbo框架会将所有使用Dubbo的注解@Service标注的类提升为Bean，为使用@Reference注解的字段或方法注入代理对象。 总结代码量远比预计得多，写的还是有点混乱的。从代码整个流程可以看出，虽然注解使用更加简洁、方便，但是背后的工作一点都没有少，甚至更多更复杂。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubbo源码分析 - XML配置","slug":"rpc/xml配置","date":"2020-03-28T16:00:00.000Z","updated":"2020-09-03T03:12:53.638Z","comments":false,"path":"posts/a8d76a91/","link":"","permalink":"https://gentryhuang.com/posts/a8d76a91/","excerpt":"","text":"前言在 Dubbo源码分析 - API和属性配置 中介绍了Dubbo的配置承载对象，分析了核心的配置类及方法。了解了API配置后XML配置就容易多了，XML配置相比较API配置的区别在配置对象创建及其属性的设置是由Spring管理的，Dubbo和Spring XML融合是关键。 Dubbo和Spring融合Dubbo框架直接集成了Spring的能力，利用Spring配置文件扩展出自定义的解析方式，即使用Spring的自定标签。关于Spring自定标签的示例，在Spring自定义标签 中有详细介绍，Dubbo基于schema的设计也是如此，下面我们就来分析下Dubbo是怎么和Spring融合的。 Dubbo的配置对象模型Dubbo的配置对象模型已经在 [Dubbo源码分析 - API和属性配置] 中详细介绍过了，在Dubbo的命名空间处理器中也可以具体看到哪些配置类和Spring进行交互，这里就不再介绍。 Dubbo的xsd文件dubbo.xsd文件是用来约束使用XML配置时的标签和对应的属性，如Dubbo中的&lt;dubbo:service&gt;标签等。由于当前分析的dubbo版本是2.6.5，Dubbo已经捐给了Apache组织，为了遵循Apache标准和兼容Dubbo原来的版本，会出现两个xsd文件，这篇文章还是按照Dubbo原来的版本进行相关描述。 dubbo.xsd总览 Dubbo设计的粒度很多都是针对方法级别的，如方法级别的timeout、retries等特性。具体的每个复杂类型的详细使用可以参考:官方文档 dubbo.xsd中的类型关系 上图的类型继承关系和Dubbo的配置类之间的关系几乎保持一致，因为这里定义的复杂类型就是要映射到配置类的属性上，即schema中的字段对应Config类中的属性和get/set方法。 Dubbo的spring.schemas文件12http\\:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&#x3D;META-INF&#x2F;dubbo.xsdhttp\\:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&#x3D;META-INF&#x2F;compat&#x2F;dubbo.xsd spring.schemas文件用来指明约束文件的具体路径。 Dubbo的spring.handlers12http\\:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x3D;com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandlerhttp\\:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x3D;com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler spring.handlers文件用来指明Dubbo的XML命名空间处理器，即使用DubboNamespaceHandler来解析Dubbo自定义的标签。 Dubbo的DubboNamespaceHandler123456789101112131415161718192021222324public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123; static &#123; Version.checkDuplicate(DubboNamespaceHandler.class); &#125; /** * 方法中定义了每个&lt;xsd:element/&gt;对应的BeanDefinitionParser 【Dubbo Bean定义解析器】 */ @Override public void init() &#123; registerBeanDefinitionParser(\"application\", new DubboBeanDefinitionParser(ApplicationConfig.class, true)); registerBeanDefinitionParser(\"module\", new DubboBeanDefinitionParser(ModuleConfig.class, true)); registerBeanDefinitionParser(\"registry\", new DubboBeanDefinitionParser(RegistryConfig.class, true)); registerBeanDefinitionParser(\"monitor\", new DubboBeanDefinitionParser(MonitorConfig.class, true)); registerBeanDefinitionParser(\"provider\", new DubboBeanDefinitionParser(ProviderConfig.class, true)); registerBeanDefinitionParser(\"consumer\", new DubboBeanDefinitionParser(ConsumerConfig.class, true)); registerBeanDefinitionParser(\"protocol\", new DubboBeanDefinitionParser(ProtocolConfig.class, true)); registerBeanDefinitionParser(\"service\", new DubboBeanDefinitionParser(ServiceBean.class, true)); registerBeanDefinitionParser(\"reference\", new DubboBeanDefinitionParser(ReferenceBean.class, false)); // 注解已经重写，AnnotationBeanDefinitionParser 已经废弃，即@DubboComponentScan 作为 Dubbo 2.5.7 新增的 Annotation，是XML 元素 &lt;dubbo:annotation&gt; 的替代方案。 registerBeanDefinitionParser(\"annotation\", new AnnotationBeanDefinitionParser()); &#125;&#125; Dubbo解析配置的入口是在 DubboNamespaceHandler类中完成的，该类主要把不同的标签关联到解析实现类中，registerBeanDefinitionParser方法约定在遇到Dubbo自定的标签如application、registry、protocol等都会委托给Dubbo的命名空间处理器DubboNamespaceHandler处理，该处理器又会把解析任务交给DubboBeanDefinitionParser来处理。 Dubbo的DubboBeanDefinitionParser实现了Spring的BeanDefinitionParser接口，是真正用来解析自定的Dubbo标签，将标签解析成对应的Bean定义并注册到Spring上下文中。 使用Dubbo标签123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- provider's application name, used for tracing dependency relationship --&gt; &lt;dubbo:application name=\"demo-provider\" owner=\"gentryhuang\"/&gt; &lt;!-- use multicast registry center to export service --&gt; &lt;!--&lt;dubbo:registry address=\"multicast://224.5.6.7:1234\" protocol=\"test\"/&gt; --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- use dubbo protocol to export service on port 20880 --&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!-- service implementation, as same as regular local bean --&gt; &lt;bean id=\"demoService\" class=\"com.alibaba.dubbo.demo.provider.DemoServiceImpl\"/&gt; &lt;!-- declare the service interface to be exported --&gt; &lt;dubbo:service interface=\"com.alibaba.dubbo.demo.DemoService\" ref=\"demoService\"/&gt;&lt;/beans&gt; 小结以上就是Dubbo和Spring的XML配置进行融合的过程，与 Spring自定义标签 文章中的流程是一样的。总的来说，Dubbo框架先以流的形式装载Spring的XML配置文件，在将流解析成DOM的过程中会加载spring.schemas文件，然后读取该文件中指定的的xsd约束文件，接着使用xsd中的约束规则对每个标签及其属性进行校验，不合法则抛出异常，整个配置文件符合约束规则则生成DOM对象。和spring.handlers文件。spring.schema文件指定了配置约束文件的位置，加载spring.schemas文件的目的就是用来校验Spring的XML配置文件内容是否合法。加载spring.handlers文件的目的是，当解析Spring的XML配置文件中的标签时,会查找该文件中指定的DubboNamespaceHandler类来进行自定义标签的初始化和解析。 解析准备加载 spring.schemas 文件12345678910111213141516AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory)&#123; // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); // 设置 'META-INF/spring.schemas' 到 ResourceEntityResolver beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader);&#125; 上面代码就设置 spring.schemas 文件路径，为接下来加载 spring.schemas 文件做准备。 123456789XmlBeanDefinitionReader#doLoadBeanDefinitions(InputSource inputSource, Resource resource)&#123; try &#123; // 加载 META-INF/spring.schemas 中xsd文件，在构建Dom时进行校验XML配置内容是否正确 Document doc = doLoadDocument(inputSource, resource); // 加载 META-INF/spring.handlers 中的命名空间处理器，初始化并放入缓存 return registerBeanDefinitions(doc, resource); &#125; // 省略无关代码&#125; 上面的代码是注册XML中的Bean的大流程入口，分别是加载 META-INF/spring.schemas 中xsd文件，用于构建DOM时校验XML配置内容是否正确，加载 META-INF/spring.handlers 中的命名空间处理器，用于处理标签和BeanDefinitionParser的映射关系以及解析标签。下面我们来看Spring是如何加载spring.schemas文件内容的。 12345678910111213141516171819202122232425PluggableSchemaResolver#getSchemaMappings()&#123; if (this.schemaMappings == null) &#123; synchronized (this) &#123; if (this.schemaMappings == null) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Loading schema mappings from [\" + this.schemaMappingsLocation + \"]\"); &#125; try &#123; // 从 META-INF/spring.schemas 中读取xsd文件路径 Properties mappings = PropertiesLoaderUtils.loadAllProperties(this.schemaMappingsLocation, this.classLoader); if (logger.isDebugEnabled()) &#123; logger.debug(\"Loaded schema mappings: \" + mappings); &#125; Map&lt;String, String&gt; schemaMappings = new ConcurrentHashMap&lt;String, String&gt;(mappings.size()); // 放入缓存中 CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings); this.schemaMappings = schemaMappings; &#125;catch (IOException ex) &#123; throw new IllegalStateException(\"Unable to load schema mappings from location [\" + this.schemaMappingsLocation + \"]\", ex); &#125; &#125; &#125; &#125; return this.schemaMappings;&#125; 12345678910111213141516171819202122232425262728/** * @param publicId * @param systemId */PluggableSchemaResolver#resolveEntity(String publicId, String systemId)&#123; if (systemId != null) &#123; // 根据 spring.schemas中配置的xxx.xsd找到对应的xsd文件 String resourceLocation = getSchemaMappings().get(systemId); if (resourceLocation != null) &#123; // 加载xsd文件 Resource resource = new ClassPathResource(resourceLocation, this.classLoader); try &#123; InputSource source = new InputSource(resource.getInputStream()); source.setPublicId(publicId); source.setSystemId(systemId); if (logger.isDebugEnabled()) &#123; logger.debug(\"Found XML schema [\" + systemId + \"] in classpath: \" + resourceLocation); &#125; return source; &#125;catch (FileNotFoundException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Couldn't find XML schema [\" + systemId + \"]: \" + resource, ex); &#125; &#125; &#125; &#125; return null;&#125; 以上就是Spring在启动时加载spring.schemas中配置的xsd文件的几个代码片段，将XML配置文件解析成DOM的过程中，对每个标签及其属性进行校验，依据就是xsd中的约束条件。由于是Spring的源码部分，这里不进行深入分析，感兴趣的胖友可以自行调试。 加载 spring.handlers 文件123456789101112/** * @param doc 配置文件对应的DOM对象 * @param resource 配置文件资源对象 */XmlBeanDefinitionReader#registerBeanDefinitions(Document doc, Resource resource)&#123; // 创建Bean定义的DOMReader，用来读取、解析DOM，接着创建对应的Bean BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); // 读取、解析DOM、创建对应的Bean documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; registerBeanDefinitions方法是将Spring的XML配置文件中定义的有关标签进行创建并注册到Spring的注册表中。注意，这里所说的能够创建Bean的有关标签必须有对应的BeanDefinitionParser，否则不会对该标签进行处理。 1234567891011121314/** * @param resource 配置文件资源对象 */XmlBeanDefinitionReader#createReaderContext(Resource resource)&#123; return new XmlReaderContext( resource, this.problemReporter, this.eventListener, this.sourceExtractor, this, // 读取 META-INF/spring.handlers 文件 getNamespaceHandlerResolver() );&#125; createReaderContext 方法用来创建 XmlReaderContext，该对象中包含的核心属性如下： 由XmlReaderContext对象中的属性可知，在创建该对象的过程中对 META-INF/spring.handlers 文件进行了读取。现在有了配置文件的DOM对象、Bean定义工厂以及spring.handlers文件中各种NamespaceHandler，接下来就可以解析DOM树，创建并注册相应的Bean。 12345678DefaultBeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)&#123; this.readerContext = readerContext; logger.debug(\"Loading bean definitions\"); // 获取DOM的根元素，一般是 beans Element root = doc.getDocumentElement(); // 解析入口 doRegisterBeanDefinitions(root);&#125; 上面的代码主要是获取DOM对象的根元素，然后以这个根元素作为起点进行解析，下面我们接着解析代码。 123456789101112131415161718192021222324252627282930/*** Parse the elements at the root level in the document:* \"import\", \"alias\", \"bean\".* @param root DOM的根元素* @param delegate Bean定义解析器代理*/DefaultBeanDefinitionDocumentReader#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; // 判读根元素是不是默认的命名空间 'http://www.springframework.org/schema/beans' if (delegate.isDefaultNamespace(root)) &#123; // 获取根元素下的子元素列表 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); // 判断是否是元素 if (node instanceof Element) &#123; Element ele = (Element) node; // 当前元素的命名空间如果是默认的命名空间即Spring自身的命名空间，则通过Spring自身逻辑进行解析 if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; // 当前元素的命名空间非默认的命名空间即自定义的标签，则通过自定义逻辑进行解析 else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125;else &#123; delegate.parseCustomElement(root); &#125;&#125; 上面代码的主要逻辑是判断要解析的DOM元素即标签，是否是Spring内置的，如果是Spring内置则整个解析逻辑使用Spring自身的那一套，如果是自定义的，则解析逻辑交给开发者。Spring自身的解析逻辑忽略，下面我们来分析下自定义的标签的处理流程。 1234567891011121314151617181920BeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element ele)&#123; return parseCustomElement(ele, null);&#125;/** * @param ele DOM的根元素 * @param containingBd */BeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element ele, org.springframework.beans.factory.config.BeanDefinition containingBd)&#123; // 获取元素即标签的命名空间 String namespaceUri = getNamespaceURI(ele); // 使用 XmlReaderContext中的 DefaultNamespaceHandlerResolver获取命名空间对应的 NamespaceHandler对象 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) &#123; error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele); return null; &#125; // 使用 NamespaceHandler 对象解析标签 return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; 上面代码先是获取当前元素的命名空间，然后通过该命名空间获取对应 NamespaceHandler对象，最后通过该对象解析当前元素。下面我们依次分析这两个步骤的代码。 1234567891011121314151617181920212223242526272829303132333435363738DefaultNamespaceHandlerResolver#resolve(String namespaceUri)&#123;// 获取 DefaultNamespaceHandlerResolver#handlerMappings属性，即命名空间到NamespaceHandler的映射，注意这里的NamespaceHandler可能是还没有进行实例化的字符串 Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();// 从缓存中获取 NamespaceHandler Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) &#123; return null; &#125;// 如果当前命名空间对应的 NamespaceHandler 就是 NamespaceHandler对象，则需要进行实例化，直接返回即可 else if (handlerOrClassName instanceof NamespaceHandler) &#123; return (NamespaceHandler) handlerOrClassName; &#125; // 当前命名空间对应的 NamespaceHandler 还是字符串，需要反射创建对象 else &#123; String className = (String) handlerOrClassName; try &#123; // 获取当前 当前命名空间对应的 NamespaceHandler 串 的 Class Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123; throw new FatalBeanException(\"Class [\" + className + \"] for namespace [\" + namespaceUri + \"] does not implement the [\" + NamespaceHandler.class.getName() + \"] interface\"); &#125; // 创建对象 NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); // 执行 init 方法，进行标签和BeanDefinitionParser 的关联 namespaceHandler.init(); // 加入缓存 handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; &#125;catch (ClassNotFoundException ex) &#123; throw new FatalBeanException(\"NamespaceHandler class [\" + className + \"] for namespace [\" + namespaceUri + \"] not found\", ex); &#125;catch (LinkageError err) &#123; throw new FatalBeanException(\"Invalid NamespaceHandler class [\" + className + \"] for namespace [\" + namespaceUri + \"]: problem with handler class file or dependent class\", err); &#125; &#125;&#125; 上面代码核心是获取当前命名空间对应的 NamespaceHandler ，如果 NamespaceHandler 还是个字符串，那么就通过反射创建对象，接着调用该对象的 init(),进行标签和 BeanDefinitionParser 的关联 ，方法如果已经创建过了对象则直接返回该 NamespaceHandler 对象。由于Dubbo自定义标签的命名空间对应的NamespaceHandler是 DubboNamespaceHandler，我们在前面已经分析过了它的源码，这里再详细说明下。 1234567891011121314151617181920212223public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123; static &#123; Version.checkDuplicate(DubboNamespaceHandler.class); &#125; /** * 方法中定义了每个&lt;xsd:element/&gt;对应的BeanDefinitionParser 【Dubbo Bean定义解析器】 */ @Override public void init() &#123; registerBeanDefinitionParser(\"application\", new DubboBeanDefinitionParser(ApplicationConfig.class, true)); registerBeanDefinitionParser(\"module\", new DubboBeanDefinitionParser(ModuleConfig.class, true)); registerBeanDefinitionParser(\"registry\", new DubboBeanDefinitionParser(RegistryConfig.class, true)); registerBeanDefinitionParser(\"monitor\", new DubboBeanDefinitionParser(MonitorConfig.class, true)); registerBeanDefinitionParser(\"provider\", new DubboBeanDefinitionParser(ProviderConfig.class, true)); registerBeanDefinitionParser(\"consumer\", new DubboBeanDefinitionParser(ConsumerConfig.class, true)); registerBeanDefinitionParser(\"protocol\", new DubboBeanDefinitionParser(ProtocolConfig.class, true)); registerBeanDefinitionParser(\"service\", new DubboBeanDefinitionParser(ServiceBean.class, true)); registerBeanDefinitionParser(\"reference\", new DubboBeanDefinitionParser(ReferenceBean.class, false)); registerBeanDefinitionParser(\"annotation\", new AnnotationBeanDefinitionParser()); &#125;&#125; 上面的代码比较直观，一个标签对应一个 DubboBeanDefinitionParser 对象，同时也对应这一个Dubbo的配置承载类。我们接下主要看registerBeanDefinitionParser方法是怎么把标签和DubboBeanDefinitionParser关联到一起的。 1234567891011121314public abstract class NamespaceHandlerSupport implements NamespaceHandler &#123; /** * 标签名 到 BeanDefinitionParser 映射集合 */ private final Map&lt;String, BeanDefinitionParser&gt; parsers = new HashMap&lt;String, BeanDefinitionParser&gt;(); /** * 关联 标签名 到 BeanDefinitionParser */ protected final void registerBeanDefinitionParser(String elementName, BeanDefinitionParser parser) &#123; this.parsers.put(elementName, parser); &#125;&#125; 原来如此简单，就是调用父类 NamespaceHandlerSupport 的registerBeanDefinitionParser方法，将标签名到BeanDefinitionParser的映射保存到缓存中。到了这里所有解析前的工作已经准备就绪，终于可以进入到这篇文章的核心部分了。之所以用了那么多的铺垫，就是想把整个过程串起来，如果一下子进入到Dubbo自定义标签的解析感觉还是挺奇怪的，毕竟笔者对Spring的源码也不熟悉，就按部就班吧。 解析标签解析准备是特意为解析标签做的铺垫，有了这个铺垫下面的解析逻辑就容易很多了。我们接着解析准备中的 parseCustomElement 方法继续分析。 123456789101112public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123; // 1. 获取DOM元素即标签对应的命名空间 String namespaceUri = getNamespaceURI(ele); // 2. 获取命名空间映射的 NamespaceHandler对象 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) &#123; error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele); return null; &#125; // 3. 调用 NamespaceHandler对象 的parse方法进行解析 return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; 上面代码中的第3步才正式进入到标签的解析，这里的 NamespaceHandler 就 DubboNamespaceHandler对象，parse 方法是其父类 NamespaceHandlerSupport 中的方法，我们来看看逻辑。 123456789101112131415161718192021 @Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; /* * 1. 获取标签的名称关联的 BeanDefinitionParser * 2. 使用 BeanDefinitionParser解析标签 */ return findParserForElement(element, parserContext).parse(element, parserContext);&#125;private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) &#123; // 获取标签名 String localName = parserContext.getDelegate().getLocalName(element); // 从缓存中获取标签名对应的 BeanDefinitionParser对象，即 DubboBeanDefinitionParser对象 BeanDefinitionParser parser = this.parsers.get(localName); if (parser == null) &#123; parserContext.getReaderContext().fatal( \"Cannot locate BeanDefinitionParser for element [\" + localName + \"]\", element); &#125; return parser;&#125; 上面代码就是从 标签名 到 BeanDefinitionParser 映射集合parsers中获取标签名对应的BeanDefinitionParser对象，该映射集合是在 DubboNamespaceHandler#init 方法执行时维护的。下面我们接着分析DubboBeanDefinitionParser类。 Dubbo Bean定义解析器1234567891011121314151617181920212223242526272829303132333435public class DubboBeanDefinitionParser implements BeanDefinitionParser &#123; /** * 标签元素对应的对象类 */ private final Class&lt;?&gt; beanClass; /** * 是否需要Bean的 id 属性 */ private final boolean required; /** * @param beanClass Bean 对象的类 * @param required 是否需要在Bean对象的编号（id）不存在时自动生成编号。无需被其他应用引用的配置对象，无需自动生成编号。 eg：&lt;dubbo:reference/&gt; */ public DubboBeanDefinitionParser(Class&lt;?&gt; beanClass, boolean required) &#123; this.beanClass = beanClass; this.required = required; &#125; /** * Spring解析标签的入口方法 * * @param element 标签元素对象 * @param parserContext 解析上下文 * @return */ @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; return parse(element, parserContext, beanClass, required); &#125; // $&#123;省略的代码&#125; &#125; DubboBeanDefinitionParser实现了Spring的BeanDefinitionParser接口，即Spring的Bean定义解析器。该类中有两个重要属性，beanClass 和 required，这两个属性的值是在创建Dubbo的Bean定义解析器时通过构造方法传入的，分别是标签元素对应的配置类和在创建配置Bean的时候可能需要i的d属性。parse方法是解析XML元素的主流程的入口，其中 parserContext 参数是XML解析的上下文，它包含了 XmlReaderContext 这个重要对象，而该对象中又包含了BeanFactory等信息，具体如下图: 有了BeanFactory就可以实现Bean的定义了，接下来我们继续分析Dubbo是如何处理自定义标签与对应的配置类之间的关系，以及怎样创建标签对应的Bean定义的。 创建Bean定义并注册到Spring上下文1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @param element 标签对应的DOM * @param parserContext spring 解析上下文 * @param beanClass 标签对应的配置类 * @param required 在创建Bean定义的时候是否需要id * @return 标签对应的配置类的Bean定义 */ @SuppressWarnings(\"unchecked\") private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123; // 生成Spring的Bean定义，指定beanClass交给Spring反射创建实例 RootBeanDefinition beanDefinition = new RootBeanDefinition(); beanDefinition.setBeanClass(beanClass); /** * 设置Bean初始化方式，默认设置为延迟加载。 * 需要说明的是，引用缺省是延迟初始化的，只有引用被注入到其它Bean或者getBean() 获取才会初始化。如果需要立即初始化可以配置： &lt;dubbo:reference init=\"true\"/&gt; */ beanDefinition.setLazyInit(false); //--------------------------- 确保Spring 容器中没有重复的Bean定义 开始 ------------------------/ // 解析标签对象的id属性 String id = element.getAttribute(\"id\"); // 标签没有设置id属性，并且创建的Bean定义需要id时，就执行生成id的逻辑。需要注意的是，Dubbo的reference标签对应Bean定义不需要id if ((id == null || id.length() == 0) &amp;&amp; required) &#123; // 1. 取name属性值 String generatedBeanName = element.getAttribute(\"name\"); if (generatedBeanName == null || generatedBeanName.length() == 0) &#123; // 2. 也没有设置name属性，此时如果当前标签是Protocol，那么id的值就直接设置为 'dubbo'，非Protocol协议则尝试取标签的interface属性值 if (ProtocolConfig.class.equals(beanClass)) &#123; generatedBeanName = \"dubbo\"; &#125; else &#123; generatedBeanName = element.getAttribute(\"interface\"); &#125; &#125; // 3. 以上过程都没有生成id，则最后使用标签对应的配置类的类名 if (generatedBeanName == null || generatedBeanName.length() == 0) &#123; generatedBeanName = beanClass.getName(); &#125; id = generatedBeanName; int counter = 2; // 检查Spring注册表中是否存在标识id，存在就通过自增序列继续处理id,使其唯一 while (parserContext.getRegistry().containsBeanDefinition(id)) &#123; id = generatedBeanName + (counter++); &#125; &#125; if (id != null &amp;&amp; id.length() &gt; 0) &#123; if (parserContext.getRegistry().containsBeanDefinition(id)) &#123; throw new IllegalStateException(\"Duplicate spring bean id \" + id); &#125; // 把标签对应的配置类的Bean定义注册到Spring，Bean 名称为id parserContext.getRegistry().registerBeanDefinition(id, beanDefinition); // 为Bean追加id属性 beanDefinition.getPropertyValues().addPropertyValue(\"id\", id); &#125; // $&#123;省略的代码&#125; &#125; 特殊处理protocol标签123456789101112131415161718192021222324252627282930313233343536373839/** * @param element 标签对应的DOM * @param parserContext spring 解析上下文 * @param beanClass 标签对应的配置类 * @param required 在创建Bean定义的时候是否需要id * @return 标签对应的配置类的Bean定义 */ @SuppressWarnings(\"unchecked\") private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123; // $&#123;省略的代码&#125; if (ProtocolConfig.class.equals(beanClass)) &#123; /** * 以下代码逻辑需要满足： * 顺序需要这样： * 1 &lt;dubbo:service interface=\"com.xxx.xxxService protocol=\"dubbo\" ref=\"xxxServiceImpl\"/&gt; * 2 &lt;dubbo:protocol id =\"dubbo\" name=\"dubbo\" port=\"20880\"/&gt; */ // 获取Bean注册表中所有的Bean id for (String name : parserContext.getRegistry().getBeanDefinitionNames()) &#123; // 根据id获取Bean定义 BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name); // 获取当前Bean定义的属性对象集合，并尝试获取属性名为 'protocol' 的属性对象 PropertyValue property = definition.getPropertyValues().getPropertyValue(\"protocol\"); if (property != null) &#123; // 获取属性值 Object value = property.getValue(); // 如果当前遍历的Bean定义中的属性满足条件，就更新该Bean的 protocol 属性值，即名称为id的RuntimeBeanReference对象 if (value instanceof ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) &#123; definition.getPropertyValues().addPropertyValue(\"protocol\", new RuntimeBeanReference(id)); &#125; &#125; &#125; &#125; // $&#123;省略的代码&#125; &#125; 上面的代码用来处理框架中那些属性名为’protocol’且属性类型为为ProtocolConfig的Bean，如果该Bean符合条件就更新该Bean的protocol属性值。 特殊处理service标签1234567891011121314151617181920212223242526272829/** * @param element 标签对应的DOM * @param parserContext spring 解析上下文 * @param beanClass 标签对应的配置类 * @param required 在创建Bean定义的时候是否需要id * @return 标签对应的配置类的Bean定义 */ @SuppressWarnings(\"unchecked\") private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123; // $&#123;省略的代码&#125; else if (ServiceBean.class.equals(beanClass)) &#123; // 如果&lt;dubbo:service&gt;配置了class属性，那么为具体class配置的类创建Bean定义，并且把该定义注入到Service的 ref属性。一般不这么使用。 // eg: &lt;dubbo:service interface=\"com.alibaba.dubbo.demo.DemoService class=\"com.alibaba.dubbo.demo.provider.DemoServiceImpl\"/&gt; String className = element.getAttribute(\"class\"); if (className != null &amp;&amp; className.length() &gt; 0) &#123; RootBeanDefinition classDefinition = new RootBeanDefinition(); classDefinition.setBeanClass(ReflectUtils.forName(className)); classDefinition.setLazyInit(false); // 解析 &lt;dubbo:service class=\"xxx\"/&gt; 情况下内嵌的&lt;property/&gt;标签，然后设置到classDefinition的属性中 parseProperties(element.getChildNodes(), classDefinition); // 设置ref属性，相当于设置 &lt;dubbo:service ref=\"\"/&gt;属性 beanDefinition.getPropertyValues().addPropertyValue(\"ref\", new BeanDefinitionHolder(classDefinition, id + \"Impl\")); &#125; &#125; // $&#123;省略的代码&#125; &#125; 上面的代码用来处理 service标签 中有 class 属性的情况，处理逻辑就是创建class对应的Bean定义，然后设置到 service标签 对应的Bean的ref属性中。我们再来看看对service的子标签 property 的解析。 123456789101112131415161718192021222324252627282930313233/** * 解析 &lt;dubbo:service class=\"xxx\"/&gt; 情况下内嵌的&lt;property/&gt; * * @param nodeList 子元素数组 * @param beanDefinition Bean定义对象 */private static void parseProperties(NodeList nodeList, RootBeanDefinition beanDefinition) &#123; if (nodeList != null &amp;&amp; nodeList.getLength() &gt; 0) &#123; for (int i = 0; i &lt; nodeList.getLength(); i++) &#123; Node node = nodeList.item(i); // 只解析&lt;property/&gt;标签 if (node instanceof Element) &#123; if (\"property\".equals(node.getNodeName()) || \"property\".equals(node.getLocalName())) &#123; String name = ((Element) node).getAttribute(\"name\"); // 优先使用value属性，其次使用ref属性 if (name != null &amp;&amp; name.length() &gt; 0) &#123; String value = ((Element) node).getAttribute(\"value\"); String ref = ((Element) node).getAttribute(\"ref\"); if (value != null &amp;&amp; value.length() &gt; 0) &#123; beanDefinition.getPropertyValues().addPropertyValue(name, value); &#125; else if (ref != null &amp;&amp; ref.length() &gt; 0) &#123; beanDefinition.getPropertyValues().addPropertyValue(name, new RuntimeBeanReference(ref)); &#125; else &#123; // 属性不全，抛出异常 throw new UnsupportedOperationException(\"Unsupported &lt;property name=\\\"\" + name + \"\\\"&gt; sub tag, Only supported &lt;property name=\\\"\" + name + \"\\\" ref=\\\"...\\\" /&gt; or &lt;property name=\\\"\" + name + \"\\\" value=\\\"...\\\" /&gt;\"); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 上面的代码用来解析service的property标签，目的是为service标签的class属性对应的Bean定义设置属性，比较简单。 特殊处理provider/consumer标签1234567891011121314151617181920212223/** * @param element 标签对应的DOM * @param parserContext spring 解析上下文 * @param beanClass 标签对应的配置类 * @param required 在创建Bean定义的时候是否需要id * @return 标签对应的配置类的Bean定义 */ @SuppressWarnings(\"unchecked\") private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123; // $&#123;省略的代码&#125; else if (ProviderConfig.class.equals(beanClass)) &#123; // 解析 &lt;dubbo:provider/&gt; 的内嵌子元素&lt;dubbo:service/&gt; parseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition); &#125;else if (ConsumerConfig.class.equals(beanClass)) &#123; // 解析 &lt;dubbo:consumer/&gt; 的内嵌子元素&lt;dubbo:reference/&gt; parseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition); &#125; // $&#123;省略的代码&#125; &#125; 从上面的代码可以看出，特殊处理provider/consumer标签就是处理它有service/reference子标签的情况，代码过程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 解析内嵌的标签 * * @param element 父标签对象 - provider/consumer标签对象 * @param parserContext Spring解析上下文 * @param beanClass 内嵌子元素的Bean类 - ServiceBean/ReferenceBean * @param required 是否需要Bean的id属性 * @param tag 子元素标签名 service/reference * @param property 父Bean对象在子元素中的属性名 provider/consumer * @param ref 父Bean的id * @param beanDefinition 父Bean定义对象 */ private static void parseNested(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required, String tag, String property, String ref, BeanDefinition beanDefinition) &#123; // 获取子节点列表 NodeList nodeList = element.getChildNodes(); if (nodeList != null &amp;&amp; nodeList.getLength() &gt; 0) &#123; boolean first = true; for (int i = 0; i &lt; nodeList.getLength(); i++) &#123; // 获取子节点 Node node = nodeList.item(i); if (node instanceof Element) &#123; // 当前节点是否是指定的子节点，这里可能是service/reference节点 if (tag.equals(node.getNodeName()) || tag.equals(node.getLocalName())) &#123; if (first) &#123; first = false; // 获取父节点的default的属性值 [暂时不知道有什么用] String isDefault = element.getAttribute(\"default\"); if (isDefault == null || isDefault.length() == 0) &#123; beanDefinition.getPropertyValues().addPropertyValue(\"default\", \"false\"); &#125; &#125; // 解析子元素，创建BeanDefinition 对象 （递归） BeanDefinition subDefinition = parse((Element) node, parserContext, beanClass, required); // 设置子BeanDefinition的指向，指向父BeanDefinition if (subDefinition != null &amp;&amp; ref != null &amp;&amp; ref.length() &gt; 0) &#123; subDefinition.getPropertyValues().addPropertyValue(property, new RuntimeBeanReference(ref)); &#125; &#125; &#125; &#125; &#125; &#125; 上面的代码主要处理provider/consumer标签内部嵌套的标签，内部嵌套的标签对象会自动持有外层标签的对象。 设置标签的属性到 BeanDefinition前面处理的逻辑属于特殊的情况，接下来我们分析标签的属性是如何设置到配置对象中的。本质上是通过遍历配置对象的get、set和is前缀方法，通过反射将标签属性设置到配置对象中。总体上分为两种情况： 如果标签属性和方法名相同，则通过反射调用设置标签的值到配置对象中。 如果标签属性不能匹配到配置对象中的方法名称，则将标签属性当作parameter参数设置到配置对象中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194/** * @param element 标签对应的DOM * @param parserContext spring 解析上下文 * @param beanClass 标签对应的配置类 * @param required 在创建Bean定义的时候是否需要id * @return 标签对应的配置类的Bean定义 */ @SuppressWarnings(\"unchecked\") private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123; // $&#123;省略的代码&#125; // 用来保存已遍历的配置对象的属性集合，用来判断标签中哪些属性没有匹配上 Set&lt;String&gt; props = new HashSet&lt;String&gt;(); // 专门存放&lt;dubbo:parameters/&gt; 标签下子标签属性信息。最后都设置到Bean定义中 ManagedMap parameters = null; // 1. 获取配置对象所有方法 for (Method setter : beanClass.getMethods()) &#123; String name = setter.getName(); // 2. 选择所有set前缀方法，并且只有一个参数的 public 方法 if (name.length() &gt; 3 &amp;&amp; name.startsWith(\"set\") &amp;&amp; Modifier.isPublic(setter.getModifiers()) &amp;&amp; setter.getParameterTypes().length == 1) &#123; // 获取方法的参数类型 Class&lt;?&gt; type = setter.getParameterTypes()[0]; // 3. 提取set对应的属性名字，eg: setTimeout-&gt;timeout,setBeanName-&gt;bean-name String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \"-\"); // 保存到属性 props 集合中 props.add(property); // 4. 尝试获取属性对应的getter方法 Method getter = null; try &#123; getter = beanClass.getMethod(\"get\" + name.substring(3), new Class&lt;?&gt;[0]); &#125; catch (NoSuchMethodException e) &#123; try &#123; // 没有setter对应的getter方法，尝试获取is方法，is方法在功能上是同getter getter = beanClass.getMethod(\"is\" + name.substring(3), new Class&lt;?&gt;[0]); &#125; catch (NoSuchMethodException e2) &#123; &#125; &#125; // 5. 校验属性是否有对应的getter/is前缀方法，没有就跳过 if (getter == null || !Modifier.isPublic(getter.getModifiers()) || !type.equals(getter.getReturnType())) &#123; continue; &#125; // 6. 解析 &lt;dubbo:parameter/&gt; 标签，将当前标签element的子标签 &lt;dubbo:parameter/&gt; 的属性键值对保存到parameters中 if (\"parameters\".equals(property)) &#123; parameters = parseParameters(element.getChildNodes(), beanDefinition); // 7. 解析 &lt;dubbo:method/&gt; 标签，将当前标签element的子标签 &lt;dubbo:method/&gt; 进行解析，将解析得到的对应BeanDefiniton放入到ManagedList集合中，最后作为 beanDefiniton的methods属性值。 &#125; else if (\"methods\".equals(property)) &#123; parseMethods(id, element.getChildNodes(), beanDefinition, parserContext); // 8. 解析 &lt;dubbo:argument/&gt;标签，将当前标签element的子标签 &lt;dubbo:argument/&gt; 进行解析，将解析得到的对应的BeanDefinition放入到ManagedList集合中，最后作为 beanDefinition的arguments属性值。 &#125; else if (\"arguments\".equals(property)) &#123; parseArguments(id, element.getChildNodes(), beanDefinition, parserContext); &#125; else &#123; // 9. 获取标签属性的值 【前面的步骤之所以单独处理，是因为当前配置配置对象对应的属性不是一个标签属性，而是一个子标签】 String value = element.getAttribute(property); if (value != null) &#123; value = value.trim(); if (value.length() &gt; 0) &#123; // 9.1 标签中配置了 registry=N/A, 不想注册到的情况 if (\"registry\".equals(property) &amp;&amp; RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) &#123; RegistryConfig registryConfig = new RegistryConfig(); // RegistryConfig的地址设置 N/A registryConfig.setAddress(RegistryConfig.NO_AVAILABLE); beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig); // 9.2 多注册中心情况，将多个注册中心处理成一个集合，然后设置到 beanDefiniton 中，属性名为 'registries' &#125; else if (\"registry\".equals(property) &amp;&amp; value.indexOf(',') != -1) &#123; parseMultiRef(\"registries\", value, beanDefinition, parserContext); // 9.3 多服务提供者情况，将多个服务提供者处理成一个集合，然后设置到 beanDefinition 中，属性为 'providers' &#125; else if (\"provider\".equals(property) &amp;&amp; value.indexOf(',') != -1) &#123; parseMultiRef(\"providers\", value, beanDefinition, parserContext); // 9.4 多协议情况，将多个协议处理成一个集合，然后设置到 beanDefinition 中，属性为 'protocols' &#125; else if (\"protocol\".equals(property) &amp;&amp; value.indexOf(',') != -1) &#123; parseMultiRef(\"protocols\", value, beanDefinition, parserContext); &#125; else &#123; Object reference; // 10. 属性类型为基本类型的情况 if (isPrimitive(type)) &#123; // 兼容性处理【一些设置了但是意义不大的属性就把值设置为null】 if (\"async\".equals(property) &amp;&amp; \"false\".equals(value) || \"timeout\".equals(property) &amp;&amp; \"0\".equals(value) || \"delay\".equals(property) &amp;&amp; \"0\".equals(value) || \"version\".equals(property) &amp;&amp; \"0.0.0\".equals(value) || \"stat\".equals(property) &amp;&amp; \"-1\".equals(value) || \"reliable\".equals(property) &amp;&amp; \"false\".equals(value)) &#123; // backward compatibility for the default value in old version's xsd value = null; &#125; reference = value; //11. 处理在&lt;dubbo:provider/&gt; 或者 &lt;dubbo:service/&gt; 上定义了 protocol 属性的兼容性，目前已经不推荐这样使用了，应该单独配置 &lt;dubbo:protocol/&gt; &#125; else if (\"protocol\".equals(property) &amp;&amp; ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(value) &amp;&amp; (!parserContext.getRegistry().containsBeanDefinition(value) || !ProtocolConfig.class.getName().equals(parserContext.getRegistry().getBeanDefinition(value).getBeanClassName()))) &#123; if (\"dubbo:provider\".equals(element.getTagName())) &#123; logger.warn(\"Recommended replace &lt;dubbo:provider protocol=\\\"\" + value + \"\\\" ... /&gt; to &lt;dubbo:protocol name=\\\"\" + value + \"\\\" ... /&gt;\"); &#125; // backward compatibility ProtocolConfig protocol = new ProtocolConfig(); protocol.setName(value); reference = protocol; //------- 12. 事件通知: 在调用前，调用后，出现异常，会触发oninvoke，onreturn,onthrow三个事件，可以配置当事件发生时，通知哪个类的哪个方法 ------// /* // 格式：实现Bean.方法 &lt;bean id=\"demoCallBack\" class = \"com.alibaba.dubbo.callback.implicit.NofifyImpl\"/&gt; &lt;dubbo:reference id = \"demoService\" interface=\"com.alibaba.dubbo.IDemoService\"&gt; &lt;dubbo:method name=\"get\" onreturn=\"demoCallBack.xxxMethod\" onthrow=\"demoCallBack.xMethod\"/&gt; &lt;/dubbo:reference&gt; */ // 12.1 处理 onreturn 属性 &#125; else if (\"onreturn\".equals(property)) &#123; // 按照 . 拆分 int index = value.lastIndexOf(\".\"); // 获取实例名 String returnRef = value.substring(0, index); // 获取实例的方法 String returnMethod = value.substring(index + 1); // 创建 RuntimeBeanReference，指向回调的对象 reference = new RuntimeBeanReference(returnRef); // 设置 onreturnMethod 到 BeanDefinition 的属性值 beanDefinition.getPropertyValues().addPropertyValue(\"onreturnMethod\", returnMethod); // 12.2 处理 onthrow 属性 &#125; else if (\"onthrow\".equals(property)) &#123; int index = value.lastIndexOf(\".\"); String throwRef = value.substring(0, index); String throwMethod = value.substring(index + 1); // 创建 RuntimeBeanReference，指向回调的对象 reference = new RuntimeBeanReference(throwRef); // 设置 onthrowMethod 到 BeanDefinition 的属性值 beanDefinition.getPropertyValues().addPropertyValue(\"onthrowMethod\", throwMethod); //12.3 处理oninvoke 属性 &#125; else if (\"oninvoke\".equals(property)) &#123; int index = value.lastIndexOf(\".\"); String invokeRef = value.substring(0, index); String invokeRefMethod = value.substring(index + 1); reference = new RuntimeBeanReference(invokeRef); beanDefinition.getPropertyValues().addPropertyValue(\"oninvokeMethod\", invokeRefMethod); //----------------------------- 事件通知结束 ------------------------------// &#125; else &#123; // 13. 属性名没有匹配到对应的标签名，都会到这里 //13.1 如果属性名是ref, ref 对应的Bean 必须是单例的 if (\"ref\".equals(property) &amp;&amp; parserContext.getRegistry().containsBeanDefinition(value)) &#123; BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value); if (!refBean.isSingleton()) &#123; throw new IllegalStateException(\"The exported service ref \" + value + \" must be singleton! Please set the \" + value + \" bean scope to singleton, eg: &lt;bean id=\\\"\" + value + \"\\\" scope=\\\"singleton\\\" ...&gt;\"); &#125; &#125; // 创建RuntimeBeanReference reference = new RuntimeBeanReference(value); &#125; // 设置Bean定义的属性 beanDefinition.getPropertyValues().addPropertyValue(property, reference); &#125; &#125; &#125; &#125; &#125; &#125; // 将标签中自定义的属性（不是Dubbo Schema 约定好的）也加入到 parameters 集合中 NamedNodeMap attributes = element.getAttributes(); int len = attributes.getLength(); for (int i = 0; i &lt; len; i++) &#123; Node node = attributes.item(i); String name = node.getLocalName(); if (!props.contains(name)) &#123; if (parameters == null) &#123; parameters = new ManagedMap(); &#125; String value = node.getNodeValue(); parameters.put(name, new TypedStringValue(value, String.class)); &#125; &#125; if (parameters != null) &#123; beanDefinition.getPropertyValues().addPropertyValue(\"parameters\", parameters); &#125; return beanDefinition; &#125; 上面的代码是把属性注入到标签对应的BeanDefinition，如果属性是引用对象，Dubbo默认会创建 RuntimeBeanReference 类型注入，运行时由Spring注入引用对象。 总结Dubbo框架解析配置文件生成BeanDefinition其实是生成标签对应的配置类的Bean定义，Bean定义中的属性值主要来源于标签的属性值，Dubbo对标签属性只是进行了提取，标签的内嵌标签处理也是如此，运行时属性注入和转换都还是Spring来完成的，Dubbo框架生成的BeanDefinition最终会委托Spring创建对应的对象，这个属于Spring的流程就不多说了。dubbo.xsd文件中定义的类型都会有与之对应的配置承载类中的属性，我们已经在API配置中介绍过了。XML配置解析还是挺复杂的，分支流比较多，下一章要分析的注解配置稍微比这个复杂一些。随着后面深入的分析就会发现这些东西都是基础，结合Dubbo的整个过程就很容易理解了。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubbo源码分析 - API和属性配置","slug":"rpc/API配置","date":"2020-03-24T16:00:00.000Z","updated":"2020-09-03T03:12:53.647Z","comments":false,"path":"posts/1d3295e6/","link":"","permalink":"https://gentryhuang.com/posts/1d3295e6/","excerpt":"","text":"前言我们通过 Dubbo URL统一模型 已经了解了Dubbo URL是Duboo的配置总线，贯穿整个Dubbo的生命周期。虽然Dubbo URL直接决定了Dubbo组件的角色并控制Dubbo的行为，但是Dubbo URL中的信息需要Dubbo的配置承对象来提供，而配置承载对象中的数据来源于多种配置和设置。 目前Dubbo框架同时支持4种配置方式：API硬编码配置、XML配置、注解配置、属性配置。而所有的配置项分为三大类: 服务注册和发现：表示该配置项用于服务的注册和发现。 服务治理：表示该配置项用于治理服务间的关系，或为开发测试提供便利条件。 性能调优：表示该配置项用于调优性能，不同的选项对性能会产生影响。 注意：所有配置最终都会转换为Dubbo URL 配置承载对象不管是注解还是XML配置都需要配置对象来承载，XML配置、注解配置、属性配置都是和配置对象或其属性相映射的，为什么这里没有说API配置和配置对象的映射关系呢？其实API配置就是直接操作配置对象，而XML配置和注解配置都是由Spring来创建配置对象并设置属性的，而我们的属性配置是在配置对象已经存在的基础上，为其设置指定的属性值。下面是Dubbo的属性配置类的结构： 上图中我使用了黄色框和红色框分别对抽象配置类和配置实现类进行了标注，其中DubboShutdownHook先忽略。红色框中的配置类是直接的配置承载类，黄色框中的抽象配置类是配置承载类的父类。下面是配置承载类的UML图： 直观图 依赖关系图 通过上面的关系图我们可以很清楚地了解到每个配置之间的关系，我们接下来就顺着关系图分别介绍核心的配置类。 AbstractConfig 抽象配置类除了ArgumentConfig配置类，几乎其他的所有配置类都直接或间接继承该类，该类主要提供配置解析与校验相关的工具方法。 格式校验123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public abstract class AbstractConfig implements Serializable &#123; // 省略其它代码 $&#123;&#125; //-------------------------- 格式检验 -----------------------------/ private static final int MAX_LENGTH = 200; private static final int MAX_PATH_LENGTH = 200; private static final Pattern PATTERN_NAME = Pattern.compile(\"[\\\\-._0-9a-zA-Z]+\"); private static final Pattern PATTERN_MULTI_NAME = Pattern.compile(\"[,\\\\-._0-9a-zA-Z]+\"); private static final Pattern PATTERN_METHOD_NAME = Pattern.compile(\"[a-zA-Z][0-9a-zA-Z]*\"); private static final Pattern PATTERN_PATH = Pattern.compile(\"[/\\\\-$._0-9a-zA-Z]+\"); private static final Pattern PATTERN_NAME_HAS_SYMBOL = Pattern.compile(\"[:*,/\\\\-._0-9a-zA-Z]+\"); private static final Pattern PATTERN_KEY = Pattern.compile(\"[*,\\\\-._0-9a-zA-Z]+\"); protected static void checkExtension(Class&lt;?&gt; type, String property, String value) &#123; checkName(property, value); if (value != null &amp;&amp; value.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(type).hasExtension(value)) &#123; throw new IllegalStateException(\"No such extension \" + value + \" for \" + property + \"/\" + type.getName()); &#125; &#125; protected static void checkMultiExtension(Class&lt;?&gt; type, String property, String value) &#123; checkMultiName(property, value); if (value != null &amp;&amp; value.length() &gt; 0) &#123; String[] values = value.split(\"\\\\s*[,]+\\\\s*\"); for (String v : values) &#123; if (v.startsWith(Constants.REMOVE_VALUE_PREFIX)) &#123; v = v.substring(1); &#125; if (Constants.DEFAULT_KEY.equals(v)) &#123; continue; &#125; if (!ExtensionLoader.getExtensionLoader(type).hasExtension(v)) &#123; throw new IllegalStateException(\"No such extension \" + v + \" for \" + property + \"/\" + type.getName()); &#125; &#125; &#125; &#125; protected static void checkLength(String property, String value) &#123; checkProperty(property, value, MAX_LENGTH, null); &#125; protected static void checkPathLength(String property, String value) &#123; checkProperty(property, value, MAX_PATH_LENGTH, null); &#125; protected static void checkName(String property, String value) &#123; checkProperty(property, value, MAX_LENGTH, PATTERN_NAME); &#125; protected static void checkNameHasSymbol(String property, String value) &#123; checkProperty(property, value, MAX_LENGTH, PATTERN_NAME_HAS_SYMBOL); &#125; protected static void checkKey(String property, String value) &#123; checkProperty(property, value, MAX_LENGTH, PATTERN_KEY); &#125; protected static void checkMultiName(String property, String value) &#123; checkProperty(property, value, MAX_LENGTH, PATTERN_MULTI_NAME); &#125; protected static void checkPathName(String property, String value) &#123; checkProperty(property, value, MAX_PATH_LENGTH, PATTERN_PATH); &#125; protected static void checkMethodName(String property, String value) &#123; checkProperty(property, value, MAX_LENGTH, PATTERN_METHOD_NAME); &#125; protected static void checkParameterName(Map&lt;String, String&gt; parameters) &#123; if (parameters == null || parameters.size() == 0) &#123; return; &#125; for (Map.Entry&lt;String, String&gt; entry : parameters.entrySet()) &#123; checkNameHasSymbol(entry.getKey(), entry.getValue()); &#125; &#125; protected static void checkProperty(String property, String value, int maxlength, Pattern pattern) &#123; if (value == null || value.length() == 0) &#123; return; &#125; if (value.length() &gt; maxlength) &#123; throw new IllegalStateException(\"Invalid \" + property + \"=\\\"\" + value + \"\\\" is longer than \" + maxlength); &#125; if (pattern != null) &#123; Matcher matcher = pattern.matcher(value); if (!matcher.matches()) &#123; throw new IllegalStateException(\"Invalid \" + property + \"=\\\"\" + value + \"\\\" contains illegal \" + \"character, only digit, letter, '-', '_' or '.' is legal.\"); &#125; &#125; &#125; // 省略其它代码 $&#123;&#125;&#125; AbstractConfig的子类会调用这里的方法进行相关的参数校验。 添加属性（属性和系统参数配置）读取启动参数变量和Properties配置文件中属性到配置承载对象中，该方法其实就是属性配置 和 系统参数配置的逻辑。这个逻辑非常重要，无论是API配置还是XML配置，以及注解配置，都会使用该逻辑为配置承载对象设置系统参数值以及配置属性值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public abstract class AbstractConfig implements Serializable &#123; // 省略其它代码 $&#123;&#125; /** * 1 id 属性，Bean定义的名称，适用于除了API配置之外的三种配置（属性配置，xml配置,注解配置）方式，可用于对象之间的引用 * 2 不适用API配置，是因为API配置直接setter(xxx)对象即可 */ protected String id; /** * 读取带有配置项名前缀的启动参数变量和properties配置到 配置承载对象中。 * 说明：在此之前配置承载对象中只可能有xml配置的属性值，或者注解配置的属性值 * * @param config 配置对象 */ protected static void appendProperties(AbstractConfig config) &#123; if (config == null) &#123; return; &#125; // 获得配置项前缀（使用配置类的类名，获得对应的属性标签）-&gt; dubbo.tag. String prefix = \"dubbo.\" + getTagName(config.getClass()) + \".\"; // 获得配置类的所有方法，用于下面通过反射获得配置项的属性名，再用属性名去读取启动参数变量和.properties配置到配置对象 Method[] methods = config.getClass().getMethods(); for (Method method : methods) &#123; try &#123; // 拿到方法名 String name = method.getName(); // 选择方法是 【public &amp;&amp; setter &amp;&amp; 唯一参数为基本类型】 的方法 if (name.length() &gt; 3 &amp;&amp; name.startsWith(\"set\") &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 1 &amp;&amp; isPrimitive(method.getParameterTypes()[0])) &#123; // 获得属性名 如： ApplicationConfig#setName(...) 方法，对应的属性名为 name String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \".\"); //----------- 读取的覆盖策略： JVM -D &gt; XML &gt; .properties ----------/ String value = null; //【启动参数变量】优先从带有 id属性的XxxConfig的配置中获取，例如 dubbo.application.demo-provider.name if (config.getId() != null &amp;&amp; config.getId().length() &gt; 0) &#123; // id字段 String pn = prefix + config.getId() + \".\" + property; value = System.getProperty(pn); if (!StringUtils.isBlank(value)) &#123; logger.info(\"Use System Property \" + pn + \" to config dubbo\"); &#125; &#125; //【启动参数变量】获取不到，再从不带 id属性 的XxxConfig的配置中获取，例如：dubbo.application.name if (value == null || value.length() == 0) &#123; // 没有id字段 String pn = prefix + property; value = System.getProperty(pn); if (!StringUtils.isBlank(value)) &#123; logger.info(\"Use System Property \" + pn + \" to config dubbo\"); &#125; &#125; // 配置优先级以及覆盖： 启动参数变量 &gt; XML配置[注解/java配置] &gt; properties配置 。因此需要使用getter判断XML是否已经配置 if (value == null || value.length() == 0) &#123; Method getter; try &#123; getter = config.getClass().getMethod(\"get\" + name.substring(3)); &#125; catch (NoSuchMethodException e) &#123; try &#123; getter = config.getClass().getMethod(\"is\" + name.substring(3)); &#125; catch (NoSuchMethodException e2) &#123; getter = null; &#125; &#125; if (getter != null) &#123; // 使用getter 判断XML是否已经设置过，如果没有设置的话就从.properties文件中读取 if (getter.invoke(config) == null) &#123; // [properties配置] 优先从带有 id 属性的配置中获取，例如：dubbo.application.demo-provider.name if (config.getId() != null &amp;&amp; config.getId().length() &gt; 0) &#123; value = ConfigUtils.getProperty(prefix + config.getId() + \".\" + property); &#125; // [properties配置]获取不到，再从不带 id 属性的配置中获取，例如：dubbo.application.name if (value == null || value.length() == 0) &#123; value = ConfigUtils.getProperty(prefix + property); &#125; // [properties配置]获取不到，这里进行老版本兼容，从不带id属性的配置中获取 if (value == null || value.length() == 0) &#123; String legacyKey = legacyProperties.get(prefix + property); if (legacyKey != null &amp;&amp; legacyKey.length() &gt; 0) &#123; value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey)); &#125; &#125; &#125; &#125; &#125; // 获取到值（系统参数配置或者.properties文件中的，不包含xml配置，xml配置有单独的设置方法） if (value != null &amp;&amp; value.length() &gt; 0) &#123; method.invoke(config, convertPrimitive(method.getParameterTypes()[0], value)); &#125; &#125; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; &#125; // 省略其它代码 $&#123;&#125;&#125; 上面的代码主要就是为已经实例化好的配置承载对象设置属性值，主要逻辑如下： 根据配置对象获取属性配置的前缀，如 dubbo.application. 遍历配置承载对象中的所有方法找到符合条件的setter方法 根据配置覆盖策略的优先级，设置配置承载对象的属性值 配置对象的属性到参数集合将配置承载对象的属性添加到参数集合中，用于构建Dubbo URL，如在服务暴露和引用是构建相关的URL。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public abstract class AbstractConfig implements Serializable &#123; // 省略其它代码 $&#123;&#125; /** * 将配置对象的属性添加到参数集合 * * @param parameters * @param config */ protected static void appendParameters(Map&lt;String, String&gt; parameters, Object config) &#123; appendParameters(parameters, config, null); &#125; /** * 将配置对象的属性添加到参数集合，主要逻辑： * &lt;p&gt; * 1 通过反射获取目标对象的getter方法，并调用该方法获取属性值，然后再通过getter方法名解析出属性名，如：从方法名getName中可解析出属性name，如果用户传入了属性名前缀，此时需要将属性名加入前缀内容。 * 2 将 属性名-属性值 键值对存入到map中就可以了 * * @param parameters 参数集合，该集合会用于URL * @param config 配置对象 * @param prefix 属性前缀。用于配置项添加到参数集合中时的前缀 */ @SuppressWarnings(\"unchecked\") protected static void appendParameters(Map&lt;String, String&gt; parameters, Object config, String prefix) &#123; if (config == null) &#123; return; &#125; // 获得所有方法的数组，为下面通过反射获得配置项的值做准备 Method[] methods = config.getClass().getMethods(); for (Method method : methods) &#123; try &#123; String name = method.getName(); // 选择方法为 返回值为基本类型 + public的getter/is方法 （和解析到配置类的过滤添加呼应） if ((name.startsWith(\"get\") || name.startsWith(\"is\")) &amp;&amp; !\"getClass\".equals(name) &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 0 &amp;&amp; isPrimitive(method.getReturnType())) &#123; // 尝试获取方法上的@Parameter注解 Parameter parameter = method.getAnnotation(Parameter.class); // 方法返回类型是Object的或者方法的@Parameter(excluded = true)的， 不统计对应的值到参数集合 if (method.getReturnType() == Object.class || parameter != null &amp;&amp; parameter.excluded()) &#123; continue; &#125; // 获得属性名 int i = name.startsWith(\"get\") ? 3 : 2; String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), \".\"); String key; // @Parameter注解有配置key属性就取出该值 if (parameter != null &amp;&amp; parameter.key().length() &gt; 0) &#123; key = parameter.key(); &#125; else &#123; key = prop; &#125; // 利用反射获得属性的值 Object value = method.invoke(config); String str = String.valueOf(value).trim(); if (value != null &amp;&amp; str.length() &gt; 0) &#123; // 是否转移，默认不转译 if (parameter != null &amp;&amp; parameter.escaped()) &#123; str = URL.encode(str); &#125; // @Parameter注解有配置append属性，就进行拼接 if (parameter != null &amp;&amp; parameter.append()) &#123; // 1. 看参数集合中是否有key为： default.key的值(默认属性值),有就拼接到属性值前面 String pre = parameters.get(Constants.DEFAULT_KEY + \".\" + key); if (pre != null &amp;&amp; pre.length() &gt; 0) &#123; str = pre + \",\" + str; &#125; // 2. 看参数集合中是否有key对应的值，有就拼接到属性值前面 pre = parameters.get(key); if (pre != null &amp;&amp; pre.length() &gt; 0) &#123; str = pre + \",\" + str; &#125; &#125; // 如果指定了属性前缀就拼接上去，就在属性名前面加上前缀 if (prefix != null &amp;&amp; prefix.length() &gt; 0) &#123; key = prefix + \".\" + key; &#125; // 把最后处理的属性值加入参数集合中 parameters.put(key, str); // 当配置对象的属性getter方法加了@Parameter(required=true)时，校验配置项非空 &#125; else if (parameter != null &amp;&amp; parameter.required()) &#123; throw new IllegalStateException(config.getClass().getSimpleName() + \".\" + key + \" == null\"); &#125; // 当方法为public Map getParameters()&#123;...&#125;时，就以此将Map中的key-value加入到参数集合 &#125; else if (\"getParameters\".equals(name) &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 0 &amp;&amp; method.getReturnType() == Map.class) &#123; // 通过 getParameters()方法，获取动态设置的配置项 Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) method.invoke(config, new Object[0]); if (map != null &amp;&amp; map.size() &gt; 0) &#123; String pre = (prefix != null &amp;&amp; prefix.length() &gt; 0 ? prefix + \".\" : \"\"); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue()); &#125; &#125; &#125; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; &#125; // 省略其它代码 $&#123;&#125;&#125; 上面代码主要就是将配置承载对象中的属性设置到属性集合Map中，用于构建Dubbo URL。整个逻辑需要注意，配置承载对象的getter方法上标注的 @Parameter 注解，以及配置承载对象的getParameters方法。 添加事件通知属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public abstract class AbstractConfig implements Serializable &#123; // 省略其它代码 $&#123;&#125; protected static void appendAttributes(Map&lt;Object, Object&gt; parameters, Object config) &#123; appendAttributes(parameters, config, null); &#125; /** * * @param parameters 参数集合 * @param config 配置对象 * @param prefix 属性前缀。用于配置项添加到参数集合中时的前缀 */ protected static void appendAttributes(Map&lt;Object, Object&gt; parameters, Object config, String prefix) &#123; if (config == null) &#123; return; &#125; Method[] methods = config.getClass().getMethods(); for (Method method : methods) &#123; try &#123; String name = method.getName(); // 选择方法为 返回值为基本类型 + public的getter/is方法 （和解析到配置类的过滤添加呼应） if ((name.startsWith(\"get\") || name.startsWith(\"is\")) &amp;&amp; !\"getClass\".equals(name) &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 0 &amp;&amp; isPrimitive(method.getReturnType())) &#123; // 选择带有@Parameter(attribute=true)的方法 Parameter parameter = method.getAnnotation(Parameter.class); if (parameter == null || !parameter.attribute()) &#123; continue; &#125; String key; parameter.key(); if (parameter.key().length() &gt; 0) &#123; key = parameter.key(); &#125; else &#123; int i = name.startsWith(\"get\") ? 3 : 2; key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1); &#125; // 获得属性值，存在则添加到参数集合中 Object value = method.invoke(config); if (value != null) &#123; if (prefix != null &amp;&amp; prefix.length() &gt; 0) &#123; key = prefix + \".\" + key; &#125; parameters.put(key, value); &#125; &#125; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; &#125; // 省略其它代码 $&#123;&#125;&#125; 上面代码主要用于Dubbo的事件通知的，具体是标注在MethodConfig配置承载对象的 getOnreturn(),getOnreturnMethod(),getOnthrow()…方法上。 AbstractInterfaceConfig 抽象配置类继承关系如下： 123AbstractConfig - AbstractMethodConfig - AbstractInterfaceConfig AbstractConfig抽象类的核心逻辑已经分析过，AbstractMethodConfig抽象类中没有比较重要的逻辑，基本都是 配置属性的设置/获取方法，就不再分析，接下来我们一起看下AbstractInterfaceConfig抽象类的逻辑。 校验注册中心配置123456789101112131415161718192021222324252627282930313233343536public abstract class AbstractInterfaceConfig extends AbstractMethodConfig &#123;// 省略其它代码 $&#123;&#125;protected void checkRegistry() &#123; // for backward compatibility if (registries == null || registries.isEmpty()) &#123; String address = ConfigUtils.getProperty(\"dubbo.registry.address\"); if (address != null &amp;&amp; address.length() &gt; 0) &#123; registries = new ArrayList&lt;RegistryConfig&gt;(); String[] as = address.split(\"\\\\s*[|]+\\\\s*\"); for (String a : as) &#123; RegistryConfig registryConfig = new RegistryConfig(); registryConfig.setAddress(a); registries.add(registryConfig); &#125; &#125; &#125; if ((registries == null || registries.isEmpty())) &#123; throw new IllegalStateException((getClass().getSimpleName().startsWith(\"Reference\") ? \"No such any registry to refer service in consumer \" : \"No such any registry to export service in provider \") + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", Please add &lt;dubbo:registry address=\\\"...\\\" /&gt; to your spring config. If you want unregister, please set &lt;dubbo:service registry=\\\"N/A\\\" /&gt;\"); &#125; for (RegistryConfig registryConfig : registries) &#123; // 调用AbstractConfig中的方法 appendProperties(registryConfig); &#125; &#125;// 省略其它代码 $&#123;&#125;&#125; 校验应用配置123456789101112131415161718192021222324252627282930313233public abstract class AbstractInterfaceConfig extends AbstractMethodConfig &#123;// 省略其它代码 $&#123;&#125; protected void checkApplication() &#123; // for backward compatibility if (application == null) &#123; String applicationName = ConfigUtils.getProperty(\"dubbo.application.name\"); if (applicationName != null &amp;&amp; applicationName.length() &gt; 0) &#123; application = new ApplicationConfig(); &#125; &#125; if (application == null) &#123; throw new IllegalStateException( \"No such application config! Please add &lt;dubbo:application name=\\\"...\\\" /&gt; to your spring config.\"); &#125; // 调用AbstractConfig中的方法 appendProperties(application); String wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_KEY); if (wait != null &amp;&amp; wait.trim().length() &gt; 0) &#123; System.setProperty(Constants.SHUTDOWN_WAIT_KEY, wait.trim()); &#125; else &#123; wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY); if (wait != null &amp;&amp; wait.trim().length() &gt; 0) &#123; System.setProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY, wait.trim()); &#125; &#125; &#125;// 省略其它代码 $&#123;&#125;&#125; 加载注册中心URL数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public abstract class AbstractInterfaceConfig extends AbstractMethodConfig &#123;// 省略其它代码 $&#123;&#125; /** * 加载注册中心URL数组 * * @param provider 是否是服务提供者 * @return URL数组 */ protected List&lt;URL&gt; loadRegistries(boolean provider) &#123; // 校验RegistryConfig 配置数组，不存在会抛出异常，并且该方法会初始化RegistryConfig的配置属性 checkRegistry(); // 创建注册中心URL数组 List&lt;URL&gt; registryList = new ArrayList&lt;URL&gt;(); if (registries != null &amp;&amp; !registries.isEmpty()) &#123; // 遍历RegistryConfig 数组 for (RegistryConfig config : registries) &#123; // 获取注册中心的地址 String address = config.getAddress(); // 地址为空就使用 0.0.0.0 任意地址 if (address == null || address.length() == 0) &#123; address = Constants.ANYHOST_VALUE; &#125; // 如果配置了启动参数的注册中心地址，它的优先级最高，就进行覆盖 String sysaddress = System.getProperty(\"dubbo.registry.address\"); if (sysaddress != null &amp;&amp; sysaddress.length() &gt; 0) &#123; address = sysaddress; &#125; // 选择有效的注册中心地址 if (address.length() &gt; 0 &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123; // 创建参数集合map,用于Dubbo URL的构建 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 将应用配置对象和注册中心配置对象的属性添加到参数集合map中 appendParameters(map, application); /** * 需要注意的是：RegistryConfig 的 getAddress方法上使用了 @Parameter(excluded = true)注解，因此它的address属性不会加入到参数集合map中 * @Parameter(excluded = true) * public String getAddress() &#123;return address;&#125; */ appendParameters(map, config); // 添加 path,dubbo,timestamp,pid 到参数集合map中 map.put(\"path\", RegistryService.class.getName()); // 这里的path要和服务暴露逻辑中的path区分，注册中心的URL中的path为RegistryService的全路径名 map.put(\"dubbo\", Version.getProtocolVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; // 参数集合map中不存在 protocol 参数【以上配置对象的属性中没有有效的协议protocol参数】，就默认 使用 dubbo 作为 协议protocol的值 if (!map.containsKey(\"protocol\")) &#123; // 不需考虑remote扩展实现的情况 if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(\"remote\")) &#123; map.put(\"protocol\", \"remote\"); &#125; else &#123; map.put(\"protocol\", \"dubbo\"); &#125; &#125; // 解析地址，创建Dubbo URL数组，注意address可能包含多个注册中心ip, 【数组大小可以为一】 List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map); // 循环 dubbo Register url for (URL url : urls) &#123; // 设置 registry=$&#123;protocol&#125;参数,设置到注册中心的 URL的参数部分的位置上，并且是追加式的添加 url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol()); // 重置 URL中的 protocol属性为 'registry',即将URL的协议头设置为'registry' url = url.setProtocol(Constants.REGISTRY_PROTOCOL); /** * 通过判断条件，决定是否添加url到registryList中，条件如下： * 1 如果是服务提供者,是否只订阅不注册，如果是就不添加到注册中心URL数组中 * 2 如果是服务消费者，是否是只注册不订阅，如果是就不添加到注册中心URL数组中 * */ if ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, true))) &#123; registryList.add(url); &#125; &#125; &#125; &#125; &#125; return registryList; &#125;// 省略其它代码 $&#123;&#125;&#125; 加载监控中心URL12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public abstract class AbstractInterfaceConfig extends AbstractMethodConfig &#123;// 省略其它代码 $&#123;&#125;/** * 加载监控中心URL * * @param registryURL 注册中心URL * @return 监控中心URL */ protected URL loadMonitor(URL registryURL) &#123; // 如果监控配置为空，就从属性配置中加载配置到MonitorConfig if (monitor == null) &#123; // 获取监控地址 String monitorAddress = ConfigUtils.getProperty(\"dubbo.monitor.address\"); // 获取监控协议 String monitorProtocol = ConfigUtils.getProperty(\"dubbo.monitor.protocol\"); // 没有配置就直接返回 if ((monitorAddress == null || monitorAddress.length() == 0) &amp;&amp; (monitorProtocol == null || monitorProtocol.length() == 0)) &#123; return null; &#125; // 创建MonitorConfig monitor = new MonitorConfig(); if (monitorAddress != null &amp;&amp; monitorAddress.length() &gt; 0) &#123; monitor.setAddress(monitorAddress); &#125; if (monitorProtocol != null &amp;&amp; monitorProtocol.length() &gt; 0) &#123; monitor.setProtocol(monitorProtocol); &#125; &#125; // 为MonitorConfig加载配置【启动参数变量和properties配置到配置对象】 appendProperties(monitor); // 添加 interface,dubbo,timestamp,pid 到 map 集合中 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(Constants.INTERFACE_KEY, MonitorService.class.getName()); map.put(\"dubbo\", Version.getProtocolVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; //set ip String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY); if (hostToRegistry == null || hostToRegistry.length() == 0) &#123; hostToRegistry = NetUtils.getLocalHost(); &#125; else if (isInvalidLocalHost(hostToRegistry)) &#123; throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + Constants.DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry); &#125; map.put(Constants.REGISTER_IP_KEY, hostToRegistry); appendParameters(map, monitor); appendParameters(map, application); // 获得监控地址 String address = monitor.getAddress(); // 如果启动参数配置了监控中心地址，就进行覆盖，启动参数优先级最高 String sysaddress = System.getProperty(\"dubbo.monitor.address\"); if (sysaddress != null &amp;&amp; sysaddress.length() &gt; 0) &#123; address = sysaddress; &#125; // 直连监控中心服务器地址 if (ConfigUtils.isNotEmpty(address)) &#123; // 若监控地址不存在 protocol 参数，默认 dubbo 添加到 map 集合中 if (!map.containsKey(Constants.PROTOCOL_KEY)) &#123; // logstat这个拓展实现已经不存在了,可以忽略 if (ExtensionLoader.getExtensionLoader(MonitorFactory.class).hasExtension(\"logstat\")) &#123; map.put(Constants.PROTOCOL_KEY, \"logstat\"); &#125; else &#123; map.put(Constants.PROTOCOL_KEY, \"dubbo\"); &#125; &#125; // 解析地址，创建Dubbo URL 对象 return UrlUtils.parseURL(address, map); /** * 1 当 protocol=registry时，并且注册中心URL非空时，从注册中心发现监控中心地址，以注册中心URL为基础，创建监控中心URL * 2 基于注册中心创建的监控中心URL： protocol = dubbo,parameters.protocol=registry,parameter.refer=map */ &#125; else if (Constants.REGISTRY_PROTOCOL.equals(monitor.getProtocol()) &amp;&amp; registryURL != null) &#123; return registryURL.setProtocol(\"dubbo\").addParameter(Constants.PROTOCOL_KEY, \"registry\").addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)); &#125; return null; &#125;// 省略其它代码 $&#123;&#125;&#125; 校验接口和方法列表123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class AbstractInterfaceConfig extends AbstractMethodConfig &#123;// 省略其它代码 $&#123;&#125; /** * 校验接口和方法： * 1 接口类必须非空并且必须是接口 * 2 方法在接口中已经定义 * * @param interfaceClass * @param methods */ protected void checkInterfaceAndMethods(Class&lt;?&gt; interfaceClass, List&lt;MethodConfig&gt; methods) &#123; // interface cannot be null if (interfaceClass == null) &#123; throw new IllegalStateException(\"interface not allow null!\"); &#125; // to verify interfaceClass is an interface if (!interfaceClass.isInterface()) &#123; throw new IllegalStateException(\"The interface class \" + interfaceClass + \" is not a interface!\"); &#125; // check if methods exist in the interface if (methods != null &amp;&amp; !methods.isEmpty()) &#123; for (MethodConfig methodBean : methods) &#123; String methodName = methodBean.getName(); if (methodName == null || methodName.length() == 0) &#123; throw new IllegalStateException(\"&lt;dubbo:method&gt; name attribute is required! Please check: &lt;dubbo:service interface=\\\"\" + interfaceClass.getName() + \"\\\" ... &gt;&lt;dubbo:method name=\\\"\\\" ... /&gt;&lt;/&lt;dubbo:reference&gt;\"); &#125; boolean hasMethod = false; for (java.lang.reflect.Method method : interfaceClass.getMethods()) &#123; if (method.getName().equals(methodName)) &#123; hasMethod = true; break; &#125; &#125; if (!hasMethod) &#123; throw new IllegalStateException(\"The interface \" + interfaceClass.getName() + \" not found method \" + methodName); &#125; &#125; &#125; &#125;// 省略其它代码 $&#123;&#125;&#125; 校验Stub和Mock相关的配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public abstract class AbstractInterfaceConfig extends AbstractMethodConfig &#123;// 省略其它代码 $&#123;&#125; /** * 校验Stub和Mock相关的配置 * * @param interfaceClass */ protected void checkStubAndMock(Class&lt;?&gt; interfaceClass) &#123; if (ConfigUtils.isNotEmpty(local)) &#123; Class&lt;?&gt; localClass = ConfigUtils.isDefault(local) ? ReflectUtils.forName(interfaceClass.getName() + \"Local\") : ReflectUtils.forName(local); if (!interfaceClass.isAssignableFrom(localClass)) &#123; throw new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceClass.getName()); &#125; try &#123; ReflectUtils.findConstructor(localClass, interfaceClass); &#125; catch (NoSuchMethodException e) &#123; throw new IllegalStateException(\"No such constructor \\\"public \" + localClass.getSimpleName() + \"(\" + interfaceClass.getName() + \")\\\" in local implementation class \" + localClass.getName()); &#125; &#125; if (ConfigUtils.isNotEmpty(stub)) &#123; Class&lt;?&gt; localClass = ConfigUtils.isDefault(stub) ? ReflectUtils.forName(interfaceClass.getName() + \"Stub\") : ReflectUtils.forName(stub); if (!interfaceClass.isAssignableFrom(localClass)) &#123; throw new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceClass.getName()); &#125; try &#123; ReflectUtils.findConstructor(localClass, interfaceClass); &#125; catch (NoSuchMethodException e) &#123; throw new IllegalStateException(\"No such constructor \\\"public \" + localClass.getSimpleName() + \"(\" + interfaceClass.getName() + \")\\\" in local implementation class \" + localClass.getName()); &#125; &#125; // mock 配置校验 if (ConfigUtils.isNotEmpty(mock)) &#123; // 如果mock以 'return' 开头，则去掉该前缀 if (mock.startsWith(Constants.RETURN_PREFIX)) &#123; // 获取return 指定的内容 String value = mock.substring(Constants.RETURN_PREFIX.length()); try &#123; // 解析return指定的内容，并转换成对应的返回类型 MockInvoker.parseMockValue(value); &#125; catch (Exception e) &#123; throw new IllegalStateException(\"Illegal mock json value in &lt;dubbo:service ... mock=\\\"\" + mock + \"\\\" /&gt;\"); &#125; // 不是以 'return' 开头 &#125; else &#123; // 获得Mock类 Class&lt;?&gt; mockClass = ConfigUtils.isDefault(mock) ? ReflectUtils.forName(interfaceClass.getName() + \"Mock\") : ReflectUtils.forName(mock); // 校验是否实现接口 if (!interfaceClass.isAssignableFrom(mockClass)) &#123; throw new IllegalStateException(\"The mock implementation class \" + mockClass.getName() + \" not implement interface \" + interfaceClass.getName()); &#125; // 校验是否有默认的构造方法 try &#123; mockClass.getConstructor(new Class&lt;?&gt;[0]); &#125; catch (NoSuchMethodException e) &#123; throw new IllegalStateException(\"No such empty constructor \\\"public \" + mockClass.getSimpleName() + \"()\\\" in mock implementation class \" + mockClass.getName()); &#125; &#125; &#125; &#125;// 省略其它代码 $&#123;&#125;&#125; ServiceConfig 配置类该类是 服务暴露 的核心类，我们在 Dubbo示例 - API配置 中已经使用API的方式创建一个Dubbo应用，最后通过调用 ServiceConfig#export()方法进行服务的导出，ServiceConfig 继承关系如下： 12345AbstractConfig - AbstractMethodConfig - AbstractInterfaceConfig - AbstractServiceConfig - ServiceConfig AbstractServiceConfig 抽象类中也没有核心的逻辑，主要就是配置属性的设置和获取方法，因此也不再分析。 ServiceConfig#export()方法主要做以下几件事： 进一步初始化Dubbo的配置承载对象，因为有的配置对象我们可能并没有显示创建或配置。 对配置对象们进行校验是否为空，为空则新建，或者抛出异常。 ServiceConfig聚集了Dubbo服务的的所有配置属性，使用它的属性构建Dubbo URL对象 进行服务暴露 ServiceConfig 属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ServiceConfig&lt;T&gt; extends AbstractServiceConfig &#123; /** * 自适应 Protocol实现对象 */ private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension(); /** * 自适应 ProxyFactory 实现对象 */ private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension(); /** * 随机端口集合 */ private static final Map&lt;String, Integer&gt; RANDOM_PORT_MAP = new HashMap&lt;String, Integer&gt;(); /** * 延迟暴露线程池 */ private static final ScheduledExecutorService delayExportExecutor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"DubboServiceDelayExporter\", true)); private final List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); /** * 服务配置暴露的Exporter 集合 */ private final List&lt;Exporter&lt;?&gt;&gt; exporters = new ArrayList&lt;Exporter&lt;?&gt;&gt;(); /** * 服务接口全路径名 */ private String interfaceName; /** * 非配置，通过interfaceName 通过反射获得 */ private Class&lt;?&gt; interfaceClass; /** * 服务接口的实现对象 */ private T ref; /** * 服务名 */ private String path; /** * 服务方法配置对象集合 */ private List&lt;MethodConfig&gt; methods; /** * 服务提供者默认配置的配置对象 */ private ProviderConfig provider; private transient volatile boolean exported; private transient volatile boolean unexported; /** * 泛化 */ private volatile String generic; // 省略其它代码 $&#123;&#125;&#125; 进一步初始化配置承载对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182public class ServiceConfig&lt;T&gt; extends AbstractServiceConfig &#123; // 省略其它代码 $&#123;&#125; /** * 暴露服务入口，加jvm锁 */ public synchronized void export() &#123; // 当export 或者 delay 未配置时，从ProviderConfig对象读取 if (provider != null) &#123; if (export == null) &#123; export = provider.getExport(); &#125; if (delay == null) &#123; delay = provider.getDelay(); &#125; &#125; // 不暴露服务(export = false),则不进行暴露服务逻辑 if (export != null &amp;&amp; !export) &#123; return; &#125; // 延迟暴露的话，就是使用任务线程池ScheduledExecutorService处理 if (delay != null &amp;&amp; delay &gt; 0) &#123; delayExportExecutor.schedule(new Runnable() &#123; @Override public void run() &#123; doExport(); &#125; &#125;, delay, TimeUnit.MILLISECONDS); &#125; else &#123; doExport(); &#125; &#125; /** * 服务暴露，jvm锁 */ protected synchronized void doExport() &#123; // 检查是否可以暴露，若可以，标记已经暴露然后执行服务暴露逻辑 if (unexported) &#123; throw new IllegalStateException(\"Already unexported!\"); &#125; // 如果已经暴露了直接返回 if (exported) &#123; return; &#125; // 标记已经暴露过了 exported = true; // 校验interfaceName 是否合法，即接口名非空 if (interfaceName == null || interfaceName.length() == 0) &#123; throw new IllegalStateException(\"&lt;dubbo:service interface=\\\"\\\" /&gt; interface not allow null!\"); &#125; // 校验provider是否为空，为空则新建一个，并拼接属性配置（环境变量 + .properties文件中的 属性）到ProviderConfig对象 checkDefault(); // 检测application，module等核心配置类对象是否为空，若为空则尝试从其他配置类对象中获取对应的实例。即： 从ProviderConfig 对象中，读取application,module,registries,monitor,protocols配置对象 if (provider != null) &#123; if (application == null) &#123; application = provider.getApplication(); &#125; if (module == null) &#123; module = provider.getModule(); &#125; if (registries == null) &#123; registries = provider.getRegistries(); &#125; if (monitor == null) &#123; monitor = provider.getMonitor(); &#125; if (protocols == null) &#123; protocols = provider.getProtocols(); &#125; &#125; // 从ModuleConfig 对象中，读取registries,monitor配置对象 if (module != null) &#123; if (registries == null) &#123; registries = module.getRegistries(); &#125; if (monitor == null) &#123; monitor = module.getMonitor(); &#125; &#125; // 从ApplicationConfig 对象中，读取registries,monitor配置对象 if (application != null) &#123; if (registries == null) &#123; registries = application.getRegistries(); &#125; if (monitor == null) &#123; monitor = application.getMonitor(); &#125; &#125; // 检测ref是否泛化接口的实现 if (ref instanceof GenericService) &#123; // 设置 interfaceClass 为 GenericService.class interfaceClass = GenericService.class; if (StringUtils.isEmpty(generic)) &#123; // 设置 generic = \"true\" generic = Boolean.TRUE.toString(); &#125; // 普通接口的实现 &#125; else &#123; try &#123; // 通过反射获取对应的接口的Class interfaceClass = Class.forName(interfaceName, true, Thread.currentThread() .getContextClassLoader()); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; // 检验接口和方法 （接口非空，方法都在接口中定义） checkInterfaceAndMethods(interfaceClass, methods); // 校验引用ref是否实现了当前接口 checkRef(); // 标记为非泛化实现 generic = Boolean.FALSE.toString(); &#125; /** 处理服务接口客户端本地代理,即本地存根（local 属性 -&gt; AbstractInterfaceConfig#setLocal）。目前已经废弃，此处主要用于兼容，使用stub属性. todo 服务端没有意义 &#123;@link StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125; */ if (local != null) &#123; // 如果local属性设置为ture，表示使用缺省代理类名，即：接口名 + Local 后缀 if (\"true\".equals(local)) &#123; local = interfaceName + \"Local\"; &#125; Class&lt;?&gt; localClass; try &#123; // 获取本地存根类 localClass = ClassHelper.forNameWithThreadContextClassLoader(local); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; // 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法 if (!interfaceClass.isAssignableFrom(localClass)) &#123; throw new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceName); &#125; &#125; /** 处理服务接口客户端本地代理(stub 属性)相关，即本地存根。目的：想在客户端【服务消费方】执行需要的逻辑，不局限服务提供的逻辑。本地存根类编写方式是固定。todo 服务端没有意义 &#123;@link StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125;*/ if (stub != null) &#123; // 如果stub属性设置为ture，表示使用缺省代理类名，即：接口名 + Stub 后缀 if (\"true\".equals(stub)) &#123; stub = interfaceName + \"Stub\"; &#125; Class&lt;?&gt; stubClass; try &#123; // 获取本地存根类 stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; // 判断interfaceClass 是否是 stubClass 的接口，即 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法 if (!interfaceClass.isAssignableFrom(stubClass)) &#123; throw new IllegalStateException(\"The stub implementation class \" + stubClass.getName() + \" not implement interface \" + interfaceName); &#125; &#125; /* 检测各种对象是否为空，为空则新建，或者抛出异常*/ // 校验ApplicationConfig配置 checkApplication(); // 校验RegistryConfig配置 checkRegistry(); // 校验ProtocolConfig配置数组 checkProtocol(); // 读取环境变量和properties配置到ServiceConfig对象（自己） appendProperties(this); // 校验Stub和Mock相关的配置 checkStubAndMock(interfaceClass); // 服务路径，缺省是接口名 if (path == null || path.length() == 0) &#123; path = interfaceName; &#125; // 暴露服务 doExportUrls(); ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref); ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel); &#125; // 省略其它代码 $&#123;&#125;&#125; 多协议多注册中心123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196public class ServiceConfig&lt;T&gt; extends AbstractServiceConfig &#123; // 省略其它代码 $&#123;&#125; /** * Dubbo 允许我们使用不同的协议导出服务，也允许我们向多个注册中心注册服务。Dubbo 在 doExportUrls 方法中对多协议，多注册中心进行了支持 */ @SuppressWarnings(&#123;\"unchecked\", \"rawtypes\"&#125;) private void doExportUrls() &#123; // 加载注册中心URL 数组 【协议已经处理过，不再是配置的注册中心协议 如：zookeeper ,而是统一替换成了registry】 List&lt;URL&gt; registryURLs = loadRegistries(true); // 遍历协议集合，支持多协议暴露。 for (ProtocolConfig protocolConfig : protocols) &#123; doExportUrlsFor1Protocol(protocolConfig, registryURLs); &#125; &#125; /** * 使用不同的协议，逐个向注册中心分组暴露服务。该方法中包含了本地和远程两种暴露方式 * * @param protocolConfig 协议配置对象 * @param registryURLs 处理过的注册中心分组集合【已经添加了ApplicationConfig和RegistryConfig的参数】 */ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; // 协议名 String name = protocolConfig.getName(); // 协议名为空时，缺省设置为 dubbo if (name == null || name.length() == 0) &#123; name = \"dubbo\"; &#125; // 创建参数集合map，用于Dubbo URL 的构建（服务提供者URL） Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 将side,dubbo,timestamp,pid参数，添加到map集合中 map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE); map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; // 通过反射将各种配置对象中的属性添加到map集合中，map用于URL的构建【注意属性覆盖问题】 appendParameters(map, application); appendParameters(map, module); appendParameters(map, provider, Constants.DEFAULT_KEY); appendParameters(map, protocolConfig); appendParameters(map, this); // 将MethodConfig 对象数组添加到 map 集合中。就是将每个MethodConfig和其对应的ArgumentConfig对象数组添加到map中【处理方法相关的属性到map】 if (methods != null &amp;&amp; !methods.isEmpty()) &#123; // methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method&gt; 标签的配置信息 for (MethodConfig method : methods) &#123; /** * 将MethodConfig对象的属性添加到map集合中，其中属性键 = 方法名.属性名。如： * &lt;dubbo:method name=\"sleep\" retries=\"2\"&gt;&lt;/dubbo:method&gt;对应的MethodConfig，属性到map的格式 map=&#123;\"sleep.retries\":2,...&#125; */ appendParameters(map, method, method.getName()); // 当配置了 MehodConfig.retry = false 时，强制禁用重试 String retryKey = method.getName() + \".retry\"; if (map.containsKey(retryKey)) &#123; String retryValue = map.remove(retryKey); // 检测 MethodConfig retry 是否为 false，若是，则设置重试次数为0 if (\"false\".equals(retryValue)) &#123; map.put(method.getName() + \".retries\", \"0\"); &#125; &#125; // 将MethodConfig下的ArgumentConfig 对象数组，添加到 map 集合中 List&lt;ArgumentConfig&gt; arguments = method.getArguments(); if (arguments != null &amp;&amp; !arguments.isEmpty()) &#123; for (ArgumentConfig argument : arguments) &#123; // 检测type 属性是否为空， if (argument.getType() != null &amp;&amp; argument.getType().length() &gt; 0) &#123; // 通过反射取出接口的方法列表 Method[] methods = interfaceClass.getMethods(); // 遍历接口中的方法列表 if (methods != null &amp;&amp; methods.length &gt; 0) &#123; for (int i = 0; i &lt; methods.length; i++) &#123; String methodName = methods[i].getName(); // 比对方法名，查找目标方法 if (methodName.equals(method.getName())) &#123; // 通过反射取出目标方法的参数类型列表 Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes(); // 若果配置index配置项，且值不为-1 if (argument.getIndex() != -1) &#123; // 从argtypes数组中获取下标index处的元素argType，并检测ArgumentConfig中的type属性与argType名称是否一致，不一致则抛出异常 if (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123; // 将ArgumentConfig对象的属性添加到map集合中，键前缀=方法名.index，如：map = &#123;\"sleep.2\":true&#125; appendParameters(map, argument, method.getName() + \".\" + argument.getIndex()); &#125; else &#123; throw new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType()); &#125; &#125; else &#123; // 遍历参数类型数组argtypes，查找argument.type类型的参数 for (int j = 0; j &lt; argtypes.length; j++) &#123; Class&lt;?&gt; argclazz = argtypes[j]; // 从参数类型列表中查找类型名称为argument.type的参数 if (argclazz.getName().equals(argument.getType())) &#123; // 将ArgumentConfig对象的属性添加到map集合中 appendParameters(map, argument, method.getName() + \".\" + j); if (argument.getIndex() != -1 &amp;&amp; argument.getIndex() != j) &#123; throw new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType()); &#125; &#125; &#125; &#125; &#125; &#125; &#125; // 用户未配置 type 属性，但配置了index属性，且index != -1 &#125; else if (argument.getIndex() != -1) &#123; // 指定单个参数的位置 // 将ArgumentConfig对象的属性添加到map集合中 appendParameters(map, argument, method.getName() + \".\" + argument.getIndex()); &#125; else &#123; throw new IllegalArgumentException(\"argument config must set index or type attribute.eg: &lt;dubbo:argument index='0' .../&gt; or &lt;dubbo:argument type=xxx .../&gt;\"); &#125; &#125; &#125; &#125; // end of methods for &#125; //------------------- 检测 generic 是否 为 true ,并根据检测结果向map中添加不同的信息 ---/ // 将 generic,methods,revision 加入到数组 if (ProtocolUtils.isGeneric(generic)) &#123; map.put(Constants.GENERIC_KEY, generic); map.put(Constants.METHODS_KEY, Constants.ANY_VALUE); &#125; else &#123; // 先从MAINFEST.MF 中获取版本号，若获取不到，再从jar包命名中可能带的版本号作为结果，如 2.6.5.RELEASE。若都不存在，返回默认版本号【源码运行可能会没有】 String revision = Version.getVersion(interfaceClass, version); if (revision != null &amp;&amp; revision.length() &gt; 0) &#123; map.put(\"revision\", revision); // 修订号 &#125; // 为接口生成包裹类 Wrapper，Wrapper 中包含了接口的详细信息，比如接口方法名数组，字段信息等【Dubbo 自定义功能类】 String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames(); // 添加方法名到 map 中，如果包含多个方法名，则用逗号隔开，比如：method=a,b if (methods.length == 0) &#123; logger.warn(\"NO method found in service interface \" + interfaceClass.getName()); // 没有方法名就添加 method=* map.put(Constants.METHODS_KEY, Constants.ANY_VALUE); &#125; else &#123; // 将逗号作为分隔符连接方法名，并将连接后的字符串放入 map 中 map.put(Constants.METHODS_KEY, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), \",\")); &#125; &#125; // token 【使暴露出去的服务更安全，使用token做安全校验】 if (!ConfigUtils.isEmpty(token)) &#123; if (ConfigUtils.isDefault(token)) &#123; map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString()); &#125; else &#123; map.put(Constants.TOKEN_KEY, token); &#125; &#125; // 协议为injvm时，不注册，不通知 if (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123; protocolConfig.setRegister(false); map.put(\"notify\", \"false\"); &#125; // 获得基础路径 String contextPath = protocolConfig.getContextpath(); if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) &#123; contextPath = provider.getContextpath(); &#125; // --------------------------- 主机绑定----------------------------/ // 获得注册到注册中心的服务提供者host，并为map设置bind.ip , anyhost 两个key String host = this.findConfigedHosts(protocolConfig, registryURLs, map); // 获取端口，并为map设置bing.port key Integer port = this.findConfigedPorts(protocolConfig, name, map); /** * 创建Dubbo URL对象 【注意这里的 path 的值】 * 1 name: 协议名 * 2 host: 主机名 * 3 port: 端口 * 4 path: 【基础路径】/path * 5 parameters: 属性集合map */ URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? \"\" : contextPath + \"/\") + path, map); // 省略服务暴露代码 &#125; // 省略其它代码 $&#123;&#125;&#125; ReferenceConfig 配置类该类是 服务引用 的核心类，我们在 Dubbo示例 - API配置 中已经使用API的方式创建一个Dubbo应用，最后通过调用 ReferenceConfig#get()方法引用服务，ReferenceConfig 继承关系如下： 12345AbstractConfig - AbstractMethodConfig - AbstractInterfaceConfig - AbstractReferenceConfig - ReferenceConfig AbstractReferenceConfig 抽象类中也没有核心的逻辑，主要就是配置属性的设置和获取方法，因此也不再分析。 ReferenceConfig#get()方法主要做以下几件事： 进一步初始化Dubbo的配置承载对象，因为有的配置对象我们可能并没有显示创建或配置。 对配置对象们进行校验是否为空，为空则新建，或者抛出异常。 ReferenceConfig聚集了Dubbo服务消费者的的所有配置属性，使用它的属性构建Dubbo URL对象 进行服务引用 ReferenceConfig 属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ReferenceConfig&lt;T&gt; extends AbstractReferenceConfig &#123; /** * 自适应 Protocol 拓展实现 */ private static final Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension(); /** * 自适应 Cluster 拓展实现 */ private static final Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension(); /** * 自适应 ProxyFactory 拓展实现 */ private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension(); /** * 服务引用URL数组 */ private final List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); /** * 服务接口名 */ private String interfaceName; /** * 服务接口 */ private Class&lt;?&gt; interfaceClass; /** * 连接类型 */ private String client; /** * 直连服务提供者地址 * 1 可以是注册中心，也可以是服务提供者 * 2 可以配置多个，使用 \";\" 分割 */ private String url; /** * 方法配置对象集合 */ private List&lt;MethodConfig&gt; methods; /** * 消费者默认配置的配置对象 */ private ConsumerConfig consumer; /** * 协议 */ private String protocol; /** * 服务接口代理对象 */ private transient volatile T ref; /** * Invoker */ private transient volatile Invoker&lt;?&gt; invoker; private transient volatile boolean initialized; private transient volatile boolean destroyed; // 省略其它代码 $&#123;&#125;&#125; 进一步初始化配置承载对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230public class ReferenceConfig&lt;T&gt; extends AbstractReferenceConfig &#123; // 省略其它代码 $&#123;&#125; public synchronized T get() &#123; // 已销毁，不可获得 if (destroyed) &#123; throw new IllegalStateException(\"Already destroyed!\"); &#125; // 若未初始化，调用init()方法进行初始化 if (ref == null) &#123; init(); &#125; // 返回引用服务 return ref; &#125; private void init() &#123; // 已经初始化过，直接返回 if (initialized) &#123; return; &#125; initialized = true; // 校验接口名非空 if (interfaceName == null || interfaceName.length() == 0) &#123; throw new IllegalStateException(\"&lt;dubbo:reference interface=\\\"\\\" /&gt; interface not allow null!\"); &#125; // 拼接属性配置（环境变量 + .properties 中的属性）到 ConsumerConfig对象 checkDefault(); // 拼接属性配置（环境变量 + .properties 中的属性）到ReferenceConfig（自己） appendProperties(this); // 若未设置 generic 属性，就使用ConsumerConfig的generic属性 if (getGeneric() == null &amp;&amp; getConsumer() != null) &#123; setGeneric(getConsumer().getGeneric()); &#125; // 是否是泛化接口的实现，如果是泛化接口实现的话，就直接设置当前接口为 GenericService.class if (ProtocolUtils.isGeneric(getGeneric())) &#123; interfaceClass = GenericService.class; // 普通接口的实现 &#125; else &#123; try &#123; // 根据接口名，获得对应的接口类 interfaceClass = Class.forName(interfaceName, true, Thread.currentThread().getContextClassLoader()); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; // 校验接口和方法 checkInterfaceAndMethods(interfaceClass, methods); &#125; // 直连提供者，第一优先级，通过 -D 参数（系统变量）指定 ，例如 java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890 String resolve = System.getProperty(interfaceName); String resolveFile = null; // 直连提供者第二优先级，通过文件映射，例如 com.alibaba.xxx.XxxService=dubbo://localhost:20890 if (resolve == null || resolve.length() == 0) &#123; // 从系统属性中获取解析文件路径 resolveFile = System.getProperty(\"dubbo.resolve.file\"); if (resolveFile == null || resolveFile.length() == 0) &#123; // 默认先加载 $&#123;user.home&#125;/dubbo-resolve.properties 文件，无需配置，自动加载 File userResolveFile = new File(new File(System.getProperty(\"user.home\")), \"dubbo-resolve.properties\"); if (userResolveFile.exists()) &#123; // 获取文件绝对路径 resolveFile = userResolveFile.getAbsolutePath(); &#125; &#125; // 存在resolveFile,则进行文件读取加载 if (resolveFile != null &amp;&amp; resolveFile.length() &gt; 0) &#123; Properties properties = new Properties(); FileInputStream fis = null; try &#123; fis = new FileInputStream(new File(resolveFile)); // 从文件中加载配置 properties.load(fis); &#125; catch (IOException e) &#123; throw new IllegalStateException(\"Unload \" + resolveFile + \", cause: \" + e.getMessage(), e); &#125; finally &#123; try &#123; if (null != fis) &#123; fis.close(); &#125; &#125; catch (IOException e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; // 根据服务全路径名获取对应的 直连提供者的url resolve = properties.getProperty(interfaceName); &#125; &#125; // 设置直连提供者的 url if (resolve != null &amp;&amp; resolve.length() &gt; 0) &#123; url = resolve; if (logger.isWarnEnabled()) &#123; if (resolveFile != null) &#123; logger.warn(\"Using default dubbo resolve file \" + resolveFile + \" replace \" + interfaceName + \"\" + resolve + \" to p2p invoke remote service.\"); &#125; else &#123; logger.warn(\"Using -D\" + interfaceName + \"=\" + resolve + \" to p2p invoke remote service.\"); &#125; &#125; &#125; // 不通过系统属性指定，就使用配置的直连（在配置的前提下），如：&lt;dubbo:reference id=\"xxxService\" interface=\"com.alibaba.xxx.XxxService\" url=\"dubbo://localhost:20890\" /&gt; // 尝试从ConsumerConfig 对象中，读取 application,module,registries,monitor 配置对象 if (consumer != null) &#123; if (application == null) &#123; application = consumer.getApplication(); &#125; if (module == null) &#123; module = consumer.getModule(); &#125; if (registries == null) &#123; registries = consumer.getRegistries(); &#125; if (monitor == null) &#123; monitor = consumer.getMonitor(); &#125; &#125; // 从ModuleConfig 对象中，读取registries,monitor配置对象 if (module != null) &#123; if (registries == null) &#123; registries = module.getRegistries(); &#125; if (monitor == null) &#123; monitor = module.getMonitor(); &#125; &#125; // 从ApplicationConfig对象中，读取registries,monitor配置对象 if (application != null) &#123; if (registries == null) &#123; registries = application.getRegistries(); &#125; if (monitor == null) &#123; monitor = application.getMonitor(); &#125; &#125; // 校验ApplicationConfig配置 checkApplication(); // 校验 Stub和 Mock 相关的配置 checkStubAndMock(interfaceClass); // 创建参数集合map，用于下面创建Dubbo URL Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 符合条件的方法对象的属性，主要用来Dubbo事件通知 Map&lt;Object, Object&gt; attributes = new HashMap&lt;Object, Object&gt;(); // 将 side，dubbo,timestamp,pid参数，添加到map集合中 map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE); map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; // 非泛化服务，设置revision,methods,interface加入到map集合中 if (!isGeneric()) &#123; String revision = Version.getVersion(interfaceClass, version); if (revision != null &amp;&amp; revision.length() &gt; 0) &#123; map.put(\"revision\", revision); &#125; // 获取接口方法列表，并添加到map中 String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames(); if (methods.length == 0) &#123; logger.warn(\"NO method found in service interface \" + interfaceClass.getName()); map.put(\"methods\", Constants.ANY_VALUE); &#125; else &#123; map.put(\"methods\", StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), \",\")); &#125; &#125; map.put(Constants.INTERFACE_KEY, interfaceName); // 将各种配置对象中的属性，添加到 map 集合中 appendParameters(map, application); appendParameters(map, module); appendParameters(map, consumer, Constants.DEFAULT_KEY); appendParameters(map, this); // 获得服务键，作为前缀 格式：group/interface:version String prefix = StringUtils.getServiceKey(map); // 将MethodConfig 对象数组中每个MethodConfig中的属性添加到map中 if (methods != null &amp;&amp; !methods.isEmpty()) &#123; // 遍历 MethodConfig 列表 for (MethodConfig method : methods) &#123; appendParameters(map, method, method.getName()); // 当配置了 MethodConfig.retry=false 时，强制禁用重试 String retryKey = method.getName() + \".retry\"; if (map.containsKey(retryKey)) &#123; String retryValue = map.remove(retryKey); if (\"false\".equals(retryValue)) &#123; // 添加重试次数配置 methodName.retries map.put(method.getName() + \".retries\", \"0\"); &#125; &#125; // 将带有@Parameter(attribute=true)配置对象的属性，添加到参数集合中 appendAttributes(attributes, method, prefix + \".\" + method.getName()); // 检查属性集合中的事件通知方法是否正确，若正确，进行转换 checkAndConvertImplicitConfig(method, map, attributes); &#125; &#125; // 以系统环境变量（DUBBO_IP_TO_REGISTRY）的值作为服务消费者ip地址,没有设置再取主机地址 String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY); if (hostToRegistry == null || hostToRegistry.length() == 0) &#123; hostToRegistry = NetUtils.getLocalHost(); &#125; else if (isInvalidLocalHost(hostToRegistry)) &#123; throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + Constants.DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry); &#125; map.put(Constants.REGISTER_IP_KEY, hostToRegistry); // 把attributes集合添加到StaticContext进行缓存，为了以后的事件通知 StaticContext.getSystemContext().putAll(attributes); try&#123; System.out.println(\" ref = createProxy(map); is begin.....\"); Thread.sleep(5000); &#125;catch (Exception ex)&#123; &#125; // 省略服务引用代码 &#125; // 省略其它代码 $&#123;&#125;&#125; 其它配置类前面只是针对Dubbo的核心配置类进行了分析，还很多其它的配置类并没有分析到(ServiceBean和ReferenceBean属于整合Spring的配置类，我们在XML配置中分析)，不过没有分析到的配置类中几乎都没有复杂的逻辑，大多是封装了配置属性的设置和获取操作。每个配置类中封装的配置属性都有所不同，那些抽象的配置类封装的都是可供不同子类复用的属性和方法，每个配置类可以设置那些属性我们可以参考官方文档，需要说明的是，官网给出的是XML配置形式，不过按照对应的规则转换就可以相通了。 总结Dubbo的配置相对比较枯燥，刚开始看的时候可能有点蒙圈，笔者也是硬着头皮看了好久，看完后也不是很理解，但是把整个流程看完后再回来看体会就更深了。XML配置和注解配置也是基于API配置和属性配置的，区别是XML配置和注解配置要解决和Spring融合问题，我们在接下来的文章中再详细分析。嘿咻，整篇文章都在贴代码！","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"Dubbo源码分析 - 动态编译","slug":"rpc/Dubbo动态编译","date":"2020-03-21T16:00:00.000Z","updated":"2020-09-03T03:12:53.630Z","comments":false,"path":"posts/68ac5094/","link":"","permalink":"https://gentryhuang.com/posts/68ac5094/","excerpt":"","text":"概述在Dubbo自适应扩展中，我们已经得到了自适应扩展类的字符串，需要通过编译才能得到真正的Class，本篇文章就来介绍将类的字符串编译成类的过程。 动态编译 dubbo 的动态编译的整体结构如上图所示。dubbo中的Compiler基于dubbo spi机制进行加载，目前支持jdk和javassist两种实现： 12&lt;dubbo:application compiler=\"jdk\" /&gt;&lt;dubbo:application compiler=\"javassist\" /&gt; 整体了解了dubbo的动态编译后，我们接着上一篇文章继续分析，dubbo动态编译入口的代码如下： 12345678910private Class&lt;?&gt; createAdaptiveExtensionClass() &#123; // 生成自适应拓展实现的代码字符串 String code = createAdaptiveExtensionClassCode(); // 获取类加载器 ClassLoader classLoader = findClassLoader(); // 获取Compiler自适应扩展对象 com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension(); // 动态编译，生成Class return compiler.compile(code, classLoader);&#125; 该方法在编译阶段需要先获取自适应编译对象，然后调用该对象的compile方法进行代码的编译。其实这里并不是直接使用自适应对象进行代码编译，而是将具体的编译任务交给子类来完成，即JdkCompiler子类和JavassistCompiler子类，下面我们来看看dubbo 动态编译的成员及它们的用途。 Compiler 扩展接口12345678910111213141516/** * Compiler. (SPI, Singleton, ThreadSafe) * 使用Dubbo SPI机制，默认拓展名为javassist */@SPI(\"javassist\")public interface Compiler &#123; /** * 编译Java 代码 * * @param code Java代码字符串 * @param classLoader 类加载器 * @return Compiled class 编译后的类 */ Class&lt;?&gt; compile(String code, ClassLoader classLoader);&#125; AdaptiveCompiler 固定自适应扩展类12345678910111213141516171819202122232425262728293031323334353637383940/** * AdaptiveCompiler. (SPI, Singleton, ThreadSafe) * 实现Compiler接口，带有@Adaptive注解，是固定的自适应实现类 */@Adaptivepublic class AdaptiveCompiler implements Compiler &#123; /** * 默认编辑器的拓展名 */ private static volatile String DEFAULT_COMPILER; /** * 静态方法，设置默认编辑器的拓展名。该方法被 &#123;@link com.alibaba.dubbo.config.ApplicationConfig#setCompiler(java.lang.String)&#125;方法调用. * 在&lt;dubbo:application compiler=\"\"/&gt; 配置 可触发该方法 * * @param compiler */ public static void setDefaultCompiler(String compiler) &#123; DEFAULT_COMPILER = compiler; &#125; @Override public Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123; Compiler compiler; // 获得Compiler的ExtensionLoader对象 ExtensionLoader&lt;Compiler&gt; loader = ExtensionLoader.getExtensionLoader(Compiler.class); // 声明 name 变量 String name = DEFAULT_COMPILER; // 使用设置的拓展名，获得Compiler拓展对象 if (name != null &amp;&amp; name.length() &gt; 0) &#123; compiler = loader.getExtension(name); // 获得默认的Compiler拓展对象 &#125; else &#123; compiler = loader.getDefaultExtension(); &#125; // 使用真正的Compiler对象，动态编译代码 return compiler.compile(code, classLoader); &#125;&#125; 该类使用了@Adaptive注解，说明AdaptiveCompiler会固定为默认实现，通过代码的逻辑不难发现，该类主要用来管理其它的Compiler,每次调用compiler方法时会尝试根据扩展名获取Compiler的扩展对象，默认情况下使用JavassistCompiler扩展对象，然后使用编译对象进行动态编译代码串。 AbstractCompiler 抽象编译类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public abstract class AbstractCompiler implements Compiler &#123; /** * 包名的正则表达式，注意匹配组 */ private static final Pattern PACKAGE_PATTERN = Pattern.compile(\"package\\\\s+([$_a-zA-Z][$_a-zA-Z0-9\\\\.]*);\"); /** * 类名的正则表达式，注意匹配组 */ private static final Pattern CLASS_PATTERN = Pattern.compile(\"class\\\\s+([$_a-zA-Z][$_a-zA-Z0-9]*)\\\\s+\"); @Override public Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123; // 获得包名 code = code.trim(); Matcher matcher = PACKAGE_PATTERN.matcher(code); String pkg; if (matcher.find()) &#123; pkg = matcher.group(1); &#125; else &#123; pkg = \"\"; &#125; // 获得类名 matcher = CLASS_PATTERN.matcher(code); String cls; if (matcher.find()) &#123; cls = matcher.group(1); &#125; else &#123; throw new IllegalArgumentException(\"No such class name in \" + code); &#125; // 获得完整类名： 包名.类名 String className = pkg != null &amp;&amp; pkg.length() &gt; 0 ? pkg + \".\" + cls : cls; try &#123; // 使用类加载器尝试加载类，如果加载成功，说明已经存在（可能编译过了） return Class.forName(className, true, ClassHelper.getCallerClassLoader(getClass())); // 如果加载失败，可能类不存在，说明可能未编译过，就进行编译 &#125; catch (ClassNotFoundException e) &#123; // 代码格式验证 if (!code.endsWith(\"&#125;\")) &#123; throw new IllegalStateException(\"The java code not endsWith \\\"&#125;\\\", code: \\n\" + code + \"\\n\"); &#125; try &#123; // 使用具体的编译器进行代码编译，由子类实现 return doCompile(className, code); &#125; catch (RuntimeException t) &#123; throw t; &#125; catch (Throwable t) &#123; throw new IllegalStateException(\"Failed to compile class, cause: \" + t.getMessage() + \", class: \" + className + \", code: \\n\" + code + \"\\n, stack: \" + ClassUtils.toString(t)); &#125; &#125; &#125; /** * 编译代码 * * @param name 类名 * @param source 代码串 * @return 编译后的类 * @throws Throwable 异常 */ protected abstract Class&lt;?&gt; doCompile(String name, String source) throws Throwable;&#125; 该抽象类主要做两件事情，先获取要编译的字符串中的类的全路径名，根据类名尝试加载对应的类，如果加载成功说明已经编译过了，就直接返回即可，防止重复编译。如果加载失败，那么就需要进行编译处理。接下来将编译的任务交给具体的子类来完成。 JavassistCompiler 编译器在介绍JavassistCompiler编译器前，我们需要先简单了解下Javassist，这样就能很好理解JavassistCompiler的逻辑了。Javassist是用来处理java字节码的类库，可以进行分析、编辑和创建Java字节码，它提供了丰富的API，可以使开发人员很方便操作字节码。不仅如此，我们知道处理Java字节码的工具很多，如cglib，asm等，为什么选择Javassist呢？因为Javassist简单且快速，可以直接使用Java编码的方式而不需要了解虚拟机指令就能动态改变类的结构，或者动态生成类。下面我们来看下javassist的几个API，dubbo就是使用javassist的API来动态生成类的。 读取Class 1234567891011121314// 获取默认的ClassPool（搜索类路径只是JVM的同路径下的class），是一个Javassist的类池ClassPool pool = ClassPool.getDefault();//从classpath中查询类XxxCtClass cc = pool.get(\"Xxx\");//设置Xxx的父类Yyycc.setSuperclass(pool.get(\"Yyy\"));// 转为字节数组，进行CtClass的冻结byte[] b=cc.toBytecode();// 生成class 类，默认加载到当前线程的ClassLoader中，也可以选择输出的ClassLoader。Class clazz=cc.toClass();// 修改读取的Class的name，这样会创建一个新的Class，旧的不会删除cc.setName(\"XxxTemp\");// 其它api... 创建Class 12345678910111213ClassPool pool = ClassPool.getDefault();// 创建一个Xxx类CtClass cc = pool.makeClass(\"Xxx\");//新增方法CtMethod m = CtNewMethod.make(\"public void test()&#123;System.out.print(hello world)&#125;\",cc);cc.addMethod(m);//新增FieldCtField f = new CtField(CtClass.intType, \"a\", point);cc.addField(f);//引入包pool.importPackage(\"package\");// 其它api... 搜索路径 12345678910ClassPool pool = ClassPool.getDefault();//默认加载方式如pool.insertClassPath(new ClassClassPath(this.getClass()));//从文件加载classpathpool.insertClassPath(\"filepath\")//从URL中加载pool.insertClassPath(new URLClassPath(\"xxx\"));//追加 LoaderClassPathpool.appendClassPath(new LoaderClassPath(ClassHelper.getCallerClassLoader(getClass()))); 具体操作示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class JavassistCompilerDemo &#123; public static void main(String[] args) throws Exception &#123; // 创建 createStudentClass(); // 读取 readStudentClass(); &#125; /** * 创建字节码信息 * * @throws Exception */ private static void createStudentClass() throws Exception &#123; // 创建ClassPool ClassPool pool = ClassPool.getDefault(); // 创建 com.alibaba.dubbo.test.Student 类 CtClass ctClass = pool.makeClass(\"com.alibaba.dubbo.test.Student\"); // 创建属性(通用形式) CtField nameField = CtField.make(\"private String name;\", ctClass); ctClass.addField(nameField); // API形式创建属性 CtField ageField = new CtField(pool.getCtClass(\"int\"), \"age\", ctClass); ageField.setModifiers(Modifier.PRIVATE); ctClass.addField(ageField); // 创建方法 （通用方式） CtMethod setName = CtMethod.make(\"public void setName(String name)&#123;this.name = name;&#125;\", ctClass); CtMethod getName = CtMethod.make(\"public String getName()&#123;return name;&#125;\", ctClass); ctClass.addMethod(setName); ctClass.addMethod(getName); // api形式创建方法 ctClass.addMethod(CtNewMethod.getter(\"getAge\", ageField)); ctClass.addMethod(CtNewMethod.setter(\"setAge\", ageField)); //创建无参构造方法 CtConstructor ctConstructor = new CtConstructor(null, ctClass); ctConstructor.setBody(\"&#123;&#125;\"); ctClass.addConstructor(ctConstructor); // 创建有参构造方法 CtConstructor constructor = new CtConstructor(new CtClass[]&#123;CtClass.intType, pool.get(\"java.lang.String\")&#125;, ctClass); constructor.setBody(\"&#123;this.age=age;this.name=name;&#125;\"); ctClass.addConstructor(constructor); // api创建普通方法 CtMethod ctMethod = new CtMethod(CtClass.voidType, \"sayHello\", new CtClass[]&#123;&#125;, ctClass); ctMethod.setModifiers(Modifier.PUBLIC); ctMethod.setBody(new StringBuilder(\"&#123;\\n System.out.println(\\\"hello world!\\\"); \\n&#125;\").toString()); ctClass.addMethod(ctMethod); // 生成class 类 Class&lt;?&gt; clazz = ctClass.toClass(); // 反射创建对象 Object obj = clazz.newInstance(); //方法调用 obj.getClass().getMethod(\"sayHello\", new Class[]&#123;&#125;).invoke(obj); // 获取ctClass的字节码 byte[] codeByteArray = ctClass.toBytecode(); // 将字节码写入到class文件中 FileOutputStream fos = new FileOutputStream(new File(\"/opt/test/Student.class\")); fos.write(codeByteArray); fos.close(); &#125; /** * 访问已存在的字节码信息 * * @throws Exception */ private static void readStudentClass() throws Exception &#123; // 创建ClassPool ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.get(\"com.alibaba.dubbo.test.Student\"); //得到字节码 byte[] bytes = ctClass.toBytecode(); System.out.println(Arrays.toString(bytes)); //获取类名 System.out.println(ctClass.getName()); //获取接口 System.out.println(Arrays.toString(ctClass.getInterfaces())); //获取方法列表 System.out.println(Arrays.toString(ctClass.getMethods())); &#125;&#125; 运行上面的代码会在本地/opt/test文件目录下生成了一个Student.class文件，我们通过 javap 命令进行反编译的结果如下：1234567891011$ javap Student.class Compiled from \"Student.java\"public class com.alibaba.dubbo.test.Student &#123; public void setName(java.lang.String); public java.lang.String getName(); public int getAge(); public void setAge(int); public com.alibaba.dubbo.test.Student(); public com.alibaba.dubbo.test.Student(int, java.lang.String); public void sayHello();&#125; 可以清楚地看到，通过Javassist把一个完整的class字符串编译成为一个Class，有了这个案例的铺垫我们就很容易理解JavassistCompiler的原理了，让我们一起来看看它的逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/** * JavassistCompiler. (SPI, Singleton, ThreadSafe) * 基于 Javassist 实现的 Compiler */public class JavassistCompiler extends AbstractCompiler &#123; /** * 匹配import */ private static final Pattern IMPORT_PATTERN = Pattern.compile(\"import\\\\s+([\\\\w\\\\.\\\\*]+);\\n\"); /** * 匹配 extents */ private static final Pattern EXTENDS_PATTERN = Pattern.compile(\"\\\\s+extends\\\\s+([\\\\w\\\\.]+)[^\\\\&#123;]*\\\\&#123;\\n\"); /** * 匹配 implements */ private static final Pattern IMPLEMENTS_PATTERN = Pattern.compile(\"\\\\s+implements\\\\s+([\\\\w\\\\.]+)\\\\s*\\\\&#123;\\n\"); /** * 正则匹配方法/属性 */ private static final Pattern METHODS_PATTERN = Pattern.compile(\"\\n(private|public|protected)\\\\s+\"); /** * 正则匹配变量 */ private static final Pattern FIELD_PATTERN = Pattern.compile(\"[^\\n]+=[^\\n]+;\"); @Override public Class&lt;?&gt; doCompile(String name, String source) throws Throwable &#123; // 获得类名 int i = name.lastIndexOf('.'); String className = i &lt; 0 ? name : name.substring(i + 1); // 创建ClassPoll对象 ClassPool pool = new ClassPool(true); // 设置类搜索路径 pool.appendClassPath(new LoaderClassPath(ClassHelper.getCallerClassLoader(getClass()))); // 匹配import Matcher matcher = IMPORT_PATTERN.matcher(source); // 引入包名 List&lt;String&gt; importPackages = new ArrayList&lt;String&gt;(); // 引入类名 Map&lt;String, String&gt; fullNames = new HashMap&lt;String, String&gt;(); // 匹配import，导入依赖包 while (matcher.find()) &#123; String pkg = matcher.group(1); // 导入整个包下的类/接口 if (pkg.endsWith(\".*\")) &#123; String pkgName = pkg.substring(0, pkg.length() - 2); pool.importPackage(pkgName); importPackages.add(pkgName); // 导入指定类/接口 &#125; else &#123; int pi = pkg.lastIndexOf('.'); if (pi &gt; 0) &#123; String pkgName = pkg.substring(0, pi); pool.importPackage(pkgName); importPackages.add(pkgName); fullNames.put(pkg.substring(pi + 1), pkg); &#125; &#125; &#125; String[] packages = importPackages.toArray(new String[0]); // 匹配extends matcher = EXTENDS_PATTERN.matcher(source); CtClass cls; if (matcher.find()) &#123; String extend = matcher.group(1).trim(); String extendClass; // 内嵌的类，如： extends A.B if (extend.contains(\".\")) &#123; extendClass = extend; // 指定引用的类 &#125; else if (fullNames.containsKey(extend)) &#123; extendClass = fullNames.get(extend); // 引用整个包下的类 &#125; else &#123; extendClass = ClassUtils.forName(packages, extend).getName(); &#125; // 创建 CtClass 对象 cls = pool.makeClass(name, pool.get(extendClass)); &#125; else &#123; // 创建 CtClass 对象 cls = pool.makeClass(name); &#125; // 匹配 implements matcher = IMPLEMENTS_PATTERN.matcher(source); if (matcher.find()) &#123; String[] ifaces = matcher.group(1).trim().split(\"\\\\,\"); for (String iface : ifaces) &#123; iface = iface.trim(); String ifaceClass; // 内嵌的接口，例如：extends A.B if (iface.contains(\".\")) &#123; ifaceClass = iface; // 指定引用的接口 &#125; else if (fullNames.containsKey(iface)) &#123; ifaceClass = fullNames.get(iface); // 引用整个包下的接口 &#125; else &#123; ifaceClass = ClassUtils.forName(packages, iface).getName(); &#125; // 添加接口 cls.addInterface(pool.get(ifaceClass)); &#125; &#125; // 获得类中的内容，即 &#123; &#125; 内的内容 String body = source.substring(source.indexOf(\"&#123;\") + 1, source.length() - 1); // 匹配 方法、属性 String[] methods = METHODS_PATTERN.split(body); for (String method : methods) &#123; method = method.trim(); if (method.length() &gt; 0) &#123; // 构造方法 if (method.startsWith(className)) &#123; cls.addConstructor(CtNewConstructor.make(\"public \" + method, cls)); // 变量 &#125; else if (FIELD_PATTERN.matcher(method).matches()) &#123; cls.addField(CtField.make(\"private \" + method, cls)); // 方法 &#125; else &#123; cls.addMethod(CtNewMethod.make(\"public \" + method, cls)); &#125; &#125; &#125; // 生成类 return cls.toClass(ClassHelper.getCallerClassLoader(getClass()), JavassistCompiler.class.getProtectionDomain()); &#125;&#125; 整个逻辑下来就是按照编写一个类的步骤对自适应类的字符串进行正则匹配拆解，不断通过正则表达式匹配不同部分的代码，然后调用Javassist的API生成代表不同部分的对象，最终组装成一个完整的自适应扩展类，还是挺简单的。这里说一句，dubbo中很多地方都是采用拼接字符串方式，然后通过具体的技术手段生成目标对象，如dubbo 的服务暴露源码中Wrapper类的生成逻辑也是先拼接字符串，然后通过dubbo的ClassGenerator处理成Class，但是ClassGenerator内部也是封装了Javassist相关对象，具体生成Class还是Javassist来完成的。 JdkCompiler 编译器JdkCompiler使用的是jdk内置的编译器，主要使用三个不同功能的对象完成对字符串的编译: JavaFileObject对象将字符串代码包装成一个文件对象 JavaFileManager接口负责管理文件的读取和输出位置 JavaCompiler.CompilationTask 对象把JavaFileObject对象 编译成具体的类 1234567891011121314151617181920212223public Class&lt;?&gt; doCompile(String name, String sourceCode) throws Throwable &#123; int i = name.lastIndexOf('.'); String packageName = i &lt; 0 ? \"\" : name.substring(0, i); String className = i &lt; 0 ? name : name.substring(i + 1); // 1 创建JavaFileObject 对象 JavaFileObjectImpl javaFileObject = new JavaFileObjectImpl(className, sourceCode); // 2 JavaFileManager 管理类文件的输入和输出位置 javaFileManager.putFileForInput(StandardLocation.SOURCE_PATH, packageName, className + ClassUtils.JAVA_EXTENSION, javaFileObject); // 3 调用JavaCompiler.CompilationTask 的call方法 把JavaFileObject对象 编译成具体的类 Boolean result = compiler.getTask(null, javaFileManager, diagnosticCollector, options, null, Arrays.asList(javaFileObject)) .call(); if (result == null || !result) &#123; throw new IllegalStateException(\"Compilation failed. class: \" + name + \", diagnostics: \" + diagnosticCollector); &#125; // 加载生成的类 return classLoader.loadClass(name);&#125; 上面代码就是JdkCompiler编译的逻辑，使用的都是jdk的接口，想要了解更多可以自行查看源代码，其它的就不多做分析。 小结自此，dubbo spi分析完了。dubbo框架具有良好的扩展性得益于两个方面，第一个方面就是在不同的场景中，dubbo使用了不同的设计模式，第二个方面就是dubbo spi机制。可以说dubbo中几乎所有的组件都是通过dubbo spi机制串联起来的，串联的总线就是Dubbo URL，可见dubbo spi在整个框架中的重要性。在接下来的几篇文章中我们将一起了解下dubbo多样的配置，总体上不难，就是内容有点多。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Javassist","slug":"Javassist","permalink":"https://gentryhuang.com/tags/Javassist/"},{"name":"JDK","slug":"JDK","permalink":"https://gentryhuang.com/tags/JDK/"}]},{"title":"Dubbo源码分析 - 自适应扩展","slug":"rpc/Dubbo自适应扩展","date":"2020-03-17T16:00:00.000Z","updated":"2020-09-03T03:12:53.633Z","comments":false,"path":"posts/3e0b5964/","link":"","permalink":"https://gentryhuang.com/posts/3e0b5964/","excerpt":"","text":"前言上一篇文章中我们分析了dubbo spi机制，但是遗留了自适应扩展并没有展开说明，这篇文章就是来填坑的。上篇文章中也介绍了固定的自适应扩展类以及加载的流程，这篇文章主要专注于自动生成的自适应扩展类以及自适应扩展对象的创建，就不再过多介绍固定的自适应扩展。自适应扩展整体上需要讨论三部分内容：自适应扩展原理、自适应扩展类串的生成 和 动态编译 。 该篇文章将讨论前两个部分，动态编译会单独写一篇文章详细说明。 自适应扩展原理扩展点的扩展类一般会在框架启动时被加载，但我们这次的主角并不会在框架启动时被加载，只可能在获取自适应实现的时候被创建、编译和实例化。这里之所以说可能，是当一个扩展接口既有固定的自适应扩展类，又想实现自动生成自适应扩展类的情况下，只会以固定的自适应扩展类为准，不会去创建动态的自适应扩展类，在框架启动时就会加载固定扩展类并放入缓存。当缓存中不存在自适应扩展类时，dubbo没有直接使用代理模式实现自适应扩展，而是为扩展接口生成具有代理功能的代码，然后通过动态编译得到自适应类，整个过程最终的目的是为扩展点生成代理对象，而代理对象主要任务就是从URL中获取扩展名对应的扩展实。接下来我们通过对官网的例子稍加改动来说明自动生成的自适应扩展的原理。 车轮制造接口 WheelMaker 123public interface WheelMaker &#123; void makeWheel(URL url);&#125; WheelMaker 接口的普通实现类 123456// CommonWheelMaker对应的扩展名设置为 commonWheelMakerpublic class CommonWheelMaker implements WheelMaker &#123; public void makeWheel(URL url) &#123; System.out.println(\"打印url，制造全宇宙最好的车轮...\" + url); &#125;&#125; WheelMaker 接口的自适应实现类 12345678910111213141516171819public class AdaptiveWheelMaker implements WheelMaker &#123; public void makeWheel(URL url) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; // 1.从 URL 中获取 WheelMaker 名称 String wheelMakerName = url.getParameter(\"wheel.maker\"); if (wheelMakerName == null) &#123; throw new IllegalArgumentException(\"wheelMakerName == null\"); &#125; // 2.通过 SPI 加载 WheelMaker 名称 对应WheelMaker具体实现。这里获取扩展实现还是使用getExtension方法。 WheelMaker wheelMaker = ExtensionLoader.getExtensionLoader(WheelMaker.class).getExtension(wheelMakerName); // 3.调用目标方法 wheelMaker.makeWheel(url); &#125;&#125; AdaptiveWheelMaker 是一个代理类[在dubbo框架中该类型的类是自动生成的,并发手动实现],与传统的代理逻辑不同，AdaptiveWheelMaker 所代理的对象是在 makeWheel 方法中通过 SPI 加载得到的。makeWheel 方法主要做了三件事情： 从 URL 中获取 WheelMaker 扩展名 通过 SPI 加载具体的 WheelMaker 实现类 调用目标方法 程序运行时，假设我们获取到了AdaptiveWheelMaker对象，然后调用它的makeWheel方法，然后有这样一个 url 参数传入： 1dubbo:&#x2F;&#x2F;192.168.0.101:20880&#x2F;XxxService?wheel.maker&#x3D;commonWheelMaker AdaptiveWheelMaker 的 makeWheel 方法从 url 中提取 wheel.maker 参数，得到扩展名 commonWheelMaker，之后再通过 SPI 加载扩展名为 commonWheelMaker 的实现类，最终得到具体的 WheelMaker 实例。 原理小结这个例子展示了自动生成的自适应扩展类的核心实现，即在扩展接口的方法被调用（dubbo中是使用自适应扩展对象调用的）时，通过SPI加载具体的扩展对象，并调用该扩展对象的同名方法。 自适应扩展类串的生成通过上面的例子，我们直观的认识了自适应扩展类的工作原理。通过上一篇文章我们知道@Adaptive 可注解在类或方法上，注解在类上时，Dubbo 不会为该类生成代理类。注解在扩展接口的方法上时，Dubbo 会为为该接口生成代理逻辑。接下来我们从上一篇文章提到的getAdaptiveExtension方法入口继续分析。 getAdaptiveExtension 方法12345678910111213141516171819202122232425262728293031323334353637public T getAdaptiveExtension() &#123; // 从缓存中获取扩展点对应的自适应扩展对象 Object instance = cachedAdaptiveInstance.get(); // 如果缓存未命中，则通过双重检锁获取/创建 if (instance == null) &#123; // 若之前创建的时候没有报错，即之前创建了并且没有抛出异常 if (createAdaptiveInstanceError == null) &#123; synchronized (cachedAdaptiveInstance) &#123; // 再次尝试从缓存中获取 instance = cachedAdaptiveInstance.get(); if (instance == null) &#123; try &#123; // 创建自适应拓展对象 instance = createAdaptiveExtension(); // 放入缓存中 cachedAdaptiveInstance.set(instance); &#125; catch (Throwable t) &#123; createAdaptiveInstanceError = t; throw new IllegalStateException(\"fail to create adaptive instance: \" + t.toString(), t); &#125; &#125; &#125; // 若之前创建的时候报错，则抛出异常 &#125; else &#123; throw new IllegalStateException(\"fail to create adaptive instance: \" + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError); &#125; &#125; return (T) instance;&#125; 上面的代码用来获取扩展点的自适应对象，该方法先检查缓存，缓存中没有则调用 createAdaptiveExtension 方法尝试创建自适应对象。我们继续跟进 createAdaptiveExtension 方法。 12345678910111213private T createAdaptiveExtension() &#123; try &#123; /** * 1 getAdaptiveExtensionClass方法用来获得自适应扩展类【注意，获得的自适应扩展类可能是配置文件中的类，也可能是通过字节码创建的】 * 2 通过反射创建自适应扩展对象 * 3 调用injectExtension方法，向创建的自适应拓展对象注入依赖 */ return injectExtension((T) getAdaptiveExtensionClass().newInstance()); &#125; catch (Exception e) &#123; throw new IllegalStateException(\"Can not create adaptive extension \" + type + \", cause: \" + e.getMessage(), e); &#125; &#125; 上面的方法先获取自适应扩展类，然后利用反射创建自适应对象，接着会向创建的自适应对象注入依赖。现在，我们已经知道了自适应扩展类分为两类，固定的自适应扩展类中可能存在一些依赖，这时需要使用扩展工厂进行setter注入，自动生成的扩展实现一般不会依赖其它属性。接下来我们分析下自适应扩展类怎么获取的。 123456789101112private Class&lt;?&gt; getAdaptiveExtensionClass() &#123; // 刷新扩展点实现类集合 getExtensionClasses(); // 缓存中有扩展点的自适应类就直接返回 if (cachedAdaptiveClass != null) &#123; return cachedAdaptiveClass; &#125; // 没有就自动生成自适应拓展类的代码，编译后返回该类 return cachedAdaptiveClass = createAdaptiveExtensionClass(); &#125; 上面的代码先是刷新扩展点实现类集合，注意如果扩展接口的实现类中有标注@Adaptive注解的类，那么cachedAdaptiveClass缓存属性中保存的就是该类，即固定的自适应扩展类。如果没有的话，说明当前扩展接口的实现类中不存在固定的自适应扩展类，那么只能尝试创建该接口的自适应扩展类，代码逻辑如下： 1234567891011private Class&lt;?&gt; createAdaptiveExtensionClass() &#123; // 生成自适应拓展实现类的代码字符串 String code = createAdaptiveExtensionClassCode(); // 获取类加载器 ClassLoader classLoader = findClassLoader(); // 获取Compiler自适应扩展对象 com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension(); // 动态编译，生成Class return compiler.compile(code, classLoader); &#125; createAdaptiveExtensionClass 方法包含三个步骤： 生成自适应扩展实现类的代码字符串 获取Compiler自适应扩展对象 动态编译 自适应拓展实现类的代码字符串 ，生成Class 后面两个步骤属于 动态编译 部分，不在本文范畴，我们主要关注 自适应扩展实现类的代码字符串 的生成逻辑。 自适应扩展类代码生成createAdaptiveExtensionClassCode方法代码非常多，不过总的逻辑大致可以分为八个逻辑分支，已经进行详细的注释，下面就直接贴上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322private String createAdaptiveExtensionClassCode() &#123; StringBuilder codeBuilder = new StringBuilder(); //----------------- 1 检查扩展接口方法是否包含 Adaptive注解，要求至少有一个方法被 Adaptive 注解修饰 --------------------/ // 反射获取扩展点所有方法 Method[] methods = type.getMethods(); boolean hasAdaptiveAnnotation = false; // 遍历方法列表，检测是否标注 Adaptive 注解 for (Method m : methods) &#123; if (m.isAnnotationPresent(Adaptive.class)) &#123; hasAdaptiveAnnotation = true; break; &#125; &#125; // 若所有方法上都没有Adaptive注解，就抛出异常 if (!hasAdaptiveAnnotation) &#123; throw new IllegalStateException(\"No adaptive method on extension \" + type.getName() + \", refuse to create the adaptive class!\"); &#125; //------------------ 2 生成自适应扩展类的代码字符串，代码生成的顺序与 Java 文件内容顺序一致 ---------------------------/ // 生成package codeBuilder.append(\"package \").append(type.getPackage().getName()).append(\";\"); // 生成import，注意自适应类只依赖ExtensionLoader，其它的都不会依赖，因为使用的都是全路径名，不需要再导入包了 codeBuilder.append(\"\\nimport \").append(ExtensionLoader.class.getName()).append(\";\"); // 开始生成 class codeBuilder.append(\"\\npublic class \").append(type.getSimpleName()).append(\"$Adaptive\").append(\" implements \").append(type.getCanonicalName()).append(\" &#123;\"); //------------------ 3 生成自适应扩展类中的方法，接口中方法可以被 Adaptive 注解修饰，也可以不被修饰，但处理方式也不同 -------/ // 遍历方法列表，为类中填充方法 for (Method method : methods) &#123; // 方法返回类型 Class&lt;?&gt; rt = method.getReturnType(); // 方法参数类型 Class&lt;?&gt;[] pts = method.getParameterTypes(); // 方法异常类型 Class&lt;?&gt;[] ets = method.getExceptionTypes(); // 尝试获取方法的 Adaptive 注解，有无注解的区别体现在 生成方法字符串的差异上 Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class); // 类中的方法字符串集 StringBuilder code = new StringBuilder(512); // 3.1 生成没有Adaptive注解的方法代码串。Dubbo不会为没有标注Adaptive注解的方法生成代理逻辑，仅仅生成一句抛出异常代码 if (adaptiveAnnotation == null) &#123; code.append(\"throw new UnsupportedOperationException(\\\"method \") .append(method.toString()).append(\" of interface \") .append(type.getName()).append(\" is not adaptive method!\\\");\"); // 3.2 生成有Adaptive注解的方法代码串。核心逻辑就是从方法的参数列表中直接或间接获取配置总线URL，然后结合Adaptive注解值及默认扩展名策略，从URL中得到扩展名，然后通过ExtensionLoader获取扩展名对应的扩展实现对象。 &#125; else &#123; int urlTypeIndex = -1; // 遍历方法参数类型数组 for (int i = 0; i &lt; pts.length; ++i) &#123; // 判断参数类型是不是URL，确定URL参数位置 if (pts[i].equals(URL.class)) &#123; urlTypeIndex = i; break; &#125; &#125; // urlTypeIndex != -1，表示参数列表中存在 URL类型的参数，即直接获取配置总线URL。如： &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException 方法 if (urlTypeIndex != -1) &#123; // 为 URL 类型参数生成判空代码，如：if (arg0 == null) throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument == null\"); String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"url == null\\\");\", urlTypeIndex); code.append(s); // 为 URL 类型参数生成赋值代码，形如 URL url = arg0 s = String.format(\"\\n%s url = arg%d;\", URL.class.getName(), urlTypeIndex); code.append(s); &#125; // 参数列表中不存在 URL 类型参数，只能间接尝试获取配置总线URL。如：&lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException 方法，配置总线URL是从invoker中获取。 else &#123; // 目标方法名，这里如果存在就是 getUrl String attribMethod = null; // find URL getter method LBL_PTS: // 遍历方法的参数类型列表 for (int i = 0; i &lt; pts.length; ++i) &#123; // 获取当前方法的参数类型 的 全部方法 Method[] ms = pts[i].getMethods(); // 判断方法参数对象中是否有 public URL getUrl() 方法 for (Method m : ms) &#123; String name = m.getName(); if ((name.startsWith(\"get\") || name.length() &gt; 3) &amp;&amp; Modifier.isPublic(m.getModifiers()) &amp;&amp; !Modifier.isStatic(m.getModifiers()) &amp;&amp; m.getParameterTypes().length == 0 &amp;&amp; m.getReturnType() == URL.class) &#123; urlTypeIndex = i; attribMethod = name; // 找到方法参数列表中间接存在URL的参数，则结束寻找逻辑 break LBL_PTS; &#125; &#125; &#125; // 如果参数列表中没有一个参数有getUrl方法，则抛出异常 if (attribMethod == null) &#123; throw new IllegalStateException(\"fail to create adaptive class for interface \" + type.getName() + \": not found url parameter or url attribute in parameters of method \" + method.getName()); &#125; // 为可返回URL的参数生成判空代码，如：if (arg0 == null) throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument == null\"); String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"%s argument == null\\\");\", urlTypeIndex, pts[urlTypeIndex].getName()); code.append(s); // 为可返回URL的参数 的getUrl方法返回 的URL生成判空代码，如：if (arg0.getUrl() == null) throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null\"); s = String.format(\"\\nif (arg%d.%s() == null) throw new IllegalArgumentException(\\\"%s argument %s() == null\\\");\", urlTypeIndex, attribMethod, pts[urlTypeIndex].getName(), attribMethod); code.append(s); // 生成赋值语句，形如：URL url = argN.getUrl(); s = String.format(\"%s url = arg%d.%s();\", URL.class.getName(), urlTypeIndex, attribMethod); code.append(s); &#125; //----------------- 4 获取 Adaptive 注解值 ，Adaptive 注解值 value 类型为 String[]，可填写多个值，默认情况下为空数组 -------------/ /** * 获取@Adaptive注解的值，如果有值，这些值将作为获取扩展名的key，需要注意，Protocol扩展和其它扩展点是不同的，前者获取扩展名是取协议，后者获取扩展名是取参数的值 * 1 普通扩展点，如ProxyFactor： String extName = url.getParameter(\"proxy\", \"javassist\"); * 2 Protocol扩展点： String extName = ( url.getProtocol() == null ? \"dubbo\" : url.getProtocol() ); */ String[] value = adaptiveAnnotation.value(); // 如果@Adaptive注解没有指定值，则根据扩展接口名生成。如：SimpleExt -&gt; simple.ext，即将扩展接口名中的大写转小写，并使用'.'把它们连接起来 if (value.length == 0) &#123; // 获取扩展接口简单名称的字符数组 char[] charArray = type.getSimpleName().toCharArray(); StringBuilder sb = new StringBuilder(128); for (int i = 0; i &lt; charArray.length; i++) &#123; // 判断是否大写字母，如果是就使用 '.' 连接，并大写转小写 if (Character.isUpperCase(charArray[i])) &#123; if (i != 0) &#123; sb.append(\".\"); &#125; sb.append(Character.toLowerCase(charArray[i])); &#125; else &#123; sb.append(charArray[i]); &#125; &#125; value = new String[]&#123;sb.toString()&#125;; &#125; //--------------------- 5 检测方法参数列表中是否存在 Invocation 类型的参数，有则表示是调用方法 --------------------/ boolean hasInvocation = false; for (int i = 0; i &lt; pts.length; ++i) &#123; // 参数类型是Invocation if (pts[i].getName().equals(\"com.alibaba.dubbo.rpc.Invocation\")) &#123; // 为 Invocation 类型参数生成判空代码 String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"invocation == null\\\");\", i); code.append(s); // 生成 String methodName = argN.getMethodName()； 代码，Invocation是调用信息，里面包含调用方法 s = String.format(\"\\nString methodName = arg%d.getMethodName();\", i); code.append(s); hasInvocation = true; break; &#125; &#125; //----------------------- 6 扩展名决策逻辑，@SPI、@Adaptive以及方法含有Invocation类型参数都会影响最终的扩展名 -------------------------/ // 设置默认拓展名，SPI注解值，默认情况下 SPI注解值为空串，此时cachedDefaultName = null String defaultExtName = cachedDefaultName; String getNameCode = null; /** * 遍历Adaptive 的注解值，用于生成从URL中获取拓展名的代码，最终的扩展名会赋值给 getNameCode 变量。 * 注意： * 1 这个循环的遍历顺序是由后向前遍历的，因为Adaptive注解可能配置了多个扩展名，而dubbo获取扩展名的策略是从前往后依次获取，找到即结束，以下代码拼接的时候也是从后往前拼接。 * 2 生成的扩展名代码大致有3大类，Adaptive的注解中属性值的数目决定了内嵌层级： *（1） String extName = (url.getProtocol() == null ? defaultExtName : url.getProtocol()); 获取协议扩展点的扩展名 *（2） String extName = url.getMethodParameter(methodName, Adaptive的注解值, defaultExtName); 获取方法级别的参数值作为扩展名，因为方法的参数列表中含有Invocation调用信息。 *（3） String extName = url.getParameter(Adaptive的注解值, defaultExtName); 获取参数值作为扩展名 *（4） 如果Adaptive的注解中属性值有多个，就进行嵌套获取。如配置两个，以(3)为例：String extName = url.getParameter(Adaptive的注解值[0],url.getParameter(Adaptive的注解值[1], defaultExtName)); * 3 参数如果是protocol，protocol是url主要部分，可通过getProtocol方法直接获取。如果是其他的需要是从URL参数部分获取。两者获取方法不一样。其中参数获取又可分为方法级别参数和非方法级别参数 */ for (int i = value.length - 1; i &gt;= 0; --i) &#123; // 第一次遍历分支 if (i == value.length - 1) &#123; if (null != defaultExtName) &#123; if (!\"protocol\".equals(value[i])) &#123; // 方法参数列表中有调用信息Invocation参数 if (hasInvocation) &#123; getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName); &#125; else &#123; getNameCode = String.format(\"url.getParameter(\\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName); &#125; &#125; else &#123; getNameCode = String.format(\"( url.getProtocol() == null ? \\\"%s\\\" : url.getProtocol() )\", defaultExtName); &#125; &#125; else &#123; if (!\"protocol\".equals(value[i])) &#123; // 方法参数列表中有调用信息Invocation参数 if (hasInvocation) &#123; getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName); &#125; else &#123; getNameCode = String.format(\"url.getParameter(\\\"%s\\\")\", value[i]); &#125; &#125; else &#123; getNameCode = \"url.getProtocol()\"; &#125; &#125; // 第二次开始都走该分支，用于嵌套获取扩展名 &#125; else &#123; if (!\"protocol\".equals(value[i])) &#123; // 方法参数列表中有调用信息Invocation参数 if (hasInvocation) &#123; getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName); &#125; else &#123; getNameCode = String.format(\"url.getParameter(\\\"%s\\\", %s)\", value[i], getNameCode); &#125; &#125; else &#123; getNameCode = String.format(\"url.getProtocol() == null ? (%s) : url.getProtocol()\", getNameCode); &#125; &#125; &#125; // 生成扩展明 赋值代码 code.append(\"\\nString extName = \").append(getNameCode).append(\";\"); // 生成 扩展明 判空代码 String s = String.format(\"\\nif(extName == null) \" + \"throw new IllegalStateException(\\\"Fail to get extension(%s) name from url(\\\" + url.toString() + \\\") use keys(%s)\\\");\", type.getName(), Arrays.toString(value)); code.append(s); //---------------------------------------- 7 生成 获取扩展对象代码 以及 调用扩展对象的目标方法代码 ---------------------------------/ // 生成 extension扩展对象 赋值 代码 s = String.format(\"\\n%s extension = (%&lt;s)%s.getExtensionLoader(%s.class).getExtension(extName);\", type.getName(), ExtensionLoader.class.getSimpleName(), type.getName()); code.append(s); // 如果方法返回值类型非void，则生成return语句 if (!rt.equals(void.class)) &#123; code.append(\"\\nreturn \"); &#125; // 生成 extension扩展对象 调用目标方法逻辑，形如： extension.方法名(arg0, arg2, ..., argN); s = String.format(\"extension.%s(\", method.getName()); code.append(s); // 生成extension调用方法中的参数 拼接，注意和生成方法签名的参数名保持一直 for (int i = 0; i &lt; pts.length; i++) &#123; if (i != 0) &#123; code.append(\", \"); &#125; code.append(\"arg\").append(i); &#125; code.append(\");\"); &#125; //------------------------------------------- 8 生成方法签名，包裹方法体内容 ---------------------------------------/ // 生成方法签名，格式：public + 返回值全限定名 + 方法名 +( codeBuilder.append(\"\\npublic \").append(rt.getCanonicalName()).append(\" \").append(method.getName()).append(\"(\"); // 生成方法签名的参数列表 for (int i = 0; i &lt; pts.length; i++) &#123; if (i &gt; 0) &#123; codeBuilder.append(\", \"); &#125; codeBuilder.append(pts[i].getCanonicalName()); codeBuilder.append(\" \"); codeBuilder.append(\"arg\").append(i); &#125; codeBuilder.append(\")\"); // 生成异常抛出代码 if (ets.length &gt; 0) &#123; codeBuilder.append(\" throws \"); for (int i = 0; i &lt; ets.length; i++) &#123; if (i &gt; 0) &#123; codeBuilder.append(\", \"); &#125; codeBuilder.append(ets[i].getCanonicalName()); &#125; &#125; // 方法开始符号 codeBuilder.append(\" &#123;\"); // 包括方法体内容 codeBuilder.append(code.toString()); // 追加方法结束符号 codeBuilder.append(\"\\n&#125;\"); &#125; // 追加类的结束符号，生成自适应扩展类结束 codeBuilder.append(\"\\n&#125;\"); if (logger.isDebugEnabled()) &#123; logger.debug(codeBuilder.toString()); &#125; return codeBuilder.toString(); &#125; 上面的代码逻辑就一个任务，使用字符串拼接一个自适应扩展类串，梳理出来后并没有那么复杂，其实就是按照编写一个类的步骤进行拼接的。如果非要说复杂的话，那么就提体现在拼接扩展名的逻辑代码中，因为情况非常多，胖友们可以多调试多归类。想要观察生成的自适应扩展类有两种办法，日志级别设置成debug是一种简单粗暴的方式，还可以使用反编译工具进行查看。 总结本篇文章主要分析了自动生成的自适应扩展类的原理，以及详细分析了生成一个自适应扩展类的过程，总体来说还是很复杂的。至于为什么不直接使用代理的方式生成自适应扩展类，主要的原因是代理方式效率太低，更详细的可以参考梁飞大佬的博客 动态代理方案性能对比。自适应扩展还没结束，我们虽然有了一个自适应扩展类的字符串，但是还需要对这个字符串进行编译处理成Class，这样才能创建一个对象自适应扩展对象，下一篇文章中我们就来分析dubbo的动态编译原理。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"SPI","slug":"SPI","permalink":"https://gentryhuang.com/tags/SPI/"}]},{"title":"Dubbo源码分析 - Dubbo SPI","slug":"rpc/spi机制之dubbo","date":"2020-03-12T16:00:00.000Z","updated":"2020-09-05T14:06:44.015Z","comments":false,"path":"posts/5d81f464/","link":"","permalink":"https://gentryhuang.com/posts/5d81f464/","excerpt":"","text":"概述dubbo并未使用jdk标准的SPI机制，而是对其进行了增强，优化了性能问题并且相比jdk spi更加健壮。 dubbo spi 对 jdk spi的改进 JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源，而dubbo可以选择性实例化。 如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时会报不支持ruby，而不是真正失败的原因。 增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。 原始jdk spi 不支持缓存，dubbo设计了多维度缓存，提高了框架的性能。 dubbo spi 配置规范 spi配置文件路径 123META-INF&#x2F;dubbo&#x2F;internal : 主要用于 Dubbo 内部提供的拓展点实现META-INF&#x2F;dubbo : 主要用于自定义扩展点实现META-INF&#x2F;services : 用于兼容jdk的spi 说明: 上面的spi配置文件路径是种规范，实际上在使用的时候写在哪个文件下都可以被加载到，但是实际开放种最好按照规范配置。 spi配置文件名称 1扩展点全路径名 文件内容 12key&#x3D;value形式，多个使用换行符分割，这是dubbo配置的方式value形式，没有指定扩展名，这是jdk配置方式，dubbo进行了兼容，会自动为扩展实现类生成默认的扩展名 说明: dubbo spi 通过键值对的方式进行配置，这样我们可以按需实例化扩展点的实现，而不是一次实例化所有的扩展实现类。 加载扩展实现1dubbo使用ExtensionLoader加载指定实现类，dubbo spi的逻辑几乎都封装在该类中。 示例前面简单介绍了dubbo spi机制，下面我们通过一个例子来演示dubbo spi的简单用法。扩展点接口及实现复用 spi机制之jdk示例 中代码，区别是dubbo spi的接口使用@SPI注解进行标注。 定义扩展接口，使用@SPI注解进行标注 123456789package com.alibaba.dubbo.spi;@SPIpublic interface Command &#123; /** * 执行方法 */ void execute();&#125; 在META-INF/dubbo文件目录下创建一个文件，名称为Command的全路径名 com.alibaba.dubbo.spi.Command。 配置内容为扩展实现类及其扩展名，如下： 12start&#x3D;com.alibaba.dubbo.spi.impl.StartCommandshutdown&#x3D;com.alibaba.dubbo.spi.impl.ShutdownCommand 准备就绪后，最后写测试代码，如下： 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; // ExtensionLoader是dubbo提供的，用来加载拓展实现类 ExtensionLoader&lt;Command&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Command.class); // 加载指定扩展名对应的扩展实现对象（获取的时候会进行实例化） Command startCommand = extensionLoader.getExtension(\"start\"); startCommand.execute(); Command shutdownCommand = extensionLoader.getExtension(\"shutdown\"); shutdownCommand.execute(); &#125;&#125; 测试结果如下： 1234start commandshut down commandProcess finished with exit code 0 简单说明和演示dubbo spi后，我们对dubbo spi有了一定的认识，使用起来还是比较简单的，接下来进入源码分析阶段，让我们一起去看看dubbo底层是怎么加载和选择扩展实现的。 dubbo spi 源码分析进行源码分析之前，我们先看下dubbo spi整体的代码结构，然后对核心注解和类进行说明。 代码结构 扩展点 SPI 注解扩展点接口标识，dubbo的扩展点必须标注该注解，否则在执行spi逻辑时框架会报异常。 1234567891011@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)public @interface SPI &#123; /** * @return 缺省扩展名 */ String value() default \"\";&#125; SPI注解的value属性是用来指定扩展点的默认扩展名，如Protocol扩展接口： 12@SPI(\"dubbo\")public interface Protocol &#123;//...&#125; // dubbo对应的扩展实现类就是DubboProtocol，即Protocol默认的扩展实现类 扩展点 Adaptive 注解12345678910111213141516171819@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface Adaptive &#123; /** * 根据URL的Key获取对应的Value作为自适应拓展名。比如，&lt;code&gt;String[] &#123;\"key1\", \"key2\"&#125;&lt;/code&gt;，表示 * &lt;ul&gt; * &lt;li&gt;先在URL上找key1的Value作为自适应拓展名； * &lt;li&gt;key1没有value，则使用key2的value作为自适应拓展名。 * &lt;li&gt;key2没有value，就使用缺省的扩展，即： 如果&#123;@link URL&#125;这些Key都没有value，使用缺省的扩展（在接口的&#123;@link SPI&#125;中设定的值） * &lt;li&gt;如果没有设置缺省扩展名或者缺省扩展名也没有value，则方法调用会抛出&#123;@link IllegalStateException&#125;。 * &lt;/ul&gt; * 注意：如果没有使用Adaptive注解指定扩展名，扩展接口也没有指定@SPI默认值，则在加载扩展实现的时候dubbo会自动把扩展接口名称根据驼峰大小写分开，并使用 '.' 符号连接起来， * 以此名称作为默认扩展名。如：SimpleExt -&gt; simple.ext * * @return parameter key names in URL */ String[] value() default &#123;&#125;;&#125; 一个拓展接口，在框架中同时只能存在一个 Adaptive 拓展实现类，可能是固定的扩展实现类，也可能是自动生成、编译得到的扩展实现类。@Adaptive 注解，可添加类或方法上，分别代表了两种不同的使用方式。第一种，标记在类上（属于装饰类），整个实现类会作为自适应扩展类，dubbo不会为该类生成代理类，它主要用于固定已知类。目前 Dubbo 项目里，只有 ExtensionFactory 拓展的实现类 AdaptiveExtensionFactory 和Compiler 拓展的实现AdaptiveCompiler这么使用。第二种，标记在扩展接口的方法上，代表自动生成、编译一个该接口的动态Adaptive拓展实现类（属于动态代理类，如Protocol$Adaptive），一般该类没有实际的工作，只是根据参数和运行状态加载其他的扩展实现来完成最终的工作。 扩展点 Activate 注解1234567891011121314151617181920212223242526272829303132333435@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface Activate &#123; /** * group过滤条件。在调用&#123;@link ExtensionLoader#getActivateExtension(URL, String, String)&#125; 方法时，如果传入的group参数符合该注解设置的group属性值，则匹配。 */ String[] group() default &#123;&#125;; /** * key过滤条件。在调用&#123;@link ExtensionLoader#getActivateExtension(URL, String, String)&#125; 方法时，如果url中的参数中存在该注解设置的key值，则匹配。 */ String[] value() default &#123;&#125;; /** * 排序属性 * * @return extension list which should be put before the current one */ String[] before() default &#123;&#125;; /** * 排序属性 * * @return extension list which should be put after the current one */ String[] after() default &#123;&#125;; /** * 排序属性 * * @return absolute ordering info */ int order() default 0;&#125; 该注解用于设置扩展实现类被自动激活的加载条件，如：过滤器扩展点有多个实现，那么就可以使用该注解设置激活条件，在获取自动激活扩展实现时需要符合条件才能获取到。框架通过ExtensionLoader#getActivateExtension方法获得激活条件的扩展实现集合。 ExtensionLoaderdubbo的扩展加载器，dubbo spi 的相关逻辑几乎都被封装在该类中，该类是 dubbo spi 的 核心。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class ExtensionLoader&lt;T&gt; &#123; //========================================= 类属性，所有ExtensionLoader对象共享 ================================================ /** * dubbo扩展点目录 ，该目录是为了兼容jdk的spi */ private static final String SERVICES_DIRECTORY = \"META-INF/services/\"; /** * dubbo扩展点目录，主要用于自定义扩展点实现 */ private static final String DUBBO_DIRECTORY = \"META-INF/dubbo/\"; /** * dubbo扩展点目录，用于 Dubbo 内部提供的拓展点实现 */ private static final String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + \"internal/\"; /** * 扩展点实现名的分隔符 正则表达式，多个扩展点名之间使用 ',' 进行分割 */ private static final Pattern NAME_SEPARATOR = Pattern.compile(\"\\\\s*[,]+\\\\s*\"); /** * 扩展点加载器集合 * key: 拓展点接口 * value: 扩展点加载器。 一个扩展点接口对应一个 扩展点加载器 */ private static final ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = new ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;(); /** * 扩展点实现类集合 * key: 扩展点实现类 * value: 扩展点实现对象 * 说明： * 一个扩展点通过对应的ExtensionLoader去加载它的具体实现，考虑到性能和资源问题，在加载拓展配置后不会立马进行扩展实现的对象的初始化，而是先把扩展配置存起来。 * 等到真正使用对应的拓展实现时才进行扩展实现的对象的初始化，初始化后也进行缓存。即： * 1 缓存加载的拓展配置 * 2 缓存创建的拓展实现对象 */ private static final ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = new ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;(); // ============================== 实例属性 ，每个ExtensionLoader对象独有 ==================================================== /** * 扩展点，如：Protocol */ private final Class&lt;?&gt; type; /** * 扩展点实现工厂，用于向扩展对象中注入依赖属性，一般通过调用 &#123;@link #injectExtension(Object)&#125; 方法进行实现。 * 特别说明： * 除了ExtensionFactory扩展接口，其余的所有扩展接口的ExtensionLoader对象都会拥有一个自己的扩展工厂，即 objectFactory = AdaptiveExtensionFactory； * @see ExtensionLoader 构造方法 */ private final ExtensionFactory objectFactory; /** * 扩展点实现类 到 扩展名 的映射 * 如： * dubbo=dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol ===&gt; &lt;DubboProtocol,dubbo&gt; */ private final ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = new ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;(); /** * 扩展名 到 扩展点实现类 的映射 * 不包括以下两种类型： * 1 自适应扩展实现类，如：AdaptiveExtensionFactory * 2 扩展点的Wrapper实现类，如：ProtocolFilterWrapper * 如： * dubbo=dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol ===&gt; &lt;dubbo,DubboProtocol&gt; */ private final Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = new Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;(); /** * 扩展名 到 @Activate注解 的映射， 如： ContextFilter -&gt; Activate */ private final Map&lt;String, Activate&gt; cachedActivates = new ConcurrentHashMap&lt;String, Activate&gt;(); /** * 扩展名 到 扩展点实现对象 的映射 * 如： * dubbo=dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol ===&gt; &lt;dubbo,Holder&lt;DubboProtocol对象&gt;&gt; */ private final ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = new ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;(); /** * 自适应扩展对象 * 注意: 一个扩展点最多只能有一个自适应扩展对象，&gt; 1 框架就会报错 */ private final Holder&lt;Object&gt; cachedAdaptiveInstance = new Holder&lt;Object&gt;(); /** * 自适应扩展实现类 &#123;@link #getAdaptiveExtensionClass()&#125; */ private volatile Class&lt;?&gt; cachedAdaptiveClass = null; /** * 扩展点的默认扩展名，通过 &#123;@link SPI&#125; 注解获得 */ private String cachedDefaultName; /** * 创建自适应对象时发生的异常 -&gt; &#123;@link #createAdaptiveExtension()&#125; */ private volatile Throwable createAdaptiveInstanceError; /** * 扩展点Wrapper实现类集合，如：ProtocolFilterWrapper */ private Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses; /** * 扩展名 到 加载对应扩展类发生的异常 的映射 */ private Map&lt;String, IllegalStateException&gt; exceptions = new ConcurrentHashMap&lt;String, IllegalStateException&gt;(); /** * 构造方法 * 说明： * 1 任意一个扩展点在获取对应的ExtensionLoader时，都会先尝试获取属于它的ExtensionFactory自适应扩展，即 AdaptiveExtensionFactory， * 它管理着SpiExtensionFactory和SpringExtensionFactory这两大扩展点工厂，用于调用 &#123;@link #injectExtension(Object)&#125;方法，向扩展实现中注入依赖属性， * 需要注意的是，SpiExtensionFactory和SpringExtensionFactory获得对象是不同的，前者获取自适应对象，后者从Spring容器中获取对象。 * 2 当扩展点是ExtensionFactory时，那么它的对应的ExtensionLoader的objectFactory 属性为null * * @param type 扩展点 */ private ExtensionLoader(Class&lt;?&gt; type) &#123; this.type = type; objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()); &#125; // 省略其它代码...&#125; 基于性能的考虑，dubbo spi相比较与jdk spi的一个改进就是使用了大量的缓存，dubbo spi 缓存从大的方向可分为 类缓存、实例缓存，这两种缓存又能根据扩展实现类的种类分为 普通扩展缓存、包装扩展缓存、自适应扩展缓存。 类缓存 dubbo spi在查询扩展类时，会先从缓存中获取，如果缓存中不存在，再加载配置文件并分类缓存，注意，这个过程不会进行初始化流程。 实例缓存 dubbo spi缓存的Class是按需进行实例化的，在查询实例时会先从缓存中获取，如果缓存不存在则会进行加载/初始化，然后缓存起来。 多类型的扩展点根据扩展实现类的特点及用途可以分为普通扩展类、自动激活扩展类、包装扩展类以及自适应扩展类，其中自动激活扩展类属于普通扩展类。需要注意的是，除了动态编译得到的自适应扩展类，其它的所有扩展类都需要在配置文件中进行配置，否则框架无法加载到。下面我们简单说明下各个类型的扩展类及其特点。 普通扩展类属于最基础的扩展类，一般通过扩展名获取对应的扩展实现就是该类型。在配置普通扩展类时需要指定扩展名，不指定会按规则自动生成，因为普通扩展实现都是根据扩展名获取的。 包装扩展类包括扩展类又叫 Wrapper类，一般不是扩展点的真正实现，主要用来对扩展实现进行功能增强或通用逻辑处理。Wrapper类有两个特征：实现扩展接口、存在一个参数类型是扩展点的构造方法。Wrapper类是dubbo AOP的实现。在配置Wrapper类时，可以不指定扩展名，即使指定了也不会使用，但一般情况根据dubbo spi的约定还是统一配置。 自适应类自适应类非常灵活，也叫 Adaptive类，有两种实现方式。Adaptive类的两个特征：实现扩展接口、实现类或扩展接口的方法上需要使用 @Adaptive 标注。类上标注@Adaptive是一个Adaptive类可以理解，但是扩展接口的方法上标注@Adaptive怎么会是一个类呢？是因为标注在扩展接口的方法上，dubbo spi机制在获取自适应扩展实现类时，如果当前环境中没有自适应扩展实现类就会对标注的方法所在接口进行javassist操作，生成自适应扩展类的字符串，然后通过动态编译成一个自适应类。@Adaptive标注在扩展接口的方法上的方式，可以动态地通过URL中的参数来确定使用哪个扩展实现。在配置文件中可以不指定扩展名，即使指定了也不会使用，但一般情况根据dubbo spi的约定还是统一配置。 自动激活类自动激活类属于特殊的普通扩展类，该类的两个特征：实现接口、类上使用 @Activate 标注。它支持某个扩展点需要同时激活多个实现的特性，如 dubbo中的过滤器扩展点，需要激活多个扩展实现。 ExtensionLoader 工作流程ExtensionLoader封装了dubbo spi的主要逻辑，配置的加载、扩展类缓存、扩展实现的实例化及缓存、自适应类的生成与编译及缓存、自适应对象的实例化及缓存以及dubbo ioc和aop的实现等。这些逻辑主要体现在三个入口方法中，每个入口方法获取到的扩展实现类型会有所不同，但是方法内部逻辑有相同之处。下面我们分别从三个入口方法开始详细分析dubbo spi的整个流程，需要说明的是，getExtension方法是最核心的方法，其它两个入口方法都会依赖该方法中的部分流程，因此我们会先分析getExtension方法，在分析其它两个方法的时候涉及重复的流程就不再分析。 getExtension 方法ExtensionLoader中最核心的方法，因为它实现了一个完整的查询扩展实现的逻辑。获取过程中的每一步都会先检查缓存是否命中，命中就直接返回或进行赋值，没有命中则加载配置文件，然后缓存配置文件中的扩展实现。 12345678910111213141516171819202122232425262728293031323334353637383940/** * 获得指定扩展名的扩展对象 * * @param name 扩展名 * @return */ @SuppressWarnings(\"unchecked\") public T getExtension(String name) &#123; if (name == null || name.length() == 0) &#123; throw new IllegalArgumentException(\"Extension name == null\"); &#125; // 如果当前扩展名是 'true'，就获取默认的扩展对象 if (\"true\".equals(name)) &#123; // 方法简化为 getExtension(cachedDefaultName) , cacheDefaultName的值参见 @SPI注解 return getDefaultExtension(); &#125; // 从缓存中获得对应的扩展对象 Holder&lt;Object&gt; holder = cachedInstances.get(name); if (holder == null) &#123; cachedInstances.putIfAbsent(name, new Holder&lt;Object&gt;()); holder = cachedInstances.get(name); &#125; Object instance = holder.get(); // 缓存中没有， 双重检锁获取扩展名对应扩展实现对象 if (instance == null) &#123; synchronized (holder) &#123; instance = holder.get(); if (instance == null) &#123; // 缓存中确实没有，就创建扩展名对应的扩展实现对象 instance = createExtension(name); // 将扩展实现对象放入缓存中 holder.set(instance); &#125; &#125; &#125; return (T) instance; &#125; 上面的代码逻辑比较简单，根据扩展名获取扩展对象，先检查缓存中是否有目标对象，没有则调用 createExtension方法开始创建扩展对象。需要特被说明的是，如果name是true的情况，加载的就是默认扩展类。那么下面我们来分析createExtension方法流程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 创建扩展名对应的扩展点实现对象并缓存到类属性的集合中 * * @param name * @return */ @SuppressWarnings(\"unchecked\") private T createExtension(String name) &#123; // 获取扩展名对应的扩展点实现类，先尝试从缓存中取对应的扩展实现类，没有的话就加载配置文件然后再次获取 Class&lt;?&gt; clazz = getExtensionClasses() .get(name); // 没有找到扩展名对应的扩展点实现类，则报错 if (clazz == null) &#123; throw findException(name); &#125; try &#123; // 从类属性缓存集合中尝试获取扩展点实现类对应的对象 T instance = (T) EXTENSION_INSTANCES.get(clazz); // 当缓存中没有，就通过反射创建扩展点实现类对象并放入缓存 if (instance == null) &#123; EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance()); instance = (T) EXTENSION_INSTANCES.get(clazz); &#125; // dubbo ioc实现，进行setter注入 injectExtension(instance); /** * dubbo aop实现 * 注意： * 如果当前扩展点存在 Wrapper类，那么从ExtensionLoader 中获得的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类，因此调用方法时调用的是Wrapper类中的方法，并非直接调用扩展点的真正实现。 * 即 如果在Wrapper的方法中不显示调用扩展点的真正实现的话，那么结果一定不是预期的。 */ Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses; if (wrapperClasses != null &amp;&amp; !wrapperClasses.isEmpty()) &#123; for (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123; // 创建 Wrapper 实例，然后进行 setter注入依赖属性 instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance)); &#125; &#125; return instance; &#125; catch (Throwable t) &#123; throw new IllegalStateException(\"Extension instance(name: \" + name + \", class: \" + type + \") could not be instantiated: \" + t.getMessage(), t); &#125; &#125; createExtension(String name)方法的逻辑代码中已经详细注释说明，下面小结关键的步骤： 调用getExtensionClasses()刷新扩展点实现类集合 通过反射创建扩展点的扩展对象并放入类缓存中 使用dubbo的setter注入向扩展对象中注入依赖属性 使用扩展点的Wrapper对扩展对象实现dubbo的aop处理逻辑 通过扩展名获取扩展对象时可能不能命中缓存，此时就要创建扩展对象，创建扩展对象需要扩展实现类，下面我们看下dubbo获取扩展名到扩展实现类的映射集合。 123456789101112131415161718192021222324/** * 获取扩展点实现类的集合，先从缓存中获取，没有命中缓存就从配置文件中加载并分类放入缓存。 * * @return */ private Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123; // 先从缓存中获取 Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get(); // 双重检锁，获取扩展点的扩展实现类集合 if (classes == null) &#123; synchronized (cachedClasses) &#123; classes = cachedClasses.get(); if (classes == null) &#123; // 加载扩展类 classes = loadExtensionClasses(); // 将 扩展名到扩展点实现类的映射 加入到 cachedClasses 集合中，缓存起来 cachedClasses.set(classes); &#125; &#125; &#125; return classes; &#125; 如果缓存不能命中扩展名对应的扩展实现类就只能加载配置文件刷新扩展点实现类集合,下面我们看下dubbo是如何加载配置文件的。 123456789101112131415161718192021222324252627282930313233343536private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123; //1、 通过@SPI注解获得扩展点的默认扩展名（前提是当前拓展点需要有@SPI注解，其实程序执行到这里type一定是有@SPI注解的，因为在获取扩展点的扩展加载器的时候已经判断了） final SPI defaultAnnotation = type.getAnnotation(SPI.class); //1.1 如果扩展点的@SPI注解设置了默认值 if (defaultAnnotation != null) &#123; // @SPI注解的值就是扩展点的默认扩展名 String value = defaultAnnotation.value(); if ((value = value.trim()).length() &gt; 0) &#123; // 对默认扩展名进行分隔处理，以逗号分隔为字符串数组 String[] names = NAME_SEPARATOR.split(value); // 检测 SPI 注解内容是否合法，不合法则抛出异常 if (names.length &gt; 1) &#123; throw new IllegalStateException(\"more than 1 default extension name on extension \" + type.getName() + \": \" + Arrays.toString(names)); &#125; /** 设置默认名称，cachedDefaultName 是用来加载扩展点的默认实现 &#123;@link #getDefaultExtension()&#125; */ if (names.length == 1) &#123; cachedDefaultName = names[0]; &#125; &#125; &#125; //2、 从配置文件中加载拓展实现类集合，这里分别对应三类文件（1. Dubbo内置的 2. Dubbo自定义 3. JDK SPI） Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;String, Class&lt;?&gt;&gt;(); loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY); loadDirectory(extensionClasses, DUBBO_DIRECTORY); loadDirectory(extensionClasses, SERVICES_DIRECTORY); return extensionClasses;&#125; 我们可以看到该方法没有太多的逻辑，主要处理扩展点的默认扩展名，如果存在的化就放入缓存中，具体加载配置文件的逻辑由loadDirectory方法实现。 需要注意的是，唯一调用该方法的入口 {@link #getExtensionClasses()} 已经加过了锁，因此此处无需再次加锁。接下来继续分析dubbo如何加载配置文件。 123456789101112131415161718192021222324252627282930313233private void loadDirectory(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir) &#123; // 拼接完整的文件名（相对路径）： 目录 + type全类名 String fileName = dir + type.getName(); try &#123; Enumeration&lt;java.net.URL&gt; urls; // 类加载器 ClassLoader classLoader = findClassLoader(); /** 获得文件名对应的所有文件数组（可能同一个文件名在不同的目录结构中，这样就会获取多个文件）,每个文件内容封装到一个java.net.URL中*/ if (classLoader != null) &#123; urls = classLoader.getResources(fileName); &#125; else &#123; urls = ClassLoader.getSystemResources(fileName); &#125; // 遍历java.net.URL集合 if (urls != null) &#123; while (urls.hasMoreElements()) &#123; java.net.URL resourceURL = urls.nextElement(); // 加载java.net.URL loadResource(extensionClasses, classLoader, resourceURL); &#125; &#125; &#125; catch (Throwable t) &#123; logger.error(\"Exception when load extension class(interface: \" + type + \", description file: \" + fileName + \").\", t); &#125;&#125; 通过上面代码可以看出,loadDirectory方法主要就做一件事，加载配置文件并将每个配置文件内容封装到java.net.URL集合中，接下来在loadResource方法中就可以从该URL中依次解析扩展名和扩展实现类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 加载配置文件内容（已经封装成了java.net.URL） * * @param extensionClasses 扩展类集合 * @param classLoader 类加载器 * @param resourceURL 文件内容资源 */ private void loadResource(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL) &#123; try &#123; // 读取文件内容 BufferedReader reader = new BufferedReader(new InputStreamReader(resourceURL.openStream(), \"utf-8\")); try &#123; String line; // 一行一行的读取。会跳过当前被注释掉行，例如：#dubbo=xxx while ((line = reader.readLine()) != null) &#123; // 如果有#注释，那么ci为0，没有就为-1 final int ci = line.indexOf('#'); // 在有#注释的情况下，此时line的长度为0 if (ci &gt;= 0) &#123; line = line.substring(0, ci); &#125; // 去除前后端空格，防止自定义扩展点实现时配置不规范 line = line.trim(); // 没有#注释的情况 if (line.length() &gt; 0) &#123; try &#123; /** * 拆分 key=value ，name为拓展名 line为拓展实现类名。注意： * 1 这里name可能为空,这种情况扩展名会自动生成（因为Dubbo SPI兼容Java SPI，Dubbo SPI配置强调key=value格式，应该尽可能遵守规则） * 2 扩展名只对普通扩展才有意义，对自适应扩展、Wrapper是没用的，之所以要配置，是为了统一dubbo spi配置规则 */ String name = null; // i &gt; 0，有扩展名； i &lt; 0 没有配置扩展名，即兼容Java SPI int i = line.indexOf('='); if (i &gt; 0) &#123; /** 获取 = 左边的key 即扩展名 */ name = line.substring(0, i).trim(); /** 获取 = 右边的value 即拓展点的实现的全限定性类名 */ line = line.substring(i + 1).trim(); &#125; // 加载当前行对应的扩展点配置 if (line.length() &gt; 0) &#123; /** * 1 通过反射，根据名称获取扩展点实现类 * 2 对扩展实现类进行分类缓存 */ loadClass(extensionClasses, resourceURL, Class.forName(line, true, classLoader), name); &#125; &#125; catch (Throwable t) &#123; IllegalStateException e = new IllegalStateException(\"Failed to load extension class(interface: \" + type + \", class line: \" + line + \") in \" + resourceURL + \", cause: \" + t.getMessage(), t); exceptions.put(line, e); &#125; &#125; &#125; &#125; finally &#123; reader.close(); &#125; &#125; catch (Throwable t) &#123; logger.error(\"Exception when load extension class(interface: \" + type + \", class file: \" + resourceURL + \") in \" + resourceURL, t); &#125; &#125; loadResource方法用于将配置文件中的每行记录读取出来，经过解析和反射处理就能拿到扩展名和对应的扩展实现类，扩展名和扩展实现类的获取逻辑已经在代码中详细注释。最后调用loadClass方法进行分类缓存，这些缓存很多，我们来看下dubbo是如何处理实例缓存的分类的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * 对扩展点实现类进行分类缓存 * * @param extensionClasses 扩展实现类集合 * @param resourceURL 文件内容资源 * @param clazz 扩展点实现类 * @param name 扩展名 【只对普通扩展才有意义】 * @throws NoSuchMethodException */private void loadClass(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name) throws NoSuchMethodException &#123; // 判断拓展点实现类，是否实现了当前type接口，没有实现就会报错 if (!type.isAssignableFrom(clazz)) &#123; throw new IllegalStateException(\"Error when load extension class(interface: \" + type + \", class line: \" + clazz.getName() + \"), class \" + clazz.getName() + \"is not subtype of interface.\"); &#125; //-------------------------------------- 根据扩展点实现类的类型可分为三大类 ，在进行分类缓存中有优先级，即同一个实现类只能归属到某个分类中 --------------------------------/ /** * 1、自适应扩展类 * 说明： * （1）当前扩展点实现类是否标注@Adaptive注解，标记的话就是自适应扩展类，直接缓存到 cachedAdaptiveClass 属性中，然后结束逻辑，即不会进行下面的 Wrapper、普通扩展类以及自动激活类逻辑判断。 * （2）自适应固定扩展实现类其实不需要配置扩展名，即使配置了也用不到，因为自适应扩展类和自适应扩展对象整个转换闭环都用不到扩展名。之所以配置，是为了统一规则。 */ if (clazz.isAnnotationPresent(Adaptive.class)) &#123; // 一个扩展点有且仅允许一个自适应扩展实现类，如果符合条件就加入到缓存中，否则抛出异常 if (cachedAdaptiveClass == null) &#123; cachedAdaptiveClass = clazz; &#125; else if (!cachedAdaptiveClass.equals(clazz)) &#123; throw new IllegalStateException(\"More than 1 adaptive class found: \" + cachedAdaptiveClass.getClass().getName() + \", \" + clazz.getClass().getName()); &#125; /** * 2、Wrapper类型 （该类需要有有一个参数的构造方法，且这个参数类型是当前的扩展点type） * 说明： * （1）当前扩展点实现类如果是Wrapper类，直接缓存到 cachedWrapperClasses 属性集合中，然后结束逻辑，即不会进行下面的 普通扩展类以及自动激活类逻辑判断。 * （2）Wrapper类其实不需要配置扩展名，即使配置了也用不到。之所以配置，是为了统一规则。 */ &#125; else if (isWrapperClass(clazz)) &#123; Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses; if (wrappers == null) &#123; cachedWrapperClasses = new ConcurrentHashSet&lt;Class&lt;?&gt;&gt;(); wrappers = cachedWrapperClasses; &#125; wrappers.add(clazz); /** * 3、普通的扩展实现类，注意Activate自动激活类从大的方面也属于普通的扩展实现类 */ &#125; else &#123; // 判断是否有默认的构造方法，没有会抛出异常 clazz.getConstructor(); // 未配置扩展名，则自动生成。适用于Java SPI的配置方式（Dubbo SPI 兼容Java SPI） 例如： xxx.yyy.DemoFilter生成的拓展名为demo if (name == null || name.length() == 0) &#123; // 自动生成扩展名 name = findAnnotationName(clazz); if (name.length() == 0) &#123; throw new IllegalStateException(\"No such extension name for the class \" + clazz.getName() + \" in the config \" + resourceURL); &#125; &#125; // 对扩展名进行分割处理，dubbo支持配置多个扩展名。如果配置多个扩展名需要以','分割 String[] names = NAME_SEPARATOR.split(name); if (names != null &amp;&amp; names.length &gt; 0) &#123; // 3.1、 如果当前类标注了@Activate，就缓存到 cachedActivates集合。需要注意的是，即使扩展点配置多个，cachedActivates 的key 只取第一个。 Activate activate = clazz.getAnnotation(Activate.class); if (activate != null) &#123; // 拓展名与 @Activate的映射 cachedActivates.put(names[0], activate); &#125; /** * 3.2、缓存当前扩展点分类到 cachedNames 集合 和 cachedClasses 集合 * 说明： * （1）cachedNames 缓存集合中的数据特点：同一个扩展点实现类对应的扩展名即使在配置多个扩展名的情况下也只取第一个 * （2）cachedClasses 缓存集合的数据特点：同一个扩展点实现类对应的扩展名可能存在多个 */ for (String n : names) &#123; // 缓存扩展类到扩展名的映射 if (!cachedNames.containsKey(clazz)) &#123; cachedNames.put(clazz, n); &#125; // 缓存扩展名到扩展类的映射，注意如果在不同的文件中配置同一个扩展点实现，并且扩展名有相同的情况，这时以解析的第一个为准 Class&lt;?&gt; c = extensionClasses.get(n); if (c == null) &#123; extensionClasses.put(n, clazz); &#125; else if (c != clazz) &#123; throw new IllegalStateException(\"Duplicate extension \" + type.getName() + \" name \" + n + \" on \" + c.getName() + \" and \" + clazz.getName()); &#125; &#125; &#125; &#125;&#125; 通过上面的代码可知，loadClass方法主要就是分类缓存不同扩展实现类，这个过程不涉及扩展实现类的实例化，这也验证了前面的结论，dubbo spi是按需实例化对象。到这里getExtension方法主要过就分析完了，前面也说到该方法是加载扩展实现的完整逻辑，其它的两个入口中的逻辑也会使用上面过程中的部分逻辑，在下面的代码分析中我们可以看到。 getActivateExtension 方法该方法只是根据不同的条件同时激活多个普通扩展实现类，即会做一些通用的判断来筛选是否是激活扩展扩展对象。前面多次提到该法会依赖getExtension方法中的逻辑，下面我就一起来看看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 获得激活条件的扩展实现对象集合 * * @param url url * @param values 激活的扩展名数组，可能为空。如：获取dubbo内置的过滤器时，key=service.filter，url中没有对应的值 * @param group 过滤分组名 * @return 被激活的扩展实现对象集合 * @see com.alibaba.dubbo.common.extension.Activate */ public List&lt;T&gt; getActivateExtension(URL url, String[] values, String group) &#123; // 激活扩展实现对象结果集 List&lt;T&gt; exts = new ArrayList&lt;T&gt;(); // 激活的扩展名集合 List&lt;String&gt; names = values == null ? new ArrayList&lt;String&gt;(0) : Arrays.asList(values); // 判断扩展名集合中是否有 '-default' , 如： &lt;dubbo:service filter=\"-default\"/&gt; 代表移出所有默认的过滤器。注意，names是个空的List是符合条件的 if (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123; // 获取/刷新 扩展点实现类的集合 getExtensionClasses(); /** * 遍历cachedActivates (拓展名 到 @Activate 的映射) * 1 匹配分组，匹配成功则继续逻辑，否则不处理 加载配置文件时收集到的激活扩展类 * 2 对激活扩展类进行实例化[初次才会，以后就从缓存中取] * 3 判断当前缓存中的激活扩展类是否和传入的激活扩展类冲突，如果有冲突，就忽略缓存中的激活扩展类，以传入的扩展类为主 */ for (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123; // 扩展名 String name = entry.getKey(); // Activate Activate activate = entry.getValue(); // 匹配分组，判断Activate注解的group属性值是否包含当前传入的group，包含就符合分组条件 if (isMatchGroup(group, activate.group())) &#123; // 获取扩展名对应的扩展点实现对象 T ext = getExtension(name); // 是否忽略 加载配置文件时收集到的激活扩展类 if (!names.contains(name) // 匹配扩展名 &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name) // 如果包含 '-' 表示不激活该扩展实现 &amp;&amp; isActive(activate, url)) // 检测URL中是否出现了指定的key &#123; exts.add(ext); &#125; &#125; &#125; // 对扩展对象进行排序（根据注解的before、after、order属性） Collections.sort(exts, ActivateComparator.COMPARATOR); &#125; List&lt;T&gt; usrs = new ArrayList&lt;T&gt;(); // 遍历传入的激活扩展名集合 for (int i = 0; i &lt; names.size(); i++) &#123; // 获取激活扩展名 String name = names.get(i); // 判断是否是 移除激活扩展名，如果是就忽略。 如： &lt;dubbo:service filter=\"-demo\"/&gt;，那么此时demo对应的扩展实现就是属于无效的 if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX) &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123; // 处理 自定义的激活扩展配置在默认的激活扩展前面的情况, 如： &lt;dubbo:service filter=\"demo,default\"/&gt;，那么自定义的demo激活扩展就优先默认的激活扩展。主要是exts中的值变化，前面已经处理了默认的激活扩展(加载配置文件时收集到的激活扩展类) if (Constants.DEFAULT_KEY.equals(name)) &#123; if (!usrs.isEmpty()) &#123; exts.addAll(0, usrs); usrs.clear(); &#125; &#125; else &#123; // 获得激活扩展实现对象 T ext = getExtension(name); usrs.add(ext); &#125; &#125; &#125; if (!usrs.isEmpty()) &#123; exts.addAll(usrs); &#125; return exts; &#125; 获取激活的扩展对象逻辑在代码中已经详细注释说明，获取扩展实现对象还是调用了getExtension方法。该方法主要步骤： 如果触发获取扩展实现类动作时，会检查缓存，如果缓存中没有，就加载配置文件来刷新扩展实现类集合。 遍历缓存中的激活集合（这个缓存内容是加载的带有@Activate注解的扩展类信息），根据传入的URL匹配条件筛选出符合激活条件的扩展类实现，然后进行排序操作。 遍历传入的激活扩展名集合，根据设置的顺序调整扩展点激活顺序，其中default代表的是所有@Activate标注并且配置在配置文件中的扩展实现类 通过getExtension(name)获取激活扩展名对应的扩展对象并加入结果集合 返回符合条件的激活类集合 getAdaptiveExtension 方法获取自适应扩展对象的入口，如果获取的自适应扩展类属于固定的，那么该方法相对独立，几乎不依赖getExtension方法的逻辑。如果属于动态生成则内部也会调用getExtension方法。由于该方法会涉及到javassist、动态编译等技术，内容较多且比较复杂，这里不再进行分析，我会单独写一篇文章进行详细说明。下面先给出固定的自适应扩展类和自动生成的自适应扩展类的示例，让胖友们有个概念。 固定的自适应扩展类，以编译扩展接口为例： 12345678910111213141516171819202122232425262728293031323334353637383940/** * AdaptiveCompiler. (SPI, Singleton, ThreadSafe) * 实现Compiler接口，自适应Compiler实现类 */@Adaptivepublic class AdaptiveCompiler implements Compiler &#123; /** * 默认编辑器的拓展名 */ private static volatile String DEFAULT_COMPILER; /** * 静态方法，设置默认编辑器的拓展名。该方法被 &#123;@link com.alibaba.dubbo.config.ApplicationConfig#setCompiler(java.lang.String)&#125;方法调用. * 在&lt;dubbo:application compiler=\"\"/&gt; 配置下可触发该方法 * * @param compiler */ public static void setDefaultCompiler(String compiler) &#123; DEFAULT_COMPILER = compiler; &#125; @Override public Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123; Compiler compiler; // 获得Compiler的ExtensionLoader对象 ExtensionLoader&lt;Compiler&gt; loader = ExtensionLoader.getExtensionLoader(Compiler.class); // 声明 name 变量，引用 DEFAULT_COMPILER 的值，避免下面的值变了 String name = DEFAULT_COMPILER; // 使用设置的拓展名，获得Compiler拓展对象 if (name != null &amp;&amp; name.length() &gt; 0) &#123; compiler = loader.getExtension(name); // 获得默认的Compiler拓展对象 &#125; else &#123; compiler = loader.getDefaultExtension(); &#125; // 使用真正的Compiler对象，动态编译代码 return compiler.compile(code, classLoader); &#125;&#125; 动态生成的自适应扩展类，以ZookeeperTransporter扩展接口为例 12345678910111213141516171819import com.alibaba.dubbo.common.extension.ExtensionLoader;public class ZookeeperTransporter$Adaptive implements com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter &#123; public com.alibaba.dubbo.remoting.zookeeper.ZookeeperClient connect(com.alibaba.dubbo.common.URL arg0) &#123; if (arg0 == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; com.alibaba.dubbo.common.URL url = arg0; String extName = url.getParameter(\"client\", url.getParameter(\"transporter\", \"curator\")); if (extName == null) &#123; throw new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter) name from url(\" + url.toString() + \") use keys([client, transporter])\"); &#125; com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter extension = (com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter) ExtensionLoader .getExtensionLoader(com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter.class) .getExtension(extName); return extension.connect(arg0); &#125;&#125; hasExtension 方法123456789101112131415161718/** * 判断是否有对应的扩展实现类 * * @param name 扩展名 * @return */ public boolean hasExtension(String name) &#123; if (name == null || name.length() == 0) &#123; throw new IllegalArgumentException(\"Extension name == null\"); &#125; try &#123; // 没有name对应的扩展实现类就抛出异常，即最后返回false this.getExtensionClass(name); return true; &#125; catch (Throwable t) &#123; return false; &#125; &#125; 上面代码比较简单，根据扩展名判断是否有对应的扩展实现类，之所以单独拿出来介绍是Dubbo的很多流程会用到该方法，有个印象就可以了。 dubbo ioc 实现dubbo的ioc实现目前仅支持setter注入，严谨来说，dubbo的ioc实现方式还可以通过构造注入，即Wrapper类的实现。dubbo的setter注入要求是，如果某个扩展类是另外一个扩展点实现类的成员属性，并且拥有对应的setter方法，那么dubbo就会自动注入对应的扩展点实现对象。这个功能在上面创建扩展实现的时候需要用到，当时没有详细说明，下面我们单独来分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 依赖注入 * * @param instance 扩展实现对象 （注意，可能会是一个Wrapper） * @return */ private T injectExtension(T instance) &#123; try &#123; // 只有ExtensionFactory扩展点对应的ExtensionLoader对象的该属性为null，其它扩展点的ExtensionLoader对象的该属性必然不为null if (objectFactory != null) &#123; // 反射获得扩展实现对象中的所有方法 for (Method method : instance.getClass().getMethods()) &#123; // 过滤规则为 ' set开头 + 仅有一个参数 + public ' 的方法 if (method.getName().startsWith(\"set\") &amp;&amp; method.getParameterTypes().length == 1 &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123; /** * 检查方法是否有 @DisableInject 注解，有该注解就忽略依赖注入 */ if (method.getAnnotation(DisableInject.class) != null) &#123; continue; &#125; // 获取setter方法参数类型 Class&lt;?&gt; pt = method.getParameterTypes()[0]; try &#123; // 获得属性名，如：setXxx -&gt; xxx String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : \"\"; /** * 通过扩展工厂获得属性值，即 方法参数类型作为扩展点，属性名作为扩展名。 * ExtensionFactory的实现有三个,AdaptiveExtensionFactory是对其它两个工厂的管理，getExtension方法的真正调用的是其它两个工厂的方法: * 1）SpringExtensionFactory * getExtension方法会返回容器中名称为property并且类型为pt的bean对象 * 2）SpiExtensionFactory * getExtension方法会返回类型为pt的自适应拓展对象，因为该方法会校验pt是接口类型并且有@SPI注解，然后pt有拓展类的情况下，就会获取pt的自适应拓展对象，property没用到 */ Object object = objectFactory.getExtension(pt, property); // 通过反射设置属性值 if (object != null) &#123; method.invoke(instance, object); &#125; &#125; catch (Exception e) &#123; logger.error(\"fail to inject via method \" + method.getName() + \" of interface \" + type.getName() + \": \" + e.getMessage(), e); &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; return instance; &#125; dubbo的ioc基于setter方法注入依赖的，注入的依赖来源则需要通过扩展工厂提供，接下来我们来分析dubbo的扩展工厂。 扩展工厂接口123456789101112@SPIpublic interface ExtensionFactory &#123; /** * Get extension. 获得扩展对象 * * @param type object type. 扩展接口 * @param name object name. 扩展名 * @return object instance. 扩展实现实例 */ &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name);&#125; ExtensionFactory 扩展工厂，是dubbo的一个扩展点。主要用于获取扩展实现对象所需的依赖，然后完成依赖注入，该接口的uml关系如下： 由uml图可知，该接口有三个扩展实现类。AdaptiveExtensionFactory是它的自适应实现类，只是用来管理SpiExtensionFactory和SpringExtensionFactory，具体依赖的查找还是由这两个类完成，下面我们分别来分析。 AdaptiveExtensionFactory 工厂12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Adaptivepublic class AdaptiveExtensionFactory implements ExtensionFactory &#123; /** * ExtensionFactory扩展实现对象集合 */ private final List&lt;ExtensionFactory&gt; factories; /** * AdaptiveExtensionFactory也是ExtensionFactory的扩展实现类，只是比较特殊，是自适应扩展类，不同于普通的扩展类 */ public AdaptiveExtensionFactory() &#123; ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class); List&lt;ExtensionFactory&gt; list = new ArrayList&lt;ExtensionFactory&gt;(); // 使用ExtensionLoader 加载拓展点实现类，getSupportedExtensions() 返回的是ExtensionFactory扩展点实现类对应的扩展名集合 for (String name : loader.getSupportedExtensions()) &#123; // 根据扩展名获取 ExtensionFactory 的扩展实现对象 并加入缓存中 list.add(loader.getExtension(name)); &#125; factories = Collections.unmodifiableList(list); &#125; /** * 获取目标对象，主要用于 &#123;@link ExtensionLoader#injectExtension(java.lang.Object)&#125; 方法中，用于获取扩展实现对象所需要的依赖属性值 * * @param type object type. 扩展接口 * @param name object name. 扩展名 * @param &lt;T&gt; * @return */ @Override public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123; // 遍历扩展工厂对象，获取指定的扩展对象或Spring中的Bean对象 for (ExtensionFactory factory : factories) &#123; T extension = factory.getExtension(type, name); if (extension != null) &#123; return extension; &#125; &#125; return null; &#125;&#125; AdaptiveExtensionFactory 自适应扩展工厂，内部维护了一个 ExtensionFactory 列表，用来管理其它的ExtensionFactory。在用户没有自定义ExtensionFactory的情况下，dubbo目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建 自适应的拓展，后者从Spring容器中获取所需依赖。 SpiExtensionFactory 工厂12345678910111213141516171819202122232425public class SpiExtensionFactory implements ExtensionFactory &#123; /** * 获取自适应扩展对象 * * @param type object type. 扩展接口 * @param name object name. 扩展名 * @param &lt;T&gt; * @return */ @Override public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123; // 校验是接口类型并且有@SPI注解 if (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123; // 加载拓展接口对应的 ExtensionLoader ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type); // 判断当前扩展点是否有普通的扩展实现类，注意：当前扩展点存在普通的扩展实现类才会去获取对应的自适应扩展对象 if (!loader.getSupportedExtensions().isEmpty()) &#123; // 获取自适应扩展对象 return loader.getAdaptiveExtension(); &#125; &#125; return null; &#125;&#125; SpringExtensionFactory 工厂12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class SpringExtensionFactory implements ExtensionFactory &#123; private static final Logger logger = LoggerFactory.getLogger(SpringExtensionFactory.class); /** * Spring上下文 */ private static final Set&lt;ApplicationContext&gt; contexts = new ConcurrentHashSet&lt;ApplicationContext&gt;(); /** * 保存Spring上下文 * * @param context */ public static void addApplicationContext(ApplicationContext context) &#123; contexts.add(context); &#125; public static void removeApplicationContext(ApplicationContext context) &#123; contexts.remove(context); &#125; // currently for test purpose public static void clearContexts() &#123; contexts.clear(); &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123; // 遍历SpringContext上下集合 for (ApplicationContext context : contexts) &#123; // 判断容器中是否包含名称为name的bean if (context.containsBean(name)) &#123; // 获得bean对象 Object bean = context.getBean(name); // 判断获得的bean类型是否是type类型 if (type.isInstance(bean)) &#123; return (T) bean; &#125; &#125; &#125; logger.warn(\"No spring extension (bean) named:\" + name + \", try to find an extension (bean) of type \" + type.getName()); if (Object.class == type) &#123; return null; &#125; for (ApplicationContext context : contexts) &#123; try &#123; return context.getBean(type); &#125; catch (NoUniqueBeanDefinitionException multiBeanExe) &#123; logger.warn(\"Find more than 1 spring extensions (beans) of type \" + type.getName() + \", will stop auto injection. Please make sure you have specified the concrete parameter type and there's only one extension of that type.\"); &#125; catch (NoSuchBeanDefinitionException noBeanExe) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Error when get spring extension(bean) for type:\" + type.getName(), noBeanExe); &#125; &#125; &#125; logger.warn(\"No spring extension (bean) named:\" + name + \", type:\" + type.getName() + \" found, stop get bean.\"); return null; &#125;&#125; dubbo使用spring容器管理的依赖为扩展对象注入依赖属性。dubbo是如何与spring容器打通的呢？有两处结合点，分别是服务暴露和服务引用的时候，利用ApplicationContextAware的回调方法设置spring上下文。 服务暴露结合点 123456789101112131415161718192021222324252627282930313233public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener&lt;ContextRefreshedEvent&gt;, BeanNameAware, ApplicationEventPublisherAware &#123; // 省略无关代码 @Override public void setApplicationContext(ApplicationContext applicationContext) &#123;// 当前加载的上下文 this.applicationContext = applicationContext; // 为Spring拓展工厂注入上下文 ,todo dubbo和Spring容器打通 SpringExtensionFactory.addApplicationContext(applicationContext); if (applicationContext != null) &#123; SPRING_CONTEXT = applicationContext; try &#123; Method method = applicationContext.getClass().getMethod(\"addApplicationListener\", new Class&lt;?&gt;[]&#123;ApplicationListener.class&#125;); // backward compatibility to spring 2.0.1 method.invoke(applicationContext, new Object[]&#123;this&#125;); supportedApplicationListener = true; // 当前Spring容器是否支持上下文监听 &#125; catch (Throwable t) &#123; if (applicationContext instanceof AbstractApplicationContext) &#123; try &#123; Method method = AbstractApplicationContext.class.getDeclaredMethod(\"addListener\", new Class&lt;?&gt;[]&#123;ApplicationListener.class&#125;); // backward compatibility to spring 2.0.1 if (!method.isAccessible()) &#123; method.setAccessible(true); &#125; method.invoke(applicationContext, new Object[]&#123;this&#125;); supportedApplicationListener = true; &#125; catch (Throwable t2) &#123; &#125; &#125; &#125; &#125; &#125;&#125; 服务引用结合点123456789public class ReferenceBean&lt;T&gt; extends ReferenceConfig&lt;T&gt; implements FactoryBean, ApplicationContextAware, InitializingBean, DisposableBean &#123; // 省略无关代码 @Override public void setApplicationContext(ApplicationContext applicationContext) &#123; this.applicationContext = applicationContext; // dubbo 和 spring容器打通 SpringExtensionFactory.addApplicationContext(applicationContext); &#125;&#125; dubbo aop 实现dubbo aop 实现需要Wrapper类，关于Wrapper类前面已经介绍过了，这里不再说明。关于dubbo aop的功能也在前面的流程中体现出来了，单独把dubbo aop拿出来进行说明是考虑到前面的篇幅没有具体到Wrapper类，只是阐述了其功能和实现。实现一个Wrapper类的基本步骤如下： 定义一个Wrapper类并实现扩展接口，然后编写AOP逻辑。 在配置文件配置自定义的Wrapper类 定义 Wrapper类123456789101112131415161718192021public class CommandWrapper implements Command &#123; Command command; /** * 构造方法的参数必须是扩展点类型 * * @param command */ public CommandWrapper(Command command) &#123; this.command = command; &#125; @Override public void execute() &#123; System.out.println(\"CommandWrapper is running ...\"); // 执行扩展实现对象，注意，如果不显示调用扩展实现，那么就达不到目标结果，只会执行这个并没有真正实现的Wrapper command.execute(); &#125;&#125; 定义Wrapper类很简单，只要按照Wrapper类的要求进行实现即可。需要说明的是，我们所说的Wrapper类其实不强制类名以Wrapper结尾，只要符合Wrapper类的要求就是一个Wrapper类，并不是用名字进行区分是否Wrapper类，只是这样写是dubbo的一种约定罢了。 配置 Wrapper类 dubbo 内置的Wrapper 举例123456789101112131415161718192021222324252627/** * 实现 Cluster接口，MockClusterWrapper实现类，注意它是个Wrapper类，对应的Cluster对象都会被它所包装。 */public class MockClusterWrapper implements Cluster &#123; /** * 真正的Cluster 对象 */ private Cluster cluster; public MockClusterWrapper(Cluster cluster) &#123; this.cluster = cluster; &#125; /** * 创建MockClusterInvoker对象 * * @param directory Directory 对象 * @param &lt;T&gt; * @return * @throws RpcException */ @Override public &lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory) throws RpcException &#123; return new MockClusterInvoker&lt;T&gt;(directory, this.cluster.join(directory)); &#125;&#125; 总结本篇文章简单介绍了dubbo spi 用法，并对 dubbo spi 的核心源码进行了分析，总体上不算复杂但很繁琐，细节点很多，比如，扩展名生成的规则，扩展类的种类区别，自动激活扩展生效条件。想要掌握整个流程需要耐心调试源码，笔者差点被spi及接下来要分析的dubbo配置给劝退了。另外，由于dubbo spi自适应机制涉及到的代码量较多，逻辑比较复杂，我将会在下一篇文章中单独进行分析。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"SPI","slug":"SPI","permalink":"https://gentryhuang.com/tags/SPI/"}]},{"title":"Java SPI","slug":"rpc/SPI机制之JDK","date":"2020-03-10T16:00:00.000Z","updated":"2020-09-03T01:23:40.731Z","comments":false,"path":"posts/a9c33b8c/","link":"","permalink":"https://gentryhuang.com/posts/a9c33b8c/","excerpt":"","text":"SPI概述SPI（Service Provider Interface）是JDK内置的一种服务提供发现机制。一个服务(Service)通常指的是已知的接口或者抽象类，服务提供方就是对这个接口或者抽象类的实现，然后按照SPI标准存放到资源路径META-INF/services目录下，文件的命名为该服务接口的全限定名。Java SPI使用了策略模式，一个接口多种实现，我们只声明接口，具体的实现并不在程序中直接确定，而是由配置决定。 约定 服务的提供者的接口，它的多种实现一般会在jar包的META-INF/services 目录下，在这个目录下创建服务提供者接口同名文件，这个文件中就是接口的具体实现类的全限定性类名。而当外部加载这个服务提供功能时，就能通过该jar包META-INF/services/下的配置文件得到具体的实现类名，并加载实例化，完成功能的装配。 实现步骤 定义接口 编写接口实现类 在META-INF/services 目录下创建一个以接口全路径名的文件 文件内容是接口实现类的全路径名，可以有多个，如果多个需要使用分行符分割 在代码中使用jdk的ServiceLoader来加载接口的具体实现类 示例服务提供者接口1234567package com.alibaba.dubbo.spi;public interface Command &#123; /** * 执行方法 */ void execute();&#125; 服务提供者实现类1234567package com.alibaba.dubbo.spi.impl;public class StartCommand implements Command&#123; @Override public void execute() &#123; System.out.println(\"start....\"); &#125; &#125; 1234567package com.alibaba.dubbo.spi.impl;public class ShutdownCommand implements Command&#123; @Override public void execute() &#123; System.out.println(\"shutdown....\"); &#125; &#125; 在META-INF/services下创建 com.alibaba.dubbo.spi.Command文件123# 内容com.alibaba.dubbo.spi.impl.StartCommandcom.alibaba.dubbo.spi.impl.ShutdownCommand 加载扩展实现123456789101112131415public class Main &#123; public static void main(String[] args) &#123; // ServiceLoader是JDK的，用来加载接口的实现类（通过配置文件加载） ServiceLoader&lt;Command&gt; serviceLoader = ServiceLoader.load(Command.class); for (Command command : serviceLoader) &#123; if (command instanceof StartCommand) &#123; System.out.println(\"判断出是Start：\" + command.getClass().getSimpleName()); &#125; if (command instanceof ShutdownCommand) &#123; System.out.println(\"判断出是Shutdown：\" + command.getClass().getSimpleName()); &#125; command.execute(); &#125; &#125;&#125; 使用jdk的spi的依赖mysql驱动 SpringServletContainer初始化器 小结jdk的spi机制虽然实现了服务发现机制，即在模块装配的时候不在模块中写死代码就能够发现服务，但是存在性能和健壮性问题，具体的问题及解决方案在dubbo spi中说明。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"JDK","slug":"JDK","permalink":"https://gentryhuang.com/tags/JDK/"},{"name":"SPI","slug":"SPI","permalink":"https://gentryhuang.com/tags/SPI/"}]},{"title":"Dubbo项目结构总览","slug":"rpc/dubbo项目结构总览","date":"2020-03-08T16:00:00.000Z","updated":"2020-08-15T13:48:14.901Z","comments":false,"path":"posts/e2577ca1/","link":"","permalink":"https://gentryhuang.com/posts/e2577ca1/","excerpt":"","text":"前言dubbo源码分析相关文章使用的dubbo版本为2.6.5，如使用其它版本会显示说明。参考文档以官方文档 为主【官网文档写的太好了】，参考书籍《深入理解Apache Dubbo与实战》。 框架设计由于dubbo官方文档写的非常好，这里会大量引用相关的图片及说明，点我 进入官方文档。 整体设计 图例说明： 图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。 图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。 图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。 图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。 总体分层从整体设计设计图可知悉，dubbo的总体分为业务层(Business)、RPC层、Remote三层，每一层细分共可分成十层。Service和Config两层可以认为是API层，主要提供给API使用者，使用者无须关心底层的实现，只需要配置和完成业务代码即可。其它八层合在一起可以认为是SPI层，用于扩展，即开放者可以基于SPI层自定义一些组件来完成具体业务，也可以基于dubbo框架做定制性的二次开发。 dubbo核心组件dubbo中每层都代表了不同的逻辑实现，它们是一个个组件，这些组件构成了整个dubbo体系。对于使用方来说更多接触到的是配置，按照dubbo配置规则选择适合当前业务的配置项即可轻松实现rpc调用。正是由于dubbo的各个组件职责分明的设计，才使得dubbo框架能够做到高扩展性。dubbo核心组件如下表： 分层名 作用 service 业务层：包括业务代码的接口与实现，即开放者实现的业务代码。 config 配置层：主要围绕ServiceConfig（服务提供方配置）和ReferenceConfig（服务消费方）展开，初始化配置信息。可以理解为该层管理了整个dubbo的配置 proxy 服务代理层：在dubbo中，无论提供者还是消费者，框架都会生成一个代理类，整个过程对上层是透明的。当调用一个远程接口时，看起来就像是调用了一个本地接口一样，代理层会自动做远程调用并返回结果，即让业务层对远程调用完全无感知 registry 注册中心层：负责dubbo框架的服务注册与发现。当有新的服务加入或旧服务下线时，注册中心都会感知并通知给所有订阅方 cluster 集群容错层：提供多种容错策略、封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance以及Mock monitor 监控层：RPC 调用次数和调用时间监控等 protocol 远程调用层：封装RPC调用具体过程，以 Invocation, Result 为中心，是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。 exchange 信息交换层：建立Request-Response模型，封装请求响应模式，以 Request, Response 为中心 transport 网络传输层：把网络传输抽象为统一接口，以 Message 为中心，如Mina和Netty虽然接口不一样，但是Dubbo在它们上面封装了统一的接口。用户可以根据其扩展接口添加更多的网络传输方式。 serialize 序列化层：如果数据要通过网络进行传输，则需要先做序列化，转成二进制流。序列化层负责管理整个框架网络传输时的序列化和反序列化工作 关系说明 在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。 图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。 而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。 Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。 而Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。 Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。 领域模型 Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。 Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。 Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。 特别说明: protocol是对数据格式的一种约定，它可以把我们对接口的配置，根据具体的协议转换成不同的Invoker对象。 基本设计原则 Dubbo 自身的功能也是通过扩展点实现的，也就是 Dubbo 的所有功能点都可被用户自定义扩展所替换 采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息 源码分析范围除了架构图中的Monitor模块不会详细分析，其它都会详细分析。 小结本文主要简单介绍了dubbo的总体架构图和核心组件，这样在阅读源码之前有整体的概念。更详细的介绍可以参考官网文档。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"URL统一模型","slug":"rpc/dubbo之url统一模型","date":"2020-03-06T16:00:00.000Z","updated":"2020-09-04T09:14:17.485Z","comments":false,"path":"posts/46f95e97/","link":"","permalink":"https://gentryhuang.com/posts/46f95e97/","excerpt":"","text":"URL 定义URL 的全名即统一资源定位符，因特网上的可用资源是使用字符串来表示的，而这些具有特定格式和语义的字符串就是URL 标准的URL格式: 12组成：协议、账号&#x2F;密码、主机、端口、路径 [大多数url不需要账号&#x2F;密码,需要安全认证的才会需要]格式：protocol:&#x2F;&#x2F;[username:password@]host:port&#x2F;path?key&#x3D;value&amp;key&#x3D;value Dubbo中的 URLDubbo中也使用了类似的 URL，URL 中的每个参数几乎都有各自的用途，它们往往对应着特定的功能或实现。Dubbo中对这个 URL 做了封装，大体上分为主要参数和键值对参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * url 例子: * &lt;ul&gt; * &lt;li&gt;http://www.facebook.com/friends?param1=value1&amp;amp;param2=value2 * &lt;li&gt;http://username:password@10.20.130.230:8080/list?version=1.0.0 * &lt;li&gt;ftp://username:password@192.168.1.7:21/1/read.txt * &lt;li&gt;registry://192.168.1.7:9090/com.alibaba.service1?param1=value1&amp;amp;param2=value2 * &lt;/ul&gt; * 一些特别的url: * &lt;ul&gt; * &lt;li&gt;192.168.1.3:20880&lt;br&gt; * for this case, url protocol = null, url host = 192.168.1.3, port = 20880, url path = null * &lt;li&gt;file:///home/user1/router.js?type=script&lt;br&gt; * for this case, url protocol = file, url host = null, url path = home/user1/router.js * &lt;li&gt;file://home/user1/router.js?type=script&lt;br&gt; * for this case, url protocol = file, url host = home, url path = user1/router.js * &lt;li&gt;file:///D:/1/router.js?type=script&lt;br&gt; * for this case, url protocol = file, url host = null, url path = D:/1/router.js * &lt;li&gt;file:/D:/1/router.js?type=script&lt;br&gt; * 同上： file:///D:/1/router.js?type=script * &lt;li&gt;/home/user1/router.js?type=script &lt;br&gt; * 对于这些例子： url protocol = null, url host = null, url path = home/user1/router.js * &lt;li&gt;home/user1/router.js?type=script &lt;br&gt; * 对于这些例子： url protocol = null, url host = home, url path = user1/router.js * &lt;/ul&gt; * * @see java.net.URL * @see java.net.URI */public final class URL implements Serializable &#123; private static final long serialVersionUID = -1985165475234910535L; /** * 协议名 */ private final String protocol; /** * 用户名 */ private final String username; /** * 密码 */ private final String password; /** by default, host to registry * 地址 */ private final String host; /** by default, port to registry * 端口 */ private final int port; /** * 路径（服务名） */ private final String path; /** * 参数集合，键值对形式 */ private final Map&lt;String, String&gt; parameters; // 省略其它属性及构造函数 public URL(String protocol, String username, String password, String host, int port, String path, Map&lt;String, String&gt; parameters) &#123; if ((username == null || username.length() == 0) &amp;&amp; password != null &amp;&amp; password.length() &gt; 0) &#123; throw new IllegalArgumentException(\"Invalid url, password without username!\"); &#125; this.protocol = protocol; this.username = username; this.password = password; this.host = host; this.port = (port &lt; 0 ? 0 : port); // trim the beginning \"/\" while (path != null &amp;&amp; path.startsWith(\"/\")) &#123; path = path.substring(1); &#125; this.path = path; if (parameters == null) &#123; parameters = new HashMap&lt;String, String&gt;(); &#125; else &#123; parameters = new HashMap&lt;String, String&gt;(parameters); &#125; this.parameters = Collections.unmodifiableMap(parameters); &#125; // 省略其它方法 &#125; Dubbo中常见的 URL Dubbo协议的服务 1dubbo:&#x2F;&#x2F;10.1.22.50:20880&#x2F;com.alibaba.dubbo.demo.DemoService?anyhost&#x3D;true&amp;application&#x3D;demo-provider&amp;bean.name&#x3D;com.alibaba.dubbo.demo.DemoService&amp;bind.ip&#x3D;10.1.14.50&amp;bind.port&#x3D;20880&amp;dubbo&#x3D;2.0.2&amp;generic&#x3D;false&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;qos.port&#x3D;22222&amp;side&#x3D;provider&amp;timestamp&#x3D;1596611769521 服务提供者 1provider:&#x2F;&#x2F;10.1.22.50:20880&#x2F;com.alibaba.dubbo.demo.DemoService?anyhost&#x3D;true&amp;application&#x3D;demo-provider&amp;bean.name&#x3D;com.alibaba.dubbo.demo.DemoService&amp;category&#x3D;configurators&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.2&amp;generic&#x3D;false&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;side&#x3D;provider&amp;timestamp&#x3D;1596611769521 服务消费者 1consumer:&#x2F;&#x2F;10.1.22.50&#x2F;com.alibaba.dubbo.demo.DemoService?application&#x3D;demo-consumer&amp;category&#x3D;consumers&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.2&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;3363&amp;qos.port&#x3D;33333&amp;side&#x3D;consumer&amp;timestamp&#x3D;1596612621336 服务暴露过程临时协议 1registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.2&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;qos.port&#x3D;22222&amp;registry&#x3D;zookeeper&amp;timestamp&#x3D;1596611658802 zk注册中心 1zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.2&amp;interface&#x3D;com.alibaba.dubbo.registry.RegistryService&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;qos.port&#x3D;22222&amp;timestamp&#x3D;1596611658802 说明: 除此之外还有很多类型的 URL ，不同的协议[如：dubbo协议、http协议等]对应不同的URL、不同的角色[如：提供者、消费者、注册中心、路由器等]对应不同的URL、不同的功能流程[如：服务暴露、服务引用、服务路由等]对应不同的URL…这些在后面的源码解析中都有对应。 Dubbo的 URL 统一模型的意义Dubbo中的 URL 可以说是Dubbo的配置总线，它贯穿整个Dubbo的生命周期。上下文的信息传递需要 URL 来提供，特定功能的实现需要 URL 的支持[如：所有扩展点参数都包含url参数，url作为上下文信息贯穿整个拓展点体系]。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"Dubbo示例 - 注解配置","slug":"rpc/Dubbo第三例","date":"2020-03-05T16:00:00.000Z","updated":"2020-09-01T12:12:42.307Z","comments":false,"path":"posts/7202a9c0/","link":"","permalink":"https://gentryhuang.com/posts/7202a9c0/","excerpt":"","text":"快速启动使用注解的方式进行配置 定义服务接口12345678910package com.alibaba.dubbo.examples.annotation.api;/** * AnnotationService */public interface AnnotationService &#123; String sayHello(String name);&#125; 服务提供方123456789101112131415161718package com.alibaba.dubbo.examples.annotation.impl;import com.alibaba.dubbo.config.annotation.Service;import com.alibaba.dubbo.examples.annotation.api.AnnotationService;/** * AnnotationServiceImpl，注意，这里 @Service 注解是Dubbo的注解，用来进行服务暴露的 */@Servicepublic class AnnotationServiceImpl implements AnnotationService &#123; @Override public String sayHello(String name) &#123; System.out.println(\"async provider received: \" + name); return \"annotation: hello, \" + name; &#125;&#125; 服务提供方属性配置12345# dubbo-provider.propertiesdubbo.application.name&#x3D;annotation-providerdubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181dubbo.protocol.name&#x3D;dubbodubbo.protocol.port&#x3D;20880 说明: 使用dubbo注解形式一般结合属性配置，用来配置应用共享的配置项。 指定扫描路径，启动容器并暴露服务12345678910111213141516171819202122232425262728293031323334353637383940package com.alibaba.dubbo.examples.annotation;import com.alibaba.dubbo.config.ProviderConfig;import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;/** * AnnotationProvider * * Java Config + 注解的方式 */public class AnnotationProvider &#123; public static void main(String[] args) throws Exception &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ProviderConfiguration.class); context.start(); System.in.read(); &#125; @Configuration @EnableDubbo(scanBasePackages = \"com.alibaba.dubbo.examples.annotation.impl\") @PropertySource(\"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-provider.properties\") static public class ProviderConfiguration &#123; /** * 这里通过Java Config显示组装出Bean，会注入给Dubbo服务，即标注有@Service的类。如果不显示装配，Dubbo会默认创建内置的配置类定义，创建内置的配置类定义的前提是配置了相关的属性，否则不会创建。其他配置类似。 */ @Bean public ProviderConfig providerConfig() &#123; ProviderConfig providerConfig = new ProviderConfig(); providerConfig.setTimeout(5000); return providerConfig; &#125; &#125;&#125; 服务消费方123456789101112131415161718192021package com.alibaba.dubbo.examples.annotation.action;import com.alibaba.dubbo.config.annotation.Reference;import com.alibaba.dubbo.examples.annotation.api.AnnotationService;import org.springframework.stereotype.Component;/** * AnnotationAction，注意，@Reference注解用来引用服务 */@Component(\"annotationAction\")public class AnnotationAction &#123; @Reference private AnnotationService annotationService; public String doSayHello(String name) &#123; return annotationService.sayHello(name); &#125;&#125; 服务消费方属性配置1234# dubbo-consumer.propertiesdubbo.application.name&#x3D;annotation-consumerdubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181dubbo.consumer.timeout&#x3D;3000 说明: 使用dubbo注解形式一般结合属性配置，用来配置应用共享的配置项。 扫描路径，启动容器并调用服务123456789101112131415161718192021222324252627282930313233343536373839404142package com.alibaba.dubbo.examples.annotation;import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;import com.alibaba.dubbo.examples.annotation.action.AnnotationAction;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;/** * AnnotationConsumer */public class AnnotationConsumer &#123; public static void main(String[] args) throws Exception &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConsumerConfiguration.class); context.start(); final AnnotationAction annotationAction = (AnnotationAction) context.getBean(\"annotationAction\"); String hello = annotationAction.doSayHello(\"world\"); System.out.println(\"result :\" + hello); System.in.read(); &#125; @Configuration @EnableDubbo(scanBasePackages = \"com.alibaba.dubbo.examples.annotation.action\") @PropertySource(\"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-consumer.properties\") @ComponentScan(value = &#123;\"com.alibaba.dubbo.examples.annotation.action\"&#125;) static public class ConsumerConfiguration &#123; /** * 这里通过Java Config显示组装出Bean，会注入给Dubbo服务，即标注有@Reference的类。如果不显示装配，Dubbo会默认创建内置的配置类定义，创建内置的配置类定义的前提是配置了相关的属性，否则不会创建。其他配置类似。 */ @Bean public ConsumerConfig consumerConfig() &#123; ConsumerConfig consumerConfig = new ConsumerConfig(); consumerConfig.setTimeout(3000); return consumerConfig; &#125; &#125;&#125; 小结注解实现使代码更整洁，开发效率更高，随着注解和配置化的盛行，xml的方式会渐渐地淡出舞台。但使用注解对开放者的要求更高，具体的dubbo注解如何与Spring融合，在后面的章节中会进行说明。使用注解的方式，配置对象的创建及配置对象属性设置也都是Spring完成的，注意这里Spring完成配置属性地设置是指启动加载的配置属性，如上面例子中的@PropertySource注解引入的配置文件内容，此外@Service、@Reference注解中的属性Spring会自动绑定到配置对象中，至于系统参数、dubbo.properties中的配置参数等是dubbo框架自动加载并配置的，我们可在服务暴露和服务引用中看到具体的过程。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"Dubbo示例 - XML配置","slug":"rpc/Dubbo第二例","date":"2020-03-03T16:00:00.000Z","updated":"2020-08-15T15:30:22.534Z","comments":false,"path":"posts/3f1c0a92/","link":"","permalink":"https://gentryhuang.com/posts/3f1c0a92/","excerpt":"","text":"快速启动使用xml的方式进行配置，详细配置项：配置参考手册 定义服务接口12345package com.alibaba.dubbo.demo;public interface DemoService &#123; String sayHello(String name);&#125; 服务提供方实现接口12345678910111213141516package com.alibaba.dubbo.demo.provider;import com.alibaba.dubbo.demo.DemoService;import com.alibaba.dubbo.rpc.RpcContext;import java.text.SimpleDateFormat;import java.util.Date;public class DemoServiceImpl implements DemoService &#123; @Override public String sayHello(String name) &#123; System.out.println(\"[\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()) + \"] Hello \" + name + \", request from consumer: \" + RpcContext.getContext().getRemoteAddress()); return \"Hello \" + name + \", response from provider: \" + RpcContext.getContext().getLocalAddress(); &#125;&#125; 服务提供方服务暴露配置1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=\"demo-provider\" owner=\"gentryhuang\"/&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;bean id=\"demoService\" class=\"com.alibaba.dubbo.demo.provider.DemoServiceImpl\"/&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;dubbo:service interface=\"com.alibaba.dubbo.demo.DemoService\" ref=\"demoService\"/&gt;&lt;/beans&gt; 启动Spring容器，进行服务暴露12345678910111213package com.alibaba.dubbo.demo.provider;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Provider &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;\"META-INF/spring/dubbo-demo-provider.xml\"&#125;); context.start(); System.in.read(); // press any key to exit &#125;&#125; 服务消费者引用服务配置1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=\"demo-consumer\"/&gt; &lt;!-- 使用zookeeper注册中心暴露发现服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id=\"demoService\" check=\"false\" interface=\"com.alibaba.dubbo.demo.DemoService\"/&gt;&lt;/beans&gt; 加载Spring配置，并调用远程服务123456789101112131415161718192021222324package com.alibaba.dubbo.demo.consumer;import com.alibaba.dubbo.demo.DemoService;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Consumer &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;\"META-INF/spring/dubbo-demo-consumer.xml\"&#125;); context.start(); DemoService demoService = (DemoService) context.getBean(\"demoService\"); // get remote service proxy while (true) &#123; try &#123; Thread.sleep(5000); String hello = demoService.sayHello(\"world\"); // call remote method System.out.println(hello); // get result &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125; &#125;&#125; 小结dubbo自定义了很多的xml标签，这些标签就对应了API配置中的配置对象，标签的属性就对应配置对象的属性，API的方式是手动创建配置对象并设置属性值，xml的方式是创建配置对象和设置属性值都交给Spring来完成，注意DubboBeanDefinitionParser设置的属性值不包括系统参数、dubbo.properties等，而是xml中配置对象的属性。这些标签是怎么和pring融合的在spring自定义标签中已经介绍了实现原理，在后面的dubbo配置解析中会继续说明。更多的配置请参考：配置参考手册。下一篇文章中我们介绍使用注解的方式进行配置,这种方式更简洁，效率更高。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"Dubbo示例 - API配置","slug":"rpc/Dubbo第一例","date":"2020-03-02T16:00:00.000Z","updated":"2020-08-15T08:43:51.063Z","comments":false,"path":"posts/f0ae64a/","link":"","permalink":"https://gentryhuang.com/posts/f0ae64a/","excerpt":"","text":"快速启动使用API的方式进行启动、调用。API 属性与配置项一对一，各属性含义，请参见：配置参考手册，比如：ApplicationConfig.setName(“xxx”) 对应 &lt;dubbo:application name=”xxx” /&gt; 定义服务接口1234567891011121314151617package com.code.resorce.api;/** * DemoService * * @author shunhua * @since 2020/03/03 * &lt;p&gt; * desc： */public interface DemoService &#123; /** * @return */ String hello();&#125; 服务提供方实现接口123456789101112131415161718package com.code.resource.reading.api;import com.code.resorce.api.DemoService;/** * DemoServiceImpl * * @author shunhua * @since 2020/03/03 * &lt;p&gt; * desc： */public class DemoServiceImpl implements DemoService &#123; @Override public String hello() &#123; return \"hello world\"; &#125;&#125; 使用API配置声明暴露服务123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * ApiProvider * * @author shunhua * @since 2020/03/03 * &lt;p&gt; * desc： */public class ApiProvider &#123; public static void main(String[] args) throws IOException &#123; // 服务对象 DemoService demoService = new DemoServiceImpl(); // 应用配置 ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName(\"api-config-demo-provider\"); // 连接注册中心配置 RegistryConfig registryConfig = new RegistryConfig(); registryConfig.setAddress(\"zookeeper://127.0.0.1:2181\"); // 服务提供者协议配置 ProtocolConfig protocolConfig = new ProtocolConfig(); protocolConfig.setName(\"dubbo\"); protocolConfig.setPort(20880); //省略ServiceConfig的其它配置项，如Module、Provider、Monitor等 // 服务提供者暴露服务配置，注意：ServiceConfig为重对象，内部封装了与注册中心的连接，以及开启服务端口，请自行缓存，否则可能造成内存和连接泄漏 ServiceConfig&lt;DemoService&gt; serviceConfig = new ServiceConfig&lt;DemoService&gt;(); serviceConfig.setApplication(applicationConfig); serviceConfig.setRegistry(registryConfig); serviceConfig.setProtocol(protocolConfig); serviceConfig.setInterface(DemoService.class); serviceConfig.setRef(demoService); // 暴露及注册服务 serviceConfig.export(); // 阻主线程，防止服务关闭，用于消费者的调用 System.in.read(); &#125;&#125; 使用API配置服务引用123456789101112131415161718192021222324252627282930313233343536373839/** * ApiConsumer * * @author shunhua * @since 2020/03/03 * &lt;p&gt; * desc： */public class ApiConsumer &#123; public static void main(String[] args) throws InterruptedException &#123; // 当前应用配置 ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName(\"api-config-demo-provider\"); // 连接注册中心配置 RegistryConfig registryConfig = new RegistryConfig(); registryConfig.setAddress(\"zookeeper://127.0.0.1:2181\"); // 省略ReferenceConfig的其它配置项，如 Module、Consumer、Monitor等 // 引用远程服务，注意：ReferenceConfig为重对象，内部封装了与注册中心的连接，以及与服务提供方的连接，请自行缓存，否则可能造成内存和连接泄漏 ReferenceConfig&lt;DemoService&gt; referenceConfig = new ReferenceConfig&lt;DemoService&gt;(); referenceConfig.setApplication(applicationConfig); referenceConfig.setRegistry(registryConfig); referenceConfig.setInterface(DemoService.class); // 获取代理对象 DemoService demoService = referenceConfig.get(); while (true) &#123; String ping = demoService.sayHello(\"ping\"); System.out.println(ping); Thread.sleep(3000); &#125; &#125;&#125; 小结使用API硬编码的方式简单、直观，无需关注其它细节（如不需要关心和Spring整合的细节），让使用者更容器理解dubbo的各个组件及其之间的联系，编写服务提供者与消费者更加容易。默认情况下dubbo框架只需要依赖Netty通信框架就可以实现RPC调用，注册中心也可以不需要，即只要有服务提供者、服务消费者 以及 架起消费者连接到提供者的通信桥梁即可实现一个完整的RPC调用。 虽然使用API的方式简单易懂，但是对于应用、服务的管理就需要很大的成本，对于每个应用、服务都需编写大量重复的代码，并且是硬编码，显然是不合理的。Spring本身的一大特性就是依赖管理，而我们这些API中的配置承载对象完全可以交给Spring来管理，这样就实现了配置化，虽然引入了Spring这个第三方框架，但是是非常合理的，毕竟Spring是主流。下一篇文章我们使用Spring的xml配置方式实现RPC调用。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"Spring自定义标签","slug":"rpc/Spring自定义标签","date":"2020-03-01T16:00:00.000Z","updated":"2020-09-03T01:33:46.285Z","comments":false,"path":"posts/eee3e639/","link":"","permalink":"https://gentryhuang.com/posts/eee3e639/","excerpt":"","text":"spring自定义标签Spring除了很多内置的xml标签外，还支持自定义xml标签，开发者只需要按照Spring的约定规则就可以实现自定义标签，这样开发者就可以把自定义的Bean交给Spring管理。自定义标签包结构如下： 自定义标签的规则编写模型1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.code.resource.reading.xml.schema.model;/** * Hero * * @author shunhua * @since 2020/03/02 * &lt;p&gt; * desc： */public class Hero &#123; /** * name */ private String name; /** * age */ private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Hero&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 定义模型的xsd文件12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xsd:schema xmlns=\"http://gentryhuang.site/schema/people\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" targetNamespace=\"http://gentryhuang.com/schema/people\"&gt; &lt;!-- 定义元素的复杂类型 --&gt; &lt;xsd:complexType name=\"elementComplexType\"&gt; &lt;!-- 定义模型类中的属性 --&gt; &lt;xsd:attribute name=\"name\" type=\"xsd:string\"&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;&lt;![CDATA[ The element name. ]]&gt;&lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;/xsd:attribute&gt; &lt;xsd:attribute name=\"age\" type=\"xsd:int\"&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;&lt;![CDATA[ The element age. ]]&gt;&lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;/xsd:attribute&gt; &lt;/xsd:complexType&gt; &lt;!-- 定义在xml文件中用到的元素名称 --&gt; &lt;xsd:element name=\"hero\" type=\"elementComplexType\"&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;&lt;![CDATA[ 定义标签 ]]&gt;&lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;/xsd:element&gt;&lt;/xsd:schema&gt; 说明: 该文件要放在 resources的META-INF目录下。该文件是用来约束使用xml配置时的标签和对应的属性。 编写spring.schemas文件1http\\:&#x2F;&#x2F;gentryhuang.com&#x2F;schema&#x2F;people&#x2F;hero.xsd&#x3D;META-INF&#x2F;hero.xsd 说明: http://gentryhuang.com/schema/people 就是模型对应的xsd中的targetNamespace的值，它指定了约束文件的具体路径。 编写BeanDefinitionParser12345678910111213141516171819202122232425262728293031323334353637383940414243package com.code.resource.reading.xml.schema;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.RootBeanDefinition;import org.springframework.beans.factory.xml.BeanDefinitionParser;import org.springframework.beans.factory.xml.ParserContext;import org.w3c.dom.Element;/** * HeroBeanDefinitionParser * * @author shunhua * @since 2020/03/02 * &lt;p&gt; * desc： */public class HeroBeanDefinitionParser implements BeanDefinitionParser &#123; /** * 标签对应的类 */ private final Class&lt;?&gt; beanClass; public HeroBeanDefinitionParser(Class&lt;?&gt; beanClass) &#123; this.beanClass = beanClass; &#125; @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; RootBeanDefinition beanDefinition = new RootBeanDefinition(); beanDefinition.setBeanClass(beanClass); beanDefinition.setLazyInit(false); beanDefinition.getPropertyValues().add(\"name\",element.getAttribute(\"name\")); beanDefinition.getPropertyValues().add(\"age\",element.getAttribute(\"age\")); // 获取Bean定义注册表 BeanDefinitionRegistry registry = parserContext.getRegistry(); // 注册Bean registry.registerBeanDefinition(\"hero\",beanDefinition); return beanDefinition; &#125;&#125; 说明: 用来解析自定义的xml标签 编写命名空间处理器123456789101112131415161718192021222324package com.code.resource.reading.xml.schema;import com.code.resource.reading.xml.schema.model.Hero;import org.springframework.beans.factory.xml.NamespaceHandlerSupport;/** * HeroNamespaceHandler * * @author shunhua * @since 2020/03/02 * &lt;p&gt; * desc： */public class HeroNamespaceHandler extends NamespaceHandlerSupport &#123; /** * 定义了&lt;xsd:element/&gt;对应的BeanDefinitionParser */ @Override public void init() &#123; registerBeanDefinitionParser(\"hero\",new HeroBeanDefinitionParser(Hero.class)); &#125;&#125; 说明:一般情况下 一个&lt;xsd:element/&gt; 对应一个BeanDefinitionParser 编写spring.handlers文件1http\\:&#x2F;&#x2F;gentryhuang.com&#x2F;schema&#x2F;people&#x3D;com.code.resource.reading.xml.schema.HeroNamespaceHandler 说明: 这是一个键值对，key是xsd文件中的 targetNamespace，该文件指明了使用哪个类来解析自定义的标签。 使用spring的自定义标签12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:people=\"http://gentryhuang.com/schema/people\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://gentryhuang.com/schema/people http://gentryhuang.com/schema/people/hero.xsd\"&gt; &lt;!-- 1 xmlns:people的值是xsd文件中的targetNamespace 2 xmlns:hero 可以写成xmlns:xxx,此时标签前缀也要是 &lt;xxx:hero/&gt; --&gt; &lt;people:hero name=\"hlb\" age=\"18\"/&gt;&lt;/beans&gt; 测试123456789101112131415161718192021package com.code.resource.reading.xml.schema;import com.code.resource.reading.xml.schema.model.Hero;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Client * * @author shunhua * @since 2020/03/02 * &lt;p&gt; * desc： */public class Client &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"hero.xml\"); Hero hero = (Hero) applicationContext.getBean(\"hero\"); System.out.println(hero); &#125;&#125; 小结spring在解析到自定义的namespace标签时，比如 &lt;people:hero /&gt;，会查找对应的spring.schemas和spring.handlers文件，通过spring.schemas文件确定需要加载的标签及属性，然后会触发spring.handlers文件中指定的类来进行初始化和解析。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"},{"name":"Spring","slug":"Spring","permalink":"https://gentryhuang.com/tags/Spring/"}]},{"title":"初识RPC","slug":"rpc/初识RPC","date":"2020-02-29T16:00:00.000Z","updated":"2020-09-06T03:59:50.707Z","comments":false,"path":"posts/626d9676/","link":"","permalink":"https://gentryhuang.com/posts/626d9676/","excerpt":"","text":"基本概念RPC（Remote Procedure Call）远程过程调用，简单来说就是一个节点请求另一个节点提供的服务，像本地方法调用一样调用远程的服务。详细说明：请求方没有服务实现的细节，执行目标行为还是服务提供的节点。请求服务的节点和服务提供的节点以某种方式进行通信，请求方把行为及行为参数传递给服务提供方，服务提供方会根据请求方传递的数据找到对应的服务实现然后执行目标行为，最后再把执行结果返回给请求方。 本地过程调用发起请求和响应结果都在同一个服务节点上，在Java中就是同一个JVM中的方法调用过程。 远程过程调用请求的发起者和请求的处理者不在同一个节点上，它们之间需要进行网络通信才能完成请求和响应。 简单RPC实现说明: 例子是使用梁飞大佬的 技术博客 中的案例 服务接口及实现12345678910111213141516171819202122232425262728293031package com.alibaba.study.rpc.service;/** * HelloService */public interface HelloService &#123; /** * 服务方法 * * @param name * @return */ String hello(String name);&#125;---package com.alibaba.study.rpc.service.impl;import com.alibaba.study.rpc.service.HelloService;/** * HelloServiceImpl */public class HelloServiceImpl implements HelloService &#123; @Override public String hello(String name) &#123; return \"Hello \" + name; &#125;&#125; RPC框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177package com.alibaba.study.rpc.framework;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.net.ServerSocket;import java.net.Socket;/** * RpcFramework */public class RpcFramework &#123; /** * 暴露服务 * * @param service 服务实现 * @param port 服务端口 * @throws Exception */ public static void export(final Object service, int port) throws Exception &#123; if (service == null) &#123; throw new IllegalArgumentException(\"service instance == null\"); &#125; if (port &lt;= 0 || port &gt; 65535) &#123; throw new IllegalArgumentException(\"Invalid port \" + port); &#125; System.out.println(\"Export service \" + service.getClass().getName() + \" on port \" + port); // 以指定端口创建ServerSocket ServerSocket server = new ServerSocket(port); for (; ; ) &#123; try &#123; // 等待接收请求 final Socket socket = server.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; try &#123; // 获取请求的数据流 ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); try &#123; // 获取客户端请求的方法名 String methodName = input.readUTF(); // 获取客户端请求的参数类型列表 Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject(); // 获取客户端请求的参数列表 Object[] arguments = (Object[]) input.readObject(); // 创建对象输出流对象，用于响应结果给客户端 ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); try &#123; // 通过反射，获取服务接口指定的方法 Method method = service.getClass().getMethod(methodName, parameterTypes); // 反射调用 Object result = method.invoke(service, arguments); // 将结果响应给客户端 output.writeObject(result); &#125; catch (Throwable t) &#123; output.writeObject(t); &#125; finally &#123; output.close(); &#125; &#125; finally &#123; input.close(); &#125; &#125; finally &#123; socket.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 引用服务 * * @param &lt;T&gt; 接口泛型 * @param interfaceClass 接口类型 * @param host 服务器主机名 * @param port 服务器端口 * @return 远程服务 * @throws Exception */ @SuppressWarnings(\"unchecked\") public static &lt;T&gt; T refer(final Class&lt;T&gt; interfaceClass, final String host, final int port) throws Exception &#123; if (interfaceClass == null) &#123; throw new IllegalArgumentException(\"Interface class == null\"); &#125; if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException(\"The \" + interfaceClass.getName() + \" must be interface class!\"); &#125; if (host == null || host.length() == 0) &#123; throw new IllegalArgumentException(\"Host == null!\"); &#125; if (port &lt;= 0 || port &gt; 65535) &#123; throw new IllegalArgumentException(\"Invalid port \" + port); &#125; System.out.println(\"Get remote service \" + interfaceClass.getName() + \" from server \" + host + \":\" + port); /** * 使用JDK的动态代理创建接口的代理对象 * 说明： * 在 InvocationHandler#invoke方法内部实现Socket与ServerSocket的通信。当使用代理对象调用方法时，内部使用Socket进行通信，然后把通信的结果返回。 */ return (T) Proxy.newProxyInstance( interfaceClass.getClassLoader(), new Class&lt;?&gt;[]&#123;interfaceClass&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable &#123; // 创建Socket，用于连接ServerSocket Socket socket = new Socket(host, port); try &#123; // 创建用于发送数据到ServerSocket的输出流 ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); try &#123; //--------------------- 数据契约 ----------------------------/ // 方法名 output.writeUTF(method.getName()); // 参数类型 output.writeObject(method.getParameterTypes()); // 参数值 output.writeObject(arguments); //------------------------ 数据契约 --------------------------/ // 创建用于接收ServerSocket的输入流 ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); try &#123; // 读取ServerSocket响应的数据 Object result = input.readObject(); if (result instanceof Throwable) &#123; throw (Throwable) result; &#125; // 返回结果 return result; &#125; finally &#123; input.close(); &#125; &#125; finally &#123; output.close(); &#125; &#125; finally &#123; socket.close(); &#125; &#125; &#125;); &#125;&#125; 服务暴露1234567891011121314151617package com.alibaba.study.rpc.provider;import com.alibaba.study.rpc.framework.RpcFramework;import com.alibaba.study.rpc.service.HelloService;import com.alibaba.study.rpc.service.impl.HelloServiceImpl;/** * RpcProvider */public class RpcProvider &#123; public static void main(String[] args) throws Exception &#123; // 服务实现 HelloService service = new HelloServiceImpl(); // 暴露服务 RpcFramework.export(service, 1234); &#125;&#125; 引用服务1234567891011121314151617181920package com.alibaba.study.rpc.consumer;import com.alibaba.study.rpc.framework.RpcFramework;import com.alibaba.study.rpc.service.HelloService;/** * RpcConsumer */public class RpcConsumer &#123; public static void main(String[] args) throws Exception &#123; // 引用服务【代理对象】 HelloService service = RpcFramework.refer(HelloService.class, \"127.0.0.1\", 1234); while (true) &#123; String hello = service.hello(\"World\"); System.out.println(hello); Thread.sleep(1000); &#125; &#125;&#125; 小结这个例子中，通信是使用同步阻塞的Socket来实现的，采用端对端的方式。远程调用使用的是JDK的动态代理，在invoke方法中实现网络通信。参数序列化使用的是JDK的ObjectStream。一个完善的RPC框架其实就是在这例子的基础上进行多方位扩展和改进。比如，网络通信可以使用性能更好的NIO框架Netty，动态代理可以使用javaassist字节码生成方式[注意：不是javaassist提供的动态代理接口，该接口比JDK自带的还慢]，序列化方式可以采用fastjson、hession2以及kryo等技术。如果服务数量达到一定规模，可以引进注册中心进行服务的治理。节点间的通信方式可以有多种，因此可以扩展多协议。除此之外，性能和健壮性也是一个优秀的RPC框架所必须的，如集群容错、负载均衡、重试机制、服务降级…这些都会在后面分析的Dubbo框架中得到很好的体现。","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"命令模式","slug":"design_pattern/behaviour_type/命令模式","date":"2019-10-04T16:00:00.000Z","updated":"2020-08-09T09:26:57.923Z","comments":true,"path":"posts/78134e07/","link":"","permalink":"https://gentryhuang.com/posts/78134e07/","excerpt":"","text":"定义命令模式又叫指令模式，是将“请求”封装成对象，以便使用不同的请求。我们可以把不同的请求封装成不同请求对象，对于接收者来说这些类型都能识别，然后根据不同的请求对象执行不同的行为。 说明命令模式解决了应用程序中对象的职责以及它们之间的通信方式，命令模式可以使命令发送者和接收者完全解耦，发送者和接收者之间没有直接的引用关系。发送命令的对象只知道如何下命令，不需要知道如何完成命令。 类型行为型 使用场景121. 请求调用者和请求接收者需要解耦，使得调用者和接收者不直接交互2. 需要抽象出等待执行的行为 优点1231. 降低耦合 - 通过命令模式把请求的发送者和请求的接收者进行解耦2. 容易扩展新命令或者一组命令 缺点12命令的无限扩展会增加类的数量，提高系统实现复杂度 - 针对每一个命令我们都要设计并开发一个具体的命令类 相关的设计模式命令模式和备忘录模式 1可以把两者结合使用，使用备忘录模式保存命令的历史记录，这样可以调用之前的命令 简单需求一创业公司为了抢占市场，老板对开发部前后下达了两个命令，先使用单例架构快速开发出产品，等到抢占了市场后再扩大规模把单体结构拆成微服务架构。 命令模式演练 把命令抽象成对象，这是命令模式实现的核心 1命令扩展很容易，增加命令只需封装一个命令类。如果有命令行为体根据情况修改命令行为体。 命令行为体 1每个命令执行的具体行为在行为体中，但不是必须的，也可以不要行为体，让命令执行变得更灵活。 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.command;import lombok.extern.slf4j.Slf4j;/** * Project 项目 * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class Project &#123; /** * 项目名称 */ private String name; public Project(String name)&#123; this.name = name; &#125; /** * 使用单体架构开发项目 */ public void monomer()&#123; log.info(String.format(\"%s项目使用单体架构开发\",this.name)); &#125; /** * 使用微服务架构开发项目 */ public void microservice()&#123; log.info(String.format(\"%s项目使用微服务架构开发\",this.name)); &#125;&#125; 命令接口 1234567891011121314package com.design.pattern.command;/** * Command 命令接口 * * @author shunhua * @date 2019-10-04 */public interface Command &#123; /** * 执行命令 */ void execute();&#125; 单体架构开发命令 123456789101112131415161718192021222324252627282930package com.design.pattern.command;/** * MonomerCommand 单体架构开发命令类，执行的是单体架构开发 * * @author shunhua * @date 2019-10-04 */public class MonomerCommand implements Command &#123; /** * 组合，命令对应的行为体 (非必须的，命令的行为可以根据具体业务编写) */ private Project project; /** * 构造方法 * @param project */ public MonomerCommand(Project project)&#123; this.project = project; &#125; /** * 执行命令 */ @Override public void execute() &#123; project.monomer(); &#125;&#125; 微服务架构开发命令 12345678910111213141516171819202122232425262728293031package com.design.pattern.command;/** * MicroserviceCommand 微服务架构开发命令类，执行的是微服务架构开发 * * @author shunhua * @date 2019-10-04 */public class MicroserviceCommand implements Command &#123; /** * 组合，命令对应的行为体 (非必须的，命令的行为可以根据具体业务编写) */ private Project project; /** * 构造方法 * @param project */ public MicroserviceCommand(Project project)&#123; this.project = project; &#125; /** * 执行命令 */ @Override public void execute() &#123; project.microservice(); &#125;&#125; 命令接收者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.design.pattern.command;import java.util.ArrayList;import java.util.List;/** * Staff 命令执行者 * * @author shunhua * @date 2019-10-04 */public class Staff &#123; /** * 命令集合，可以接收多个命令 */ private List&lt;Command&gt; commands = new ArrayList&lt;&gt;(); /** * 接收命令 * @param command */ public void addCommand(Command command)&#123; commands.add(command); &#125; /** * 移除命令 * @param command */ public void removeCommand(Command command)&#123; commands.remove(command); &#125; /** * 执行指定的名 * @param command */ public void execureCommand(Command command)&#123; command.execute(); &#125; /** * 执行命令集 */ public void executeCommandList()&#123; this.commands.stream().forEach(Command::execute); commands.clear(); &#125;&#125; 应用层 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.command;import org.junit.Test;/** * Boss 命令的下达者 * * @author shunhua * @date 2019-10-04 */public class Boss &#123; @Test public void test() throws InterruptedException &#123; // 创建命令的行为体 Project projectDevelopment = new Project(\"带你飞\"); // 创建命令对象(老板下达命令) MicroserviceCommand microserviceCommand = new MicroserviceCommand(projectDevelopment); MonomerCommand monomerCommand = new MonomerCommand(projectDevelopment); System.out.println(\"//-----------------------分别执行命令---------------------------/\"); // 员工接收并执行命令 Staff staff = new Staff(); staff.execureCommand(microserviceCommand); staff.execureCommand(monomerCommand); Thread.sleep(2000); System.out.println(\"//-----------------------统一执行命令集-------------------------/\"); // 员工接收多个命令,统一执行 staff.addCommand(microserviceCommand); staff.addCommand(monomerCommand); staff.executeCommandList(); &#125;&#125; 命令模式在源码中的使用Runnable接口的实现类 1Runnable可以看成一个抽象的命令，它的实现可以理解为具体的命令实现","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"状态模式","slug":"design_pattern/behaviour_type/状态模式","date":"2019-10-04T16:00:00.000Z","updated":"2020-08-09T09:28:21.142Z","comments":true,"path":"posts/8acb1976/","link":"","permalink":"https://gentryhuang.com/posts/8acb1976/","excerpt":"","text":"定义允许一个对象在其内部状态改变时，改变它的行为，如果行为不需要改变就不要改变。一般这个存在多个状态的对象是一个“上下文”。 类型行为型 使用场景1一个对象存在多个状态（不同状态下行为不同），且状态可相互转换 优点12341. 将不同的状态隔离 - 每个状态都是一个类2. 把各种状态的转换逻辑分布到State的子类中，减少相互间依赖 3. 增加新的状态非常简单（也就增加一个状态类，如果还要满足相互转换，其他已有的状态内部也需要修改） 缺点1状态多的业务场景导致类数目增加，系统变得复杂 相关的设计模式状态模式和享元模式 1它们有时可以配合使用 简单需求播放视频的时候，有播放状态、快进播放状态、暂停状态以及停止状态，这些状态大都可以相互转换。当状态发生改变时对应的播放行为也发生了改变。 状态父类 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.state;import lombok.Setter;/** * VideoState 视频状态 * * @author shunhua * @date 2019-10-05 */@Setterpublic abstract class VideoState &#123; /** * 视频资源上下文 */ protected VideoContext videoContext; /** * 播放 */ public abstract void play(); /** * 快进 */ public abstract void speed(); /** * 暂停 */ public abstract void pause(); /** * 停止 */ public abstract void stop(); &#125; 播放状态类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;/** * PlayState 视频播放状态 * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class PlayState extends VideoState &#123; @Override public void play() &#123; log.info(\"视频正常播放状态\"); &#125; /** * 可切换快进 */ @Override public void speed() &#123; super.videoContext.setVideoState(VideoContext.SPEED_STATE); &#125; /** * 可切换暂停 */ @Override public void pause() &#123; super.videoContext.setVideoState(VideoContext.PAUSE_STATE); &#125; /** * 可切换停止 */ @Override public void stop() &#123; super.videoContext.setVideoState(VideoContext.STOP_STATE); &#125;&#125; 暂停播放状态类 123456789101112131415161718192021222324252627282930313233package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;/** * PauseState 视频暂停状态 * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class PauseState extends VideoState &#123; @Override public void play() &#123; super.videoContext.setVideoState(VideoContext.PLAY_STATE); &#125; @Override public void speed() &#123; super.videoContext.setVideoState(VideoContext.SPEED_STATE); &#125; @Override public void pause() &#123; log.info(\"视频暂停播放状态\"); &#125; @Override public void stop() &#123; super.videoContext.setVideoState(VideoContext.STOP_STATE); &#125;&#125; 快进播放状态类 123456789101112131415161718192021222324252627282930313233package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;/** * SpeedState 视频加速状态 * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class SpeedState extends VideoState &#123; @Override public void play() &#123; super.videoContext.setVideoState(VideoContext.PLAY_STATE); &#125; @Override public void speed() &#123; log.info(\"视频快进播放状态\"); &#125; @Override public void pause() &#123; super.videoContext.setVideoState(VideoContext.PAUSE_STATE); &#125; @Override public void stop() &#123; super.videoContext.setVideoState(VideoContext.STOP_STATE); &#125;&#125; 停止状态类 123456789101112131415161718192021222324252627282930313233package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;/** * StopState 视频停止状态 * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class StopState extends VideoState &#123; @Override public void play() &#123; super.videoContext.setVideoState(VideoContext.PLAY_STATE); &#125; @Override public void speed() &#123; log.info(\"停止状态不能快进\"); &#125; @Override public void pause() &#123; log.info(\"停止状态不能暂停\"); &#125; @Override public void stop() &#123; log.info(\"视频停止播放状态\"); &#125;&#125; 状态对应的上下文 123456789101112131415161718192021222324252627282930313233package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class Client &#123; @Test public void test()&#123; // 声明一个上下文 VideoContext videoContext = new VideoContext(); videoContext.setVideoState(new PlayState()); log.info(\"当前状态：\" + videoContext.getVideoState().getClass().getSimpleName()); videoContext.pause(); log.info(\"当前状态：\" + videoContext.getVideoState().getClass().getSimpleName()); videoContext.speed(); log.info(\"当前状态：\" + videoContext.getVideoState().getClass().getSimpleName()); videoContext.stop(); log.info(\"当前状态：\" + videoContext.getVideoState().getClass().getSimpleName()); &#125;&#125; 状态模式在源码中的使用 状态模式和业务场景更紧密相关，比如电商中订单的状态、根据业务设置状态机、办公系统流程的状态等，源码中相对很少使用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"访问者模式","slug":"design_pattern/behaviour_type/访问者模式","date":"2019-10-04T16:00:00.000Z","updated":"2020-08-09T09:30:13.914Z","comments":true,"path":"posts/64b51ed9/","link":"","permalink":"https://gentryhuang.com/posts/64b51ed9/","excerpt":"","text":"定义封装作用于某数据结构(如List/Set/Map等)中的各元素的操作。可以在不改变各元素的类的前提下，定义作用于这些元素的操作。即当访问某个资源时，不去修改资源本身而是定义访问资源的操作 类型行为型 使用场景121. 一个数据结构如（List&#x2F;Set&#x2F;Map等）包含很多类型对象2. 数据结构于数据操作分离 优点1增加新的操作很容易，即增加一个新的访问者 缺点1231. 增加新的数据结构困难，需要修改的地方比较多2. 具体元素变更比较麻烦 - 增加或者删除元素里面的属性都算变更 相关的设计模式访问者模式和迭代器模式 121. 它们都是在某种数据结构上进行处理2. 访问者模式主要对保存在数据结构中的元素进行某种特定的处理，迭代器用于逐个遍历保存在数据结构中的一些元素 简单需求网络课程有免费的也有付费的，免费的课程普通用户都可以访问，付费的课程需要购买称为Vip用户才能访问。相同的资源不同的用户身份，访问的结果不同 访问者模式演练 当访问某个资源时，不去修改资源本身而是定义访问资源的操作。相同的资源不同的访问身份，产生不同的操作行为 抽象课程资源 12345678910111213141516171819202122232425262728package com.design.pattern.visitor;import lombok.Getter;import lombok.Setter;/** * Course 被访问的资源 * * 不改变Course,而是定义访问Course的操作，这里体现在IVisitor的方法上 * * @author shunhua * @date 2019-10-05 */@Getter@Setterpublic abstract class Course &#123; /** * 课程名称 */ private String name; /** * 接受访问 把访问者传入 * @param visitor */ public abstract void accept(IVisitor visitor); &#125; 免费课程资源 12345678910111213141516171819package com.design.pattern.visitor;/** * FreeCourse * * @author shunhua * @date 2019-10-05 */public class FreeCourse extends Course &#123; /** * 接受访问 * @param visitor */ @Override public void accept(IVisitor visitor) &#123; visitor.visit(this); &#125;&#125; 付费课程资源 12345678910111213141516171819202122232425262728package com.design.pattern.visitor;import lombok.Getter;import lombok.Setter;/** * PayCourse * * @author shunhua * @date 2019-10-05 */@Getter@Setterpublic class PayCourse extends Course &#123; /** * 价格 */ private int price; /** * 接受访问 * @param visitor */ @Override public void accept(IVisitor visitor) &#123; visitor.visit(this); &#125;&#125; 访问者抽象 12345678910111213141516171819202122232425package com.design.pattern.visitor;/** * IVisitor 访问接口 * * 这里定义了访问资源的操作，具体的访问细节体现在实现类中，不同的实现类对相同的资源产生不同的操作行为，这是访问者的核心 * * @author shunhua * @date 2019-10-05 */public interface IVisitor &#123; /** * 访问免费课程 * @param freeCourse */ void visit(FreeCourse freeCourse); /** * 访问付费课程 * @param payCourse */ void visit(PayCourse payCourse);&#125; 普通访问者 12345678910111213141516171819202122232425262728293031package com.design.pattern.visitor;import lombok.extern.slf4j.Slf4j;/** * GeneralVisitor 普通访问者 * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class GeneralVisitor implements IVisitor &#123; /** * 访问免费课程 * @param freeCourse */ @Override public void visit(FreeCourse freeCourse) &#123; log.info(\"免费课程名：\" + freeCourse.getName()); &#125; /** * 访问付费课程 * @param payCourse */ @Override public void visit(PayCourse payCourse) &#123; log.info(\"这是付费课程，你还没有购买，没有访问权限\"); &#125;&#125; Vip访问者 12345678910111213141516171819202122232425262728293031package com.design.pattern.visitor;import lombok.extern.slf4j.Slf4j;/** * VipVisitor Vip访问者 * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class VipVisitor implements IVisitor&#123; /** * 访问免费课程 * @param freeCourse */ @Override public void visit(FreeCourse freeCourse) &#123; log.info(\"免费课程名：\" + freeCourse.getName()); &#125; /** * 访问付费课程 * @param payCourse */ @Override public void visit(PayCourse payCourse) &#123; log.info(\"付费课程名：\" + payCourse.getName() + \" 价格为：\" + payCourse.getPrice()); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.design.pattern.visitor;import org.junit.Test;import java.util.ArrayList;import java.util.List;/** * Client * * @author shunhua * @date 2019-10-05 */public class Client &#123; @Test public void test()&#123; List&lt;Course&gt; courseList = new ArrayList&lt;&gt;(); FreeCourse freeCourse = new FreeCourse(); freeCourse.setName(\"这是一个免费的课程\"); PayCourse payCourse = new PayCourse(); payCourse.setName(\"这是一个付费的课程\"); payCourse.setPrice(300); courseList.add(freeCourse); courseList.add(payCourse); // 普通访问者 GeneralVisitor generalVisitor = new GeneralVisitor(); // Vip用户 VipVisitor vipVisitor = new VipVisitor(); System.out.println(\"//----------普通访问者----------------/\"); courseList.stream().forEach(course -&gt; &#123; course.accept(generalVisitor); &#125;); System.out.println(\"//----------vip用户------------------/\"); courseList.stream().forEach(course -&gt; &#123; course.accept(vipVisitor); &#125;); &#125;&#125; 访问者模式在源码中的使用FileVisitor 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package java.nio.file;import java.nio.file.attribute.BasicFileAttributes;import java.io.IOException;import java.util.Objects;/** * 资源是文件 * * @since 1.7 */public class SimpleFileVisitor&lt;T&gt; implements FileVisitor&lt;T&gt; &#123; /** * Initializes a new instance of this class. */ protected SimpleFileVisitor() &#123; &#125; /** * Invoked for a directory before entries in the directory are visited. * * &lt;p&gt; Unless overridden, this method returns &#123;@link FileVisitResult#CONTINUE * CONTINUE&#125;. */ @Override public FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException &#123; Objects.requireNonNull(dir); Objects.requireNonNull(attrs); return FileVisitResult.CONTINUE; &#125; /** * Invoked for a file in a directory. * * &lt;p&gt; Unless overridden, this method returns &#123;@link FileVisitResult#CONTINUE * CONTINUE&#125;. */ @Override public FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException &#123; Objects.requireNonNull(file); Objects.requireNonNull(attrs); return FileVisitResult.CONTINUE; &#125; /** * Invoked for a file that could not be visited. * * &lt;p&gt; Unless overridden, this method re-throws the I/O exception that prevented * the file from being visited. */ @Override public FileVisitResult visitFileFailed(T file, IOException exc) throws IOException &#123; Objects.requireNonNull(file); throw exc; &#125; /** * Invoked for a directory after entries in the directory, and all of their * descendants, have been visited. * * &lt;p&gt; Unless overridden, this method returns &#123;@link FileVisitResult#CONTINUE * CONTINUE&#125; if the directory iteration completes without an I/O exception; * otherwise this method re-throws the I/O exception that caused the iteration * of the directory to terminate prematurely. */ @Override public FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException &#123; Objects.requireNonNull(dir); if (exc != null) throw exc; return FileVisitResult.CONTINUE; &#125;&#125; BeanDefinitionVisitor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package org.springframework.beans.factory.config;import java.util.LinkedHashMap;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Set;import org.springframework.beans.MutablePropertyValues;import org.springframework.beans.PropertyValue;import org.springframework.lang.Nullable;import org.springframework.util.Assert;import org.springframework.util.ObjectUtils;import org.springframework.util.StringValueResolver;/** * 资源：Bean的定义 * * @author Juergen Hoeller * @author Sam Brannen * @since 1.2 * @see BeanDefinition * @see BeanDefinition#getPropertyValues * @see BeanDefinition#getConstructorArgumentValues * @see PropertyPlaceholderConfigurer */public class BeanDefinitionVisitor &#123; @Nullable private StringValueResolver valueResolver; /** * Create a new BeanDefinitionVisitor, applying the specified * value resolver to all bean metadata values. * @param valueResolver the StringValueResolver to apply */ public BeanDefinitionVisitor(StringValueResolver valueResolver) &#123; Assert.notNull(valueResolver, \"StringValueResolver must not be null\"); this.valueResolver = valueResolver; &#125; /** * Create a new BeanDefinitionVisitor for subclassing. * Subclasses need to override the &#123;@link #resolveStringValue&#125; method. */ protected BeanDefinitionVisitor() &#123; &#125; /** * Traverse the given BeanDefinition object and the MutablePropertyValues * and ConstructorArgumentValues contained in them. * @param beanDefinition the BeanDefinition object to traverse * @see #resolveStringValue(String) */ public void visitBeanDefinition(BeanDefinition beanDefinition) &#123; visitParentName(beanDefinition); visitBeanClassName(beanDefinition); visitFactoryBeanName(beanDefinition); visitFactoryMethodName(beanDefinition); visitScope(beanDefinition); if (beanDefinition.hasPropertyValues()) &#123; visitPropertyValues(beanDefinition.getPropertyValues()); &#125; if (beanDefinition.hasConstructorArgumentValues()) &#123; ConstructorArgumentValues cas = beanDefinition.getConstructorArgumentValues(); visitIndexedArgumentValues(cas.getIndexedArgumentValues()); visitGenericArgumentValues(cas.getGenericArgumentValues()); &#125; &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"中介者模式","slug":"design_pattern/behaviour_type/中介者模式","date":"2019-10-03T16:00:00.000Z","updated":"2020-08-09T09:26:26.731Z","comments":true,"path":"posts/d036071c/","link":"","permalink":"https://gentryhuang.com/posts/d036071c/","excerpt":"","text":"定义定义了一个封装一组对象如何交互的对象（这个对象用来协调这一组对象（“同事类”））。通过使对象明确地相互引用来促进松散耦合，并允许独立地改变它们的交互。 类型行为型 适用场景121. 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱难以理解，使用中介者进行协调2. 交互的公共行为，如果需要改变行为则可以增加新的中介者类 优点121. 将一对多转化成了一对一、降低程序复杂度2. 类之间的解耦 缺点1中介者过多，导致系统复杂 相关的设计模式中介者模式和观察者模式 1两者有时结合使用，使用观察者模式实现中介者模式中角色间的通信 简单需求公司的员工之间发送公有消息，使用工作群统一发送，不需要发送者逐一发给其他员工 中介者模式演练 中介者 12345678910111213141516171819202122232425package com.design.pattern.mediator;import lombok.extern.slf4j.Slf4j;import java.util.Date;/** * WorkGroup 中介者 - 工作群 * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class WorkGroup &#123; /** * 中介者显示员工发送的消息 * @param worker * @param msg */ public static void showMsg(Worker worker, String msg)&#123; log.info(String.format(\"%s 【%s】: %s\",new Date().toString(),worker.getName(),msg)); &#125;&#125; 参与交互的对象类 123456789101112131415161718192021222324252627package com.design.pattern.mediator;import lombok.AllArgsConstructor;import lombok.Data;/** * Worker 员工 通常称为“同事类” * * @author shunhua * @date 2019-10-04 */@Data@AllArgsConstructorpublic class Worker &#123; /** * 花名 */ private String name; /** * 员工只和中介者（工作群）打交道，这是中介者模式的核心 * @param msg */ public void sendMsg(String msg)&#123; WorkGroup.showMsg(this,msg); &#125;&#125; 应用层 12345678910111213141516171819202122232425package com.design.pattern.mediator;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-04 */public class Client &#123; @Test public void test()&#123; Worker worker = new Worker(\"舜华\"); Worker worker1= new Worker(\"高斯林\"); worker1.sendMsg(\"小伙子，就你还想学我的Java！！！\"); worker.sendMsg(\"有句话不知当讲不当讲？\"); &#125;&#125; 中介者模式在源码中的使用Timer 1Timer是一个中介者，它协调TimerTask任务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package java.util;import java.util.Date;import java.util.concurrent.atomic.AtomicInteger;public class Timer &#123; /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they're obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); /** * Timer中有多个schedule重载方法，里面都调用了sched方法 */ public void schedule(TimerTask task, long delay) &#123; if (delay &lt; 0) throw new IllegalArgumentException(\"Negative delay.\"); sched(task, System.currentTimeMillis()+delay, 0); &#125; /** * * Timer是一个中介者，通过sched方法统一协调TimerTask * * @param task 被协调的对象 * @param time * @param period */ private void sched(TimerTask task, long time, long period) &#123; if (time &lt; 0) throw new IllegalArgumentException(\"Illegal execution time.\"); // Constrain value of period sufficiently to prevent numeric // overflow while still being effectively infinitely large. if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1)) period &gt;&gt;= 1; synchronized(queue) &#123; if (!thread.newTasksMayBeScheduled) throw new IllegalStateException(\"Timer already cancelled.\"); synchronized(task.lock) &#123; if (task.state != TimerTask.VIRGIN) throw new IllegalStateException( \"Task already scheduled or cancelled\"); task.nextExecutionTime = time; task.period = period; task.state = TimerTask.SCHEDULED; &#125; queue.add(task); if (queue.getMin() == task) queue.notify(); &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"备忘录模式","slug":"design_pattern/behaviour_type/备忘录模式","date":"2019-10-03T16:00:00.000Z","updated":"2020-08-09T09:27:24.516Z","comments":true,"path":"posts/c3176455/","link":"","permalink":"https://gentryhuang.com/posts/c3176455/","excerpt":"","text":"定义保存一个对象的某个状态，以便在适当的时候恢复对象。这里的状态可以理解为对象的一个快照。 类型行为型 适用场景121 保存及恢复数据相关业务场景2 后悔的时候，即想恢复到之前的状态 优点121 为用户提供一种可恢复机制2 存档信息的封装 缺点12资源占用 - 如果暂存的对象比较多，而且对象的属性也比较多，那么肯定会对资源造成一定的消耗，占用大量的资源。 相关的设计模式备忘录模式和状态模式 1备忘录模式中是用实例来表示状态的，我们存档的是一个对象实例。状态模式中是使用类来表示状态。 简单需求在写文档时，间断性地保存，然后可以撤销回退到上一个版本 备忘录模式演练 文章 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.design.pattern.memento;import lombok.AllArgsConstructor;import lombok.Data;import java.io.Serializable;/** * Article 文章 * * @author shunhua * @date 2019-10-04 */@Data@AllArgsConstructorpublic class Article implements Serializable &#123; private static final long serialVersionUID = -321234774998152556L; /** * 文章标题 */ private String title; /** * 文章内容 */ private String content; /** * 图片 */ private String img; /** * 把文章保存起来 * @return */ public ArticleMemento saveToMemento()&#123; ArticleMemento articleMemento = new ArticleMemento(this.title,this.content,this.img); return articleMemento; &#125; /** * 把保存的文章标题、内容以及图片回退回来 * @param articleMemento */ public void undoFromMemento(ArticleMemento articleMemento)&#123; this.title = articleMemento.getTitle(); this.content = articleMemento.getContent(); this.img = articleMemento.getImg(); &#125;&#125; 文章快照 123456789101112131415161718192021222324252627282930package com.design.pattern.memento;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.ToString;/** * ArticleMemento 文章快照,对于快照不需要Setter方法，只用于保存 * * @author shunhua * @date 2019-10-04 */@Getter@ToString@AllArgsConstructorpublic class ArticleMemento &#123; /** * 标题 */ private String title; /** * 内容 */ private String content; /** * 图片 */ private String img;&#125; 文章快照暂存管理 12345678910111213141516171819202122232425262728293031323334package com.design.pattern.memento;import java.util.Stack;/** * ArticleMementoManager 文章快照管理者 * * @author shunhua * @date 2019-10-04 */public class ArticleMementoManager &#123; /** * 保存 文章快照 的栈，在回退的时候回退的是最新的状态 */ private final Stack&lt;ArticleMemento&gt; ARTICLE_MEMENTO_STACK = new Stack&lt;&gt;(); /** * 获取文章快照 * @return */ public ArticleMemento getMemento()&#123; ArticleMemento articleMemento = ARTICLE_MEMENTO_STACK.pop(); return articleMemento; &#125; /** * 把文章保存为快照 * @param articleMemento */ public void addMemento(ArticleMemento articleMemento)&#123; ARTICLE_MEMENTO_STACK.push(articleMemento); &#125;&#125; 备忘录模式在源码中的使用spring-webflow中的使用 123456789101112131415161718192021222324252627282930313233343536373839package org.springframework.binding.message;import java.io.Serializable;import org.springframework.context.MessageSource;/** * A message context whose internal state can be managed by an external care-taker. State management employs the GOF * Memento pattern. This context can produce a serializable memento representing its internal state at any time. A * care-taker can then use that memento at a later time to restore any context instance to a previous state. * * @author Keith Donald */public interface StateManageableMessageContext extends MessageContext &#123; /** * 存档 * Create a serializable memento, or token representing a snapshot of the internal state of this message context. * @return the messages memento */ Serializable createMessagesMemento(); /** * 回退 * Set the state of this context from the memento provided. After this call, the messages in this context will match * what is encapsulated inside the memento. Any previous state will be overridden. * @param messagesMemento the messages memento */ void restoreMessages(Serializable messagesMemento); /** * Configure the message source used to resolve messages added to this context. May be set at any time to change how * coded messages are resolved. * @param messageSource the message source * @see MessageContext#addMessage(MessageResolver) */ void setMessageSource(MessageSource messageSource);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"责任链模式","slug":"design_pattern/behaviour_type/责任链模式","date":"2019-10-03T16:00:00.000Z","updated":"2020-08-09T09:30:40.577Z","comments":true,"path":"posts/6208627e/","link":"","permalink":"https://gentryhuang.com/posts/6208627e/","excerpt":"","text":"定义责任链模式又叫职责链模式。为请求创建一个接收此次请求的对象的链，这个链条由多个对象组成。 类型行为型 适用场景1一个请求的处理需要链中一个或多个协作处理 优点1231.请求的发送者和接收者（请求的处理者）解耦 2.责任链可以动态组合3.责任链方便扩展和收缩（增加或减少处理对象） 缺点121. 责任链太长或者处理时间过长会影响性能2. 责任链有可能过多 相关的设计模式责任链模式和状态模式 1责任链模式中各个对象不会指定下一个处理对象是谁，只有在客户端设定链条中的顺序以及元素直到被某个元素处理或整条链结束。状态模式是让每个状态对象知道自己下一个处理的对象是谁，在编译时就设定好了。 简单需求在注册网站的时候，我们需要提供用户名、邮箱以及密码，网站会有一个校验流程，分别对用户名、邮箱以及密码进行校验，如果任何一个步骤没有通过就不能注册，只有全部校验通过才能完成注册。 责任链模式演练 责任链的构建是由客户端决定的，责任链的入口也是客户端决定的 待处理的对象 12345678910111213141516171819202122232425262728package com.design.pattern.chain;import lombok.AllArgsConstructor;import lombok.Data;/** * User 待校验的用户 * * @author shunhua * @date 2019-10-04 */@Data@AllArgsConstructorpublic class User &#123; /** * 用户名 */ private String name; /** * 邮箱 */ private String email; /** * 密码 */ private String password;&#125; 处理器父类 1234567891011121314151617181920212223242526272829303132package com.design.pattern.chain;/** * Handler 责任链模式的核心 * * 注意：构造责任链是客户端的任务,并且入口也是客户单选择的 * * @author shunhua * @date 2019-10-04 */public abstract class Handler &#123; /** * 一个自己类型的对象，一般是子类对象 */ protected Handler handler; /** * 设置下一个处理器 * @param handler */ public void setNextHandler(Handler handler)&#123; this.handler = handler; &#125; /** * 交给子类实现，用来校验用户信息是否符合 * @param user */ protected abstract void handle(User user);&#125; 名称处理器 1234567891011121314151617181920212223242526272829303132333435package com.design.pattern.chain;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.util.ObjectUtils;/** * NameHandler 用户名处理器 * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class NameHandler extends Handler &#123; /** * 校验用户名 * @param user */ @Override protected void handle(User user) &#123; if(StringUtils.isNotBlank(user.getName()))&#123; log.info(\"用户名符合要求\"); // 如果有下一个校验器就继续执行，注意这个链的顺序是由客户端决定的 if(!ObjectUtils.isEmpty(super.handler))&#123; super.handler.handle(user); return; &#125;else &#123; log.info(\"完成注册\"); &#125; return; &#125; log.info(\"用户名校验不通过，结束校验\"); &#125;&#125; 邮箱处理器 123456789101112131415161718192021222324252627282930package com.design.pattern.chain;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.util.ObjectUtils;/** * EmailHandler 邮箱校验器 * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class EmailHandler extends Handler&#123; @Override protected void handle(User user) &#123; if(StringUtils.isNotBlank(user.getEmail()))&#123; log.info(\"邮箱符合要求\"); if(!ObjectUtils.isEmpty(super.handler))&#123; super.handler.handle(user); return; &#125;else &#123; log.info(\"完成注册\"); &#125; return; &#125; log.info(\"邮箱验证不通过，验证结束\"); &#125;&#125; 密码处理器 123456789101112131415161718192021222324252627282930package com.design.pattern.chain;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.util.ObjectUtils;/** * PasswordHandler 密码验证器 * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class PasswordHandler extends Handler &#123; @Override protected void handle(User user) &#123; if(StringUtils.isNotBlank(user.getPassword()) &amp;&amp; user.getPassword().length() &gt;5)&#123; log.info(\"密码符合要求\"); if(!ObjectUtils.isEmpty(super.handler))&#123; super.handler.handle(user); return; &#125;else &#123; log.info(\"完成注册\"); &#125; return; &#125; log.info(\"密码验证不通过，验证结束\"); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031323334353637package com.design.pattern.chain;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-04 */public class Client &#123; @Test public void test()&#123; // 创建待验证的用户 User user = new User(\"shunhua\",\"gentryhuang.xw@gmail.com\",\"123456\"); // 姓名验证器 NameHandler nameHandler = new NameHandler(); // 邮箱验证器 EmailHandler emailHandler = new EmailHandler(); // 密码验证器 PasswordHandler passwordHandler = new PasswordHandler(); /** * 注意：构造责任链是客户端决定的 * * 构建责任链 : NameHandler -&gt; EmailHandler -&gt; PasswordHandler */ nameHandler.setNextHandler(emailHandler); emailHandler.setNextHandler(passwordHandler); /** * 处理请求入口 */ nameHandler.handle(user); &#125;&#125; 责任链在源码中的使用过滤器-Filter 123456789101112131415161718192021222324252627282930313233// 以OncePerRequestFilter为例public abstract class OncePerRequestFilter extends GenericFilterBean &#123; public static final String ALREADY_FILTERED_SUFFIX = \".FILTERED\"; public OncePerRequestFilter() &#123; &#125; public final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (request instanceof HttpServletRequest &amp;&amp; response instanceof HttpServletResponse) &#123; HttpServletRequest httpRequest = (HttpServletRequest)request; HttpServletResponse httpResponse = (HttpServletResponse)response; String alreadyFilteredAttributeName = this.getAlreadyFilteredAttributeName(); boolean hasAlreadyFilteredAttribute = request.getAttribute(alreadyFilteredAttributeName) != null; if (!hasAlreadyFilteredAttribute &amp;&amp; !this.skipDispatch(httpRequest) &amp;&amp; !this.shouldNotFilter(httpRequest)) &#123; request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE); try &#123; this.doFilterInternal(httpRequest, httpResponse, filterChain); &#125; finally &#123; request.removeAttribute(alreadyFilteredAttributeName); &#125; &#125; else &#123; // 待下一个过滤器处理 filterChain.doFilter(request, response); &#125; &#125; else &#123; throw new ServletException(\"OncePerRequestFilter just supports HTTP requests\"); &#125; &#125; // ... &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理模式","slug":"design_pattern/structure_type/代理模式","date":"2019-10-02T16:00:00.000Z","updated":"2020-08-09T09:34:32.145Z","comments":true,"path":"posts/7b510e10/","link":"","permalink":"https://gentryhuang.com/posts/7b510e10/","excerpt":"","text":"定义为其他对象提供一种代理，以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介的作用。 举例：租房子，目标对象代表房东，客户端代表用户，房屋中介代表中介。房屋中介起到代理的作用，签合同和缴纳水电费直接找中介就可以了，不需要和房东直接接触，即中介代理房东。 类型结构型 使用场景12◆ 保护目标对象◆ 增强目标对象 优点1234◆ 代理模式能将代理对象与真实被调用的目标对象分离◆ 一定程度上降低了系统的耦合度，扩展性好◆ 保护目标对象◆ 在不修改目标类的前提下，增强目标对象 缺点123◆ 代理模式会造成系统设计中类的数目增加◆ 在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢◆ 增加系统的复杂度 扩展 根据代理对象与目标对象代理关系的创建时机的不同，可以分为静态代理和动态代理。动态代理又根据实现技术的不同分为JDK的Proxy动态代理和CGLIB动态代理。 静态代理 1静态代理就是在代码中指定显式的代理,在编译之前代理关系就已经确定了。在代理类中对同名的方法进行包装，用户通过对代理类的被包装过的方法来调用目标对象的业务方法，同时对目标对象的业务方法进行增强。 JDK动态代理 1jdk的动态代理是通过接口中的方法名对在动态生成的代理类中，调用业务实现类的同名方法。注意:必须是接口,因为jdk底层先创建一个代理类，然后再创建代理类的实例，它的类型是接口类型，不是目标类的类型。 CGLIB代理 1cglib是通过继承来实现的，生成的代理类是业务类的子类，通过重写业务方法执行代理。使用CGLib进行代理时一定要注意final修改的类和方法以及是否有无参构造器。CGLib底层使用asm字节码生成的。 代理模式相关的设计模式代理模式和装饰者模式 1目的不同，装饰者模式是为对象加上行为，而代理模式是控制访问，代理模式更加关注通过控制代理人的方式来增强目标对象。增强对象的方式一般是增强对象的某些行为。 代理模式和适配器模式 1适配器模式主要改变所要考虑对象的接口，代理模式不可以改变所代理类的接口。 代理模式演练静态代理 静态代理的代理类是手动编写的，代理关系在编译之前就确立了。通常目标对象在代理类中创建。 目标类接口 1234567891011121314package com.design.pattern.proxy.staticproxy;/** * IRentalHouseService * * @author shunhua * @date 2019-10-03 */public interface IRentalHouseService &#123; /** * 租房方法 */ void rent();&#125; 目标类 123456789101112131415161718192021222324package com.design.pattern.proxy.jdkproxy;import com.design.pattern.proxy.staticproxy.IRentalHouseService;import lombok.extern.slf4j.Slf4j;/** *RentalHouseServiceImpl * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseService implements IRentalHouseService &#123; /** * 出租房子，目标方法 * @return */ @Override public void rent()&#123; log.info(\"1800/月，2室1厅1厨1卫！\"); &#125;&#125; 代理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.design.pattern.proxy.staticproxy;import lombok.extern.slf4j.Slf4j;/** * RentalHouseServiceProxy 代理类 * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceProxy &#123; /** * 代理对象需要目标对象 */ private RentalHouseService rentalHouseService; /** * 构造方法 */ public RentalHouseServiceProxy()&#123; rentalHouseService = new RentalHouseService(); &#125; /** * 代理方法 */ public void rent()&#123; dialNumber(); rentalHouseService.rent(); signContract(); &#125; /** * 需要房租请联系我，目标方法的前置方法 */ private void dialNumber() &#123; log.info(\"需要租房请致电：123456\"); &#125; /** * 签合同，目标方法的后置方法 */ private void signContract() &#123; log.info(\"房子还满意就可以签合同了！\"); &#125;&#125; 应用层 1234567891011121314151617181920package com.design.pattern.proxy.staticproxy;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-03 */public class Client &#123; @Test public void test()&#123; // 租房直接找代理 RentalHouseServiceProxy proxy = new RentalHouseServiceProxy(); proxy.rent(); &#125;&#125; jdk动态代理 jdk动态代理用于目标类有接口的情况。代理类不是手动创建，而是程序运行时动态生成。有时目标对象需要在客户端中创建，这样情况下不能够保护和隐藏目标对象，只是增强了目标方法功能。代理类的名称由三部分构成：$ + Proxy + 数字，数字表示当前JDK的Proxy所生成的代理类的索引，索引从0开始计数。 目标类接口 1234567891011121314package com.design.pattern.proxy.jdkproxy;/** * IRentalHouseService * * @author shunhua * @date 2019-10-03 */public interface IRentalHouseService &#123; /** * 租房方法 */ void rent();&#125; 目标类 123456789101112131415161718192021222324package com.design.pattern.proxy.jdkproxy;import com.design.pattern.proxy.staticproxy.IRentalHouseService;import lombok.extern.slf4j.Slf4j;/** * RentalHouseServiceImpl 目标类 * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceImpl implements IRentalHouseService &#123; /** * 出租房子，目标方法 * @return */ @Override public void rent()&#123; log.info(\"1800/月，2室1厅1厨1卫！\"); &#125;&#125; InvocationHandler实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.design.pattern.proxy.jdkproxy;import lombok.extern.slf4j.Slf4j;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * RentalHouseServiceProxy * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceProxy implements InvocationHandler &#123; private IRentalHouseService target; public RentalHouseServiceProxy(IRentalHouseService target) &#123; this.target = target; &#125; /** * 当执行代理对象的代理方法时，代理方法会调用该invoke() * * @param proxy 代理对象 * @param method 目标方法 * @param args 目标方法的参数列表 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 调用目标方法前 dialNumber(); // 执行目标方法 Object result = method.invoke(target, args); // 调用目标方法后 signContract(); return result; &#125; /** * 需要房租请联系我，目标方法的前置方法 */ private void dialNumber() &#123; log.info(\"需要租房请致电：123456\"); &#125; /** * 签合同，目标方法的后置方法 */ private void signContract() &#123; log.info(\"房子还满意就可以签合同了！\"); &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930313233package com.design.pattern.proxy.jdkproxy;import org.junit.Test;import java.lang.reflect.Proxy;/** * Client * * @author shunhua * @date 2019-10-04 */public class Client &#123; @Test public void test()&#123; // 创建目标对象 IRentalHouseService target = new RentalHouseServiceImpl(); // 创建代理对象（接口实现类的代理对象） IRentalHouseService proxy = (IRentalHouseService) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new RentalHouseServiceProxy(target) ); /** * 调用代理对象的代理方法,注意当调用代理对象的代理方法时，InvocationHandler的invoke方法会被自动调用 */ proxy.rent(); &#125;&#125; CGLIB动态代理 CGLIB的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类，代理的目标类可以没有实现接口，也可以有实现的接口。CGLIB使用子类扩展父类的方式来生成代理对象，即CGLIB会动态生成目标类的子类作为代理类，并创建其对象即代理对象。 目标类 123456789101112131415161718192021222324package com.design.pattern.proxy.cglibproxy;import com.design.pattern.proxy.staticproxy.IRentalHouseService;import lombok.extern.slf4j.Slf4j;/** * RentalHouseServiceImpl 目标类 * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceImpl implements IRentalHouseService &#123; /** * 出租房子，目标方法 * @return */ @Override public void rent()&#123; log.info(\"1800/月，2室1厅1厨1卫！\"); &#125;&#125; MethodInterceptor的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.design.pattern.proxy.cglibproxy;import lombok.extern.slf4j.Slf4j;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * RentalHouseServiceProxy * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceProxy implements MethodInterceptor &#123; /** * * @param o 代理对象 * @param method 目标方法 * @param objects 目标方法参数列表 * @param methodProxy 目标方法的代理对象 * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return null; &#125; /** * 需要房租请联系我，目标方法的前置方法 */ private void dialNumber() &#123; log.info(\"需要租房请致电：123456\"); &#125; /** * 签合同，目标方法的后置方法 */ private void signContract() &#123; log.info(\"房子还满意就可以签合同了！\"); &#125;&#125; 生成代理类的逻辑类 1234567891011121314151617181920212223242526272829303132333435package com.design.pattern.proxy.cglibproxy;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;/** * CglibProxy 手动创建 * * @author shunhua * @date 2019-10-04 */public class CglibProxy &#123; /** * 创建Cglib的代理对象 * * @param targetClass 目标类 * @param callBack 委托类对象 * @return */ public static IRentalHouseService createCglibProxy(Class targetClass, MethodInterceptor callBack)&#123; // 创建增强其 Enhancer enhancer = new Enhancer(); // 指定目标类 enhancer.setSuperclass(targetClass); // 设置回调接口 enhancer.setCallback(callBack); // 创建并返回代理对象，即目标类的子类对象 return (IRentalHouseService) enhancer.create(); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031package com.design.pattern.proxy.cglibproxy;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-04 */public class Client &#123; @Test public void test() &#123; // 创建目标对象 IRentalHouseService target = new RentalHouseServiceImpl(); // 创建委托对象 RentalHouseServiceProxy rentalHouseServiceProxy = new RentalHouseServiceProxy(); // 创建代理对象（接口实现类的代理对象） IRentalHouseService cglibProxy = CglibProxy.createCglibProxy(target.getClass(), rentalHouseServiceProxy); /** * 调用代理对象的代理方法,注意当调用代理对象的代理方法时，InvocationHandler的invoke方法会被自动调用 */ cglibProxy.rent(); &#125;&#125; 代理模式在源码中的使用jdk中的应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490package java.lang.reflect;import java.lang.ref.WeakReference;import java.security.AccessController;import java.security.PrivilegedAction;import java.util.Arrays;import java.util.IdentityHashMap;import java.util.Map;import java.util.Objects;import java.util.concurrent.atomic.AtomicLong;import java.util.function.BiFunction;import sun.misc.ProxyGenerator;import sun.misc.VM;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;import sun.reflect.misc.ReflectUtil;import sun.security.util.SecurityConstants;public class Proxy implements java.io.Serializable &#123; private static final long serialVersionUID = -2222568056686623797L; /** parameter types of a proxy class constructor */ private static final Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;; /** * a cache of proxy classes */ private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory()); /** * the invocation handler for this proxy instance. * @serial */ protected InvocationHandler h; /** * Prohibits instantiation. */ private Proxy() &#123; &#125; /** * Constructs a new &#123;@code Proxy&#125; instance from a subclass * (typically, a dynamic proxy class) with the specified value * for its invocation handler. * * @param h the invocation handler for this proxy instance * * @throws NullPointerException if the given invocation handler, &#123;@code h&#125;, * is &#123;@code null&#125;. */ protected Proxy(InvocationHandler h) &#123; Objects.requireNonNull(h); this.h = h; &#125; @CallerSensitive public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) throws IllegalArgumentException &#123; final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; return getProxyClass0(loader, intfs); &#125; /* * Check permissions required to create a Proxy class. * * To define a proxy class, it performs the access checks as in * Class.forName (VM will invoke ClassLoader.checkPackageAccess): * 1. \"getClassLoader\" permission check if loader == null * 2. checkPackageAccess on the interfaces it implements * * To get a constructor and new instance of a proxy class, it performs * the package access check on the interfaces it implements * as in Class.getConstructor. * * If an interface is non-public, the proxy class must be defined by * the defining loader of the interface. If the caller's class loader * is not the same as the defining loader of the interface, the VM * will throw IllegalAccessError when the generated proxy class is * being defined via the defineClass0 method. */ private static void checkProxyAccess(Class&lt;?&gt; caller, ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; ClassLoader ccl = caller.getClassLoader(); if (VM.isSystemDomainLoader(loader) &amp;&amp; !VM.isSystemDomainLoader(ccl)) &#123; sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION); &#125; ReflectUtil.checkProxyPackageAccess(ccl, interfaces); &#125; &#125; /** * 生成代理类的核心方法 */ private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(\"interface limit exceeded\"); &#125; // 如果缓存中有对应的代理类就直接获取，没有就创建然后放入缓存 return proxyClassCache.get(loader, interfaces); &#125; /* * a key used for proxy class with 0 implemented interfaces */ private static final Object key0 = new Object(); /* * Key1 and Key2 are optimized for the common use of dynamic proxies * that implement 1 or 2 interfaces. */ /* * a key used for proxy class with 1 implemented interface */ private static final class Key1 extends WeakReference&lt;Class&lt;?&gt;&gt; &#123; private final int hash; Key1(Class&lt;?&gt; intf) &#123; super(intf); this.hash = intf.hashCode(); &#125; @Override public int hashCode() &#123; return hash; &#125; @Override public boolean equals(Object obj) &#123; Class&lt;?&gt; intf; return this == obj || obj != null &amp;&amp; obj.getClass() == Key1.class &amp;&amp; (intf = get()) != null &amp;&amp; intf == ((Key1) obj).get(); &#125; &#125; /* * a key used for proxy class with 2 implemented interfaces */ private static final class Key2 extends WeakReference&lt;Class&lt;?&gt;&gt; &#123; private final int hash; private final WeakReference&lt;Class&lt;?&gt;&gt; ref2; Key2(Class&lt;?&gt; intf1, Class&lt;?&gt; intf2) &#123; super(intf1); hash = 31 * intf1.hashCode() + intf2.hashCode(); ref2 = new WeakReference&lt;Class&lt;?&gt;&gt;(intf2); &#125; @Override public int hashCode() &#123; return hash; &#125; @Override public boolean equals(Object obj) &#123; Class&lt;?&gt; intf1, intf2; return this == obj || obj != null &amp;&amp; obj.getClass() == Key2.class &amp;&amp; (intf1 = get()) != null &amp;&amp; intf1 == ((Key2) obj).get() &amp;&amp; (intf2 = ref2.get()) != null &amp;&amp; intf2 == ((Key2) obj).ref2.get(); &#125; &#125; /* * a key used for proxy class with any number of implemented interfaces * (used here for 3 or more only) */ private static final class KeyX &#123; private final int hash; private final WeakReference&lt;Class&lt;?&gt;&gt;[] refs; @SuppressWarnings(\"unchecked\") KeyX(Class&lt;?&gt;[] interfaces) &#123; hash = Arrays.hashCode(interfaces); refs = (WeakReference&lt;Class&lt;?&gt;&gt;[])new WeakReference&lt;?&gt;[interfaces.length]; for (int i = 0; i &lt; interfaces.length; i++) &#123; refs[i] = new WeakReference&lt;&gt;(interfaces[i]); &#125; &#125; @Override public int hashCode() &#123; return hash; &#125; @Override public boolean equals(Object obj) &#123; return this == obj || obj != null &amp;&amp; obj.getClass() == KeyX.class &amp;&amp; equals(refs, ((KeyX) obj).refs); &#125; private static boolean equals(WeakReference&lt;Class&lt;?&gt;&gt;[] refs1, WeakReference&lt;Class&lt;?&gt;&gt;[] refs2) &#123; if (refs1.length != refs2.length) &#123; return false; &#125; for (int i = 0; i &lt; refs1.length; i++) &#123; Class&lt;?&gt; intf = refs1[i].get(); if (intf == null || intf != refs2[i].get()) &#123; return false; &#125; &#125; return true; &#125; &#125; /** * A function that maps an array of interfaces to an optimal key where * Class objects representing interfaces are weakly referenced. */ private static final class KeyFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Object&gt; &#123; @Override public Object apply(ClassLoader classLoader, Class&lt;?&gt;[] interfaces) &#123; switch (interfaces.length) &#123; case 1: return new Key1(interfaces[0]); // the most frequent case 2: return new Key2(interfaces[0], interfaces[1]); case 0: return key0; default: return new KeyX(interfaces); &#125; &#125; &#125; /** * A factory function that generates, defines and returns the proxy class given * the ClassLoader and array of interfaces. */ private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; // prefix for all proxy class names private static final String proxyClassNamePrefix = \"$Proxy\"; // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + \" is not visible from class loader\"); &#125; /* * Verify that the Class object actually represents an * interface. */ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + \" is not an interface\"); &#125; /* * Verify that this interface is not a duplicate. */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( \"repeated interface: \" + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( \"non-public interfaces from different packages\"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\"; &#125; /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125; &#125; // 该方法最终返回一个新的对象（目标对象） @CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * 生成代理类的核心方法 */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; private static void checkNewProxyPermission(Class&lt;?&gt; caller, Class&lt;?&gt; proxyClass) &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; if (ReflectUtil.isNonPublicProxyClass(proxyClass)) &#123; ClassLoader ccl = caller.getClassLoader(); ClassLoader pcl = proxyClass.getClassLoader(); // do permission check if the caller is in a different runtime package // of the proxy class int n = proxyClass.getName().lastIndexOf('.'); String pkg = (n == -1) ? \"\" : proxyClass.getName().substring(0, n); n = caller.getName().lastIndexOf('.'); String callerPkg = (n == -1) ? \"\" : caller.getName().substring(0, n); if (pcl != ccl || !pkg.equals(callerPkg)) &#123; sm.checkPermission(new ReflectPermission(\"newProxyInPackage.\" + pkg)); &#125; &#125; &#125; &#125; /** * Returns true if and only if the specified class was dynamically * generated to be a proxy class using the &#123;@code getProxyClass&#125; * method or the &#123;@code newProxyInstance&#125; method. * * &lt;p&gt;The reliability of this method is important for the ability * to use it to make security decisions, so its implementation should * not just test if the class in question extends &#123;@code Proxy&#125;. * * @param cl the class to test * @return &#123;@code true&#125; if the class is a proxy class and * &#123;@code false&#125; otherwise * @throws NullPointerException if &#123;@code cl&#125; is &#123;@code null&#125; */ public static boolean isProxyClass(Class&lt;?&gt; cl) &#123; return Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl); &#125; /** * Returns the invocation handler for the specified proxy instance. * * @param proxy the proxy instance to return the invocation handler for * @return the invocation handler for the proxy instance * @throws IllegalArgumentException if the argument is not a * proxy instance * @throws SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present * and the caller's class loader is not the same as or an * ancestor of the class loader for the invocation handler * and invocation of &#123;@link SecurityManager#checkPackageAccess * s.checkPackageAccess()&#125; denies access to the invocation * handler's class. */ @CallerSensitive public static InvocationHandler getInvocationHandler(Object proxy) throws IllegalArgumentException &#123; /* * Verify that the object is actually a proxy instance. */ if (!isProxyClass(proxy.getClass())) &#123; throw new IllegalArgumentException(\"not a proxy instance\"); &#125; final Proxy p = (Proxy) proxy; final InvocationHandler ih = p.h; if (System.getSecurityManager() != null) &#123; Class&lt;?&gt; ihClass = ih.getClass(); Class&lt;?&gt; caller = Reflection.getCallerClass(); if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), ihClass.getClassLoader())) &#123; ReflectUtil.checkPackageAccess(ihClass); &#125; &#125; return ih; &#125; private static native Class&lt;?&gt; defineClass0(ClassLoader loader, String name, byte[] b, int off, int len);&#125; Spring中的应用12345678910111213141516public class ProxyFactoryBean extends ProxyCreatorSupport implements FactoryBean&lt;Object&gt;, BeanClassLoaderAware, BeanFactoryAware &#123; //如果不声明，默认单例对象，注解声明多例，则声明多例对象 public Object getObject() throws BeansException &#123; this.initializeAdvisorChain(); if (this.isSingleton()) &#123; return this.getSingletonInstance(); &#125; else &#123; if (this.targetName == null) &#123; this.logger.warn(\"Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the 'targetName' property.\"); &#125; return this.newPrototypeInstance(); &#125; &#125;&#125; 12JdkDynamicAopProxy:对jdk动态代理的封装CglibAopProxy:对类进行代理增强 MyBatis中的应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package org.apache.ibatis.binding;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import org.apache.ibatis.session.SqlSession;/** * @author Lasse Voss */public class MapperProxyFactory&lt;T&gt; &#123; private final Class&lt;T&gt; mapperInterface; private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;&gt;(); public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; public Map&lt;Method, MapperMethod&gt; getMethodCache() &#123; return methodCache; &#125; @SuppressWarnings(\"unchecked\") protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; // 生成一个代理对象并返回 return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;,); &#125; public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); &#125;&#125;/** * MapperProxy代理类的信息 */public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable &#123; private static final long serialVersionUID = -6424540398559729838L; private final SqlSession sqlSession; private final Class&lt;T&gt; mapperInterface; private final Map&lt;Method, MapperMethod&gt; methodCache; public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) &#123; this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; this.methodCache = methodCache; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, args); &#125; else if (isDefaultMethod(method)) &#123; return invokeDefaultMethod(proxy, method, args); &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; final MapperMethod mapperMethod = cachedMapperMethod(method); return mapperMethod.execute(sqlSession, args); &#125; private MapperMethod cachedMapperMethod(Method method) &#123; return methodCache.computeIfAbsent(method, k -&gt; new MapperMethod(mapperInterface, method, sqlSession.getConfiguration())); &#125; // ... 等等 ｝","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"观察者模式","slug":"design_pattern/behaviour_type/观察者模式","date":"2019-10-01T16:00:00.000Z","updated":"2020-08-09T09:29:21.271Z","comments":true,"path":"posts/9a246216/","link":"","permalink":"https://gentryhuang.com/posts/9a246216/","excerpt":"","text":"定义定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并更新。 类型行为型 适用场景1关联行为场景，建立一套触发机制。如：注某个产品的价格，然后进行通知，其中价格的变动可能会影响一条链，就像是一个触发链条。这样就可以使用观察者模式创建一个种链式发机制。 优点12341. 观察者和被观察者之间建立一个抽象的耦合 - 因为是抽象的耦合关系，不管是增加观察者还是被观察者都很容易扩展2. 支持广播通信 - 类似消息广播，需要监听主题的只需要注册就可以了 缺点123451. 观察者之间有过多的细节依赖、提高了时间消耗及程序复杂度 - 过多的依赖：触发机制和触发链条 - 提高了时间消耗及程序复杂度：如果一个被观察对象有多个直接或间接观察者，一旦被观察者变化，然后发出通知，将所有观察者都通知到会花费一些时间2. 使用要得当，避免循环调用 - 如果在观察者和被观察者之间有循环依赖的话，被观察者（主题对象）会触发它们之间进行循环调用，这样会导致系统崩溃 简单需求学生在学习课程的时候可能会提出问题，而老师则是关注自己的课程，有学生提出自己课程的问题就给出解答 观察者模式演练 被观察者需要继承的类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package java.util;/** * @since JDK1.0 */public class Observable &#123; private boolean changed = false; private Vector&lt;Observer&gt; obs; /** Construct an Observable with zero Observers. */ public Observable() &#123; obs = new Vector&lt;&gt;(); &#125; /** * * 在观察者列表中增加一个观察者 * * @param o 要添加的观察者对象 * @throws NullPointerException 如果参数传入null会抛出异常 */ public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; /** * 从观察者列表中删除指定的观察者 * * @param o 要被移出的观察者 出入为null不会抛出异常 */ public synchronized void deleteObserver(Observer o) &#123; obs.removeElement(o); &#125; /** * 通知观察者们，主题对象（被观察者发生了改变），该方法不传参数给观察者们 */ public void notifyObservers() &#123; notifyObservers(null); &#125; /** * 通知观察者们，主题对象（被观察者发生了改变），该方法传参数给观察者们 */ public void notifyObservers(Object arg) &#123; /* * a temporary array buffer, used as a snapshot of the state of * current Observers. */ Object[] arrLocal; synchronized (this) &#123; /* * 在通知观察者们之前会先校验标识主题对象（被观察者）改变的属性，如果没有改变就直接返回不进行通知 */ if (!changed) return; arrLocal = obs.toArray(); clearChanged(); &#125; for (int i = arrLocal.length-1; i&gt;=0; i--) // 通过调用观察者的update方法通知观察者，会把当前主题对象（被观察者对象）传给观察者 ((Observer)arrLocal[i]).update(this, arg); &#125; /** * 清除观察者列表 */ public synchronized void deleteObservers() &#123; obs.removeAllElements(); &#125; /** * 调用这个方法就是说明了主题对象（被观察者发生了改变），设置标识对象为true */ protected synchronized void setChanged() &#123; changed = true; &#125; /** * * 调用这个方法说明主题对象（被观察者）已经不再改变了或者要通知的观察者都通知完了。这个方法会在调用notifyObservers方法自动调用 */ protected synchronized void clearChanged() &#123; changed = false; &#125; /** * 获取主题对象是否改变的标识 */ public synchronized boolean hasChanged() &#123; return changed; &#125; /** * 返回关注主题对象的观察的个数 * * @return the number of observers of this object. */ public synchronized int countObservers() &#123; return obs.size(); &#125;&#125; 观察者需要实现的接口 123456789101112package java.util;/** * @since JDK1.0 */public interface Observer &#123; /** * * 当订阅的主题对象（被观察者）发生改变时，会通过调用 notifyObservers方法来通知所有设计到的观察者，就是通过调用观察者的update方法进行通知的 */ void update(Observable o, Object arg);&#125; 主题类（被观察者） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.design.pattern.observer;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.util.ArrayList;import java.util.List;import java.util.Observable;/** * Course * 1 它下面有问题，Course属于被观察者，也就是主题对象 * 2 作为被观察者必须继承Observable类，标志是可观察的 * * @author shunhua * @date 2019-10-02 */@Data@Slf4jpublic class Course extends Observable &#123; /** * 课程名 */ private String name; /** * 课程对应的问题列表 */ private List&lt;Question&gt; questions = new ArrayList&lt;&gt;(); public Course(String name) &#123; this.name = name; &#125; public void addQuestion(Question question) &#123; questions.add(question); &#125; /** * 主题改变方法 * * @param course */ public void produceQuestion(Course course) &#123; questions.stream().forEach(question -&gt; &#123; log.info(String.format(\"%s在%s提出了问题\", question.getUserName(), course.getName())); /** * 调用父类Observabel中的setChanged方法，把changed标识设置为true,表示主题对象发生了改变,此时观察者和被观察者之间进行通信 */ setChanged(); /** * 通知观察者 */ notifyObservers(question); &#125; ); &#125;&#125; 观察者 123456789101112131415161718192021222324252627282930313233343536373839package com.design.pattern.observer;import lombok.AllArgsConstructor;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.util.Observable;import java.util.Observer;/** * Teacher * * 1 观察的是课程，而不是问题，问题属于课程 。 Teacher属于观察者 * 2 必须实现Observer接口，表示它是一个观察者 * * @author shunhua * @date 2019-10-02 */@Data@AllArgsConstructor@Slf4jpublic class Teacher implements Observer &#123; /** * 老师名称 */ private String name; /** * * @param o 被观察对象 * @param arg 被观察者的notifyObservers方法传递过来的对象 */ @Override public void update(Observable o, Object arg) &#123; Course course = (Course) o; Question question = (Question) arg; log.info(String.format(\"%s课程被%s同学提出%s的问题，需要%s解答\",course.getName(),question.getUserName(),question.getQuestionContent(),name)); &#125;&#125; 应用辅助类 1234567891011121314151617181920212223package com.design.pattern.observer;import lombok.Builder;import lombok.Data;/** * Question * * @author shunhua * @date 2019-10-02 */@Data@Builderpublic class Question &#123; /** * 问题提问者名称 */ private String userName; /** * 具体问题 */ private String questionContent;&#125; 应用层 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.observer;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-02 */public class Client &#123; @Test public void test()&#123; Course course = new Course(\"《Java从入门到放弃》\"); Teacher teacher = new Teacher(\"Java学院老师\"); Teacher teacher1 = new Teacher(\"鼓励师\"); // 为课程添加观察者 course.addObserver(teacher); course.addObserver(teacher1); // 添加课程的问题 course.addQuestion(Question.builder() .userName(\"gentryhuang\") .questionContent(\"Java学不完，需要放弃吗？\") .build()); course.addQuestion(Question.builder() .userName(\"xw\") .questionContent(\"快看，又一个学Java的转行了，要跑路吗？\") .build()); // 主题对象发生变化（有问题提出了） course.produceQuestion(course); &#125;&#125; 观察者模式源码解析监听器实现方案就是观察者模式实现的一种 Guava中观察者模式的使用 使用@Subscribe进行方法标注 12345678910111213141516171819package com.design.pattern.observer.guava;import com.google.common.eventbus.Subscribe;import lombok.extern.slf4j.Slf4j;/** * GuavaEvent * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class GuavaEvent &#123; @Subscribe public void subscribe(String event)&#123; log.info(\"执行subscribe方法，传入参数是：\" + event); &#125;&#125; 在应用层把订阅者进行注册 12345678910111213141516171819202122232425262728293031323334package com.design.pattern.observer.guava;import com.google.common.eventbus.EventBus;import org.junit.Test;/** * GuavaEventTest * * @author shunhua * @date 2019-10-02 */public class GuavaEventTest &#123; @Test public void test() &#123; /** * Guava实现观察者模式的核心类 */ EventBus eventBus = new EventBus(); /** * GuavaEvent中有使用@Subscribe注解标注的方法 */ GuavaEvent guavaEvent = new GuavaEvent(); /** * GuavaEvent的@Subscribe标注的方法 加入到观察者模式中，作为订阅者即观察者 */ eventBus.register(guavaEvent); /** * 调用EventBus的post方法会回调Subscribe标注的方法 */ eventBus.post(\"post的内容\"); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"解释器模式","slug":"design_pattern/behaviour_type/解释器模式","date":"2019-10-01T16:00:00.000Z","updated":"2020-08-09T09:29:48.704Z","comments":true,"path":"posts/30cf0cd2/","link":"","permalink":"https://gentryhuang.com/posts/30cf0cd2/","excerpt":"","text":"定义给定一个语言，定义它的文法（语法）的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。即 为了解释一种语言（语言的语法），而为语言创建的解释器 类型行为型 适用场景1在处理日志的时候，由于多个服务产生的日志格式不一定统一，但是数据里面的要素是相同的，这种情况下我们就可以通过程序来解决该问题，而这个程序我们就可以理解为解释器，只不过可以解释不同日志格式。在实际项目中解释器模式使用的比较少，多使用开源包。 优点1语法由很多类表示，容易改变及扩展此“语言”（涉及的代码还不足以说明是种语言） 缺点1当语法规则数目太多时，增加了系统复杂度 简单需求自定义一套可以加法、乘法的语法，使用栈来表示，这和日常的加法和乘法是不一样的。然后定义加法和乘法解释器，解释对应的表达式然后拿到最终的结果。 解释器模式演练 解释器接口 123456789101112131415package com.design.pattern.interpreter;/** * Interpreter 解释接口 * * @author shunhua * @date 2019-10-02 */public interface Interpreter &#123; /** * 解释方法 * @return */ int interpret();&#125; 加法解释器 123456789101112131415161718192021222324252627282930313233343536373839package com.design.pattern.interpreter;/** * AddInterpreter 加法解释器 * * @author shunhua * @date 2019-10-02 */public class AddInterpreter implements Interpreter &#123; /** * 它们的方法返回值作为加数和被加数 */ private Interpreter firstExpression,secondeExpression; /** * 加法需要 加数和被加数 * @param firstExpression * @param secondeExpression */ public AddInterpreter(Interpreter firstExpression,Interpreter secondeExpression)&#123; this.firstExpression = firstExpression; this.secondeExpression = secondeExpression; &#125; /** * 返回两个表达式结果的和 * @return */ @Override public int interpret() &#123; return this.firstExpression.interpret() + this.secondeExpression.interpret(); &#125; @Override public String toString() &#123; return \"+\"; &#125;&#125; 乘法解释器 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.interpreter;/** * MultiInterpreter 乘法解释器 * * @author shunhua * @date 2019-10-02 */public class MultiInterpreter implements Interpreter &#123; /** * 它们的表达式结果作为乘数和被乘除数 */ private Interpreter firstExpression,secondExpression; /** * 乘法需要 乘数和被乘数 * @param firstExpression * @param secondExpression */ public MultiInterpreter(Interpreter firstExpression,Interpreter secondExpression)&#123; this.firstExpression = firstExpression; this.secondExpression = secondExpression; &#125; /** * 乘法解释器的解释方法 * @return */ @Override public int interpret() &#123; return this.firstExpression.interpret() * this.secondExpression.interpret(); &#125; @Override public String toString() &#123; return \"*\"; &#125;&#125; 表达式处理解释器 1234567891011121314151617181920212223242526272829303132333435363738394041// 注意这个解释器就是简单转换数据的package com.design.pattern.interpreter;/** * NumberInterpreter 表达式处理解释器 * * @author shunhua * @date 2019-10-02 */public class NumberInterpreter implements Interpreter &#123; /** * 表达式要返回的值 */ private int number; /** * 数值构造器 * @param number */ public NumberInterpreter(int number)&#123; this.number = number; &#125; /** * 字符串转换构造器 * @param number */ public NumberInterpreter(String number)&#123; this.number = Integer.parseInt(number); &#125; /** * 解释方法 * @return */ @Override public int interpret() &#123; return this.number; &#125;&#125; 封装解释器的处理类–暴露给用户的解释器（它内部是对几个解释器的封装） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.design.pattern.interpreter;import lombok.extern.slf4j.Slf4j;import java.util.Arrays;import java.util.Stack;/** * ExpressionParse * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class ExpressionParse &#123; /** * 定义一个栈，这里是解释器类型栈 */ private Stack&lt;Interpreter&gt; stack = new Stack&lt;&gt;(); public int parse(String str)&#123; String[] strItemArray = str.split(\" \"); Arrays.stream(strItemArray).forEach(symbol -&gt;&#123; // 不是运算符，需要入栈 if(!OperatorUtil.isOperator(symbol))&#123; Interpreter numberExpression = new NumberInterpreter(symbol); stack.push(numberExpression); log.info(String.format(\"入栈：%d\",numberExpression.interpret())); &#125;else &#123; // 是运算符，可以进行计算 Interpreter firstExpression = stack.pop(); Interpreter secondExpression = stack.pop(); log.info(String.format(\"出栈： %d 和 %d\",firstExpression.interpret(),secondExpression.interpret())); Interpreter operator = OperatorUtil.getExpressionObject(firstExpression,secondExpression,symbol); log.info(String.format(\"解释器类型：%s\",operator.toString())); int result = operator.interpret(); NumberInterpreter resultExpression = new NumberInterpreter(result); stack.push(resultExpression); log.info(String.format(\"阶段结果入栈： %d\",resultExpression.interpret())); &#125; &#125;); int result = stack.pop().interpret(); return result; &#125;&#125; 工具类 1234567891011121314151617181920212223242526272829303132333435package com.design.pattern.interpreter;/** * OperatorUtil * * @author shunhua * @date 2019-10-02 */public class OperatorUtil &#123; /** * 是否可操作 * @param symbol * @return */ public static boolean isOperator(String symbol)&#123; return \"+\".equals(symbol) || \"*\".equals(symbol); &#125; /** * 使用解释器进行解释，表达式的结果 * @param firstExpression * @param secondExpression * @param symbol * @return */ public static Interpreter getExpressionObject(Interpreter firstExpression,Interpreter secondExpression,String symbol)&#123; if(\"+\".equals(symbol))&#123; return new AddInterpreter(firstExpression,secondExpression); &#125; else if (\"*\".equals(symbol))&#123; return new MultiInterpreter(firstExpression,secondExpression); &#125; return null; &#125;&#125; 应用 12345678910111213141516171819202122232425package com.design.pattern.interpreter;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class Client &#123; @Test public void test()&#123; // 输入表达式 String inputStr = \"18 70 12 + *\"; // 对表达式进行解释 ExpressionParse expressionParse = new ExpressionParse(); int result = expressionParse.parse(inputStr); log.info(\"最终解释结果：\" + result); &#125;&#125; 解释器模式在源码中的使用java.util.regex.Pattern 1正则表达式就是一种语法，通过jdk中的正则解释器把它解释出来 123456789101112131415161718192021222324252627282930package com.design.pattern.interpreter;import lombok.extern.slf4j.Slf4j;import org.junit.Test;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * PatternTest * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class PatternTest &#123; @Test public void test()&#123; String str = \"china\"; String patternStr = \"\\\\s+\" + str + \"\\\\s+\"; // 正则解释器，解释正则表达式 Pattern pattern = Pattern.compile(patternStr); String content = \" china becames more and more beautiful! \"; Matcher matcher = pattern.matcher(content); if (matcher.find()) &#123; String content_new = matcher.replaceAll(\"China \"); log.info(String.format(\"old: %s, new: %s\",content,content_new)); &#125; &#125;&#125; Spring的EL解释器 1El表达式是一种语法，通过Spring的解释器去解释 12345678910111213141516171819202122232425262728293031package com.design.pattern.interpreter.resource;import lombok.extern.slf4j.Slf4j;import org.junit.Test;import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;/** * SpelParserTest * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class SpelParserTest &#123; /** * 使用Spring的语言解释器(ExpressionParser) 解释Spring的EL（解释语言）表达式 */ @Test public void test() &#123; // 创建Spring的语言解释器 ExpressionParser parser = new SpelExpressionParser(); // 使用解释解析Spring的El表达式 Expression expression = parser.parseExpression(\"2 * 100 * 10 + 19\"); // 取出结果 int result = (Integer) expression.getValue(); log.info(\"解释后的结果：\" + result); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","slug":"design_pattern/creation_type/单例模式","date":"2019-10-01T16:00:00.000Z","updated":"2020-07-04T16:28:45.963Z","comments":true,"path":"posts/f1601c3e/","link":"","permalink":"https://gentryhuang.com/posts/f1601c3e/","excerpt":"","text":"单例模式定义保证一个类仅有一个实例，并提供一个全局访问点。 类型创建型 适用场景12想确保任何情况下都绝对只有一个实例 - 数据库连接池、线程池以及计数器等 优点1234561. 在内存里只有一个实例，减少了内存开销 - 特别是一个对象频繁的创建和销毁，而且在创建和销毁时性能又不能很好的优化2. 可以避免对资源的多重占用 - 如对一个文件进行写操作，由于只有一个实例存在内存中，可以避免对同一个资源文件同时写操作3. 设置全局访问点，严格控制访问 - 对外控制创建的入口 缺点1没有接口，扩展困难，想要扩展需要修改源代码 拓展点1234567891011121. 私有构造器 - 为了禁止从单例类外部调用构造函数创建对象，为了达到目的必须设置构造函数为私有的2. 线程安全 - 线程安全在单例模式设计的过程中非常重要3. 延迟加载 - 延时创建对象4. 序列化和反序列化安全 - 对于单例对象一旦序列化和反序列化，就会对单例进行破坏5. 反射 - 单例模式也要防止反射攻击6. 双重检锁机制7. 单例静态内部类的实现方案 单例模式相关的设计模式单例模式和工厂模式 1在一些业务场景中，我们可以把工厂类设置为单例的 单例模式和享元模式 1在一些业务场景中，要管理很多单例对象，通过享元模式和单例模式结合来完成单例对象的获取，在这种结合场景下，享元模式的应用就类似于单例对象的一个工厂，只不过会获取已经创建好的对象而不会重新创建新的对象。 单例模式类型懒汉式单例模式-非安全 1234567891011121314151617181920212223242526272829303132333435363738394041package com.design.pattern.singleton.lazynosafe;/** * LazyDoubleCheckSingleton 懒汉式-线程不安全 * * @author shunhua * @date 2019-10-02 */public class LazySingleton &#123; /** * 定义LazySingleton属性 */ private static LazySingleton lazySingleton = null; /** * 指定构造方法是私有的 */ private LazySingleton()&#123;&#125; /** * 全局控制点 * @return */ public static LazySingleton getInstance()&#123; /** * 在没有断点干预的情况下，多线程执行和CPU分配有关。为了更清楚的观看多线程执行，可以使用多线程debug来达到控制多个线程的目的 * * 在多线程下有以下几种可能，这里以两个线程解释，线程A和线程B * * 1 当线程B走到if(lazySingleton == null)时，线程A已经执行创建好了对象，此时线程B直接返回线程A创建的对象 * 2 当线程B走到if(lazySingleton == null)时，线程A还没有创建好对象即LazySingleton仍然为空，紧接着线程B的if判断通过，当A创建完对象准备返回lazySingleton即执行return lazySingleton时，线程B创建好了对象并赋值给lazySingleton，此时lazySingleton变量的值是线程B创建的对象引用，会覆盖线程A创建的对象对应的引用，最终线程A和线程B返回的虽然是指向同一个对象（线程B创建的）的引用，但是实质上对象已经创建了两次。 * 3 当线程B走到if(lazySingleton == null)时，线程A还没有创建好对象即LazySingleton仍然为空，仅接着线程B的if判断通过，线程A在线程B创建对象之前返回了，那么最终线程A和线程B都会创建对象，并且返回的对象引用不会相同，它们指向各自创建的对象。 * */ if(lazySingleton == null)&#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125; 123456789101112131415161718192021package com.design.pattern.singleton.lazynosafe;import lombok.extern.slf4j.Slf4j;/** * MyThread 实现Runnable接口，实现多线程 * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class MyThread implements Runnable &#123; @Override public void run() &#123; // 获取目标对象 LazySingleton lazySingleton = LazySingleton.getInstance(); // 打印当前执行的线程信息和目标对象信息 log.info(Thread.currentThread().getName() +\" \"+ lazySingleton); &#125;&#125; 懒汉式单例模式安全-锁粒度较大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.design.pattern.singleton.lazysafebutlockisbig;/** * LazyDoubleCheckSingleton 懒汉式-线程安全但是锁的粒度太大 * * @author shunhua * @date 2019-10-02 */public class LazySingleton &#123; /** * 定义LazySingleton属性 */ private static LazySingleton lazySingleton = null; /** * 指定构造方法是私有的 */ private LazySingleton()&#123;&#125; /** * 全局控制点 * * synchronize加锁的位置不同，线程持有的对象也会不同 * 1 加在静态方法上，持有的是类的class文件，即当前类 * 2 加在非静态方法上，持有的是堆内存中的对象，即执行当前方法的对象 * * @return */ public synchronized static LazySingleton getInstance()&#123; /** * synchronize加锁在静态方法上等同于锁代码块时LazySingleton.class作为持有对象： * * public static LazyDoubleCheckSingleton getInstance()&#123; * synchronized(LazyDoubleCheckSingleton.class)&#123; * if (lazySingleton == null) &#123; * lazySingleton = new LazyDoubleCheckSingleton(); * &#125; * &#125; * return lazySingleton; * &#125; */ if(lazySingleton == null)&#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125; 懒汉式单例模式-双重检锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.design.pattern.singleton.lazysafedoublecheck;/** * LazyDoubleCheckSingleton 双重检锁，兼顾了性能和线程安全 * * @author shunhua * @date 2019-10-03 */public class LazyDoubleCheckSingleton &#123; /** * 定义LazySingleton属性 ,这里加volatile关键字防止指令重排序和内存可见 */ private volatile static LazyDoubleCheckSingleton lazySingleton = null; /** * 指定构造方法是私有的 */ private LazyDoubleCheckSingleton()&#123;&#125; /** * 全局控制点 * * 双重检锁指的就是两次判断 * * @return */ public static LazyDoubleCheckSingleton getInstance()&#123; /** * 1 这一层if判断如果不使用也能保证线程安全，但是锁的粒度又回到了大粒度版本。使用这一层判断是为了缩小synchronized锁的粒度 * 2 引入了这一层会增加一个隐患-由于指令重排序，走到该层if判断lazySingleton可能确实不为空，但是它指向的对象可能还没有初始化完成，当使用这个对象的时候可能会导致系统异常 */ if(lazySingleton == null)&#123; /** * 加锁 */ synchronized (LazyDoubleCheckSingleton.class)&#123; /** * 这一层if必须要有，因为synchronized锁的粒度小了，不是整个方法，当出现线程进入第一个if块中但被阻塞在同步代码块外时（别的线程拿到了锁在里面创建对象）， * 如果不加该if判断该线程还会创建一个对象，而不会直接返回已经创建好的对象的引用。 */ if(lazySingleton == null)&#123; /** LazyDoubleCheckSingleton = new LazyDoubleCheckSingleton() JVM主要做的事粗略步骤如下： * * 1. 在堆空间里分配内存给这个对象 * 2. 执行构造方法进行初始化，注意此初始化不是类加载过程中的初始化 * 3. 设置lazySingleton指向分配好的内存地址 * 注意：在没有处理指令重排序的情况下2、3两步由于重排序可能步骤会倒置（因为Java语言规范，允许那些在单线程内不会改变单线程程序执行结果的重排序，因为有的重排序可以提高程序执行性能 ），这会可能会造成线程拿到的引用指向的是一个还没有初始化完成的对象，虽然不为空但它还没有执行构造方法，如果恰巧构造方法里面需要对某些参数进行初始化，当使用这个对象还没有初始化的参数时会导致系统异常 * * 详细的步骤如下： * 1. 当遇到new指令时，会先检查这个指定的参数也就是LazyDoubleCheckSingleton能否在常量池中定位到该类的符号引用，并且检查这个符号引用代表的类是否已经执行过类的加载（加载、解析、准备和初始化），如果没有就执行下一步，如果执行了接着虚拟机为新生对象分配内存（此时从虚拟机的视角来说一个新对象已经产生了），紧接着执行new指令执行之后的调用&lt;init&gt;方法。 * 2. 加载 （1 通过类的全限定名获取定义此类的二进制字节流 2 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构即Class中的常量池进入方法区的运行时常量池中 3 在方法区生成一个代表这个类的Class对象） * 3. 验证 （确保Class文件的字节流中包含的信息符合当前虚拟机的要求，确保虚拟机自身安全） * 4. 准备 （在方法区中为类变量分配内存并设置类变量初始值） * 5. 解析 （可能会发生，因为它也可能发生在初始化阶段之后。 主要作用就是将常量池中的符号引用替换为直接引用） * 6. 初始化 （这是类加载过程的最后一步，主要就是执行类构造器&lt;clinit&gt;方法，初始化类变量） * * 最后：设置lazySingleton指向分配好的内存地址 */ lazySingleton = new LazyDoubleCheckSingleton(); &#125; &#125; &#125; return lazySingleton; &#125;&#125; 枚举式单例模式 12345678910111213141516171819202122232425262728293031323334353637383940package com.design.pattern.singleton.enuminstance;/** * EnumInstance 使用枚举的方式实现单例模式 * * 1. 枚举实际上是一个继承Enum的被final修饰的类，它的构造方法（只有有参构造方法）也是私有的。其中枚举常量也是static final的，并且在static代码块中实例化（和恶汉式很像） * 2. 枚举实现的单例防止了序列化攻击（readObject方法执行获取的对象是已经存在的枚举常量）和反射攻击（枚举类的构造函数会判断，如果通过反射调用就抛出异常）以及线程安全 * 3. 推荐使用枚举实现单例 * * @author shunhua * @date 2019-10-03 */public enum EnumInstance &#123; /** * 枚举常量 */ INSTANCE; /** * 枚举的成员变量 */ private Object data; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; /** * 暴露给外部的全局点 * * @return */ public static EnumInstance getInstance() &#123; return INSTANCE; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.design.pattern.singleton.enuminstance;import lombok.extern.slf4j.Slf4j;import java.io.*;import java.lang.reflect.Constructor;/** * EnumInstanceTest * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class EnumInstanceTest &#123; public static void main(String[] args) &#123; EnumInstance instance = EnumInstance.getInstance(); instance.setData(new Object()); try &#123; //------------------ 枚举实现的单例，是不受序列化破坏的影响---------------------/ File file = new File(\"singleton\"); // 使用ObjectOutputStream对象输出流，把单例对象写入文件中。注意文件的后缀名带不带都行。如果不指定文件的路径，就默认使用当前工程的目录作为路径 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file)); // 将单例对象写入文件中 objectOutputStream.writeObject(instance); // 使用ObjectInputStream对象输入流，把文件中的单例对象读到内存中 ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file)); EnumInstance newInstance = (EnumInstance) objectInputStream.readObject(); /** readObject方法调用的核心方法：这个逻辑保证了取出的枚举对象的唯一性 private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException &#123; if (bin.readByte() != TC_ENUM) &#123; throw new InternalError(); &#125; ObjectStreamClass desc = readClassDesc(false); if (!desc.isEnum()) &#123; throw new InvalidClassException(\"non-enum class: \" + desc); &#125; int enumHandle = handles.assign(unshared ? unsharedMarker : null); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) &#123; handles.markException(enumHandle, resolveEx); &#125; // 获取枚举对象的名称，这个是唯一的，它对应一个枚举常量 String name = readString(false); Enum&lt;?&gt; result = null; // 获取枚举对象的Class Class&lt;?&gt; cl = desc.forClass(); if (cl != null) &#123; try &#123; // 通过枚举对象的Class和枚举对象的名称获取对应的枚举常量，没有创建新的对象 @SuppressWarnings(\"unchecked\") Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name); result = en; &#125; catch (IllegalArgumentException ex) &#123; throw (IOException) new InvalidObjectException( \"enum constant \" + name + \" does not exist in \" + cl).initCause(ex); &#125; if (!unshared) &#123; handles.setObject(enumHandle, result); &#125; &#125; handles.finish(enumHandle); passHandle = enumHandle; return result; &#125; */ log.info(\"instance: \" + instance); log.info(\"newInstance: \" + newInstance); log.info(String.format(\"instance [%s] newInstance\", instance == newInstance)); System.out.println(\"------------------------------------------\"); log.info(\"instance: \" + instance.getData()); log.info(\"newInstance: \" + newInstance.getData()); log.info(String.format(\"instance.data [%s] newInstance.data\", instance.getData() == newInstance.getData())); //-------------------------- 枚举实现的单例,不受反射破坏的影响， ----------------/ Class enumClass = EnumInstance.class; Constructor constructor = enumClass.getDeclaredConstructor(); constructor.setAccessible(true); /** * 通过反射调用枚举的构造器（构造器只有有参构造）会抛出异常，防止了反射攻击 */ &#125; catch (Exception e) &#123; log.info(e.getMessage()); &#125; &#125;&#125; 容器单例模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.design.pattern.singleton.containersingleton;import org.apache.commons.lang3.StringUtils;import org.springframework.util.ObjectUtils;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * ContainerSingleton 容器单例模式 * * 统一管理多个实例，节省资源 * * @author shunhua * @date 2019-10-03 */public class ContainerSingleton &#123; /** * 存放对象，相当于一个缓存 */ private static Map&lt;String,Object&gt; SINGLETON_MAP = new ConcurrentHashMap&lt;&gt;(); /** * 多线程情况下不安全，可能导致值的覆盖 * @param key * @param instance */ public static void putInstance(String key,Object instance)&#123; if(StringUtils.isNotBlank(key) &amp;&amp; !ObjectUtils.isEmpty(instance))&#123; if(!SINGLETON_MAP.containsKey(key))&#123; SINGLETON_MAP.put(key,instance); &#125; &#125; &#125; /** * 获取对象 * @param key * @return */ public static Object getInstance(String key)&#123; return SINGLETON_MAP.get(key); &#125;&#125; 饿汉式单例模式 1234567891011121314151617181920212223242526272829303132333435363738394041package com.design.pattern.singleton.hungry;/** * HungrySingleton 饿汉式 * &lt;p&gt; * 1 优点 * 写法简单，类加载（严格来说是类加载过程的初始化阶段以及调用构造函数）的时候就完成了对象的创建，避免了线程同步问题 * 2 缺点 * 类加载的时候就完成了对象的创建，没有延迟效果，如果类的对象从始至终都没有用过，或者只是想获取类的某个类变量，那么还是会创建对象，这无疑造成了内存的浪费 * * * @author shunhua * @date 2019-10-03 */public class HungrySingleton &#123; /** * 私有构造函数 */ private HungrySingleton() &#123; &#125; /** * 声明为final的变量必须在类加载完成时（准确的是类加载初始化的时候，singleton就需要被赋值即HungrySingleton对象的引用）就已经赋值 */ // private final static HungrySingleton singleton = new HungrySingleton(); private final static HungrySingleton singleton; static &#123; singleton = new HungrySingleton(); &#125; /** * 全局访问点 * @return */ public static HungrySingleton getInstance() &#123; return singleton; &#125;&#125; 破坏饿汉式单例-方式1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.design.pattern.singleton.reflectattackresolve;/** * HungrySingleton 饿汉式 * &lt;p&gt; * 1 优点 * 写法简单，类加载（严格来说是类加载过程的初始化阶段以及调用构造函数）的时候就完成了对象的创建，避免了线程同步问题 * 2 缺点 * 类加载的时候就完成了对象的创建，没有延迟效果，如果类的对象从始至终都没有用过，或者只是想获取类的某个类变量，那么还是会创建对象，这无疑造成了内存的浪费 * * * @author shunhua * @date 2019-10-03 */public class HungrySingleton &#123; // private final static HungrySingleton singleton = new HungrySingleton(); private final static HungrySingleton singleton; /** * 私有构造函数 */ private HungrySingleton() &#123; if(singleton == null)&#123; System.out.println(\"调用构造方法在赋值引用给singleton之前，这是指令重排序带来的可能\"); &#125;else &#123; System.out.println(\"调用构造方法在赋值引用给singleton之后，这是指令重排序带来的可能\"); &#125; &#125; /** * 声明为final的变量必须在类加载完成时（准确的是类加载初始化的时候，singleton就需要被赋值即HungrySingleton对象的引用）就已经赋值 */ static &#123; singleton = new HungrySingleton(); &#125; /** * 全局访问点 * @return */ public static HungrySingleton getInstance() &#123; return singleton; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.design.pattern.singleton.reflectattackresolve;import lombok.extern.slf4j.Slf4j;import java.lang.reflect.Constructor;/** * HungrySingletonTest * * 反射破坏单例模式不容易彻底阻止，没有特别好的方式。 * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class HungrySingletonTest &#123; /** * 对于在类加载的整个过程实例就能创建好的单例模式（恶汉式、静态内部类），为了防止反射攻击，可以在构造方法中进行判断，如果是通过反射创建对象就抛出异常 * * * @param args */ public static void main(String[] args) &#123; try &#123; // 获取hungrySingleton的Class对象 Class objectClass = HungrySingleton.class; // 通过全局访问点拿到单例对象 HungrySingleton instance = HungrySingleton.getInstance(); // 获取声明的构造器 Constructor constructor = objectClass.getDeclaredConstructor(); // 强制设置声明的构造器是可以访问的 constructor.setAccessible(true); // 通过构造器反射创建对象 HungrySingleton newInstance = (HungrySingleton) constructor.newInstance(); log.info(\"instance: \" + instance); log.info(\"newInstance： \" + newInstance); log.info(String.format(\"instance [%s] newInstance\",instance == newInstance)); &#125;catch (Exception e)&#123; log.info(e.getMessage()); &#125; &#125;&#125; 破坏饿汉式单例-方式2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.design.pattern.singleton.serializationdestroysingleton;import java.io.Serializable;/** * HungrySingleton 饿汉式 * &lt;p&gt; * 1 优点 * 写法简单，类加载（严格来说是类加载过程的初始化阶段以及调用构造函数）的时候就完成了对象的创建，避免了线程同步问题 * 2 缺点 * 类加载的时候就完成了对象的创建，没有延迟效果，如果类的对象从始至终都没有用过，或者只是想获取类的某个类变量，那么还是会创建对象，这无疑造成了内存的浪费 * 3 实现Serializable，为了实现序列化 * * @author shunhua * @date 2019-10-03 */public class HungrySingleton implements Serializable &#123; private static final long serialVersionUID = 1136799709809340054L; /** * 私有构造函数 */ private HungrySingleton() &#123; &#125; /** * 声明为final的变量必须在类加载完成时（准确的是类加载初始化的时候，singleton就需要被赋值即HungrySingleton对象的引用）就已经赋值 */ // private final static HungrySingleton singleton = new HungrySingleton(); private final static HungrySingleton singleton; static &#123; singleton = new HungrySingleton(); &#125; /** * 全局访问点 * @return */ public static HungrySingleton getInstance() &#123; return singleton; &#125; /** * 1. 对于使用序列化和反序列化产生新的实例的方式破坏了单例，可以在类中增加readResolve()方法来预防，readResolve（）方法返回单例对象即可 * 2. 这是反序列化机制决定的，在反序列化的时候会判断类如果实现了Serializable或者Externalizable接口又包含readResolve()方法的话，会直接 * 调用readResolve（）方法来获取实例。值得注意的是，readObject方法底层会先通过反射创建一个新的单例实例，然后再通过反射调用readResolve方 * 法获取单例对象。即虽然最后通过readResolve拿到的是已经创建好的对象，但本质上还是通过反射创建了一个新的对象，只是这个新的对象是用来调用readResolve方法 * 返回单例对象而已。 * * * @return */ public Object readResolve()&#123; return singleton; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.design.pattern.singleton.serializationdestroysingleton;import lombok.extern.slf4j.Slf4j;import java.io.*;/** * HungrySingletonTest * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class HungrySingletonTest &#123; public static void main(String[] args) &#123; HungrySingleton instance = HungrySingleton.getInstance(); try &#123; File file = new File(\"singleton\"); // 使用ObjectOutputStream对象输出流，把单例对象写入文件中。注意文件的后缀名带不带都行。如果不指定文件的路径，就默认使用当前工程的目录作为路径 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file)); // 将单例对象写入文件中 objectOutputStream.writeObject(instance); // 使用ObjectInputStream对象输入流，把文件中的单例对象读到内存中 ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file)); /** * * 如果HungrySingleton类实现了Serializable或者Externalizable接口，那么readObject方法底层会使用反射，调用ObjectStreamClass#newInstance方法创建一个新的单例对象, * 这个单例对象是为了调用它对应的类中的readResolve方法，如果没有实现那两个接口中的任何一个就会返回null。即接着会判断这个新创建的单例对象中有没有readResolve方法，如果 * 有就会通过反射调用这个readResolve方法，最终readObject方法返回的是readResolve方法返回的对象 * */ HungrySingleton newInstance = (HungrySingleton) objectInputStream.readObject(); log.info(\"instance: \" + instance); log.info(\"newInstance: \" + newInstance); log.info(String.format(\"instance [%s] newInstance\", instance == newInstance)); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 静态内部类的单例模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.design.pattern.singleton.staticinnerclass;/** * StaticInnerClassSingleton 静态内部类的单例模式 ，使用静态内部类也是做延迟初始化单例对象，来降低单例实例的开销即在需要的时候才进行初始化 * * @author shunhua * @date 2019-10-03 */public class StaticInnerClassSingleton &#123; /** * 私有构造器不能少，防止外部创建对象，让外部只能通过全局访问点拿到单例对象 */ private StaticInnerClassSingleton()&#123;&#125; /** * 1. 这个静态内部类要声明为私有的，因为创建对象在它里面，不能让外面访问它 * 2. 如果类没有初始化，需要类立即初始化的常见情况： * （1）new 一个对象 * （2）类中声明的静态方法被调用 * （3）类中声明的一个静态成员被赋值 * （4）类中声明的一个静态成员被使用，并且这个成员不是一个常量（被final修饰，已在编译期把结果放入常量池中的静态字段） * （5）对类进行反射调用 * （6）作为父类（包括接口），其子类被初始化了，那么父类需要先初始化 * （7）执行的主类（包含main方法的类） * * 3.使用静态内部类创建单例对象利用了类加载过程中的初始化阶段的特性： * 虚拟机会保证一个类的类构造器&lt;clinit&gt;方法在多线程环境中被正确地加类的对象初始化锁（这是JVM帮我们自动完成的）、同步，如果多个线程同时去初始化一个类， * 那么只会有一个线程去执行这个类的类构造器方法&lt;clinit&gt;，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;方法完毕。 * 因此，即使在多线程环境下执行 private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton()语句 * 也不需要关心指令重排序的情况，因为初始化阶段在对类变量赋值的时候只会有一个线程可以执行&lt;clinit&gt;方法，而单线程执行的情况下，指令是否重排序是没有影响的。 */ private static class InnerClass &#123; /** * 1. 初始化时，需要staticInnerClassSingleton赋值，即 new StaticInnerClassSingleton()会被执行。这些都是&lt;clinit&gt;方法执行的结果，而&lt;clinit&gt;方法在多线程环境下只会有一个线程执行，即使这个方法内部涉及重排序也关系。 * 2. 活跃线程初始化类（执行&lt;clinit&gt;方法）后,类已经初始化完成，不会再进行初始化，其他线程直接访问类成员即可 */ private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton(); &#125; /** * 全局访问点 * * 当执行getInstance方法时就去调用InnerClass内部类里面的staticInnerClassSingleton实例，此时InnerClass内部类会被加载到内存里，在类加载的时候就创建对象，和饿汉式一个道理，保证了只有一个实例， * 而且在调用getInstance方法时才进行单例的创建，又具有懒汉式的部分特性。 * @return */ public static StaticInnerClassSingleton getInstance() &#123; /** * 外部访问getInstance这个全局访问点时，会间接访问InnerClass的静态成员，这会导致静态内部类被初始化 */ return InnerClass.staticInnerClassSingleton; &#125;&#125; 单例模式在源码中的使用jdk-RunTime 12345678910111213141516171819202122232425262728293031package java.lang;import java.io.*;import java.util.StringTokenizer;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;/** * Every Java application has a single instance of class * &lt;code&gt;Runtime&lt;/code&gt; that allows the application to interface with * the environment in which the application is running. The current * runtime can be obtained from the &lt;code&gt;getRuntime&lt;/code&gt; method. * &lt;p&gt; * An application cannot create its own instance of this class. * * @author unascribed * @see java.lang.Runtime#getRuntime() * @since JDK1.0 */public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() &#123; return currentRuntime; &#125; private Runtime() &#123;&#125; // ... 省略其他方法&#125; Spring-AbstractFactoryBean 12345678910111213141516171819202122232425262728@Overridepublic final T getObject() throws Exception &#123; if (isSingleton()) &#123; return (this.initialized ? this.singletonInstance : getEarlySingletonInstance()); &#125; else &#123; return createInstance(); &#125;&#125;/** * Determine an 'early singleton' instance, exposed in case of a * circular reference. Not called in a non-circular scenario. */@SuppressWarnings(\"unchecked\")private T getEarlySingletonInstance() throws Exception &#123; Class&lt;?&gt;[] ifcs = getEarlySingletonInterfaces(); if (ifcs == null) &#123; throw new FactoryBeanNotInitializedException( getClass().getName() + \" does not support circular references\"); &#125; if (this.earlySingletonInstance == null) &#123; this.earlySingletonInstance = (T) Proxy.newProxyInstance( this.beanClassLoader, ifcs, new EarlySingletonInvocationHandler()); &#125; return this.earlySingletonInstance;&#125; MyBatis-ErrorContext 12345678910111213141516171819202122232425262728293031323334public class ErrorContext &#123; private static final String LINE_SEPARATOR = System.getProperty(\"line.separator\",\"\\n\"); // 基于ThreadLocal的单例模式，它不是整个应用全局唯一而是线程级别唯一，保证了每个线程各自的错误上下文 private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal&lt;&gt;(); private ErrorContext stored; private String resource; private String activity; private String object; private String message; private String sql; private Throwable cause; /** * 私有构造器 */ private ErrorContext() &#123; &#125; /** * 每个线程获取各自的对象 * @return */ public static ErrorContext instance() &#123; ErrorContext context = LOCAL.get(); if (context == null) &#123; context = new ErrorContext(); LOCAL.set(context); &#125; return context; &#125; // ... 等等&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"策略模式","slug":"design_pattern/behaviour_type/策略模式","date":"2019-09-27T16:00:00.000Z","updated":"2020-08-09T09:28:54.518Z","comments":true,"path":"posts/72e3b671/","link":"","permalink":"https://gentryhuang.com/posts/72e3b671/","excerpt":"","text":"定义定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户。即把不同的算法封装到不同的类里面，让它们之间可以相互替换， 应用层不会受到影响。 类型行为型 使用场景12341 系统有很多类，而他们的区别仅仅在于它们的行为不同 - 使用策略模式就可以动态地让一个对象在多个行为中选择一种行为，也就是说我们把这个对象不同的行为放到不同的类里面，而每一种行为对应着一种策略2 一个系统需要动态地在几种算法中选择一种 - 这里算法就是策略，策略里面封装的就是一系列逻辑以及计算方式 优点1234561 符合开闭原则 - 策略模式提供了对开闭原则的完美支持，我们可以在不修改原有系统的基础上选择具体的行为2 避免使用多重条件转移语句 - 大量的if...else, switch。 我们把具体的策略行为分离为一个一个的单独的类来替换if...else里面的逻辑，这样写也可以降低代码的耦合3 提高算法的保密性和安全性 - 在使用的时候我们只知道策略的功能，不需要知道具体的细节。在具体的策略类中封装了不同的行为和算法以及相关的数据结构，对于应用层来说，是不需要知道内部的细节的。比如使用Dubbo的服务提供者，不需要知道内部逻辑的细节。 缺点121 应用层必须知道所有的策略类，并自行决定使用哪一个策略类2 产生很多策略类 策略模式相关的设计模式策略模式和工厂模式 121 工厂模式是创建型的设计模式，策略模式是行为型的设计模式2 工厂模式接受指令，创建符合要求的对象。策略模式接受创建好的对象，从而实现不同的行为 策略模式和状态模式 121 使用策略模式的时候，应用层需要知道应该选择哪一种策略。在使用状态模式的时候，应用层是不需要关心具体的状态，这些状态会自动转换2 如果系统中某个类的对象存在多种状态，不同状态下行为又有差异，而且这些状态可以发生转换时可以使用状态模式。如果系统中某个类的某种行为存在多种实现方式，如促销是个行为，这种行为就有多种实现方式，这种情况下应该使用策略模式。 简单需求当当网在双十一或者618的时候会有很多的促销活动，促销是书籍的一个行为，这个促销行为有多种实现。 策略模式演练最基本的使用 策略父类型（这里是接口的方式） 12345678910111213package com.design.pattern.strategy.base;/** * PromotionStrategy 促销策略父类型 * @author shunhua * @date 2019-09-28 */public interface PromotionStrategy &#123; /** * 进行促销 */ void doPromotion();&#125; 具体策略实例 发现策略 123456789101112131415161718192021package com.design.pattern.strategy.base;import lombok.extern.slf4j.Slf4j;/** * FanXianPromotionStrategy 返现（支付金额达到一定数额进行返现到账号）策略 * * @author shunhua * @date 2019-09-28 */@Slf4jpublic class FanXianPromotionStrategy implements PromotionStrategy &#123; /** * 促销 */ @Override public void doPromotion() &#123; log.info(\"返现促销，返回的金额存放到账号的余额中\"); &#125;&#125; 立减优惠策略 123456789101112131415161718192021package com.design.pattern.strategy.base;import lombok.extern.slf4j.Slf4j;/** * LiJianPromotionStrategy 立减（下单立减一定的金额）策略 * * @author shunhua * @date 2019-09-28 */@Slf4jpublic class LiJianPromotionStrategy implements PromotionStrategy &#123; /** * 促销 */ @Override public void doPromotion() &#123; log.info(\"立减促销，书籍的价格直接减去立减活动设置的价格\"); &#125;&#125; 满减策略 123456789101112131415161718192021package com.design.pattern.strategy.base;import lombok.extern.slf4j.Slf4j;/** * ManJianPromotionStrategy 满减（当支付金额达到规定的最低数就进行优惠）策略 * * @author shunhua * @date 2019-09-28 */@Slf4jpublic class ManJianPromotionStrategy implements PromotionStrategy &#123; /** * 促销 */ @Override public void doPromotion() &#123; log.info(\"满减促销，满200减50\"); &#125;&#125; 策略包装类 1234567891011121314151617181920212223242526package com.design.pattern.strategy.base;/** * PromotionActivity 促销活动，包装（使用）策略模式 * * @author shunhua * @date 2019-09-28 */public class PromotionActivity &#123; /** * 促销策略 */ private PromotionStrategy promotionStrategy; public PromotionActivity(PromotionStrategy promotionStrategy)&#123; this.promotionStrategy = promotionStrategy; &#125; /** * 执行具体的促销策略 */ public void execute()&#123; promotionStrategy.doPromotion(); &#125;&#125; 应用层 12345678910111213141516171819202122232425262728293031package com.design.pattern.strategy.base;import com.design.pattern.strategy.base.FanXianPromotionStrategy;import com.design.pattern.strategy.base.ManJianPromotionStrategy;import com.design.pattern.strategy.base.PromotionActivity;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-28 */public class Client &#123; @Test public void test()&#123; /** * 618满减活动策略 */ PromotionActivity activity618 = new PromotionActivity(new ManJianPromotionStrategy()); /** * 双11 返现活动策略 */ PromotionActivity activity11 = new PromotionActivity(new FanXianPromotionStrategy()); activity618.execute(); activity11.execute(); &#125;&#125; 小结 1这是策略模式的简单使用，整体上扩展性比较好，想增加策略很方便。 基本使用演进应用层 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.strategy.v1;import org.junit.Test;import org.springframework.util.ObjectUtils;/** * Client * * @author shunhua * @date 2019-09-28 */public class Client &#123; @Test public void test()&#123; PromotionActivity activity ; // 应用层参数 String promotion = \"FANXIAN\"; switch (promotion)&#123; case \"FANXIAN\" : activity = new PromotionActivity(new FanXianPromotionStrategy()); break; case \"LIJIAN\": activity = new PromotionActivity(new LiJianPromotionStrategy()); break; case \"MANJIAN\": activity = new PromotionActivity(new ManJianPromotionStrategy()); break; default: activity = null; &#125; if(!ObjectUtils.isEmpty(activity))&#123; activity.execute(); &#125; &#125;&#125; 小结 12这种方式和应用交互容易使代码过于臃肿，因为每次需要的时候都会创建策略对象和包装策略的对象，并且过多的选择判断，整个代码看起来不优雅。 优化后版本策略工厂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.design.pattern.strategy.v2;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * PromotionStrategyFactory 促销策略工厂 * * @author shunhua * @date 2019-09-28 */public class PromotionStrategyFactory &#123; /** * 策略集合 */ private final static Map&lt;String,PromotionStrategy&gt; PROMOTION_STRATEGY_MAP = new ConcurrentHashMap&lt;&gt;(); /** * 类加载的时候就开始创建对象 */ static &#123; PROMOTION_STRATEGY_MAP.put(PromotionKey.LIJIAN_STRATEGY,new LiJianPromotionStrategy()); PROMOTION_STRATEGY_MAP.put(PromotionKey.FANXIAN_STRATEGY,new FanXianPromotionStrategy()); PROMOTION_STRATEGY_MAP.put(PromotionKey.MANJIAN_STRATEGY,new ManJianPromotionStrategy()); &#125; /** * 单例的 */ private PromotionStrategyFactory()&#123;&#125; /** * 根据策略模式名获取对应的策略 * @param strategy * @return */ public static PromotionStrategy getPromotionStrategy(String strategy)&#123; return PROMOTION_STRATEGY_MAP.get(strategy); &#125; private interface PromotionKey&#123; /** * 立减策略 */ String LIJIAN_STRATEGY = \"LIJIAN\"; /** * 满减策略 */ String MANJIAN_STRATEGY = \"LIJIAN\"; /** * 返现策略 */ String FANXIAN_STRATEGY = \"FANXIAN\"; &#125;&#125; 应用层 123456789101112131415161718192021222324package com.design.pattern.strategy.v2;import org.junit.Test;import org.springframework.util.ObjectUtils;/** * Client * * @author shunhua * @date 2019-09-28 */public class Client &#123; @Test public void test()&#123; // 应用层参数 String promotion = \"FANXIAN\"; // 使用工厂模式 PromotionActivity activity = new PromotionActivity(PromotionStrategyFactory.getPromotionStrategy(promotion)); if(!ObjectUtils.isEmpty(activity))&#123; activity.execute(); &#125; &#125;&#125; 小结 121. 使用策略工厂防止策略对象频繁创建2. 策略模式常常结合单例、工厂以及享元模式等使用 策略模式源码解析jdk的Comparator 1Comparator就是一个比较策略接口，它有很多的实现，也支持自定义策略，这些策略实现就是一个个策略。 12345678910111213141516171819 /** * 排序会根据具体的排序策略执行 * @since 1.8 */@SuppressWarnings(\"unchecked\")public static &lt;T&gt; void parallelSort(T[] a, Comparator&lt;? super T&gt; cmp) &#123; if (cmp == null) cmp = NaturalOrder.INSTANCE; int n = a.length, p, g; if (n &lt;= MIN_ARRAY_SORT_GRAN || (p = ForkJoinPool.getCommonPoolParallelism()) == 1) TimSort.sort(a, 0, n, cmp, null, 0, 0); else new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt; (null, a, (T[])Array.newInstance(a.getClass().getComponentType(), n), 0, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ? MIN_ARRAY_SORT_GRAN : g, cmp).invoke(); &#125; Spring的Resource 1Resource是资源访问接口，它就是一个资源访问相关的策略接口，它有很多的实现类，也就意味着有很多访问资源的策略。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.springframework.core.io;import java.io.File;import java.io.IOException;import java.net.URI;import java.net.URL;import java.nio.channels.Channels;import java.nio.channels.ReadableByteChannel;import org.springframework.lang.Nullable;public interface Resource extends InputStreamSource &#123; boolean exists(); default boolean isReadable() &#123; return this.exists(); &#125; default boolean isOpen() &#123; return false; &#125; default boolean isFile() &#123; return false; &#125; URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; default ReadableByteChannel readableChannel() throws IOException &#123; return Channels.newChannel(this.getInputStream()); &#125; long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String var1) throws IOException; @Nullable String getFilename(); String getDescription();&#125; Spring的InstantiationStrategy 1Spring初始化策略接口，它的实现类：SimpleInstantiationStrategy和CglibSubclassingInstantiationStrategy初始化策略","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"模版方法模式","slug":"design_pattern/behaviour_type/模版方法模式","date":"2019-09-26T16:00:00.000Z","updated":"2020-08-09T09:27:55.252Z","comments":true,"path":"posts/5029c2a3/","link":"","permalink":"https://gentryhuang.com/posts/5029c2a3/","excerpt":"","text":"定义定义了一个算法的骨架，并允许子类为一个或多个步骤提供实现。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。 类型行为型 使用场景12◆ 各子类中公共的行为被提取出来并集中到一个公共父类中，从而避免代码重复◆ 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现 优点123◆提高复用性（将相同代码部分放到抽象父类中）◆提高扩展性◆符合开闭原则 缺点123◆继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍◆类数目增加◆增加了系统实现的复杂度 模版方法扩展 模版方法中有一个定义：钩子方法。它提供了缺省的行为，子类可以在必要时进行扩展，利用它和父类交互。即构造方法是这个模版对子类更进一步的开放以及扩展。 相关的设计模式模版方法模式和工厂方法模式 工厂方法是模版方法的一种特殊实现 模版方法模式和策略模式 模版方法模式不改变算法流程，策略模式可以改变算法流程，并且策略方法之间是可以相互替换的。策略模式的目的是使不同的算法可以相互替换，并且不影响应用层客户端的使用。模板方法模式是针对定义一个算法的流程，将一些不太一样的具体步骤交给子类去实现。 简单需求某机构要制作一门课程，制作这个课程需要一定的步骤，由于课程的种类不同可能某个步骤不同，但是整体步骤都是一致的。 模版方法演练 抽象课程类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.design.pattern.template;import lombok.extern.slf4j.Slf4j;/** * Course 课程抽象类 * * @author shunhua * @date 2019-09-27 */@Slf4jpublic abstract class Course &#123; /** * 模版方法 定义流程的 * 1 该方法的流程是固定的，有些步骤的细节可能因子类不同 * 2 该方法必须申明为final，子类不能重写。 */ protected final void makeCourse()&#123; // 制作PPT makePPT(); // 制作视频 makeVideo(); // 通过构造方法实现所需逻辑 if(needMakeArticle())&#123; // 编写手稿 makeArticle(); &#125; // 打包课程上线 packageCourse(); &#125; /** * 制作PPT是共有的方法，因此是固定的，子类不需要有自己的实现 */ final void makePPT()&#123; log.info(\"制作ppt\"); &#125; /** * 制作视频是共有的方法，因此是固定的，子类不需要有自己的实现 */ final void makeVideo()&#123; log.info(\"制作视频\"); &#125; /** * 编写手记，这个是固定的不需要之类有自己的实现，不过它不一定是共有的，需要看情况 */ final void makeArticle()&#123; log.info(\"编写手记\"); &#125; /** * 钩子方法 子类可以重写用来跟父类交互的。默认是false，不需要手记 */ protected boolean needMakeArticle()&#123; return false; &#125; /** * 打包课程的方法，不同的课程可能包装的不一样，根据子类情况重写 */ abstract void packageCourse();&#125; 课程类1 123456789101112131415161718192021package com.design.pattern.template;import lombok.extern.slf4j.Slf4j;/** * FECourse * * @author shunhua * @date 2019-09-27 */@Slf4jpublic class FECourse extends Course &#123; /** * 重写打包课程的方法 */ @Override void packageCourse() &#123; log.info(\"提供前端课程的源代码和图片素材\"); &#125;&#125; 课程类2 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.template;import lombok.extern.slf4j.Slf4j;/** * JvmCource * * @author shunhua * @date 2019-09-27 */@Slf4jpublic class JvmCource extends Course &#123; private boolean flag = Boolean.FALSE; /** * 通过构造方法设置钩子方法的参数，把钩子方法开放给客户端更加灵活 * * @param flag */ public JvmCource(boolean flag)&#123; this.flag = flag; &#125; @Override void packageCourse() &#123; log.info(\"Jvm课程提供调优工具软件包\"); &#125; /** * 使用钩子方法来和父类交互，增加自己的逻辑 * @return */ @Override protected boolean needMakeArticle() &#123; return flag; &#125;&#125; 客户端 1234567891011121314151617181920212223package com.design.pattern.template;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-27 */public class Client &#123; @Test public void test()&#123; Course jvmCourse = new JvmCource(Boolean.TRUE); jvmCourse.makeCourse(); Course feCourse = new FECourse(); feCourse.makeCourse(); &#125;&#125; 模版方法模式源码解析AbstractList(父)-ArrayList(子)AbstractList 1234567public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;//get方法为抽象方法，完全交给子类去实现abstract public E get(int index);&#125; ArrayList 12345678910public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;//子类来实现get方法 public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125;&#125; 同理：AbstractSet、AbstractMap同样采用了模版方法模式 HttpServlet1我们一般继承HttpServlet，然后重写doGet或者doPost等doXxx方法，HttpServlet中定义了一套模版，只要覆写这些方法即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod();if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn't support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125;&#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp);&#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(\"http.method_not_implemented\"); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);&#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"迭代器模式","slug":"design_pattern/behaviour_type/迭代器模式","date":"2019-09-26T16:00:00.000Z","updated":"2020-08-09T09:31:35.235Z","comments":true,"path":"posts/9055d217/","link":"","permalink":"https://gentryhuang.com/posts/9055d217/","excerpt":"","text":"定义提供一种方法，顺序访问一个集合对象中的各个元素，而又不暴露该对象的内部细节。 类型行为型 适用场景121 访问一个集合对象的内容而无需暴露它的内部表示2 为遍历不同的集合结构提供一个统一的接口 优点1分离了集合对象的遍历行为，因为抽象出了迭代器来遍历对象，这样就可以通过迭代器来访问集合对象内部元素了。 缺点1类的个数成对增加，由于迭代器模式是将存储数据和遍历数据这个两个职责进行分离，所以当新出现一种集合类就需要增加一种新的对应的迭代器。这样类的个数增加，这在一定程度上增加了系统的复杂性。 迭代器相关的设计模式迭代器模式和访问者模式 121 这两者都是迭代地访问集合对象中的各个元素2 访问者模式中扩展开放的部分在作用于对象的操作上，而在迭代器模式中扩展开放的部分是在集合对象的种类上 说明迭代器模式在日常开发中一般不会自己写，除非我们定义自己的数据结构，然后为这个数据结构实现对应的迭代器。 简单需求课程的增加和删除以及迭代该课程集 迭代器模式演练s 实体类 1234567891011121314151617181920package com.design.pattern.iterator.v2;import lombok.AllArgsConstructor;import lombok.Data;/** * Course 相当于集合中的元素 * * @author shunhua * @date 2019-09-27 */@Data@AllArgsConstructorpublic class Course &#123; /** * 课程的名字 */ private String name;&#125; 集合类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.design.pattern.iterator.v2;import java.util.ArrayList;import java.util.List;/** * MyCollection * * @author shunhua * @date 2019-09-27 */public class MyCollection&lt;T&gt; &#123; /** * 元素集合 */ private final List&lt;T&gt; list = new ArrayList&lt;&gt;(); /** * 增加元素 * @param item */ public void add(T item)&#123; list.add(item); &#125; /** * 移出元素 */ public void remove(T item)&#123; this.list.remove(item); &#125; /** * 删除所有元素 */ public void removeAll()&#123; this.list.removeAll(list); &#125; /** * 获取迭代器，注意需要把实体对象列表传给迭代器 * @return */ public MyIterator iterator()&#123; return new MyIterator(list); &#125;&#125; 迭代器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.design.pattern.iterator.v2;import java.util.List;/** * MyIterator * * @author shunhua * @date 2019-09-27 */public class MyIterator&lt;T&gt; &#123; /** * 集合 */ private List&lt;T&gt; list ; /** * 游标 */ private int position; /** * 集合中的元素 */ private T item; public MyIterator(List&lt;T&gt; list)&#123; this.list = list; &#125; /** * 是否有下一个元素 * @return */ public boolean hasNext()&#123; if( this.position &lt; list.size())&#123; return true; &#125; return false; &#125; /** * 迭代元素 * @return */ public T next()&#123; T item = list.get(position); position ++; return item; &#125;&#125; 应用层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.design.pattern.iterator.v2;import com.design.pattern.iterator.v1.Course;import com.design.pattern.iterator.v1.CourseHandler;import com.design.pattern.iterator.v1.CourseHandlerImpl;import com.design.pattern.iterator.v1.CourseIterator;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-27 */@Slf4jpublic class Client &#123; @Test public void test() &#123; Course course1 = new Course(\"Java从入门到放弃\"); Course course2 = new Course(\"MySql从删库到跑路\"); Course course3 = new Course(\"Python从入门到精通\"); MyCollection&lt;Course&gt; collection = new MyCollection(); collection.add(course1); collection.add(course2); collection.add(course3); log.info(\"----------课程列表-------------\"); printCourses(collection); collection.remove(course1); log.info(\"----------删除操作之后的课程---- \"); printCourses(collection); &#125; private void printCourses(MyCollection collection) &#123; MyIterator iterator = collection.iterator(); while (iterator.hasNext()) &#123; Course course = (Course) iterator.next(); log.info(course.toString()); &#125; &#125;&#125; 迭代器模式源码解析ArrayList的迭代器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** ArrayList的内部类实现了Iterator * An optimized version of AbstractList.Itr */private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"组合模式","slug":"design_pattern/structure_type/组合模式","date":"2019-09-23T16:00:00.000Z","updated":"2020-08-09T09:36:05.220Z","comments":true,"path":"posts/df879792/","link":"","permalink":"https://gentryhuang.com/posts/df879792/","excerpt":"","text":"定义将对象组合成树形结构以表示“部分-整体”的层次结构。作用是使客户端对单个对象和组合对象保持一致的方式处理。组合模式就是将多个对象组合成一个对象（这些对象具有相同的类型，使用它们的父类型作为统一的对象供客户端访问），简化了对多个对象的访问 类型结构型 使用场景121. 希望客户端可以忽略组合对象与单个对象的差异时2. 处理一个树形结构时 优点1234◆清楚地定义了分层次的复杂对象，表示对象的全部或部分层次◆让客户端忽略了层次的差异，方便对整个层次结构进行控制◆简化客户端代码◆符合开闭原则 缺点121. 限制类型时会较为复杂，因为它们都具有相同的父类型2. 使设计变得更加抽象 相关的设计模式组合模式和访问者模式 可以用访问模式访问组合模式的递归结构 简单需求课程分为不同的类型，每一种类型对应一个课程目录，课程目录下又有很多的课程，要求打印出课程的结构 组合模式的演练 1我们可以通过行为方法进行识别组合模式，组合模式是将相同的抽象类类型或者接口类型转为相同的树状结构，使用抽象作为访问的入口。叶子对象（单个对象）和组合好的对象（包含叶子对象的集合）都要继承或实现相同的父类，这样组合模式才能将它们进行统一处理。 统一抽象类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.design.pattern.composite;/** * 1. 方法中的抛出异常处理，是体现方法不能被使用，因为课程和课程目录使用的方法不同 * 2. 课程和课程目录使用统一类型供客户端访问 * @author shunhua * @date 2019-09-24 */public abstract class CourseComponet &#123; /** * 扩展课程目录 * @param courseComponet */ public void addCatalog(CourseComponet courseComponet)&#123; throw new UnsupportedOperationException(\"不支持添加课程目录操作\"); &#125; /** * 删除课程目录 * @param courseComponet */ public void removeCatalog(CourseComponet courseComponet)&#123; throw new UnsupportedOperationException(\"不支持删除课程目录操作\"); &#125; /** * 获取课程名称 * @param courseComponet * @return */ public String getName(CourseComponet courseComponet)&#123; throw new UnsupportedOperationException(\"不支持获取课程名称操作\"); &#125; /** * 获取课程价格 * @param courseComponet * @return */ public double getPrice(CourseComponet courseComponet)&#123; throw new UnsupportedOperationException(\"不支持获取课程价格操作\"); &#125; /** * 打印信息 */ public void print()&#123; throw new UnsupportedOperationException(\"不支持打印操作\"); &#125;&#125; 课程类 1234567891011121314151617181920212223242526272829303132333435363738394041package com.design.pattern.composite;import lombok.extern.slf4j.Slf4j;&#x2F;** * Course 课程类 * * @author shunhua * @date 2019-09-24 *&#x2F;@Slf4jpublic class Course extends CourseComponet &#123; &#x2F;** * 课程名 *&#x2F; private String courseName; &#x2F;** * 课程价格 *&#x2F; private double price; public Course(String courseName, double price) &#123; this.courseName &#x3D; courseName; this.price &#x3D; price; &#125; @Override public String getName(CourseComponet courseComponet) &#123; return this.courseName; &#125; @Override public double getPrice(CourseComponet courseComponet) &#123; return this.price; &#125; @Override public void print() &#123; log.info(&quot;课程名：&quot; + courseName + &quot;, 课程价格：&quot; + price); &#125;&#125; 课程目录类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.design.pattern.composite;import lombok.extern.slf4j.Slf4j;import java.util.ArrayList;import java.util.List;/** * CourseCatalog 课程目录类 * * @author shunhua * @date 2019-09-24 */@Slf4jpublic class CourseCatalog extends CourseComponet &#123; /** * 课程目录下的课程集合 ，这里使用统一抽象类型表示，这里就组合了课程对象 */ private List&lt;CourseComponet&gt; items = new ArrayList&lt;&gt;(); /** * 课程目录名 */ private String catalogName; public CourseCatalog(String catalogName)&#123; this.catalogName = catalogName; &#125; /** * 为课程目录添加课程 * @param courseComponet */ @Override public void addCatalog(CourseComponet courseComponet) &#123; this.items.add(courseComponet); &#125; /** * 删除课程目录中的课程 * @param courseComponet */ @Override public void removeCatalog(CourseComponet courseComponet) &#123; this.items.remove(courseComponet); &#125; @Override public String getName(CourseComponet courseComponet) &#123; return this.catalogName; &#125; /** * 打印目录以及目录下的课程 */ @Override public void print() &#123; log.info(catalogName); for(CourseComponet courseComponet : items)&#123; courseComponet.print(); &#125; &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930313233package com.design.pattern.composite;import org.junit.Test;&#x2F;** * Client 课程目录和课程，对客户端来说都是一个类型的对象 * * @author shunhua * @date 2019-09-24 *&#x2F;public class Client &#123; @Test public void test()&#123; CourseComponet catalog &#x3D; new CourseCatalog(&quot;课程顶级目录&quot;); CourseComponet linuxCourse &#x3D; new Course(&quot;鸟哥私房菜&quot;,80); CourseComponet gitCourse &#x3D; new Course(&quot;Git权威指南&quot;,120); CourseComponet javaCatalog &#x3D; new CourseCatalog(&quot;Java课程目录&quot;); CourseComponet spring &#x3D; new Course(&quot;Spring实战&quot;,70); CourseComponet mybatis &#x3D; new Course(&quot;MyBatis技术内幕&quot;,60); javaCatalog.addCatalog(spring); javaCatalog.addCatalog(mybatis); catalog.addCatalog(linuxCourse); catalog.addCatalog(gitCourse); catalog.addCatalog(javaCatalog); &#x2F;&#x2F; 打印课程目录以及目录下的课程列表 catalog.print(); &#125;&#125; 组合模式源码解析jdk源码之HashMap 1234567891011121314151617181920212223242526272829303132public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; /** * 方法的入参是Map类型，使用Map类型作为统一的接收参数，不需要关注任何之类型的对象 */ public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; if (table == EMPTY_TABLE) &#123; inflateTable((int) Math.max(numKeysToBeAdded * loadFactor, threshold)); &#125; if (numKeysToBeAdded &gt; threshold) &#123; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); &#125; for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue()); &#125;&#125; jdk源码之ArrayList 1234567891011/** * 方法的入参使用统一的父类型Collection，客户端不需要关注具体的子类型对象 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; MyBatis源码之SqlNode 12MyBatis的sql语句会被解析成不同的SqlNode类型的对象，这些对象都实现了SqlNode。其中MixedSqlNode是联系不同的SqlNode的一个核心对象，组合模式可以统一处理的它们。 12345678910111213141516171819202122package org.apache.ibatis.scripting.xmltags;import java.util.List;public class MixedSqlNode implements SqlNode &#123; /** * SqlNode不同实现的集合 */ private final List&lt;SqlNode&gt; contents; public MixedSqlNode(List&lt;SqlNode&gt; contents) &#123; this.contents = contents; &#125; @Override public boolean apply(DynamicContext context) &#123; for (SqlNode sqlNode : contents) &#123; sqlNode.apply(context); &#125; return true; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"享元模式","slug":"design_pattern/structure_type/享元模式","date":"2019-09-22T16:00:00.000Z","updated":"2020-08-09T09:33:14.983Z","comments":true,"path":"posts/e19da94a/","link":"","permalink":"https://gentryhuang.com/posts/e19da94a/","excerpt":"","text":"定义提供了减少对象数量从而改善应用的对象结构的方式。运用共享技术有效地支持大量细粒度的对象。即减少创建对象的数量，共享对象，从而减少内存的占用并且提高性能 。注意：享元模式重要的就是共享。 类型结构型 应用场景1234◆ 常常应用于系统底层的开发，以便解决系统的性能问题 如String类型就是使用了享元模式，String对象存在即返回，没有就创建然后放入到字符串常量池中。再比如数据库连接池，里面都是创建好的数据库连接，需要的时候拿来用不需要的时候归还回去。即系统中如果有大量的对象，可能会造成内存溢出，我们可以把共同的部分抽象出来，有相同的业务请求，则返回在内存中的已有对象，避免重新创建◆ 系统有大量相似对象、需要缓冲池的场景 某个对象的复用度越高，越倾向于使用享元模式 优点12◆减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率◆减少内存之外的其他资源占用(时间资源、文件句柄、窗口句柄等) 缺点1234◆关注内&#x2F;外部状态、关注线程安全问题 我们使用共享模式的时候，大都是使用hashMap，不会用HashTable（因为hashTable会由于同步锁造成效率过低，这样得不偿失），这样就需要在有些场景下关注线程安全问题。同时还要关注内、外部状态。◆使系统、程序的逻辑复杂化 使用了享元对象提高了系统的复杂度，还要分离内外不状态，并且外部状态不应该随着内部状态的变化而变化，否则系统就混乱了。 扩展内部状态 1在享元模式内部并且不会随着环境改变而改变的共享部分；无论外部环境如何变化，我都不变，并且该状态在享元模式内部。可理解为是享元对象的一个属性，这个属性不会与外部交互。 外部状态 1随着环境改变而改变的就是外部状态，这种状态是不可以共享的状态，并且记录在享元模式的外部。可理解为享元对象的一个可以和外界交互的属性，它会随时发生改变。 相关设计模式享元模式和代理模式 1代理模式是代理一个类，如果生成这个代理类花的资源和时间比较多，可以使用享元模式处理这个类的速度 享元模式和单例模式 1容器单例是两种方式的一种结合。享元模式是一种复用对象的思想 简单需求年终了，研发部门Leader可能需要多次地去汇报工作情况，已经有报告结果的就不需要再整理报告了，直接拿到报告就可以去汇报了。没有做过汇报的就需要先整理报告。 享元模式演练 报告 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.flyweight;import lombok.Data;import lombok.extern.slf4j.Slf4j;/** * Presentation 报告类 * * @author shunhua * @date 2019-09-23 */@Data@Slf4jpublic class Presentation &#123; /** * 报告相关部门 */ private String department; /** * 汇报内容 */ private String content; /** * 通过外部状态属性进行构造 * @param department */ public Presentation(String department)&#123; this.department = department; &#125; /** * 报告内容 */ public void report() &#123; log.info(content); &#125;&#125; 报告工厂 1234567891011121314151617181920212223242526272829303132333435363738394041package com.design.pattern.flyweight;import lombok.extern.slf4j.Slf4j;import org.springframework.util.ObjectUtils;import java.util.HashMap;import java.util.Map;/** * PresentationFactory 报告工厂 * * @author shunhua * @date 2019-09-23 */@Slf4jpublic class PresentationFactory &#123; /** * 此处应用了 final修饰 引用成员变量，引用对象的内容可以修改，但是引用地址不可以修改。这里作为报告池。 */ private static final Map&lt;String,Presentation&gt; PRESENTATION_MAP = new HashMap&lt;&gt;(16); /** * 这里不考虑安全问题 * @param department * @return */ public static Presentation getPresentation(String department)&#123; // 先从报告池中获取 Presentation leaderPresentation = PRESENTATION_MAP.get(department); // 报告池中没有再创建一个，然后放到报告池中 if(ObjectUtils.isEmpty(leaderPresentation))&#123; leaderPresentation = new Presentation(department); log.info(\"----------- 报告池中没有需先创建----------\"); PRESENTATION_MAP.put(department,leaderPresentation); leaderPresentation.setContent(\"部门：\" + department +\" 汇报...\"); leaderPresentation.report(); &#125; return leaderPresentation; &#125;&#125; 客户端 12345678910111213141516171819202122package com.design.pattern.flyweight;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-23 */public class Client &#123; private final String presentation[] = &#123;\"业务部\",\"研发部\",\"管理部\"&#125;; @Test public void test()&#123; for(int i = 0; i &lt; 20; i++)&#123; String department = presentation[(int)(Math.random() * presentation.length)]; Presentation leaderPresentation = PresentationFactory.getPresentation(department); leaderPresentation.report(); &#125; &#125;&#125; 享元模式源码解析Integer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public final class Integer extends Number implements Comparable&lt;Integer&gt; &#123; /** * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * 如果传入的数值在缓存的-127和128之间，那么都会在cache中，否则的话，会new出新的对象，这也是为什么100==100为true，1000==1000为false * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */ public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125;/** 只要在-128-127，使用 == 判断是可以的，不再这个范围就不能使用==,需要使用equqls * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * */ private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"桥接模式","slug":"design_pattern/structure_type/桥接模式","date":"2019-09-20T16:00:00.000Z","updated":"2020-08-09T09:35:41.268Z","comments":true,"path":"posts/563268dc/","link":"","permalink":"https://gentryhuang.com/posts/563268dc/","excerpt":"","text":"定义将抽象部分与它的具体实现部分分离开来，使它们都可以独立地变化（这在一定程度上实现解耦）。桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，防止类爆炸。从它的命名可以看出，bridge是桥梁的意思， 将桥两边联系起来。目的就是把两个不同的类之间建立联系，而两个类之间建立联系的方式有很多，而桥接模式是通过组合的方式建立两个不同类之间的关系，而不是继承。这也符合合成复用原则：优先通过组合的方式建立两个类之间联系，而不是继承，继承过多会发生类爆炸的情况。说明一点:这里说的抽象部分和具体实现部分，并不局限一个是抽象的，另一个是具体的实现，这只是从概念上去定义。 1将抽象部分与它的具体实现部分分离，其实这并不是将抽象类与他的派生类分离，而是抽象类和它的派生类用来实现自己的对象。或者说在一个系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化。 类型结构型 适用场景 抽象和具体实现之间增加更多的灵活性 1使用桥接模式就可以避免在这两个层次之间建立静态的继承关系，而是建立关联关系。此外，抽象部分和具体实现部分，它们都可以分别通过继承关系独立扩展，并且互不影响，就可以动态地将一个抽象化子类的对象和一个具体实现化子类的对象进行组合，这样就把抽象化角色和具体实现化角色实现了解耦。 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展 1抽象的部分可以独立扩展，具体实现也可以独立扩展 不希望使用继承，或因为多层继承导致系统类的个数剧增 优点 分离抽象部分及其具体实现部分 1因为桥接模式使用了组合，使用对象间的关联关系，来解耦了抽象和具体实现之间的固有绑定关系，使抽象和实现可以沿着各自的维度进行扩展、变化。也就是说，抽象和实现不在同一个继承层次结构中，从而通过组合来获得多维度的组合对象。 提高了系统的可扩展性 1在两个变化维度中，扩展任意一个维度都不需要修改原有的系统 符合开闭原则 符合合成复用原则 缺点 增加了系统的理解与设计难度 1由于类之间的关系建立在抽象层，要求我们在编码的时候，一开始就要针对抽象层进行设计和编程 需要正确地识别出系统中两个独立变化的维度 相关设计模式 组合模式 1组合模式更强调的是部分和整体间的组合，而桥接模式强调的是平行级别上不同类的组合 适配器模式 1适配器模式和桥接模式都是为了让两个东西配合工作，但它们两个的目的不一样，适配器模式是改变已有的接口，让它们之间可以相互配合，而桥接模式是分离抽象和具体实现。也就是说，适配器模式可以把功能上相似但是接口不同的类适配起来，而桥接模式是把类的抽象和类的具体实现分离开，然后在此基础上使这些层次结构结合起来。 关键一点桥接模式重要的就是把抽象和具体实现分离开，中间通过组合来搭建它们之间的桥梁 案例分析 场景 121）有两个银行，分别是ABC和ICBC银行，同时有两个账号，分别是定期账号和活期账号。2）使用桥接模式可以 让实现（这里就是账号具体实现）和抽象（这里就是抽象的银行类）分离，银行属性增加修改银行类即可，账号类属性增加修改账号类即可。逻辑清晰，同时也解决了上述类爆炸的情况。 编码 账号接口 Account 12345678910public interface Account &#123; /** * 开户 */ Account openAccount(); /** * 开户类型 */ void showAccountType();&#125; ​ 账号的两个实现类 SavingAccount和 DepositAccount 1234567891011121314151617181920212223242526public class SavingAccount implements Account &#123; @Override public Account openAccount() &#123; System.out.println(\"SavingAccount--开活期账号\"); return new SavingAccount(); &#125; @Override public void showAccountType() &#123; System.out.println(\"SavingAccount--这是一个活期账号\"); &#125;&#125;-----public class DepositAccount implements Account &#123; @Override public Account openAccount() &#123; System.out.println(\"DepositAccount--开定期账号\"); return new DepositAccount(); &#125; @Override public void showAccountType() &#123; System.out.println(\"DepositAccouont--这是一个定期账号\"); &#125;&#125; ​ 银行抽象类 Bank 123456789101112131415161718192021222324252627public abstract class Bank &#123; /** * 这里要写成一个抽象的，因为要把Account引入到Bank里面，通 * 过这种组合的方式，把Account的行为交给Bank的子类来实现，即 * Bank这个抽象类中的某个行为要委托给Account这个接口的实现， * 抽象和具体的实现分离指定的就是这种情况。 */ /** * 要交给子类，声明为protected，这样只有子类能够拿到 */ protected Account account; /** * 通过构造器把Account传过来，也可以通过setter注入的方式赋值 */ public Bank(Account account)&#123; this.account = account; &#125; /** * 这个方法要参照Account接口中的方法，因为Bank里面的具体方法要委托给Account里面 * 的openAccount方法，但这里面方法名不要求一定一致 */ abstract Account openAccount();&#125; ​ 银行抽象类的子类 ABCBank和ICBCBank 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ABCBank extends Bank &#123; /** * 构造的时候传入的是哪个Account就返回哪一个Account(openAccount方法) * @param account */ public ABCBank(Account account) &#123; super(account); &#125; /** * 这里返回的就是父类中的Account * @return */ @Override Account openAccount() &#123; System.out.println(\"ABCBank--开户中国农业银行账号\"); // 很重要，要使用父类里组合进来的Account，不然桥接模式就没什么意义了 account.openAccount(); return account; &#125;&#125;---public class ICBCBank extends Bank &#123; /** * 构造的时候传入的是哪个Account就返回哪一个Account(openAccount方法) * @param account */ public ICBCBank(Account account) &#123; super(account); &#125; /** * 这里返回的就是父类中的Account * @return */ @Override Account openAccount() &#123; System.out.println(\"ICBC--开户中国工商银行账号\"); // 很重要，要使用父类里组合进来的Account，不然桥接模式就没什么意义了 account.openAccount(); return account; &#125;&#125; 单元测试 TestDemo 1234567891011121314151617181920212223242526272829public class TestDemo &#123; public static void main(String[] args) &#123; // ICBCBank-DepositAccount Bank icbcBank = new ICBCBank(new DepositAccount()); Account icbcAccount = icbcBank.openAccount(); System.out.println(\"**************************\"); icbcAccount.showAccountType(); System.out.println(\"--------------------------\"); // ICBCBank-SavingAccount Bank icbcBank2 = new ICBCBank(new SavingAccount()); Account icbcAccount2 = icbcBank2.openAccount(); System.out.println(\"**************************\"); icbcAccount2.showAccountType(); System.out.println(\"--------------------------\"); // ABCBank-DepositAccount Bank abcBank2 = new ABCBank(new DepositAccount()); Account abcAccount2 = abcBank2.openAccount(); System.out.println(\"**************************\"); abcAccount2.showAccountType(); System.out.println(\"--------------------------\"); // ABCBank-SavingAccount Bank abcBank = new ABCBank(new SavingAccount()); Account abcAccount = abcBank.openAccount(); System.out.println(\"**************************\"); abcAccount.showAccountType(); &#125;&#125; 总结 通过桥接模式，把实现部分Account（Account的具体实现类）和抽象部分Bank（Bank抽象类）进行了桥接，使用组合作为一根线连接它们。当然也有聚合的方式实现桥接。 桥接模式在JDK源码中的应用实现部分1java.sql.Driver接口的实现： 如MySQL的Driver，Oracle的Driver Driver接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package java.sql;import java.util.logging.Logger;/** * The interface that every driver class must implement. * &lt;P&gt;The Java SQL framework allows for multiple database drivers. * * &lt;P&gt;Each driver should supply a class that implements * the Driver interface. * * &lt;P&gt;The DriverManager will try to load as many drivers as it can * find and then for any given connection request, it will ask each * driver in turn to try to connect to the target URL. * * &lt;P&gt;It is strongly recommended that each Driver class should be * small and standalone so that the Driver class can be loaded and * queried without bringing in vast quantities of supporting code. * * &lt;P&gt;When a Driver class is loaded, it should create an instance of * itself and register it with the DriverManager. This means that a * user can load and register a driver by calling: * &lt;p&gt; * &#123;@code Class.forName(\"foo.bah.Driver\")&#125; * &lt;p&gt; * A JDBC driver may create a &#123;@linkplain DriverAction&#125; implementation in order * to receive notifications when &#123;@linkplain DriverManager#deregisterDriver&#125; has * been called. * @see DriverManager * @see Connection * @see DriverAction */public interface Driver &#123; Connection connect(String url, java.util.Properties info) throws SQLException; boolean acceptsURL(String url) throws SQLException; DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info) throws SQLException; int getMajorVersion(); int getMinorVersion(); boolean jdbcCompliant(); public Logger getParentLogger() throws SQLFeatureNotSupportedException;&#125; Driver接口的MySql驱动实现 123456789101112131415161718192021222324252627282930313233343536373839404142package com.mysql.cj.jdbc;import java.sql.SQLException;/** * The Java SQL framework allows for multiple database drivers. Each driver should supply a class that implements the Driver interface * * &lt;p&gt; * The DriverManager will try to load as many drivers as it can find and then for any given connection request, it will ask each driver in turn to try to * connect to the target URL. * * &lt;p&gt; * It is strongly recommended that each Driver class should be small and standalone so that the Driver class can be loaded and queried without bringing in vast * quantities of supporting code. * * &lt;p&gt; * When a Driver class is loaded, it should create an instance of itself and register it with the DriverManager. This means that a user can load and register a * driver by doing Class.forName(\"foo.bah.Driver\") */public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; // // Register ourselves with the DriverManager // static &#123; try &#123; // 把驱动注册到DriverManager中 java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125; &#125; /** * Construct a new driver and register it with DriverManager * * @throws SQLException * if a database error occurs. */ public Driver() throws SQLException &#123; // Required for Class.forName().newInstance() &#125;&#125; 抽象部分1java.sql.DriverManager这个类作为抽象部分，它并不是抽象类。再次说明，抽象部分并不一定就是抽象类或接口，只是从桥接模式整体看，把它分为两大部分。registeredDrivers作为实现部分组合到抽象部分。 DriverInfo实现部分的父类型接口Driver只是作为DriverInfo的一个属性 123456789101112131415161718192021222324252627282930class DriverInfo &#123; final Driver driver; DriverAction da; DriverInfo(Driver driver, DriverAction action) &#123; this.driver = driver; da = action; &#125; @Override public boolean equals(Object other) &#123; return (other instanceof DriverInfo) &amp;&amp; this.driver == ((DriverInfo) other).driver; &#125; @Override public int hashCode() &#123; return driver.hashCode(); &#125; @Override public String toString() &#123; return (\"driver[className=\" + driver + \"]\"); &#125; DriverAction action() &#123; return da; &#125;&#125; DriverManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209 package java.sql; import java.util.Iterator; import java.util.ServiceLoader; import java.security.AccessController; import java.security.PrivilegedAction; import java.util.concurrent.CopyOnWriteArrayList; import sun.reflect.CallerSensitive; import sun.reflect.Reflection; /** * @see Driver * @see Connection */ public class DriverManager &#123; // 注册 JDBC driver 的列表 private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;(); private static volatile int loginTimeout = 0; private static volatile java.io.PrintWriter logWriter = null; private static volatile java.io.PrintStream logStream = null; // Used in println() to synchronize logWriter private final static Object logSync = new Object(); /* Prevent the DriverManager class from being instantiated. */ private DriverManager()&#123;&#125; /** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the &#123;@code ServiceLoader&#125; mechanism */ static &#123; loadInitialDrivers(); println(\"JDBC DriverManager initialized\"); &#125; /** * The &lt;code&gt;SQLPermission&lt;/code&gt; constant that allows the * setting of the logging stream. * @since 1.3 */ final static SQLPermission SET_LOG_PERMISSION = new SQLPermission(\"setLog\"); /** * The &#123;@code SQLPermission&#125; constant that allows the * un-register a registered JDBC driver. * @since 1.8 */ final static SQLPermission DEREGISTER_DRIVER_PERMISSION = new SQLPermission(\"deregisterDriver\"); //--------------------------JDBC 2.0----------------------------- /** * Retrieves the log writer. * * The &lt;code&gt;getLogWriter&lt;/code&gt; and &lt;code&gt;setLogWriter&lt;/code&gt; * methods should be used instead * of the &lt;code&gt;get/setlogStream&lt;/code&gt; methods, which are deprecated. * @return a &lt;code&gt;java.io.PrintWriter&lt;/code&gt; object * @see #setLogWriter * @since 1.2 */ public static java.io.PrintWriter getLogWriter() &#123; return logWriter; &#125; public static void setLogWriter(java.io.PrintWriter out) &#123; SecurityManager sec = System.getSecurityManager(); if (sec != null) &#123; sec.checkPermission(SET_LOG_PERMISSION); &#125; logStream = null; logWriter = out; &#125; @CallerSensitive public static Connection getConnection(String url, java.util.Properties info) throws SQLException &#123; return (getConnection(url, info, Reflection.getCallerClass())); &#125; @CallerSensitive public static Connection getConnection(String url, String user, String password) throws SQLException &#123; java.util.Properties info = new java.util.Properties(); if (user != null) &#123; info.put(\"user\", user); &#125; if (password != null) &#123; info.put(\"password\", password); &#125; return (getConnection(url, info, Reflection.getCallerClass())); &#125; @CallerSensitive public static Connection getConnection(String url) throws SQLException &#123; java.util.Properties info = new java.util.Properties(); return (getConnection(url, info, Reflection.getCallerClass())); &#125; /** * Attempts to locate a driver that understands the given URL. * The &lt;code&gt;DriverManager&lt;/code&gt; attempts to select an appropriate driver from * the set of registered JDBC drivers. * * @param url a database URL of the form * &lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt; * @return a &lt;code&gt;Driver&lt;/code&gt; object representing a driver * that can connect to the given URL * @exception SQLException if a database access error occurs */ @CallerSensitive public static Driver getDriver(String url) throws SQLException &#123; println(\"DriverManager.getDriver(\\\"\" + url + \"\\\")\"); Class&lt;?&gt; callerClass = Reflection.getCallerClass(); for (DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerClass)) &#123; try &#123; if(aDriver.driver.acceptsURL(url)) &#123; // Success! println(\"getDriver returning \" + aDriver.driver.getClass().getName()); return (aDriver.driver); &#125; &#125; catch(SQLException sqe) &#123; // Drop through and try the next driver. &#125; &#125; else &#123; println(\" skipping: \" + aDriver.driver.getClass().getName()); &#125; &#125; println(\"getDriver: no suitable driver\"); throw new SQLException(\"No suitable driver\", \"08001\"); &#125; /** * Registers the given driver with the &#123;@code DriverManager&#125;. * A newly-loaded driver class should call * the method &#123;@code registerDriver&#125; to make itself * known to the &#123;@code DriverManager&#125;. If the driver is currently * registered, no action is taken. * * @param driver the new JDBC Driver that is to be registered with the * &#123;@code DriverManager&#125; * @exception SQLException if a database access error occurs * @exception NullPointerException if &#123;@code driver&#125; is null */ public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException &#123; registerDriver(driver, null); &#125; /** * Registers the given driver with the &#123;@code DriverManager&#125;. * A newly-loaded driver class should call * the method &#123;@code registerDriver&#125; to make itself * known to the &#123;@code DriverManager&#125;. If the driver is currently * registered, no action is taken. * * @param driver the new JDBC Driver that is to be registered with the * &#123;@code DriverManager&#125; * @param da the &#123;@code DriverAction&#125; implementation to be used when * &#123;@code DriverManager#deregisterDriver&#125; is called * @exception SQLException if a database access error occurs * @exception NullPointerException if &#123;@code driver&#125; is null * @since 1.8 */ public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException &#123; /* Register the driver if it has not already been added to our list */ if(driver != null) &#123; registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); &#125; else &#123; // This is for compatibility with the original DriverManager throw new NullPointerException(); &#125; println(\"registerDriver: \" + driver); &#125;&#125; ​ ​ ​ ​ ​","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"适配器模式","slug":"design_pattern/structure_type/适配器模式","date":"2019-09-20T16:00:00.000Z","updated":"2020-08-09T09:39:03.024Z","comments":true,"path":"posts/f5c535ea/","link":"","permalink":"https://gentryhuang.com/posts/f5c535ea/","excerpt":"","text":"定义将一个类（被适配者）转换成客户期望的另一个接口（目标），使原本接口不兼容的类（它们的接口不同）可以一起工作（使用同一接口了）。 类型结构型 应用场景12◆已经存在的类，它的方法和需求不匹配时◆不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案，是软件维护阶段需要考虑的事情 优点123◆能提高类的透明性和复用，现有的类复用但不需要改变，解决了现有类和目标类不匹配的问题◆目标类和适配器类解耦，提高程序扩展性◆符合开闭原则，具体的操作都在适配者中，客户端只知道适配者，扩展只需对适配者扩展即可 缺点12◆适配器编写过程需要全面考虑，可能会增加系统的复杂性◆增加系统代码可读的难度，如我们调用的是A接口实现，其实内部已经被适配成了B接口的实现 扩展12◆对象适配器（符合组合复用原则，并且使用委托机制）◆类适配器（通过类继承实现） 相关的设计模式适配器模式和外观模式 123a 都是现有类现存系统的封装，前者复用原有的接口，后者定义了新的接口b 前者使原有的两个接口协同工作，后者在现有的系统中提供一个更为方便的访问入口c 适配力度不同，后者适配整个子系统 适配器模式演练1类适配器通过 继承关系 达到适配的目的，而对象适配器通过 组合 达到适配目的 类适配器模式 被适配者 12345678910111213141516171819package com.design.pattern.adapter.classadapter;import lombok.extern.slf4j.Slf4j;/** * Adaptee 被适配者 * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class Adaptee &#123; /** * 适配方法，想要和目标类一起工作 */ public void adaptee()&#123; log.info(\"被适配者...run\"); &#125;&#125; 适配器（适配者） 1234567891011121314151617181920212223package com.design.pattern.adapter.classadapter;import lombok.extern.slf4j.Slf4j;/** * Adapter * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class Adapter extends Adaptee implements Target &#123; /** * 1、适配者只是实现目标类的接口，并且继承被适配类，这样使得被适配类拥有目标类相容的接口 * 2、在适配器实现目标接口的方法中调用父类被适配者的方法 */ @Override public void run() &#123; // TODO 这里可以添加其他的操作 log.info(\"适配器...run\"); super.adaptee(); &#125;&#125; 目标接口 1234567891011121314package com.design.pattern.adapter.classadapter;/** * Target 目标类接口 * * @author shunhua * @date 2019-09-21 */public interface Target &#123; /** * 目标操作 */ void run();&#125; 目标类 123456789101112131415161718package com.design.pattern.adapter.classadapter;import lombok.extern.slf4j.Slf4j;/** * CurrTarget 目标接口的实现类，可省去，只是作比较 * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class CurrTarget implements Target &#123; @Override public void run() &#123; log.info(\"目标...run\"); &#125;&#125; 客户端 12345678910111213141516171819202122232425package com.design.pattern.adapter.classadapter;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-21 */public class Client &#123; @Test public void test()&#123; // 目标类的操作 Target target = new CurrTarget(); // 目标类的方法 target.run(); // 被适配者通过适配器进行适配，可以和目标类一起工作 target = new Adapter(); // 适配者的方法，内部是被适配者的方法 target.run(); &#125;&#125; 对象适配模式 被适配者 12345678910111213141516171819package com.design.pattern.adapter.objectadapter;import lombok.extern.slf4j.Slf4j;/** * Adaptee 被适配者 * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class Adaptee &#123; /** * 适配方法，想要和目标类一起工作 */ public void adaptee()&#123; log.info(\"被适配者...run\"); &#125;&#125; 适配器（适配者） 12345678910111213141516171819202122232425262728package com.design.pattern.adapter.objectadapter;import lombok.extern.slf4j.Slf4j;/** * Adapter * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class Adapter implements Target &#123; /** * 通过组合 */ private Adaptee adaptee = new Adaptee(); /** * 1 适配器是实现了目标类的接口，为了是被适配者和目标类拥有同一接口 * 2 通过组合的方法，直接在适配器实现目标接口的方法中调用被适配者实例的方法 */ @Override public void run() &#123; // TODO 可以根据具体业务增加其他的操作 log.info(\"适配器...run\"); adaptee.adaptee(); &#125;&#125; 目标接口 1234567891011121314package com.design.pattern.adapter.objectadapter;/** * Target 目标类接口 * * @author shunhua * @date 2019-09-21 */public interface Target &#123; /** * 目标操作 */ void run();&#125; 目标类 12345678910111213141516171819package com.design.pattern.adapter.objectadapter;;import lombok.extern.slf4j.Slf4j;/** * CurrTarget 目标接口的实现类，可省去，只是作比较 * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class CurrTarget implements Target &#123; @Override public void run() &#123; log.info(\"目标...run\"); &#125;&#125; 客户端 12345678910111213141516171819202122232425package com.design.pattern.adapter.objectadapter;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-22 */public class Client &#123; @Test public void test()&#123; // 目标类 Target target = new CurrTarget(); target.run(); // 通过适配器把被适配者转换成目标接口类型 target = new Adapter(); // 调用适配器实现目标接口的方法，内部调用的是被适配者的方法 target.run(); &#125;&#125; 简单需求1手机电源适配器可以把220v交流电转化为5v直流电 目标接口-5v直流电 123456789101112131415package com.design.pattern.adapter.demand;/** * DC5V 目标电压 * * @author shunhua * @date 2019-09-22 */public interface DC5V &#123; /** * 5V直流电 * @return */ int outPutDC5V();&#125; 需要被适配的类-220v交流电 123456789101112131415161718192021package com.design.pattern.adapter.demand;import lombok.extern.slf4j.Slf4j;/** * AC220V 需要被适配的电压 * * @author shunhua * @date 2019-09-22 */@Slf4jpublic class AC220V &#123; /** * 220V交流电 * @return */ public int outputAC220V()&#123; return 220; &#125;&#125; 变压器-适配器 1234567891011121314151617181920212223242526package com.design.pattern.adapter.demand;import lombok.extern.slf4j.Slf4j;/** * PowerAdapter 电源适配器 * * @author shunhua * @date 2019-09-22 */@Slf4jpublic class PowerAdapter implements DC5V &#123; /** * 通过组合的方式 */ private AC220V ac220V = new AC220V(); @Override public int outPutDC5V() &#123; int ac = ac220V.outputAC220V(); int target = ac/44; // 变压处理 log.info(String.format(\"适配器处理后，%dV电压变为%dV\",220,target)); return 5; &#125;&#125; 客户端 12345678910111213141516171819package com.design.pattern.adapter.demand;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-22 */public class Client &#123; @Test public void test() &#123; DC5V dc5V = new PowerAdapter(); // 通过PowerAdapter适配，把220V交流转为5V直流电 dc5V.outPutDC5V(); &#125;&#125; 源码解析12在SpringMVC中，前端控制器接到请求后会通过处理器映射器找处理器，然后返回一个处理器执行链，接着通过匹配处理器适配器来确定哪一个处理器适配器可以适配当前的处理器，确定后执行处理方法，然后返回ModelAndView。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // 找到处理器对应的处理器适配器 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // 实际调用处理器，然后返回ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125; &#125; // 处理器映射器找处理器逻辑（返回处理器执行链，包含了处理器）/** * Return the HandlerExecutionChain for this request. * &lt;p&gt;Tries all handler mappings in order. * @param request current HTTP request * @return the HandlerExecutionChain, or &#123;@code null&#125; if no handler could be found */ @Nullable protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; &#125; return null; &#125; // 匹配合适的处理器适配器逻辑 /** * Return the HandlerAdapter for this handler object. * @param handler the handler object to find an adapter for * @throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error. */ protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; if (this.handlerAdapters != null) &#123; for (HandlerAdapter adapter : this.handlerAdapters) &#123; if (adapter.supports(handler)) &#123; return adapter; &#125; &#125; &#125; throw new ServletException(\"No adapter for handler [\" + handler + \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\"); &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰者模式","slug":"design_pattern/structure_type/装饰者模式","date":"2019-09-18T16:00:00.000Z","updated":"2020-08-09T09:37:50.231Z","comments":true,"path":"posts/a708a60d/","link":"","permalink":"https://gentryhuang.com/posts/a708a60d/","excerpt":"","text":"定义在不改变原有对象的基础上，将功能附加到对象上。提供了比继承更有弹性的替代方案（扩展原有对象功能）。 类型结构型 应用场景12◆扩展一个类的功能或给一个类添加附加职责◆动态的给一个对象添加功能，这些功能可以再动态的撤销 优点123◆继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能。一般我们可以使用继承实现功能的扩展，如果需要扩展的功能种类繁多，那么势必会生成很多子类，这无疑增加了系统的复杂性。并且使用继承需要提前预知哪些功能，因为继承关系在编译的时候就确定了。而装饰者模式可以动态地加入。其实装饰者模式也是建立在继承的关系基础之上的，注意，这不意味着就不使用继承了，继承也是扩展形式之一，只是某些时候不一定能达到弹性设计的最佳方式。◆通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果◆符合开闭原则，装饰者和被装饰者可以独立变化，原有的代码不需要改变。其实装饰者做的是把装饰功能从类中移出去，这样简化了原来被装饰的类，同时把类的核心职责和装饰功能区分开。 缺点12◆会出现更多的代码，更多的类，增加程序复杂性。装饰者模式可能会比继承方式的使用的类要少，但是对象很多，并且这些对象类型是一样的，因为装饰者会继承被装饰类，而被装饰类又有具体的实体，这些实体对象类型又一样，所有排查问题增加了难度。◆动态装饰时，多层装饰时会更复杂 关联的设计模式装饰者模式和代理模式 121 装饰者模式关注动态地添加方法，代理模式关注于控制对对象的访问2 代理模式中的代理类可以对它的客户隐藏一个对象的具体信息，通常在使用代理模式的时候常常在代理类中创建一个对象的实例，装饰者模式通常把原始对象作为一个参数传入装饰者的构造器，这是使用上的不同。 装饰者模式和适配器模式 1231 两者都是包装者模式2 装饰者和被装饰者可以实现相同的接口或者装饰者是被装饰者的子类3 适配器和被适配的类有不同的接口，也有可能是部分接口是重合的 简单需求买煎饼的时候可以根据自身情况要求加鸡蛋或者香肠，卖煎饼的根据需求去做煎饼。 装饰者模式演练非装饰者模式12需求：加一个鸡蛋加一元，一个火腿两元，现在a买一个煎饼，b买加蛋的煎饼，c买加肠的煎饼方案：通过堆积类完成需求，但是面对众多的需求会类爆炸的。 煎饼类 12345678910111213141516171819202122232425package com.design.pattern.decorator.v1;/** * BatterCake 煎饼类 * * @author shunhua * @date 2019-09-19 */public class BatterCake &#123; /** * 获取食品描述 * @return */ public String getDesc()&#123; return \"煎饼\"; &#125; /** * 食品单价 * @return */ public int cost()&#123; return 5; &#125;&#125; 鸡蛋煎饼类 1234567891011121314151617181920package com.design.pattern.decorator.v1;/** * BatterCakeWithEgg 加鸡蛋的煎饼 * * @author shunhua * @date 2019-09-19 */public class BatterCakeWithEgg extends BatterCake &#123; @Override public String getDesc() &#123; return super.getDesc() + \" 加一个鸡蛋\"; &#125; @Override public int cost() &#123; return super.cost() + 1; &#125;&#125; 香肠煎饼类 12345678910111213141516171819package com.design.pattern.decorator.v1;/** * BatterCakeWithSausage 加香肠的煎饼 * * @author shunhua * @date 2019-09-19 */public class BatterCakeWithSausage extends BatterCake &#123; @Override public String getDesc() &#123; return super.getDesc() + \" 加一个香肠\"; &#125; @Override public int cost() &#123; return super.cost() + 2; &#125;&#125; 客户端 1234567891011121314151617181920212223242526272829package com.design.pattern.decorator.v1;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-19 */@Slf4jpublic class Client &#123; @Test public void test()&#123; // 煎饼 BatterCake batterCake = new BatterCake(); log.info(batterCake.getDesc() + \"销售价格为 \" + batterCake.cost()); // 鸡蛋煎饼 BatterCakeWithEgg batterCakeWithEgg = new BatterCakeWithEgg(); log.info(batterCakeWithEgg.getDesc() + \"销售价格为 \" + batterCakeWithEgg.cost()); // 香肠煎饼 BatterCakeWithSausage batterCakeWithSausage = new BatterCakeWithSausage(); log.info(batterCakeWithSausage.getDesc() + \"销售价格为 \" + batterCakeWithEgg.cost()); &#125;&#125; 装饰者模式12需求：现在肠和蛋随机，a 加2蛋2肠 b加1蛋2肠方案：使用装饰类添加功能，为煎饼加鸡蛋、加香肠 要求： 所谓装饰者模式，通用做法要有抽象的实体类和确定的实体类，同时要有抽象的装饰者和确定的装饰者。现在实体类是煎饼，装饰者是鸡蛋和香肠。 关联： 煎饼实体类继承煎饼抽象类，装饰者抽象类也继承煎饼抽象类，通过它们的父类组合来达到煎饼实体类和装饰者抽象类的关系 抽象煎饼类 123456789101112131415161718192021package com.design.pattern.decorator.v2;/** * AbstractBatterCake 抽象煎饼类（也可以是接口） * * @author shunhua * @date 2019-09-19 */public abstract class AbstractBatterCake &#123; /** * 食品描述 * @return */ public abstract String getDesc(); /** * 价格 * @return */ public abstract int cost();&#125; 煎饼类 1234567891011121314151617181920package com.design.pattern.decorator.v2;/** * BatterCake 实体煎饼类 * * @author shunhua * @date 2019-09-19 */public class BatterCake extends AbstractBatterCake &#123; @Override public String getDesc() &#123; return \"煎饼\"; &#125; @Override public int cost() &#123; return 5; &#125;&#125; 抽象装饰类 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.decorator.v2;/** * * 装饰者同样继承 抽象煎饼类，这是为了方便 ，和煎饼类交互 * * 如果不用构造器的方式，也可以使用set方式 * * @author shunhua * @date 2019-09-19 */public abstract class AbstractDecorator extends AbstractBatterCake &#123; /** * 定义煎饼属性，用于注入 */ private AbstractBatterCake batterCake; public AbstractDecorator(AbstractBatterCake batterCake)&#123; this.batterCake = batterCake; &#125; @Override public String getDesc() &#123; return batterCake.getDesc(); &#125; @Override public int cost() &#123; return batterCake.cost(); &#125; /** * 装饰者实体类特有操作 */ protected abstract void handle();&#125; 鸡蛋装饰类 1234567891011121314151617181920212223242526272829303132package com.design.pattern.decorator.v2;import lombok.extern.slf4j.Slf4j;/** * EggDecorator * * @author shunhua * @date 2019-09-19 */@Slf4jpublic class EggDecorator extends AbstractDecorator &#123; public EggDecorator(AbstractBatterCake batterCake) &#123; super(batterCake); &#125; @Override public String getDesc() &#123; return super.getDesc() + \" 加一个鸡蛋\"; &#125; @Override public int cost() &#123; return super.cost() + 1; &#125; @Override protected void handle() &#123; log.info(\"鸡蛋装饰者特有的处理\"); &#125;&#125; 香肠装饰类 1234567891011121314151617181920212223242526272829303132package com.design.pattern.decorator.v2;import lombok.extern.slf4j.Slf4j;/** * SauseDecorator * * @author shunhua * @date 2019-09-19 */@Slf4jpublic class SauseDecorator extends AbstractDecorator &#123; public SauseDecorator(AbstractBatterCake batterCake) &#123; super(batterCake); &#125; @Override public String getDesc() &#123; return super.getDesc() + \" 加一个香肠\"; &#125; @Override public int cost() &#123; return super.cost() + 2; &#125; @Override protected void handle() &#123; log.info(\"香肠装饰者特有的处理方式\"); &#125;&#125; 客户端 1234567891011121314151617181920212223242526272829package com.design.pattern.decorator.v2;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-19 */@Slf4jpublic class Client &#123; @Test public void test()&#123; AbstractBatterCake batterCake; // 装饰煎饼 batterCake = new BatterCake(); // 鸡蛋装饰 batterCake = new EggDecorator(batterCake); batterCake = new EggDecorator(batterCake); ((EggDecorator) batterCake).handle(); // 香肠装饰 batterCake = new SauseDecorator(batterCake); ((SauseDecorator) batterCake).handle(); log.info(batterCake.getDesc() + \" 一共卖了\" + batterCake.cost() + \"元\"); &#125;&#125; 装饰者模式在源码中的使用BufferedReader 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class BufferedReader extends Reader &#123; private Reader in; private char cb[]; private int nChars, nextChar; // todo 省略 /** * 对Reader类型的 实例进行包装 */ public BufferedReader(Reader in, int sz) &#123; super(in); if (sz &lt;= 0) throw new IllegalArgumentException(\"Buffer size &lt;= 0\"); this.in = in; cb = new char[sz]; nextChar = nChars = 0; &#125; /** * Creates a buffering character-input stream that uses a default-sized * input buffer. * * @param in A Reader */ public BufferedReader(Reader in) &#123; this(in, defaultCharBufferSize); &#125; /** * 这里使用Reader 类型对象进行操作 */ private void fill() throws IOException &#123; int dst; if (markedChar &lt;= UNMARKED) &#123; /* No mark */ dst = 0; &#125; else &#123; /* Marked */ int delta = nextChar - markedChar; if (delta &gt;= readAheadLimit) &#123; /* Gone past read-ahead limit: Invalidate mark */ markedChar = INVALIDATED; readAheadLimit = 0; dst = 0; &#125; else &#123; if (readAheadLimit &lt;= cb.length) &#123; /* Shuffle in the current buffer */ System.arraycopy(cb, markedChar, cb, 0, delta); markedChar = 0; dst = delta; &#125; else &#123; /* Reallocate buffer to accommodate read-ahead limit */ char ncb[] = new char[readAheadLimit]; System.arraycopy(cb, markedChar, ncb, 0, delta); cb = ncb; markedChar = 0; dst = delta; &#125; nextChar = nChars = delta; &#125; &#125; int n; do &#123; n = in.read(cb, dst, cb.length - dst); &#125; while (n == 0); if (n &gt; 0) &#123; nChars = dst + n; nextChar = dst; &#125; &#125;&#125;/** * 注意Reader是抽象的 */public abstract class Reader implements Readable, Closeable &#123; // todo 省略&#125; InputStream类型作为被装饰类型，它的装饰者有很多，如上图中列出FilerInputStream、BufferedInputStream以及LineInputStream。在装饰者内部本质上都是使用InputStream的实例操作的。 BufferedInputStream 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class BufferedInputStream extends FilterInputStream &#123; private static int DEFAULT_BUFFER_SIZE = 8192; private static int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8; protected volatile byte buf[]; private static final AtomicReferenceFieldUpdater&lt;BufferedInputStream, byte[]&gt; bufUpdater = AtomicReferenceFieldUpdater.newUpdater (BufferedInputStream.class, byte[].class, \"buf\"); protected int count; protected int pos; protected int markpos = -1; protected int marklimit; private InputStream getInIfOpen() throws IOException &#123; InputStream input = in; if (input == null) throw new IOException(\"Stream closed\"); return input; &#125; /** * 对InputStream类型进行包装 */ public BufferedInputStream(InputStream in) &#123; this(in, DEFAULT_BUFFER_SIZE); &#125; /** * 对InputStream类型进行包装 */ public BufferedInputStream(InputStream in, int size) &#123; super(in); if (size &lt;= 0) &#123; throw new IllegalArgumentException(\"Buffer size &lt;= 0\"); &#125; buf = new byte[size]; &#125;&#125; Servlet的HttpServletRequestWrapper HttpServletRequestWrapper继承了ServletRequestWrapper也实现了HttpServletRequest,它们的公共父类是ServletRequest. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * HttpServletRequestWrapper装饰类 */public class HttpServletRequestWrapper extends ServletRequestWrapper implements HttpServletRequest &#123; /** * 对HttpServletRequest进行装饰，ServletRequestWrapper抽象的装饰者也对HttpServletRequest的父类进行装饰 */ public HttpServletRequestWrapper(HttpServletRequest request) &#123; super(request); &#125; private HttpServletRequest _getHttpServletRequest() &#123; return (HttpServletRequest) super.getRequest(); &#125; /** * The default behavior of this method is to return getAuthType() * on the wrapped request object. */ public String getAuthType() &#123; return this._getHttpServletRequest().getAuthType(); &#125; /** * The default behavior of this method is to return getCookies() * on the wrapped request object. */ public Cookie[] getCookies() &#123; return this._getHttpServletRequest().getCookies(); &#125; /** * The default behavior of this method is to return getDateHeader(String name) * on the wrapped request object. */ public long getDateHeader(String name) &#123; return this._getHttpServletRequest().getDateHeader(name); &#125;&#125;/*** ServletRequestWrapper装饰类*/public class ServletRequestWrapper implements ServletRequest &#123; private ServletRequest request; /** * Creates a ServletRequest adaptor wrapping the given request object. * @throws java.lang.IllegalArgumentException if the request is null */ public ServletRequestWrapper(ServletRequest request) &#123; if (request == null) &#123; throw new IllegalArgumentException(\"Request cannot be null\"); &#125; this.request = request; &#125; /** * Return the wrapped request object. */ public ServletRequest getRequest() &#123; return this.request; &#125; /** * Sets the request object being wrapped. * @throws java.lang.IllegalArgumentException if the request is null. */ public void setRequest(ServletRequest request) &#123; if (request == null) &#123; throw new IllegalArgumentException(\"Request cannot be null\"); &#125; this.request = request; &#125; /** * * The default behavior of this method is to call getAttribute(String name) * on the wrapped request object. */ public Object getAttribute(String name) &#123; return this.request.getAttribute(name); &#125; /** * The default behavior of this method is to return getAttributeNames() * on the wrapped request object. */ public Enumeration getAttributeNames() &#123; return this.request.getAttributeNames(); &#125; &#125; MyBatis的FifoCache MyBatis的Cache模块中使用大量的装饰者模式，在decorators包下都是的，下面列举最近最少使用策略的装饰类。 123456789101112131415161718192021222324252627282930313233343536373839/*** lru算法 最近最少使用*/public class LruCache implements Cache &#123; private final Cache delegate; private Map&lt;Object, Object&gt; keyMap; private Object eldestKey; public LruCache(Cache delegate) &#123; this.delegate = delegate; setSize(1024); &#125; @Override public String getId() &#123; return delegate.getId(); &#125; @Override public int getSize() &#123; return delegate.getSize(); &#125; public void setSize(final int size) &#123; keyMap = new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) &#123; private static final long serialVersionUID = 4267176411845948333L; @Override protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) &#123; boolean tooBig = size() &gt; size; if (tooBig) &#123; eldestKey = eldest.getKey(); &#125; return tooBig; &#125; &#125;; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"外观模式","slug":"design_pattern/structure_type/外观模式","date":"2019-09-16T16:00:00.000Z","updated":"2020-08-09T09:34:58.171Z","comments":true,"path":"posts/f7de8aa8/","link":"","permalink":"https://gentryhuang.com/posts/f7de8aa8/","excerpt":"","text":"定义又叫门面模式，提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。 类型结构型 使用场景 子系统越来越复杂，增加外观模式提供简单调用接口 构建多层系统结构，利用外观对象作为每层的入口，简化层间调用 优点1234◆简化了调用过程，无需了解深入子系统，防止带来风险(将子系统集成到一起，不去修改子系统)。◆减少系统依赖、松散耦合（客户端与子系统）◆更好的划分访问层次◆符合迪米特法则，即最少知道原则 缺点12◆增加子系统、扩展子系统行为容易引入风险◆增加子系统、扩展子系统行为不符合开闭原则 相关联设计模式对比外观模式和中介者模式 1前者关注外界和子系统的交互，后者关注子系统内部的交互 外观模式和单例模式 1外观模式和单例模式可以结合使用,通常把外观模式中的外观做成单例的 外观模式和抽象工厂模式 1前者可以通过后者获取子系统的实例，子系统可以经内部对外观类进行屏蔽 简单需求 某网站有积分兑换礼物的功能，设计的时候需要校验三步： a 资格校验系统，是木木网会员。 b 积分系统，该系统放的是各个积分的获取支出，需要拿出该用户目前的积分和该礼物所需要的积分进行对比 c 物流系统，如果满足ab，则返回成功，并返回一个订单号。 关注点： 应用层无需知道资格校验类等其他子系统的类 外观模式演练 121. 应用层不关心子系统，应用层只和外观类通信，子系统只和外观类通信2. 如果扩展子系统的，使用实体外观类的话，不符合开闭原则，如果使用抽象外观类或者外观接口，然后用实体继承或实现的话，符合开闭原则。主要看外观对应的子系统群是否变更频繁，不频繁可以使用实体外观，这样更简单。 实体类 1234567891011121314151617181920package com.design.pattern.facade;import lombok.AllArgsConstructor;import lombok.Data;/** * PointsGift 积分兑换礼物 * * @author shunhua * @date 2019-09-17 */@Data@AllArgsConstructorpublic class PointsGift &#123; /** * 礼物名称 */ private String name;&#125; 资格验证系统类 1234567891011121314151617181920212223package com.design.pattern.facade;import lombok.extern.slf4j.Slf4j;/** * QualifyService 校验系统 * * @author shunhua * @date 2019-09-17 */@Slf4jpublic class QualifyService &#123; /** * 校验逻辑，积分是否够 * @param pointsGift * @return */ public boolean isAvailable(PointsGift pointsGift)&#123; log.info(pointsGift.getName() + \"积分通过\"); return true; &#125;&#125; 积分系统类 1234567891011121314151617181920212223package com.design.pattern.facade;import lombok.extern.slf4j.Slf4j;&#x2F;** * PointsPaymentService 积分支付 * * @author shunhua * @date 2019-09-17 *&#x2F;@Slf4jpublic class PointsPaymentService &#123; &#x2F;** * 积分兑换礼物 * @param pointsGift * @return *&#x2F; public boolean pay(PointsGift pointsGift)&#123; log.info(&quot;支付&quot; + pointsGift.getName() + &quot;积分成功&quot;); return true; &#125;&#125; 物流系统类 1234567891011121314151617181920212223package com.design.pattern.facade;import lombok.extern.slf4j.Slf4j;/** * ShippingService * * @author shunhua * @date 2019-09-17 */@Slf4jpublic class ShippingService &#123; /** * 物流系统对接 * @param pointsGift * @return */ public String shipGift(PointsGift pointsGift)&#123; log.info(pointsGift.getName() + \"进入物流系统\"); return \"123456\"; &#125;&#125; 客户端 1234567891011121314151617181920package com.design.pattern.facade;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-17 */public class Client &#123; @Test public void test()&#123; PointsGift pointsGift = new PointsGift(\"机械键盘\"); GiftExchangeService giftExchangeService = new GiftExchangeService(); giftExchangeService.giftExchange(pointsGift); &#125;&#125; 外观模式在源码中的使用Spring-jdbc 1Spring对原生的JDBC进行了封装，我们只需要访问Spring提供的接口方法就可以达到目的。 MyBatis的Configuration 123456/** Configuration#newMetaObject方法底层也是对一些列逻辑的封装，我们只需要调用newMetaObject即可，不需关系内部。 * 如果需要修改内部逻辑，这外观接口是不需要改变的 */public MetaObject newMetaObject(Object object) &#123; return MetaObject.forObject(object, objectFactory, objectWrapperFactory, reflectorFactory); &#125; Tomcat源码 12341. Tomcat中大量使用了外观模式，如RequestFacade、ResponseFacade等。2. RequestFacade implements HttpServletRequest，Request implements HttpServletRequest，Request使用了RequestFacade包装了 自己。Request#getRequest在获取HttpServletRequest时，返回的其实是RequestFacade，之后用这个返回的对象完成的操作都是RequestFacade 来完成的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"原型模式","slug":"design_pattern/creation_type/原型模式","date":"2019-09-15T16:00:00.000Z","updated":"2020-07-04T16:28:45.962Z","comments":true,"path":"posts/91ad9ce3/","link":"","permalink":"https://gentryhuang.com/posts/91ad9ce3/","excerpt":"","text":"定义原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。可以理解为克隆方法克隆对象。 特点不需要知道任何创建的细节，不调用构造函数 类型创建型 适用场景1234◆类初始化消耗较多资源◆new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）◆构造函数比较复杂◆循环体中生产大量对象时 优点 原型模式性能比直接new一个对象性能高 简化创建对象的过程 缺点 必须配备克隆方法（重写Object的clone方法，否则不会生效，克隆也是原型模式的核心） 对克隆复杂对象或对克隆出的对象进行复杂改造时，容易引入风险 对复杂对象的深拷贝、浅拷贝要运用得当 扩展深克隆1创建一个新对象，本体对象的引用类型属性需要进行深克隆，这样它就不会再指向原有对象地址。 浅克隆1创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。 小结1深浅克隆都会在堆中新分配一块区域，它用来指向本体，区别在于对象属性引用的对象是否需要进行克隆（递归性的） 简单需求某个对象创建的时候相对比较消耗资源，但是这个对象又不得不创建多次，这时可以使用原型模式。原型模式是在内存中进行二进制字节流的拷贝，比new一个对象性能好很多 原型模式实践使用原型模式之前邮件类 12345678910111213141516171819202122232425package com.design.pattern.prototype;import lombok.Data;/** * Mail * * @author shunhua * @date 2019-09-16 */@Datapublic class Mail &#123; /** * 邮件名 */ private String name; /** * 邮件地址 */ private String address; /** * 邮件内容 */ private String content;&#125; 邮件工具类 123456789101112131415161718192021222324252627282930package com.design.pattern.prototype;import lombok.extern.slf4j.Slf4j;import java.text.MessageFormat;/** * MailUtil * * @author shunhua * @date 2019-09-16 */@Slf4jpublic class MailUtil &#123; /** * 发送邮件 * 重点： 占位符赋值的实现 * @param mail */ public static void sendMail(Mail mail)&#123; String content = \"向&#123;0&#125;,邮件地址:&#123;1&#125;,邮件内容：&#123;2&#125;发送邮件\"; log.info(MessageFormat.format(content,mail.getName(),mail.getAddress(),mail.getContent())); &#125; /** * 保存邮件的模版内容 * @param mail */ public static void mailTemplate(Mail mail)&#123; log.info(\"邮件的模版内容：\" + mail.getContent()); &#125;&#125; 客户端 12345678910111213141516171819202122232425package com.design.pattern.prototype;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-16 */public class Client &#123; @Test public void test()&#123; Mail mail = new Mail(); mail.setContent(\"邮件模版\"); for(int i = 0; i &lt; 10; i++)&#123; mail.setName(\"姓名\" + i); mail.setAddress(\"姓名\" + i + \"@\" + \"gmail.com\"); mail.setContent(\"你收到一封邮件\"); MailUtil.sendMail(mail); &#125; MailUtil.mailTemplate(mail); &#125;&#125; 使用原型模式默认方式（浅拷贝）邮件类 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.prototype;import lombok.Data;/** * Mail 想要能被克隆需要实现Cloneable接口 * * @author shunhua * @date 2019-09-16 */@Datapublic class Mail implements Cloneable &#123; /** * 邮件名 */ private String name; /** * 邮件地址 */ private String address; /** * 邮件内容 */ private String content; /** * 重写克隆方法 * @return * @throws CloneNotSupportedException */ @Override protected Object clone() throws CloneNotSupportedException &#123; System.out.println(\"克隆Mail...\"); return super.clone(); &#125;&#125; 邮件工具类 12345678910111213141516171819202122232425262728293031package com.design.pattern.prototype;import lombok.extern.slf4j.Slf4j;import java.text.MessageFormat;/** * MailUtil * * @author shunhua * @date 2019-09-16 */@Slf4jpublic class MailUtil &#123; /** * 发送邮件 * @param mail */ public static void sendMail(Mail mail)&#123; String content = \"向&#123;0&#125;,邮件地址:&#123;1&#125;,邮件内容：&#123;2&#125;发送邮件\"; log.info(MessageFormat.format(content,mail.getName(),mail.getAddress(),mail.getContent())); &#125; /** * 保存邮件的模版内容 * @param mail */ public static void mailTemplate(Mail mail)&#123; log.info(\"邮件的模版内容：\" + mail.getContent()); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728package com.design.pattern.prototype;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-16 */public class Client &#123; @Test public void test() throws CloneNotSupportedException &#123; Mail mail = new Mail(); mail.setContent(\"邮件模版\"); for(int i = 0; i &lt; 10; i++)&#123; /** 需要创建多个Mail对象,注意不会调用Mail的构造方法，而是调用了Mail中的clone方法 **/ Mail mailTemp = (Mail) mail.clone(); mailTemp.setName(\"姓名\" + i); mailTemp.setAddress(\"姓名\" + i + \"@\" + \"gmail.com\"); mailTemp.setContent(\"你收到一封邮件\"); MailUtil.sendMail(mailTemp); &#125; // 得到原始的邮件模版 MailUtil.mailTemplate(mail); &#125;&#125; 使用原型模式默认方式（深拷贝）12345678对于被克隆的目标对象中有引用类型的属性时，如果不对该引用类型的属性进行克隆处理，那么该属性对于目标对象和克隆得到的新对象都是同一个，这很容易引起问题，一定要注意。这样情况，只需要对这个属性进行浅拷贝处理即可解决。@Override protected Object clone() throws CloneNotSupportedException &#123; Mail mail = (Mail) super.clone(); //深克隆 mail.date = (Date) pig.date.clone(); return mail; &#125; 原型模式扩展实体类 1234567891011/** * 一种常用的原型模式 * 通过抽象类来实现原型模式 */public abstract class A implements Cloneable&#123; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 继承类 123456789101112131415/** * 继承A类，直接调用clone接口 */public class B extends A&#123; public static void main(String [] args)&#123; B b = new B(); try &#123; b.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); System.out.println(\"处理异常\"); &#125; &#125;&#125; 克隆破坏单例123克隆破坏单例的根本原因是，通过反射暴力调用单例类中的clone方法，这样就会得到一个新对象，单例也就变成了多例。防止克隆破坏单例，只需要让单例类不实现克隆接口即可，或者实现了克隆接口但是克隆方法返回的仍然是同一对象，而不是处理克隆。 原型模式在源码中的使用1可以通过观察Cloneable接口的使用，就可以追踪原型模式是怎样使用的 源码解析1(Object) 12//native 调用非java代码接口 protected native Object clone() throws CloneNotSupportedException; 源码解析2(ArrayList实现克隆) 1234567891011121314151617181920212223public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;/** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */ public Object clone() &#123; try &#123; @SuppressWarnings(\"unchecked\") ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125;&#125; 源码解析3(MyBatis的cacheKey) 12345678910111213141516171819package org.apache.ibatis.cache;import java.io.Serializable;import java.lang.reflect.Array;import java.util.ArrayList;import java.util.List;/** * @author Clinton Begin */public class CacheKey implements Cloneable, Serializable &#123; @Override public CacheKey clone() throws CloneNotSupportedException &#123; CacheKey clonedCacheKey = (CacheKey) super.clone(); clonedCacheKey.updateList = new ArrayList&lt;Object&gt;(updateList); return clonedCacheKey; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者模式","slug":"design_pattern/creation_type/建造者模式","date":"2019-09-11T14:33:47.000Z","updated":"2020-08-09T09:16:58.216Z","comments":true,"path":"posts/fe816c3c/","link":"","permalink":"https://gentryhuang.com/posts/fe816c3c/","excerpt":"","text":"定义 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。用户只需指定需要建造的类型就可以得到它们，建造过程及细节不需要知道。 类型 创建型 适用场景 如果一个对象有非常复杂的内部结构（很多属性） 想把复杂对象的创建和使用分离优点 封装性好，创建和使用分离 扩展性好、建造类之间独立、一定程度上解耦 缺点 产生多余的Builder对象 产品内部发生变化，建造者都需要修改，成本较大 建造者模式和工厂模式比较 建造者模式更注重方法的调用顺序，而工厂模式更注重生产产品 创建对象的粒度不同，建造者模式可以创建复杂的产品，有各种复杂的部件组成。而工程模式创建出来的都几乎一个样子 工厂模式注重把产品创建出来，而建造者不仅要创建出产品，还要知道产品有哪些部件组成的 简单需求说明 有一个课程需要上线在网站，这个课程需要满足以下条件：课程名、课程的课件资源以及视频资源，只有这个三个组件有了 才能组装成上线的课程。这里在创建课时，需要有顺序的执行，最终得到一个符合要求的课程。 v1 通过中间类实现uml类图 课程类 1234567891011121314151617181920212223242526package com.design.pattern.builder;import lombok.Data;/** * Course * * @author shunhua * @date 2019-09-11 */@Datapublic class Course &#123; /** * 课程名 */ private String name; /** * 课程资料 */ private String source; /** * 课程视频 */ private String video;&#125; 建造者抽象类 123456789101112131415161718192021222324252627282930313233package com.design.pattern.builder;/** * CourseBuilder * * @author shunhua * @date 2019-09-11 */public abstract class CourseBuilder &#123; /** * 建造课程名 * @param name */ public abstract void buildName(String name); /** * 建造课程资料 * @param source */ public abstract void buildSource(String source); /** * 建造课程视频 * @param video */ public abstract void buildVideo(String video); /** * 构建课程 * @return */ public abstract Course buildCourse();&#125; 建造者实现类 1234567891011121314151617181920212223242526272829303132package com.design.pattern.builder;/** * ActualCourseBuilder 真正的课程创建者 * * @author shunhua * @date 2019-09-11 */public class ActualCourseBuilder extends CourseBuilder&#123; private Course course = new Course(); @Override public void buildName(String name) &#123; course.setName(name); &#125; @Override public void buildSource(String source) &#123; course.setSource(source); &#125; @Override public void buildVideo(String video) &#123; course.setVideo(video); &#125; @Override public Course buildCourse() &#123; return course; &#125;&#125; 助教（对课程进行组装） 12345678910111213141516171819202122232425262728293031package com.design.pattern.builder;/** * Assistant 课程助教 * * @author shunhua * @date 2019-09-11 */public class Assistant &#123; private CourseBuilder courseBuilder; public void setCourseBuilder(CourseBuilder courseBuilder)&#123; this.courseBuilder = courseBuilder; &#125; /** * 课程助教 组装课程 * @param name * @param source * @param video * @return */ public Course buildCourse(String name,String source,String video)&#123; this.courseBuilder.buildName(name); this.courseBuilder.buildSource(source); this.courseBuilder.buildVideo(video); return this.courseBuilder.buildCourse(); &#125;&#125; 客户端 1234567891011121314151617181920212223package com.design.pattern.builder;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-11 */@Slf4jpublic class Client &#123; @Test public void test()&#123; CourseBuilder courseBuilder = new ActualCourseBuilder(); Assistant assistant = new Assistant(); assistant.setCourseBuilder(courseBuilder); Course course = assistant.buildCourse(\"Java进阶\",\"ppt\",\"Java进阶视频\"); log.info(course.toString()); &#125;&#125; v2 静态内部类演练建造者模式（链式调用）uml类图 1静态内部类builder有3个属性，课程类有相同的3个属性，链式调用的时候，给builder全部或者部分赋值，build的时候，把builder对象传送到course，course获取到builder的属性，然后返回这个course； Course类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.design.pattern.builder.v2;import lombok.Data;/** * Course * * @author shunhua * @date 2019-09-11 */@Datapublic class Course &#123; /** * 课程名 */ private String name; /** * 课程资料 */ private String source; /** * 课程视频 */ private String video; public Course(CourseBuilder courseBuilder)&#123; this.name = courseBuilder.name; this.source = courseBuilder.source; this.video = courseBuilder.video; &#125; /** * 把实体类与对应的创建类写在一起，这种使用更常见,使用链式调用 */ public static class CourseBuilder &#123; /** * 课程名 */ private String name; /** * 课程资料 */ private String source; /** * 课程视频 */ private String video; public CourseBuilder buildName(String name) &#123; this.name = name; return this; &#125; public CourseBuilder buildSource(String source) &#123; this.source = source; return this; &#125; public CourseBuilder buildVideo(String video) &#123; this.video = video; return this; &#125; /** * * @return */ public Course build()&#123; return new Course(this); &#125; &#125;&#125; 客户端 1234567891011121314151617181920212223package com.design.pattern.builder.v2;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-11 */@Slf4jpublic class Client &#123; @Test public void test()&#123; Course course = new Course.CourseBuilder() .buildName(\"java进阶\") .buildSource(\"ppt课件\") .buildVideo(\"java进阶视频\") .build(); log.info(course.toString()); &#125;&#125; 建造者模式在源码中的使用jdk的StringBuilder和StringBuffer12345678910111213// 如StringBuilder的append方法 @Override public StringBuilder append(String str) &#123; super.append(str); return this; &#125;// 如StringBuffer的append方法 @Override public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this; &#125; MyBatis的SqlSessionFactoryBuilder1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123; try &#123; // XML配置的builder 来创建 Configuration XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); // parse方法创建Configuration ，SqlSessionFactoryBuilder的build方法创建SqlSessionFactory return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; inputStream.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; // public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125; // XMLConfigBuilder#parse public Configuration parse() &#123; if (parsed) &#123; throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\"); &#125; parsed = true; parseConfiguration(parser.evalNode(\"/configuration\")); return configuration; &#125; private void parseConfiguration(XNode root) &#123; try &#123; Properties settings = settingsAsPropertiess(root.evalNode(\"settings\")); //issue #117 read properties first propertiesElement(root.evalNode(\"properties\")); loadCustomVfs(settings); typeAliasesElement(root.evalNode(\"typeAliases\")); pluginElement(root.evalNode(\"plugins\")); objectFactoryElement(root.evalNode(\"objectFactory\")); objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\")); reflectorFactoryElement(root.evalNode(\"reflectorFactory\")); settingsElement(settings); // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode(\"environments\")); databaseIdProviderElement(root.evalNode(\"databaseIdProvider\")); typeHandlerElement(root.evalNode(\"typeHandlers\")); mapperElement(root.evalNode(\"mappers\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"抽象工厂","slug":"design_pattern/creation_type/抽象工厂","date":"2019-09-09T16:00:00.000Z","updated":"2020-09-04T06:07:24.449Z","comments":true,"path":"posts/df11d265/","link":"","permalink":"https://gentryhuang.com/posts/df11d265/","excerpt":"","text":"定义 抽象工厂模式提供一个创建一系列相关或相互依赖对象的的接口。无须指定它们具体的类。 类型 创建型 使用场景 客户端（应用层）不依赖于产品实例如何被创建、实现等细节 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码 提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 优点 应用层代码不和具体的产品发生依赖，只和具体的产品族工厂发生依赖关系，低耦合，高内聚 从具体的产品工厂取出来的肯定是同一产品族，开发的时候逻辑清晰 对于产品族来说，符合开闭原则，增加新的产品族的时候，对扩展开放 缺点 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工程的接口。增加了系统的抽象性和理解难度。 为何有产品族的业务场景宜用抽象工厂设计模式？而不是工厂设计模式 如果使用工厂设计模式，可能会因为工厂类太多而产生类爆炸的现象 产品族和产品等级 工厂方法针对的就是产品等级结构，它处理的就是同一类型产品（如：产品类型都是冰箱但是有不同品牌） 抽象工厂针对的就是产品族，它处理的就是一系列产品（如：海尔旗下不同的产品） 简单场景说明 一个课程不仅要有视频资料，还需要有对应的笔记,这样两者都存在才是一门课程。 抽象工厂演练 笔记 1234567891011121314package com.design.pattern.abstractfactory;/** * Article * * @author shunhua * @date 2019-09-10 */public abstract class Article &#123; /** * 生产笔记的方法 */ public abstract void produce();&#125; java笔记 123456789101112131415161718package com.design.pattern.abstractfactory;import lombok.extern.slf4j.Slf4j;/** * JavaArticle * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class JavaArticle extends Article &#123; @Override public void produce() &#123; log.info(\"生产Java笔记\"); &#125;&#125; python笔记 123456789101112131415161718package com.design.pattern.abstractfactory;import lombok.extern.slf4j.Slf4j;/** * PythonArticle * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class PythonArticle extends Article &#123; @Override public void produce() &#123; log.info(\"生产python笔记\"); &#125;&#125; 视频资源 1234567891011121314package com.design.pattern.abstractfactory;/** * Video * * @author shunhua * @date 2019-09-10 */public abstract class Video &#123; /** * 生产视频的抽象方法 */ public abstract void produce();&#125; Java视频资源 123456789101112131415161718package com.design.pattern.abstractfactory;import lombok.extern.slf4j.Slf4j;/** * JavaVideo * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class JavaVideo extends Video &#123; @Override public void produce() &#123; log.info(\"生成Java视频资源\"); &#125;&#125; python视频资源 123456789101112131415161718package com.design.pattern.abstractfactory;import lombok.extern.slf4j.Slf4j;/** * PythonVideo * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class PythonVideo extends Video &#123; @Override public void produce() &#123; log.info(\"生产python视频\"); &#125;&#125; 课程工厂（产品族工厂） 1234567891011121314151617181920package com.design.pattern.abstractfactory;/** * CourseFactory * * @author shunhua * @date 2019-09-10 */public interface CourseFactory &#123; /** * 生产视频 * @return */ Video getVideo(); /** * 生产笔记 * @return */ Article getArticle();&#125; Java课程工厂 1234567891011121314151617181920package com.design.pattern.abstractfactory;/** * JavaCourseFactory * * @author shunhua * @date 2019-09-10 */public class JavaCourseFactory implements CourseFactory &#123; @Override public Video getVideo() &#123; return new JavaVideo(); &#125; @Override public Article getArticle() &#123; return new JavaArticle(); &#125;&#125; Python课程工厂 1234567891011121314151617181920package com.design.pattern.abstractfactory;/** * PythonCourseFactory * * @author shunhua * @date 2019-09-10 */public class PythonCourseFactory implements CourseFactory&#123; @Override public Video getVideo() &#123; return new PythonVideo(); &#125; @Override public Article getArticle() &#123; return new PythonArticle(); &#125;&#125; 客户端 123456789101112131415161718192021package com.design.pattern.abstractfactory;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-10 */public class Client &#123; @Test public void test()&#123; CourseFactory courseFactory = new JavaCourseFactory(); Video video = courseFactory.getVideo(); Article article = courseFactory.getArticle(); video.produce(); article.produce(); &#125;&#125; 抽象工厂在源码中的使用源码解析Connection的两个方法属性同一个产品族，这是一个父类 1234567891011121314151617181920// mysql和oracle获取的是同一产品族下的statement和同一产品族下的preparestatementpublic interface Connection extends Wrapper, AutoCloseable &#123; Statement createStatement() throws SQLException; PreparedStatement prepareStatement(String sql) throws SQLException; // ... &#125; // executeQuery方法和execureUpdate方法属于同一个产品族public interface Statement extends Wrapper, AutoCloseable &#123; ResultSet executeQuery(String sql) throws SQLException; int executeUpdate(String sql) throws SQLException; &#125; MyBatis的SqlSession源码解析java.sql.Connection/java.sql.Statement/org.apache.ibatis.session.SqlSessionFactory等 接口就是一个抽象工厂（从同一个抽象工厂中返回的产品一定属于同一个产品族）它里面有多个工厂方法，它的实现类通过实现不同的工厂方法，来创建出不同的产品。 SqlSessionFactory 12345678910111213141516171819202122232425package org.apache.ibatis.session;import java.sql.Connection;/** * Creates an &#123;@link SqlSession&#125; out of a connection or a DataSource * * @author Clinton Begin */public interface SqlSessionFactory &#123; SqlSession openSession(); SqlSession openSession(boolean autoCommit); SqlSession openSession(Connection connection); SqlSession openSession(TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType); SqlSession openSession(ExecutorType execType, boolean autoCommit); SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType, Connection connection); Configuration getConfiguration();&#125; SqlSessionFactory子类 SqlSessionManagerSqlSessionFactory子类 DefaultSqlSessionFactory","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂方法","slug":"design_pattern/creation_type/工厂方法","date":"2019-09-08T16:00:00.000Z","updated":"2020-09-04T06:09:12.309Z","comments":true,"path":"posts/a778ad08/","link":"","permalink":"https://gentryhuang.com/posts/a778ad08/","excerpt":"","text":"定义 定义一个创建对象的接口（抽象方法），让实现这个接口的类（实现抽象方法）来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行，即通过子类实现抽象方法来创建对象。 工厂方法就是用来解决同一产品等级的业务抽象问题。工厂创建对象用的，方法通过子类实现方法来创建对象。 类型 创建型 使用场景 创建对象需要大量的重复代码 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节 一个类通过其子类来指定创建哪个对象优点用户只需要关心所需产品对应的工厂，无须关心创建细节。加入新的产品符合开闭原则，提高了可扩展性。缺点实现类的个数容易过多（增加新产品的时候，不仅需要编写新的产品类还需要编写对应的工厂类，因此类的个数增加）、增加复杂度。工厂方法本身使用了抽象，我们需要引入抽象层，如果想要动态创建可能还会使用反射技术，这都增加了系统的抽象性和理解难度产品等级和产品族 工厂方法是为了决绝同一产品等级的业务抽象问题，抽象工厂是为了解决同一产品族的问题 产品等级相同类型的产品为同一产品等级，如：汽车有大众、长安、奥迪等，它们属于同一产品等级 产品族不同类型的产品，如长安汽车、长安摩托、长安自行车 工厂方法演练 Food类 1234567891011121314package com.design.pattern.factorymethod;/** * 相同类型的产品属于同一产品等级，无论是面包还是沙拉，它们都是同一个等级，这里是Food * * @author shunhua * @date 2019-09-09 */public abstract class Food &#123; /** * 生产产品方法 */ public abstract void produce();&#125; 面包类 123456789101112131415161718192021package com.design.pattern.factorymethod;import lombok.Data;import lombok.ToString;import lombok.extern.slf4j.Slf4j;/** * Bread * * @author shunhua * @date 2019-09-09 */@Slf4j@ToStringpublic class Bread extends Food &#123; @Override public void produce() &#123; log.info(\"生产面包!\"); &#125;&#125; 沙拉类 1234567891011121314151617181920package com.design.pattern.factorymethod;import lombok.ToString;import lombok.extern.slf4j.Slf4j;/** * Salad * * @author shunhua * @date 2019-09-09 */@Slf4j@ToStringpublic class Salad extends Food &#123; @Override public void produce() &#123; log.info(\"生成沙拉!\"); &#125;&#125; 抽象工厂 123456789101112131415package com.design.pattern.factorymethod;/** * 工厂方法,子类继承即可 * 这里使用抽象类主要考虑到在类中有些是已知的，使用抽象类合适。如果全都是未知的使用接口比较合适。 * @author shunhua * @date 2019-09-09 */public abstract class FoodFactory &#123; /** * 工厂方法，起到规约的作用，并不生产具体的产品，具体产品的生成由其实现完成 * @return */ public abstract Food createFood();&#125; 子工厂类-面包工厂 12345678910111213141516171819package com.design.pattern.factorymethod;/** * BreadFactory 只生产Bread * * @author shunhua * @date 2019-09-10 */public class BreadFactory extends FoodFactory &#123; /** * 生产面包的工厂方法 * @return */ @Override public Food createFood() &#123; return new Bread(); &#125;&#125; 子工厂类-沙拉工厂 123456789101112131415161718package com.design.pattern.factorymethod;/** * SaladFactory 只生产Salad * * @author shunhua * @date 2019-09-10 */public class SaladFactory extends FoodFactory &#123; /** * 生产面包的工厂方法 * @return */ @Override public Food createFood() &#123; return new Salad(); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728package com.design.pattern.factorymethod;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class Client &#123; @Test public void test()&#123; // 面包工厂方法 FoodFactory breadFactory = new BreadFactory(); Food bread = breadFactory.createFood(); log.info(String.valueOf(bread)); // 沙拉工厂方法 FoodFactory saladFactory = new SaladFactory(); Food salad = saladFactory.createFood(); log.info(String.valueOf(salad)); &#125;&#125; 工厂方法在源码中的使用Collection的Iterator解析Collection接口相当于抽象工厂（因为它处理的是等级组问题即多个类型的产品），其中它里面的Iterator iterator()方法相当于工厂方法。ArrayList实现了这个方法，该方法为ArrayList生产Itr，Itr是Iterator类型。还有ILoggerFactory和Logger产品族对应的工厂方法的使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"合成复用原则","slug":"design_pattern/principle/合成复用原则","date":"2019-09-04T16:00:00.000Z","updated":"2020-07-04T13:42:18.872Z","comments":true,"path":"posts/b91a199d/","link":"","permalink":"https://gentryhuang.com/posts/b91a199d/","excerpt":"","text":"继承关系的选择 继承关系是is a的关系，所以看是否有继承关系，通常要看子类和父类共用的方法，子类是否能够实现父类的方法 起名 合成复用原则，组合复用原则，聚合复用原则 定义 尽量使用组合，聚合，而不是继承关系达到复用软件的目的 组合聚合（黑箱复用） 优点降低耦合，提高系统的灵活性。使一个类的变化对其他类造成的影响较小 缺点会生成较多的对象进行管理 继承（白箱复用） 优点新的扩展性容易实现，修改和扩展相对容易 缺点父类的方法侵入性的带给子类，父类方法的改变，子类也必须改变，相比耦合较高 组合聚合区别关系强弱，组合强，聚合弱","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"里氏替换原则","slug":"design_pattern/principle/里氏替换原则","date":"2019-09-03T16:00:00.000Z","updated":"2020-07-04T13:42:18.873Z","comments":true,"path":"posts/3d1cbe69/","link":"","permalink":"https://gentryhuang.com/posts/3d1cbe69/","excerpt":"","text":"定义 如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。 定义扩展 一个软件实体如果适用一个父类的话，那一定适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。（反对子类重写父类） 特点123456789◆引申意义：子类可以扩展父类的功能，但不能改变父类原有的功能。◆含义1：子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。◆含义2：子类中可以增加自己特有的方法。◆含义3：当子类的方法重载父类的方法时，方法的前置条件（即方法的输入&#x2F;入参）要比父类方法的输入参数更宽松。（入参宽松）◆含义4：当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的输出&#x2F;返回值）要比父类更严格或相等。（出参严谨）（前两条，约定子类最好不要重写父类的方法，如果一定要重写的话，可以使用组合聚合等方法实现）（后两条,约定了子啊重载或实现父类方法的条件） 优点 约束了继承泛滥，很多非子类父类关系的类，没必要使用继承关系 加强程序的可维护性，降低需求变更时引起的风险 coding里氏替换原则继承关系判别（是否是真正意义的继承）1子类行为规则应与父类行为规则一致，如果子类达不到这一点，则会违背里氏替换原则，违背里氏替换原则会怎样？继承逻辑混乱，代码不便于维护 入参控制1重载的时候入参要更加宽松，可以不引起逻辑混乱 父类 1234567import java.util.HashMap;public class Base &#123; public void method(HashMap hashMap)&#123; System.out.println(\"执行父类HashMap方法\"); &#125;&#125; 子类 12345678910111213141516171819import java.util.HashMap;import java.util.Map;public class Child extends Base&#123; // @Override // public void method(HashMap hashMap) &#123; // System.out.println(\"执行子类的HashMap方法\"); // &#125; /** * 子类重载 * 重载的时候入参 Map比 Hashmap宽松，此时执行的时候会执行父类，不执行重载的类 * @param Map */ public void method(Map Map) &#123; System.out.println(\"执行子类Map方法\"); &#125;&#125; 出参控制1子类的出参如果包含父类，会直接报错 父类 12345678910111213package com.design.pattern.principle.liskovSubstitutation.outputmethod;import java.util.Map;/** * Base * * @author shunhua * @date 2019-09-15 */public abstract class Base &#123; public abstract Map method();&#125; 子类 12345678910111213141516171819202122232425262728293031package com.design.pattern.principle.liskovSubstitutation.outputmethod;import java.util.HashMap;import java.util.Map;/** * Child * * @author shunhua * @date 2019-09-15 */public class Child extends Base &#123; /** * 子类的出参如果包含父类，会直接报错。 * @return */ /* @Override public Object method() &#123; return null; &#125;*/ /** * 父类的出参包含子类的出参是可以的 * @return */ @Override public HashMap method()&#123; return new HashMap(2); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"接口隔离原则","slug":"design_pattern/principle/接口隔离原则","date":"2019-09-02T16:00:00.000Z","updated":"2020-07-04T13:42:18.871Z","comments":true,"path":"posts/e0ec8882/","link":"","permalink":"https://gentryhuang.com/posts/e0ec8882/","excerpt":"","text":"定义 用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。 注意点 一个类对一个类的依赖应该建立在最小的接口上（这里的类是泛指，也代表接口）。 建立单一接口，不要建立庞大臃肿的接口 尽量细化接口，接口中的方法尽量少 注意适度原则，一定要适度，虽然接口中的方法尽量少，但是也要有限度。优点符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。和单一职责原则比较单一职责原则指的是类、接口和方法的职责是单一的，强调的是职责，如果职责是单一的那么在类或者接口中具有多个方法都是可以的，因为它们都是一类的，比如叫声，不同的动物有不同的叫。接口隔离原则注重地是对接口依赖的隔离。简单需求说明使用统一的接口定义多个功能的方法，但是有的实现不一定会全部用到，最好是将这个统一的接口根据不同的维度进行拆分成多个接口，实现根据需要进行接口的实现。 coding接口隔离原则反例接口 12345public interface IAnimalAction &#123; void eat(); void fly(); void swim();&#125; 狗实现类 1234567891011121314151617181920public class DogCaseOne implements IAnimalAction&#123; @Override public void eat() &#123; &#125; /** * 注：这里是空方法，狗不会飞，所以明显设计的不合理，最好不要有太多的空方法 */ @Override public void fly() &#123; &#125; @Override public void swim() &#123; &#125;&#125; 鸟实现类 12345678910111213141516171819public class LarkCaseOne implements IAnimalAction&#123; @Override public void eat() &#123; &#125; @Override public void fly() &#123; &#125; /** * 很明显，百灵鸟不会游泳，此处为空方法，设计不合理 */ @Override public void swim() &#123; &#125;&#125; 接口隔离原则正例吃东西接口 123456public interface IEat&#123; /** * 吃东西 */ void eat();&#125; 飞翔接口 123456public interface IFly&#123; /** * 飞翔 */ void fly();&#125; 游泳接口 123456public interface ISwim&#123; /** * 游泳 */ void swim();&#125; 狗实现类 123456789101112131415/** * 狗只用实现 吃和游泳方法即可 */@Slf4jpublic class DogCaseTwo implements IEat,ISwim&#123; @Override public void eat() &#123; log.info(\"狗吃东西!\"); &#125; @Override public void swim() &#123; log.info(\"狗游泳\"); &#125;&#125; 鸟实现类 123456789101112131415/** * 鸟实现 吃和飞方法即可 */@Slf4jpublic class LarkCaseTwo implements IEat,IFly&#123; @Override public void eat() &#123; log.info(\"鸟吃东西\"); &#125; @Override public void fly() &#123; log.info(\"鸟飞翔\"); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"迪米特法则","slug":"design_pattern/principle/迪米特法则","date":"2019-09-02T16:00:00.000Z","updated":"2020-07-04T13:42:18.870Z","comments":true,"path":"posts/ebdadec7/","link":"","permalink":"https://gentryhuang.com/posts/ebdadec7/","excerpt":"","text":"定义 迪米特法则也叫最少知道原则,一个对象应该对其他对象保持最少的了解（比如包的权限，修饰的关键字）。尽量降低类与类之间的耦合。 优点 降低类之间的耦合。 强调 只关心出现在成员变量、方法的入参和出参中的类，不关心方法体内部的类。 简单需求说明 公司老板想了解某个业务组的项目情况，老板直接找到TeamLeader，不需要关心项目组其他成员。而TeamLeader需要让组内 某个成员进行整理资料，然交给自己，自己再交给老板。 coding迪米特法则反例老板类 123456789101112131415161718import java.util.ArrayList;import java.util.List;/** * 此处设计不合理，只访问朋友类（成员变量中的类，输入中出现的类，输出中出现的类） * 成员方法中的类不需要引入(Member) */public class Boss &#123; public void findMembers()&#123; TeamLeader leader = new TeamLeader(); List&lt;Member&gt; list = new ArrayList&lt;Member&gt;(); for(int i= 0;i&lt;10;i++)&#123; list.add(new Member()); &#125; leader.countMember(list); &#125;&#125; 主管类 12345678import java.util.List;@Slf4jpublic class TeamLeader &#123; public void countMember(List list)&#123; log.info(\"当前项目组的成员数：\"+list.size()); &#125;&#125; 项目组成员类 12345678910111213public class Member &#123; // ..&#125;``` **应用类**```javapublic class Client&#123; public static void main(String[] args)&#123; Boss boss = new Boss(); boss.findMembers(); &#125;&#125; 迪米特法则正例老板类 1234567891011121314151617package com.design.pattern.principle.demeter;/** * Boss * * @author shunhua * @date 2019-09-03 */public class Boss &#123; /** * 对Member不需要见，只关心TeamLeader * @param teamLeader */ public void findProject(TeamLeader teamLeader)&#123; teamLeader.findProject(); &#125;&#125; 主管类 1234567891011121314151617181920package com.design.pattern.principle.demeter;import lombok.extern.slf4j.Slf4j;/** * TeamLeader * * @author shunhua * @date 2019-09-03 */@Slf4jpublic class TeamLeader &#123; /** * 关注Member */ public void findProject()&#123; Member member = new Member(); log.info(String.valueOf(member)); &#125;&#125; 成员类 1234567891011package com.design.pattern.principle.demeter;/** * Member * * @author shunhua * @date 2019-09-03 */public class Member &#123; // ..&#125; 应用 12345678910111213141516171819202122package com.design.pattern.principle;import com.design.pattern.principle.demeter.Boss;import com.design.pattern.principle.demeter.TeamLeader;import org.junit.Test;/** * DemeterTest * * @author shunhua * @date 2019-09-03 */public class DemeterTest &#123; @Test public void test()&#123; Boss boss = new Boss(); TeamLeader teamLeader = new TeamLeader(); boss.findProject(teamLeader); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"依赖倒置原则","slug":"design_pattern/principle/依赖倒置原则","date":"2019-09-01T16:00:00.000Z","updated":"2020-07-04T13:42:18.866Z","comments":true,"path":"posts/91021fa8/","link":"","permalink":"https://gentryhuang.com/posts/91021fa8/","excerpt":"","text":"定义 高层模块不应该依赖低层模块，二者都应该依赖其抽象。 优点 可以减少类间的耦合性、提高系统稳定性，增强代码可读性和可维护性，可降低修改程序造成的风险。 细节描述 抽象不应该依赖细节，细节应该依赖抽象。针对接口编程而不要针对实现编程。 简单需求说明 某同学想要学习某一课程，最简单的方式直接在Person中编写一个方法即可，但是如果以后想要学习其他课程就 需要修改Person类。为了解耦，我们可以把课程抽象出去，高层对底层的依赖，这样Person依赖的就是抽象，我 们针对接口编程，而不是针对实现编程。 coding非面向抽象编程12345678910111213141516171819202122232425缺点：应用依赖具体的实现，对于后续需求变更更加不适用&#96;&#96;&#96; **实体类**&#96;&#96;&#96;javapackage com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;&#x2F;** * Person * * @author shunhua * @date 2019-09-02 *&#x2F;@Slf4jpublic class Person &#123; public void learnJavaCourse()&#123; log.info(&quot;学习Java课程&quot;); &#125; public void learnPythonCourse()&#123; log.info(&quot;学习Python课程&quot;); &#125;&#125; 应用 12345678910111213141516171819202122package com.design.pattern.principle;import com.design.pattern.principle.dependenceinversion.PythonCourse;import com.design.pattern.principle.dependenceinversion.JavaCourse;import com.design.pattern.principle.dependenceinversion.Person;import org.junit.Test;/** * DependeceinversionTest * * @author shunhua * @date 2019-09-02 */public class DependeceinversionTest &#123; @Test public void test()&#123; Person person = new Person(); person.studyJava(); person.studyPython(); &#125;&#125; 面向接口编程1这里使用接口方法传参的方式 课程接口 1234567891011121314package com.design.pattern.principle.dependenceinversion;/** * ICourse * * @author shunhua * @date 2019-09-02 */public interface ICourse &#123; /** * 学习课程 */ void learnCourse();&#125; Java课程 123456789101112131415161718package com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;/** * JavaCourse * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class JavaCourse implements ICourse &#123; @Override public void learnCourse() &#123; log.info(\"gentryhuang is learning java\"); &#125;&#125; Python课程 123456789101112131415161718package com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;/** * PythonCourse * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class PythonCourse implements ICourse &#123; @Override public void learnCourse() &#123; log.info(\"gentryhuang is learning python\"); &#125;&#125; 实体 1234567891011121314151617package com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;/** * Person * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class Person &#123; public void learnCource(ICourse course)&#123; course.learnCourse(); &#125;&#125; 应用 123456789101112131415161718192021package com.design.pattern.principle;import com.design.pattern.principle.dependenceinversion.PythonCourse;import com.design.pattern.principle.dependenceinversion.JavaCourse;import com.design.pattern.principle.dependenceinversion.Person;import org.junit.Test;/** * DependeceinversionTest * * @author shunhua * @date 2019-09-02 */public class DependeceinversionTest &#123; @Test public void test()&#123; Person person = new Person(); person.learnCource(new JavaCourse()); person.learnCource(new PythonCourse()); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单一职责原则","slug":"design_pattern/principle/单一职责原则","date":"2019-09-01T16:00:00.000Z","updated":"2020-07-04T13:42:18.868Z","comments":true,"path":"posts/46a1bcf2/","link":"","permalink":"https://gentryhuang.com/posts/46a1bcf2/","excerpt":"","text":"定义 不要存在多于一个导致类变更的原因。体现在一个类/接口/方法只负责一项职责。 优点 降低类的复杂度、提高类的可读性，提高系统的可维护性，降低变更引起的风险。 详解 在类的级别上，可以定义不同的类实现不同的功能，在接口级别上，可以根据功能抽象出不同的接口，然后按需要实现一个或多个接口。方法级别上，可以做到不同的方法实现不同的操作。 要点讲解12341. 实际应用中，类不采用单一职责，接口和方法采用单一职责。2. 定义：单一职责规定 一个类，接口或者方法，只有一个变化的原因3. 优点：降低类的复杂性，提高可读性，维护时风险降低4. 实际应用，受依赖，组合，聚合这些关系影响，同时受控于项目规模，项目周期，技术人员水平，对进度把控等影响。应适当的应用单一职责原则 简单需求说明 完成不同功能，并且使设计模块具有可读性和可维护性。可以使用不同的类或接口或方法去完成某一类功能，这样就显得单一，具有针对性。 类的单一职责原则实体类1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.design.pattern.principle.singleresponsibility;import lombok.extern.slf4j.Slf4j;/** * WalkBird * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class WalkBird &#123; public void moveMode(String birdName)&#123; log.info(birdName + \"陆地奔跑\"); &#125;&#125;``` **实体类2**```javapackage com.design.pattern.principle.singleresponsibility;import lombok.extern.slf4j.Slf4j;/** * FlyBird * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class FlyBird &#123; public void moveMode(String birdName)&#123; log.info(birdName + \"用翅膀飞\"); &#125;&#125;``` **应用**```javapublic class Client &#123; public static void main(String[] args) &#123; WalkBird walkBird = new WalkBird(); walkBird.birdMove(\"鸵鸟\"); FlyBird flyBird = new FlyBird(); flyBird.birdMove(\"大雁\"); &#125;&#125;``` ### 接口的单一职责**接口1**```java/** * 这个接口和获取内容的接口有先后顺序，只有开始学习，才能获取内容，如果退出学习，就不能在获取内容了， * 由于职责不同，所以设计两个接口符合单一职责原则 */public interface IcourseAction &#123; void beginStudy(); void quitStudy();&#125; 接口2 1234567/** * 注，本接口主要是获取课程的内容 */public interface IcourseContent &#123; String getCourseText();//获取课程文本内容 byte[] getCourseVideo();//获取课程的视频&#125; 实体类 12345678910111213141516171819202122@Slf4jpublic class Course implements IcourseAction,IcourseContent&#123; @Override public void beginStudy() &#123; log.info(\"开始学习!\"); &#125; @Override public void quitStudy() &#123; log.info(\"学习完成！\"); &#125; @Override public String getCourseText() &#123; return \"Java 资料\"; &#125; @Override public byte[] getCourseVideo() &#123; return new byte[0]; &#125;&#125; 方法的单一职责12345678910111213141516171819202122232425public class Method &#123; /** * 单一职责原则，修改用户的名称 * @return */ public String updateUserName()&#123; return \"\"; &#125; /** * 单一职责原则,修改用户的密码 * @return */ public String updateUserPassWord()&#123; return \"\"; &#125; /** * 不符合单一职责 * @return */ public String updateUserInfo(String userId,String gender)&#123; return \" \"; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"开闭原则","slug":"design_pattern/principle/开闭原则","date":"2019-08-31T16:00:00.000Z","updated":"2020-07-04T13:42:18.869Z","comments":true,"path":"posts/f50731fc/","link":"","permalink":"https://gentryhuang.com/posts/f50731fc/","excerpt":"","text":"定义 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 强调的是用抽象构建框架，用实现扩展细节。 核心思想 面向抽象编程，因为抽象是稳定的。 理解 不改变原先的业务逻辑，新增的功能点通过重写复用的方法进行编程。 优点 提高软件系统的可复用性以及可维护性 简单需求说明 软件实体ICourse，以及它的实现JavaCource实现了基本功能，如需要额外的功能可以对JavaCourse进行扩展即继承来添加， 这样在不修改底层的ICourse和JavaCourse的前提下，做到功能的添加。即，越基层的模块影响范围越大，越高层的模块影响 范围较小，总体实现了对扩展开放，对修改关闭，这样就可以有效解决影响范围。 codingv1 基类1需求：打印出原价以及课程其他信息 接口 12345678910111213141516171819202122232425package com.design.pattern.principle.openclose;/** * ICourse * * @author shunhua * @date 2019-09-01 */public interface ICourse &#123; /** * 获取课程id * @return */ Integer getId(); /** * 获取课程名称 * @return */ String getName(); /** * 获取课程价格 * @return */ Double getPrice();&#125; 实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.design.pattern.principle.openclose;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * JavaCourse * * @author shunhua * @date 2019-09-01 */@AllArgsConstructor@NoArgsConstructor@Datapublic class JavaCourse implements ICourse &#123; /** * 课程id */ private Integer id; /** * 课程名称 */ private String name; /** * 课程价格 */ private Double price; @Override public Integer getId() &#123; return this.id; &#125; @Override public String getName() &#123; return this.name; &#125; @Override public Double getPrice() &#123; return this.price; &#125;&#125; 应用 123456789101112131415161718192021222324252627package com.design.pattern.principle;import com.design.pattern.principle.openclose.ICourse;import com.design.pattern.principle.openclose.JavaCourse;import com.design.pattern.principle.openclose.JavaDiscountCourse;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * OpencloseTest * * @author shunhua * @date 2019-09-01 */@Slf4jpublic class OpencloseTest &#123; @Test public void testBase()&#123; ICourse javaCourse = new JavaCourse(100,\"Java从入门到放弃\",200d); log.info(String.format(\"课程id: %d,课程名: %s, 课程价格：%f\", javaCourse.getId(), javaCourse.getName(), javaCourse.getPrice()) ); &#125;&#125; v21需求：打印出原价和折扣后的价格以及课程其他信息（接口不应该随意发生变化，面向接口编程） 接口 12345678910111213141516171819202122232425package com.design.pattern.principle.openclose;/** * ICourse * * @author shunhua * @date 2019-09-01 */public interface ICourse &#123; /** * 获取课程id * @return */ Integer getId(); /** * 获取课程名称 * @return */ String getName(); /** * 获取课程价格 * @return */ Double getPrice();&#125; 实体类 1234567891011121314151617181920212223242526272829303132package com.design.pattern.principle.openclose;/** * JavaDiscountCourse * * @author shunhua * @date 2019-09-01 */public class JavaDiscountCourse extends JavaCourse &#123; public JavaDiscountCourse(Integer id, String name, Double price) &#123; super(id, name, price); &#125; /** * 获取折扣价 * @return */ @Override public Double getPrice() &#123; return super.getPrice() * 0.8; &#125; /** * 获取原价 * @return */ public Double getOriginPrice()&#123; return super.getPrice(); &#125;&#125; 应用 123456789101112131415161718192021222324252627282930313233343536373839package com.design.pattern.principle;import com.design.pattern.principle.openclose.ICourse;import com.design.pattern.principle.openclose.JavaCourse;import com.design.pattern.principle.openclose.JavaDiscountCourse;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * OpencloseTest * * @author shunhua * @date 2019-09-01 */@Slf4jpublic class OpencloseTest &#123; @Test public void testBase()&#123; ICourse javaCourse = new JavaCourse(100,\"Java从入门到放弃\",200d); log.info(String.format(\"课程id: %d,课程名: %s, 课程价格：%f\", javaCourse.getId(), javaCourse.getName(), javaCourse.getPrice()) ); &#125; @Test public void testEx()&#123; ICourse javaCource = new JavaDiscountCourse(100,\"java从入门到放弃\",200d); log.info(String.format(\"课程id: %d,课程名: %s, 课程原价：%f，课程折扣价格：%f\", javaCource.getId(), javaCource.getName(), ((JavaDiscountCourse) javaCource).getOriginPrice(), javaCource.getPrice()) ); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"简单工厂","slug":"design_pattern/other_type/简单工厂","date":"2019-08-28T16:00:00.000Z","updated":"2020-08-09T09:24:21.833Z","comments":true,"path":"posts/90fd4bf3/","link":"","permalink":"https://gentryhuang.com/posts/90fd4bf3/","excerpt":"","text":"定义 由一个工厂对象决定创建出哪一种产品类的实例 类型 创建型，但不属于GOF23种设计模式。简单工厂模式严格意义上说并不是一种设计模式，它是一种编码上的风格和习惯 使用场景 工厂类负责创建的对象比较少 客户端（应用层）只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心优点只需要传入一个正确的参数，就可以获取所需要的对象而无须知道其创建细节缺点简单工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背了开闭原则。 coding未使用简单工厂模式的代码父类 12345678910111213public abstract class Video&#123; public abstract void printVideo();&#125;``` **子类JavaVideo**```java@Slf4jpublic class JavaVideo extends Video&#123; @Override public void printVideo() &#123; log.info(\"录制java视频\"); &#125;&#125; 子类PythonVideo 1234567@Slf4jpublic class PythonVideo extends Video&#123; @Override public void printVideo() &#123; log.info(\"录制python视频\"); &#125;&#125; 应用 1234567public class client&#123; @Test public void test()&#123; Video video = new JavaVideo(); video.printVideo(); &#125;&#125; 使用简单工厂模式 工厂类 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.design.pattern.simplefactory;/** * 简单工厂 * * @author shunhua * @date 2019-09-09 */public class FoodFactory &#123; /** * 随着要产品增多，以下逻辑必须要修改 * @param type 这里使用字符串根据类型进行创建不同的实例 * @return */ public Food createFood(String type)&#123; if(\"salad\".equalsIgnoreCase(type))&#123; return new Salad(); &#125;else if(\"bread\".equalsIgnoreCase(type))&#123; return new Bread(); &#125; return null; &#125; /** * * @param c 这里使用反射创建不同的实例 * @return */ public Food createFood(Class c)&#123; Food food = null; try &#123; food = (Food) Class.forName(c.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return food; &#125;&#125; 父类 1234567891011121314package com.design.pattern.simplefactory;/** * Food * * @author shunhua * @date 2019-09-09 */public abstract class Food &#123; /** * 生产产品方法 */ public abstract void produce();&#125; 子类面包 123456789101112131415161718package com.design.pattern.simplefactory;import lombok.extern.slf4j.Slf4j;/** * Bread * * @author shunhua * @date 2019-09-09 */@Slf4jpublic class Bread extends Food &#123; @Override public void produce() &#123; log.info(\"生产面包!\"); &#125;&#125; 子类沙拉 123456789101112131415161718package com.design.pattern.simplefactory;import lombok.extern.slf4j.Slf4j;/** * Salad * * @author shunhua * @date 2019-09-09 */@Slf4jpublic class Salad extends Food &#123; @Override public void produce() &#123; log.info(\"生成沙拉!\"); &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.design.pattern.simplefactory;import com.common.base.ObjectUtils;import com.design.pattern.simplefactory.Bread;import com.design.pattern.simplefactory.Food;import com.design.pattern.simplefactory.FoodFactory;import com.design.pattern.simplefactory.Salad;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-09 */public class Client &#123; /* 非简单工厂模式 @Test public void simpleFactoryBefore()&#123; // 这里需要依赖具体的生产类 Food food = new Bread(); Food food1 = new Salad(); food.produce(); food1.produce(); &#125;*/ /* @Test public void simpleFactoryByType()&#123; // 创建一个简单工厂 FoodFactory factory = new FoodFactory(); // 由工厂创建实例对象 Food food = factory.createFood(\"salad\"); food.produce(); &#125; */ @Test public void simpleFactoryByClass()&#123; FoodFactory factory = new FoodFactory(); Food food = factory.createFood(Bread.class); if(ObjectUtils.isNotNull(food))&#123; food.produce(); &#125; &#125;&#125; 简单工厂在源码中的使用jdk的Calendar源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445// 这里使用的是静态方法，因为不需要再通过继承进行扩展。如需扩展就不使用static关键字public static Calendar getInstance(TimeZone zone, Locale aLocale)&#123; return createCalendar(zone, aLocale); &#125; private static Calendar createCalendar(TimeZone zone, Locale aLocale) &#123; CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale).getCalendarProvider(); if (provider != null) &#123; try &#123; return provider.getInstance(zone, aLocale); &#125; catch (IllegalArgumentException iae) &#123; // fall back to the default instantiation &#125; &#125; Calendar cal = null; if (aLocale.hasExtensions()) &#123; String caltype = aLocale.getUnicodeLocaleType(\"ca\"); if (caltype != null) &#123; // 根据不同的类型创建日期对象 switch (caltype) &#123; case \"buddhist\": cal = new BuddhistCalendar(zone, aLocale); break; case \"japanese\": cal = new JapaneseImperialCalendar(zone, aLocale); break; case \"gregory\": cal = new GregorianCalendar(zone, aLocale); break; &#125; &#125; &#125; if (cal == null) &#123; if (aLocale.getLanguage() == \"th\" &amp;&amp; aLocale.getCountry() == \"TH\") &#123; cal = new BuddhistCalendar(zone, aLocale); &#125; else if (aLocale.getVariant() == \"JP\" &amp;&amp; aLocale.getLanguage() == \"ja\" &amp;&amp; aLocale.getCountry() == \"JP\") &#123; cal = new JapaneseImperialCalendar(zone, aLocale); &#125; else &#123; cal = new GregorianCalendar(zone, aLocale); &#125; &#125; return cal; &#125; DriverManager源码解析（通过classForName获取）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public static Connection getConnection(String url, java.util.Properties info) throws SQLException &#123; // Gets the classloader of the code that called this method, may // be null. ClassLoader callerCL = DriverManager.getCallerClassLoader(); return (getConnection(url, info, callerCL)); &#125;// Worker method called by the public getConnection() methods. private static Connection getConnection( String url, java.util.Properties info, ClassLoader callerCL) throws SQLException &#123; java.util.Vector drivers = null; /* * When callerCl is null, we should check the application's * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if(callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; if(url == null) &#123; throw new SQLException(\"The url cannot be null\", \"08001\"); &#125; println(\"DriverManager.getConnection(\\\"\" + url + \"\\\")\"); if (!initialized) &#123; initialize(); &#125; synchronized (DriverManager.class)&#123; // use the readcopy of drivers drivers = readDrivers; &#125; // Walk through the loaded drivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for (int i = 0; i &lt; drivers.size(); i++) &#123; DriverInfo di = (DriverInfo)drivers.elementAt(i); // If the caller does not have permission to load the driver then // skip it. if ( getCallerClass(callerCL, di.driverClassName ) != di.driverClass ) &#123; println(\" skipping: \" + di); continue; &#125; try &#123; println(\" trying \" + di); Connection result = di.driver.connect(url, info); if (result != null) &#123; // Success! println(\"getConnection returning \" + di); return (result); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; // if we got here nobody could connect. if (reason != null) &#123; println(\"getConnection failed: \" + reason); throw reason; &#125; println(\"getConnection: no suitable driver found for \"+ url); throw new SQLException(\"No suitable driver found for \"+ url, \"08001\"); &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"uml基础","slug":"design_pattern/uml","date":"2019-08-27T16:00:00.000Z","updated":"2020-08-09T09:14:31.577Z","comments":true,"path":"posts/cadc5d6c/","link":"","permalink":"https://gentryhuang.com/posts/cadc5d6c/","excerpt":"","text":"定义统一建模语言（缩写UML），非专利的第三代建模和规约语言 特点 UML是一种开放的方法 UML用于说明、可视化、构建和编写一个正在开发的面向对象的、软件密集系统的制品的开放方法 UML展现了一系列最佳工程的实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层面已经被验证有效 UML分类 结构式图形 强调的是系统式的建模，具体包含静态图（类图、对象图、包图）、实现图（组件图、部署图）、剖面图以及复合结构图 行为式图形 强调系统模型中触发的事件，具体包含活动图、状态图以及用例图 交互式图形 属于行为式图形子集合，强调系统模型中资源流程。具体包含通信图、交互概念图、时序图 以及时间图 ​ UML类图用于表示类、接口、实例等之间相互的静态关系。虽然名字叫类图，但类图中并不只有类，还可能包括权限、属性、方法等 UML记忆方式12341. uml箭头：从子类指向父类，只有知道对方信息时才能指向对方方向2. 空心三角箭头：继承或实现，实线-继承：积极的，强关联，关联，通常一个类中有一个类的对象做属性；虚线-实现：消极的，弱关联，依赖3. 空心菱形：聚合，（注：可以看作一个盘子，可以放很多相同的东西（箭头方向所指的类），聚在一起。是has a的关系）弱关联4. 实心菱形：组合，（注：代表器皿里有实体结构存在，组合起来成为一个。是contains-a的关系）强关联 uml箭头：从子类指向父类，定义子类时需要通过extends关键字指定父类，只有知道对方信息时才能指向对方方向 实线-继承 | 虚线-实现 ​ 空心菱形-聚合 实心菱形-组合 组合关系中常见的数字表达 123456◆常见数字表达及含义，假设有A类和B类，数字标记在A类侧◆0..1：0或1个实例 在系统某一时刻，b的实例可以与0个或1个A实例相关◆0..*：0或多个实例 在系统某一时刻，b的实例可以与0个或多个A实例相关◆1..1：1个实例. b的实例可以和1个A实例相关◆1只能有一个实例. b的实例可以和1个A实例相关◆1..*：至少有一个实例. b实例可以与一个或多个A实例相关 UML时序图 是显示对象之间交互的图，这些对象是按照时间顺序排列的 时序图中 包含的建模元素 对象（Actor）、生命线（lifeline）、控制焦点（Focus of control）、消息（Message）等 时序图示例 12345678910111213竖线代表生命线对象：c：client ，s：server，d：device 代表实例消息：箭头代表的元素(open,work等)竖矩形代表实例处于某种活动中，实线实心箭头：代表方法调用，同步调用实线非实心箭头：代表异步调用虚线：代表返回 UML类图讲解123456789101112131415+ 公共方法- private权限# protected权限 包内和包外继承的子类都能引用~ default权限（包权限）只有包内能引用下划线 静态 Static斜体 抽象类（或抽象方法）（包含抽象方法的必是抽象类）（类和至少一个方法都是斜体）方法 可以带参，可以不带参 返回值写到冒号后边，void不用加 UML整体讲解12345678910设计模式中的对象关系: 依赖关系 虚线箭头，箭头方向指向被依赖的部分 组合关系 实心菱形 聚合关系 空心菱形（想象成盘子，盛东西，盘子的多，另一方少） 关联关系 实线箭头，箭头指向被关联的部分 类与类的连接，（它使一个类知道另一个类的属性和方法，关联关 系一般用成员变量实现） 继承 空心三角形实线 实现 空心三角形虚线注意： 实现接口有两种方式，一种是棒棒糖的形式，另一种是虚线空心三角形的方式 UML中部分对比1234567891.1 关联和依赖的对比关联是a类中存在b类对象，企鹅类中有气候类的属性依赖是a类成员方法中有b类的属性，动物新陈代谢方法中有水和空气的属性，只有调这个方法的时候，才可能临时用一下1.2 组合和聚合的对比组合有相同的生命周期，鸟有翅膀，鸟死了，翅膀不复存在大雁群有大雁，一只大雁挂了，大雁群不会消失1.3 继承和实现的对实线：继承虚线：实现","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"Redis","slug":"Redis","permalink":"https://gentryhuang.com/categories/Redis/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"},{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Redis数据结构","slug":"Redis数据结构","permalink":"https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"JDK","slug":"JDK","permalink":"https://gentryhuang.com/tags/JDK/"},{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Spring","slug":"Spring","permalink":"https://gentryhuang.com/tags/Spring/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://gentryhuang.com/tags/Zookeeper/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"},{"name":"Javassist","slug":"Javassist","permalink":"https://gentryhuang.com/tags/Javassist/"},{"name":"SPI","slug":"SPI","permalink":"https://gentryhuang.com/tags/SPI/"},{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}