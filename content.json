{"meta":{"title":"","subtitle":"","description":"","author":null,"url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2020-07-04T07:35:16.691Z","updated":"2020-07-04T07:35:16.691Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"123456789101112131415161718&#x2F;** * * * ┏┓ ┏┓ * ┃ ┃ + +* ┃ ━ ┃ ++ + + +* ████━████ ┃ 🚂🚂🚂-&lt;-&lt; 欢迎访问我的博客* ┃ ┃ + * ┃ ┻ ┃ + + * ┃ ┃ * ┗━┓ ┏━┛Code is far away from bug with the animal protecting * ┃ ┃ 神兽护体，永无bug * ┃ ┃ +* ┃ ┗━━━┓+* ┃ ┣┓ 📬 联系我：gentryhuang.xw@gmail.com* ┃ ┏┛ + + * ┗┓┓┏━┳┓┏┛ +* ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ *&#x2F;"},{"title":"分类","date":"2020-07-03T15:03:26.305Z","updated":"2020-07-03T15:03:26.305Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-07-03T15:03:37.362Z","updated":"2020-07-03T15:03:37.362Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-07-03T15:41:09.493Z","updated":"2020-07-03T15:03:47.905Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-03T15:03:56.993Z","updated":"2020-07-03T15:03:56.993Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"合成复用原则","slug":"合成复用原则","date":"2019-09-04T16:00:00.000Z","updated":"2020-07-04T11:06:12.212Z","comments":true,"path":"2019/09/05/合成复用原则/","link":"","permalink":"http://yoursite.com/2019/09/05/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/","excerpt":"","text":"继承关系的选择 继承关系是is a的关系，所以看是否有继承关系，通常要看子类和父类共用的方法，子类是否能够实现父类的方法 起名 合成复用原则，组合复用原则，聚合复用原则 定义 尽量使用组合，聚合，而不是继承关系达到复用软件的目的 组合聚合（黑箱复用） 优点降低耦合，提高系统的灵活性。使一个类的变化对其他类造成的影响较小 缺点会生成较多的对象进行管理 继承（白箱复用） 优点新的扩展性容易实现，修改和扩展相对容易 缺点父类的方法侵入性的带给子类，父类方法的改变，子类也必须改变，相比耦合较高 组合聚合区别关系强弱，组合强，聚合弱","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"里氏替换原则","slug":"里氏替换原则","date":"2019-09-03T16:00:00.000Z","updated":"2020-07-04T11:04:37.597Z","comments":true,"path":"2019/09/04/里氏替换原则/","link":"","permalink":"http://yoursite.com/2019/09/04/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/","excerpt":"","text":"定义 如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。 定义扩展 一个软件实体如果适用一个父类的话，那一定适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。（反对子类重写父类） 特点123456789◆引申意义：子类可以扩展父类的功能，但不能改变父类原有的功能。◆含义1：子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。◆含义2：子类中可以增加自己特有的方法。◆含义3：当子类的方法重载父类的方法时，方法的前置条件（即方法的输入&#x2F;入参）要比父类方法的输入参数更宽松。（入参宽松）◆含义4：当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的输出&#x2F;返回值）要比父类更严格或相等。（出参严谨）（前两条，约定子类最好不要重写父类的方法，如果一定要重写的话，可以使用组合聚合等方法实现）（后两条,约定了子啊重载或实现父类方法的条件） 优点 约束了继承泛滥，很多非子类父类关系的类，没必要使用继承关系 加强程序的可维护性，降低需求变更时引起的风险 coding里氏替换原则继承关系判别（是否是真正意义的继承）1子类行为规则应与父类行为规则一致，如果子类达不到这一点，则会违背里氏替换原则，违背里氏替换原则会怎样？继承逻辑混乱，代码不便于维护 入参控制1重载的时候入参要更加宽松，可以不引起逻辑混乱 父类 1234567import java.util.HashMap;public class Base &#123; public void method(HashMap hashMap)&#123; System.out.println(\"执行父类HashMap方法\"); &#125;&#125; 子类 12345678910111213141516171819import java.util.HashMap;import java.util.Map;public class Child extends Base&#123; // @Override // public void method(HashMap hashMap) &#123; // System.out.println(\"执行子类的HashMap方法\"); // &#125; /** * 子类重载 * 重载的时候入参 Map比 Hashmap宽松，此时执行的时候会执行父类，不执行重载的类 * @param Map */ public void method(Map Map) &#123; System.out.println(\"执行子类Map方法\"); &#125;&#125; 出参控制1子类的出参如果包含父类，会直接报错 父类 12345678910111213package com.design.pattern.principle.liskovSubstitutation.outputmethod;import java.util.Map;/** * Base * * @author shunhua * @date 2019-09-15 */public abstract class Base &#123; public abstract Map method();&#125; 子类 12345678910111213141516171819202122232425262728293031package com.design.pattern.principle.liskovSubstitutation.outputmethod;import java.util.HashMap;import java.util.Map;/** * Child * * @author shunhua * @date 2019-09-15 */public class Child extends Base &#123; /** * 子类的出参如果包含父类，会直接报错。 * @return */ /* @Override public Object method() &#123; return null; &#125;*/ /** * 父类的出参包含子类的出参是可以的 * @return */ @Override public HashMap method()&#123; return new HashMap(2); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"接口隔离原则","slug":"接口隔离原则","date":"2019-09-02T16:00:00.000Z","updated":"2020-07-04T11:00:45.279Z","comments":true,"path":"2019/09/03/接口隔离原则/","link":"","permalink":"http://yoursite.com/2019/09/03/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/","excerpt":"","text":"定义 用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。 注意点 一个类对一个类的依赖应该建立在最小的接口上（这里的类是泛指，也代表接口）。 建立单一接口，不要建立庞大臃肿的接口 尽量细化接口，接口中的方法尽量少 注意适度原则，一定要适度，虽然接口中的方法尽量少，但是也要有限度。优点符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。和单一职责原则比较单一职责原则指的是类、接口和方法的职责是单一的，强调的是职责，如果职责是单一的那么在类或者接口中具有多个方法都是可以的，因为它们都是一类的，比如叫声，不同的动物有不同的叫。接口隔离原则注重地是对接口依赖的隔离。简单需求说明使用统一的接口定义多个功能的方法，但是有的实现不一定会全部用到，最好是将这个统一的接口根据不同的维度进行拆分成多个接口，实现根据需要进行接口的实现。 coding接口隔离原则反例接口 12345public interface IAnimalAction &#123; void eat(); void fly(); void swim();&#125; 狗实现类 1234567891011121314151617181920public class DogCaseOne implements IAnimalAction&#123; @Override public void eat() &#123; &#125; /** * 注：这里是空方法，狗不会飞，所以明显设计的不合理，最好不要有太多的空方法 */ @Override public void fly() &#123; &#125; @Override public void swim() &#123; &#125;&#125; 鸟实现类 12345678910111213141516171819public class LarkCaseOne implements IAnimalAction&#123; @Override public void eat() &#123; &#125; @Override public void fly() &#123; &#125; /** * 很明显，百灵鸟不会游泳，此处为空方法，设计不合理 */ @Override public void swim() &#123; &#125;&#125; 接口隔离原则正例吃东西接口 123456public interface IEat&#123; /** * 吃东西 */ void eat();&#125; 飞翔接口 123456public interface IFly&#123; /** * 飞翔 */ void fly();&#125; 游泳接口 123456public interface ISwim&#123; /** * 游泳 */ void swim();&#125; 狗实现类 123456789101112131415/** * 狗只用实现 吃和游泳方法即可 */@Slf4jpublic class DogCaseTwo implements IEat,ISwim&#123; @Override public void eat() &#123; log.info(\"狗吃东西!\"); &#125; @Override public void swim() &#123; log.info(\"狗游泳\"); &#125;&#125; 鸟实现类 123456789101112131415/** * 鸟实现 吃和飞方法即可 */@Slf4jpublic class LarkCaseTwo implements IEat,IFly&#123; @Override public void eat() &#123; log.info(\"鸟吃东西\"); &#125; @Override public void fly() &#123; log.info(\"鸟飞翔\"); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"迪米特法则","slug":"迪米特法则","date":"2019-09-02T16:00:00.000Z","updated":"2020-07-04T11:03:00.959Z","comments":true,"path":"2019/09/03/迪米特法则/","link":"","permalink":"http://yoursite.com/2019/09/03/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/","excerpt":"","text":"定义 迪米特法则也叫最少知道原则,一个对象应该对其他对象保持最少的了解（比如包的权限，修饰的关键字）。尽量降低类与类之间的耦合。 优点 降低类之间的耦合。 强调 只关心出现在成员变量、方法的入参和出参中的类，不关心方法体内部的类。 简单需求说明 公司老板想了解某个业务组的项目情况，老板直接找到TeamLeader，不需要关心项目组其他成员。而TeamLeader需要让组内 某个成员进行整理资料，然交给自己，自己再交给老板。 coding迪米特法则反例老板类 123456789101112131415161718import java.util.ArrayList;import java.util.List;/** * 此处设计不合理，只访问朋友类（成员变量中的类，输入中出现的类，输出中出现的类） * 成员方法中的类不需要引入(Member) */public class Boss &#123; public void findMembers()&#123; TeamLeader leader = new TeamLeader(); List&lt;Member&gt; list = new ArrayList&lt;Member&gt;(); for(int i= 0;i&lt;10;i++)&#123; list.add(new Member()); &#125; leader.countMember(list); &#125;&#125; 主管类 12345678import java.util.List;@Slf4jpublic class TeamLeader &#123; public void countMember(List list)&#123; log.info(\"当前项目组的成员数：\"+list.size()); &#125;&#125; 项目组成员类 12345678910111213public class Member &#123; // ..&#125;``` **应用类**```javapublic class Client&#123; public static void main(String[] args)&#123; Boss boss = new Boss(); boss.findMembers(); &#125;&#125; 迪米特法则正例老板类 1234567891011121314151617package com.design.pattern.principle.demeter;/** * Boss * * @author shunhua * @date 2019-09-03 */public class Boss &#123; /** * 对Member不需要见，只关心TeamLeader * @param teamLeader */ public void findProject(TeamLeader teamLeader)&#123; teamLeader.findProject(); &#125;&#125; 主管类 1234567891011121314151617181920package com.design.pattern.principle.demeter;import lombok.extern.slf4j.Slf4j;/** * TeamLeader * * @author shunhua * @date 2019-09-03 */@Slf4jpublic class TeamLeader &#123; /** * 关注Member */ public void findProject()&#123; Member member = new Member(); log.info(String.valueOf(member)); &#125;&#125; 成员类 1234567891011package com.design.pattern.principle.demeter;/** * Member * * @author shunhua * @date 2019-09-03 */public class Member &#123; // ..&#125; 应用 12345678910111213141516171819202122package com.design.pattern.principle;import com.design.pattern.principle.demeter.Boss;import com.design.pattern.principle.demeter.TeamLeader;import org.junit.Test;/** * DemeterTest * * @author shunhua * @date 2019-09-03 */public class DemeterTest &#123; @Test public void test()&#123; Boss boss = new Boss(); TeamLeader teamLeader = new TeamLeader(); boss.findProject(teamLeader); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单一职责原则","slug":"单一职责原则","date":"2019-09-01T16:00:00.000Z","updated":"2020-07-04T10:58:08.873Z","comments":true,"path":"2019/09/02/单一职责原则/","link":"","permalink":"http://yoursite.com/2019/09/02/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/","excerpt":"","text":"定义 不要存在多于一个导致类变更的原因。体现在一个类/接口/方法只负责一项职责。 优点 降低类的复杂度、提高类的可读性，提高系统的可维护性，降低变更引起的风险。 详解 在类的级别上，可以定义不同的类实现不同的功能，在接口级别上，可以根据功能抽象出不同的接口，然后按需要实现一个或多个接口。方法级别上，可以做到不同的方法实现不同的操作。 要点讲解12341. 实际应用中，类不采用单一职责，接口和方法采用单一职责。2. 定义：单一职责规定 一个类，接口或者方法，只有一个变化的原因3. 优点：降低类的复杂性，提高可读性，维护时风险降低4. 实际应用，受依赖，组合，聚合这些关系影响，同时受控于项目规模，项目周期，技术人员水平，对进度把控等影响。应适当的应用单一职责原则 简单需求说明 完成不同功能，并且使设计模块具有可读性和可维护性。可以使用不同的类或接口或方法去完成某一类功能，这样就显得单一，具有针对性。 类的单一职责原则实体类1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.design.pattern.principle.singleresponsibility;import lombok.extern.slf4j.Slf4j;/** * WalkBird * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class WalkBird &#123; public void moveMode(String birdName)&#123; log.info(birdName + \"陆地奔跑\"); &#125;&#125;``` **实体类2**```javapackage com.design.pattern.principle.singleresponsibility;import lombok.extern.slf4j.Slf4j;/** * FlyBird * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class FlyBird &#123; public void moveMode(String birdName)&#123; log.info(birdName + \"用翅膀飞\"); &#125;&#125;``` **应用**```javapublic class Client &#123; public static void main(String[] args) &#123; WalkBird walkBird = new WalkBird(); walkBird.birdMove(\"鸵鸟\"); FlyBird flyBird = new FlyBird(); flyBird.birdMove(\"大雁\"); &#125;&#125;``` ### 接口的单一职责**接口1**```java/** * 这个接口和获取内容的接口有先后顺序，只有开始学习，才能获取内容，如果退出学习，就不能在获取内容了， * 由于职责不同，所以设计两个接口符合单一职责原则 */public interface IcourseAction &#123; void beginStudy(); void quitStudy();&#125; 接口2 1234567/** * 注，本接口主要是获取课程的内容 */public interface IcourseContent &#123; String getCourseText();//获取课程文本内容 byte[] getCourseVideo();//获取课程的视频&#125; 实体类 12345678910111213141516171819202122@Slf4jpublic class Course implements IcourseAction,IcourseContent&#123; @Override public void beginStudy() &#123; log.info(\"开始学习!\"); &#125; @Override public void quitStudy() &#123; log.info(\"学习完成！\"); &#125; @Override public String getCourseText() &#123; return \"Java 资料\"; &#125; @Override public byte[] getCourseVideo() &#123; return new byte[0]; &#125;&#125; 方法的单一职责12345678910111213141516171819202122232425public class Method &#123; /** * 单一职责原则，修改用户的名称 * @return */ public String updateUserName()&#123; return \"\"; &#125; /** * 单一职责原则,修改用户的密码 * @return */ public String updateUserPassWord()&#123; return \"\"; &#125; /** * 不符合单一职责 * @return */ public String updateUserInfo(String userId,String gender)&#123; return \" \"; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"依赖倒置原则","slug":"依赖倒置原则","date":"2019-09-01T16:00:00.000Z","updated":"2020-07-04T10:55:53.195Z","comments":true,"path":"2019/09/02/依赖倒置原则/","link":"","permalink":"http://yoursite.com/2019/09/02/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/","excerpt":"","text":"定义 高层模块不应该依赖低层模块，二者都应该依赖其抽象。 优点 可以减少类间的耦合性、提高系统稳定性，增强代码可读性和可维护性，可降低修改程序造成的风险。 细节描述 抽象不应该依赖细节，细节应该依赖抽象。针对接口编程而不要针对实现编程。 简单需求说明 某同学想要学习某一课程，最简单的方式直接在Person中编写一个方法即可，但是如果以后想要学习其他课程就 需要修改Person类。为了解耦，我们可以把课程抽象出去，高层对底层的依赖，这样Person依赖的就是抽象，我 们针对接口编程，而不是针对实现编程。 coding非面向抽象编程12345678910111213141516171819202122232425缺点：应用依赖具体的实现，对于后续需求变更更加不适用&#96;&#96;&#96; **实体类**&#96;&#96;&#96;javapackage com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;&#x2F;** * Person * * @author shunhua * @date 2019-09-02 *&#x2F;@Slf4jpublic class Person &#123; public void learnJavaCourse()&#123; log.info(&quot;学习Java课程&quot;); &#125; public void learnPythonCourse()&#123; log.info(&quot;学习Python课程&quot;); &#125;&#125; 应用 12345678910111213141516171819202122package com.design.pattern.principle;import com.design.pattern.principle.dependenceinversion.PythonCourse;import com.design.pattern.principle.dependenceinversion.JavaCourse;import com.design.pattern.principle.dependenceinversion.Person;import org.junit.Test;/** * DependeceinversionTest * * @author shunhua * @date 2019-09-02 */public class DependeceinversionTest &#123; @Test public void test()&#123; Person person = new Person(); person.studyJava(); person.studyPython(); &#125;&#125; 面向接口编程1这里使用接口方法传参的方式 课程接口 1234567891011121314package com.design.pattern.principle.dependenceinversion;/** * ICourse * * @author shunhua * @date 2019-09-02 */public interface ICourse &#123; /** * 学习课程 */ void learnCourse();&#125; Java课程 123456789101112131415161718package com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;/** * JavaCourse * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class JavaCourse implements ICourse &#123; @Override public void learnCourse() &#123; log.info(\"gentryhuang is learning java\"); &#125;&#125; Python课程 123456789101112131415161718package com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;/** * PythonCourse * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class PythonCourse implements ICourse &#123; @Override public void learnCourse() &#123; log.info(\"gentryhuang is learning python\"); &#125;&#125; 实体 1234567891011121314151617package com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;/** * Person * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class Person &#123; public void learnCource(ICourse course)&#123; course.learnCourse(); &#125;&#125; 应用 123456789101112131415161718192021package com.design.pattern.principle;import com.design.pattern.principle.dependenceinversion.PythonCourse;import com.design.pattern.principle.dependenceinversion.JavaCourse;import com.design.pattern.principle.dependenceinversion.Person;import org.junit.Test;/** * DependeceinversionTest * * @author shunhua * @date 2019-09-02 */public class DependeceinversionTest &#123; @Test public void test()&#123; Person person = new Person(); person.learnCource(new JavaCourse()); person.learnCource(new PythonCourse()); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"开闭原则","slug":"开闭原则","date":"2019-08-31T16:00:00.000Z","updated":"2020-07-04T10:52:14.483Z","comments":true,"path":"2019/09/01/开闭原则/","link":"","permalink":"http://yoursite.com/2019/09/01/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/","excerpt":"","text":"定义 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 强调的是用抽象构建框架，用实现扩展细节。 核心思想 面向抽象编程，因为抽象是稳定的。 理解 不改变原先的业务逻辑，新增的功能点通过重写复用的方法进行编程。 优点 提高软件系统的可复用性以及可维护性 简单需求说明 软件实体ICourse，以及它的实现JavaCource实现了基本功能，如需要额外的功能可以对JavaCourse进行扩展即继承来添加， 这样在不修改底层的ICourse和JavaCourse的前提下，做到功能的添加。即，越基层的模块影响范围越大，越高层的模块影响 范围较小，总体实现了对扩展开放，对修改关闭，这样就可以有效解决影响范围。 codingv1 基类1需求：打印出原价以及课程其他信息 接口 12345678910111213141516171819202122232425package com.design.pattern.principle.openclose;/** * ICourse * * @author shunhua * @date 2019-09-01 */public interface ICourse &#123; /** * 获取课程id * @return */ Integer getId(); /** * 获取课程名称 * @return */ String getName(); /** * 获取课程价格 * @return */ Double getPrice();&#125; 实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.design.pattern.principle.openclose;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * JavaCourse * * @author shunhua * @date 2019-09-01 */@AllArgsConstructor@NoArgsConstructor@Datapublic class JavaCourse implements ICourse &#123; /** * 课程id */ private Integer id; /** * 课程名称 */ private String name; /** * 课程价格 */ private Double price; @Override public Integer getId() &#123; return this.id; &#125; @Override public String getName() &#123; return this.name; &#125; @Override public Double getPrice() &#123; return this.price; &#125;&#125; 应用 123456789101112131415161718192021222324252627package com.design.pattern.principle;import com.design.pattern.principle.openclose.ICourse;import com.design.pattern.principle.openclose.JavaCourse;import com.design.pattern.principle.openclose.JavaDiscountCourse;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * OpencloseTest * * @author shunhua * @date 2019-09-01 */@Slf4jpublic class OpencloseTest &#123; @Test public void testBase()&#123; ICourse javaCourse = new JavaCourse(100,\"Java从入门到放弃\",200d); log.info(String.format(\"课程id: %d,课程名: %s, 课程价格：%f\", javaCourse.getId(), javaCourse.getName(), javaCourse.getPrice()) ); &#125;&#125; v21需求：打印出原价和折扣后的价格以及课程其他信息（接口不应该随意发生变化，面向接口编程） 接口 12345678910111213141516171819202122232425package com.design.pattern.principle.openclose;/** * ICourse * * @author shunhua * @date 2019-09-01 */public interface ICourse &#123; /** * 获取课程id * @return */ Integer getId(); /** * 获取课程名称 * @return */ String getName(); /** * 获取课程价格 * @return */ Double getPrice();&#125; 实体类 1234567891011121314151617181920212223242526272829303132package com.design.pattern.principle.openclose;/** * JavaDiscountCourse * * @author shunhua * @date 2019-09-01 */public class JavaDiscountCourse extends JavaCourse &#123; public JavaDiscountCourse(Integer id, String name, Double price) &#123; super(id, name, price); &#125; /** * 获取折扣价 * @return */ @Override public Double getPrice() &#123; return super.getPrice() * 0.8; &#125; /** * 获取原价 * @return */ public Double getOriginPrice()&#123; return super.getPrice(); &#125;&#125; 应用 123456789101112131415161718192021222324252627282930313233343536373839package com.design.pattern.principle;import com.design.pattern.principle.openclose.ICourse;import com.design.pattern.principle.openclose.JavaCourse;import com.design.pattern.principle.openclose.JavaDiscountCourse;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * OpencloseTest * * @author shunhua * @date 2019-09-01 */@Slf4jpublic class OpencloseTest &#123; @Test public void testBase()&#123; ICourse javaCourse = new JavaCourse(100,\"Java从入门到放弃\",200d); log.info(String.format(\"课程id: %d,课程名: %s, 课程价格：%f\", javaCourse.getId(), javaCourse.getName(), javaCourse.getPrice()) ); &#125; @Test public void testEx()&#123; ICourse javaCource = new JavaDiscountCourse(100,\"java从入门到放弃\",200d); log.info(String.format(\"课程id: %d,课程名: %s, 课程原价：%f，课程折扣价格：%f\", javaCource.getId(), javaCource.getName(), ((JavaDiscountCourse) javaCource).getOriginPrice(), javaCource.getPrice()) ); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"uml基础","slug":"uml","date":"2018-05-09T16:00:00.000Z","updated":"2020-07-03T14:26:00.014Z","comments":true,"path":"2018/05/10/uml/","link":"","permalink":"http://yoursite.com/2018/05/10/uml/","excerpt":"","text":"UML概述定义统一建模语言（缩写UML），非专利的第三代建模和规约语言 特点 UML是一种开放的方法 UML用于说明、可视化、构建和编写一个正在开发的面向对象的、软件密集系统的制品的开放方法 UML展现了一系列最佳工程的实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层面已经被验证有效 UML分类 结构式图形 强调的是系统式的建模，具体包含静态图（类图、对象图、包图）、实现图（组件图、部署图）、剖面图以及复合结构图 行为式图形 强调系统模型中触发的事件，具体包含活动图、状态图以及用例图 交互式图形 属于行为式图形子集合，强调系统模型中资源流程。具体包含通信图、交互概念图、时序图 以及时间图 ​ UML类图用于表示类、接口、实例等之间相互的静态关系。虽然名字叫类图，但类图中并不只有类，还可能包括权限、属性、方法等 UML记忆方式12341. uml箭头：从子类指向父类，只有知道对方信息时才能指向对方方向2. 空心三角箭头：继承或实现，实线-继承：积极的，强关联，关联，通常一个类中有一个类的对象做属性；虚线-实现：消极的，弱关联，依赖3. 空心菱形：聚合，（注：可以看作一个盘子，可以放很多相同的东西（箭头方向所指的类），聚在一起。是has a的关系）弱关联4. 实心菱形：组合，（注：代表器皿里有实体结构存在，组合起来成为一个。是contains-a的关系）强关联 uml箭头：从子类指向父类，定义子类时需要通过extends关键字指定父类，只有知道对方信息时才能指向对方方向 实线-继承 | 虚线-实现 ​ 空心菱形-聚合 实心菱形-组合 组合关系中常见的数字表达 123456◆常见数字表达及含义，假设有A类和B类，数字标记在A类侧◆0..1：0或1个实例 在系统某一时刻，b的实例可以与0个或1个A实例相关◆0..*：0或多个实例 在系统某一时刻，b的实例可以与0个或多个A实例相关◆1..1：1个实例. b的实例可以和1个A实例相关◆1只能有一个实例. b的实例可以和1个A实例相关◆1..*：至少有一个实例. b实例可以与一个或多个A实例相关 UML时序图 是显示对象之间交互的图，这些对象是按照时间顺序排列的 时序图中 包含的建模元素 对象（Actor）、生命线（lifeline）、控制焦点（Focus of control）、消息（Message）等 时序图示例 12345678910111213竖线代表生命线对象：c：client ，s：server，d：device 代表实例消息：箭头代表的元素(open,work等)竖矩形代表实例处于某种活动中，实线实心箭头：代表方法调用，同步调用实线非实心箭头：代表异步调用虚线：代表返回 UML类图讲解1234567891011121314151617+ 公共方法- private权限# protected权限 包内和包外继承的子类都能引用~ default权限（包权限）只有包内能引用下划线 静态 Static斜体 抽象类（或抽象方法）（包含抽象方法的必是抽象类）（类和至少一个方法都是斜体）方法 可以带参，可以不带参 返回值写到冒号后边，void不用加注意：下图类名应该为斜体，因为有抽象方法study（），所以GeelyClass为抽象类，应该为斜体。 UML整体讲解12345678910设计模式中的对象关系: 依赖关系 虚线箭头，箭头方向指向被依赖的部分 组合关系 实心菱形 聚合关系 空心菱形（想象成盘子，盛东西，盘子的多，另一方少） 关联关系 实线箭头，箭头指向被关联的部分 类与类的连接，（它使一个类知道另一个类的属性和方法，关联关 系一般用成员变量实现） 继承 空心三角形实线 实现 空心三角形虚线注意： 实现接口有两种方式，一种是棒棒糖的形式，另一种是虚线空心三角形的方式 UML中部分对比1234567891.1 关联和依赖的对比关联是a类中存在b类对象，企鹅类中有气候类的属性依赖是a类成员方法中有b类的属性，动物新陈代谢方法中有水和空气的属性，只有调这个方法的时候，才可能临时用一下1.2 组合和聚合的对比组合有相同的生命周期，鸟有翅膀，鸟死了，翅膀不复存在大雁群有大雁，一只大雁挂了，大雁群不会消失1.3 继承和实现的对实线：继承虚线：实现","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}