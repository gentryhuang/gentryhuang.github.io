{"meta":{"title":"gentryhuang‘s blog","subtitle":"blog","description":"博客","author":"gentryhuang","url":"https://gentryhuang.com","root":"/"},"pages":[{"title":"关于我","date":"2020-07-06T16:28:53.042Z","updated":"2020-07-04T07:35:16.691Z","comments":false,"path":"about/index.html","permalink":"https://gentryhuang.com/about/index.html","excerpt":"","text":"123456789101112131415161718&#x2F;** * * * ┏┓ ┏┓ * ┃ ┃ + +* ┃ ━ ┃ ++ + + +* ████━████ ┃ 🚂🚂🚂-&lt;-&lt; 欢迎访问我的博客* ┃ ┃ + * ┃ ┻ ┃ + + * ┃ ┃ * ┗━┓ ┏━┛Code is far away from bug with the animal protecting * ┃ ┃ 神兽护体，永无bug * ┃ ┃ +* ┃ ┗━━━┓+* ┃ ┣┓ 📬 联系我：gentryhuang.xw@gmail.com* ┃ ┏┛ + + * ┗┓┓┏━┳┓┏┛ +* ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ *&#x2F;"},{"title":"分类","date":"2020-07-03T15:03:26.305Z","updated":"2020-07-03T15:03:26.305Z","comments":false,"path":"categories/index.html","permalink":"https://gentryhuang.com/categories/index.html","excerpt":"","text":""},{"title":"项目","date":"2020-07-06T16:29:08.229Z","updated":"2020-07-06T16:29:08.229Z","comments":false,"path":"repository/index.html","permalink":"https://gentryhuang.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-07-05T10:07:05.047Z","updated":"2020-07-03T15:03:37.362Z","comments":true,"path":"links/index.html","permalink":"https://gentryhuang.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-03T15:03:56.993Z","updated":"2020-07-03T15:03:56.993Z","comments":false,"path":"tags/index.html","permalink":"https://gentryhuang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"链表","slug":"redis_theory/data_structure/链表","date":"2020-07-08T11:33:59.000Z","updated":"2020-07-08T11:41:12.445Z","comments":false,"path":"posts/2362a8ea/","link":"","permalink":"https://gentryhuang.com/posts/2362a8ea/","excerpt":"","text":"链表 redis中的链表 链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置这中数据结构，所以redis构建了自己的链表实现。 redis链表节点的结构 12345678typedef struct listNode&#123; // 前置节点 struct listNode *prev; // 后置节点 struct listNode *next; // 节点的值 (可用于保存各种不同类型的值) void *value&#125;listNode; redis链表结构 123456789101112131415161718192021typedef struct list &#123; // 表头节点 listNode *head; // 表尾节点 listNode *tail; // 节点值复制函数，用于复制链表节点所保存的值 void *(*dup)(void *ptr); // 节点值释放函数，用于释放链表节点所保存的值 void (*free)(void *ptr); // 节点值对比函数，用于对比链表节点所保存的值和其他值是否相等 int (*match)(void *ptr, void *key); // 链表所包含的节点数量 unsigned long len;&#125; list; redis链表的特点 12345- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点- 带表头和表尾指针：使用list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)- 带链表长度计数器：程序使用list结构的len属性标记链表中节点的个数，程序获取链表中节点个数的复杂度为O(1)- 多态：链表可以保存各种不同类型的值 链表在redis中的应用 链表被广泛用于实现redis的各种功能，如：列表键、发布与订阅、慢查询、监视器，redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。","categories":[{"name":"Redis原理","slug":"Redis原理","permalink":"https://gentryhuang.com/categories/Redis%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"Redis数据结构","slug":"Redis数据结构","permalink":"https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"简单动态字符串","slug":"redis_theory/data_structure/简单动态字符串","date":"2020-07-08T11:00:50.000Z","updated":"2020-07-21T07:41:30.123Z","comments":false,"path":"posts/aa1d8127/","link":"","permalink":"https://gentryhuang.com/posts/aa1d8127/","excerpt":"","text":"简单动态字符串 初识动态字符串 redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS作为redis的默认字符串表示。 在redis中，c字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如日志。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，redis就会使用SDS来表示字符串值。 值的注意的是，对于redis中的key都是使用SDS来实现的。此外，SDS除了用来保存Redis数据库中的字符串值之外，SDS还被用作缓冲区（buffer）: AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区。 sds的结构 12345678struct sdshdr&#123; // 记录buf数组中已使用字节的数量等价于sds所保存字符串的长度 int len; // 记录buf数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[];&#125; 注意： sds遵循c字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在sds的len属性中，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由sds函数自动完成的。遵循空字符结尾的好处是，sds可以直接使用一部分C字符串函数库里面的函数。 sds与c字符串的区别 c语言使用的简单字符串表示方式，并不能满足redis对字符串在安全性、效率以及功能方面的要求。 3.1 常数复杂度获取字符串长度 因为c字符串并不记录自身的长度信息，所以要获取长度就必须遍历整个字符串，故获取字符串长度的复杂度为O(N)。而redis的sds结构中通过len属性记录了sds的长度，故获取字符串长度的复杂度为O(1)。注意，设置和更新sds长度的工作是由sds的API在执行时自动完成的，使用sds无须进行任何手动修改长度的操作。 3.2 避免缓冲区溢出 c字符串不记录自身长度，很容易造成缓冲区溢出。与c字符串不同，sds的空间分配策略完全杜绝了发生缓冲区溢出的可能性，当sds api需要对sds进行修改时，api会先检查sds的空间是否满足需要，如果不满足的话，api会自动将sds的空间扩展至执行所需的大小，然后才执行实际的修改操作，因此使用sds既不需要手动修改sds的空间大小，也不会出现c字符串中可能出现的缓冲区溢出问题。 1234567891011121314151617sds sdscatlen(sds s, const void *t, size_t len) &#123; size_t curlen = sdslen(s); //追加时先进行扩容，后面详细说明 s = sdsMakeRoomFor(s,len); if (s == NULL) return NULL; //拼接字符串 memcpy(s+curlen, t, len); sdssetlen(s, curlen+len); s[curlen+len] = '\\0'; return s;&#125;// s:原数组 //strlen(t) 需拼接的目标数组的长度sds sdscat(sds s, const char *t) &#123; return sdscatlen(s, t, strlen(t));&#125;​ 3.3 内存分配与释放 因为c字符串的长度和底层数组的长度之间存在着关联性，所以每次增加或者缩短一个c字符串，程序都总要对保存这个c字符串的数字进行一次分配操作，但是内存分配操作涉及到复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，为了避免c字符串的这种缺陷，sds通过未使用空间解除了字符串长度和底层数组长度之间的关联，通过未使用空间，sds实现了空间预分配和惰性空间释放两种优化策略。 空间预分配 空间预分配用于优化sds的字符串增长操作：当sds的api对一个sds进行修改，并且需要对sds进行空间扩展的时候，程序不仅会为sds分配修改所必须要的空间，还会为sds分配额外的未使用空间。通过空间预分配策略，redis可以减少连续执行字符串增长操作所需的内存重新分配次数，在扩展sds空间之前，sds api 会先检查未使用空间是否足够，如果足够就直接使用未使用空间，而不需要执行内存重新分配。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// redis 扩容源码/* * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后， * buf 至少会有 addlen + 1 长度的空余空间 * （额外的 1 字节是为 \\0 准备的） * * 返回值 * sds ：扩展成功返回扩展后的 sds * 扩展失败返回 NULL * * 复杂度 * T = O(N) */sds sdsMakeRoomFor(sds s, size_t addlen) &#123; struct sdshdr *sh, *newsh; // 获取 s 目前的空余空间长度 size_t free = sdsavail(s); size_t len, newlen; // s 目前的空余空间已经足够，无须再进行扩展，直接返回 if (free &gt;= addlen) return s; // 获取 s 目前已占用空间的长度 len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); // s 最少需要的长度 newlen = (len+addlen); // 根据新长度，为 s 分配新空间所需的大小 if (newlen &lt; SDS_MAX_PREALLOC) // 如果新长度小于 SDS_MAX_PREALLOC // 那么为它分配两倍于所需长度的空间 newlen *= 2; else // 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC newlen += SDS_MAX_PREALLOC; // T = O(N) newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1); // 内存不足，分配失败，返回 if (newsh == NULL) return NULL; // 更新 sds 的空余长度 newsh-&gt;free = newlen - len; // 返回 sds return newsh-&gt;buf;&#125; 额外分配未使用空间数量的计算策略： 对sds修改后，sds的长度（即len属性的值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时sds的len属性的值将和free属性的值相同。例如：修改后sds的len变成10字节，那么程序也会分配10字节的未使用空间，sds的buf数组的实际长度：10 + 10 + 1 = 21字节 对sds修改后，sds的长度大于等于1MB，那么程序会分配1MB的未使用空间。例如：修改后sds的len变成30MB，那么程序会分配1MB的未使用空间，sds的buf数组的时间长度：30MB + 1MB + 1byte 惰性空间释放 惰性空间释放用于优化sds的字符串缩短操作：当sds的api需要缩短sds保存的字符串时，程序并不立即使用内存重分配来回收缩短后多来的字节，而是使用free属性将这些字节的数量纪录起来，用于将来对sds进行增长操作时，这些未使用空间可能就派上用场了。注意，sds也提供了相应的api，可以真正地释放sds的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。 3.4 二进制安全 c字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里不能包含空字符，否则在读取的时候会被默认为结束字符，这些限制使得c字符串只能保存文本数据，不能保存图片、音视频、压缩文件这类的二进制数据。sds的api都是二进制安全的，所有的sds api都会以二进制的方式处理sds存放在buf数组里的数据,程序不会对其中的数据做任何限制、过滤，数据写入时是什么样，它被读取时就是什么样。这也是将sds的buf属性称为字节数组的原因，redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。 c字符串和sds之间的区别 123456 C字符串 SDS- 获取字符串长度的复杂度为O（n） 获取字符串长度的复杂度O（1）- API是不安全的，可能造成缓冲区溢出 API是安全的- 修改字符串长度N次，必然要执行N次内存重分配 修改字符长度N次，最多执行N次内存重分配- 只能保存文本数据 可以保存文本或者二进制数据- 可使用&lt;string.h&gt;库中的函数 可使用一部分&lt;string.h&gt;库中的函数 sds更多的api可参考源码","categories":[{"name":"Redis原理","slug":"Redis原理","permalink":"https://gentryhuang.com/categories/Redis%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"Redis数据结构","slug":"Redis数据结构","permalink":"https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"dubbo第三例","slug":"rpc/Dubbo第三例","date":"2020-03-05T16:00:00.000Z","updated":"2020-08-04T12:14:10.052Z","comments":false,"path":"posts/7202a9c0/","link":"","permalink":"https://gentryhuang.com/posts/7202a9c0/","excerpt":"","text":"快速启动使用注解的方式进行配置 定义服务接口12345678910package com.alibaba.dubbo.examples.annotation.api;/** * AsyncService */public interface AnnotationService &#123; String sayHello(String name);&#125; 服务提供方123456789101112131415161718package com.alibaba.dubbo.examples.annotation.impl;import com.alibaba.dubbo.config.annotation.Service;import com.alibaba.dubbo.examples.annotation.api.AnnotationService;/** * AsyncServiceImpl，注意，这里 @Service 注解是Dubbo的注解，用来进行服务暴露的 */@Servicepublic class AnnotationServiceImpl implements AnnotationService &#123; @Override public String sayHello(String name) &#123; System.out.println(\"async provider received: \" + name); return \"annotation: hello, \" + name; &#125;&#125; 服务提供方属性配置12345# dubbo-provider.propertiesdubbo.application.name&#x3D;annotation-providerdubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181dubbo.protocol.name&#x3D;dubbodubbo.protocol.port&#x3D;20880 说明: 使用dubbo注解形式一般结合属性配置，用来配置应用共享的配置项。 指定扫描路径，启动容器并暴露服务123456789101112131415161718192021222324252627282930313233343536package com.alibaba.dubbo.examples.annotation;import com.alibaba.dubbo.config.ProviderConfig;import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;/** * MergeProvider * * Java Config + 注解的方式 */public class AnnotationProvider &#123; public static void main(String[] args) throws Exception &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ProviderConfiguration.class); context.start(); System.in.read(); &#125; @Configuration @EnableDubbo(scanBasePackages = \"com.alibaba.dubbo.examples.annotation.impl\") @PropertySource(\"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-provider.properties\") static public class ProviderConfiguration &#123; @Bean public ProviderConfig providerConfig() &#123; ProviderConfig providerConfig = new ProviderConfig(); providerConfig.setTimeout(5000); return providerConfig; &#125; &#125;&#125; 服务消费方123456789101112131415161718192021package com.alibaba.dubbo.examples.annotation.action;import com.alibaba.dubbo.config.annotation.Reference;import com.alibaba.dubbo.examples.annotation.api.AnnotationService;import org.springframework.stereotype.Component;/** * AnnotationAction，注意，@Reference注解用来引用服务 */@Component(\"annotationAction\")public class AnnotationAction &#123; @Reference private AnnotationService annotationService; public String doSayHello(String name) &#123; return annotationService.sayHello(name); &#125;&#125; 服务消费方属性配置1234# dubbo-consumer.propertiesdubbo.application.name&#x3D;annotation-consumerdubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181dubbo.consumer.timeout&#x3D;3000 说明: 使用dubbo注解形式一般结合属性配置，用来配置应用共享的配置项。 扫描路径，启动容器并调用服务1234567891011121314151617181920212223242526272829303132package com.alibaba.dubbo.examples.annotation;import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;import com.alibaba.dubbo.examples.annotation.action.AnnotationAction;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;/** * CallbackConsumer */public class AnnotationConsumer &#123; public static void main(String[] args) throws Exception &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConsumerConfiguration.class); context.start(); final AnnotationAction annotationAction = (AnnotationAction) context.getBean(\"annotationAction\"); String hello = annotationAction.doSayHello(\"world\"); System.out.println(\"result :\" + hello); System.in.read(); &#125; @Configuration @EnableDubbo(scanBasePackages = \"com.alibaba.dubbo.examples.annotation.action\") @PropertySource(\"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-consumer.properties\") @ComponentScan(value = &#123;\"com.alibaba.dubbo.examples.annotation.action\"&#125;) static public class ConsumerConfiguration &#123; &#125;&#125; 小结注解实现是代码更整洁，开放效率更高，随着注解和配置化的盛行，xml的方式会渐渐地淡出舞台。但使用注解对开放者的要求更高，具体的dubbo注解如何与Spring融合，在后面的章节中会进行说明。","categories":[{"name":"rpc","slug":"rpc","permalink":"https://gentryhuang.com/categories/rpc/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://gentryhuang.com/tags/dubbo/"},{"name":"rpc","slug":"rpc","permalink":"https://gentryhuang.com/tags/rpc/"}]},{"title":"dubbo第二例","slug":"rpc/Dubbo第二例","date":"2020-03-03T16:00:00.000Z","updated":"2020-08-04T12:14:10.047Z","comments":false,"path":"posts/3f1c0a92/","link":"","permalink":"https://gentryhuang.com/posts/3f1c0a92/","excerpt":"","text":"快速启动使用xml的方式进行配置，详细配置项：配置参考手册 定义服务接口12345package com.alibaba.dubbo.demo;public interface DemoService &#123; String sayHello(String name);&#125; 服务提供方实现接口12345678910111213141516package com.alibaba.dubbo.demo.provider;import com.alibaba.dubbo.demo.DemoService;import com.alibaba.dubbo.rpc.RpcContext;import java.text.SimpleDateFormat;import java.util.Date;public class DemoServiceImpl implements DemoService &#123; @Override public String sayHello(String name) &#123; System.out.println(\"[\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()) + \"] Hello \" + name + \", request from consumer: \" + RpcContext.getContext().getRemoteAddress()); return \"Hello \" + name + \", response from provider: \" + RpcContext.getContext().getLocalAddress(); &#125;&#125; 服务提供方服务暴露配置1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=\"demo-provider\" owner=\"gentryhuang\"/&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;bean id=\"demoService\" class=\"com.alibaba.dubbo.demo.provider.DemoServiceImpl\"/&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;dubbo:service interface=\"com.alibaba.dubbo.demo.DemoService\" ref=\"demoService\"/&gt;&lt;/beans&gt; 启动Spring容器，进行服务暴露12345678910111213package com.alibaba.dubbo.demo.provider;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Provider &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;\"META-INF/spring/dubbo-demo-provider.xml\"&#125;); context.start(); System.in.read(); // press any key to exit &#125;&#125; 服务消费者引用服务配置1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=\"demo-consumer\"/&gt; &lt;!-- 使用zookeeper注册中心暴露发现服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id=\"demoService\" check=\"false\" interface=\"com.alibaba.dubbo.demo.DemoService\"/&gt;&lt;/beans&gt; 加载Spring配置，并调用远程服务123456789101112131415161718192021222324package com.alibaba.dubbo.demo.consumer;import com.alibaba.dubbo.demo.DemoService;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Consumer &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;\"META-INF/spring/dubbo-demo-consumer.xml\"&#125;); context.start(); DemoService demoService = (DemoService) context.getBean(\"demoService\"); // get remote service proxy while (true) &#123; try &#123; Thread.sleep(5000); String hello = demoService.sayHello(\"world\"); // call remote method System.out.println(hello); // get result &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125; &#125;&#125; 小结dubbo自定义了很多的xml标签，这些标签是怎么和pring融合的在spring自定义标签中已经介绍了实现原理，在后面的dubbo配置解析中会继续说明。更多更能的配置参考：配置参考手册","categories":[{"name":"rpc","slug":"rpc","permalink":"https://gentryhuang.com/categories/rpc/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://gentryhuang.com/tags/dubbo/"},{"name":"rpc","slug":"rpc","permalink":"https://gentryhuang.com/tags/rpc/"}]},{"title":"dubbo第一例","slug":"rpc/Dubbo第一例","date":"2020-03-02T16:00:00.000Z","updated":"2020-08-04T12:14:10.054Z","comments":false,"path":"posts/f0ae64a/","link":"","permalink":"https://gentryhuang.com/posts/f0ae64a/","excerpt":"","text":"快速启动使用API的方式进行启动、调用。API 属性与配置项一对一，各属性含义，请参见：配置参考手册，比如：ApplicationConfig.setName(“xxx”) 对应 &lt;dubbo:application name=”xxx” /&gt; 定义服务接口1234567891011121314151617package com.code.resorce.api;/** * DemoService * * @author shunhua * @since 2020/03/03 * &lt;p&gt; * desc： */public interface DemoService &#123; /** * @return */ String hello();&#125; 服务提供方实现接口123456789101112131415161718package com.code.resource.reading.api;import com.code.resorce.api.DemoService;/** * DemoServiceImpl * * @author shunhua * @since 2020/03/03 * &lt;p&gt; * desc： */public class DemoServiceImpl implements DemoService &#123; @Override public String hello() &#123; return \"hello world\"; &#125;&#125; 使用API配置声明暴露服务123456789101112131415161718192021222324252627282930313233343536public class ServiceExport &#123; public static void main(String[] args) &#123; DemoService demoService = new DemoServiceImpl(); // 当前应用配置 ApplicationConfig application = new ApplicationConfig(); application.setName(\"app-api\"); // 连接注册中心配置 RegistryConfig registry = new RegistryConfig(); registry.setAddress(\"zookeeper://127.0.0.1:2181\"); registry.setUsername(\"aaa\"); registry.setPassword(\"bbb\"); // 服务提供者协议配置 ProtocolConfig protocol = new ProtocolConfig(); protocol.setName(\"dubbo\"); protocol.setPort(20880); protocol.setThreads(200); // 注意：ServiceConfig为重对象，内部封装了与注册中心的连接，以及开启服务端口 // 服务提供者暴露服务配置 ServiceConfig&lt;DemoService&gt; service = new ServiceConfig&lt;&gt;(); // 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏 service.setApplication(application); service.setRegistry(registry); // 多个注册中心可以用setRegistries() service.setProtocol(protocol); // 多个协议可以用setProtocols() service.setInterface(DemoService.class); service.setRef(demoService); service.setVersion(\"1.0.0\"); // 暴露及注册服务 service.export(); &#125;&#125; 使用API配置服务引用1234567891011121314151617181920212223242526272829import org.apache.dubbo.rpc.config.ApplicationConfig;import org.apache.dubbo.rpc.config.RegistryConfig;import org.apache.dubbo.rpc.config.ConsumerConfig;import org.apache.dubbo.rpc.config.ReferenceConfig;import com.xxx.XxxService; // 当前应用配置ApplicationConfig application = new ApplicationConfig();application.setName(\"app-api-consumer\"); // 连接注册中心配置RegistryConfig registry = new RegistryConfig();registry.setAddress(\"zookeeper://127.0.0.1:2181\");registry.setUsername(\"aaa\");registry.setPassword(\"bbb\"); // 注意：ReferenceConfig为重对象，内部封装了与注册中心的连接，以及与服务提供方的连接 // 引用远程服务ReferenceConfig&lt;DemoService&gt; reference = new ReferenceConfig&lt;&gt;(); // 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏reference.setApplication(application);reference.setRegistry(registry); // 多个注册中心可以用setRegistries()reference.setInterface(DemoService.class);reference.setVersion(\"1.0.0\"); // 和本地bean一样使用xxxServiceDemoService demoService = reference.get(); // 注意：此代理对象内部封装了所有通讯细节，对象较重，请缓存复用// demoService 进行服务调用 小结API的使用是有范围的，仅用于 OpenAPI, ESB, Test, Mock 等系统集成，普通服务提供方或消费方，应该使用xml或注解配置方式。","categories":[{"name":"rpc","slug":"rpc","permalink":"https://gentryhuang.com/categories/rpc/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://gentryhuang.com/tags/dubbo/"},{"name":"rpc","slug":"rpc","permalink":"https://gentryhuang.com/tags/rpc/"}]},{"title":"spring自定义标签","slug":"rpc/Spring自定义标签","date":"2020-03-01T16:00:00.000Z","updated":"2020-08-04T12:53:36.713Z","comments":false,"path":"posts/eee3e639/","link":"","permalink":"https://gentryhuang.com/posts/eee3e639/","excerpt":"","text":"spring自定义标签spring除了很多内置的xml标签外，还支持自定义xml标签，开发者只需要按照Spring的约定规则就可以实现自定义标签，这样开发者就可以把自定义的Bean交给Spring管理。自定义标签包结构如下： 自定义标签的规则编写模型1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.code.resource.reading.xml.schema.model;/** * Hero * * @author shunhua * @since 2020/03/02 * &lt;p&gt; * desc： */public class Hero &#123; /** * name */ private String name; /** * age */ private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Hero&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 定义模型的xsd文件12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xsd:schema xmlns=\"http://gentryhuang.site/schema/people\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" targetNamespace=\"http://gentryhuang.com/schema/people\"&gt; &lt;!-- 定义元素的复杂类型 --&gt; &lt;xsd:complexType name=\"elementComplexType\"&gt; &lt;!-- 定义模型类中的属性 --&gt; &lt;xsd:attribute name=\"name\" type=\"xsd:string\"&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;&lt;![CDATA[ The element name. ]]&gt;&lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;/xsd:attribute&gt; &lt;xsd:attribute name=\"age\" type=\"xsd:int\"&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;&lt;![CDATA[ The element age. ]]&gt;&lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;/xsd:attribute&gt; &lt;/xsd:complexType&gt; &lt;!-- 定义在xml文件中用到的元素名称 --&gt; &lt;xsd:element name=\"hero\" type=\"elementComplexType\"&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;&lt;![CDATA[ 定义标签 ]]&gt;&lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;/xsd:element&gt;&lt;/xsd:schema&gt; 说明: 该文件要放在 resources的META-INF目录下。该文件是用来约束使用xml配置时的标签和对应的属性。 编写spring.schemas文件1http\\:&#x2F;&#x2F;gentryhuang.com&#x2F;schema&#x2F;people&#x2F;hero.xsd&#x3D;META-INF&#x2F;hero.xsd 说明: http://gentryhuang.com/schema/people 就是模型对应的xsd中的targetNamespace的值，它指定了约束文件的具体路径。 编写BeanDefinitionParser12345678910111213141516171819202122232425262728293031323334353637383940414243package com.code.resource.reading.xml.schema;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.RootBeanDefinition;import org.springframework.beans.factory.xml.BeanDefinitionParser;import org.springframework.beans.factory.xml.ParserContext;import org.w3c.dom.Element;/** * HeroBeanDefinitionParser * * @author shunhua * @since 2020/03/02 * &lt;p&gt; * desc： */public class HeroBeanDefinitionParser implements BeanDefinitionParser &#123; /** * 标签对应的类 */ private final Class&lt;?&gt; beanClass; public HeroBeanDefinitionParser(Class&lt;?&gt; beanClass) &#123; this.beanClass = beanClass; &#125; @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; RootBeanDefinition beanDefinition = new RootBeanDefinition(); beanDefinition.setBeanClass(beanClass); beanDefinition.setLazyInit(false); beanDefinition.getPropertyValues().add(\"name\",element.getAttribute(\"name\")); beanDefinition.getPropertyValues().add(\"age\",element.getAttribute(\"age\")); // 获取Bean定义注册表 BeanDefinitionRegistry registry = parserContext.getRegistry(); // 注册Bean registry.registerBeanDefinition(\"hero\",beanDefinition); return beanDefinition; &#125;&#125; 说明: 用来解析自定义的xml标签 编写命名空间处理器123456789101112131415161718192021222324package com.code.resource.reading.xml.schema;import com.code.resource.reading.xml.schema.model.Hero;import org.springframework.beans.factory.xml.NamespaceHandlerSupport;/** * HeroNamespaceHandler * * @author shunhua * @since 2020/03/02 * &lt;p&gt; * desc： */public class HeroNamespaceHandler extends NamespaceHandlerSupport &#123; /** * 定义了&lt;xsd:element/&gt;对应的BeanDefinitionParser */ @Override public void init() &#123; registerBeanDefinitionParser(\"hero\",new HeroBeanDefinitionParser(Hero.class)); &#125;&#125; 说明:一般情况下 一个&lt;xsd:element/&gt; 对应一个BeanDefinitionParser 编写spring.handlers文件1http\\:&#x2F;&#x2F;gentryhuang.com&#x2F;schema&#x2F;people&#x3D;com.code.resource.reading.xml.schema.HeroNamespaceHandler 说明: 这是一个键值对，key是xsd文件中的 targetNamespace，该文件指明了使用哪个类来解析自定义的标签。 使用spring的自定义标签12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:people=\"http://gentryhuang.com/schema/people\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://gentryhuang.com/schema/people http://gentryhuang.com/schema/people/hero.xsd\"&gt; &lt;!-- 1 xmlns:people的值是xsd文件中的targetNamespace 2 xmlns:hero 可以写成xmlns:xxx,此时标签前缀也要是 &lt;xxx:hero/&gt; --&gt; &lt;people:hero name=\"hlb\" age=\"18\"/&gt;&lt;/beans&gt; 测试123456789101112131415161718192021package com.code.resource.reading.xml.schema;import com.code.resource.reading.xml.schema.model.Hero;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Client * * @author shunhua * @since 2020/03/02 * &lt;p&gt; * desc： */public class Client &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"hero.xml\"); Hero hero = (Hero) applicationContext.getBean(\"hero\"); System.out.println(hero); &#125;&#125; 小结spring在解析到自定义的namespace标签时，比如 &lt;people:hero /&gt;，会查找对应的spring.schemas和spring.handlers文件，通过spring.schemas文件确定需要加载的标签及属性，然后会触发spring.handlers文件中指定的类来进行初始化和解析。","categories":[{"name":"rpc","slug":"rpc","permalink":"https://gentryhuang.com/categories/rpc/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://gentryhuang.com/tags/rpc/"},{"name":"spring","slug":"spring","permalink":"https://gentryhuang.com/tags/spring/"}]},{"title":"初识rpc","slug":"rpc/初识RPC","date":"2020-02-29T16:00:00.000Z","updated":"2020-08-04T12:14:10.056Z","comments":false,"path":"posts/626d9676/","link":"","permalink":"https://gentryhuang.com/posts/626d9676/","excerpt":"","text":"基本概念RPC（Remote Procedure Call）远程过程调用，简单来说就是一个节点请求另一个节点提供的服务。请求方没有服务实现的细节，执行目标行为还是服务提供的节点。请求服务的节点和服务提供的节点以某种方式进行通信，请求方把行为及行为参数传递给服务提供方，服务提供方会根据请求方传递的数据找到对应的服务实现然后执行目标行为，最后再把执行结果返回给请求方。 本地过程调用发起请求和响应结果都在同一个服务节点上，在Java中就是同一个JVM中的方法调用过程。 远程过程调用请求的发起者和请求的处理者不在同一个节点上，它们之间需要进行网络通信才能完成请求和响应。 简单RPC实现说明: 例子是使用梁飞大佬的 技术博客 中的案例 服务接口及实现12345678910111213141516171819202122232425262728293031package com.alibaba.study.rpc.service;/** * HelloService */public interface HelloService &#123; /** * 服务方法 * * @param name * @return */ String hello(String name);&#125;---package com.alibaba.study.rpc.service.impl;import com.alibaba.study.rpc.service.HelloService;/** * HelloServiceImpl */public class HelloServiceImpl implements HelloService &#123; @Override public String hello(String name) &#123; return \"Hello \" + name; &#125;&#125; RPC框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177package com.alibaba.study.rpc.framework;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.net.ServerSocket;import java.net.Socket;/** * RpcFramework */public class RpcFramework &#123; /** * 暴露服务 * * @param service 服务实现 * @param port 服务端口 * @throws Exception */ public static void export(final Object service, int port) throws Exception &#123; if (service == null) &#123; throw new IllegalArgumentException(\"service instance == null\"); &#125; if (port &lt;= 0 || port &gt; 65535) &#123; throw new IllegalArgumentException(\"Invalid port \" + port); &#125; System.out.println(\"Export service \" + service.getClass().getName() + \" on port \" + port); // 以指定端口创建ServerSocket ServerSocket server = new ServerSocket(port); for (; ; ) &#123; try &#123; // 等待接收请求 final Socket socket = server.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; try &#123; // 获取请求的数据流 ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); try &#123; // 获取客户端请求的方法名 String methodName = input.readUTF(); // 获取客户端请求的参数类型列表 Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject(); // 获取客户端请求的参数列表 Object[] arguments = (Object[]) input.readObject(); // 创建对象输出流对象，用于响应结果给客户端 ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); try &#123; // 通过反射，获取服务接口指定的方法 Method method = service.getClass().getMethod(methodName, parameterTypes); // 反射调用 Object result = method.invoke(service, arguments); // 将结果响应给客户端 output.writeObject(result); &#125; catch (Throwable t) &#123; output.writeObject(t); &#125; finally &#123; output.close(); &#125; &#125; finally &#123; input.close(); &#125; &#125; finally &#123; socket.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 引用服务 * * @param &lt;T&gt; 接口泛型 * @param interfaceClass 接口类型 * @param host 服务器主机名 * @param port 服务器端口 * @return 远程服务 * @throws Exception */ @SuppressWarnings(\"unchecked\") public static &lt;T&gt; T refer(final Class&lt;T&gt; interfaceClass, final String host, final int port) throws Exception &#123; if (interfaceClass == null) &#123; throw new IllegalArgumentException(\"Interface class == null\"); &#125; if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException(\"The \" + interfaceClass.getName() + \" must be interface class!\"); &#125; if (host == null || host.length() == 0) &#123; throw new IllegalArgumentException(\"Host == null!\"); &#125; if (port &lt;= 0 || port &gt; 65535) &#123; throw new IllegalArgumentException(\"Invalid port \" + port); &#125; System.out.println(\"Get remote service \" + interfaceClass.getName() + \" from server \" + host + \":\" + port); /** * 使用JDK的动态代理创建接口的代理对象 * 说明： * 在 InvocationHandler#invoke方法内部实现Socket与ServerSocket的通信。当使用代理对象调用方法时，内部使用Socket进行通信，然后把通信的结果返回。 */ return (T) Proxy.newProxyInstance( interfaceClass.getClassLoader(), new Class&lt;?&gt;[]&#123;interfaceClass&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable &#123; // 创建Socket，用于连接ServerSocket Socket socket = new Socket(host, port); try &#123; // 创建用于发送数据到ServerSocket的输出流 ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); try &#123; //--------------------- 数据契约 ----------------------------/ // 方法名 output.writeUTF(method.getName()); // 参数类型 output.writeObject(method.getParameterTypes()); // 参数值 output.writeObject(arguments); //------------------------ 数据契约 --------------------------/ // 创建用于接收ServerSocket的输入流 ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); try &#123; // 读取ServerSocket响应的数据 Object result = input.readObject(); if (result instanceof Throwable) &#123; throw (Throwable) result; &#125; // 返回结果 return result; &#125; finally &#123; input.close(); &#125; &#125; finally &#123; output.close(); &#125; &#125; finally &#123; socket.close(); &#125; &#125; &#125;); &#125;&#125; 服务暴露1234567891011121314151617package com.alibaba.study.rpc.provider;import com.alibaba.study.rpc.framework.RpcFramework;import com.alibaba.study.rpc.service.HelloService;import com.alibaba.study.rpc.service.impl.HelloServiceImpl;/** * RpcProvider */public class RpcProvider &#123; public static void main(String[] args) throws Exception &#123; // 服务实现 HelloService service = new HelloServiceImpl(); // 暴露服务 RpcFramework.export(service, 1234); &#125;&#125; 引用服务1234567891011121314151617181920package com.alibaba.study.rpc.consumer;import com.alibaba.study.rpc.framework.RpcFramework;import com.alibaba.study.rpc.service.HelloService;/** * RpcConsumer */public class RpcConsumer &#123; public static void main(String[] args) throws Exception &#123; // 引用服务【代理对象】 HelloService service = RpcFramework.refer(HelloService.class, \"127.0.0.1\", 1234); while (true) &#123; String hello = service.hello(\"World\"); System.out.println(hello); Thread.sleep(1000); &#125; &#125;&#125; 小结这个例子中，通信是使用同步阻塞的Socket来实现的，采用端对端的方式。远程调用使用的是JDK的动态代理，在invoke方法中实现网络通信。参数序列化使用的是JDK的ObjectStream。一个完善的RPC框架其实就是在这例子的基础上进行多方位扩展和改进。比如，网络通信可以使用性能更好的NIO框架Netty，动态代理可以使用javaassist字节码生成方式[注意：不是javaassist提供的动态代理接口，该接口比JDK自带的还慢]，序列化方式可以采用fastjson、hession2以及kryo等技术。如果服务数量达到一定规模，可以引进注册中心进行服务的治理。节点间的通信方式可以有多种，因此可以扩展多协议。除此之外，性能和健壮性也是一个优秀的RPC框架所必须的，如集群容错、负载均衡、重试机制、服务降级…这些都会在后面分析的Dubbo框架中得到很好的体现。","categories":[{"name":"rpc","slug":"rpc","permalink":"https://gentryhuang.com/categories/rpc/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://gentryhuang.com/tags/rpc/"}]},{"title":"命令模式","slug":"design_pattern/behaviour_type/命令模式","date":"2019-10-04T16:00:00.000Z","updated":"2020-07-05T04:13:10.181Z","comments":true,"path":"posts/78134e07/","link":"","permalink":"https://gentryhuang.com/posts/78134e07/","excerpt":"","text":"定义命令模式又叫指令模式，是将“请求”封装成对象，以便使用不同的请求。我们可以把不同的请求封装成不同请求对象，对于接收者来说这些类型都能识别，然后根据不同的请求对象执行不同的行为。 说明命令模式解决了应用程序中对象的职责以及它们之间的通信方式，命令模式可以使命令发送者和接收者完全解耦，发送者和接收者之间没有直接的引用关系。发送命令的对象只知道如何下命令，不需要知道如何完成命令。 类型行为型 使用场景121. 请求调用者和请求接收者需要解耦，使得调用者和接收者不直接交互2. 需要抽象出等待执行的行为 优点1231. 降低耦合 - 通过命令模式把请求的发送者和请求的接收者进行解耦2. 容易扩展新命令或者一组命令 缺点12命令的无限扩展会增加类的数量，提高系统实现复杂度 - 针对每一个命令我们都要设计并开发一个具体的命令类 相关的设计模式命令模式和备忘录模式 1可以把两者结合使用，使用备忘录模式保存命令的历史记录，这样可以调用之前的命令 简单需求一创业公司为了抢占市场，老板对开发部前后下达了两个命令，先使用单例架构快速开发出产品，等到抢占了市场后再扩大规模把单体结构拆成微服务架构。 命令模式演练 把命令抽象成对象，这是命令模式实现的核心 1命令扩展很容易，增加命令只需封装一个命令类。如果有命令行为体根据情况修改命令行为体。 命令行为体 1每个命令执行的具体行为在行为体中，但不是必须的，也可以不要行为体，让命令执行变得更灵活。 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.command;import lombok.extern.slf4j.Slf4j;/** * Project 项目 * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class Project &#123; /** * 项目名称 */ private String name; public Project(String name)&#123; this.name = name; &#125; /** * 使用单体架构开发项目 */ public void monomer()&#123; log.info(String.format(\"%s项目使用单体架构开发\",this.name)); &#125; /** * 使用微服务架构开发项目 */ public void microservice()&#123; log.info(String.format(\"%s项目使用微服务架构开发\",this.name)); &#125;&#125; 命令接口 1234567891011121314package com.design.pattern.command;/** * Command 命令接口 * * @author shunhua * @date 2019-10-04 */public interface Command &#123; /** * 执行命令 */ void execute();&#125; 单体架构开发命令 123456789101112131415161718192021222324252627282930package com.design.pattern.command;/** * MonomerCommand 单体架构开发命令类，执行的是单体架构开发 * * @author shunhua * @date 2019-10-04 */public class MonomerCommand implements Command &#123; /** * 组合，命令对应的行为体 (非必须的，命令的行为可以根据具体业务编写) */ private Project project; /** * 构造方法 * @param project */ public MonomerCommand(Project project)&#123; this.project = project; &#125; /** * 执行命令 */ @Override public void execute() &#123; project.monomer(); &#125;&#125; 微服务架构开发命令 12345678910111213141516171819202122232425262728293031package com.design.pattern.command;/** * MicroserviceCommand 微服务架构开发命令类，执行的是微服务架构开发 * * @author shunhua * @date 2019-10-04 */public class MicroserviceCommand implements Command &#123; /** * 组合，命令对应的行为体 (非必须的，命令的行为可以根据具体业务编写) */ private Project project; /** * 构造方法 * @param project */ public MicroserviceCommand(Project project)&#123; this.project = project; &#125; /** * 执行命令 */ @Override public void execute() &#123; project.microservice(); &#125;&#125; 命令接收者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.design.pattern.command;import java.util.ArrayList;import java.util.List;/** * Staff 命令执行者 * * @author shunhua * @date 2019-10-04 */public class Staff &#123; /** * 命令集合，可以接收多个命令 */ private List&lt;Command&gt; commands = new ArrayList&lt;&gt;(); /** * 接收命令 * @param command */ public void addCommand(Command command)&#123; commands.add(command); &#125; /** * 移除命令 * @param command */ public void removeCommand(Command command)&#123; commands.remove(command); &#125; /** * 执行指定的名 * @param command */ public void execureCommand(Command command)&#123; command.execute(); &#125; /** * 执行命令集 */ public void executeCommandList()&#123; this.commands.stream().forEach(Command::execute); commands.clear(); &#125;&#125; 应用层 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.command;import org.junit.Test;/** * Boss 命令的下达者 * * @author shunhua * @date 2019-10-04 */public class Boss &#123; @Test public void test() throws InterruptedException &#123; // 创建命令的行为体 Project projectDevelopment = new Project(\"带你飞\"); // 创建命令对象(老板下达命令) MicroserviceCommand microserviceCommand = new MicroserviceCommand(projectDevelopment); MonomerCommand monomerCommand = new MonomerCommand(projectDevelopment); System.out.println(\"//-----------------------分别执行命令---------------------------/\"); // 员工接收并执行命令 Staff staff = new Staff(); staff.execureCommand(microserviceCommand); staff.execureCommand(monomerCommand); Thread.sleep(2000); System.out.println(\"//-----------------------统一执行命令集-------------------------/\"); // 员工接收多个命令,统一执行 staff.addCommand(microserviceCommand); staff.addCommand(monomerCommand); staff.executeCommandList(); &#125;&#125; 命令模式在源码中的使用Runnable接口的实现类 1Runnable可以看成一个抽象的命令，它的实现可以理解为具体的命令实现","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"状态模式","slug":"design_pattern/behaviour_type/状态模式","date":"2019-10-04T16:00:00.000Z","updated":"2020-07-04T16:28:45.956Z","comments":true,"path":"posts/8acb1976/","link":"","permalink":"https://gentryhuang.com/posts/8acb1976/","excerpt":"","text":"定义允许一个对象在其内部状态改变时，改变它的行为，如果行为不需要改变就不要改变。一般这个存在多个状态的对象是一个“上下文”。 类型行为型 使用场景1一个对象存在多个状态（不同状态下行为不同），且状态可相互转换 优点12341. 将不同的状态隔离 - 每个状态都是一个类2. 把各种状态的转换逻辑分布到State的子类中，减少相互间依赖 3. 增加新的状态非常简单（也就增加一个状态类，如果还要满足相互转换，其他已有的状态内部也需要修改） 缺点1状态多的业务场景导致类数目增加，系统变得复杂 相关的设计模式状态模式和享元模式 1它们有时可以配合使用 简单需求播放视频的时候，有播放状态、快进播放状态、暂停状态以及停止状态，这些状态大都可以相互转换。当状态发生改变时对应的播放行为也发生了改变。 状态父类 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.state;import lombok.Setter;/** * VideoState 视频状态 * * @author shunhua * @date 2019-10-05 */@Setterpublic abstract class VideoState &#123; /** * 视频资源上下文 */ protected VideoContext videoContext; /** * 播放 */ public abstract void play(); /** * 快进 */ public abstract void speed(); /** * 暂停 */ public abstract void pause(); /** * 停止 */ public abstract void stop(); &#125; 播放状态类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;/** * PlayState 视频播放状态 * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class PlayState extends VideoState &#123; @Override public void play() &#123; log.info(\"视频正常播放状态\"); &#125; /** * 可切换快进 */ @Override public void speed() &#123; super.videoContext.setVideoState(VideoContext.SPEED_STATE); &#125; /** * 可切换暂停 */ @Override public void pause() &#123; super.videoContext.setVideoState(VideoContext.PAUSE_STATE); &#125; /** * 可切换停止 */ @Override public void stop() &#123; super.videoContext.setVideoState(VideoContext.STOP_STATE); &#125;&#125; 暂停播放状态类 123456789101112131415161718192021222324252627282930313233package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;/** * PauseState 视频暂停状态 * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class PauseState extends VideoState &#123; @Override public void play() &#123; super.videoContext.setVideoState(VideoContext.PLAY_STATE); &#125; @Override public void speed() &#123; super.videoContext.setVideoState(VideoContext.SPEED_STATE); &#125; @Override public void pause() &#123; log.info(\"视频暂停播放状态\"); &#125; @Override public void stop() &#123; super.videoContext.setVideoState(VideoContext.STOP_STATE); &#125;&#125; 快进播放状态类 123456789101112131415161718192021222324252627282930313233package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;/** * SpeedState 视频加速状态 * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class SpeedState extends VideoState &#123; @Override public void play() &#123; super.videoContext.setVideoState(VideoContext.PLAY_STATE); &#125; @Override public void speed() &#123; log.info(\"视频快进播放状态\"); &#125; @Override public void pause() &#123; super.videoContext.setVideoState(VideoContext.PAUSE_STATE); &#125; @Override public void stop() &#123; super.videoContext.setVideoState(VideoContext.STOP_STATE); &#125;&#125; 停止状态类 123456789101112131415161718192021222324252627282930313233package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;/** * StopState 视频停止状态 * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class StopState extends VideoState &#123; @Override public void play() &#123; super.videoContext.setVideoState(VideoContext.PLAY_STATE); &#125; @Override public void speed() &#123; log.info(\"停止状态不能快进\"); &#125; @Override public void pause() &#123; log.info(\"停止状态不能暂停\"); &#125; @Override public void stop() &#123; log.info(\"视频停止播放状态\"); &#125;&#125; 状态对应的上下文 123456789101112131415161718192021222324252627282930313233package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class Client &#123; @Test public void test()&#123; // 声明一个上下文 VideoContext videoContext = new VideoContext(); videoContext.setVideoState(new PlayState()); log.info(\"当前状态：\" + videoContext.getVideoState().getClass().getSimpleName()); videoContext.pause(); log.info(\"当前状态：\" + videoContext.getVideoState().getClass().getSimpleName()); videoContext.speed(); log.info(\"当前状态：\" + videoContext.getVideoState().getClass().getSimpleName()); videoContext.stop(); log.info(\"当前状态：\" + videoContext.getVideoState().getClass().getSimpleName()); &#125;&#125; 状态模式在源码中的使用 状态模式和业务场景更紧密相关，比如电商中订单的状态、根据业务设置状态机、办公系统流程的状态等，源码中相对很少使用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"访问者模式","slug":"design_pattern/behaviour_type/访问者模式","date":"2019-10-04T16:00:00.000Z","updated":"2020-07-04T16:28:45.961Z","comments":true,"path":"posts/64b51ed9/","link":"","permalink":"https://gentryhuang.com/posts/64b51ed9/","excerpt":"","text":"定义封装作用于某数据结构(如List/Set/Map等)中的各元素的操作。可以在不改变各元素的类的前提下，定义作用于这些元素的操作。即当访问某个资源时，不去修改资源本身而是定义访问资源的操作 类型行为型 使用场景121. 一个数据结构如（List&#x2F;Set&#x2F;Map等）包含很多类型对象2. 数据结构于数据操作分离 优点1增加新的操作很容易，即增加一个新的访问者 缺点1231. 增加新的数据结构困难，需要修改的地方比较多2. 具体元素变更比较麻烦 - 增加或者删除元素里面的属性都算变更 相关的设计模式访问者模式和迭代器模式 121. 它们都是在某种数据结构上进行处理2. 访问者模式主要对保存在数据结构中的元素进行某种特定的处理，迭代器用于逐个遍历保存在数据结构中的一些元素 简单需求网络课程有免费的也有付费的，免费的课程普通用户都可以访问，付费的课程需要购买称为Vip用户才能访问。相同的资源不同的用户身份，访问的结果不同 访问者模式演练 当访问某个资源时，不去修改资源本身而是定义访问资源的操作。相同的资源不同的访问身份，产生不同的操作行为 抽象课程资源 12345678910111213141516171819202122232425262728package com.design.pattern.visitor;import lombok.Getter;import lombok.Setter;/** * Course 被访问的资源 * * 不改变Course,而是定义访问Course的操作，这里体现在IVisitor的方法上 * * @author shunhua * @date 2019-10-05 */@Getter@Setterpublic abstract class Course &#123; /** * 课程名称 */ private String name; /** * 接受访问 把访问者传入 * @param visitor */ public abstract void accept(IVisitor visitor); &#125; 免费课程资源 12345678910111213141516171819package com.design.pattern.visitor;/** * FreeCourse * * @author shunhua * @date 2019-10-05 */public class FreeCourse extends Course &#123; /** * 接受访问 * @param visitor */ @Override public void accept(IVisitor visitor) &#123; visitor.visit(this); &#125;&#125; 付费课程资源 12345678910111213141516171819202122232425262728package com.design.pattern.visitor;import lombok.Getter;import lombok.Setter;/** * PayCourse * * @author shunhua * @date 2019-10-05 */@Getter@Setterpublic class PayCourse extends Course &#123; /** * 价格 */ private int price; /** * 接受访问 * @param visitor */ @Override public void accept(IVisitor visitor) &#123; visitor.visit(this); &#125;&#125; 访问者抽象 12345678910111213141516171819202122232425package com.design.pattern.visitor;/** * IVisitor 访问接口 * * 这里定义了访问资源的操作，具体的访问细节体现在实现类中，不同的实现类对相同的资源产生不同的操作行为，这是访问者的核心 * * @author shunhua * @date 2019-10-05 */public interface IVisitor &#123; /** * 访问免费课程 * @param freeCourse */ void visit(FreeCourse freeCourse); /** * 访问付费课程 * @param payCourse */ void visit(PayCourse payCourse);&#125; 普通访问者 12345678910111213141516171819202122232425262728293031package com.design.pattern.visitor;import lombok.extern.slf4j.Slf4j;/** * GeneralVisitor 普通访问者 * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class GeneralVisitor implements IVisitor &#123; /** * 访问免费课程 * @param freeCourse */ @Override public void visit(FreeCourse freeCourse) &#123; log.info(\"免费课程名：\" + freeCourse.getName()); &#125; /** * 访问付费课程 * @param payCourse */ @Override public void visit(PayCourse payCourse) &#123; log.info(\"这是付费课程，你还没有购买，没有访问权限\"); &#125;&#125; Vip访问者 12345678910111213141516171819202122232425262728293031package com.design.pattern.visitor;import lombok.extern.slf4j.Slf4j;/** * VipVisitor Vip访问者 * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class VipVisitor implements IVisitor&#123; /** * 访问免费课程 * @param freeCourse */ @Override public void visit(FreeCourse freeCourse) &#123; log.info(\"免费课程名：\" + freeCourse.getName()); &#125; /** * 访问付费课程 * @param payCourse */ @Override public void visit(PayCourse payCourse) &#123; log.info(\"付费课程名：\" + payCourse.getName() + \" 价格为：\" + payCourse.getPrice()); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.design.pattern.visitor;import org.junit.Test;import java.util.ArrayList;import java.util.List;/** * Client * * @author shunhua * @date 2019-10-05 */public class Client &#123; @Test public void test()&#123; List&lt;Course&gt; courseList = new ArrayList&lt;&gt;(); FreeCourse freeCourse = new FreeCourse(); freeCourse.setName(\"这是一个免费的课程\"); PayCourse payCourse = new PayCourse(); payCourse.setName(\"这是一个付费的课程\"); payCourse.setPrice(300); courseList.add(freeCourse); courseList.add(payCourse); // 普通访问者 GeneralVisitor generalVisitor = new GeneralVisitor(); // Vip用户 VipVisitor vipVisitor = new VipVisitor(); System.out.println(\"//----------普通访问者----------------/\"); courseList.stream().forEach(course -&gt; &#123; course.accept(generalVisitor); &#125;); System.out.println(\"//----------vip用户------------------/\"); courseList.stream().forEach(course -&gt; &#123; course.accept(vipVisitor); &#125;); &#125;&#125; 访问者模式在源码中的使用FileVisitor 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package java.nio.file;import java.nio.file.attribute.BasicFileAttributes;import java.io.IOException;import java.util.Objects;/** * 资源是文件 * * @since 1.7 */public class SimpleFileVisitor&lt;T&gt; implements FileVisitor&lt;T&gt; &#123; /** * Initializes a new instance of this class. */ protected SimpleFileVisitor() &#123; &#125; /** * Invoked for a directory before entries in the directory are visited. * * &lt;p&gt; Unless overridden, this method returns &#123;@link FileVisitResult#CONTINUE * CONTINUE&#125;. */ @Override public FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException &#123; Objects.requireNonNull(dir); Objects.requireNonNull(attrs); return FileVisitResult.CONTINUE; &#125; /** * Invoked for a file in a directory. * * &lt;p&gt; Unless overridden, this method returns &#123;@link FileVisitResult#CONTINUE * CONTINUE&#125;. */ @Override public FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException &#123; Objects.requireNonNull(file); Objects.requireNonNull(attrs); return FileVisitResult.CONTINUE; &#125; /** * Invoked for a file that could not be visited. * * &lt;p&gt; Unless overridden, this method re-throws the I/O exception that prevented * the file from being visited. */ @Override public FileVisitResult visitFileFailed(T file, IOException exc) throws IOException &#123; Objects.requireNonNull(file); throw exc; &#125; /** * Invoked for a directory after entries in the directory, and all of their * descendants, have been visited. * * &lt;p&gt; Unless overridden, this method returns &#123;@link FileVisitResult#CONTINUE * CONTINUE&#125; if the directory iteration completes without an I/O exception; * otherwise this method re-throws the I/O exception that caused the iteration * of the directory to terminate prematurely. */ @Override public FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException &#123; Objects.requireNonNull(dir); if (exc != null) throw exc; return FileVisitResult.CONTINUE; &#125;&#125; BeanDefinitionVisitor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package org.springframework.beans.factory.config;import java.util.LinkedHashMap;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Set;import org.springframework.beans.MutablePropertyValues;import org.springframework.beans.PropertyValue;import org.springframework.lang.Nullable;import org.springframework.util.Assert;import org.springframework.util.ObjectUtils;import org.springframework.util.StringValueResolver;/** * 资源：Bean的定义 * * @author Juergen Hoeller * @author Sam Brannen * @since 1.2 * @see BeanDefinition * @see BeanDefinition#getPropertyValues * @see BeanDefinition#getConstructorArgumentValues * @see PropertyPlaceholderConfigurer */public class BeanDefinitionVisitor &#123; @Nullable private StringValueResolver valueResolver; /** * Create a new BeanDefinitionVisitor, applying the specified * value resolver to all bean metadata values. * @param valueResolver the StringValueResolver to apply */ public BeanDefinitionVisitor(StringValueResolver valueResolver) &#123; Assert.notNull(valueResolver, \"StringValueResolver must not be null\"); this.valueResolver = valueResolver; &#125; /** * Create a new BeanDefinitionVisitor for subclassing. * Subclasses need to override the &#123;@link #resolveStringValue&#125; method. */ protected BeanDefinitionVisitor() &#123; &#125; /** * Traverse the given BeanDefinition object and the MutablePropertyValues * and ConstructorArgumentValues contained in them. * @param beanDefinition the BeanDefinition object to traverse * @see #resolveStringValue(String) */ public void visitBeanDefinition(BeanDefinition beanDefinition) &#123; visitParentName(beanDefinition); visitBeanClassName(beanDefinition); visitFactoryBeanName(beanDefinition); visitFactoryMethodName(beanDefinition); visitScope(beanDefinition); if (beanDefinition.hasPropertyValues()) &#123; visitPropertyValues(beanDefinition.getPropertyValues()); &#125; if (beanDefinition.hasConstructorArgumentValues()) &#123; ConstructorArgumentValues cas = beanDefinition.getConstructorArgumentValues(); visitIndexedArgumentValues(cas.getIndexedArgumentValues()); visitGenericArgumentValues(cas.getGenericArgumentValues()); &#125; &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"中介者模式","slug":"design_pattern/behaviour_type/中介者模式","date":"2019-10-03T16:00:00.000Z","updated":"2020-07-04T16:28:45.952Z","comments":true,"path":"posts/d036071c/","link":"","permalink":"https://gentryhuang.com/posts/d036071c/","excerpt":"","text":"定义定义了一个封装一组对象如何交互的对象（这个对象用来协调这一组对象（“同事类”））。通过使对象明确地相互引用来促进松散耦合，并允许独立地改变它们的交互。 类型行为型 适用场景121. 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱难以理解，使用中介者进行协调2. 交互的公共行为，如果需要改变行为则可以增加新的中介者类 优点121. 将一对多转化成了一对一、降低程序复杂度2. 类之间的解耦 缺点1中介者过多，导致系统复杂 相关的设计模式中介者模式和观察者模式 1两者有时结合使用，使用观察者模式实现中介者模式中角色间的通信 简单需求公司的员工之间发送公有消息，使用工作群统一发送，不需要发送者逐一发给其他员工 中介者模式演练 中介者 12345678910111213141516171819202122232425package com.design.pattern.mediator;import lombok.extern.slf4j.Slf4j;import java.util.Date;/** * WorkGroup 中介者 - 工作群 * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class WorkGroup &#123; /** * 中介者显示员工发送的消息 * @param worker * @param msg */ public static void showMsg(Worker worker, String msg)&#123; log.info(String.format(\"%s 【%s】: %s\",new Date().toString(),worker.getName(),msg)); &#125;&#125; 参与交互的对象类 123456789101112131415161718192021222324252627package com.design.pattern.mediator;import lombok.AllArgsConstructor;import lombok.Data;/** * Worker 员工 通常称为“同事类” * * @author shunhua * @date 2019-10-04 */@Data@AllArgsConstructorpublic class Worker &#123; /** * 花名 */ private String name; /** * 员工只和中介者（工作群）打交道，这是中介者模式的核心 * @param msg */ public void sendMsg(String msg)&#123; WorkGroup.showMsg(this,msg); &#125;&#125; 应用层 12345678910111213141516171819202122232425package com.design.pattern.mediator;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-04 */public class Client &#123; @Test public void test()&#123; Worker worker = new Worker(\"舜华\"); Worker worker1= new Worker(\"高斯林\"); worker1.sendMsg(\"小伙子，就你还想学我的Java！！！\"); worker.sendMsg(\"有句话不知当讲不当讲？\"); &#125;&#125; 中介者模式在源码中的使用Timer 1Timer是一个中介者，它协调TimerTask任务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package java.util;import java.util.Date;import java.util.concurrent.atomic.AtomicInteger;public class Timer &#123; /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they're obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); /** * Timer中有多个schedule重载方法，里面都调用了sched方法 */ public void schedule(TimerTask task, long delay) &#123; if (delay &lt; 0) throw new IllegalArgumentException(\"Negative delay.\"); sched(task, System.currentTimeMillis()+delay, 0); &#125; /** * * Timer是一个中介者，通过sched方法统一协调TimerTask * * @param task 被协调的对象 * @param time * @param period */ private void sched(TimerTask task, long time, long period) &#123; if (time &lt; 0) throw new IllegalArgumentException(\"Illegal execution time.\"); // Constrain value of period sufficiently to prevent numeric // overflow while still being effectively infinitely large. if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1)) period &gt;&gt;= 1; synchronized(queue) &#123; if (!thread.newTasksMayBeScheduled) throw new IllegalStateException(\"Timer already cancelled.\"); synchronized(task.lock) &#123; if (task.state != TimerTask.VIRGIN) throw new IllegalStateException( \"Task already scheduled or cancelled\"); task.nextExecutionTime = time; task.period = period; task.state = TimerTask.SCHEDULED; &#125; queue.add(task); if (queue.getMin() == task) queue.notify(); &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"备忘录模式","slug":"design_pattern/behaviour_type/备忘录模式","date":"2019-10-03T16:00:00.000Z","updated":"2020-07-04T16:28:45.954Z","comments":true,"path":"posts/c3176455/","link":"","permalink":"https://gentryhuang.com/posts/c3176455/","excerpt":"","text":"定义保存一个对象的某个状态，以便在适当的时候恢复对象。这里的状态可以理解为对象的一个快照。 类型行为型 适用场景121 保存及恢复数据相关业务场景2 后悔的时候，即想恢复到之前的状态 优点121 为用户提供一种可恢复机制2 存档信息的封装 缺点12资源占用 - 如果暂存的对象比较多，而且对象的属性也比较多，那么肯定会对资源造成一定的消耗，占用大量的资源。 相关的设计模式备忘录模式和状态模式 1备忘录模式中是用实例来表示状态的，我们存档的是一个对象实例。状态模式中是使用类来表示状态。 简单需求在写文档时，间断性地保存，然后可以撤销回退到上一个版本 备忘录模式演练 文章 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.design.pattern.memento;import lombok.AllArgsConstructor;import lombok.Data;import java.io.Serializable;/** * Article 文章 * * @author shunhua * @date 2019-10-04 */@Data@AllArgsConstructorpublic class Article implements Serializable &#123; private static final long serialVersionUID = -321234774998152556L; /** * 文章标题 */ private String title; /** * 文章内容 */ private String content; /** * 图片 */ private String img; /** * 把文章保存起来 * @return */ public ArticleMemento saveToMemento()&#123; ArticleMemento articleMemento = new ArticleMemento(this.title,this.content,this.img); return articleMemento; &#125; /** * 把保存的文章标题、内容以及图片回退回来 * @param articleMemento */ public void undoFromMemento(ArticleMemento articleMemento)&#123; this.title = articleMemento.getTitle(); this.content = articleMemento.getContent(); this.img = articleMemento.getImg(); &#125;&#125; 文章快照 123456789101112131415161718192021222324252627282930package com.design.pattern.memento;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.ToString;/** * ArticleMemento 文章快照,对于快照不需要Setter方法，只用于保存 * * @author shunhua * @date 2019-10-04 */@Getter@ToString@AllArgsConstructorpublic class ArticleMemento &#123; /** * 标题 */ private String title; /** * 内容 */ private String content; /** * 图片 */ private String img;&#125; 文章快照暂存管理 12345678910111213141516171819202122232425262728293031323334package com.design.pattern.memento;import java.util.Stack;/** * ArticleMementoManager 文章快照管理者 * * @author shunhua * @date 2019-10-04 */public class ArticleMementoManager &#123; /** * 保存 文章快照 的栈，在回退的时候回退的是最新的状态 */ private final Stack&lt;ArticleMemento&gt; ARTICLE_MEMENTO_STACK = new Stack&lt;&gt;(); /** * 获取文章快照 * @return */ public ArticleMemento getMemento()&#123; ArticleMemento articleMemento = ARTICLE_MEMENTO_STACK.pop(); return articleMemento; &#125; /** * 把文章保存为快照 * @param articleMemento */ public void addMemento(ArticleMemento articleMemento)&#123; ARTICLE_MEMENTO_STACK.push(articleMemento); &#125;&#125; 备忘录模式在源码中的使用spring-webflow中的使用 123456789101112131415161718192021222324252627282930313233343536373839package org.springframework.binding.message;import java.io.Serializable;import org.springframework.context.MessageSource;/** * A message context whose internal state can be managed by an external care-taker. State management employs the GOF * Memento pattern. This context can produce a serializable memento representing its internal state at any time. A * care-taker can then use that memento at a later time to restore any context instance to a previous state. * * @author Keith Donald */public interface StateManageableMessageContext extends MessageContext &#123; /** * 存档 * Create a serializable memento, or token representing a snapshot of the internal state of this message context. * @return the messages memento */ Serializable createMessagesMemento(); /** * 回退 * Set the state of this context from the memento provided. After this call, the messages in this context will match * what is encapsulated inside the memento. Any previous state will be overridden. * @param messagesMemento the messages memento */ void restoreMessages(Serializable messagesMemento); /** * Configure the message source used to resolve messages added to this context. May be set at any time to change how * coded messages are resolved. * @param messageSource the message source * @see MessageContext#addMessage(MessageResolver) */ void setMessageSource(MessageSource messageSource);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"责任链模式","slug":"design_pattern/behaviour_type/责任链模式","date":"2019-10-03T16:00:00.000Z","updated":"2020-07-04T16:28:45.961Z","comments":true,"path":"posts/6208627e/","link":"","permalink":"https://gentryhuang.com/posts/6208627e/","excerpt":"","text":"定义责任链模式又叫职责链模式。为请求创建一个接收此次请求的对象的链，这个链条由多个对象组成。 类型行为型 适用场景1一个请求的处理需要链中一个或多个协作处理 优点1231.请求的发送者和接收者（请求的处理者）解耦 2.责任链可以动态组合3.责任链方便扩展和收缩（增加或减少处理对象） 缺点121. 责任链太长或者处理时间过长会影响性能2. 责任链有可能过多 相关的设计模式责任链模式和状态模式 1责任链模式中各个对象不会指定下一个处理对象是谁，只有在客户端设定链条中的顺序以及元素直到被某个元素处理或整条链结束。状态模式是让每个状态对象知道自己下一个处理的对象是谁，在编译时就设定好了。 简单需求在注册网站的时候，我们需要提供用户名、邮箱以及密码，网站会有一个校验流程，分别对用户名、邮箱以及密码进行校验，如果任何一个步骤没有通过就不能注册，只有全部校验通过才能完成注册。 责任链模式演练 责任链的构建是由客户端决定的，责任链的入口也是客户端决定的 待处理的对象 12345678910111213141516171819202122232425262728package com.design.pattern.chain;import lombok.AllArgsConstructor;import lombok.Data;/** * User 待校验的用户 * * @author shunhua * @date 2019-10-04 */@Data@AllArgsConstructorpublic class User &#123; /** * 用户名 */ private String name; /** * 邮箱 */ private String email; /** * 密码 */ private String password;&#125; 处理器父类 1234567891011121314151617181920212223242526272829303132package com.design.pattern.chain;/** * Handler 责任链模式的核心 * * 注意：构造责任链是客户端的任务,并且入口也是客户单选择的 * * @author shunhua * @date 2019-10-04 */public abstract class Handler &#123; /** * 一个自己类型的对象，一般是子类对象 */ protected Handler handler; /** * 设置下一个处理器 * @param handler */ public void setNextHandler(Handler handler)&#123; this.handler = handler; &#125; /** * 交给子类实现，用来校验用户信息是否符合 * @param user */ protected abstract void handle(User user);&#125; 名称处理器 1234567891011121314151617181920212223242526272829303132333435package com.design.pattern.chain;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.util.ObjectUtils;/** * NameHandler 用户名处理器 * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class NameHandler extends Handler &#123; /** * 校验用户名 * @param user */ @Override protected void handle(User user) &#123; if(StringUtils.isNotBlank(user.getName()))&#123; log.info(\"用户名符合要求\"); // 如果有下一个校验器就继续执行，注意这个链的顺序是由客户端决定的 if(!ObjectUtils.isEmpty(super.handler))&#123; super.handler.handle(user); return; &#125;else &#123; log.info(\"完成注册\"); &#125; return; &#125; log.info(\"用户名校验不通过，结束校验\"); &#125;&#125; 邮箱处理器 123456789101112131415161718192021222324252627282930package com.design.pattern.chain;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.util.ObjectUtils;/** * EmailHandler 邮箱校验器 * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class EmailHandler extends Handler&#123; @Override protected void handle(User user) &#123; if(StringUtils.isNotBlank(user.getEmail()))&#123; log.info(\"邮箱符合要求\"); if(!ObjectUtils.isEmpty(super.handler))&#123; super.handler.handle(user); return; &#125;else &#123; log.info(\"完成注册\"); &#125; return; &#125; log.info(\"邮箱验证不通过，验证结束\"); &#125;&#125; 密码处理器 123456789101112131415161718192021222324252627282930package com.design.pattern.chain;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.util.ObjectUtils;/** * PasswordHandler 密码验证器 * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class PasswordHandler extends Handler &#123; @Override protected void handle(User user) &#123; if(StringUtils.isNotBlank(user.getPassword()) &amp;&amp; user.getPassword().length() &gt;5)&#123; log.info(\"密码符合要求\"); if(!ObjectUtils.isEmpty(super.handler))&#123; super.handler.handle(user); return; &#125;else &#123; log.info(\"完成注册\"); &#125; return; &#125; log.info(\"密码验证不通过，验证结束\"); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031323334353637package com.design.pattern.chain;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-04 */public class Client &#123; @Test public void test()&#123; // 创建待验证的用户 User user = new User(\"shunhua\",\"gentryhuang.xw@gmail.com\",\"123456\"); // 姓名验证器 NameHandler nameHandler = new NameHandler(); // 邮箱验证器 EmailHandler emailHandler = new EmailHandler(); // 密码验证器 PasswordHandler passwordHandler = new PasswordHandler(); /** * 注意：构造责任链是客户端决定的 * * 构建责任链 : NameHandler -&gt; EmailHandler -&gt; PasswordHandler */ nameHandler.setNextHandler(emailHandler); emailHandler.setNextHandler(passwordHandler); /** * 处理请求入口 */ nameHandler.handle(user); &#125;&#125; 责任链在源码中的使用过滤器-Filter 123456789101112131415161718192021222324252627282930313233// 以OncePerRequestFilter为例public abstract class OncePerRequestFilter extends GenericFilterBean &#123; public static final String ALREADY_FILTERED_SUFFIX = \".FILTERED\"; public OncePerRequestFilter() &#123; &#125; public final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (request instanceof HttpServletRequest &amp;&amp; response instanceof HttpServletResponse) &#123; HttpServletRequest httpRequest = (HttpServletRequest)request; HttpServletResponse httpResponse = (HttpServletResponse)response; String alreadyFilteredAttributeName = this.getAlreadyFilteredAttributeName(); boolean hasAlreadyFilteredAttribute = request.getAttribute(alreadyFilteredAttributeName) != null; if (!hasAlreadyFilteredAttribute &amp;&amp; !this.skipDispatch(httpRequest) &amp;&amp; !this.shouldNotFilter(httpRequest)) &#123; request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE); try &#123; this.doFilterInternal(httpRequest, httpResponse, filterChain); &#125; finally &#123; request.removeAttribute(alreadyFilteredAttributeName); &#125; &#125; else &#123; // 待下一个过滤器处理 filterChain.doFilter(request, response); &#125; &#125; else &#123; throw new ServletException(\"OncePerRequestFilter just supports HTTP requests\"); &#125; &#125; // ... &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理模式","slug":"design_pattern/structure_type/代理模式","date":"2019-10-02T16:00:00.000Z","updated":"2020-07-04T16:28:45.967Z","comments":true,"path":"posts/7b510e10/","link":"","permalink":"https://gentryhuang.com/posts/7b510e10/","excerpt":"","text":"定义为其他对象提供一种代理，以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介的作用。 举例：租房子，目标对象代表房东，客户端代表用户，房屋中介代表中介。房屋中介起到代理的作用，签合同和缴纳水电费直接找中介就可以了，不需要和房东直接接触，即中介代理房东。 类型结构型 使用场景12◆ 保护目标对象◆ 增强目标对象 优点1234◆ 代理模式能将代理对象与真实被调用的目标对象分离◆ 一定程度上降低了系统的耦合度，扩展性好◆ 保护目标对象◆ 在不修改目标类的前提下，增强目标对象 缺点123◆ 代理模式会造成系统设计中类的数目增加◆ 在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢◆ 增加系统的复杂度 扩展 根据代理对象与目标对象代理关系的创建时机的不同，可以分为静态代理和动态代理。动态代理又根据实现技术的不同分为JDK的Proxy动态代理和CGLIB动态代理。 静态代理 1静态代理就是在代码中指定显式的代理,在编译之前代理关系就已经确定了。在代理类中对同名的方法进行包装，用户通过对代理类的被包装过的方法来调用目标对象的业务方法，同时对目标对象的业务方法进行增强。 JDK动态代理 1jdk的动态代理是通过接口中的方法名对在动态生成的代理类中，调用业务实现类的同名方法。注意:必须是接口,因为jdk底层先创建一个代理类，然后再创建代理类的实例，它的类型是接口类型，不是目标类的类型。 CGLIB代理 1cglib是通过继承来实现的，生成的代理类是业务类的子类，通过重写业务方法执行代理。使用CGLib进行代理时一定要注意final修改的类和方法以及是否有无参构造器。CGLib底层使用asm字节码生成的。 代理模式相关的设计模式代理模式和装饰者模式 1目的不同，装饰者模式是为对象加上行为，而代理模式是控制访问，代理模式更加关注通过控制代理人的方式来增强目标对象。增强对象的方式一般是增强对象的某些行为。 代理模式和适配器模式 1适配器模式主要改变所要考虑对象的接口，代理模式不可以改变所代理类的接口。 代理模式演练静态代理 静态代理的代理类是手动编写的，代理关系在编译之前就确立了。通常目标对象在代理类中创建。 目标类接口 1234567891011121314package com.design.pattern.proxy.staticproxy;/** * IRentalHouseService * * @author shunhua * @date 2019-10-03 */public interface IRentalHouseService &#123; /** * 租房方法 */ void rent();&#125; 目标类 123456789101112131415161718192021222324package com.design.pattern.proxy.jdkproxy;import com.design.pattern.proxy.staticproxy.IRentalHouseService;import lombok.extern.slf4j.Slf4j;/** *RentalHouseServiceImpl * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseService implements IRentalHouseService &#123; /** * 出租房子，目标方法 * @return */ @Override public void rent()&#123; log.info(\"1800/月，2室1厅1厨1卫！\"); &#125;&#125; 代理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.design.pattern.proxy.staticproxy;import lombok.extern.slf4j.Slf4j;/** * RentalHouseServiceProxy 代理类 * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceProxy &#123; /** * 代理对象需要目标对象 */ private RentalHouseService rentalHouseService; /** * 构造方法 */ public RentalHouseServiceProxy()&#123; rentalHouseService = new RentalHouseService(); &#125; /** * 代理方法 */ public void rent()&#123; dialNumber(); rentalHouseService.rent(); signContract(); &#125; /** * 需要房租请联系我，目标方法的前置方法 */ private void dialNumber() &#123; log.info(\"需要租房请致电：123456\"); &#125; /** * 签合同，目标方法的后置方法 */ private void signContract() &#123; log.info(\"房子还满意就可以签合同了！\"); &#125;&#125; 应用层 1234567891011121314151617181920package com.design.pattern.proxy.staticproxy;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-03 */public class Client &#123; @Test public void test()&#123; // 租房直接找代理 RentalHouseServiceProxy proxy = new RentalHouseServiceProxy(); proxy.rent(); &#125;&#125; jdk动态代理 jdk动态代理用于目标类有接口的情况。代理类不是手动创建，而是程序运行时动态生成。有时目标对象需要在客户端中创建，这样情况下不能够保护和隐藏目标对象，只是增强了目标方法功能。代理类的名称由三部分构成：$ + Proxy + 数字，数字表示当前JDK的Proxy所生成的代理类的索引，索引从0开始计数。 目标类接口 1234567891011121314package com.design.pattern.proxy.jdkproxy;/** * IRentalHouseService * * @author shunhua * @date 2019-10-03 */public interface IRentalHouseService &#123; /** * 租房方法 */ void rent();&#125; 目标类 123456789101112131415161718192021222324package com.design.pattern.proxy.jdkproxy;import com.design.pattern.proxy.staticproxy.IRentalHouseService;import lombok.extern.slf4j.Slf4j;/** * RentalHouseServiceImpl 目标类 * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceImpl implements IRentalHouseService &#123; /** * 出租房子，目标方法 * @return */ @Override public void rent()&#123; log.info(\"1800/月，2室1厅1厨1卫！\"); &#125;&#125; InvocationHandler实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.design.pattern.proxy.jdkproxy;import lombok.extern.slf4j.Slf4j;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * RentalHouseServiceProxy * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceProxy implements InvocationHandler &#123; private IRentalHouseService target; public RentalHouseServiceProxy(IRentalHouseService target) &#123; this.target = target; &#125; /** * 当执行代理对象的代理方法时，代理方法会调用该invoke() * * @param proxy 代理对象 * @param method 目标方法 * @param args 目标方法的参数列表 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 调用目标方法前 dialNumber(); // 执行目标方法 Object result = method.invoke(target, args); // 调用目标方法后 signContract(); return result; &#125; /** * 需要房租请联系我，目标方法的前置方法 */ private void dialNumber() &#123; log.info(\"需要租房请致电：123456\"); &#125; /** * 签合同，目标方法的后置方法 */ private void signContract() &#123; log.info(\"房子还满意就可以签合同了！\"); &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930313233package com.design.pattern.proxy.jdkproxy;import org.junit.Test;import java.lang.reflect.Proxy;/** * Client * * @author shunhua * @date 2019-10-04 */public class Client &#123; @Test public void test()&#123; // 创建目标对象 IRentalHouseService target = new RentalHouseServiceImpl(); // 创建代理对象（接口实现类的代理对象） IRentalHouseService proxy = (IRentalHouseService) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new RentalHouseServiceProxy(target) ); /** * 调用代理对象的代理方法,注意当调用代理对象的代理方法时，InvocationHandler的invoke方法会被自动调用 */ proxy.rent(); &#125;&#125; CGLIB动态代理 CGLIB的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类，代理的目标类可以没有实现接口，也可以有实现的接口。CGLIB使用子类扩展父类的方式来生成代理对象，即CGLIB会动态生成目标类的子类作为代理类，并创建其对象即代理对象。 目标类 123456789101112131415161718192021222324package com.design.pattern.proxy.cglibproxy;import com.design.pattern.proxy.staticproxy.IRentalHouseService;import lombok.extern.slf4j.Slf4j;/** * RentalHouseServiceImpl 目标类 * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceImpl implements IRentalHouseService &#123; /** * 出租房子，目标方法 * @return */ @Override public void rent()&#123; log.info(\"1800/月，2室1厅1厨1卫！\"); &#125;&#125; MethodInterceptor的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.design.pattern.proxy.cglibproxy;import lombok.extern.slf4j.Slf4j;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * RentalHouseServiceProxy * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceProxy implements MethodInterceptor &#123; /** * * @param o 代理对象 * @param method 目标方法 * @param objects 目标方法参数列表 * @param methodProxy 目标方法的代理对象 * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return null; &#125; /** * 需要房租请联系我，目标方法的前置方法 */ private void dialNumber() &#123; log.info(\"需要租房请致电：123456\"); &#125; /** * 签合同，目标方法的后置方法 */ private void signContract() &#123; log.info(\"房子还满意就可以签合同了！\"); &#125;&#125; 生成代理类的逻辑类 1234567891011121314151617181920212223242526272829303132333435package com.design.pattern.proxy.cglibproxy;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;/** * CglibProxy 手动创建 * * @author shunhua * @date 2019-10-04 */public class CglibProxy &#123; /** * 创建Cglib的代理对象 * * @param targetClass 目标类 * @param callBack 委托类对象 * @return */ public static IRentalHouseService createCglibProxy(Class targetClass, MethodInterceptor callBack)&#123; // 创建增强其 Enhancer enhancer = new Enhancer(); // 指定目标类 enhancer.setSuperclass(targetClass); // 设置回调接口 enhancer.setCallback(callBack); // 创建并返回代理对象，即目标类的子类对象 return (IRentalHouseService) enhancer.create(); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031package com.design.pattern.proxy.cglibproxy;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-04 */public class Client &#123; @Test public void test() &#123; // 创建目标对象 IRentalHouseService target = new RentalHouseServiceImpl(); // 创建委托对象 RentalHouseServiceProxy rentalHouseServiceProxy = new RentalHouseServiceProxy(); // 创建代理对象（接口实现类的代理对象） IRentalHouseService cglibProxy = CglibProxy.createCglibProxy(target.getClass(), rentalHouseServiceProxy); /** * 调用代理对象的代理方法,注意当调用代理对象的代理方法时，InvocationHandler的invoke方法会被自动调用 */ cglibProxy.rent(); &#125;&#125; 代理模式在源码中的使用jdk中的应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490package java.lang.reflect;import java.lang.ref.WeakReference;import java.security.AccessController;import java.security.PrivilegedAction;import java.util.Arrays;import java.util.IdentityHashMap;import java.util.Map;import java.util.Objects;import java.util.concurrent.atomic.AtomicLong;import java.util.function.BiFunction;import sun.misc.ProxyGenerator;import sun.misc.VM;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;import sun.reflect.misc.ReflectUtil;import sun.security.util.SecurityConstants;public class Proxy implements java.io.Serializable &#123; private static final long serialVersionUID = -2222568056686623797L; /** parameter types of a proxy class constructor */ private static final Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;; /** * a cache of proxy classes */ private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory()); /** * the invocation handler for this proxy instance. * @serial */ protected InvocationHandler h; /** * Prohibits instantiation. */ private Proxy() &#123; &#125; /** * Constructs a new &#123;@code Proxy&#125; instance from a subclass * (typically, a dynamic proxy class) with the specified value * for its invocation handler. * * @param h the invocation handler for this proxy instance * * @throws NullPointerException if the given invocation handler, &#123;@code h&#125;, * is &#123;@code null&#125;. */ protected Proxy(InvocationHandler h) &#123; Objects.requireNonNull(h); this.h = h; &#125; @CallerSensitive public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) throws IllegalArgumentException &#123; final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; return getProxyClass0(loader, intfs); &#125; /* * Check permissions required to create a Proxy class. * * To define a proxy class, it performs the access checks as in * Class.forName (VM will invoke ClassLoader.checkPackageAccess): * 1. \"getClassLoader\" permission check if loader == null * 2. checkPackageAccess on the interfaces it implements * * To get a constructor and new instance of a proxy class, it performs * the package access check on the interfaces it implements * as in Class.getConstructor. * * If an interface is non-public, the proxy class must be defined by * the defining loader of the interface. If the caller's class loader * is not the same as the defining loader of the interface, the VM * will throw IllegalAccessError when the generated proxy class is * being defined via the defineClass0 method. */ private static void checkProxyAccess(Class&lt;?&gt; caller, ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; ClassLoader ccl = caller.getClassLoader(); if (VM.isSystemDomainLoader(loader) &amp;&amp; !VM.isSystemDomainLoader(ccl)) &#123; sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION); &#125; ReflectUtil.checkProxyPackageAccess(ccl, interfaces); &#125; &#125; /** * 生成代理类的核心方法 */ private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(\"interface limit exceeded\"); &#125; // 如果缓存中有对应的代理类就直接获取，没有就创建然后放入缓存 return proxyClassCache.get(loader, interfaces); &#125; /* * a key used for proxy class with 0 implemented interfaces */ private static final Object key0 = new Object(); /* * Key1 and Key2 are optimized for the common use of dynamic proxies * that implement 1 or 2 interfaces. */ /* * a key used for proxy class with 1 implemented interface */ private static final class Key1 extends WeakReference&lt;Class&lt;?&gt;&gt; &#123; private final int hash; Key1(Class&lt;?&gt; intf) &#123; super(intf); this.hash = intf.hashCode(); &#125; @Override public int hashCode() &#123; return hash; &#125; @Override public boolean equals(Object obj) &#123; Class&lt;?&gt; intf; return this == obj || obj != null &amp;&amp; obj.getClass() == Key1.class &amp;&amp; (intf = get()) != null &amp;&amp; intf == ((Key1) obj).get(); &#125; &#125; /* * a key used for proxy class with 2 implemented interfaces */ private static final class Key2 extends WeakReference&lt;Class&lt;?&gt;&gt; &#123; private final int hash; private final WeakReference&lt;Class&lt;?&gt;&gt; ref2; Key2(Class&lt;?&gt; intf1, Class&lt;?&gt; intf2) &#123; super(intf1); hash = 31 * intf1.hashCode() + intf2.hashCode(); ref2 = new WeakReference&lt;Class&lt;?&gt;&gt;(intf2); &#125; @Override public int hashCode() &#123; return hash; &#125; @Override public boolean equals(Object obj) &#123; Class&lt;?&gt; intf1, intf2; return this == obj || obj != null &amp;&amp; obj.getClass() == Key2.class &amp;&amp; (intf1 = get()) != null &amp;&amp; intf1 == ((Key2) obj).get() &amp;&amp; (intf2 = ref2.get()) != null &amp;&amp; intf2 == ((Key2) obj).ref2.get(); &#125; &#125; /* * a key used for proxy class with any number of implemented interfaces * (used here for 3 or more only) */ private static final class KeyX &#123; private final int hash; private final WeakReference&lt;Class&lt;?&gt;&gt;[] refs; @SuppressWarnings(\"unchecked\") KeyX(Class&lt;?&gt;[] interfaces) &#123; hash = Arrays.hashCode(interfaces); refs = (WeakReference&lt;Class&lt;?&gt;&gt;[])new WeakReference&lt;?&gt;[interfaces.length]; for (int i = 0; i &lt; interfaces.length; i++) &#123; refs[i] = new WeakReference&lt;&gt;(interfaces[i]); &#125; &#125; @Override public int hashCode() &#123; return hash; &#125; @Override public boolean equals(Object obj) &#123; return this == obj || obj != null &amp;&amp; obj.getClass() == KeyX.class &amp;&amp; equals(refs, ((KeyX) obj).refs); &#125; private static boolean equals(WeakReference&lt;Class&lt;?&gt;&gt;[] refs1, WeakReference&lt;Class&lt;?&gt;&gt;[] refs2) &#123; if (refs1.length != refs2.length) &#123; return false; &#125; for (int i = 0; i &lt; refs1.length; i++) &#123; Class&lt;?&gt; intf = refs1[i].get(); if (intf == null || intf != refs2[i].get()) &#123; return false; &#125; &#125; return true; &#125; &#125; /** * A function that maps an array of interfaces to an optimal key where * Class objects representing interfaces are weakly referenced. */ private static final class KeyFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Object&gt; &#123; @Override public Object apply(ClassLoader classLoader, Class&lt;?&gt;[] interfaces) &#123; switch (interfaces.length) &#123; case 1: return new Key1(interfaces[0]); // the most frequent case 2: return new Key2(interfaces[0], interfaces[1]); case 0: return key0; default: return new KeyX(interfaces); &#125; &#125; &#125; /** * A factory function that generates, defines and returns the proxy class given * the ClassLoader and array of interfaces. */ private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; // prefix for all proxy class names private static final String proxyClassNamePrefix = \"$Proxy\"; // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + \" is not visible from class loader\"); &#125; /* * Verify that the Class object actually represents an * interface. */ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + \" is not an interface\"); &#125; /* * Verify that this interface is not a duplicate. */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( \"repeated interface: \" + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( \"non-public interfaces from different packages\"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\"; &#125; /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125; &#125; // 该方法最终返回一个新的对象（目标对象） @CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * 生成代理类的核心方法 */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; private static void checkNewProxyPermission(Class&lt;?&gt; caller, Class&lt;?&gt; proxyClass) &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; if (ReflectUtil.isNonPublicProxyClass(proxyClass)) &#123; ClassLoader ccl = caller.getClassLoader(); ClassLoader pcl = proxyClass.getClassLoader(); // do permission check if the caller is in a different runtime package // of the proxy class int n = proxyClass.getName().lastIndexOf('.'); String pkg = (n == -1) ? \"\" : proxyClass.getName().substring(0, n); n = caller.getName().lastIndexOf('.'); String callerPkg = (n == -1) ? \"\" : caller.getName().substring(0, n); if (pcl != ccl || !pkg.equals(callerPkg)) &#123; sm.checkPermission(new ReflectPermission(\"newProxyInPackage.\" + pkg)); &#125; &#125; &#125; &#125; /** * Returns true if and only if the specified class was dynamically * generated to be a proxy class using the &#123;@code getProxyClass&#125; * method or the &#123;@code newProxyInstance&#125; method. * * &lt;p&gt;The reliability of this method is important for the ability * to use it to make security decisions, so its implementation should * not just test if the class in question extends &#123;@code Proxy&#125;. * * @param cl the class to test * @return &#123;@code true&#125; if the class is a proxy class and * &#123;@code false&#125; otherwise * @throws NullPointerException if &#123;@code cl&#125; is &#123;@code null&#125; */ public static boolean isProxyClass(Class&lt;?&gt; cl) &#123; return Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl); &#125; /** * Returns the invocation handler for the specified proxy instance. * * @param proxy the proxy instance to return the invocation handler for * @return the invocation handler for the proxy instance * @throws IllegalArgumentException if the argument is not a * proxy instance * @throws SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present * and the caller's class loader is not the same as or an * ancestor of the class loader for the invocation handler * and invocation of &#123;@link SecurityManager#checkPackageAccess * s.checkPackageAccess()&#125; denies access to the invocation * handler's class. */ @CallerSensitive public static InvocationHandler getInvocationHandler(Object proxy) throws IllegalArgumentException &#123; /* * Verify that the object is actually a proxy instance. */ if (!isProxyClass(proxy.getClass())) &#123; throw new IllegalArgumentException(\"not a proxy instance\"); &#125; final Proxy p = (Proxy) proxy; final InvocationHandler ih = p.h; if (System.getSecurityManager() != null) &#123; Class&lt;?&gt; ihClass = ih.getClass(); Class&lt;?&gt; caller = Reflection.getCallerClass(); if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), ihClass.getClassLoader())) &#123; ReflectUtil.checkPackageAccess(ihClass); &#125; &#125; return ih; &#125; private static native Class&lt;?&gt; defineClass0(ClassLoader loader, String name, byte[] b, int off, int len);&#125; Spring中的应用12345678910111213141516public class ProxyFactoryBean extends ProxyCreatorSupport implements FactoryBean&lt;Object&gt;, BeanClassLoaderAware, BeanFactoryAware &#123; //如果不声明，默认单例对象，注解声明多例，则声明多例对象 public Object getObject() throws BeansException &#123; this.initializeAdvisorChain(); if (this.isSingleton()) &#123; return this.getSingletonInstance(); &#125; else &#123; if (this.targetName == null) &#123; this.logger.warn(\"Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the 'targetName' property.\"); &#125; return this.newPrototypeInstance(); &#125; &#125;&#125; 12JdkDynamicAopProxy:对jdk动态代理的封装CglibAopProxy:对类进行代理增强 MyBatis中的应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package org.apache.ibatis.binding;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import org.apache.ibatis.session.SqlSession;/** * @author Lasse Voss */public class MapperProxyFactory&lt;T&gt; &#123; private final Class&lt;T&gt; mapperInterface; private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;&gt;(); public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; public Map&lt;Method, MapperMethod&gt; getMethodCache() &#123; return methodCache; &#125; @SuppressWarnings(\"unchecked\") protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; // 生成一个代理对象并返回 return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;,); &#125; public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); &#125;&#125;/** * MapperProxy代理类的信息 */public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable &#123; private static final long serialVersionUID = -6424540398559729838L; private final SqlSession sqlSession; private final Class&lt;T&gt; mapperInterface; private final Map&lt;Method, MapperMethod&gt; methodCache; public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) &#123; this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; this.methodCache = methodCache; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, args); &#125; else if (isDefaultMethod(method)) &#123; return invokeDefaultMethod(proxy, method, args); &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; final MapperMethod mapperMethod = cachedMapperMethod(method); return mapperMethod.execute(sqlSession, args); &#125; private MapperMethod cachedMapperMethod(Method method) &#123; return methodCache.computeIfAbsent(method, k -&gt; new MapperMethod(mapperInterface, method, sqlSession.getConfiguration())); &#125; // ... 等等 ｝","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"观察者模式","slug":"design_pattern/behaviour_type/观察者模式","date":"2019-10-01T16:00:00.000Z","updated":"2020-07-04T16:28:45.959Z","comments":true,"path":"posts/9a246216/","link":"","permalink":"https://gentryhuang.com/posts/9a246216/","excerpt":"","text":"定义定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并更新。 类型行为型 适用场景1关联行为场景，建立一套触发机制。如：注某个产品的价格，然后进行通知，其中价格的变动可能会影响一条链，就像是一个触发链条。这样就可以使用观察者模式创建一个种链式发机制。 优点12341. 观察者和被观察者之间建立一个抽象的耦合 - 因为是抽象的耦合关系，不管是增加观察者还是被观察者都很容易扩展2. 支持广播通信 - 类似消息广播，需要监听主题的只需要注册就可以了 缺点123451. 观察者之间有过多的细节依赖、提高了时间消耗及程序复杂度 - 过多的依赖：触发机制和触发链条 - 提高了时间消耗及程序复杂度：如果一个被观察对象有多个直接或间接观察者，一旦被观察者变化，然后发出通知，将所有观察者都通知到会花费一些时间2. 使用要得当，避免循环调用 - 如果在观察者和被观察者之间有循环依赖的话，被观察者（主题对象）会触发它们之间进行循环调用，这样会导致系统崩溃 简单需求学生在学习课程的时候可能会提出问题，而老师则是关注自己的课程，有学生提出自己课程的问题就给出解答 观察者模式演练 被观察者需要继承的类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package java.util;/** * @since JDK1.0 */public class Observable &#123; private boolean changed = false; private Vector&lt;Observer&gt; obs; /** Construct an Observable with zero Observers. */ public Observable() &#123; obs = new Vector&lt;&gt;(); &#125; /** * * 在观察者列表中增加一个观察者 * * @param o 要添加的观察者对象 * @throws NullPointerException 如果参数传入null会抛出异常 */ public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; /** * 从观察者列表中删除指定的观察者 * * @param o 要被移出的观察者 出入为null不会抛出异常 */ public synchronized void deleteObserver(Observer o) &#123; obs.removeElement(o); &#125; /** * 通知观察者们，主题对象（被观察者发生了改变），该方法不传参数给观察者们 */ public void notifyObservers() &#123; notifyObservers(null); &#125; /** * 通知观察者们，主题对象（被观察者发生了改变），该方法传参数给观察者们 */ public void notifyObservers(Object arg) &#123; /* * a temporary array buffer, used as a snapshot of the state of * current Observers. */ Object[] arrLocal; synchronized (this) &#123; /* * 在通知观察者们之前会先校验标识主题对象（被观察者）改变的属性，如果没有改变就直接返回不进行通知 */ if (!changed) return; arrLocal = obs.toArray(); clearChanged(); &#125; for (int i = arrLocal.length-1; i&gt;=0; i--) // 通过调用观察者的update方法通知观察者，会把当前主题对象（被观察者对象）传给观察者 ((Observer)arrLocal[i]).update(this, arg); &#125; /** * 清除观察者列表 */ public synchronized void deleteObservers() &#123; obs.removeAllElements(); &#125; /** * 调用这个方法就是说明了主题对象（被观察者发生了改变），设置标识对象为true */ protected synchronized void setChanged() &#123; changed = true; &#125; /** * * 调用这个方法说明主题对象（被观察者）已经不再改变了或者要通知的观察者都通知完了。这个方法会在调用notifyObservers方法自动调用 */ protected synchronized void clearChanged() &#123; changed = false; &#125; /** * 获取主题对象是否改变的标识 */ public synchronized boolean hasChanged() &#123; return changed; &#125; /** * 返回关注主题对象的观察的个数 * * @return the number of observers of this object. */ public synchronized int countObservers() &#123; return obs.size(); &#125;&#125; 观察者需要实现的接口 123456789101112package java.util;/** * @since JDK1.0 */public interface Observer &#123; /** * * 当订阅的主题对象（被观察者）发生改变时，会通过调用 notifyObservers方法来通知所有设计到的观察者，就是通过调用观察者的update方法进行通知的 */ void update(Observable o, Object arg);&#125; 主题类（被观察者） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.design.pattern.observer;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.util.ArrayList;import java.util.List;import java.util.Observable;/** * Course * 1 它下面有问题，Course属于被观察者，也就是主题对象 * 2 作为被观察者必须继承Observable类，标志是可观察的 * * @author shunhua * @date 2019-10-02 */@Data@Slf4jpublic class Course extends Observable &#123; /** * 课程名 */ private String name; /** * 课程对应的问题列表 */ private List&lt;Question&gt; questions = new ArrayList&lt;&gt;(); public Course(String name) &#123; this.name = name; &#125; public void addQuestion(Question question) &#123; questions.add(question); &#125; /** * 主题改变方法 * * @param course */ public void produceQuestion(Course course) &#123; questions.stream().forEach(question -&gt; &#123; log.info(String.format(\"%s在%s提出了问题\", question.getUserName(), course.getName())); /** * 调用父类Observabel中的setChanged方法，把changed标识设置为true,表示主题对象发生了改变,此时观察者和被观察者之间进行通信 */ setChanged(); /** * 通知观察者 */ notifyObservers(question); &#125; ); &#125;&#125; 观察者 123456789101112131415161718192021222324252627282930313233343536373839package com.design.pattern.observer;import lombok.AllArgsConstructor;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.util.Observable;import java.util.Observer;/** * Teacher * * 1 观察的是课程，而不是问题，问题属于课程 。 Teacher属于观察者 * 2 必须实现Observer接口，表示它是一个观察者 * * @author shunhua * @date 2019-10-02 */@Data@AllArgsConstructor@Slf4jpublic class Teacher implements Observer &#123; /** * 老师名称 */ private String name; /** * * @param o 被观察对象 * @param arg 被观察者的notifyObservers方法传递过来的对象 */ @Override public void update(Observable o, Object arg) &#123; Course course = (Course) o; Question question = (Question) arg; log.info(String.format(\"%s课程被%s同学提出%s的问题，需要%s解答\",course.getName(),question.getUserName(),question.getQuestionContent(),name)); &#125;&#125; 应用辅助类 1234567891011121314151617181920212223package com.design.pattern.observer;import lombok.Builder;import lombok.Data;/** * Question * * @author shunhua * @date 2019-10-02 */@Data@Builderpublic class Question &#123; /** * 问题提问者名称 */ private String userName; /** * 具体问题 */ private String questionContent;&#125; 应用层 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.observer;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-02 */public class Client &#123; @Test public void test()&#123; Course course = new Course(\"《Java从入门到放弃》\"); Teacher teacher = new Teacher(\"Java学院老师\"); Teacher teacher1 = new Teacher(\"鼓励师\"); // 为课程添加观察者 course.addObserver(teacher); course.addObserver(teacher1); // 添加课程的问题 course.addQuestion(Question.builder() .userName(\"gentryhuang\") .questionContent(\"Java学不完，需要放弃吗？\") .build()); course.addQuestion(Question.builder() .userName(\"xw\") .questionContent(\"快看，又一个学Java的转行了，要跑路吗？\") .build()); // 主题对象发生变化（有问题提出了） course.produceQuestion(course); &#125;&#125; 观察者模式源码解析监听器实现方案就是观察者模式实现的一种 Guava中观察者模式的使用 使用@Subscribe进行方法标注 12345678910111213141516171819package com.design.pattern.observer.guava;import com.google.common.eventbus.Subscribe;import lombok.extern.slf4j.Slf4j;/** * GuavaEvent * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class GuavaEvent &#123; @Subscribe public void subscribe(String event)&#123; log.info(\"执行subscribe方法，传入参数是：\" + event); &#125;&#125; 在应用层把订阅者进行注册 12345678910111213141516171819202122232425262728293031323334package com.design.pattern.observer.guava;import com.google.common.eventbus.EventBus;import org.junit.Test;/** * GuavaEventTest * * @author shunhua * @date 2019-10-02 */public class GuavaEventTest &#123; @Test public void test() &#123; /** * Guava实现观察者模式的核心类 */ EventBus eventBus = new EventBus(); /** * GuavaEvent中有使用@Subscribe注解标注的方法 */ GuavaEvent guavaEvent = new GuavaEvent(); /** * GuavaEvent的@Subscribe标注的方法 加入到观察者模式中，作为订阅者即观察者 */ eventBus.register(guavaEvent); /** * 调用EventBus的post方法会回调Subscribe标注的方法 */ eventBus.post(\"post的内容\"); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","slug":"design_pattern/creation_type/单例模式","date":"2019-10-01T16:00:00.000Z","updated":"2020-07-04T16:28:45.963Z","comments":true,"path":"posts/f1601c3e/","link":"","permalink":"https://gentryhuang.com/posts/f1601c3e/","excerpt":"","text":"单例模式定义保证一个类仅有一个实例，并提供一个全局访问点。 类型创建型 适用场景12想确保任何情况下都绝对只有一个实例 - 数据库连接池、线程池以及计数器等 优点1234561. 在内存里只有一个实例，减少了内存开销 - 特别是一个对象频繁的创建和销毁，而且在创建和销毁时性能又不能很好的优化2. 可以避免对资源的多重占用 - 如对一个文件进行写操作，由于只有一个实例存在内存中，可以避免对同一个资源文件同时写操作3. 设置全局访问点，严格控制访问 - 对外控制创建的入口 缺点1没有接口，扩展困难，想要扩展需要修改源代码 拓展点1234567891011121. 私有构造器 - 为了禁止从单例类外部调用构造函数创建对象，为了达到目的必须设置构造函数为私有的2. 线程安全 - 线程安全在单例模式设计的过程中非常重要3. 延迟加载 - 延时创建对象4. 序列化和反序列化安全 - 对于单例对象一旦序列化和反序列化，就会对单例进行破坏5. 反射 - 单例模式也要防止反射攻击6. 双重检锁机制7. 单例静态内部类的实现方案 单例模式相关的设计模式单例模式和工厂模式 1在一些业务场景中，我们可以把工厂类设置为单例的 单例模式和享元模式 1在一些业务场景中，要管理很多单例对象，通过享元模式和单例模式结合来完成单例对象的获取，在这种结合场景下，享元模式的应用就类似于单例对象的一个工厂，只不过会获取已经创建好的对象而不会重新创建新的对象。 单例模式类型懒汉式单例模式-非安全 1234567891011121314151617181920212223242526272829303132333435363738394041package com.design.pattern.singleton.lazynosafe;/** * LazyDoubleCheckSingleton 懒汉式-线程不安全 * * @author shunhua * @date 2019-10-02 */public class LazySingleton &#123; /** * 定义LazySingleton属性 */ private static LazySingleton lazySingleton = null; /** * 指定构造方法是私有的 */ private LazySingleton()&#123;&#125; /** * 全局控制点 * @return */ public static LazySingleton getInstance()&#123; /** * 在没有断点干预的情况下，多线程执行和CPU分配有关。为了更清楚的观看多线程执行，可以使用多线程debug来达到控制多个线程的目的 * * 在多线程下有以下几种可能，这里以两个线程解释，线程A和线程B * * 1 当线程B走到if(lazySingleton == null)时，线程A已经执行创建好了对象，此时线程B直接返回线程A创建的对象 * 2 当线程B走到if(lazySingleton == null)时，线程A还没有创建好对象即LazySingleton仍然为空，紧接着线程B的if判断通过，当A创建完对象准备返回lazySingleton即执行return lazySingleton时，线程B创建好了对象并赋值给lazySingleton，此时lazySingleton变量的值是线程B创建的对象引用，会覆盖线程A创建的对象对应的引用，最终线程A和线程B返回的虽然是指向同一个对象（线程B创建的）的引用，但是实质上对象已经创建了两次。 * 3 当线程B走到if(lazySingleton == null)时，线程A还没有创建好对象即LazySingleton仍然为空，仅接着线程B的if判断通过，线程A在线程B创建对象之前返回了，那么最终线程A和线程B都会创建对象，并且返回的对象引用不会相同，它们指向各自创建的对象。 * */ if(lazySingleton == null)&#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125; 123456789101112131415161718192021package com.design.pattern.singleton.lazynosafe;import lombok.extern.slf4j.Slf4j;/** * MyThread 实现Runnable接口，实现多线程 * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class MyThread implements Runnable &#123; @Override public void run() &#123; // 获取目标对象 LazySingleton lazySingleton = LazySingleton.getInstance(); // 打印当前执行的线程信息和目标对象信息 log.info(Thread.currentThread().getName() +\" \"+ lazySingleton); &#125;&#125; 懒汉式单例模式安全-锁粒度较大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.design.pattern.singleton.lazysafebutlockisbig;/** * LazyDoubleCheckSingleton 懒汉式-线程安全但是锁的粒度太大 * * @author shunhua * @date 2019-10-02 */public class LazySingleton &#123; /** * 定义LazySingleton属性 */ private static LazySingleton lazySingleton = null; /** * 指定构造方法是私有的 */ private LazySingleton()&#123;&#125; /** * 全局控制点 * * synchronize加锁的位置不同，线程持有的对象也会不同 * 1 加在静态方法上，持有的是类的class文件，即当前类 * 2 加在非静态方法上，持有的是堆内存中的对象，即执行当前方法的对象 * * @return */ public synchronized static LazySingleton getInstance()&#123; /** * synchronize加锁在静态方法上等同于锁代码块时LazySingleton.class作为持有对象： * * public static LazyDoubleCheckSingleton getInstance()&#123; * synchronized(LazyDoubleCheckSingleton.class)&#123; * if (lazySingleton == null) &#123; * lazySingleton = new LazyDoubleCheckSingleton(); * &#125; * &#125; * return lazySingleton; * &#125; */ if(lazySingleton == null)&#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125; 懒汉式单例模式-双重检锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.design.pattern.singleton.lazysafedoublecheck;/** * LazyDoubleCheckSingleton 双重检锁，兼顾了性能和线程安全 * * @author shunhua * @date 2019-10-03 */public class LazyDoubleCheckSingleton &#123; /** * 定义LazySingleton属性 ,这里加volatile关键字防止指令重排序和内存可见 */ private volatile static LazyDoubleCheckSingleton lazySingleton = null; /** * 指定构造方法是私有的 */ private LazyDoubleCheckSingleton()&#123;&#125; /** * 全局控制点 * * 双重检锁指的就是两次判断 * * @return */ public static LazyDoubleCheckSingleton getInstance()&#123; /** * 1 这一层if判断如果不使用也能保证线程安全，但是锁的粒度又回到了大粒度版本。使用这一层判断是为了缩小synchronized锁的粒度 * 2 引入了这一层会增加一个隐患-由于指令重排序，走到该层if判断lazySingleton可能确实不为空，但是它指向的对象可能还没有初始化完成，当使用这个对象的时候可能会导致系统异常 */ if(lazySingleton == null)&#123; /** * 加锁 */ synchronized (LazyDoubleCheckSingleton.class)&#123; /** * 这一层if必须要有，因为synchronized锁的粒度小了，不是整个方法，当出现线程进入第一个if块中但被阻塞在同步代码块外时（别的线程拿到了锁在里面创建对象）， * 如果不加该if判断该线程还会创建一个对象，而不会直接返回已经创建好的对象的引用。 */ if(lazySingleton == null)&#123; /** LazyDoubleCheckSingleton = new LazyDoubleCheckSingleton() JVM主要做的事粗略步骤如下： * * 1. 在堆空间里分配内存给这个对象 * 2. 执行构造方法进行初始化，注意此初始化不是类加载过程中的初始化 * 3. 设置lazySingleton指向分配好的内存地址 * 注意：在没有处理指令重排序的情况下2、3两步由于重排序可能步骤会倒置（因为Java语言规范，允许那些在单线程内不会改变单线程程序执行结果的重排序，因为有的重排序可以提高程序执行性能 ），这会可能会造成线程拿到的引用指向的是一个还没有初始化完成的对象，虽然不为空但它还没有执行构造方法，如果恰巧构造方法里面需要对某些参数进行初始化，当使用这个对象还没有初始化的参数时会导致系统异常 * * 详细的步骤如下： * 1. 当遇到new指令时，会先检查这个指定的参数也就是LazyDoubleCheckSingleton能否在常量池中定位到该类的符号引用，并且检查这个符号引用代表的类是否已经执行过类的加载（加载、解析、准备和初始化），如果没有就执行下一步，如果执行了接着虚拟机为新生对象分配内存（此时从虚拟机的视角来说一个新对象已经产生了），紧接着执行new指令执行之后的调用&lt;init&gt;方法。 * 2. 加载 （1 通过类的全限定名获取定义此类的二进制字节流 2 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构即Class中的常量池进入方法区的运行时常量池中 3 在方法区生成一个代表这个类的Class对象） * 3. 验证 （确保Class文件的字节流中包含的信息符合当前虚拟机的要求，确保虚拟机自身安全） * 4. 准备 （在方法区中为类变量分配内存并设置类变量初始值） * 5. 解析 （可能会发生，因为它也可能发生在初始化阶段之后。 主要作用就是将常量池中的符号引用替换为直接引用） * 6. 初始化 （这是类加载过程的最后一步，主要就是执行类构造器&lt;clinit&gt;方法，初始化类变量） * * 最后：设置lazySingleton指向分配好的内存地址 */ lazySingleton = new LazyDoubleCheckSingleton(); &#125; &#125; &#125; return lazySingleton; &#125;&#125; 枚举式单例模式 12345678910111213141516171819202122232425262728293031323334353637383940package com.design.pattern.singleton.enuminstance;/** * EnumInstance 使用枚举的方式实现单例模式 * * 1. 枚举实际上是一个继承Enum的被final修饰的类，它的构造方法（只有有参构造方法）也是私有的。其中枚举常量也是static final的，并且在static代码块中实例化（和恶汉式很像） * 2. 枚举实现的单例防止了序列化攻击（readObject方法执行获取的对象是已经存在的枚举常量）和反射攻击（枚举类的构造函数会判断，如果通过反射调用就抛出异常）以及线程安全 * 3. 推荐使用枚举实现单例 * * @author shunhua * @date 2019-10-03 */public enum EnumInstance &#123; /** * 枚举常量 */ INSTANCE; /** * 枚举的成员变量 */ private Object data; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; /** * 暴露给外部的全局点 * * @return */ public static EnumInstance getInstance() &#123; return INSTANCE; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.design.pattern.singleton.enuminstance;import lombok.extern.slf4j.Slf4j;import java.io.*;import java.lang.reflect.Constructor;/** * EnumInstanceTest * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class EnumInstanceTest &#123; public static void main(String[] args) &#123; EnumInstance instance = EnumInstance.getInstance(); instance.setData(new Object()); try &#123; //------------------ 枚举实现的单例，是不受序列化破坏的影响---------------------/ File file = new File(\"singleton\"); // 使用ObjectOutputStream对象输出流，把单例对象写入文件中。注意文件的后缀名带不带都行。如果不指定文件的路径，就默认使用当前工程的目录作为路径 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file)); // 将单例对象写入文件中 objectOutputStream.writeObject(instance); // 使用ObjectInputStream对象输入流，把文件中的单例对象读到内存中 ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file)); EnumInstance newInstance = (EnumInstance) objectInputStream.readObject(); /** readObject方法调用的核心方法：这个逻辑保证了取出的枚举对象的唯一性 private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException &#123; if (bin.readByte() != TC_ENUM) &#123; throw new InternalError(); &#125; ObjectStreamClass desc = readClassDesc(false); if (!desc.isEnum()) &#123; throw new InvalidClassException(\"non-enum class: \" + desc); &#125; int enumHandle = handles.assign(unshared ? unsharedMarker : null); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) &#123; handles.markException(enumHandle, resolveEx); &#125; // 获取枚举对象的名称，这个是唯一的，它对应一个枚举常量 String name = readString(false); Enum&lt;?&gt; result = null; // 获取枚举对象的Class Class&lt;?&gt; cl = desc.forClass(); if (cl != null) &#123; try &#123; // 通过枚举对象的Class和枚举对象的名称获取对应的枚举常量，没有创建新的对象 @SuppressWarnings(\"unchecked\") Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name); result = en; &#125; catch (IllegalArgumentException ex) &#123; throw (IOException) new InvalidObjectException( \"enum constant \" + name + \" does not exist in \" + cl).initCause(ex); &#125; if (!unshared) &#123; handles.setObject(enumHandle, result); &#125; &#125; handles.finish(enumHandle); passHandle = enumHandle; return result; &#125; */ log.info(\"instance: \" + instance); log.info(\"newInstance: \" + newInstance); log.info(String.format(\"instance [%s] newInstance\", instance == newInstance)); System.out.println(\"------------------------------------------\"); log.info(\"instance: \" + instance.getData()); log.info(\"newInstance: \" + newInstance.getData()); log.info(String.format(\"instance.data [%s] newInstance.data\", instance.getData() == newInstance.getData())); //-------------------------- 枚举实现的单例,不受反射破坏的影响， ----------------/ Class enumClass = EnumInstance.class; Constructor constructor = enumClass.getDeclaredConstructor(); constructor.setAccessible(true); /** * 通过反射调用枚举的构造器（构造器只有有参构造）会抛出异常，防止了反射攻击 */ &#125; catch (Exception e) &#123; log.info(e.getMessage()); &#125; &#125;&#125; 容器单例模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.design.pattern.singleton.containersingleton;import org.apache.commons.lang3.StringUtils;import org.springframework.util.ObjectUtils;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * ContainerSingleton 容器单例模式 * * 统一管理多个实例，节省资源 * * @author shunhua * @date 2019-10-03 */public class ContainerSingleton &#123; /** * 存放对象，相当于一个缓存 */ private static Map&lt;String,Object&gt; SINGLETON_MAP = new ConcurrentHashMap&lt;&gt;(); /** * 多线程情况下不安全，可能导致值的覆盖 * @param key * @param instance */ public static void putInstance(String key,Object instance)&#123; if(StringUtils.isNotBlank(key) &amp;&amp; !ObjectUtils.isEmpty(instance))&#123; if(!SINGLETON_MAP.containsKey(key))&#123; SINGLETON_MAP.put(key,instance); &#125; &#125; &#125; /** * 获取对象 * @param key * @return */ public static Object getInstance(String key)&#123; return SINGLETON_MAP.get(key); &#125;&#125; 饿汉式单例模式 1234567891011121314151617181920212223242526272829303132333435363738394041package com.design.pattern.singleton.hungry;/** * HungrySingleton 饿汉式 * &lt;p&gt; * 1 优点 * 写法简单，类加载（严格来说是类加载过程的初始化阶段以及调用构造函数）的时候就完成了对象的创建，避免了线程同步问题 * 2 缺点 * 类加载的时候就完成了对象的创建，没有延迟效果，如果类的对象从始至终都没有用过，或者只是想获取类的某个类变量，那么还是会创建对象，这无疑造成了内存的浪费 * * * @author shunhua * @date 2019-10-03 */public class HungrySingleton &#123; /** * 私有构造函数 */ private HungrySingleton() &#123; &#125; /** * 声明为final的变量必须在类加载完成时（准确的是类加载初始化的时候，singleton就需要被赋值即HungrySingleton对象的引用）就已经赋值 */ // private final static HungrySingleton singleton = new HungrySingleton(); private final static HungrySingleton singleton; static &#123; singleton = new HungrySingleton(); &#125; /** * 全局访问点 * @return */ public static HungrySingleton getInstance() &#123; return singleton; &#125;&#125; 破坏饿汉式单例-方式1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.design.pattern.singleton.reflectattackresolve;/** * HungrySingleton 饿汉式 * &lt;p&gt; * 1 优点 * 写法简单，类加载（严格来说是类加载过程的初始化阶段以及调用构造函数）的时候就完成了对象的创建，避免了线程同步问题 * 2 缺点 * 类加载的时候就完成了对象的创建，没有延迟效果，如果类的对象从始至终都没有用过，或者只是想获取类的某个类变量，那么还是会创建对象，这无疑造成了内存的浪费 * * * @author shunhua * @date 2019-10-03 */public class HungrySingleton &#123; // private final static HungrySingleton singleton = new HungrySingleton(); private final static HungrySingleton singleton; /** * 私有构造函数 */ private HungrySingleton() &#123; if(singleton == null)&#123; System.out.println(\"调用构造方法在赋值引用给singleton之前，这是指令重排序带来的可能\"); &#125;else &#123; System.out.println(\"调用构造方法在赋值引用给singleton之后，这是指令重排序带来的可能\"); &#125; &#125; /** * 声明为final的变量必须在类加载完成时（准确的是类加载初始化的时候，singleton就需要被赋值即HungrySingleton对象的引用）就已经赋值 */ static &#123; singleton = new HungrySingleton(); &#125; /** * 全局访问点 * @return */ public static HungrySingleton getInstance() &#123; return singleton; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.design.pattern.singleton.reflectattackresolve;import lombok.extern.slf4j.Slf4j;import java.lang.reflect.Constructor;/** * HungrySingletonTest * * 反射破坏单例模式不容易彻底阻止，没有特别好的方式。 * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class HungrySingletonTest &#123; /** * 对于在类加载的整个过程实例就能创建好的单例模式（恶汉式、静态内部类），为了防止反射攻击，可以在构造方法中进行判断，如果是通过反射创建对象就抛出异常 * * * @param args */ public static void main(String[] args) &#123; try &#123; // 获取hungrySingleton的Class对象 Class objectClass = HungrySingleton.class; // 通过全局访问点拿到单例对象 HungrySingleton instance = HungrySingleton.getInstance(); // 获取声明的构造器 Constructor constructor = objectClass.getDeclaredConstructor(); // 强制设置声明的构造器是可以访问的 constructor.setAccessible(true); // 通过构造器反射创建对象 HungrySingleton newInstance = (HungrySingleton) constructor.newInstance(); log.info(\"instance: \" + instance); log.info(\"newInstance： \" + newInstance); log.info(String.format(\"instance [%s] newInstance\",instance == newInstance)); &#125;catch (Exception e)&#123; log.info(e.getMessage()); &#125; &#125;&#125; 破坏饿汉式单例-方式2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.design.pattern.singleton.serializationdestroysingleton;import java.io.Serializable;/** * HungrySingleton 饿汉式 * &lt;p&gt; * 1 优点 * 写法简单，类加载（严格来说是类加载过程的初始化阶段以及调用构造函数）的时候就完成了对象的创建，避免了线程同步问题 * 2 缺点 * 类加载的时候就完成了对象的创建，没有延迟效果，如果类的对象从始至终都没有用过，或者只是想获取类的某个类变量，那么还是会创建对象，这无疑造成了内存的浪费 * 3 实现Serializable，为了实现序列化 * * @author shunhua * @date 2019-10-03 */public class HungrySingleton implements Serializable &#123; private static final long serialVersionUID = 1136799709809340054L; /** * 私有构造函数 */ private HungrySingleton() &#123; &#125; /** * 声明为final的变量必须在类加载完成时（准确的是类加载初始化的时候，singleton就需要被赋值即HungrySingleton对象的引用）就已经赋值 */ // private final static HungrySingleton singleton = new HungrySingleton(); private final static HungrySingleton singleton; static &#123; singleton = new HungrySingleton(); &#125; /** * 全局访问点 * @return */ public static HungrySingleton getInstance() &#123; return singleton; &#125; /** * 1. 对于使用序列化和反序列化产生新的实例的方式破坏了单例，可以在类中增加readResolve()方法来预防，readResolve（）方法返回单例对象即可 * 2. 这是反序列化机制决定的，在反序列化的时候会判断类如果实现了Serializable或者Externalizable接口又包含readResolve()方法的话，会直接 * 调用readResolve（）方法来获取实例。值得注意的是，readObject方法底层会先通过反射创建一个新的单例实例，然后再通过反射调用readResolve方 * 法获取单例对象。即虽然最后通过readResolve拿到的是已经创建好的对象，但本质上还是通过反射创建了一个新的对象，只是这个新的对象是用来调用readResolve方法 * 返回单例对象而已。 * * * @return */ public Object readResolve()&#123; return singleton; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.design.pattern.singleton.serializationdestroysingleton;import lombok.extern.slf4j.Slf4j;import java.io.*;/** * HungrySingletonTest * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class HungrySingletonTest &#123; public static void main(String[] args) &#123; HungrySingleton instance = HungrySingleton.getInstance(); try &#123; File file = new File(\"singleton\"); // 使用ObjectOutputStream对象输出流，把单例对象写入文件中。注意文件的后缀名带不带都行。如果不指定文件的路径，就默认使用当前工程的目录作为路径 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file)); // 将单例对象写入文件中 objectOutputStream.writeObject(instance); // 使用ObjectInputStream对象输入流，把文件中的单例对象读到内存中 ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file)); /** * * 如果HungrySingleton类实现了Serializable或者Externalizable接口，那么readObject方法底层会使用反射，调用ObjectStreamClass#newInstance方法创建一个新的单例对象, * 这个单例对象是为了调用它对应的类中的readResolve方法，如果没有实现那两个接口中的任何一个就会返回null。即接着会判断这个新创建的单例对象中有没有readResolve方法，如果 * 有就会通过反射调用这个readResolve方法，最终readObject方法返回的是readResolve方法返回的对象 * */ HungrySingleton newInstance = (HungrySingleton) objectInputStream.readObject(); log.info(\"instance: \" + instance); log.info(\"newInstance: \" + newInstance); log.info(String.format(\"instance [%s] newInstance\", instance == newInstance)); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 静态内部类的单例模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.design.pattern.singleton.staticinnerclass;/** * StaticInnerClassSingleton 静态内部类的单例模式 ，使用静态内部类也是做延迟初始化单例对象，来降低单例实例的开销即在需要的时候才进行初始化 * * @author shunhua * @date 2019-10-03 */public class StaticInnerClassSingleton &#123; /** * 私有构造器不能少，防止外部创建对象，让外部只能通过全局访问点拿到单例对象 */ private StaticInnerClassSingleton()&#123;&#125; /** * 1. 这个静态内部类要声明为私有的，因为创建对象在它里面，不能让外面访问它 * 2. 如果类没有初始化，需要类立即初始化的常见情况： * （1）new 一个对象 * （2）类中声明的静态方法被调用 * （3）类中声明的一个静态成员被赋值 * （4）类中声明的一个静态成员被使用，并且这个成员不是一个常量（被final修饰，已在编译期把结果放入常量池中的静态字段） * （5）对类进行反射调用 * （6）作为父类（包括接口），其子类被初始化了，那么父类需要先初始化 * （7）执行的主类（包含main方法的类） * * 3.使用静态内部类创建单例对象利用了类加载过程中的初始化阶段的特性： * 虚拟机会保证一个类的类构造器&lt;clinit&gt;方法在多线程环境中被正确地加类的对象初始化锁（这是JVM帮我们自动完成的）、同步，如果多个线程同时去初始化一个类， * 那么只会有一个线程去执行这个类的类构造器方法&lt;clinit&gt;，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;方法完毕。 * 因此，即使在多线程环境下执行 private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton()语句 * 也不需要关心指令重排序的情况，因为初始化阶段在对类变量赋值的时候只会有一个线程可以执行&lt;clinit&gt;方法，而单线程执行的情况下，指令是否重排序是没有影响的。 */ private static class InnerClass &#123; /** * 1. 初始化时，需要staticInnerClassSingleton赋值，即 new StaticInnerClassSingleton()会被执行。这些都是&lt;clinit&gt;方法执行的结果，而&lt;clinit&gt;方法在多线程环境下只会有一个线程执行，即使这个方法内部涉及重排序也关系。 * 2. 活跃线程初始化类（执行&lt;clinit&gt;方法）后,类已经初始化完成，不会再进行初始化，其他线程直接访问类成员即可 */ private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton(); &#125; /** * 全局访问点 * * 当执行getInstance方法时就去调用InnerClass内部类里面的staticInnerClassSingleton实例，此时InnerClass内部类会被加载到内存里，在类加载的时候就创建对象，和饿汉式一个道理，保证了只有一个实例， * 而且在调用getInstance方法时才进行单例的创建，又具有懒汉式的部分特性。 * @return */ public static StaticInnerClassSingleton getInstance() &#123; /** * 外部访问getInstance这个全局访问点时，会间接访问InnerClass的静态成员，这会导致静态内部类被初始化 */ return InnerClass.staticInnerClassSingleton; &#125;&#125; 单例模式在源码中的使用jdk-RunTime 12345678910111213141516171819202122232425262728293031package java.lang;import java.io.*;import java.util.StringTokenizer;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;/** * Every Java application has a single instance of class * &lt;code&gt;Runtime&lt;/code&gt; that allows the application to interface with * the environment in which the application is running. The current * runtime can be obtained from the &lt;code&gt;getRuntime&lt;/code&gt; method. * &lt;p&gt; * An application cannot create its own instance of this class. * * @author unascribed * @see java.lang.Runtime#getRuntime() * @since JDK1.0 */public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() &#123; return currentRuntime; &#125; private Runtime() &#123;&#125; // ... 省略其他方法&#125; Spring-AbstractFactoryBean 12345678910111213141516171819202122232425262728@Overridepublic final T getObject() throws Exception &#123; if (isSingleton()) &#123; return (this.initialized ? this.singletonInstance : getEarlySingletonInstance()); &#125; else &#123; return createInstance(); &#125;&#125;/** * Determine an 'early singleton' instance, exposed in case of a * circular reference. Not called in a non-circular scenario. */@SuppressWarnings(\"unchecked\")private T getEarlySingletonInstance() throws Exception &#123; Class&lt;?&gt;[] ifcs = getEarlySingletonInterfaces(); if (ifcs == null) &#123; throw new FactoryBeanNotInitializedException( getClass().getName() + \" does not support circular references\"); &#125; if (this.earlySingletonInstance == null) &#123; this.earlySingletonInstance = (T) Proxy.newProxyInstance( this.beanClassLoader, ifcs, new EarlySingletonInvocationHandler()); &#125; return this.earlySingletonInstance;&#125; MyBatis-ErrorContext 12345678910111213141516171819202122232425262728293031323334public class ErrorContext &#123; private static final String LINE_SEPARATOR = System.getProperty(\"line.separator\",\"\\n\"); // 基于ThreadLocal的单例模式，它不是整个应用全局唯一而是线程级别唯一，保证了每个线程各自的错误上下文 private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal&lt;&gt;(); private ErrorContext stored; private String resource; private String activity; private String object; private String message; private String sql; private Throwable cause; /** * 私有构造器 */ private ErrorContext() &#123; &#125; /** * 每个线程获取各自的对象 * @return */ public static ErrorContext instance() &#123; ErrorContext context = LOCAL.get(); if (context == null) &#123; context = new ErrorContext(); LOCAL.set(context); &#125; return context; &#125; // ... 等等&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"解释器模式","slug":"design_pattern/behaviour_type/解释器模式","date":"2019-10-01T16:00:00.000Z","updated":"2020-07-04T16:28:45.960Z","comments":true,"path":"posts/30cf0cd2/","link":"","permalink":"https://gentryhuang.com/posts/30cf0cd2/","excerpt":"","text":"定义给定一个语言，定义它的文法（语法）的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。即 为了解释一种语言（语言的语法），而为语言创建的解释器 类型行为型 适用场景1在处理日志的时候，由于多个服务产生的日志格式不一定统一，但是数据里面的要素是相同的，这种情况下我们就可以通过程序来解决该问题，而这个程序我们就可以理解为解释器，只不过可以解释不同日志格式。在实际项目中解释器模式使用的比较少，多使用开源包。 优点1语法由很多类表示，容易改变及扩展此“语言”（涉及的代码还不足以说明是种语言） 缺点1当语法规则数目太多时，增加了系统复杂度 简单需求自定义一套可以加法、乘法的语法，使用栈来表示，这和日常的加法和乘法是不一样的。然后定义加法和乘法解释器，解释对应的表达式然后拿到最终的结果。 解释器模式演练 解释器接口 123456789101112131415package com.design.pattern.interpreter;/** * Interpreter 解释接口 * * @author shunhua * @date 2019-10-02 */public interface Interpreter &#123; /** * 解释方法 * @return */ int interpret();&#125; 加法解释器 123456789101112131415161718192021222324252627282930313233343536373839package com.design.pattern.interpreter;/** * AddInterpreter 加法解释器 * * @author shunhua * @date 2019-10-02 */public class AddInterpreter implements Interpreter &#123; /** * 它们的方法返回值作为加数和被加数 */ private Interpreter firstExpression,secondeExpression; /** * 加法需要 加数和被加数 * @param firstExpression * @param secondeExpression */ public AddInterpreter(Interpreter firstExpression,Interpreter secondeExpression)&#123; this.firstExpression = firstExpression; this.secondeExpression = secondeExpression; &#125; /** * 返回两个表达式结果的和 * @return */ @Override public int interpret() &#123; return this.firstExpression.interpret() + this.secondeExpression.interpret(); &#125; @Override public String toString() &#123; return \"+\"; &#125;&#125; 乘法解释器 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.interpreter;/** * MultiInterpreter 乘法解释器 * * @author shunhua * @date 2019-10-02 */public class MultiInterpreter implements Interpreter &#123; /** * 它们的表达式结果作为乘数和被乘除数 */ private Interpreter firstExpression,secondExpression; /** * 乘法需要 乘数和被乘数 * @param firstExpression * @param secondExpression */ public MultiInterpreter(Interpreter firstExpression,Interpreter secondExpression)&#123; this.firstExpression = firstExpression; this.secondExpression = secondExpression; &#125; /** * 乘法解释器的解释方法 * @return */ @Override public int interpret() &#123; return this.firstExpression.interpret() * this.secondExpression.interpret(); &#125; @Override public String toString() &#123; return \"*\"; &#125;&#125; 表达式处理解释器 1234567891011121314151617181920212223242526272829303132333435363738394041// 注意这个解释器就是简单转换数据的package com.design.pattern.interpreter;/** * NumberInterpreter 表达式处理解释器 * * @author shunhua * @date 2019-10-02 */public class NumberInterpreter implements Interpreter &#123; /** * 表达式要返回的值 */ private int number; /** * 数值构造器 * @param number */ public NumberInterpreter(int number)&#123; this.number = number; &#125; /** * 字符串转换构造器 * @param number */ public NumberInterpreter(String number)&#123; this.number = Integer.parseInt(number); &#125; /** * 解释方法 * @return */ @Override public int interpret() &#123; return this.number; &#125;&#125; 封装解释器的处理类–暴露给用户的解释器（它内部是对几个解释器的封装） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.design.pattern.interpreter;import lombok.extern.slf4j.Slf4j;import java.util.Arrays;import java.util.Stack;/** * ExpressionParse * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class ExpressionParse &#123; /** * 定义一个栈，这里是解释器类型栈 */ private Stack&lt;Interpreter&gt; stack = new Stack&lt;&gt;(); public int parse(String str)&#123; String[] strItemArray = str.split(\" \"); Arrays.stream(strItemArray).forEach(symbol -&gt;&#123; // 不是运算符，需要入栈 if(!OperatorUtil.isOperator(symbol))&#123; Interpreter numberExpression = new NumberInterpreter(symbol); stack.push(numberExpression); log.info(String.format(\"入栈：%d\",numberExpression.interpret())); &#125;else &#123; // 是运算符，可以进行计算 Interpreter firstExpression = stack.pop(); Interpreter secondExpression = stack.pop(); log.info(String.format(\"出栈： %d 和 %d\",firstExpression.interpret(),secondExpression.interpret())); Interpreter operator = OperatorUtil.getExpressionObject(firstExpression,secondExpression,symbol); log.info(String.format(\"解释器类型：%s\",operator.toString())); int result = operator.interpret(); NumberInterpreter resultExpression = new NumberInterpreter(result); stack.push(resultExpression); log.info(String.format(\"阶段结果入栈： %d\",resultExpression.interpret())); &#125; &#125;); int result = stack.pop().interpret(); return result; &#125;&#125; 工具类 1234567891011121314151617181920212223242526272829303132333435package com.design.pattern.interpreter;/** * OperatorUtil * * @author shunhua * @date 2019-10-02 */public class OperatorUtil &#123; /** * 是否可操作 * @param symbol * @return */ public static boolean isOperator(String symbol)&#123; return \"+\".equals(symbol) || \"*\".equals(symbol); &#125; /** * 使用解释器进行解释，表达式的结果 * @param firstExpression * @param secondExpression * @param symbol * @return */ public static Interpreter getExpressionObject(Interpreter firstExpression,Interpreter secondExpression,String symbol)&#123; if(\"+\".equals(symbol))&#123; return new AddInterpreter(firstExpression,secondExpression); &#125; else if (\"*\".equals(symbol))&#123; return new MultiInterpreter(firstExpression,secondExpression); &#125; return null; &#125;&#125; 应用 12345678910111213141516171819202122232425package com.design.pattern.interpreter;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class Client &#123; @Test public void test()&#123; // 输入表达式 String inputStr = \"18 70 12 + *\"; // 对表达式进行解释 ExpressionParse expressionParse = new ExpressionParse(); int result = expressionParse.parse(inputStr); log.info(\"最终解释结果：\" + result); &#125;&#125; 解释器模式在源码中的使用java.util.regex.Pattern 1正则表达式就是一种语法，通过jdk中的正则解释器把它解释出来 123456789101112131415161718192021222324252627282930package com.design.pattern.interpreter;import lombok.extern.slf4j.Slf4j;import org.junit.Test;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * PatternTest * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class PatternTest &#123; @Test public void test()&#123; String str = \"china\"; String patternStr = \"\\\\s+\" + str + \"\\\\s+\"; // 正则解释器，解释正则表达式 Pattern pattern = Pattern.compile(patternStr); String content = \" china becames more and more beautiful! \"; Matcher matcher = pattern.matcher(content); if (matcher.find()) &#123; String content_new = matcher.replaceAll(\"China \"); log.info(String.format(\"old: %s, new: %s\",content,content_new)); &#125; &#125;&#125; Spring的EL解释器 1El表达式是一种语法，通过Spring的解释器去解释 12345678910111213141516171819202122232425262728293031package com.design.pattern.interpreter.resource;import lombok.extern.slf4j.Slf4j;import org.junit.Test;import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;/** * SpelParserTest * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class SpelParserTest &#123; /** * 使用Spring的语言解释器(ExpressionParser) 解释Spring的EL（解释语言）表达式 */ @Test public void test() &#123; // 创建Spring的语言解释器 ExpressionParser parser = new SpelExpressionParser(); // 使用解释解析Spring的El表达式 Expression expression = parser.parseExpression(\"2 * 100 * 10 + 19\"); // 取出结果 int result = (Integer) expression.getValue(); log.info(\"解释后的结果：\" + result); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"策略模式","slug":"design_pattern/behaviour_type/策略模式","date":"2019-09-27T16:00:00.000Z","updated":"2020-07-04T16:28:45.958Z","comments":true,"path":"posts/72e3b671/","link":"","permalink":"https://gentryhuang.com/posts/72e3b671/","excerpt":"","text":"定义定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户。即把不同的算法封装到不同的类里面，让它们之间可以相互替换， 应用层不会受到影响。 类型行为型 使用场景12341 系统有很多类，而他们的区别仅仅在于它们的行为不同 - 使用策略模式就可以动态地让一个对象在多个行为中选择一种行为，也就是说我们把这个对象不同的行为放到不同的类里面，而每一种行为对应着一种策略2 一个系统需要动态地在几种算法中选择一种 - 这里算法就是策略，策略里面封装的就是一系列逻辑以及计算方式 优点1234561 符合开闭原则 - 策略模式提供了对开闭原则的完美支持，我们可以在不修改原有系统的基础上选择具体的行为2 避免使用多重条件转移语句 - 大量的if...else, switch。 我们把具体的策略行为分离为一个一个的单独的类来替换if...else里面的逻辑，这样写也可以降低代码的耦合3 提高算法的保密性和安全性 - 在使用的时候我们只知道策略的功能，不需要知道具体的细节。在具体的策略类中封装了不同的行为和算法以及相关的数据结构，对于应用层来说，是不需要知道内部的细节的。比如使用Dubbo的服务提供者，不需要知道内部逻辑的细节。 缺点121 应用层必须知道所有的策略类，并自行决定使用哪一个策略类2 产生很多策略类 策略模式相关的设计模式策略模式和工厂模式 121 工厂模式是创建型的设计模式，策略模式是行为型的设计模式2 工厂模式接受指令，创建符合要求的对象。策略模式接受创建好的对象，从而实现不同的行为 策略模式和状态模式 121 使用策略模式的时候，应用层需要知道应该选择哪一种策略。在使用状态模式的时候，应用层是不需要关心具体的状态，这些状态会自动转换2 如果系统中某个类的对象存在多种状态，不同状态下行为又有差异，而且这些状态可以发生转换时可以使用状态模式。如果系统中某个类的某种行为存在多种实现方式，如促销是个行为，这种行为就有多种实现方式，这种情况下应该使用策略模式。 简单需求当当网在双十一或者618的时候会有很多的促销活动，促销是书籍的一个行为，这个促销行为有多种实现。 策略模式演练最基本的使用 策略父类型（这里是接口的方式） 12345678910111213package com.design.pattern.strategy.base;/** * PromotionStrategy 促销策略父类型 * @author shunhua * @date 2019-09-28 */public interface PromotionStrategy &#123; /** * 进行促销 */ void doPromotion();&#125; 具体策略实例 发现策略 123456789101112131415161718192021package com.design.pattern.strategy.base;import lombok.extern.slf4j.Slf4j;/** * FanXianPromotionStrategy 返现（支付金额达到一定数额进行返现到账号）策略 * * @author shunhua * @date 2019-09-28 */@Slf4jpublic class FanXianPromotionStrategy implements PromotionStrategy &#123; /** * 促销 */ @Override public void doPromotion() &#123; log.info(\"返现促销，返回的金额存放到账号的余额中\"); &#125;&#125; 立减优惠策略 123456789101112131415161718192021package com.design.pattern.strategy.base;import lombok.extern.slf4j.Slf4j;/** * LiJianPromotionStrategy 立减（下单立减一定的金额）策略 * * @author shunhua * @date 2019-09-28 */@Slf4jpublic class LiJianPromotionStrategy implements PromotionStrategy &#123; /** * 促销 */ @Override public void doPromotion() &#123; log.info(\"立减促销，书籍的价格直接减去立减活动设置的价格\"); &#125;&#125; 满减策略 123456789101112131415161718192021package com.design.pattern.strategy.base;import lombok.extern.slf4j.Slf4j;/** * ManJianPromotionStrategy 满减（当支付金额达到规定的最低数就进行优惠）策略 * * @author shunhua * @date 2019-09-28 */@Slf4jpublic class ManJianPromotionStrategy implements PromotionStrategy &#123; /** * 促销 */ @Override public void doPromotion() &#123; log.info(\"满减促销，满200减50\"); &#125;&#125; 策略包装类 1234567891011121314151617181920212223242526package com.design.pattern.strategy.base;/** * PromotionActivity 促销活动，包装（使用）策略模式 * * @author shunhua * @date 2019-09-28 */public class PromotionActivity &#123; /** * 促销策略 */ private PromotionStrategy promotionStrategy; public PromotionActivity(PromotionStrategy promotionStrategy)&#123; this.promotionStrategy = promotionStrategy; &#125; /** * 执行具体的促销策略 */ public void execute()&#123; promotionStrategy.doPromotion(); &#125;&#125; 应用层 12345678910111213141516171819202122232425262728293031package com.design.pattern.strategy.base;import com.design.pattern.strategy.base.FanXianPromotionStrategy;import com.design.pattern.strategy.base.ManJianPromotionStrategy;import com.design.pattern.strategy.base.PromotionActivity;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-28 */public class Client &#123; @Test public void test()&#123; /** * 618满减活动策略 */ PromotionActivity activity618 = new PromotionActivity(new ManJianPromotionStrategy()); /** * 双11 返现活动策略 */ PromotionActivity activity11 = new PromotionActivity(new FanXianPromotionStrategy()); activity618.execute(); activity11.execute(); &#125;&#125; 小结 1这是策略模式的简单使用，整体上扩展性比较好，想增加策略很方便。 基本使用演进应用层 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.strategy.v1;import org.junit.Test;import org.springframework.util.ObjectUtils;/** * Client * * @author shunhua * @date 2019-09-28 */public class Client &#123; @Test public void test()&#123; PromotionActivity activity ; // 应用层参数 String promotion = \"FANXIAN\"; switch (promotion)&#123; case \"FANXIAN\" : activity = new PromotionActivity(new FanXianPromotionStrategy()); break; case \"LIJIAN\": activity = new PromotionActivity(new LiJianPromotionStrategy()); break; case \"MANJIAN\": activity = new PromotionActivity(new ManJianPromotionStrategy()); break; default: activity = null; &#125; if(!ObjectUtils.isEmpty(activity))&#123; activity.execute(); &#125; &#125;&#125; 小结 12这种方式和应用交互容易使代码过于臃肿，因为每次需要的时候都会创建策略对象和包装策略的对象，并且过多的选择判断，整个代码看起来不优雅。 优化后版本策略工厂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.design.pattern.strategy.v2;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * PromotionStrategyFactory 促销策略工厂 * * @author shunhua * @date 2019-09-28 */public class PromotionStrategyFactory &#123; /** * 策略集合 */ private final static Map&lt;String,PromotionStrategy&gt; PROMOTION_STRATEGY_MAP = new ConcurrentHashMap&lt;&gt;(); /** * 类加载的时候就开始创建对象 */ static &#123; PROMOTION_STRATEGY_MAP.put(PromotionKey.LIJIAN_STRATEGY,new LiJianPromotionStrategy()); PROMOTION_STRATEGY_MAP.put(PromotionKey.FANXIAN_STRATEGY,new FanXianPromotionStrategy()); PROMOTION_STRATEGY_MAP.put(PromotionKey.MANJIAN_STRATEGY,new ManJianPromotionStrategy()); &#125; /** * 单例的 */ private PromotionStrategyFactory()&#123;&#125; /** * 根据策略模式名获取对应的策略 * @param strategy * @return */ public static PromotionStrategy getPromotionStrategy(String strategy)&#123; return PROMOTION_STRATEGY_MAP.get(strategy); &#125; private interface PromotionKey&#123; /** * 立减策略 */ String LIJIAN_STRATEGY = \"LIJIAN\"; /** * 满减策略 */ String MANJIAN_STRATEGY = \"LIJIAN\"; /** * 返现策略 */ String FANXIAN_STRATEGY = \"FANXIAN\"; &#125;&#125; 应用层 123456789101112131415161718192021222324package com.design.pattern.strategy.v2;import org.junit.Test;import org.springframework.util.ObjectUtils;/** * Client * * @author shunhua * @date 2019-09-28 */public class Client &#123; @Test public void test()&#123; // 应用层参数 String promotion = \"FANXIAN\"; // 使用工厂模式 PromotionActivity activity = new PromotionActivity(PromotionStrategyFactory.getPromotionStrategy(promotion)); if(!ObjectUtils.isEmpty(activity))&#123; activity.execute(); &#125; &#125;&#125; 小结 121. 使用策略工厂防止策略对象频繁创建2. 策略模式常常结合单例、工厂以及享元模式等使用 策略模式源码解析jdk的Comparator 1Comparator就是一个比较策略接口，它有很多的实现，也支持自定义策略，这些策略实现就是一个个策略。 12345678910111213141516171819 /** * 排序会根据具体的排序策略执行 * @since 1.8 */@SuppressWarnings(\"unchecked\")public static &lt;T&gt; void parallelSort(T[] a, Comparator&lt;? super T&gt; cmp) &#123; if (cmp == null) cmp = NaturalOrder.INSTANCE; int n = a.length, p, g; if (n &lt;= MIN_ARRAY_SORT_GRAN || (p = ForkJoinPool.getCommonPoolParallelism()) == 1) TimSort.sort(a, 0, n, cmp, null, 0, 0); else new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt; (null, a, (T[])Array.newInstance(a.getClass().getComponentType(), n), 0, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ? MIN_ARRAY_SORT_GRAN : g, cmp).invoke(); &#125; Spring的Resource 1Resource是资源访问接口，它就是一个资源访问相关的策略接口，它有很多的实现类，也就意味着有很多访问资源的策略。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.springframework.core.io;import java.io.File;import java.io.IOException;import java.net.URI;import java.net.URL;import java.nio.channels.Channels;import java.nio.channels.ReadableByteChannel;import org.springframework.lang.Nullable;public interface Resource extends InputStreamSource &#123; boolean exists(); default boolean isReadable() &#123; return this.exists(); &#125; default boolean isOpen() &#123; return false; &#125; default boolean isFile() &#123; return false; &#125; URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; default ReadableByteChannel readableChannel() throws IOException &#123; return Channels.newChannel(this.getInputStream()); &#125; long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String var1) throws IOException; @Nullable String getFilename(); String getDescription();&#125; Spring的InstantiationStrategy 1Spring初始化策略接口，它的实现类：SimpleInstantiationStrategy和CglibSubclassingInstantiationStrategy初始化策略","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"模版方法模式","slug":"design_pattern/behaviour_type/模版方法模式","date":"2019-09-26T16:00:00.000Z","updated":"2020-07-04T16:28:45.955Z","comments":true,"path":"posts/5029c2a3/","link":"","permalink":"https://gentryhuang.com/posts/5029c2a3/","excerpt":"","text":"定义定义了一个算法的骨架，并允许子类为一个或多个步骤提供实现。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。 类型行为型 使用场景12◆ 各子类中公共的行为被提取出来并集中到一个公共父类中，从而避免代码重复◆ 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现 优点123◆提高复用性（将相同代码部分放到抽象父类中）◆提高扩展性◆符合开闭原则 缺点123◆继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍◆类数目增加◆增加了系统实现的复杂度 模版方法扩展 模版方法中有一个定义：钩子方法。它提供了缺省的行为，子类可以在必要时进行扩展，利用它和父类交互。即构造方法是这个模版对子类更进一步的开放以及扩展。 相关的设计模式模版方法模式和工厂方法模式 工厂方法是模版方法的一种特殊实现 模版方法模式和策略模式 模版方法模式不改变算法流程，策略模式可以改变算法流程，并且策略方法之间是可以相互替换的。策略模式的目的是使不同的算法可以相互替换，并且不影响应用层客户端的使用。模板方法模式是针对定义一个算法的流程，将一些不太一样的具体步骤交给子类去实现。 简单需求某机构要制作一门课程，制作这个课程需要一定的步骤，由于课程的种类不同可能某个步骤不同，但是整体步骤都是一致的。 模版方法演练 抽象课程类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.design.pattern.template;import lombok.extern.slf4j.Slf4j;/** * Course 课程抽象类 * * @author shunhua * @date 2019-09-27 */@Slf4jpublic abstract class Course &#123; /** * 模版方法 定义流程的 * 1 该方法的流程是固定的，有些步骤的细节可能因子类不同 * 2 该方法必须申明为final，子类不能重写。 */ protected final void makeCourse()&#123; // 制作PPT makePPT(); // 制作视频 makeVideo(); // 通过构造方法实现所需逻辑 if(needMakeArticle())&#123; // 编写手稿 makeArticle(); &#125; // 打包课程上线 packageCourse(); &#125; /** * 制作PPT是共有的方法，因此是固定的，子类不需要有自己的实现 */ final void makePPT()&#123; log.info(\"制作ppt\"); &#125; /** * 制作视频是共有的方法，因此是固定的，子类不需要有自己的实现 */ final void makeVideo()&#123; log.info(\"制作视频\"); &#125; /** * 编写手记，这个是固定的不需要之类有自己的实现，不过它不一定是共有的，需要看情况 */ final void makeArticle()&#123; log.info(\"编写手记\"); &#125; /** * 钩子方法 子类可以重写用来跟父类交互的。默认是false，不需要手记 */ protected boolean needMakeArticle()&#123; return false; &#125; /** * 打包课程的方法，不同的课程可能包装的不一样，根据子类情况重写 */ abstract void packageCourse();&#125; 课程类1 123456789101112131415161718192021package com.design.pattern.template;import lombok.extern.slf4j.Slf4j;/** * FECourse * * @author shunhua * @date 2019-09-27 */@Slf4jpublic class FECourse extends Course &#123; /** * 重写打包课程的方法 */ @Override void packageCourse() &#123; log.info(\"提供前端课程的源代码和图片素材\"); &#125;&#125; 课程类2 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.template;import lombok.extern.slf4j.Slf4j;/** * JvmCource * * @author shunhua * @date 2019-09-27 */@Slf4jpublic class JvmCource extends Course &#123; private boolean flag = Boolean.FALSE; /** * 通过构造方法设置钩子方法的参数，把钩子方法开放给客户端更加灵活 * * @param flag */ public JvmCource(boolean flag)&#123; this.flag = flag; &#125; @Override void packageCourse() &#123; log.info(\"Jvm课程提供调优工具软件包\"); &#125; /** * 使用钩子方法来和父类交互，增加自己的逻辑 * @return */ @Override protected boolean needMakeArticle() &#123; return flag; &#125;&#125; 客户端 1234567891011121314151617181920212223package com.design.pattern.template;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-27 */public class Client &#123; @Test public void test()&#123; Course jvmCourse = new JvmCource(Boolean.TRUE); jvmCourse.makeCourse(); Course feCourse = new FECourse(); feCourse.makeCourse(); &#125;&#125; 模版方法模式源码解析AbstractList(父)-ArrayList(子)AbstractList 1234567public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;//get方法为抽象方法，完全交给子类去实现abstract public E get(int index);&#125; ArrayList 12345678910public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;//子类来实现get方法 public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125;&#125; 同理：AbstractSet、AbstractMap同样采用了模版方法模式 HttpServlet1我们一般继承HttpServlet，然后重写doGet或者doPost等doXxx方法，HttpServlet中定义了一套模版，只要覆写这些方法即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod();if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn't support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125;&#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp);&#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(\"http.method_not_implemented\"); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);&#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"迭代器模式","slug":"design_pattern/behaviour_type/迭代器模式","date":"2019-09-26T16:00:00.000Z","updated":"2020-07-04T16:28:45.964Z","comments":true,"path":"posts/9055d217/","link":"","permalink":"https://gentryhuang.com/posts/9055d217/","excerpt":"","text":"定义提供一种方法，顺序访问一个集合对象中的各个元素，而又不暴露该对象的内部细节。 类型行为型 适用场景121 访问一个集合对象的内容而无需暴露它的内部表示2 为遍历不同的集合结构提供一个统一的接口 优点1分离了集合对象的遍历行为，因为抽象出了迭代器来遍历对象，这样就可以通过迭代器来访问集合对象内部元素了。 缺点1类的个数成对增加，由于迭代器模式是将存储数据和遍历数据这个两个职责进行分离，所以当新出现一种集合类就需要增加一种新的对应的迭代器。这样类的个数增加，这在一定程度上增加了系统的复杂性。 迭代器相关的设计模式迭代器模式和访问者模式 121 这两者都是迭代地访问集合对象中的各个元素2 访问者模式中扩展开放的部分在作用于对象的操作上，而在迭代器模式中扩展开放的部分是在集合对象的种类上 说明迭代器模式在日常开发中一般不会自己写，除非我们定义自己的数据结构，然后为这个数据结构实现对应的迭代器。 简单需求课程的增加和删除以及迭代该课程集 迭代器模式演练 实体类 1234567891011121314151617181920package com.design.pattern.iterator.v2;import lombok.AllArgsConstructor;import lombok.Data;/** * Course 相当于集合中的元素 * * @author shunhua * @date 2019-09-27 */@Data@AllArgsConstructorpublic class Course &#123; /** * 课程的名字 */ private String name;&#125; 集合类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.design.pattern.iterator.v2;import java.util.ArrayList;import java.util.List;/** * MyCollection * * @author shunhua * @date 2019-09-27 */public class MyCollection&lt;T&gt; &#123; /** * 元素集合 */ private final List&lt;T&gt; list = new ArrayList&lt;&gt;(); /** * 增加元素 * @param item */ public void add(T item)&#123; list.add(item); &#125; /** * 移出元素 */ public void remove(T item)&#123; this.list.remove(item); &#125; /** * 删除所有元素 */ public void removeAll()&#123; this.list.removeAll(list); &#125; /** * 获取迭代器，注意需要把实体对象列表传给迭代器 * @return */ public MyIterator iterator()&#123; return new MyIterator(list); &#125;&#125; 迭代器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.design.pattern.iterator.v2;import java.util.List;/** * MyIterator * * @author shunhua * @date 2019-09-27 */public class MyIterator&lt;T&gt; &#123; /** * 集合 */ private List&lt;T&gt; list ; /** * 游标 */ private int position; /** * 集合中的元素 */ private T item; public MyIterator(List&lt;T&gt; list)&#123; this.list = list; &#125; /** * 是否有下一个元素 * @return */ public boolean hasNext()&#123; if( this.position &lt; list.size())&#123; return true; &#125; return false; &#125; /** * 迭代元素 * @return */ public T next()&#123; T item = list.get(position); position ++; return item; &#125;&#125; 应用层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.design.pattern.iterator.v2;import com.design.pattern.iterator.v1.Course;import com.design.pattern.iterator.v1.CourseHandler;import com.design.pattern.iterator.v1.CourseHandlerImpl;import com.design.pattern.iterator.v1.CourseIterator;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-27 */@Slf4jpublic class Client &#123; @Test public void test() &#123; Course course1 = new Course(\"Java从入门到放弃\"); Course course2 = new Course(\"MySql从删库到跑路\"); Course course3 = new Course(\"Python从入门到精通\"); MyCollection&lt;Course&gt; collection = new MyCollection(); collection.add(course1); collection.add(course2); collection.add(course3); log.info(\"----------课程列表-------------\"); printCourses(collection); collection.remove(course1); log.info(\"----------删除操作之后的课程---- \"); printCourses(collection); &#125; private void printCourses(MyCollection collection) &#123; MyIterator iterator = collection.iterator(); while (iterator.hasNext()) &#123; Course course = (Course) iterator.next(); log.info(course.toString()); &#125; &#125;&#125; 迭代器模式源码解析ArrayList的迭代器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** ArrayList的内部类实现了Iterator * An optimized version of AbstractList.Itr */private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"组合模式","slug":"design_pattern/structure_type/组合模式","date":"2019-09-23T16:00:00.000Z","updated":"2020-07-04T16:28:45.971Z","comments":true,"path":"posts/df879792/","link":"","permalink":"https://gentryhuang.com/posts/df879792/","excerpt":"","text":"定义将对象组合成树形结构以表示“部分-整体”的层次结构。作用是使客户端对单个对象和组合对象保持一致的方式处理。组合模式就是将多个对象组合成一个对象（这些对象具有相同的类型，使用它们的父类型作为统一的对象供客户端访问），简化了对多个对象的访问 类型结构型 使用场景121. 希望客户端可以忽略组合对象与单个对象的差异时2. 处理一个树形结构时 优点1234◆清楚地定义了分层次的复杂对象，表示对象的全部或部分层次◆让客户端忽略了层次的差异，方便对整个层次结构进行控制◆简化客户端代码◆符合开闭原则 缺点121. 限制类型时会较为复杂，因为它们都具有相同的父类型2. 使设计变得更加抽象 相关的设计模式组合模式和访问者模式 可以用访问模式访问组合模式的递归结构 简单需求课程分为不同的类型，每一种类型对应一个课程目录，课程目录下又有很多的课程，要求打印出课程的结构 组合模式的演练 1我们可以通过行为方法进行识别组合模式，组合模式是将相同的抽象类类型或者接口类型转为相同的树状结构，使用抽象作为访问的入口。叶子对象（单个对象）和组合好的对象（包含叶子对象的集合）都要继承或实现相同的父类，这样组合模式才能将它们进行统一处理。 统一抽象类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.design.pattern.composite;/** * 1. 方法中的抛出异常处理，是体现方法不能被使用，因为课程和课程目录使用的方法不同 * 2. 课程和课程目录使用统一类型供客户端访问 * @author shunhua * @date 2019-09-24 */public abstract class CourseComponet &#123; /** * 扩展课程目录 * @param courseComponet */ public void addCatalog(CourseComponet courseComponet)&#123; throw new UnsupportedOperationException(\"不支持添加课程目录操作\"); &#125; /** * 删除课程目录 * @param courseComponet */ public void removeCatalog(CourseComponet courseComponet)&#123; throw new UnsupportedOperationException(\"不支持删除课程目录操作\"); &#125; /** * 获取课程名称 * @param courseComponet * @return */ public String getName(CourseComponet courseComponet)&#123; throw new UnsupportedOperationException(\"不支持获取课程名称操作\"); &#125; /** * 获取课程价格 * @param courseComponet * @return */ public double getPrice(CourseComponet courseComponet)&#123; throw new UnsupportedOperationException(\"不支持获取课程价格操作\"); &#125; /** * 打印信息 */ public void print()&#123; throw new UnsupportedOperationException(\"不支持打印操作\"); &#125;&#125; 课程类 1234567891011121314151617181920212223242526272829303132333435363738394041package com.design.pattern.composite;import lombok.extern.slf4j.Slf4j;&#x2F;** * Course 课程类 * * @author shunhua * @date 2019-09-24 *&#x2F;@Slf4jpublic class Course extends CourseComponet &#123; &#x2F;** * 课程名 *&#x2F; private String courseName; &#x2F;** * 课程价格 *&#x2F; private double price; public Course(String courseName, double price) &#123; this.courseName &#x3D; courseName; this.price &#x3D; price; &#125; @Override public String getName(CourseComponet courseComponet) &#123; return this.courseName; &#125; @Override public double getPrice(CourseComponet courseComponet) &#123; return this.price; &#125; @Override public void print() &#123; log.info(&quot;课程名：&quot; + courseName + &quot;, 课程价格：&quot; + price); &#125;&#125; 课程目录类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.design.pattern.composite;import lombok.extern.slf4j.Slf4j;import java.util.ArrayList;import java.util.List;/** * CourseCatalog 课程目录类 * * @author shunhua * @date 2019-09-24 */@Slf4jpublic class CourseCatalog extends CourseComponet &#123; /** * 课程目录下的课程集合 ，这里使用统一抽象类型表示，这里就组合了课程对象 */ private List&lt;CourseComponet&gt; items = new ArrayList&lt;&gt;(); /** * 课程目录名 */ private String catalogName; public CourseCatalog(String catalogName)&#123; this.catalogName = catalogName; &#125; /** * 为课程目录添加课程 * @param courseComponet */ @Override public void addCatalog(CourseComponet courseComponet) &#123; this.items.add(courseComponet); &#125; /** * 删除课程目录中的课程 * @param courseComponet */ @Override public void removeCatalog(CourseComponet courseComponet) &#123; this.items.remove(courseComponet); &#125; @Override public String getName(CourseComponet courseComponet) &#123; return this.catalogName; &#125; /** * 打印目录以及目录下的课程 */ @Override public void print() &#123; log.info(catalogName); for(CourseComponet courseComponet : items)&#123; courseComponet.print(); &#125; &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930313233package com.design.pattern.composite;import org.junit.Test;&#x2F;** * Client 课程目录和课程，对客户端来说都是一个类型的对象 * * @author shunhua * @date 2019-09-24 *&#x2F;public class Client &#123; @Test public void test()&#123; CourseComponet catalog &#x3D; new CourseCatalog(&quot;课程顶级目录&quot;); CourseComponet linuxCourse &#x3D; new Course(&quot;鸟哥私房菜&quot;,80); CourseComponet gitCourse &#x3D; new Course(&quot;Git权威指南&quot;,120); CourseComponet javaCatalog &#x3D; new CourseCatalog(&quot;Java课程目录&quot;); CourseComponet spring &#x3D; new Course(&quot;Spring实战&quot;,70); CourseComponet mybatis &#x3D; new Course(&quot;MyBatis技术内幕&quot;,60); javaCatalog.addCatalog(spring); javaCatalog.addCatalog(mybatis); catalog.addCatalog(linuxCourse); catalog.addCatalog(gitCourse); catalog.addCatalog(javaCatalog); &#x2F;&#x2F; 打印课程目录以及目录下的课程列表 catalog.print(); &#125;&#125; 组合模式源码解析jdk源码之HashMap 1234567891011121314151617181920212223242526272829303132public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; /** * 方法的入参是Map类型，使用Map类型作为统一的接收参数，不需要关注任何之类型的对象 */ public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; if (table == EMPTY_TABLE) &#123; inflateTable((int) Math.max(numKeysToBeAdded * loadFactor, threshold)); &#125; if (numKeysToBeAdded &gt; threshold) &#123; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); &#125; for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue()); &#125;&#125; jdk源码之ArrayList 1234567891011/** * 方法的入参使用统一的父类型Collection，客户端不需要关注具体的子类型对象 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; MyBatis源码之SqlNode 12MyBatis的sql语句会被解析成不同的SqlNode类型的对象，这些对象都实现了SqlNode。其中MixedSqlNode是联系不同的SqlNode的一个核心对象，组合模式可以统一处理的它们。 12345678910111213141516171819202122package org.apache.ibatis.scripting.xmltags;import java.util.List;public class MixedSqlNode implements SqlNode &#123; /** * SqlNode不同实现的集合 */ private final List&lt;SqlNode&gt; contents; public MixedSqlNode(List&lt;SqlNode&gt; contents) &#123; this.contents = contents; &#125; @Override public boolean apply(DynamicContext context) &#123; for (SqlNode sqlNode : contents) &#123; sqlNode.apply(context); &#125; return true; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"享元模式","slug":"design_pattern/structure_type/享元模式","date":"2019-09-22T16:00:00.000Z","updated":"2020-07-04T16:28:45.970Z","comments":true,"path":"posts/e19da94a/","link":"","permalink":"https://gentryhuang.com/posts/e19da94a/","excerpt":"","text":"定义提供了减少对象数量从而改善应用的对象结构的方式。运用共享技术有效地支持大量细粒度的对象。即减少创建对象的数量，共享对象，从而减少内存的占用并且提高性能 。注意：享元模式重要的就是共享。 类型结构型 应用场景1234◆ 常常应用于系统底层的开发，以便解决系统的性能问题 如String类型就是使用了享元模式，String对象存在即返回，没有就创建然后放入到字符串常量池中。再比如数据库连接池，里面都是创建好的数据库连接，需要的时候拿来用不需要的时候归还回去。即系统中如果有大量的对象，可能会造成内存溢出，我们可以把共同的部分抽象出来，有相同的业务请求，则返回在内存中的已有对象，避免重新创建◆ 系统有大量相似对象、需要缓冲池的场景 某个对象的复用度越高，越倾向于使用享元模式 优点12◆减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率◆减少内存之外的其他资源占用(时间资源、文件句柄、窗口句柄等) 缺点1234◆关注内&#x2F;外部状态、关注线程安全问题 我们使用共享模式的时候，大都是使用hashMap，不会用HashTable（因为hashTable会由于同步锁造成效率过低，这样得不偿失），这样就需要在有些场景下关注线程安全问题。同时还要关注内、外部状态。◆使系统、程序的逻辑复杂化 使用了享元对象提高了系统的复杂度，还要分离内外不状态，并且外部状态不应该随着内部状态的变化而变化，否则系统就混乱了。 扩展内部状态 1在享元模式内部并且不会随着环境改变而改变的共享部分；无论外部环境如何变化，我都不变，并且该状态在享元模式内部。可理解为是享元对象的一个属性，这个属性不会与外部交互。 外部状态 1随着环境改变而改变的就是外部状态，这种状态是不可以共享的状态，并且记录在享元模式的外部。可理解为享元对象的一个可以和外界交互的属性，它会随时发生改变。 相关设计模式享元模式和代理模式 1代理模式是代理一个类，如果生成这个代理类花的资源和时间比较多，可以使用享元模式处理这个类的速度 享元模式和单例模式 1容器单例是两种方式的一种结合。享元模式是一种复用对象的思想 简单需求年终了，研发部门Leader可能需要多次地去汇报工作情况，已经有报告结果的就不需要再整理报告了，直接拿到报告就可以去汇报了。没有做过汇报的就需要先整理报告。 享元模式演练 报告 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.flyweight;import lombok.Data;import lombok.extern.slf4j.Slf4j;/** * Presentation 报告类 * * @author shunhua * @date 2019-09-23 */@Data@Slf4jpublic class Presentation &#123; /** * 报告相关部门 */ private String department; /** * 汇报内容 */ private String content; /** * 通过外部状态属性进行构造 * @param department */ public Presentation(String department)&#123; this.department = department; &#125; /** * 报告内容 */ public void report() &#123; log.info(content); &#125;&#125; 报告工厂 1234567891011121314151617181920212223242526272829303132333435363738394041package com.design.pattern.flyweight;import lombok.extern.slf4j.Slf4j;import org.springframework.util.ObjectUtils;import java.util.HashMap;import java.util.Map;/** * PresentationFactory 报告工厂 * * @author shunhua * @date 2019-09-23 */@Slf4jpublic class PresentationFactory &#123; /** * 此处应用了 final修饰 引用成员变量，引用对象的内容可以修改，但是引用地址不可以修改。这里作为报告池。 */ private static final Map&lt;String,Presentation&gt; PRESENTATION_MAP = new HashMap&lt;&gt;(16); /** * 这里不考虑安全问题 * @param department * @return */ public static Presentation getPresentation(String department)&#123; // 先从报告池中获取 Presentation leaderPresentation = PRESENTATION_MAP.get(department); // 报告池中没有再创建一个，然后放到报告池中 if(ObjectUtils.isEmpty(leaderPresentation))&#123; leaderPresentation = new Presentation(department); log.info(\"----------- 报告池中没有需先创建----------\"); PRESENTATION_MAP.put(department,leaderPresentation); leaderPresentation.setContent(\"部门：\" + department +\" 汇报...\"); leaderPresentation.report(); &#125; return leaderPresentation; &#125;&#125; 客户端 12345678910111213141516171819202122package com.design.pattern.flyweight;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-23 */public class Client &#123; private final String presentation[] = &#123;\"业务部\",\"研发部\",\"管理部\"&#125;; @Test public void test()&#123; for(int i = 0; i &lt; 20; i++)&#123; String department = presentation[(int)(Math.random() * presentation.length)]; Presentation leaderPresentation = PresentationFactory.getPresentation(department); leaderPresentation.report(); &#125; &#125;&#125; 享元模式源码解析Integer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public final class Integer extends Number implements Comparable&lt;Integer&gt; &#123; /** * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * 如果传入的数值在缓存的-127和128之间，那么都会在cache中，否则的话，会new出新的对象，这也是为什么100==100为true，1000==1000为false * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */ public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125;/** 只要在-128-127，使用 == 判断是可以的，不再这个范围就不能使用==,需要使用equqls * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * */ private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"桥接模式","slug":"design_pattern/structure_type/桥接模式","date":"2019-09-20T16:00:00.000Z","updated":"2020-07-04T16:28:45.966Z","comments":true,"path":"posts/563268dc/","link":"","permalink":"https://gentryhuang.com/posts/563268dc/","excerpt":"","text":"定义将抽象部分与它的具体实现部分分离开来，使它们都可以独立地变化（这在一定程度上实现解耦）。桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，防止类爆炸。从它的命名可以看出，bridge是桥梁的意思， 将桥两边联系起来。目的就是把两个不同的类之间建立联系，而两个类之间建立联系的方式有很多，而桥接模式是通过组合的方式建立两个不同类之间的关系，而不是继承。这也符合合成复用原则：优先通过组合的方式建立两个类之间联系，而不是继承，继承过多会发生类爆炸的情况。说明一点:这里说的抽象部分和具体实现部分，并不局限一个是抽象的，另一个是具体的实现，这只是从概念上去定义。 1将抽象部分与它的具体实现部分分离，其实这并不是将抽象类与他的派生类分离，而是抽象类和它的派生类用来实现自己的对象。或者说在一个系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化。 类型结构型 适用场景 抽象和具体实现之间增加更多的灵活性 1使用桥接模式就可以避免在这两个层次之间建立静态的继承关系，而是建立关联关系。此外，抽象部分和具体实现部分，它们都可以分别通过继承关系独立扩展，并且互不影响，就可以动态地将一个抽象化子类的对象和一个具体实现化子类的对象进行组合，这样就把抽象化角色和具体实现化角色实现了解耦。 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展 1抽象的部分可以独立扩展，具体实现也可以独立扩展 不希望使用继承，或因为多层继承导致系统类的个数剧增 优点 分离抽象部分及其具体实现部分 1因为桥接模式使用了组合，使用对象间的关联关系，来解耦了抽象和具体实现之间的固有绑定关系，使抽象和实现可以沿着各自的维度进行扩展、变化。也就是说，抽象和实现不在同一个继承层次结构中，从而通过组合来获得多维度的组合对象。 提高了系统的可扩展性 1在两个变化维度中，扩展任意一个维度都不需要修改原有的系统 符合开闭原则 符合合成复用原则 缺点 增加了系统的理解与设计难度 1由于类之间的关系建立在抽象层，要求我们在编码的时候，一开始就要针对抽象层进行设计和编程 需要正确地识别出系统中两个独立变化的维度 相关设计模式 组合模式 1组合模式更强调的是部分和整体间的组合，而桥接模式强调的是平行级别上不同类的组合 适配器模式 1适配器模式和桥接模式都是为了让两个东西配合工作，但它们两个的目的不一样，适配器模式是改变已有的接口，让它们之间可以相互配合，而桥接模式是分离抽象和具体实现。也就是说，适配器模式可以把功能上相似但是接口不同的类适配起来，而桥接模式是把类的抽象和类的具体实现分离开，然后在此基础上使这些层次结构结合起来。 关键一点桥接模式重要的就是把抽象和具体实现分离开，中间通过组合来搭建它们之间的桥梁 案例分析 场景 121）有两个银行，分别是ABC和ICBC银行，同时有两个账号，分别是定期账号和活期账号。2）使用桥接模式可以 让实现（这里就是账号具体实现）和抽象（这里就是抽象的银行类）分离，银行属性增加修改银行类即可，账号类属性增加修改账号类即可。逻辑清晰，同时也解决了上述类爆炸的情况。 编码 账号接口 Account 12345678910public interface Account &#123; /** * 开户 */ Account openAccount(); /** * 开户类型 */ void showAccountType();&#125; ​ 账号的两个实现类 SavingAccount和 DepositAccount 1234567891011121314151617181920212223242526public class SavingAccount implements Account &#123; @Override public Account openAccount() &#123; System.out.println(\"SavingAccount--开活期账号\"); return new SavingAccount(); &#125; @Override public void showAccountType() &#123; System.out.println(\"SavingAccount--这是一个活期账号\"); &#125;&#125;-----public class DepositAccount implements Account &#123; @Override public Account openAccount() &#123; System.out.println(\"DepositAccount--开定期账号\"); return new DepositAccount(); &#125; @Override public void showAccountType() &#123; System.out.println(\"DepositAccouont--这是一个定期账号\"); &#125;&#125; ​ 银行抽象类 Bank 123456789101112131415161718192021222324252627public abstract class Bank &#123; /** * 这里要写成一个抽象的，因为要把Account引入到Bank里面，通 * 过这种组合的方式，把Account的行为交给Bank的子类来实现，即 * Bank这个抽象类中的某个行为要委托给Account这个接口的实现， * 抽象和具体的实现分离指定的就是这种情况。 */ /** * 要交给子类，声明为protected，这样只有子类能够拿到 */ protected Account account; /** * 通过构造器把Account传过来，也可以通过setter注入的方式赋值 */ public Bank(Account account)&#123; this.account = account; &#125; /** * 这个方法要参照Account接口中的方法，因为Bank里面的具体方法要委托给Account里面 * 的openAccount方法，但这里面方法名不要求一定一致 */ abstract Account openAccount();&#125; ​ 银行抽象类的子类 ABCBank和ICBCBank 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ABCBank extends Bank &#123; /** * 构造的时候传入的是哪个Account就返回哪一个Account(openAccount方法) * @param account */ public ABCBank(Account account) &#123; super(account); &#125; /** * 这里返回的就是父类中的Account * @return */ @Override Account openAccount() &#123; System.out.println(\"ABCBank--开户中国农业银行账号\"); // 很重要，要使用父类里组合进来的Account，不然桥接模式就没什么意义了 account.openAccount(); return account; &#125;&#125;---public class ICBCBank extends Bank &#123; /** * 构造的时候传入的是哪个Account就返回哪一个Account(openAccount方法) * @param account */ public ICBCBank(Account account) &#123; super(account); &#125; /** * 这里返回的就是父类中的Account * @return */ @Override Account openAccount() &#123; System.out.println(\"ICBC--开户中国工商银行账号\"); // 很重要，要使用父类里组合进来的Account，不然桥接模式就没什么意义了 account.openAccount(); return account; &#125;&#125; 单元测试 TestDemo 1234567891011121314151617181920212223242526272829public class TestDemo &#123; public static void main(String[] args) &#123; // ICBCBank-DepositAccount Bank icbcBank = new ICBCBank(new DepositAccount()); Account icbcAccount = icbcBank.openAccount(); System.out.println(\"**************************\"); icbcAccount.showAccountType(); System.out.println(\"--------------------------\"); // ICBCBank-SavingAccount Bank icbcBank2 = new ICBCBank(new SavingAccount()); Account icbcAccount2 = icbcBank2.openAccount(); System.out.println(\"**************************\"); icbcAccount2.showAccountType(); System.out.println(\"--------------------------\"); // ABCBank-DepositAccount Bank abcBank2 = new ABCBank(new DepositAccount()); Account abcAccount2 = abcBank2.openAccount(); System.out.println(\"**************************\"); abcAccount2.showAccountType(); System.out.println(\"--------------------------\"); // ABCBank-SavingAccount Bank abcBank = new ABCBank(new SavingAccount()); Account abcAccount = abcBank.openAccount(); System.out.println(\"**************************\"); abcAccount.showAccountType(); &#125;&#125; 总结 通过桥接模式，把实现部分Account（Account的具体实现类）和抽象部分Bank（Bank抽象类）进行了桥接，使用组合作为一根线连接它们。当然也有聚合的方式实现桥接。 桥接模式在JDK源码中的应用实现部分1java.sql.Driver接口的实现： 如MySQL的Driver，Oracle的Driver Driver接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package java.sql;import java.util.logging.Logger;/** * The interface that every driver class must implement. * &lt;P&gt;The Java SQL framework allows for multiple database drivers. * * &lt;P&gt;Each driver should supply a class that implements * the Driver interface. * * &lt;P&gt;The DriverManager will try to load as many drivers as it can * find and then for any given connection request, it will ask each * driver in turn to try to connect to the target URL. * * &lt;P&gt;It is strongly recommended that each Driver class should be * small and standalone so that the Driver class can be loaded and * queried without bringing in vast quantities of supporting code. * * &lt;P&gt;When a Driver class is loaded, it should create an instance of * itself and register it with the DriverManager. This means that a * user can load and register a driver by calling: * &lt;p&gt; * &#123;@code Class.forName(\"foo.bah.Driver\")&#125; * &lt;p&gt; * A JDBC driver may create a &#123;@linkplain DriverAction&#125; implementation in order * to receive notifications when &#123;@linkplain DriverManager#deregisterDriver&#125; has * been called. * @see DriverManager * @see Connection * @see DriverAction */public interface Driver &#123; Connection connect(String url, java.util.Properties info) throws SQLException; boolean acceptsURL(String url) throws SQLException; DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info) throws SQLException; int getMajorVersion(); int getMinorVersion(); boolean jdbcCompliant(); public Logger getParentLogger() throws SQLFeatureNotSupportedException;&#125; Driver接口的MySql驱动实现 123456789101112131415161718192021222324252627282930313233343536373839404142package com.mysql.cj.jdbc;import java.sql.SQLException;/** * The Java SQL framework allows for multiple database drivers. Each driver should supply a class that implements the Driver interface * * &lt;p&gt; * The DriverManager will try to load as many drivers as it can find and then for any given connection request, it will ask each driver in turn to try to * connect to the target URL. * * &lt;p&gt; * It is strongly recommended that each Driver class should be small and standalone so that the Driver class can be loaded and queried without bringing in vast * quantities of supporting code. * * &lt;p&gt; * When a Driver class is loaded, it should create an instance of itself and register it with the DriverManager. This means that a user can load and register a * driver by doing Class.forName(\"foo.bah.Driver\") */public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; // // Register ourselves with the DriverManager // static &#123; try &#123; // 把驱动注册到DriverManager中 java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125; &#125; /** * Construct a new driver and register it with DriverManager * * @throws SQLException * if a database error occurs. */ public Driver() throws SQLException &#123; // Required for Class.forName().newInstance() &#125;&#125; 抽象部分1java.sql.DriverManager这个类作为抽象部分，它并不是抽象类。再次说明，抽象部分并不一定就是抽象类或接口，只是从桥接模式整体看，把它分为两大部分。registeredDrivers作为实现部分组合到抽象部分。 DriverInfo实现部分的父类型接口Driver只是作为DriverInfo的一个属性 123456789101112131415161718192021222324252627282930class DriverInfo &#123; final Driver driver; DriverAction da; DriverInfo(Driver driver, DriverAction action) &#123; this.driver = driver; da = action; &#125; @Override public boolean equals(Object other) &#123; return (other instanceof DriverInfo) &amp;&amp; this.driver == ((DriverInfo) other).driver; &#125; @Override public int hashCode() &#123; return driver.hashCode(); &#125; @Override public String toString() &#123; return (\"driver[className=\" + driver + \"]\"); &#125; DriverAction action() &#123; return da; &#125;&#125; DriverManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209 package java.sql; import java.util.Iterator; import java.util.ServiceLoader; import java.security.AccessController; import java.security.PrivilegedAction; import java.util.concurrent.CopyOnWriteArrayList; import sun.reflect.CallerSensitive; import sun.reflect.Reflection; /** * @see Driver * @see Connection */ public class DriverManager &#123; // 注册 JDBC driver 的列表 private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;(); private static volatile int loginTimeout = 0; private static volatile java.io.PrintWriter logWriter = null; private static volatile java.io.PrintStream logStream = null; // Used in println() to synchronize logWriter private final static Object logSync = new Object(); /* Prevent the DriverManager class from being instantiated. */ private DriverManager()&#123;&#125; /** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the &#123;@code ServiceLoader&#125; mechanism */ static &#123; loadInitialDrivers(); println(\"JDBC DriverManager initialized\"); &#125; /** * The &lt;code&gt;SQLPermission&lt;/code&gt; constant that allows the * setting of the logging stream. * @since 1.3 */ final static SQLPermission SET_LOG_PERMISSION = new SQLPermission(\"setLog\"); /** * The &#123;@code SQLPermission&#125; constant that allows the * un-register a registered JDBC driver. * @since 1.8 */ final static SQLPermission DEREGISTER_DRIVER_PERMISSION = new SQLPermission(\"deregisterDriver\"); //--------------------------JDBC 2.0----------------------------- /** * Retrieves the log writer. * * The &lt;code&gt;getLogWriter&lt;/code&gt; and &lt;code&gt;setLogWriter&lt;/code&gt; * methods should be used instead * of the &lt;code&gt;get/setlogStream&lt;/code&gt; methods, which are deprecated. * @return a &lt;code&gt;java.io.PrintWriter&lt;/code&gt; object * @see #setLogWriter * @since 1.2 */ public static java.io.PrintWriter getLogWriter() &#123; return logWriter; &#125; public static void setLogWriter(java.io.PrintWriter out) &#123; SecurityManager sec = System.getSecurityManager(); if (sec != null) &#123; sec.checkPermission(SET_LOG_PERMISSION); &#125; logStream = null; logWriter = out; &#125; @CallerSensitive public static Connection getConnection(String url, java.util.Properties info) throws SQLException &#123; return (getConnection(url, info, Reflection.getCallerClass())); &#125; @CallerSensitive public static Connection getConnection(String url, String user, String password) throws SQLException &#123; java.util.Properties info = new java.util.Properties(); if (user != null) &#123; info.put(\"user\", user); &#125; if (password != null) &#123; info.put(\"password\", password); &#125; return (getConnection(url, info, Reflection.getCallerClass())); &#125; @CallerSensitive public static Connection getConnection(String url) throws SQLException &#123; java.util.Properties info = new java.util.Properties(); return (getConnection(url, info, Reflection.getCallerClass())); &#125; /** * Attempts to locate a driver that understands the given URL. * The &lt;code&gt;DriverManager&lt;/code&gt; attempts to select an appropriate driver from * the set of registered JDBC drivers. * * @param url a database URL of the form * &lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt; * @return a &lt;code&gt;Driver&lt;/code&gt; object representing a driver * that can connect to the given URL * @exception SQLException if a database access error occurs */ @CallerSensitive public static Driver getDriver(String url) throws SQLException &#123; println(\"DriverManager.getDriver(\\\"\" + url + \"\\\")\"); Class&lt;?&gt; callerClass = Reflection.getCallerClass(); for (DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerClass)) &#123; try &#123; if(aDriver.driver.acceptsURL(url)) &#123; // Success! println(\"getDriver returning \" + aDriver.driver.getClass().getName()); return (aDriver.driver); &#125; &#125; catch(SQLException sqe) &#123; // Drop through and try the next driver. &#125; &#125; else &#123; println(\" skipping: \" + aDriver.driver.getClass().getName()); &#125; &#125; println(\"getDriver: no suitable driver\"); throw new SQLException(\"No suitable driver\", \"08001\"); &#125; /** * Registers the given driver with the &#123;@code DriverManager&#125;. * A newly-loaded driver class should call * the method &#123;@code registerDriver&#125; to make itself * known to the &#123;@code DriverManager&#125;. If the driver is currently * registered, no action is taken. * * @param driver the new JDBC Driver that is to be registered with the * &#123;@code DriverManager&#125; * @exception SQLException if a database access error occurs * @exception NullPointerException if &#123;@code driver&#125; is null */ public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException &#123; registerDriver(driver, null); &#125; /** * Registers the given driver with the &#123;@code DriverManager&#125;. * A newly-loaded driver class should call * the method &#123;@code registerDriver&#125; to make itself * known to the &#123;@code DriverManager&#125;. If the driver is currently * registered, no action is taken. * * @param driver the new JDBC Driver that is to be registered with the * &#123;@code DriverManager&#125; * @param da the &#123;@code DriverAction&#125; implementation to be used when * &#123;@code DriverManager#deregisterDriver&#125; is called * @exception SQLException if a database access error occurs * @exception NullPointerException if &#123;@code driver&#125; is null * @since 1.8 */ public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException &#123; /* Register the driver if it has not already been added to our list */ if(driver != null) &#123; registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); &#125; else &#123; // This is for compatibility with the original DriverManager throw new NullPointerException(); &#125; println(\"registerDriver: \" + driver); &#125;&#125; ​ ​ ​ ​ ​","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"适配器模式","slug":"design_pattern/structure_type/适配器模式","date":"2019-09-20T16:00:00.000Z","updated":"2020-07-04T16:28:45.972Z","comments":true,"path":"posts/f5c535ea/","link":"","permalink":"https://gentryhuang.com/posts/f5c535ea/","excerpt":"","text":"定义将一个类（被适配者）转换成客户期望的另一个接口（目标），使原本接口不兼容的类（它们的接口不同）可以一起工作（使用同一接口了）。 类型结构型 应用场景12◆已经存在的类，它的方法和需求不匹配时◆不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案，是软件维护阶段需要考虑的事情 优点123◆能提高类的透明性和复用，现有的类复用但不需要改变，解决了现有类和目标类不匹配的问题◆目标类和适配器类解耦，提高程序扩展性◆符合开闭原则，具体的操作都在适配者中，客户端只知道适配者，扩展只需对适配者扩展即可 缺点12◆适配器编写过程需要全面考虑，可能会增加系统的复杂性◆增加系统代码可读的难度，如我们调用的是A接口实现，其实内部已经被适配成了B接口的实现 扩展12◆对象适配器（符合组合复用原则，并且使用委托机制）◆类适配器（通过类继承实现） 相关的设计模式适配器模式和外观模式 123a 都是现有类现存系统的封装，前者复用原有的接口，后者定义了新的接口b 前者使原有的两个接口协同工作，后者在现有的系统中提供一个更为方便的访问入口c 适配力度不同，后者适配整个子系统 适配器模式演练1类适配器通过 继承关系 达到适配的目的，而对象适配器通过 组合 达到适配目的 类适配器模式 被适配者 12345678910111213141516171819package com.design.pattern.adapter.classadapter;import lombok.extern.slf4j.Slf4j;/** * Adaptee 被适配者 * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class Adaptee &#123; /** * 适配方法，想要和目标类一起工作 */ public void adaptee()&#123; log.info(\"被适配者...run\"); &#125;&#125; 适配器（适配者） 1234567891011121314151617181920212223package com.design.pattern.adapter.classadapter;import lombok.extern.slf4j.Slf4j;/** * Adapter * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class Adapter extends Adaptee implements Target &#123; /** * 1、适配者只是实现目标类的接口，并且继承被适配类，这样使得被适配类拥有目标类相容的接口 * 2、在适配器实现目标接口的方法中调用父类被适配者的方法 */ @Override public void run() &#123; // TODO 这里可以添加其他的操作 log.info(\"适配器...run\"); super.adaptee(); &#125;&#125; 目标接口 1234567891011121314package com.design.pattern.adapter.classadapter;/** * Target 目标类接口 * * @author shunhua * @date 2019-09-21 */public interface Target &#123; /** * 目标操作 */ void run();&#125; 目标类 123456789101112131415161718package com.design.pattern.adapter.classadapter;import lombok.extern.slf4j.Slf4j;/** * CurrTarget 目标接口的实现类，可省去，只是作比较 * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class CurrTarget implements Target &#123; @Override public void run() &#123; log.info(\"目标...run\"); &#125;&#125; 客户端 12345678910111213141516171819202122232425package com.design.pattern.adapter.classadapter;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-21 */public class Client &#123; @Test public void test()&#123; // 目标类的操作 Target target = new CurrTarget(); // 目标类的方法 target.run(); // 被适配者通过适配器进行适配，可以和目标类一起工作 target = new Adapter(); // 适配者的方法，内部是被适配者的方法 target.run(); &#125;&#125; 对象适配模式 被适配者 12345678910111213141516171819package com.design.pattern.adapter.objectadapter;import lombok.extern.slf4j.Slf4j;/** * Adaptee 被适配者 * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class Adaptee &#123; /** * 适配方法，想要和目标类一起工作 */ public void adaptee()&#123; log.info(\"被适配者...run\"); &#125;&#125; 适配器（适配者） 12345678910111213141516171819202122232425262728package com.design.pattern.adapter.objectadapter;import lombok.extern.slf4j.Slf4j;/** * Adapter * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class Adapter implements Target &#123; /** * 通过组合 */ private Adaptee adaptee = new Adaptee(); /** * 1 适配器是实现了目标类的接口，为了是被适配者和目标类拥有同一接口 * 2 通过组合的方法，直接在适配器实现目标接口的方法中调用被适配者实例的方法 */ @Override public void run() &#123; // TODO 可以根据具体业务增加其他的操作 log.info(\"适配器...run\"); adaptee.adaptee(); &#125;&#125; 目标接口 1234567891011121314package com.design.pattern.adapter.objectadapter;/** * Target 目标类接口 * * @author shunhua * @date 2019-09-21 */public interface Target &#123; /** * 目标操作 */ void run();&#125; 目标类 12345678910111213141516171819package com.design.pattern.adapter.objectadapter;;import lombok.extern.slf4j.Slf4j;/** * CurrTarget 目标接口的实现类，可省去，只是作比较 * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class CurrTarget implements Target &#123; @Override public void run() &#123; log.info(\"目标...run\"); &#125;&#125; 客户端 12345678910111213141516171819202122232425package com.design.pattern.adapter.objectadapter;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-22 */public class Client &#123; @Test public void test()&#123; // 目标类 Target target = new CurrTarget(); target.run(); // 通过适配器把被适配者转换成目标接口类型 target = new Adapter(); // 调用适配器实现目标接口的方法，内部调用的是被适配者的方法 target.run(); &#125;&#125; 简单需求1手机电源适配器可以把220v交流电转化为5v直流电 目标接口-5v直流电 123456789101112131415package com.design.pattern.adapter.demand;/** * DC5V 目标电压 * * @author shunhua * @date 2019-09-22 */public interface DC5V &#123; /** * 5V直流电 * @return */ int outPutDC5V();&#125; 需要被适配的类-220v交流电 123456789101112131415161718192021package com.design.pattern.adapter.demand;import lombok.extern.slf4j.Slf4j;/** * AC220V 需要被适配的电压 * * @author shunhua * @date 2019-09-22 */@Slf4jpublic class AC220V &#123; /** * 220V交流电 * @return */ public int outputAC220V()&#123; return 220; &#125;&#125; 变压器-适配器 1234567891011121314151617181920212223242526package com.design.pattern.adapter.demand;import lombok.extern.slf4j.Slf4j;/** * PowerAdapter 电源适配器 * * @author shunhua * @date 2019-09-22 */@Slf4jpublic class PowerAdapter implements DC5V &#123; /** * 通过组合的方式 */ private AC220V ac220V = new AC220V(); @Override public int outPutDC5V() &#123; int ac = ac220V.outputAC220V(); int target = ac/44; // 变压处理 log.info(String.format(\"适配器处理后，%dV电压变为%dV\",220,target)); return 5; &#125;&#125; 客户端 12345678910111213141516171819package com.design.pattern.adapter.demand;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-22 */public class Client &#123; @Test public void test() &#123; DC5V dc5V = new PowerAdapter(); // 通过PowerAdapter适配，把220V交流转为5V直流电 dc5V.outPutDC5V(); &#125;&#125; 源码解析12在SpringMVC中，前端控制器接到请求后会通过处理器映射器找处理器，然后返回一个处理器执行链，接着通过匹配处理器适配器来确定哪一个处理器适配器可以适配当前的处理器，确定后执行处理方法，然后返回ModelAndView。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // 找到处理器对应的处理器适配器 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // 实际调用处理器，然后返回ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125; &#125; // 处理器映射器找处理器逻辑（返回处理器执行链，包含了处理器）/** * Return the HandlerExecutionChain for this request. * &lt;p&gt;Tries all handler mappings in order. * @param request current HTTP request * @return the HandlerExecutionChain, or &#123;@code null&#125; if no handler could be found */ @Nullable protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; &#125; return null; &#125; // 匹配合适的处理器适配器逻辑 /** * Return the HandlerAdapter for this handler object. * @param handler the handler object to find an adapter for * @throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error. */ protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; if (this.handlerAdapters != null) &#123; for (HandlerAdapter adapter : this.handlerAdapters) &#123; if (adapter.supports(handler)) &#123; return adapter; &#125; &#125; &#125; throw new ServletException(\"No adapter for handler [\" + handler + \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\"); &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰者模式","slug":"design_pattern/structure_type/装饰者模式","date":"2019-09-18T16:00:00.000Z","updated":"2020-07-04T16:28:45.971Z","comments":true,"path":"posts/a708a60d/","link":"","permalink":"https://gentryhuang.com/posts/a708a60d/","excerpt":"","text":"定义在不改变原有对象的基础上，将功能附加到对象上。提供了比继承更有弹性的替代方案（扩展原有对象功能）。 类型结构型 应用场景12◆扩展一个类的功能或给一个类添加附加职责◆动态的给一个对象添加功能，这些功能可以再动态的撤销 优点123◆继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能。一般我们可以使用继承实现功能的扩展，如果需要扩展的功能种类繁多，那么势必会生成很多子类，这无疑增加了系统的复杂性。并且使用继承需要提前预知哪些功能，因为继承关系在编译的时候就确定了。而装饰者模式可以动态地加入。其实装饰者模式也是建立在继承的关系基础之上的，注意，这不意味着就不使用继承了，继承也是扩展形式之一，只是某些时候不一定能达到弹性设计的最佳方式。◆通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果◆符合开闭原则，装饰者和被装饰者可以独立变化，原有的代码不需要改变。其实装饰者做的是把装饰功能从类中移出去，这样简化了原来被装饰的类，同时把类的核心职责和装饰功能区分开。 缺点12◆会出现更多的代码，更多的类，增加程序复杂性。装饰者模式可能会比继承方式的使用的类要少，但是对象很多，并且这些对象类型是一样的，因为装饰者会继承被装饰类，而被装饰类又有具体的实体，这些实体对象类型又一样，所有排查问题增加了难度。◆动态装饰时，多层装饰时会更复杂 关联的设计模式装饰者模式和代理模式 121 装饰者模式关注动态地添加方法，代理模式关注于控制对对象的访问2 代理模式中的代理类可以对它的客户隐藏一个对象的具体信息，通常在使用代理模式的时候常常在代理类中创建一个对象的实例，装饰者模式通常把原始对象作为一个参数传入装饰者的构造器，这是使用上的不同。 装饰者模式和适配器模式 1231 两者都是包装者模式2 装饰者和被装饰者可以实现相同的接口或者装饰者是被装饰者的子类3 适配器和被适配的类有不同的接口，也有可能是部分接口是重合的 简单需求买煎饼的时候可以根据自身情况要求加鸡蛋或者香肠，卖煎饼的根据需求去做煎饼。 装饰者模式演练非装饰者模式12需求：加一个鸡蛋加一元，一个火腿两元，现在a买一个煎饼，b买加蛋的煎饼，c买加肠的煎饼方案：通过堆积类完成需求，但是面对众多的需求会类爆炸的。 煎饼类 12345678910111213141516171819202122232425package com.design.pattern.decorator.v1;/** * BatterCake 煎饼类 * * @author shunhua * @date 2019-09-19 */public class BatterCake &#123; /** * 获取食品描述 * @return */ public String getDesc()&#123; return \"煎饼\"; &#125; /** * 食品单价 * @return */ public int cost()&#123; return 5; &#125;&#125; 鸡蛋煎饼类 1234567891011121314151617181920package com.design.pattern.decorator.v1;/** * BatterCakeWithEgg 加鸡蛋的煎饼 * * @author shunhua * @date 2019-09-19 */public class BatterCakeWithEgg extends BatterCake &#123; @Override public String getDesc() &#123; return super.getDesc() + \" 加一个鸡蛋\"; &#125; @Override public int cost() &#123; return super.cost() + 1; &#125;&#125; 香肠煎饼类 12345678910111213141516171819package com.design.pattern.decorator.v1;/** * BatterCakeWithSausage 加香肠的煎饼 * * @author shunhua * @date 2019-09-19 */public class BatterCakeWithSausage extends BatterCake &#123; @Override public String getDesc() &#123; return super.getDesc() + \" 加一个香肠\"; &#125; @Override public int cost() &#123; return super.cost() + 2; &#125;&#125; 客户端 1234567891011121314151617181920212223242526272829package com.design.pattern.decorator.v1;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-19 */@Slf4jpublic class Client &#123; @Test public void test()&#123; // 煎饼 BatterCake batterCake = new BatterCake(); log.info(batterCake.getDesc() + \"销售价格为 \" + batterCake.cost()); // 鸡蛋煎饼 BatterCakeWithEgg batterCakeWithEgg = new BatterCakeWithEgg(); log.info(batterCakeWithEgg.getDesc() + \"销售价格为 \" + batterCakeWithEgg.cost()); // 香肠煎饼 BatterCakeWithSausage batterCakeWithSausage = new BatterCakeWithSausage(); log.info(batterCakeWithSausage.getDesc() + \"销售价格为 \" + batterCakeWithEgg.cost()); &#125;&#125; 装饰者模式12需求：现在肠和蛋随机，a 加2蛋2肠 b加1蛋2肠方案：使用装饰类添加功能，为煎饼加鸡蛋、加香肠 要求： 所谓装饰者模式，通用做法要有抽象的实体类和确定的实体类，同时要有抽象的装饰者和确定的装饰者。现在实体类是煎饼，装饰者是鸡蛋和香肠。 关联： 煎饼实体类继承煎饼抽象类，装饰者抽象类也继承煎饼抽象类，通过它们的父类组合来达到煎饼实体类和装饰者抽象类的关系 抽象煎饼类 123456789101112131415161718192021package com.design.pattern.decorator.v2;/** * AbstractBatterCake 抽象煎饼类（也可以是接口） * * @author shunhua * @date 2019-09-19 */public abstract class AbstractBatterCake &#123; /** * 食品描述 * @return */ public abstract String getDesc(); /** * 价格 * @return */ public abstract int cost();&#125; 煎饼类 1234567891011121314151617181920package com.design.pattern.decorator.v2;/** * BatterCake 实体煎饼类 * * @author shunhua * @date 2019-09-19 */public class BatterCake extends AbstractBatterCake &#123; @Override public String getDesc() &#123; return \"煎饼\"; &#125; @Override public int cost() &#123; return 5; &#125;&#125; 抽象装饰类 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.decorator.v2;/** * * 装饰者同样继承 抽象煎饼类，这是为了方便 ，和煎饼类交互 * * 如果不用构造器的方式，也可以使用set方式 * * @author shunhua * @date 2019-09-19 */public abstract class AbstractDecorator extends AbstractBatterCake &#123; /** * 定义煎饼属性，用于注入 */ private AbstractBatterCake batterCake; public AbstractDecorator(AbstractBatterCake batterCake)&#123; this.batterCake = batterCake; &#125; @Override public String getDesc() &#123; return batterCake.getDesc(); &#125; @Override public int cost() &#123; return batterCake.cost(); &#125; /** * 装饰者实体类特有操作 */ protected abstract void handle();&#125; 鸡蛋装饰类 1234567891011121314151617181920212223242526272829303132package com.design.pattern.decorator.v2;import lombok.extern.slf4j.Slf4j;/** * EggDecorator * * @author shunhua * @date 2019-09-19 */@Slf4jpublic class EggDecorator extends AbstractDecorator &#123; public EggDecorator(AbstractBatterCake batterCake) &#123; super(batterCake); &#125; @Override public String getDesc() &#123; return super.getDesc() + \" 加一个鸡蛋\"; &#125; @Override public int cost() &#123; return super.cost() + 1; &#125; @Override protected void handle() &#123; log.info(\"鸡蛋装饰者特有的处理\"); &#125;&#125; 香肠装饰类 1234567891011121314151617181920212223242526272829303132package com.design.pattern.decorator.v2;import lombok.extern.slf4j.Slf4j;/** * SauseDecorator * * @author shunhua * @date 2019-09-19 */@Slf4jpublic class SauseDecorator extends AbstractDecorator &#123; public SauseDecorator(AbstractBatterCake batterCake) &#123; super(batterCake); &#125; @Override public String getDesc() &#123; return super.getDesc() + \" 加一个香肠\"; &#125; @Override public int cost() &#123; return super.cost() + 2; &#125; @Override protected void handle() &#123; log.info(\"香肠装饰者特有的处理方式\"); &#125;&#125; 客户端 1234567891011121314151617181920212223242526272829package com.design.pattern.decorator.v2;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-19 */@Slf4jpublic class Client &#123; @Test public void test()&#123; AbstractBatterCake batterCake; // 装饰煎饼 batterCake = new BatterCake(); // 鸡蛋装饰 batterCake = new EggDecorator(batterCake); batterCake = new EggDecorator(batterCake); ((EggDecorator) batterCake).handle(); // 香肠装饰 batterCake = new SauseDecorator(batterCake); ((SauseDecorator) batterCake).handle(); log.info(batterCake.getDesc() + \" 一共卖了\" + batterCake.cost() + \"元\"); &#125;&#125; 装饰者模式在源码中的使用BufferedReader 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class BufferedReader extends Reader &#123; private Reader in; private char cb[]; private int nChars, nextChar; // todo 省略 /** * 对Reader类型的 实例进行包装 */ public BufferedReader(Reader in, int sz) &#123; super(in); if (sz &lt;= 0) throw new IllegalArgumentException(\"Buffer size &lt;= 0\"); this.in = in; cb = new char[sz]; nextChar = nChars = 0; &#125; /** * Creates a buffering character-input stream that uses a default-sized * input buffer. * * @param in A Reader */ public BufferedReader(Reader in) &#123; this(in, defaultCharBufferSize); &#125; /** * 这里使用Reader 类型对象进行操作 */ private void fill() throws IOException &#123; int dst; if (markedChar &lt;= UNMARKED) &#123; /* No mark */ dst = 0; &#125; else &#123; /* Marked */ int delta = nextChar - markedChar; if (delta &gt;= readAheadLimit) &#123; /* Gone past read-ahead limit: Invalidate mark */ markedChar = INVALIDATED; readAheadLimit = 0; dst = 0; &#125; else &#123; if (readAheadLimit &lt;= cb.length) &#123; /* Shuffle in the current buffer */ System.arraycopy(cb, markedChar, cb, 0, delta); markedChar = 0; dst = delta; &#125; else &#123; /* Reallocate buffer to accommodate read-ahead limit */ char ncb[] = new char[readAheadLimit]; System.arraycopy(cb, markedChar, ncb, 0, delta); cb = ncb; markedChar = 0; dst = delta; &#125; nextChar = nChars = delta; &#125; &#125; int n; do &#123; n = in.read(cb, dst, cb.length - dst); &#125; while (n == 0); if (n &gt; 0) &#123; nChars = dst + n; nextChar = dst; &#125; &#125;&#125;/** * 注意Reader是抽象的 */public abstract class Reader implements Readable, Closeable &#123; // todo 省略&#125; InputStream类型作为被装饰类型，它的装饰者有很多，如上图中列出FilerInputStream、BufferedInputStream以及LineInputStream。在装饰者内部本质上都是使用InputStream的实例操作的。 BufferedInputStream 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class BufferedInputStream extends FilterInputStream &#123; private static int DEFAULT_BUFFER_SIZE = 8192; private static int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8; protected volatile byte buf[]; private static final AtomicReferenceFieldUpdater&lt;BufferedInputStream, byte[]&gt; bufUpdater = AtomicReferenceFieldUpdater.newUpdater (BufferedInputStream.class, byte[].class, \"buf\"); protected int count; protected int pos; protected int markpos = -1; protected int marklimit; private InputStream getInIfOpen() throws IOException &#123; InputStream input = in; if (input == null) throw new IOException(\"Stream closed\"); return input; &#125; /** * 对InputStream类型进行包装 */ public BufferedInputStream(InputStream in) &#123; this(in, DEFAULT_BUFFER_SIZE); &#125; /** * 对InputStream类型进行包装 */ public BufferedInputStream(InputStream in, int size) &#123; super(in); if (size &lt;= 0) &#123; throw new IllegalArgumentException(\"Buffer size &lt;= 0\"); &#125; buf = new byte[size]; &#125;&#125; Servlet的HttpServletRequestWrapper HttpServletRequestWrapper继承了ServletRequestWrapper也实现了HttpServletRequest,它们的公共父类是ServletRequest. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * HttpServletRequestWrapper装饰类 */public class HttpServletRequestWrapper extends ServletRequestWrapper implements HttpServletRequest &#123; /** * 对HttpServletRequest进行装饰，ServletRequestWrapper抽象的装饰者也对HttpServletRequest的父类进行装饰 */ public HttpServletRequestWrapper(HttpServletRequest request) &#123; super(request); &#125; private HttpServletRequest _getHttpServletRequest() &#123; return (HttpServletRequest) super.getRequest(); &#125; /** * The default behavior of this method is to return getAuthType() * on the wrapped request object. */ public String getAuthType() &#123; return this._getHttpServletRequest().getAuthType(); &#125; /** * The default behavior of this method is to return getCookies() * on the wrapped request object. */ public Cookie[] getCookies() &#123; return this._getHttpServletRequest().getCookies(); &#125; /** * The default behavior of this method is to return getDateHeader(String name) * on the wrapped request object. */ public long getDateHeader(String name) &#123; return this._getHttpServletRequest().getDateHeader(name); &#125;&#125;/*** ServletRequestWrapper装饰类*/public class ServletRequestWrapper implements ServletRequest &#123; private ServletRequest request; /** * Creates a ServletRequest adaptor wrapping the given request object. * @throws java.lang.IllegalArgumentException if the request is null */ public ServletRequestWrapper(ServletRequest request) &#123; if (request == null) &#123; throw new IllegalArgumentException(\"Request cannot be null\"); &#125; this.request = request; &#125; /** * Return the wrapped request object. */ public ServletRequest getRequest() &#123; return this.request; &#125; /** * Sets the request object being wrapped. * @throws java.lang.IllegalArgumentException if the request is null. */ public void setRequest(ServletRequest request) &#123; if (request == null) &#123; throw new IllegalArgumentException(\"Request cannot be null\"); &#125; this.request = request; &#125; /** * * The default behavior of this method is to call getAttribute(String name) * on the wrapped request object. */ public Object getAttribute(String name) &#123; return this.request.getAttribute(name); &#125; /** * The default behavior of this method is to return getAttributeNames() * on the wrapped request object. */ public Enumeration getAttributeNames() &#123; return this.request.getAttributeNames(); &#125; &#125; MyBatis的FifoCache MyBatis的Cache模块中使用大量的装饰者模式，在decorators包下都是的，下面列举最近最少使用策略的装饰类。 123456789101112131415161718192021222324252627282930313233343536373839/*** lru算法 最近最少使用*/public class LruCache implements Cache &#123; private final Cache delegate; private Map&lt;Object, Object&gt; keyMap; private Object eldestKey; public LruCache(Cache delegate) &#123; this.delegate = delegate; setSize(1024); &#125; @Override public String getId() &#123; return delegate.getId(); &#125; @Override public int getSize() &#123; return delegate.getSize(); &#125; public void setSize(final int size) &#123; keyMap = new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) &#123; private static final long serialVersionUID = 4267176411845948333L; @Override protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) &#123; boolean tooBig = size() &gt; size; if (tooBig) &#123; eldestKey = eldest.getKey(); &#125; return tooBig; &#125; &#125;; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"外观模式","slug":"design_pattern/structure_type/外观模式","date":"2019-09-16T16:00:00.000Z","updated":"2020-07-04T16:28:45.972Z","comments":true,"path":"posts/f7de8aa8/","link":"","permalink":"https://gentryhuang.com/posts/f7de8aa8/","excerpt":"","text":"定义又叫门面模式，提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。 类型结构型 使用场景 子系统越来越复杂，增加外观模式提供简单调用接口 构建多层系统结构，利用外观对象作为每层的入口，简化层间调用 优点1234◆简化了调用过程，无需了解深入子系统，防止带来风险(将子系统集成到一起，不去修改子系统)。◆减少系统依赖、松散耦合（客户端与子系统）◆更好的划分访问层次◆符合迪米特法则，即最少知道原则 缺点12◆增加子系统、扩展子系统行为容易引入风险◆增加子系统、扩展子系统行为不符合开闭原则 相关联设计模式对比外观模式和中介者模式 1前者关注外界和子系统的交互，后者关注子系统内部的交互 外观模式和单例模式 1外观模式和单例模式可以结合使用,通常把外观模式中的外观做成单例的 外观模式和抽象工厂模式 1前者可以通过后者获取子系统的实例，子系统可以经内部对外观类进行屏蔽 简单需求 某网站有积分兑换礼物的功能，设计的时候需要校验三步： a 资格校验系统，是木木网会员。 b 积分系统，该系统放的是各个积分的获取支出，需要拿出该用户目前的积分和该礼物所需要的积分进行对比 c 物流系统，如果满足ab，则返回成功，并返回一个订单号。 关注点： 应用层无需知道资格校验类等其他子系统的类 外观模式演练 121. 应用层不关心子系统，应用层只和外观类通信，子系统只和外观类通信2. 如果扩展子系统的，使用实体外观类的话，不符合开闭原则，如果使用抽象外观类或者外观接口，然后用实体继承或实现的话，符合开闭原则。主要看外观对应的子系统群是否变更频繁，不频繁可以使用实体外观，这样更简单。 实体类 1234567891011121314151617181920package com.design.pattern.facade;import lombok.AllArgsConstructor;import lombok.Data;/** * PointsGift 积分兑换礼物 * * @author shunhua * @date 2019-09-17 */@Data@AllArgsConstructorpublic class PointsGift &#123; /** * 礼物名称 */ private String name;&#125; 资格验证系统类 1234567891011121314151617181920212223package com.design.pattern.facade;import lombok.extern.slf4j.Slf4j;/** * QualifyService 校验系统 * * @author shunhua * @date 2019-09-17 */@Slf4jpublic class QualifyService &#123; /** * 校验逻辑，积分是否够 * @param pointsGift * @return */ public boolean isAvailable(PointsGift pointsGift)&#123; log.info(pointsGift.getName() + \"积分通过\"); return true; &#125;&#125; 积分系统类 1234567891011121314151617181920212223package com.design.pattern.facade;import lombok.extern.slf4j.Slf4j;&#x2F;** * PointsPaymentService 积分支付 * * @author shunhua * @date 2019-09-17 *&#x2F;@Slf4jpublic class PointsPaymentService &#123; &#x2F;** * 积分兑换礼物 * @param pointsGift * @return *&#x2F; public boolean pay(PointsGift pointsGift)&#123; log.info(&quot;支付&quot; + pointsGift.getName() + &quot;积分成功&quot;); return true; &#125;&#125; 物流系统类 1234567891011121314151617181920212223package com.design.pattern.facade;import lombok.extern.slf4j.Slf4j;/** * ShippingService * * @author shunhua * @date 2019-09-17 */@Slf4jpublic class ShippingService &#123; /** * 物流系统对接 * @param pointsGift * @return */ public String shipGift(PointsGift pointsGift)&#123; log.info(pointsGift.getName() + \"进入物流系统\"); return \"123456\"; &#125;&#125; 客户端 1234567891011121314151617181920package com.design.pattern.facade;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-17 */public class Client &#123; @Test public void test()&#123; PointsGift pointsGift = new PointsGift(\"机械键盘\"); GiftExchangeService giftExchangeService = new GiftExchangeService(); giftExchangeService.giftExchange(pointsGift); &#125;&#125; 外观模式在源码中的使用Spring-jdbc 1Spring对原生的JDBC进行了封装，我们只需要访问Spring提供的接口方法就可以达到目的。 MyBatis的Configuration 123456/** Configuration#newMetaObject方法底层也是对一些列逻辑的封装，我们只需要调用newMetaObject即可，不需关系内部。 * 如果需要修改内部逻辑，这外观接口是不需要改变的 */public MetaObject newMetaObject(Object object) &#123; return MetaObject.forObject(object, objectFactory, objectWrapperFactory, reflectorFactory); &#125; Tomcat源码 12341. Tomcat中大量使用了外观模式，如RequestFacade、ResponseFacade等。2. RequestFacade implements HttpServletRequest，Request implements HttpServletRequest，Request使用了RequestFacade包装了 自己。Request#getRequest在获取HttpServletRequest时，返回的其实是RequestFacade，之后用这个返回的对象完成的操作都是RequestFacade 来完成的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"原型模式","slug":"design_pattern/creation_type/原型模式","date":"2019-09-15T16:00:00.000Z","updated":"2020-07-04T16:28:45.962Z","comments":true,"path":"posts/91ad9ce3/","link":"","permalink":"https://gentryhuang.com/posts/91ad9ce3/","excerpt":"","text":"定义原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。可以理解为克隆方法克隆对象。 特点不需要知道任何创建的细节，不调用构造函数 类型创建型 适用场景1234◆类初始化消耗较多资源◆new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）◆构造函数比较复杂◆循环体中生产大量对象时 优点 原型模式性能比直接new一个对象性能高 简化创建对象的过程 缺点 必须配备克隆方法（重写Object的clone方法，否则不会生效，克隆也是原型模式的核心） 对克隆复杂对象或对克隆出的对象进行复杂改造时，容易引入风险 对复杂对象的深拷贝、浅拷贝要运用得当 扩展深克隆1创建一个新对象，本体对象的引用类型属性需要进行深克隆，这样它就不会再指向原有对象地址。 浅克隆1创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。 小结1深浅克隆都会在堆中新分配一块区域，它用来指向本体，区别在于对象属性引用的对象是否需要进行克隆（递归性的） 简单需求某个对象创建的时候相对比较消耗资源，但是这个对象又不得不创建多次，这时可以使用原型模式。原型模式是在内存中进行二进制字节流的拷贝，比new一个对象性能好很多 原型模式实践使用原型模式之前邮件类 12345678910111213141516171819202122232425package com.design.pattern.prototype;import lombok.Data;/** * Mail * * @author shunhua * @date 2019-09-16 */@Datapublic class Mail &#123; /** * 邮件名 */ private String name; /** * 邮件地址 */ private String address; /** * 邮件内容 */ private String content;&#125; 邮件工具类 123456789101112131415161718192021222324252627282930package com.design.pattern.prototype;import lombok.extern.slf4j.Slf4j;import java.text.MessageFormat;/** * MailUtil * * @author shunhua * @date 2019-09-16 */@Slf4jpublic class MailUtil &#123; /** * 发送邮件 * 重点： 占位符赋值的实现 * @param mail */ public static void sendMail(Mail mail)&#123; String content = \"向&#123;0&#125;,邮件地址:&#123;1&#125;,邮件内容：&#123;2&#125;发送邮件\"; log.info(MessageFormat.format(content,mail.getName(),mail.getAddress(),mail.getContent())); &#125; /** * 保存邮件的模版内容 * @param mail */ public static void mailTemplate(Mail mail)&#123; log.info(\"邮件的模版内容：\" + mail.getContent()); &#125;&#125; 客户端 12345678910111213141516171819202122232425package com.design.pattern.prototype;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-16 */public class Client &#123; @Test public void test()&#123; Mail mail = new Mail(); mail.setContent(\"邮件模版\"); for(int i = 0; i &lt; 10; i++)&#123; mail.setName(\"姓名\" + i); mail.setAddress(\"姓名\" + i + \"@\" + \"gmail.com\"); mail.setContent(\"你收到一封邮件\"); MailUtil.sendMail(mail); &#125; MailUtil.mailTemplate(mail); &#125;&#125; 使用原型模式默认方式（浅拷贝）邮件类 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.prototype;import lombok.Data;/** * Mail 想要能被克隆需要实现Cloneable接口 * * @author shunhua * @date 2019-09-16 */@Datapublic class Mail implements Cloneable &#123; /** * 邮件名 */ private String name; /** * 邮件地址 */ private String address; /** * 邮件内容 */ private String content; /** * 重写克隆方法 * @return * @throws CloneNotSupportedException */ @Override protected Object clone() throws CloneNotSupportedException &#123; System.out.println(\"克隆Mail...\"); return super.clone(); &#125;&#125; 邮件工具类 12345678910111213141516171819202122232425262728293031package com.design.pattern.prototype;import lombok.extern.slf4j.Slf4j;import java.text.MessageFormat;/** * MailUtil * * @author shunhua * @date 2019-09-16 */@Slf4jpublic class MailUtil &#123; /** * 发送邮件 * @param mail */ public static void sendMail(Mail mail)&#123; String content = \"向&#123;0&#125;,邮件地址:&#123;1&#125;,邮件内容：&#123;2&#125;发送邮件\"; log.info(MessageFormat.format(content,mail.getName(),mail.getAddress(),mail.getContent())); &#125; /** * 保存邮件的模版内容 * @param mail */ public static void mailTemplate(Mail mail)&#123; log.info(\"邮件的模版内容：\" + mail.getContent()); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728package com.design.pattern.prototype;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-16 */public class Client &#123; @Test public void test() throws CloneNotSupportedException &#123; Mail mail = new Mail(); mail.setContent(\"邮件模版\"); for(int i = 0; i &lt; 10; i++)&#123; /** 需要创建多个Mail对象,注意不会调用Mail的构造方法，而是调用了Mail中的clone方法 **/ Mail mailTemp = (Mail) mail.clone(); mailTemp.setName(\"姓名\" + i); mailTemp.setAddress(\"姓名\" + i + \"@\" + \"gmail.com\"); mailTemp.setContent(\"你收到一封邮件\"); MailUtil.sendMail(mailTemp); &#125; // 得到原始的邮件模版 MailUtil.mailTemplate(mail); &#125;&#125; 使用原型模式默认方式（深拷贝）12345678对于被克隆的目标对象中有引用类型的属性时，如果不对该引用类型的属性进行克隆处理，那么该属性对于目标对象和克隆得到的新对象都是同一个，这很容易引起问题，一定要注意。这样情况，只需要对这个属性进行浅拷贝处理即可解决。@Override protected Object clone() throws CloneNotSupportedException &#123; Mail mail = (Mail) super.clone(); //深克隆 mail.date = (Date) pig.date.clone(); return mail; &#125; 原型模式扩展实体类 1234567891011/** * 一种常用的原型模式 * 通过抽象类来实现原型模式 */public abstract class A implements Cloneable&#123; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 继承类 123456789101112131415/** * 继承A类，直接调用clone接口 */public class B extends A&#123; public static void main(String [] args)&#123; B b = new B(); try &#123; b.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); System.out.println(\"处理异常\"); &#125; &#125;&#125; 克隆破坏单例123克隆破坏单例的根本原因是，通过反射暴力调用单例类中的clone方法，这样就会得到一个新对象，单例也就变成了多例。防止克隆破坏单例，只需要让单例类不实现克隆接口即可，或者实现了克隆接口但是克隆方法返回的仍然是同一对象，而不是处理克隆。 原型模式在源码中的使用1可以通过观察Cloneable接口的使用，就可以追踪原型模式是怎样使用的 源码解析1(Object) 12//native 调用非java代码接口 protected native Object clone() throws CloneNotSupportedException; 源码解析2(ArrayList实现克隆) 1234567891011121314151617181920212223public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;/** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */ public Object clone() &#123; try &#123; @SuppressWarnings(\"unchecked\") ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125;&#125; 源码解析3(MyBatis的cacheKey) 12345678910111213141516171819package org.apache.ibatis.cache;import java.io.Serializable;import java.lang.reflect.Array;import java.util.ArrayList;import java.util.List;/** * @author Clinton Begin */public class CacheKey implements Cloneable, Serializable &#123; @Override public CacheKey clone() throws CloneNotSupportedException &#123; CacheKey clonedCacheKey = (CacheKey) super.clone(); clonedCacheKey.updateList = new ArrayList&lt;Object&gt;(updateList); return clonedCacheKey; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者模式","slug":"design_pattern/creation_type/建造者模式","date":"2019-09-11T14:33:47.000Z","updated":"2020-07-04T16:28:45.965Z","comments":true,"path":"posts/fe816c3c/","link":"","permalink":"https://gentryhuang.com/posts/fe816c3c/","excerpt":"","text":"定义 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。用户只需指定需要建造的类型就可以得到它们，建造过程及细节不需要知道。 类型 创建型 适用场景 如果一个对象有非常复杂的内部结构（很多属性） 想把复杂对象的创建和使用分离优点 封装性好，创建和使用分离 扩展性好、建造类之间独立、一定程度上解耦 缺点 产生多余的Builder对象 产品内部发生变化，建造者都需要修改，成本较大 建造者模式和工厂模式比较 建造者模式更注重方法的调用顺序，而工厂模式更注重生产产品 创建对象的粒度不同，建造者模式可以创建复杂的产品，有各种复杂的部件组成。而工程模式创建出来的都几乎一个样子 工厂模式注重把产品创建出来，而建造者不仅要创建出产品，还要知道产品有哪些部件组成的 简单需求说明 有一个课程需要上线在网站，这个课程需要满足以下条件：课程名、课程的课件资源以及视频资源，只有这个三个组件有了 才能组装成上线的课程。这里在创建课时，需要有顺序的执行，最终得到一个符合要求的课程。 v1 通过中间类实现uml类图 课程类 1234567891011121314151617181920212223242526package com.design.pattern.builder;import lombok.Data;/** * Course * * @author shunhua * @date 2019-09-11 */@Datapublic class Course &#123; /** * 课程名 */ private String name; /** * 课程资料 */ private String source; /** * 课程视频 */ private String video;&#125; 建造者抽象类 123456789101112131415161718192021222324252627282930313233package com.design.pattern.builder;/** * CourseBuilder * * @author shunhua * @date 2019-09-11 */public abstract class CourseBuilder &#123; /** * 建造课程名 * @param name */ public abstract void buildName(String name); /** * 建造课程资料 * @param source */ public abstract void buildSource(String source); /** * 建造课程视频 * @param video */ public abstract void buildVideo(String video); /** * 构建课程 * @return */ public abstract Course buildCourse();&#125; 建造者实现类 1234567891011121314151617181920212223242526272829303132package com.design.pattern.builder;/** * ActualCourseBuilder 真正的课程创建者 * * @author shunhua * @date 2019-09-11 */public class ActualCourseBuilder extends CourseBuilder&#123; private Course course = new Course(); @Override public void buildName(String name) &#123; course.setName(name); &#125; @Override public void buildSource(String source) &#123; course.setSource(source); &#125; @Override public void buildVideo(String video) &#123; course.setVideo(video); &#125; @Override public Course buildCourse() &#123; return course; &#125;&#125; 助教（对课程进行组装） 12345678910111213141516171819202122232425262728293031package com.design.pattern.builder;/** * Assistant 课程助教 * * @author shunhua * @date 2019-09-11 */public class Assistant &#123; private CourseBuilder courseBuilder; public void setCourseBuilder(CourseBuilder courseBuilder)&#123; this.courseBuilder = courseBuilder; &#125; /** * 课程助教 组装课程 * @param name * @param source * @param video * @return */ public Course buildCourse(String name,String source,String video)&#123; this.courseBuilder.buildName(name); this.courseBuilder.buildSource(source); this.courseBuilder.buildVideo(video); return this.courseBuilder.buildCourse(); &#125;&#125; 客户端 1234567891011121314151617181920212223package com.design.pattern.builder;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-11 */@Slf4jpublic class Client &#123; @Test public void test()&#123; CourseBuilder courseBuilder = new ActualCourseBuilder(); Assistant assistant = new Assistant(); assistant.setCourseBuilder(courseBuilder); Course course = assistant.buildCourse(\"Java进阶\",\"ppt\",\"Java进阶视频\"); log.info(course.toString()); &#125;&#125; v2 静态内部类演练建造者模式（链式调用）uml类图 1静态内部类builder有3个属性，课程类有相同的3个属性，链式调用的时候，给builder全部或者部分赋值，build的时候，把builder对象传送到course，course获取到builder的属性，然后返回这个course； Course类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.design.pattern.builder.v2;import lombok.Data;/** * Course * * @author shunhua * @date 2019-09-11 */@Datapublic class Course &#123; /** * 课程名 */ private String name; /** * 课程资料 */ private String source; /** * 课程视频 */ private String video; public Course(CourseBuilder courseBuilder)&#123; this.name = courseBuilder.name; this.source = courseBuilder.source; this.video = courseBuilder.video; &#125; /** * 把实体类与对应的创建类写在一起，这种使用更常见,使用链式调用 */ public static class CourseBuilder &#123; /** * 课程名 */ private String name; /** * 课程资料 */ private String source; /** * 课程视频 */ private String video; public CourseBuilder buildName(String name) &#123; this.name = name; return this; &#125; public CourseBuilder buildSource(String source) &#123; this.source = source; return this; &#125; public CourseBuilder buildVideo(String video) &#123; this.video = video; return this; &#125; /** * * @return */ public Course build()&#123; return new Course(this); &#125; &#125;&#125; 客户端 1234567891011121314151617181920212223package com.design.pattern.builder.v2;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-11 */@Slf4jpublic class Client &#123; @Test public void test()&#123; Course course = new Course.CourseBuilder() .buildName(\"java进阶\") .buildSource(\"ppt课件\") .buildVideo(\"java进阶视频\") .build(); log.info(course.toString()); &#125;&#125; 建造者模式在源码中的使用jdk的StringBuilder和StringBuffer12345678910111213// 如StringBuilder的append方法 @Override public StringBuilder append(String str) &#123; super.append(str); return this; &#125;// 如StringBuffer的append方法 @Override public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this; &#125; MyBatis的SqlSessionFactoryBuilder1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123; try &#123; // XML配置的builder 来创建 Configuration XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); // parse方法创建Configuration ，SqlSessionFactoryBuilder的build方法创建SqlSessionFactory return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; inputStream.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; // public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125; // XMLConfigBuilder#parse public Configuration parse() &#123; if (parsed) &#123; throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\"); &#125; parsed = true; parseConfiguration(parser.evalNode(\"/configuration\")); return configuration; &#125; private void parseConfiguration(XNode root) &#123; try &#123; Properties settings = settingsAsPropertiess(root.evalNode(\"settings\")); //issue #117 read properties first propertiesElement(root.evalNode(\"properties\")); loadCustomVfs(settings); typeAliasesElement(root.evalNode(\"typeAliases\")); pluginElement(root.evalNode(\"plugins\")); objectFactoryElement(root.evalNode(\"objectFactory\")); objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\")); reflectorFactoryElement(root.evalNode(\"reflectorFactory\")); settingsElement(settings); // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode(\"environments\")); databaseIdProviderElement(root.evalNode(\"databaseIdProvider\")); typeHandlerElement(root.evalNode(\"typeHandlers\")); mapperElement(root.evalNode(\"mappers\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"抽象工厂","slug":"design_pattern/creation_type/抽象工厂","date":"2019-09-09T16:00:00.000Z","updated":"2020-07-04T16:28:45.965Z","comments":true,"path":"posts/df11d265/","link":"","permalink":"https://gentryhuang.com/posts/df11d265/","excerpt":"","text":"定义 抽象工厂模式提供一个创建一系列相关或相互依赖对象的的接口。无须指定它们具体的类。 类型 创建型 使用场景 客户端（应用层）不依赖于产品实例如何被创建、实现等细节 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码 提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 优点 应用层代码不和具体的产品发生依赖，只和具体的产品族工厂发生依赖关系，低耦合，高内聚 从具体的产品工厂取出来的肯定是同一产品族，开发的时候逻辑清晰 对于产品族来说，符合开闭原则，增加新的产品族的时候，对扩展开放缺点规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工程的接口。增加了系统的抽象性和理解难度。 为何有产品族的业务场景宜用抽象工厂设计模式？而不是工厂设计模式如果使用工厂设计模式，可能会因为工厂类太多而产生类爆炸的现象产品族和产品等级 工厂方法针对的就是产品等级结构，它处理的就是同一类型产品（如：产品类型都是冰箱但是有不同品牌） 抽象工厂针对的就是产品族，它处理的就是一系列产品（如：海尔旗下不同的产品） 简单场景说明 一个课程不仅要有视频资料，还需要有对应的笔记,这样两者都存在才是一门课程。 抽象工厂演练 笔记 1234567891011121314package com.design.pattern.abstractfactory;/** * Article * * @author shunhua * @date 2019-09-10 */public abstract class Article &#123; /** * 生产笔记的方法 */ public abstract void produce();&#125; java笔记 123456789101112131415161718package com.design.pattern.abstractfactory;import lombok.extern.slf4j.Slf4j;/** * JavaArticle * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class JavaArticle extends Article &#123; @Override public void produce() &#123; log.info(\"生产Java笔记\"); &#125;&#125; python笔记 123456789101112131415161718package com.design.pattern.abstractfactory;import lombok.extern.slf4j.Slf4j;/** * PythonArticle * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class PythonArticle extends Article &#123; @Override public void produce() &#123; log.info(\"生产python笔记\"); &#125;&#125; 视频资源 1234567891011121314package com.design.pattern.abstractfactory;/** * Video * * @author shunhua * @date 2019-09-10 */public abstract class Video &#123; /** * 生产视频的抽象方法 */ public abstract void produce();&#125; Java视频资源 123456789101112131415161718package com.design.pattern.abstractfactory;import lombok.extern.slf4j.Slf4j;/** * JavaVideo * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class JavaVideo extends Video &#123; @Override public void produce() &#123; log.info(\"生成Java视频资源\"); &#125;&#125; python视频资源 123456789101112131415161718package com.design.pattern.abstractfactory;import lombok.extern.slf4j.Slf4j;/** * PythonVideo * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class PythonVideo extends Video &#123; @Override public void produce() &#123; log.info(\"生产python视频\"); &#125;&#125; 课程工厂（产品族工厂） 1234567891011121314151617181920package com.design.pattern.abstractfactory;/** * CourseFactory * * @author shunhua * @date 2019-09-10 */public interface CourseFactory &#123; /** * 生产视频 * @return */ Video getVideo(); /** * 生产笔记 * @return */ Article getArticle();&#125; Java课程工厂 1234567891011121314151617181920package com.design.pattern.abstractfactory;/** * JavaCourseFactory * * @author shunhua * @date 2019-09-10 */public class JavaCourseFactory implements CourseFactory &#123; @Override public Video getVideo() &#123; return new JavaVideo(); &#125; @Override public Article getArticle() &#123; return new JavaArticle(); &#125;&#125; Python课程工厂 1234567891011121314151617181920package com.design.pattern.abstractfactory;/** * PythonCourseFactory * * @author shunhua * @date 2019-09-10 */public class PythonCourseFactory implements CourseFactory&#123; @Override public Video getVideo() &#123; return new PythonVideo(); &#125; @Override public Article getArticle() &#123; return new PythonArticle(); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.design.pattern.abstractfactory;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-10 */public class Client &#123; @Test public void test()&#123; CourseFactory courseFactory = new JavaCourseFactory(); Video video = courseFactory.getVideo(); Article article = courseFactory.getArticle(); video.produce(); article.produce(); &#125;&#125;``` ## 抽象工厂在源码中的使用### 连接源码解析**Connection的两个方法属性同一个产品族，这是一个父类**```java// mysql和oracle获取的是同一产品族下的statement和同一产品族下的preparestatementpublic interface Connection extends Wrapper, AutoCloseable &#123; Statement createStatement() throws SQLException; PreparedStatement prepareStatement(String sql) throws SQLException; // ... &#125; // executeQuery方法和execureUpdate方法属于同一个产品族public interface Statement extends Wrapper, AutoCloseable &#123; ResultSet executeQuery(String sql) throws SQLException; int executeUpdate(String sql) throws SQLException; &#125; MyBatis的SqlSession源码解析java.sql.Connection/java.sql.Statement/org.apache.ibatis.session.SqlSessionFactory等 接口就是一个抽象工厂（从同一个抽象工厂中返回的产品一定属于同一个产品族）它里面有多个工厂方法，它的实现类通过实现不同的工厂方法，来创建出不同的产品。 SqlSessionFactory 12345678910111213141516171819202122232425package org.apache.ibatis.session;import java.sql.Connection;/** * Creates an &#123;@link SqlSession&#125; out of a connection or a DataSource * * @author Clinton Begin */public interface SqlSessionFactory &#123; SqlSession openSession(); SqlSession openSession(boolean autoCommit); SqlSession openSession(Connection connection); SqlSession openSession(TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType); SqlSession openSession(ExecutorType execType, boolean autoCommit); SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType, Connection connection); Configuration getConfiguration();&#125; SqlSessionFactory子类 SqlSessionManagerSqlSessionFactory子类 DefaultSqlSessionFactory","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂方法","slug":"design_pattern/creation_type/工厂方法","date":"2019-09-08T16:00:00.000Z","updated":"2020-07-04T14:26:53.332Z","comments":true,"path":"posts/a778ad08/","link":"","permalink":"https://gentryhuang.com/posts/a778ad08/","excerpt":"","text":"定义 定义一个创建对象的接口（抽象方法），让实现这个接口的类（实现抽象方法）来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行，即通过子类实现抽象方法来创建对象。 工厂方法就是用来解决同一产品等级的业务抽象问题。工厂创建对象用的，方法通过子类实现方法来创建对象。 类型 创建型 使用场景 创建对象需要大量的重复代码 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节 一个类通过其子类来指定创建哪个对象优点用户只需要关心所需产品对应的工厂，无须关心创建细节。加入新的产品符合开闭原则，提高了可扩展性。缺点实现类的个数容易过多（增加新产品的时候，不仅需要编写新的产品类还需要编写对应的工厂类，因此类的个数增加）、增加复杂度。工厂方法本身使用了抽象，我们需要引入抽象层，如果想要动态创建可能还会使用反射技术，这都增加了系统的抽象性和理解难度产品等级和产品族 工厂方法是为了决绝同一产品等级的业务抽象问题，抽象工厂是为了解决同以产品族的问题 产品等级相同类型的产品为同一产品等级，如：汽车有大众、长安、奥迪等，它们属于同一产品等级 产品族不同类型的产品，如长安汽车、长安摩托、长安自行车 工厂方法演练 Food类 1234567891011121314package com.design.pattern.factorymethod;/** * 相同类型的产品属于同一产品等级，无论是面包还是沙拉，它们都是同一个等级，这里是Food * * @author shunhua * @date 2019-09-09 */public abstract class Food &#123; /** * 生产产品方法 */ public abstract void produce();&#125; 面包类 123456789101112131415161718192021package com.design.pattern.factorymethod;import lombok.Data;import lombok.ToString;import lombok.extern.slf4j.Slf4j;/** * Bread * * @author shunhua * @date 2019-09-09 */@Slf4j@ToStringpublic class Bread extends Food &#123; @Override public void produce() &#123; log.info(\"生产面包!\"); &#125;&#125; 沙拉类 1234567891011121314151617181920package com.design.pattern.factorymethod;import lombok.ToString;import lombok.extern.slf4j.Slf4j;/** * Salad * * @author shunhua * @date 2019-09-09 */@Slf4j@ToStringpublic class Salad extends Food &#123; @Override public void produce() &#123; log.info(\"生成沙拉!\"); &#125;&#125; 抽象工厂 123456789101112131415package com.design.pattern.factorymethod;/** * 工厂方法,子类继承即可 * 这里使用抽象类主要考虑到在类中有些是已知的，使用抽象类合适。如果全都是未知的使用接口比较合适。 * @author shunhua * @date 2019-09-09 */public abstract class FoodFactory &#123; /** * 工厂方法，起到规约的作用，并不生产具体的产品，具体产品的生成由其实现完成 * @return */ public abstract Food createFood();&#125; 子工厂类-面包工厂 12345678910111213141516171819package com.design.pattern.factorymethod;/** * BreadFactory 只生产Bread * * @author shunhua * @date 2019-09-10 */public class BreadFactory extends FoodFactory &#123; /** * 生产面包的工厂方法 * @return */ @Override public Food createFood() &#123; return new Bread(); &#125;&#125; 子工厂类-沙拉工厂 123456789101112131415161718package com.design.pattern.factorymethod;/** * SaladFactory 只生产Salad * * @author shunhua * @date 2019-09-10 */public class SaladFactory extends FoodFactory &#123; /** * 生产面包的工厂方法 * @return */ @Override public Food createFood() &#123; return new Salad(); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728package com.design.pattern.factorymethod;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class Client &#123; @Test public void test()&#123; // 面包工厂方法 FoodFactory breadFactory = new BreadFactory(); Food bread = breadFactory.createFood(); log.info(String.valueOf(bread)); // 沙拉工厂方法 FoodFactory saladFactory = new SaladFactory(); Food salad = saladFactory.createFood(); log.info(String.valueOf(salad)); &#125;&#125; 工厂方法在源码中的使用Collection的Iterator解析Collection接口相当于抽象工厂（因为它处理的是等级组问题即多个类型的产品），其中它里面的Iterator iterator()方法相当于工厂方法。ArrayList实现了这个方法，该方法为ArrayList生产Itr，Itr是Iterator类型。还有ILoggerFactory和Logger产品族对应的工厂方法的使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"合成复用原则","slug":"design_pattern/principle/合成复用原则","date":"2019-09-04T16:00:00.000Z","updated":"2020-07-04T13:42:18.872Z","comments":true,"path":"posts/b91a199d/","link":"","permalink":"https://gentryhuang.com/posts/b91a199d/","excerpt":"","text":"继承关系的选择 继承关系是is a的关系，所以看是否有继承关系，通常要看子类和父类共用的方法，子类是否能够实现父类的方法 起名 合成复用原则，组合复用原则，聚合复用原则 定义 尽量使用组合，聚合，而不是继承关系达到复用软件的目的 组合聚合（黑箱复用） 优点降低耦合，提高系统的灵活性。使一个类的变化对其他类造成的影响较小 缺点会生成较多的对象进行管理 继承（白箱复用） 优点新的扩展性容易实现，修改和扩展相对容易 缺点父类的方法侵入性的带给子类，父类方法的改变，子类也必须改变，相比耦合较高 组合聚合区别关系强弱，组合强，聚合弱","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"里氏替换原则","slug":"design_pattern/principle/里氏替换原则","date":"2019-09-03T16:00:00.000Z","updated":"2020-07-04T13:42:18.873Z","comments":true,"path":"posts/3d1cbe69/","link":"","permalink":"https://gentryhuang.com/posts/3d1cbe69/","excerpt":"","text":"定义 如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。 定义扩展 一个软件实体如果适用一个父类的话，那一定适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。（反对子类重写父类） 特点123456789◆引申意义：子类可以扩展父类的功能，但不能改变父类原有的功能。◆含义1：子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。◆含义2：子类中可以增加自己特有的方法。◆含义3：当子类的方法重载父类的方法时，方法的前置条件（即方法的输入&#x2F;入参）要比父类方法的输入参数更宽松。（入参宽松）◆含义4：当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的输出&#x2F;返回值）要比父类更严格或相等。（出参严谨）（前两条，约定子类最好不要重写父类的方法，如果一定要重写的话，可以使用组合聚合等方法实现）（后两条,约定了子啊重载或实现父类方法的条件） 优点 约束了继承泛滥，很多非子类父类关系的类，没必要使用继承关系 加强程序的可维护性，降低需求变更时引起的风险 coding里氏替换原则继承关系判别（是否是真正意义的继承）1子类行为规则应与父类行为规则一致，如果子类达不到这一点，则会违背里氏替换原则，违背里氏替换原则会怎样？继承逻辑混乱，代码不便于维护 入参控制1重载的时候入参要更加宽松，可以不引起逻辑混乱 父类 1234567import java.util.HashMap;public class Base &#123; public void method(HashMap hashMap)&#123; System.out.println(\"执行父类HashMap方法\"); &#125;&#125; 子类 12345678910111213141516171819import java.util.HashMap;import java.util.Map;public class Child extends Base&#123; // @Override // public void method(HashMap hashMap) &#123; // System.out.println(\"执行子类的HashMap方法\"); // &#125; /** * 子类重载 * 重载的时候入参 Map比 Hashmap宽松，此时执行的时候会执行父类，不执行重载的类 * @param Map */ public void method(Map Map) &#123; System.out.println(\"执行子类Map方法\"); &#125;&#125; 出参控制1子类的出参如果包含父类，会直接报错 父类 12345678910111213package com.design.pattern.principle.liskovSubstitutation.outputmethod;import java.util.Map;/** * Base * * @author shunhua * @date 2019-09-15 */public abstract class Base &#123; public abstract Map method();&#125; 子类 12345678910111213141516171819202122232425262728293031package com.design.pattern.principle.liskovSubstitutation.outputmethod;import java.util.HashMap;import java.util.Map;/** * Child * * @author shunhua * @date 2019-09-15 */public class Child extends Base &#123; /** * 子类的出参如果包含父类，会直接报错。 * @return */ /* @Override public Object method() &#123; return null; &#125;*/ /** * 父类的出参包含子类的出参是可以的 * @return */ @Override public HashMap method()&#123; return new HashMap(2); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"接口隔离原则","slug":"design_pattern/principle/接口隔离原则","date":"2019-09-02T16:00:00.000Z","updated":"2020-07-04T13:42:18.871Z","comments":true,"path":"posts/e0ec8882/","link":"","permalink":"https://gentryhuang.com/posts/e0ec8882/","excerpt":"","text":"定义 用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。 注意点 一个类对一个类的依赖应该建立在最小的接口上（这里的类是泛指，也代表接口）。 建立单一接口，不要建立庞大臃肿的接口 尽量细化接口，接口中的方法尽量少 注意适度原则，一定要适度，虽然接口中的方法尽量少，但是也要有限度。优点符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。和单一职责原则比较单一职责原则指的是类、接口和方法的职责是单一的，强调的是职责，如果职责是单一的那么在类或者接口中具有多个方法都是可以的，因为它们都是一类的，比如叫声，不同的动物有不同的叫。接口隔离原则注重地是对接口依赖的隔离。简单需求说明使用统一的接口定义多个功能的方法，但是有的实现不一定会全部用到，最好是将这个统一的接口根据不同的维度进行拆分成多个接口，实现根据需要进行接口的实现。 coding接口隔离原则反例接口 12345public interface IAnimalAction &#123; void eat(); void fly(); void swim();&#125; 狗实现类 1234567891011121314151617181920public class DogCaseOne implements IAnimalAction&#123; @Override public void eat() &#123; &#125; /** * 注：这里是空方法，狗不会飞，所以明显设计的不合理，最好不要有太多的空方法 */ @Override public void fly() &#123; &#125; @Override public void swim() &#123; &#125;&#125; 鸟实现类 12345678910111213141516171819public class LarkCaseOne implements IAnimalAction&#123; @Override public void eat() &#123; &#125; @Override public void fly() &#123; &#125; /** * 很明显，百灵鸟不会游泳，此处为空方法，设计不合理 */ @Override public void swim() &#123; &#125;&#125; 接口隔离原则正例吃东西接口 123456public interface IEat&#123; /** * 吃东西 */ void eat();&#125; 飞翔接口 123456public interface IFly&#123; /** * 飞翔 */ void fly();&#125; 游泳接口 123456public interface ISwim&#123; /** * 游泳 */ void swim();&#125; 狗实现类 123456789101112131415/** * 狗只用实现 吃和游泳方法即可 */@Slf4jpublic class DogCaseTwo implements IEat,ISwim&#123; @Override public void eat() &#123; log.info(\"狗吃东西!\"); &#125; @Override public void swim() &#123; log.info(\"狗游泳\"); &#125;&#125; 鸟实现类 123456789101112131415/** * 鸟实现 吃和飞方法即可 */@Slf4jpublic class LarkCaseTwo implements IEat,IFly&#123; @Override public void eat() &#123; log.info(\"鸟吃东西\"); &#125; @Override public void fly() &#123; log.info(\"鸟飞翔\"); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"迪米特法则","slug":"design_pattern/principle/迪米特法则","date":"2019-09-02T16:00:00.000Z","updated":"2020-07-04T13:42:18.870Z","comments":true,"path":"posts/ebdadec7/","link":"","permalink":"https://gentryhuang.com/posts/ebdadec7/","excerpt":"","text":"定义 迪米特法则也叫最少知道原则,一个对象应该对其他对象保持最少的了解（比如包的权限，修饰的关键字）。尽量降低类与类之间的耦合。 优点 降低类之间的耦合。 强调 只关心出现在成员变量、方法的入参和出参中的类，不关心方法体内部的类。 简单需求说明 公司老板想了解某个业务组的项目情况，老板直接找到TeamLeader，不需要关心项目组其他成员。而TeamLeader需要让组内 某个成员进行整理资料，然交给自己，自己再交给老板。 coding迪米特法则反例老板类 123456789101112131415161718import java.util.ArrayList;import java.util.List;/** * 此处设计不合理，只访问朋友类（成员变量中的类，输入中出现的类，输出中出现的类） * 成员方法中的类不需要引入(Member) */public class Boss &#123; public void findMembers()&#123; TeamLeader leader = new TeamLeader(); List&lt;Member&gt; list = new ArrayList&lt;Member&gt;(); for(int i= 0;i&lt;10;i++)&#123; list.add(new Member()); &#125; leader.countMember(list); &#125;&#125; 主管类 12345678import java.util.List;@Slf4jpublic class TeamLeader &#123; public void countMember(List list)&#123; log.info(\"当前项目组的成员数：\"+list.size()); &#125;&#125; 项目组成员类 12345678910111213public class Member &#123; // ..&#125;``` **应用类**```javapublic class Client&#123; public static void main(String[] args)&#123; Boss boss = new Boss(); boss.findMembers(); &#125;&#125; 迪米特法则正例老板类 1234567891011121314151617package com.design.pattern.principle.demeter;/** * Boss * * @author shunhua * @date 2019-09-03 */public class Boss &#123; /** * 对Member不需要见，只关心TeamLeader * @param teamLeader */ public void findProject(TeamLeader teamLeader)&#123; teamLeader.findProject(); &#125;&#125; 主管类 1234567891011121314151617181920package com.design.pattern.principle.demeter;import lombok.extern.slf4j.Slf4j;/** * TeamLeader * * @author shunhua * @date 2019-09-03 */@Slf4jpublic class TeamLeader &#123; /** * 关注Member */ public void findProject()&#123; Member member = new Member(); log.info(String.valueOf(member)); &#125;&#125; 成员类 1234567891011package com.design.pattern.principle.demeter;/** * Member * * @author shunhua * @date 2019-09-03 */public class Member &#123; // ..&#125; 应用 12345678910111213141516171819202122package com.design.pattern.principle;import com.design.pattern.principle.demeter.Boss;import com.design.pattern.principle.demeter.TeamLeader;import org.junit.Test;/** * DemeterTest * * @author shunhua * @date 2019-09-03 */public class DemeterTest &#123; @Test public void test()&#123; Boss boss = new Boss(); TeamLeader teamLeader = new TeamLeader(); boss.findProject(teamLeader); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"依赖倒置原则","slug":"design_pattern/principle/依赖倒置原则","date":"2019-09-01T16:00:00.000Z","updated":"2020-07-04T13:42:18.866Z","comments":true,"path":"posts/91021fa8/","link":"","permalink":"https://gentryhuang.com/posts/91021fa8/","excerpt":"","text":"定义 高层模块不应该依赖低层模块，二者都应该依赖其抽象。 优点 可以减少类间的耦合性、提高系统稳定性，增强代码可读性和可维护性，可降低修改程序造成的风险。 细节描述 抽象不应该依赖细节，细节应该依赖抽象。针对接口编程而不要针对实现编程。 简单需求说明 某同学想要学习某一课程，最简单的方式直接在Person中编写一个方法即可，但是如果以后想要学习其他课程就 需要修改Person类。为了解耦，我们可以把课程抽象出去，高层对底层的依赖，这样Person依赖的就是抽象，我 们针对接口编程，而不是针对实现编程。 coding非面向抽象编程12345678910111213141516171819202122232425缺点：应用依赖具体的实现，对于后续需求变更更加不适用&#96;&#96;&#96; **实体类**&#96;&#96;&#96;javapackage com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;&#x2F;** * Person * * @author shunhua * @date 2019-09-02 *&#x2F;@Slf4jpublic class Person &#123; public void learnJavaCourse()&#123; log.info(&quot;学习Java课程&quot;); &#125; public void learnPythonCourse()&#123; log.info(&quot;学习Python课程&quot;); &#125;&#125; 应用 12345678910111213141516171819202122package com.design.pattern.principle;import com.design.pattern.principle.dependenceinversion.PythonCourse;import com.design.pattern.principle.dependenceinversion.JavaCourse;import com.design.pattern.principle.dependenceinversion.Person;import org.junit.Test;/** * DependeceinversionTest * * @author shunhua * @date 2019-09-02 */public class DependeceinversionTest &#123; @Test public void test()&#123; Person person = new Person(); person.studyJava(); person.studyPython(); &#125;&#125; 面向接口编程1这里使用接口方法传参的方式 课程接口 1234567891011121314package com.design.pattern.principle.dependenceinversion;/** * ICourse * * @author shunhua * @date 2019-09-02 */public interface ICourse &#123; /** * 学习课程 */ void learnCourse();&#125; Java课程 123456789101112131415161718package com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;/** * JavaCourse * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class JavaCourse implements ICourse &#123; @Override public void learnCourse() &#123; log.info(\"gentryhuang is learning java\"); &#125;&#125; Python课程 123456789101112131415161718package com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;/** * PythonCourse * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class PythonCourse implements ICourse &#123; @Override public void learnCourse() &#123; log.info(\"gentryhuang is learning python\"); &#125;&#125; 实体 1234567891011121314151617package com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;/** * Person * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class Person &#123; public void learnCource(ICourse course)&#123; course.learnCourse(); &#125;&#125; 应用 123456789101112131415161718192021package com.design.pattern.principle;import com.design.pattern.principle.dependenceinversion.PythonCourse;import com.design.pattern.principle.dependenceinversion.JavaCourse;import com.design.pattern.principle.dependenceinversion.Person;import org.junit.Test;/** * DependeceinversionTest * * @author shunhua * @date 2019-09-02 */public class DependeceinversionTest &#123; @Test public void test()&#123; Person person = new Person(); person.learnCource(new JavaCourse()); person.learnCource(new PythonCourse()); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单一职责原则","slug":"design_pattern/principle/单一职责原则","date":"2019-09-01T16:00:00.000Z","updated":"2020-07-04T13:42:18.868Z","comments":true,"path":"posts/46a1bcf2/","link":"","permalink":"https://gentryhuang.com/posts/46a1bcf2/","excerpt":"","text":"定义 不要存在多于一个导致类变更的原因。体现在一个类/接口/方法只负责一项职责。 优点 降低类的复杂度、提高类的可读性，提高系统的可维护性，降低变更引起的风险。 详解 在类的级别上，可以定义不同的类实现不同的功能，在接口级别上，可以根据功能抽象出不同的接口，然后按需要实现一个或多个接口。方法级别上，可以做到不同的方法实现不同的操作。 要点讲解12341. 实际应用中，类不采用单一职责，接口和方法采用单一职责。2. 定义：单一职责规定 一个类，接口或者方法，只有一个变化的原因3. 优点：降低类的复杂性，提高可读性，维护时风险降低4. 实际应用，受依赖，组合，聚合这些关系影响，同时受控于项目规模，项目周期，技术人员水平，对进度把控等影响。应适当的应用单一职责原则 简单需求说明 完成不同功能，并且使设计模块具有可读性和可维护性。可以使用不同的类或接口或方法去完成某一类功能，这样就显得单一，具有针对性。 类的单一职责原则实体类1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.design.pattern.principle.singleresponsibility;import lombok.extern.slf4j.Slf4j;/** * WalkBird * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class WalkBird &#123; public void moveMode(String birdName)&#123; log.info(birdName + \"陆地奔跑\"); &#125;&#125;``` **实体类2**```javapackage com.design.pattern.principle.singleresponsibility;import lombok.extern.slf4j.Slf4j;/** * FlyBird * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class FlyBird &#123; public void moveMode(String birdName)&#123; log.info(birdName + \"用翅膀飞\"); &#125;&#125;``` **应用**```javapublic class Client &#123; public static void main(String[] args) &#123; WalkBird walkBird = new WalkBird(); walkBird.birdMove(\"鸵鸟\"); FlyBird flyBird = new FlyBird(); flyBird.birdMove(\"大雁\"); &#125;&#125;``` ### 接口的单一职责**接口1**```java/** * 这个接口和获取内容的接口有先后顺序，只有开始学习，才能获取内容，如果退出学习，就不能在获取内容了， * 由于职责不同，所以设计两个接口符合单一职责原则 */public interface IcourseAction &#123; void beginStudy(); void quitStudy();&#125; 接口2 1234567/** * 注，本接口主要是获取课程的内容 */public interface IcourseContent &#123; String getCourseText();//获取课程文本内容 byte[] getCourseVideo();//获取课程的视频&#125; 实体类 12345678910111213141516171819202122@Slf4jpublic class Course implements IcourseAction,IcourseContent&#123; @Override public void beginStudy() &#123; log.info(\"开始学习!\"); &#125; @Override public void quitStudy() &#123; log.info(\"学习完成！\"); &#125; @Override public String getCourseText() &#123; return \"Java 资料\"; &#125; @Override public byte[] getCourseVideo() &#123; return new byte[0]; &#125;&#125; 方法的单一职责12345678910111213141516171819202122232425public class Method &#123; /** * 单一职责原则，修改用户的名称 * @return */ public String updateUserName()&#123; return \"\"; &#125; /** * 单一职责原则,修改用户的密码 * @return */ public String updateUserPassWord()&#123; return \"\"; &#125; /** * 不符合单一职责 * @return */ public String updateUserInfo(String userId,String gender)&#123; return \" \"; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"开闭原则","slug":"design_pattern/principle/开闭原则","date":"2019-08-31T16:00:00.000Z","updated":"2020-07-04T13:42:18.869Z","comments":true,"path":"posts/f50731fc/","link":"","permalink":"https://gentryhuang.com/posts/f50731fc/","excerpt":"","text":"定义 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 强调的是用抽象构建框架，用实现扩展细节。 核心思想 面向抽象编程，因为抽象是稳定的。 理解 不改变原先的业务逻辑，新增的功能点通过重写复用的方法进行编程。 优点 提高软件系统的可复用性以及可维护性 简单需求说明 软件实体ICourse，以及它的实现JavaCource实现了基本功能，如需要额外的功能可以对JavaCourse进行扩展即继承来添加， 这样在不修改底层的ICourse和JavaCourse的前提下，做到功能的添加。即，越基层的模块影响范围越大，越高层的模块影响 范围较小，总体实现了对扩展开放，对修改关闭，这样就可以有效解决影响范围。 codingv1 基类1需求：打印出原价以及课程其他信息 接口 12345678910111213141516171819202122232425package com.design.pattern.principle.openclose;/** * ICourse * * @author shunhua * @date 2019-09-01 */public interface ICourse &#123; /** * 获取课程id * @return */ Integer getId(); /** * 获取课程名称 * @return */ String getName(); /** * 获取课程价格 * @return */ Double getPrice();&#125; 实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.design.pattern.principle.openclose;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * JavaCourse * * @author shunhua * @date 2019-09-01 */@AllArgsConstructor@NoArgsConstructor@Datapublic class JavaCourse implements ICourse &#123; /** * 课程id */ private Integer id; /** * 课程名称 */ private String name; /** * 课程价格 */ private Double price; @Override public Integer getId() &#123; return this.id; &#125; @Override public String getName() &#123; return this.name; &#125; @Override public Double getPrice() &#123; return this.price; &#125;&#125; 应用 123456789101112131415161718192021222324252627package com.design.pattern.principle;import com.design.pattern.principle.openclose.ICourse;import com.design.pattern.principle.openclose.JavaCourse;import com.design.pattern.principle.openclose.JavaDiscountCourse;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * OpencloseTest * * @author shunhua * @date 2019-09-01 */@Slf4jpublic class OpencloseTest &#123; @Test public void testBase()&#123; ICourse javaCourse = new JavaCourse(100,\"Java从入门到放弃\",200d); log.info(String.format(\"课程id: %d,课程名: %s, 课程价格：%f\", javaCourse.getId(), javaCourse.getName(), javaCourse.getPrice()) ); &#125;&#125; v21需求：打印出原价和折扣后的价格以及课程其他信息（接口不应该随意发生变化，面向接口编程） 接口 12345678910111213141516171819202122232425package com.design.pattern.principle.openclose;/** * ICourse * * @author shunhua * @date 2019-09-01 */public interface ICourse &#123; /** * 获取课程id * @return */ Integer getId(); /** * 获取课程名称 * @return */ String getName(); /** * 获取课程价格 * @return */ Double getPrice();&#125; 实体类 1234567891011121314151617181920212223242526272829303132package com.design.pattern.principle.openclose;/** * JavaDiscountCourse * * @author shunhua * @date 2019-09-01 */public class JavaDiscountCourse extends JavaCourse &#123; public JavaDiscountCourse(Integer id, String name, Double price) &#123; super(id, name, price); &#125; /** * 获取折扣价 * @return */ @Override public Double getPrice() &#123; return super.getPrice() * 0.8; &#125; /** * 获取原价 * @return */ public Double getOriginPrice()&#123; return super.getPrice(); &#125;&#125; 应用 123456789101112131415161718192021222324252627282930313233343536373839package com.design.pattern.principle;import com.design.pattern.principle.openclose.ICourse;import com.design.pattern.principle.openclose.JavaCourse;import com.design.pattern.principle.openclose.JavaDiscountCourse;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * OpencloseTest * * @author shunhua * @date 2019-09-01 */@Slf4jpublic class OpencloseTest &#123; @Test public void testBase()&#123; ICourse javaCourse = new JavaCourse(100,\"Java从入门到放弃\",200d); log.info(String.format(\"课程id: %d,课程名: %s, 课程价格：%f\", javaCourse.getId(), javaCourse.getName(), javaCourse.getPrice()) ); &#125; @Test public void testEx()&#123; ICourse javaCource = new JavaDiscountCourse(100,\"java从入门到放弃\",200d); log.info(String.format(\"课程id: %d,课程名: %s, 课程原价：%f，课程折扣价格：%f\", javaCource.getId(), javaCource.getName(), ((JavaDiscountCourse) javaCource).getOriginPrice(), javaCource.getPrice()) ); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"简单工厂","slug":"design_pattern/other_type/简单工厂","date":"2019-08-28T16:00:00.000Z","updated":"2020-08-04T06:13:21.253Z","comments":true,"path":"posts/90fd4bf3/","link":"","permalink":"https://gentryhuang.com/posts/90fd4bf3/","excerpt":"","text":"定义 由一个工厂对象决定创建出哪一种产品类的实例 类型 创建型，但不属于GOF23种设计模式。简单工厂模式严格意义上说并不是一种设计模式，它是一种编码上的风格和习惯 使用场景 工厂类负责创建的对象比较少 客户端（应用层）只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心优点只需要传入一个正确的参数，就可以获取所需要的对象而无须知道其创建细节缺点简单工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背了开闭原则。 coding未使用简单工厂模式的代码父类 12345678910111213public abstract class Video&#123; public abstract void printVideo();&#125;``` **子类JavaVideo**```java@Slf4jpublic class JavaVideo extends Video&#123; @Override public void printVideo() &#123; log.info(\"录制java视频\"); &#125;&#125; 子类PythonVideo 1234567@Slf4jpublic class PythonVideo extends Video&#123; @Override public void printVideo() &#123; log.info(\"录制python视频\"); &#125;&#125; 应用 1234567public class client&#123; @Test public void test()&#123; Video video = new JavaVideo(); video.printVideo(); &#125;&#125; 使用简单工厂模式 工厂类 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.design.pattern.simplefactory;/** * 简单工厂 * * @author shunhua * @date 2019-09-09 */public class FoodFactory &#123; /** * 随着要产品增多，以下逻辑必须要修改 * @param type 这里使用字符串根据类型进行创建不同的实例 * @return */ public Food createFood(String type)&#123; if(\"salad\".equalsIgnoreCase(type))&#123; return new Salad(); &#125;else if(\"bread\".equalsIgnoreCase(type))&#123; return new Bread(); &#125; return null; &#125; /** * * @param c 这里使用反射创建不同的实例 * @return */ public Food createFood(Class c)&#123; Food food = null; try &#123; food = (Food) Class.forName(c.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return food; &#125;&#125; 父类 1234567891011121314package com.design.pattern.simplefactory;/** * Food * * @author shunhua * @date 2019-09-09 */public abstract class Food &#123; /** * 生产产品方法 */ public abstract void produce();&#125; 子类面包 123456789101112131415161718package com.design.pattern.simplefactory;import lombok.extern.slf4j.Slf4j;/** * Bread * * @author shunhua * @date 2019-09-09 */@Slf4jpublic class Bread extends Food &#123; @Override public void produce() &#123; log.info(\"生产面包!\"); &#125;&#125; 子类沙拉 123456789101112131415161718package com.design.pattern.simplefactory;import lombok.extern.slf4j.Slf4j;/** * Salad * * @author shunhua * @date 2019-09-09 */@Slf4jpublic class Salad extends Food &#123; @Override public void produce() &#123; log.info(\"生成沙拉!\"); &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.design.pattern.simplefactory;import com.common.base.ObjectUtils;import com.design.pattern.simplefactory.Bread;import com.design.pattern.simplefactory.Food;import com.design.pattern.simplefactory.FoodFactory;import com.design.pattern.simplefactory.Salad;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-09 */public class Client &#123; /* 非简单工厂模式 @Test public void simpleFactoryBefore()&#123; // 这里需要依赖具体的生产类 Food food = new Bread(); Food food1 = new Salad(); food.produce(); food1.produce(); &#125;*/ /* @Test public void simpleFactoryByType()&#123; // 创建一个简单工厂 FoodFactory factory = new FoodFactory(); // 由工厂创建实例对象 Food food = factory.createFood(\"salad\"); food.produce(); &#125; */ @Test public void simpleFactoryByClass()&#123; FoodFactory factory = new FoodFactory(); Food food = factory.createFood(Bread.class); if(ObjectUtils.isNotNull(food))&#123; food.produce(); &#125; &#125;&#125; 简单工厂在源码中的使用jdk的Calendar源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445// 这里使用的是静态方法，因为不需要再通过继承进行扩展。如需扩展就不使用static关键字public static Calendar getInstance(TimeZone zone, Locale aLocale)&#123; return createCalendar(zone, aLocale); &#125; private static Calendar createCalendar(TimeZone zone, Locale aLocale) &#123; CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale).getCalendarProvider(); if (provider != null) &#123; try &#123; return provider.getInstance(zone, aLocale); &#125; catch (IllegalArgumentException iae) &#123; // fall back to the default instantiation &#125; &#125; Calendar cal = null; if (aLocale.hasExtensions()) &#123; String caltype = aLocale.getUnicodeLocaleType(\"ca\"); if (caltype != null) &#123; // 根据不同的类型创建日期对象 switch (caltype) &#123; case \"buddhist\": cal = new BuddhistCalendar(zone, aLocale); break; case \"japanese\": cal = new JapaneseImperialCalendar(zone, aLocale); break; case \"gregory\": cal = new GregorianCalendar(zone, aLocale); break; &#125; &#125; &#125; if (cal == null) &#123; if (aLocale.getLanguage() == \"th\" &amp;&amp; aLocale.getCountry() == \"TH\") &#123; cal = new BuddhistCalendar(zone, aLocale); &#125; else if (aLocale.getVariant() == \"JP\" &amp;&amp; aLocale.getLanguage() == \"ja\" &amp;&amp; aLocale.getCountry() == \"JP\") &#123; cal = new JapaneseImperialCalendar(zone, aLocale); &#125; else &#123; cal = new GregorianCalendar(zone, aLocale); &#125; &#125; return cal; &#125; DriverManager源码解析（通过classForName获取）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public static Connection getConnection(String url, java.util.Properties info) throws SQLException &#123; // Gets the classloader of the code that called this method, may // be null. ClassLoader callerCL = DriverManager.getCallerClassLoader(); return (getConnection(url, info, callerCL)); &#125;// Worker method called by the public getConnection() methods. private static Connection getConnection( String url, java.util.Properties info, ClassLoader callerCL) throws SQLException &#123; java.util.Vector drivers = null; /* * When callerCl is null, we should check the application's * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if(callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; if(url == null) &#123; throw new SQLException(\"The url cannot be null\", \"08001\"); &#125; println(\"DriverManager.getConnection(\\\"\" + url + \"\\\")\"); if (!initialized) &#123; initialize(); &#125; synchronized (DriverManager.class)&#123; // use the readcopy of drivers drivers = readDrivers; &#125; // Walk through the loaded drivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for (int i = 0; i &lt; drivers.size(); i++) &#123; DriverInfo di = (DriverInfo)drivers.elementAt(i); // If the caller does not have permission to load the driver then // skip it. if ( getCallerClass(callerCL, di.driverClassName ) != di.driverClass ) &#123; println(\" skipping: \" + di); continue; &#125; try &#123; println(\" trying \" + di); Connection result = di.driver.connect(url, info); if (result != null) &#123; // Success! println(\"getConnection returning \" + di); return (result); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; // if we got here nobody could connect. if (reason != null) &#123; println(\"getConnection failed: \" + reason); throw reason; &#125; println(\"getConnection: no suitable driver found for \"+ url); throw new SQLException(\"No suitable driver found for \"+ url, \"08001\"); &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"uml基础","slug":"design_pattern/uml","date":"2019-08-27T16:00:00.000Z","updated":"2020-08-04T06:13:21.249Z","comments":true,"path":"posts/cadc5d6c/","link":"","permalink":"https://gentryhuang.com/posts/cadc5d6c/","excerpt":"","text":"定义统一建模语言（缩写UML），非专利的第三代建模和规约语言 特点 UML是一种开放的方法 UML用于说明、可视化、构建和编写一个正在开发的面向对象的、软件密集系统的制品的开放方法 UML展现了一系列最佳工程的实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层面已经被验证有效 UML分类 结构式图形 强调的是系统式的建模，具体包含静态图（类图、对象图、包图）、实现图（组件图、部署图）、剖面图以及复合结构图 行为式图形 强调系统模型中触发的事件，具体包含活动图、状态图以及用例图 交互式图形 属于行为式图形子集合，强调系统模型中资源流程。具体包含通信图、交互概念图、时序图 以及时间图 ​ UML类图用于表示类、接口、实例等之间相互的静态关系。虽然名字叫类图，但类图中并不只有类，还可能包括权限、属性、方法等 UML记忆方式12341. uml箭头：从子类指向父类，只有知道对方信息时才能指向对方方向2. 空心三角箭头：继承或实现，实线-继承：积极的，强关联，关联，通常一个类中有一个类的对象做属性；虚线-实现：消极的，弱关联，依赖3. 空心菱形：聚合，（注：可以看作一个盘子，可以放很多相同的东西（箭头方向所指的类），聚在一起。是has a的关系）弱关联4. 实心菱形：组合，（注：代表器皿里有实体结构存在，组合起来成为一个。是contains-a的关系）强关联 uml箭头：从子类指向父类，定义子类时需要通过extends关键字指定父类，只有知道对方信息时才能指向对方方向 实线-继承 | 虚线-实现 ​ 空心菱形-聚合 实心菱形-组合 组合关系中常见的数字表达 123456◆常见数字表达及含义，假设有A类和B类，数字标记在A类侧◆0..1：0或1个实例 在系统某一时刻，b的实例可以与0个或1个A实例相关◆0..*：0或多个实例 在系统某一时刻，b的实例可以与0个或多个A实例相关◆1..1：1个实例. b的实例可以和1个A实例相关◆1只能有一个实例. b的实例可以和1个A实例相关◆1..*：至少有一个实例. b实例可以与一个或多个A实例相关 UML时序图 是显示对象之间交互的图，这些对象是按照时间顺序排列的 时序图中 包含的建模元素 对象（Actor）、生命线（lifeline）、控制焦点（Focus of control）、消息（Message）等 时序图示例 12345678910111213竖线代表生命线对象：c：client ，s：server，d：device 代表实例消息：箭头代表的元素(open,work等)竖矩形代表实例处于某种活动中，实线实心箭头：代表方法调用，同步调用实线非实心箭头：代表异步调用虚线：代表返回 UML类图讲解1234567891011121314151617+ 公共方法- private权限# protected权限 包内和包外继承的子类都能引用~ default权限（包权限）只有包内能引用下划线 静态 Static斜体 抽象类（或抽象方法）（包含抽象方法的必是抽象类）（类和至少一个方法都是斜体）方法 可以带参，可以不带参 返回值写到冒号后边，void不用加注意：下图类名应该为斜体，因为有抽象方法study（），所以GeelyClass为抽象类，应该为斜体。 UML整体讲解12345678910设计模式中的对象关系: 依赖关系 虚线箭头，箭头方向指向被依赖的部分 组合关系 实心菱形 聚合关系 空心菱形（想象成盘子，盛东西，盘子的多，另一方少） 关联关系 实线箭头，箭头指向被关联的部分 类与类的连接，（它使一个类知道另一个类的属性和方法，关联关 系一般用成员变量实现） 继承 空心三角形实线 实现 空心三角形虚线注意： 实现接口有两种方式，一种是棒棒糖的形式，另一种是虚线空心三角形的方式 UML中部分对比1234567891.1 关联和依赖的对比关联是a类中存在b类对象，企鹅类中有气候类的属性依赖是a类成员方法中有b类的属性，动物新陈代谢方法中有水和空气的属性，只有调这个方法的时候，才可能临时用一下1.2 组合和聚合的对比组合有相同的生命周期，鸟有翅膀，鸟死了，翅膀不复存在大雁群有大雁，一只大雁挂了，大雁群不会消失1.3 继承和实现的对实线：继承虚线：实现","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"Redis原理","slug":"Redis原理","permalink":"https://gentryhuang.com/categories/Redis%E5%8E%9F%E7%90%86/"},{"name":"rpc","slug":"rpc","permalink":"https://gentryhuang.com/categories/rpc/"},{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Redis数据结构","slug":"Redis数据结构","permalink":"https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"dubbo","slug":"dubbo","permalink":"https://gentryhuang.com/tags/dubbo/"},{"name":"rpc","slug":"rpc","permalink":"https://gentryhuang.com/tags/rpc/"},{"name":"spring","slug":"spring","permalink":"https://gentryhuang.com/tags/spring/"},{"name":"设计模式","slug":"设计模式","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}