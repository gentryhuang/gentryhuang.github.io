{"meta":{"title":"gentryhuangâ€˜s blog","subtitle":"blog","description":"åšå®¢","author":"gentryhuang","url":"https://gentryhuang.com","root":"/"},"pages":[{"title":"å…³äºæˆ‘","date":"2020-08-09T08:58:11.880Z","updated":"2020-08-09T08:58:11.880Z","comments":false,"path":"about/index.html","permalink":"https://gentryhuang.com/about/index.html","excerpt":"","text":"123456789101112131415161718&#x2F;**** * â”â”“ â”â”“ * â”ƒ â”ƒ + +* â”ƒ â” â”ƒ ++ + + +* â–ˆâ–ˆâ–ˆâ–ˆâ”â–ˆâ–ˆâ–ˆâ–ˆâ”ƒ ğŸš‚ğŸš‚ğŸš‚-&lt;-&lt; æ¬¢è¿è®¿é—®æˆ‘çš„åšå®¢* â”ƒ â”ƒ + * â”ƒ â”» â”ƒ + + * â”ƒ â”ƒ * â”—â”â”“ â”â”â”›Code is far away from bug with the animal protecting * â”ƒ â”ƒ ç¥å…½æŠ¤ä½“ï¼Œæ°¸æ— bug * â”ƒ â”ƒ +* â”ƒ â”—â”â”â”â”“+* â”ƒ â”£â”“ ğŸ“¬ è”ç³»æˆ‘ï¼šgentryhuang.xw@gmail.com* â”ƒ â”â”› + + * â”—â”“â”“â”â”â”³â”“â”â”› +* â”ƒâ”«â”« â”ƒâ”«â”« * â”—â”»â”› â”—â”»â”› *&#x2F;"},{"title":"åˆ†ç±»","date":"2020-07-03T15:03:26.305Z","updated":"2020-07-03T15:03:26.305Z","comments":false,"path":"categories/index.html","permalink":"https://gentryhuang.com/categories/index.html","excerpt":"","text":""},{"title":"å‹æƒ…é“¾æ¥","date":"2020-07-05T10:07:05.047Z","updated":"2020-07-03T15:03:37.362Z","comments":true,"path":"links/index.html","permalink":"https://gentryhuang.com/links/index.html","excerpt":"","text":""},{"title":"é¡¹ç›®","date":"2020-07-06T16:29:08.229Z","updated":"2020-07-06T16:29:08.229Z","comments":false,"path":"repository/index.html","permalink":"https://gentryhuang.com/repository/index.html","excerpt":"","text":""},{"title":"æ ‡ç­¾","date":"2020-07-03T15:03:56.993Z","updated":"2020-07-03T15:03:56.993Z","comments":false,"path":"tags/index.html","permalink":"https://gentryhuang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RedisåŸç† - é“¾è¡¨","slug":"redis_theory/data_structure/é“¾è¡¨","date":"2021-03-16T11:33:59.000Z","updated":"2021-04-06T08:37:27.429Z","comments":false,"path":"posts/2362a8ea/","link":"","permalink":"https://gentryhuang.com/posts/2362a8ea/","excerpt":"","text":"é“¾è¡¨ redisä¸­çš„é“¾è¡¨ é“¾è¡¨ä½œä¸ºä¸€ç§å¸¸ç”¨çš„æ•°æ®ç»“æ„ï¼Œå†…ç½®åœ¨å¾ˆå¤šé«˜çº§ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå› ä¸ºredisä½¿ç”¨cè¯­è¨€å¹¶æ²¡æœ‰å†…ç½®è¿™ä¸­æ•°æ®ç»“æ„ï¼Œæ‰€ä»¥redisæ„å»ºäº†è‡ªå·±çš„é“¾è¡¨å®ç°ã€‚ redisé“¾è¡¨èŠ‚ç‚¹çš„ç»“æ„ 12345678typedef struct listNode&#123; // å‰ç½®èŠ‚ç‚¹ struct listNode *prev; // åç½®èŠ‚ç‚¹ struct listNode *next; // èŠ‚ç‚¹çš„å€¼ (å¯ç”¨äºä¿å­˜å„ç§ä¸åŒç±»å‹çš„å€¼) void *value&#125;listNode; redisé“¾è¡¨ç»“æ„ 123456789101112131415161718192021typedef struct list &#123; // è¡¨å¤´èŠ‚ç‚¹ listNode *head; // è¡¨å°¾èŠ‚ç‚¹ listNode *tail; // èŠ‚ç‚¹å€¼å¤åˆ¶å‡½æ•°ï¼Œç”¨äºå¤åˆ¶é“¾è¡¨èŠ‚ç‚¹æ‰€ä¿å­˜çš„å€¼ void *(*dup)(void *ptr); // èŠ‚ç‚¹å€¼é‡Šæ”¾å‡½æ•°ï¼Œç”¨äºé‡Šæ”¾é“¾è¡¨èŠ‚ç‚¹æ‰€ä¿å­˜çš„å€¼ void (*free)(void *ptr); // èŠ‚ç‚¹å€¼å¯¹æ¯”å‡½æ•°ï¼Œç”¨äºå¯¹æ¯”é“¾è¡¨èŠ‚ç‚¹æ‰€ä¿å­˜çš„å€¼å’Œå…¶ä»–å€¼æ˜¯å¦ç›¸ç­‰ int (*match)(void *ptr, void *key); // é“¾è¡¨æ‰€åŒ…å«çš„èŠ‚ç‚¹æ•°é‡ unsigned long len;&#125; list; redisé“¾è¡¨çš„ç‰¹ç‚¹ 12345- åŒç«¯ï¼šé“¾è¡¨èŠ‚ç‚¹å¸¦æœ‰prevå’ŒnextæŒ‡é’ˆï¼Œè·å–æŸä¸ªèŠ‚ç‚¹çš„å‰ç½®èŠ‚ç‚¹å’Œåç½®èŠ‚ç‚¹çš„å¤æ‚åº¦éƒ½æ˜¯O(1)- æ— ç¯ï¼šè¡¨å¤´èŠ‚ç‚¹çš„prevæŒ‡é’ˆå’Œè¡¨å°¾èŠ‚ç‚¹çš„nextæŒ‡é’ˆéƒ½æŒ‡å‘NULLï¼Œå¯¹é“¾è¡¨çš„è®¿é—®ä»¥NULLä¸ºç»ˆç‚¹- å¸¦è¡¨å¤´å’Œè¡¨å°¾æŒ‡é’ˆï¼šä½¿ç”¨listç»“æ„çš„headæŒ‡é’ˆå’ŒtailæŒ‡é’ˆï¼Œç¨‹åºè·å–é“¾è¡¨çš„è¡¨å¤´èŠ‚ç‚¹å’Œè¡¨å°¾èŠ‚ç‚¹çš„å¤æ‚åº¦ä¸ºO(1)- å¸¦é“¾è¡¨é•¿åº¦è®¡æ•°å™¨ï¼šç¨‹åºä½¿ç”¨listç»“æ„çš„lenå±æ€§æ ‡è®°é“¾è¡¨ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°ï¼Œç¨‹åºè·å–é“¾è¡¨ä¸­èŠ‚ç‚¹ä¸ªæ•°çš„å¤æ‚åº¦ä¸ºO(1)- å¤šæ€ï¼šé“¾è¡¨å¯ä»¥ä¿å­˜å„ç§ä¸åŒç±»å‹çš„å€¼ é“¾è¡¨åœ¨redisä¸­çš„åº”ç”¨ é“¾è¡¨è¢«å¹¿æ³›ç”¨äºå®ç°redisçš„å„ç§åŠŸèƒ½ï¼Œå¦‚ï¼šåˆ—è¡¨é”®ã€å‘å¸ƒä¸è®¢é˜…ã€æ…¢æŸ¥è¯¢ã€ç›‘è§†å™¨ï¼ŒredisæœåŠ¡å™¨æœ¬èº«è¿˜ä½¿ç”¨é“¾è¡¨æ¥ä¿å­˜å¤šä¸ªå®¢æˆ·ç«¯çš„çŠ¶æ€ä¿¡æ¯ï¼Œä»¥åŠä½¿ç”¨é“¾è¡¨æ¥æ„å»ºå®¢æˆ·ç«¯è¾“å‡ºç¼“å†²åŒºã€‚","categories":[{"name":"Redis","slug":"Redis","permalink":"https://gentryhuang.com/categories/Redis/"}],"tags":[{"name":"Redisæ•°æ®ç»“æ„","slug":"Redisæ•°æ®ç»“æ„","permalink":"https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"RedisåŸç† - ç®€å•åŠ¨æ€å­—ç¬¦ä¸²","slug":"redis_theory/data_structure/ç®€å•åŠ¨æ€å­—ç¬¦ä¸²","date":"2021-03-13T11:00:50.000Z","updated":"2021-04-06T08:37:12.759Z","comments":false,"path":"posts/aa1d8127/","link":"","permalink":"https://gentryhuang.com/posts/aa1d8127/","excerpt":"","text":"ç®€å•åŠ¨æ€å­—ç¬¦ä¸² åˆè¯†åŠ¨æ€å­—ç¬¦ä¸² redisæ²¡æœ‰ç›´æ¥ä½¿ç”¨Cè¯­è¨€ä¼ ç»Ÿçš„å­—ç¬¦ä¸²è¡¨ç¤ºï¼ˆä»¥ç©ºå­—ç¬¦ç»“å°¾çš„å­—ç¬¦æ•°ç»„ï¼‰ï¼Œè€Œæ˜¯è‡ªå·±æ„å»ºäº†ä¸€ç§åä¸ºç®€å•åŠ¨æ€å­—ç¬¦ä¸²ï¼ˆsimple dynamic stringï¼ŒSDSï¼‰çš„æŠ½è±¡ç±»å‹ï¼Œå¹¶å°†SDSä½œä¸ºredisçš„é»˜è®¤å­—ç¬¦ä¸²è¡¨ç¤ºã€‚ åœ¨redisä¸­ï¼Œcå­—ç¬¦ä¸²åªä¼šä½œä¸ºå­—ç¬¦ä¸²å­—é¢é‡ç”¨åœ¨ä¸€äº›æ— é¡»å¯¹å­—ç¬¦ä¸²å€¼è¿›è¡Œä¿®æ”¹çš„åœ°æ–¹ï¼Œæ¯”å¦‚æ—¥å¿—ã€‚å½“Rediséœ€è¦çš„ä¸ä»…ä»…æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²å­—é¢é‡ï¼Œè€Œæ˜¯ä¸€ä¸ªå¯ä»¥è¢«ä¿®æ”¹çš„å­—ç¬¦ä¸²å€¼æ—¶ï¼Œrediså°±ä¼šä½¿ç”¨SDSæ¥è¡¨ç¤ºå­—ç¬¦ä¸²å€¼ã€‚ å€¼çš„æ³¨æ„çš„æ˜¯ï¼Œå¯¹äºredisä¸­çš„keyéƒ½æ˜¯ä½¿ç”¨SDSæ¥å®ç°çš„ã€‚æ­¤å¤–ï¼ŒSDSé™¤äº†ç”¨æ¥ä¿å­˜Redisæ•°æ®åº“ä¸­çš„å­—ç¬¦ä¸²å€¼ä¹‹å¤–ï¼ŒSDSè¿˜è¢«ç”¨ä½œç¼“å†²åŒºï¼ˆbufferï¼‰: AOFæ¨¡å—ä¸­çš„AOFç¼“å†²åŒºï¼Œä»¥åŠå®¢æˆ·ç«¯çŠ¶æ€ä¸­çš„è¾“å…¥ç¼“å†²åŒºã€‚ sdsçš„ç»“æ„ 12345678struct sdshdr&#123; // è®°å½•bufæ•°ç»„ä¸­å·²ä½¿ç”¨å­—èŠ‚çš„æ•°é‡ç­‰ä»·äºsdsæ‰€ä¿å­˜å­—ç¬¦ä¸²çš„é•¿åº¦ int len; // è®°å½•bufæ•°ç»„ä¸­æœªä½¿ç”¨å­—èŠ‚çš„æ•°é‡ int free; // å­—èŠ‚æ•°ç»„ï¼Œç”¨äºä¿å­˜å­—ç¬¦ä¸² char buf[];&#125; æ³¨æ„ï¼š sdséµå¾ªcå­—ç¬¦ä¸²ä»¥ç©ºå­—ç¬¦ç»“å°¾çš„æƒ¯ä¾‹ï¼Œä¿å­˜ç©ºå­—ç¬¦çš„1å­—èŠ‚ç©ºé—´ä¸è®¡ç®—åœ¨sdsçš„lenå±æ€§ä¸­ï¼Œå¹¶ä¸”ä¸ºç©ºå­—ç¬¦åˆ†é…é¢å¤–çš„1å­—èŠ‚ç©ºé—´ï¼Œä»¥åŠæ·»åŠ ç©ºå­—ç¬¦åˆ°å­—ç¬¦ä¸²æœ«å°¾ç­‰æ“ä½œï¼Œéƒ½æ˜¯ç”±sdså‡½æ•°è‡ªåŠ¨å®Œæˆçš„ã€‚éµå¾ªç©ºå­—ç¬¦ç»“å°¾çš„å¥½å¤„æ˜¯ï¼Œsdså¯ä»¥ç›´æ¥ä½¿ç”¨ä¸€éƒ¨åˆ†Cå­—ç¬¦ä¸²å‡½æ•°åº“é‡Œé¢çš„å‡½æ•°ã€‚ sdsä¸cå­—ç¬¦ä¸²çš„åŒºåˆ« cè¯­è¨€ä½¿ç”¨çš„ç®€å•å­—ç¬¦ä¸²è¡¨ç¤ºæ–¹å¼ï¼Œå¹¶ä¸èƒ½æ»¡è¶³rediså¯¹å­—ç¬¦ä¸²åœ¨å®‰å…¨æ€§ã€æ•ˆç‡ä»¥åŠåŠŸèƒ½æ–¹é¢çš„è¦æ±‚ã€‚ 3.1 å¸¸æ•°å¤æ‚åº¦è·å–å­—ç¬¦ä¸²é•¿åº¦ å› ä¸ºcå­—ç¬¦ä¸²å¹¶ä¸è®°å½•è‡ªèº«çš„é•¿åº¦ä¿¡æ¯ï¼Œæ‰€ä»¥è¦è·å–é•¿åº¦å°±å¿…é¡»éå†æ•´ä¸ªå­—ç¬¦ä¸²ï¼Œæ•…è·å–å­—ç¬¦ä¸²é•¿åº¦çš„å¤æ‚åº¦ä¸ºO(N)ã€‚è€Œredisçš„sdsç»“æ„ä¸­é€šè¿‡lenå±æ€§è®°å½•äº†sdsçš„é•¿åº¦ï¼Œæ•…è·å–å­—ç¬¦ä¸²é•¿åº¦çš„å¤æ‚åº¦ä¸ºO(1)ã€‚æ³¨æ„ï¼Œè®¾ç½®å’Œæ›´æ–°sdsé•¿åº¦çš„å·¥ä½œæ˜¯ç”±sdsçš„APIåœ¨æ‰§è¡Œæ—¶è‡ªåŠ¨å®Œæˆçš„ï¼Œä½¿ç”¨sdsæ— é¡»è¿›è¡Œä»»ä½•æ‰‹åŠ¨ä¿®æ”¹é•¿åº¦çš„æ“ä½œã€‚ 3.2 é¿å…ç¼“å†²åŒºæº¢å‡º cå­—ç¬¦ä¸²ä¸è®°å½•è‡ªèº«é•¿åº¦ï¼Œå¾ˆå®¹æ˜“é€ æˆç¼“å†²åŒºæº¢å‡ºã€‚ä¸cå­—ç¬¦ä¸²ä¸åŒï¼Œsdsçš„ç©ºé—´åˆ†é…ç­–ç•¥å®Œå…¨æœç»äº†å‘ç”Ÿç¼“å†²åŒºæº¢å‡ºçš„å¯èƒ½æ€§ï¼Œå½“sds apiéœ€è¦å¯¹sdsè¿›è¡Œä¿®æ”¹æ—¶ï¼Œapiä¼šå…ˆæ£€æŸ¥sdsçš„ç©ºé—´æ˜¯å¦æ»¡è¶³éœ€è¦ï¼Œå¦‚æœä¸æ»¡è¶³çš„è¯ï¼Œapiä¼šè‡ªåŠ¨å°†sdsçš„ç©ºé—´æ‰©å±•è‡³æ‰§è¡Œæ‰€éœ€çš„å¤§å°ï¼Œç„¶åæ‰æ‰§è¡Œå®é™…çš„ä¿®æ”¹æ“ä½œï¼Œå› æ­¤ä½¿ç”¨sdsæ—¢ä¸éœ€è¦æ‰‹åŠ¨ä¿®æ”¹sdsçš„ç©ºé—´å¤§å°ï¼Œä¹Ÿä¸ä¼šå‡ºç°cå­—ç¬¦ä¸²ä¸­å¯èƒ½å‡ºç°çš„ç¼“å†²åŒºæº¢å‡ºé—®é¢˜ã€‚ 1234567891011121314151617sds sdscatlen(sds s, const void *t, size_t len) &#123; size_t curlen = sdslen(s); //è¿½åŠ æ—¶å…ˆè¿›è¡Œæ‰©å®¹ï¼Œåé¢è¯¦ç»†è¯´æ˜ s = sdsMakeRoomFor(s,len); if (s == NULL) return NULL; //æ‹¼æ¥å­—ç¬¦ä¸² memcpy(s+curlen, t, len); sdssetlen(s, curlen+len); s[curlen+len] = '\\0'; return s;&#125;// s:åŸæ•°ç»„ //strlen(t) éœ€æ‹¼æ¥çš„ç›®æ ‡æ•°ç»„çš„é•¿åº¦sds sdscat(sds s, const char *t) &#123; return sdscatlen(s, t, strlen(t));&#125;â€‹ 3.3 å†…å­˜åˆ†é…ä¸é‡Šæ”¾ å› ä¸ºcå­—ç¬¦ä¸²çš„é•¿åº¦å’Œåº•å±‚æ•°ç»„çš„é•¿åº¦ä¹‹é—´å­˜åœ¨ç€å…³è”æ€§ï¼Œæ‰€ä»¥æ¯æ¬¡å¢åŠ æˆ–è€…ç¼©çŸ­ä¸€ä¸ªcå­—ç¬¦ä¸²ï¼Œç¨‹åºéƒ½æ€»è¦å¯¹ä¿å­˜è¿™ä¸ªcå­—ç¬¦ä¸²çš„æ•°å­—è¿›è¡Œä¸€æ¬¡åˆ†é…æ“ä½œï¼Œä½†æ˜¯å†…å­˜åˆ†é…æ“ä½œæ¶‰åŠåˆ°å¤æ‚çš„ç®—æ³•ï¼Œå¹¶ä¸”å¯èƒ½éœ€è¦æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ï¼Œæ‰€ä»¥é€šå¸¸æ˜¯ä¸€ä¸ªæ¯”è¾ƒè€—æ—¶çš„æ“ä½œã€‚redisä½œä¸ºæ•°æ®åº“ï¼Œç»å¸¸è¢«ç”¨äºé€Ÿåº¦è¦æ±‚ä¸¥è‹›ã€æ•°æ®è¢«é¢‘ç¹ä¿®æ”¹çš„åœºåˆï¼Œä¸ºäº†é¿å…cå­—ç¬¦ä¸²çš„è¿™ç§ç¼ºé™·ï¼Œsdsé€šè¿‡æœªä½¿ç”¨ç©ºé—´è§£é™¤äº†å­—ç¬¦ä¸²é•¿åº¦å’Œåº•å±‚æ•°ç»„é•¿åº¦ä¹‹é—´çš„å…³è”ï¼Œé€šè¿‡æœªä½¿ç”¨ç©ºé—´ï¼Œsdså®ç°äº†ç©ºé—´é¢„åˆ†é…å’Œæƒ°æ€§ç©ºé—´é‡Šæ”¾ä¸¤ç§ä¼˜åŒ–ç­–ç•¥ã€‚ ç©ºé—´é¢„åˆ†é… ç©ºé—´é¢„åˆ†é…ç”¨äºä¼˜åŒ–sdsçš„å­—ç¬¦ä¸²å¢é•¿æ“ä½œï¼šå½“sdsçš„apiå¯¹ä¸€ä¸ªsdsè¿›è¡Œä¿®æ”¹ï¼Œå¹¶ä¸”éœ€è¦å¯¹sdsè¿›è¡Œç©ºé—´æ‰©å±•çš„æ—¶å€™ï¼Œç¨‹åºä¸ä»…ä¼šä¸ºsdsåˆ†é…ä¿®æ”¹æ‰€å¿…é¡»è¦çš„ç©ºé—´ï¼Œè¿˜ä¼šä¸ºsdsåˆ†é…é¢å¤–çš„æœªä½¿ç”¨ç©ºé—´ã€‚é€šè¿‡ç©ºé—´é¢„åˆ†é…ç­–ç•¥ï¼Œrediså¯ä»¥å‡å°‘è¿ç»­æ‰§è¡Œå­—ç¬¦ä¸²å¢é•¿æ“ä½œæ‰€éœ€çš„å†…å­˜é‡æ–°åˆ†é…æ¬¡æ•°ï¼Œåœ¨æ‰©å±•sdsç©ºé—´ä¹‹å‰ï¼Œsds api ä¼šå…ˆæ£€æŸ¥æœªä½¿ç”¨ç©ºé—´æ˜¯å¦è¶³å¤Ÿï¼Œå¦‚æœè¶³å¤Ÿå°±ç›´æ¥ä½¿ç”¨æœªä½¿ç”¨ç©ºé—´ï¼Œè€Œä¸éœ€è¦æ‰§è¡Œå†…å­˜é‡æ–°åˆ†é…ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// redis æ‰©å®¹æºç /* * å¯¹ sds ä¸­ buf çš„é•¿åº¦è¿›è¡Œæ‰©å±•ï¼Œç¡®ä¿åœ¨å‡½æ•°æ‰§è¡Œä¹‹åï¼Œ * buf è‡³å°‘ä¼šæœ‰ addlen + 1 é•¿åº¦çš„ç©ºä½™ç©ºé—´ * ï¼ˆé¢å¤–çš„ 1 å­—èŠ‚æ˜¯ä¸º \\0 å‡†å¤‡çš„ï¼‰ * * è¿”å›å€¼ * sds ï¼šæ‰©å±•æˆåŠŸè¿”å›æ‰©å±•åçš„ sds * æ‰©å±•å¤±è´¥è¿”å› NULL * * å¤æ‚åº¦ * T = O(N) */sds sdsMakeRoomFor(sds s, size_t addlen) &#123; struct sdshdr *sh, *newsh; // è·å– s ç›®å‰çš„ç©ºä½™ç©ºé—´é•¿åº¦ size_t free = sdsavail(s); size_t len, newlen; // s ç›®å‰çš„ç©ºä½™ç©ºé—´å·²ç»è¶³å¤Ÿï¼Œæ— é¡»å†è¿›è¡Œæ‰©å±•ï¼Œç›´æ¥è¿”å› if (free &gt;= addlen) return s; // è·å– s ç›®å‰å·²å ç”¨ç©ºé—´çš„é•¿åº¦ len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); // s æœ€å°‘éœ€è¦çš„é•¿åº¦ newlen = (len+addlen); // æ ¹æ®æ–°é•¿åº¦ï¼Œä¸º s åˆ†é…æ–°ç©ºé—´æ‰€éœ€çš„å¤§å° if (newlen &lt; SDS_MAX_PREALLOC) // å¦‚æœæ–°é•¿åº¦å°äº SDS_MAX_PREALLOC // é‚£ä¹ˆä¸ºå®ƒåˆ†é…ä¸¤å€äºæ‰€éœ€é•¿åº¦çš„ç©ºé—´ newlen *= 2; else // å¦åˆ™ï¼Œåˆ†é…é•¿åº¦ä¸ºç›®å‰é•¿åº¦åŠ ä¸Š SDS_MAX_PREALLOC newlen += SDS_MAX_PREALLOC; // T = O(N) newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1); // å†…å­˜ä¸è¶³ï¼Œåˆ†é…å¤±è´¥ï¼Œè¿”å› if (newsh == NULL) return NULL; // æ›´æ–° sds çš„ç©ºä½™é•¿åº¦ newsh-&gt;free = newlen - len; // è¿”å› sds return newsh-&gt;buf;&#125; é¢å¤–åˆ†é…æœªä½¿ç”¨ç©ºé—´æ•°é‡çš„è®¡ç®—ç­–ç•¥ï¼š å¯¹sdsä¿®æ”¹åï¼Œsdsçš„é•¿åº¦ï¼ˆå³lenå±æ€§çš„å€¼ï¼‰å°äº1MBï¼Œé‚£ä¹ˆç¨‹åºåˆ†é…å’Œlenå±æ€§åŒæ ·å¤§å°çš„æœªä½¿ç”¨ç©ºé—´ï¼Œè¿™æ—¶sdsçš„lenå±æ€§çš„å€¼å°†å’Œfreeå±æ€§çš„å€¼ç›¸åŒã€‚ä¾‹å¦‚ï¼šä¿®æ”¹åsdsçš„lenå˜æˆ10å­—èŠ‚ï¼Œé‚£ä¹ˆç¨‹åºä¹Ÿä¼šåˆ†é…10å­—èŠ‚çš„æœªä½¿ç”¨ç©ºé—´ï¼Œsdsçš„bufæ•°ç»„çš„å®é™…é•¿åº¦ï¼š10 + 10 + 1 = 21å­—èŠ‚ å¯¹sdsä¿®æ”¹åï¼Œsdsçš„é•¿åº¦å¤§äºç­‰äº1MBï¼Œé‚£ä¹ˆç¨‹åºä¼šåˆ†é…1MBçš„æœªä½¿ç”¨ç©ºé—´ã€‚ä¾‹å¦‚ï¼šä¿®æ”¹åsdsçš„lenå˜æˆ30MBï¼Œé‚£ä¹ˆç¨‹åºä¼šåˆ†é…1MBçš„æœªä½¿ç”¨ç©ºé—´ï¼Œsdsçš„bufæ•°ç»„çš„æ—¶é—´é•¿åº¦ï¼š30MB + 1MB + 1byte æƒ°æ€§ç©ºé—´é‡Šæ”¾ æƒ°æ€§ç©ºé—´é‡Šæ”¾ç”¨äºä¼˜åŒ–sdsçš„å­—ç¬¦ä¸²ç¼©çŸ­æ“ä½œï¼šå½“sdsçš„apiéœ€è¦ç¼©çŸ­sdsä¿å­˜çš„å­—ç¬¦ä¸²æ—¶ï¼Œç¨‹åºå¹¶ä¸ç«‹å³ä½¿ç”¨å†…å­˜é‡åˆ†é…æ¥å›æ”¶ç¼©çŸ­åå¤šæ¥çš„å­—èŠ‚ï¼Œè€Œæ˜¯ä½¿ç”¨freeå±æ€§å°†è¿™äº›å­—èŠ‚çš„æ•°é‡çºªå½•èµ·æ¥ï¼Œç”¨äºå°†æ¥å¯¹sdsè¿›è¡Œå¢é•¿æ“ä½œæ—¶ï¼Œè¿™äº›æœªä½¿ç”¨ç©ºé—´å¯èƒ½å°±æ´¾ä¸Šç”¨åœºäº†ã€‚æ³¨æ„ï¼Œsdsä¹Ÿæä¾›äº†ç›¸åº”çš„apiï¼Œå¯ä»¥çœŸæ­£åœ°é‡Šæ”¾sdsçš„æœªä½¿ç”¨ç©ºé—´ï¼Œæ‰€ä»¥ä¸ç”¨æ‹…å¿ƒæƒ°æ€§ç©ºé—´é‡Šæ”¾ç­–ç•¥ä¼šé€ æˆå†…å­˜æµªè´¹ã€‚ 3.4 äºŒè¿›åˆ¶å®‰å…¨ cå­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦å¿…é¡»ç¬¦åˆæŸç§ç¼–ç ï¼Œå¹¶ä¸”é™¤äº†å­—ç¬¦ä¸²çš„æœ«å°¾ä¹‹å¤–ï¼Œå­—ç¬¦ä¸²é‡Œä¸èƒ½åŒ…å«ç©ºå­—ç¬¦ï¼Œå¦åˆ™åœ¨è¯»å–çš„æ—¶å€™ä¼šè¢«é»˜è®¤ä¸ºç»“æŸå­—ç¬¦ï¼Œè¿™äº›é™åˆ¶ä½¿å¾—cå­—ç¬¦ä¸²åªèƒ½ä¿å­˜æ–‡æœ¬æ•°æ®ï¼Œä¸èƒ½ä¿å­˜å›¾ç‰‡ã€éŸ³è§†é¢‘ã€å‹ç¼©æ–‡ä»¶è¿™ç±»çš„äºŒè¿›åˆ¶æ•°æ®ã€‚sdsçš„apiéƒ½æ˜¯äºŒè¿›åˆ¶å®‰å…¨çš„ï¼Œæ‰€æœ‰çš„sds apiéƒ½ä¼šä»¥äºŒè¿›åˆ¶çš„æ–¹å¼å¤„ç†sdså­˜æ”¾åœ¨bufæ•°ç»„é‡Œçš„æ•°æ®,ç¨‹åºä¸ä¼šå¯¹å…¶ä¸­çš„æ•°æ®åšä»»ä½•é™åˆ¶ã€è¿‡æ»¤ï¼Œæ•°æ®å†™å…¥æ—¶æ˜¯ä»€ä¹ˆæ ·ï¼Œå®ƒè¢«è¯»å–æ—¶å°±æ˜¯ä»€ä¹ˆæ ·ã€‚è¿™ä¹Ÿæ˜¯å°†sdsçš„bufå±æ€§ç§°ä¸ºå­—èŠ‚æ•°ç»„çš„åŸå› ï¼Œredisä¸æ˜¯ç”¨è¿™ä¸ªæ•°ç»„æ¥ä¿å­˜å­—ç¬¦ï¼Œè€Œæ˜¯ç”¨å®ƒæ¥ä¿å­˜ä¸€ç³»åˆ—äºŒè¿›åˆ¶æ•°æ®ã€‚ cå­—ç¬¦ä¸²å’Œsdsä¹‹é—´çš„åŒºåˆ« 123456 Cå­—ç¬¦ä¸² SDS- è·å–å­—ç¬¦ä¸²é•¿åº¦çš„å¤æ‚åº¦ä¸ºOï¼ˆnï¼‰ è·å–å­—ç¬¦ä¸²é•¿åº¦çš„å¤æ‚åº¦Oï¼ˆ1ï¼‰- APIæ˜¯ä¸å®‰å…¨çš„ï¼Œå¯èƒ½é€ æˆç¼“å†²åŒºæº¢å‡º APIæ˜¯å®‰å…¨çš„- ä¿®æ”¹å­—ç¬¦ä¸²é•¿åº¦Næ¬¡ï¼Œå¿…ç„¶è¦æ‰§è¡ŒNæ¬¡å†…å­˜é‡åˆ†é… ä¿®æ”¹å­—ç¬¦é•¿åº¦Næ¬¡ï¼Œæœ€å¤šæ‰§è¡ŒNæ¬¡å†…å­˜é‡åˆ†é…- åªèƒ½ä¿å­˜æ–‡æœ¬æ•°æ® å¯ä»¥ä¿å­˜æ–‡æœ¬æˆ–è€…äºŒè¿›åˆ¶æ•°æ®- å¯ä½¿ç”¨&lt;string.h&gt;åº“ä¸­çš„å‡½æ•° å¯ä½¿ç”¨ä¸€éƒ¨åˆ†&lt;string.h&gt;åº“ä¸­çš„å‡½æ•° sdsæ›´å¤šçš„apiå¯å‚è€ƒæºç ","categories":[{"name":"Redis","slug":"Redis","permalink":"https://gentryhuang.com/categories/Redis/"}],"tags":[{"name":"Redisæ•°æ®ç»“æ„","slug":"Redisæ•°æ®ç»“æ„","permalink":"https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Dubboæºç åˆ†æ - å¼‚æ­¥æ”¹é€ ","slug":"rpc/Dubboå¼‚æ­¥æ”¹é€ ","date":"2021-02-13T16:00:00.000Z","updated":"2021-04-06T08:30:21.668Z","comments":false,"path":"posts/c812f120/","link":"","permalink":"https://gentryhuang.com/posts/c812f120/","excerpt":"","text":"æ¦‚è¿°ä» 2.7.0 ç‰ˆæœ¬å¼€å§‹ï¼ŒDubbo çš„æ‰€æœ‰å¼‚æ­¥ç¼–ç¨‹æ¥å£å¼€å§‹ä»¥ CompletableFuture ä¸ºåŸºç¡€ï¼Œä¸ä»…æ”¯æŒäº†æœåŠ¡æä¾›æ–¹çš„å¼‚æ­¥æ‰§è¡Œï¼Œè€Œä¸”å¯¹å½“å‰çš„å¼‚æ­¥è°ƒç”¨åŠŸèƒ½è¿›è¡Œäº†å¢å¼ºã€‚å¼‚æ­¥æ”¹é€ å¼•å…¥äº†ä¸€äº›åŠŸèƒ½æ¥å£å’Œå®ç°ï¼Œä»¥åŠå¯¹éƒ¨åˆ†é€»è¾‘è¿›è¡Œäº†è°ƒæ•´ï¼Œä½†åº•å±‚é€»è¾‘å¹¶æ²¡æœ‰æ”¹å˜ï¼Œæœ¬ç¯‡æ–‡ç« å°†å¯¹ Dubbo çš„å¼‚æ­¥æ¼”è¿›è¿›è¡Œä»‹ç»ã€‚ è°ƒç”¨æ–¹å¼ Dubbo çš„è¿œç¨‹è°ƒç”¨ä¸­å¤§è‡´å¯ä»¥åˆ†ä¸ºä»¥ä¸Š 4 ç§è°ƒç”¨æ–¹å¼ï¼š oneway: å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯åï¼Œä¸éœ€è¦æ¥æ”¶å“åº”ã€‚å¯¹äºä¸éœ€è¦å…³å¿ƒæœåŠ¡å“åº”ç»“æœçš„è¯·æ±‚é€‚åˆ oneway é€šä¿¡ã€‚ sync: Dubbo é»˜è®¤çš„é€šä¿¡æ–¹å¼ï¼Œå³åŒæ­¥è°ƒç”¨ã€‚ async: å¼‚æ­¥è°ƒç”¨èŒƒç•´ï¼Œä½¿ç”¨ Future çš„æ–¹å¼è·å–ç»“æœã€‚ future: å¼‚æ­¥è°ƒç”¨èŒƒç•´ï¼Œä½¿ç”¨ CompletableFuture è·å–ç»“æœï¼Œä¹Ÿæ”¯æŒé€šè¿‡ Future çš„æ–¹å¼è·å–ç»“æœã€‚ æ³¨æ„ï¼š Dubbo ä¸­çš„è°ƒç”¨æ–¹å¼å¯ä»¥åˆ†ä¸ºä¸¤å¤§ç±»ï¼Œoneway å’Œ twoway ï¼Œå¯¹äº Dubbo åè®®æ¥è¯´ï¼Œä¼šå¯¹è¿™ä¸¤ç§æ–¹å¼åšåˆ†åˆ«å¤„ç†ï¼Œå¯¹äºé Dubbo åè®®ä¸ä¼šç‰¹åˆ«åŒºåˆ†ã€‚ Dubbo 2.6.x å¼‚æ­¥å®ç°Dubbo 2.6.x çš„å¼‚æ­¥å®ç°æ˜¯é’ˆå¯¹æ¶ˆè´¹ç«¯å¼‚æ­¥ï¼Œåªéœ€æŒ‡å®šè°ƒç”¨æ–¹å¼ä¸ºå¼‚æ­¥è°ƒç”¨ï¼Œå¹¶åœ¨éœ€è¦ç»“æœçš„åœ°æ–¹ä» RpcContext ä¸­å–å‡º Future è·å–ç»“æœå³å¯ã€‚ å®ç°æ–¹å¼ æŒ‡å®šå¼‚æ­¥è°ƒç”¨12&lt;!-- è®¾ç½® async = trueï¼Œè¡¨ç¤ºå¼‚æ­¥è°ƒç”¨ã€‚é»˜è®¤æ˜¯ falseï¼ŒåŒæ­¥è°ƒç”¨ --&gt;&lt;dubbo:reference id=\"demoService\" check=\"false\" interface=\"com.alibaba.dubbo.demo.DemoService\" async=\"true\"/&gt; é€šè¿‡ä¸Šä¸‹æ–‡å–å‡º Future123String hello = demoService.sayHello(\"world\"); // call remote methodFuture&lt;String&gt; future = RpcContext.getContext().getFuture();String result = future.get(); å…·ä½“è°ƒç”¨å®ç°å¯ä»¥å‚è€ƒ Dubboå¼‚æ­¥è°ƒç”¨ ã€‚ å­˜åœ¨é—®é¢˜Dubbo 2.6.x æä¾›äº†ä¸€å®šçš„å¼‚æ­¥ç¼–ç¨‹èƒ½åŠ›ï¼Œä½†å…¶å¼‚æ­¥æ–¹å¼å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š Future è·å–æ–¹å¼ä¸å¤Ÿç›´æ¥ï¼Œä¸šåŠ¡æ–¹éœ€è¦ä» RpcContext ä¸­è·å–ã€‚å¦‚æœåŒæ—¶è¿›è¡Œå¤šä¸ªå¼‚æ­¥è°ƒç”¨ï¼Œå¦‚æœä½¿ç”¨ä¸å½“å¾ˆå®¹æ˜“é€ æˆä¸Šä¸‹æ–‡æ±¡æŸ“ã€‚ Future æ¥å£æ— æ³•å®ç°è‡ªåŠ¨å›è°ƒï¼Œè€Œä¸”å®šä¹‰çš„ ResponseFure (2.7 å·²ç»åºŸå¼ƒ)è™½ç„¶æ”¯æŒå›è°ƒï¼Œä½†æ”¯æŒçš„å¼‚æ­¥åœºæ™¯æœ‰é™ï¼Œå¹¶ä¸”ä¸æ”¯æŒ Future é—´çš„ç›¸äº’åè°ƒã€‚ ä¸æ”¯æŒæœåŠ¡ç«¯å¼‚æ­¥ã€‚ Dubbo 2.7.x å¼‚æ­¥å®ç°Dubbo 2.7.x å¼‚æ­¥æ”¹é€ æ˜¯å¯¹ Dubbo 2.6.x å¼‚æ­¥åŠŸèƒ½çš„å¢å¼ºï¼Œå¼•å…¥çš„ CompletableFuture æ—¢æ”¯æŒ Future åˆæ”¯æŒ Callback çš„è°ƒç”¨æ–¹å¼ï¼Œä½¿ç”¨æ–¹å¯ä»¥æ ¹æ®éœ€è¦è‡ªè¡Œé€‰æ‹©ã€‚ åŸºç¡€æ¨¡å‹Dubbo 2.7.x å¯¹å¼‚æ­¥å®ç°è¿›è¡Œäº†æ”¹é€ ï¼Œå¼•å…¥äº†ç›¸å…³çš„æ¥å£å’Œå®ç°ç±»ï¼Œå¼‚æ­¥å®ç°éœ€è¦è¿™äº›ç›¸å…³çš„åŸºç¡€æ¨¡å‹é…åˆå®Œæˆã€‚ä¸‹é¢æˆ‘ä»¬å…ˆå¯¹åŸºç¡€æ¨¡å‹è¿›è¡Œä»‹ç»ã€‚ ResultResult ç›¸å…³çš„ç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š åœ¨ Dubbo 2.6.x ä¸­ç»Ÿä¸€ä½¿ç”¨ RpcResult è¡¨ç¤ºè°ƒç”¨ç»“æœï¼ŒDubbo 2.7.x ä¸­åºŸå¼ƒäº† RpcResult ï¼Œé‡‡ç”¨ä»¥ä¸‹ä¸‰ä¸ªå¯¹è±¡è¡¨ç¤ºç»“æœçŠ¶æ€ã€‚ AsyncRpcResult è¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªå¼‚æ­¥çš„ã€æœªå®Œæˆçš„RPCè°ƒç”¨ï¼Œæ˜¯åœ¨è°ƒç”¨é“¾ä¸­å®é™…ä¼ é€’çš„å¯¹è±¡ã€‚ AppResponse è¡¨ç¤ºçš„æ˜¯æœåŠ¡ç«¯è¿”å›çš„å…·ä½“å“åº”ï¼Œç›¸å½“äº Dubbo 2.6.x ä¸­çš„ RpcResult ã€‚å…¶å­ç±»æ˜¯ DecodeableRpcResultã€‚ CompletableFuture è¡¨ç¤ºçš„æ˜¯æœåŠ¡ç«¯è¿”å›çš„ç»“æœï¼Œç”±è°ƒç”¨ç«¯åˆ›å»ºï¼Œç”¨äºå°è£… AppResponse å¯¹è±¡ã€‚å…¶ä¸­ DefaultFuture ç»§æ‰¿è¯¥ç±»ã€‚ ä¸‰è€…å…³ç³»ï¼šAppResponse -&gt; CompletableFuture -&gt; AsyncResult ï¼Œä¸‹é¢æˆ‘ä»¬å¯¹å…¶è¿›è¡Œä»‹ç»ã€‚ AppResponse1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class AppResponse implements Result &#123; private static final long serialVersionUID = -6925924956850004727L; // å“åº”ç»“æœ private Object result; // è¿”å›çš„å¼‚å¸¸ä¿¡æ¯ private Throwable exception; // è¿”å›çš„é™„åŠ ä¿¡æ¯ private Map&lt;String, Object&gt; attachments = new HashMap&lt;&gt;(); public AppResponse() &#123; &#125; public AppResponse(Object result) &#123; this.result = result; &#125; public AppResponse(Throwable exception) &#123; this.exception = exception; &#125; @Override public Object recreate() throws Throwable &#123; // 1 å¼‚å¸¸å¤„ç† if (exception != null) &#123; // fix issue#619 try &#123; // get Throwable class Class clazz = exception.getClass(); while (!clazz.getName().equals(Throwable.class.getName())) &#123; clazz = clazz.getSuperclass(); &#125; // get stackTrace value Field stackTraceField = clazz.getDeclaredField(\"stackTrace\"); stackTraceField.setAccessible(true); Object stackTrace = stackTraceField.get(exception); if (stackTrace == null) &#123; exception.setStackTrace(new StackTraceElement[0]); &#125; &#125; catch (Exception e) &#123; // ignore &#125; throw exception; &#125; // 2 ç»“æœ return result; &#125; // çœç•¥å…¶å®ƒæ–¹æ³• getter/setter æ–¹æ³•&#125; AppResponse æ˜¯è°ƒç”¨çš„å®é™…è¿”å›ç±»å‹ï¼Œç›¸å½“äº Dubbo 2.6.x ä¸­çš„ RpcResult ï¼Œç†è®ºä¸Šä¸éœ€è¦å®ç° Result æ¥å£ï¼Œè¿™æ ·åšæ˜¯ä¸ºäº†å…¼å®¹ã€‚ DecodeableRpcResultå±æ€§123456789101112131415161718192021222324252627public class DecodeableRpcResult extends AppResponse implements Codec, Decodeable &#123; private static final Logger log = LoggerFactory.getLogger(DecodeableRpcResult.class); // é€šé“ private Channel channel; // åºåˆ—åŒ–ç±»å‹ private byte serializationType; // åºåˆ—åŒ–ç›¸å…³çš„è¾“å…¥æµ private InputStream inputStream; // å“åº”å¯¹è±¡ private Response response; // è°ƒç”¨ä¿¡æ¯ private Invocation invocation; // æ ‡å¿—æ˜¯å¦å·²ç»è§£ç  private volatile boolean hasDecoded; public DecodeableRpcResult(Channel channel, Response response, InputStream is, Invocation invocation, byte id) &#123; Assert.notNull(channel, \"channel == null\"); Assert.notNull(response, \"response == null\"); Assert.notNull(is, \"inputStream == null\"); this.channel = channel; this.response = response; this.inputStream = is; this.invocation = invocation; this.serializationType = id; &#125;&#125; è§£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697+--- DecodeableRpcResult @Override public void decode() throws Exception &#123; // æ²¡æœ‰è§£ç ï¼Œåˆ™è¿›è¡Œè§£ç  if (!hasDecoded &amp;&amp; channel != null &amp;&amp; inputStream != null) &#123; try &#123; // è§£ç  decode(channel, inputStream); &#125; catch (Throwable e) &#123; if (log.isWarnEnabled()) &#123; log.warn(\"Decode rpc result failed: \" + e.getMessage(), e); &#125; response.setStatus(Response.CLIENT_ERROR); response.setErrorMessage(StringUtils.toString(e)); &#125; finally &#123; hasDecoded = true; &#125; &#125; &#125;---@Override public Object decode(Channel channel, InputStream input) throws IOException &#123; if (log.isDebugEnabled()) &#123; Thread thread = Thread.currentThread(); log.debug(\"Decoding in thread -- [\" + thread.getName() + \"#\" + thread.getId() + \"]\"); &#125; // 1 ç¡®å®šåºåˆ—åŒ–æ–¹å¼ï¼Œç”¨äºååºåˆ—åŒ– ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType) .deserialize(channel.getUrl(), input); // 2 è¯»å–ä¸€ä¸ª byte çš„æ ‡å¿—ä½ï¼Œå…¶å€¼å¯èƒ½æœ‰ 6 ç§ byte flag = in.readByte(); // 3 æ ¹æ®æ ‡å¿—ä½åˆ¤æ–­å½“å‰ç»“æœä¸­åŒ…å«çš„ä¿¡æ¯ï¼Œå¹¶è°ƒç”¨ä¸åŒçš„æ–¹æ³•è¿›è¡Œå¤„ç† switch (flag) &#123; case DubboCodec.RESPONSE_NULL_VALUE: break; case DubboCodec.RESPONSE_VALUE: handleValue(in); break; case DubboCodec.RESPONSE_WITH_EXCEPTION: handleException(in); break; case DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS: handleAttachment(in); break; case DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS: // æ ¹æ® RpcInvocation ä¸­è®°å½•çš„è¿”å›å€¼ç±»å‹è¯»å–è¿”å›ç»“æœï¼Œå¹¶è®¾ç½®åˆ°å½“å‰ç±»çš„ result å­—æ®µ handleValue(in); // è¯»å–é™„åŠ ä¿¡æ¯å¹¶è®¾ç½®åˆ°å½“å‰ç±»çš„ attachmetns ä¸­ handleAttachment(in); break; case DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS: handleException(in); handleAttachment(in); break; default: throw new IOException(\"Unknown result flag, expect '0' '1' '2' '3' '4' '5', but received: \" + flag); &#125; if (in instanceof Cleanable) &#123; ((Cleanable) in).cleanup(); &#125; return this; &#125; ---/** * å¤„ç†ç»“æœ * * @param in * @throws IOException */ private void handleValue(ObjectInput in) throws IOException &#123; try &#123; // 1 è¿”å›ç»“æœç±»å‹ Type[] returnTypes; if (invocation instanceof RpcInvocation) &#123; returnTypes = ((RpcInvocation) invocation).getReturnTypes(); &#125; else &#123; returnTypes = RpcUtils.getReturnTypes(invocation); &#125; // 2 æ ¹æ®è¿”å›ç»“æœç±»å‹è·å–ç»“æœ Object value = null; if (ArrayUtils.isEmpty(returnTypes)) &#123; // This almost never happens? value = in.readObject(); &#125; else if (returnTypes.length == 1) &#123; value = in.readObject((Class&lt;?&gt;) returnTypes[0]); &#125; else &#123; value = in.readObject((Class&lt;?&gt;) returnTypes[0], returnTypes[1]); &#125; // 3 è®¾ç½®ç»“æœ result setValue(value); &#125; catch (ClassNotFoundException e) &#123; rethrow(e); &#125; &#125; DecodeableRpcResult ä¸»è¦å¯¹å“åº”ç»“æœè¿›è¡Œè§£ç ï¼Œä»å­—èŠ‚æµä¸­è·å–æ•°æ®å¯¹è±¡ã€‚ CompletableFutureCompletableFuture æ˜¯ Java 8 æä¾›çš„å¼‚æ­¥ç¼–ç¨‹ç±»ï¼ŒDubbo 2.7.x ä¸­çš„ DefaultFuture ç»§æ‰¿äº† CompletableFuture ï¼ŒDubbo åè®®ä¸‹å¯¹äº twoway è¯·æ±‚éƒ½ä¼šè¿”å›ä¸€ä¸ª DefaultFuutre å¯¹è±¡ã€‚æ­¤å¤–ï¼ŒDefaultFuture æ”¯æŒåœ¨è¯·æ±‚çš„æ—¶å€™æŒ‡å®šçº¿ç¨‹æ± ï¼Œç”¨æ¥å¤„ç†è¯·æ±‚çš„å“åº”ï¼Œå…·ä½“çš„æˆ‘ä»¬ä¼šåœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­åˆ†æã€‚ AsyncRpcResultAsyncRpcResult æ˜¯åœ¨è°ƒç”¨é“¾ä¸­å®é™…ä¼ é€’çš„å¯¹è±¡ï¼Œè¡¨ç¤ºä¸€ä¸ªå¼‚æ­¥çš„ï¼Œæœªå®Œæˆçš„RPCè°ƒç”¨ã€‚æ³¨æ„ï¼Œå®ƒå¹¶ä¸æ˜¯å®é™…çš„è°ƒç”¨ç»“æœï¼ŒAppResponse æ‰æ˜¯ä¸šåŠ¡ç»“æœã€‚ å±æ€§12345678910111213141516171819202122232425public class AsyncRpcResult implements Result &#123; private static final Logger logger = LoggerFactory.getLogger(AsyncRpcResult.class); // å½“å›è°ƒå‘ç”Ÿæ—¶ï¼ŒRpcContext å¯èƒ½å·²ç»è¢«æ›´æ”¹ã€‚å³æ‰§è¡Œ AsyncRpcResult ä¸Šæ·»åŠ çš„å›è°ƒæ–¹æ³•çš„çº¿ç¨‹å¯èƒ½å…ˆåå¤„ç†è¿‡å¤šä¸ªä¸åŒçš„ AsyncRpcResult ã€‚ // å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥ä¿ç•™å½“å‰RpcContextå®ä¾‹çš„å¼•ç”¨ï¼Œå¹¶åœ¨å›è°ƒæ‰§è¡Œä¹‹å‰æ¢å¤å®ƒã€‚ private RpcContext storedContext; private RpcContext storedServerContext; // æ­¤æ¬¡ RPC è°ƒç”¨å…³è”çš„çº¿ç¨‹æ±  private Executor executor; // æ­¤æ¬¡ RPC è°ƒç”¨å…³è”çš„ Invocation å¯¹è±¡ private Invocation invocation; // è¯·æ±‚è¿”å›çš„å¯¹è±¡ ï¼ˆç”±è°ƒç”¨ç«¯åˆ›å»ºï¼‰ private CompletableFuture&lt;AppResponse&gt; responseFuture; // åœ¨æ„é€ æ–¹æ³•ä¸­é™¤äº†æ¥æ”¶å‘é€è¯·æ±‚è¿”å›çš„ CompletableFuture&lt;AppResponse&gt; å¯¹è±¡ï¼Œè¿˜ä¼šä¿å­˜å½“å‰çš„ RPC ä¸Šä¸‹æ–‡ public AsyncRpcResult(CompletableFuture&lt;AppResponse&gt; future, Invocation invocation) &#123; this.responseFuture = future; this.invocation = invocation; this.storedContext = RpcContext.getContext(); this.storedServerContext = RpcContext.getServerContext(); &#125;&#125; éœ€è¦è¯´æ˜çš„æ˜¯ï¼ŒresponseFuture å±æ€§ä¸ä»…é’ˆå¯¹ Dubbo åè®®ï¼ŒHTTPç­‰åè®®è°ƒç”¨è¿”å›ç»“æœä¹Ÿæ˜¯ CompletableFuture å¯¹è±¡ï¼Œéƒ½æ˜¯ç”±è°ƒç”¨ç«¯åˆ›å»ºã€‚åŒºåˆ«åœ¨äº Dubbo åè®®ä¸€èˆ¬è¿”å›çš„æ˜¯ DefaultFuture å¯¹è±¡ï¼Œè€Œ HTTP ç­‰åè®®ä¼šæ„é€ ä¸€ä¸ª CompletableFuture å¯¹è±¡ï¼Œæˆ‘ä»¬ä¼šåœ¨ä¸‹é¢å†…å®¹æåˆ°ã€‚ è·å–ç»“æœAsyncRpcResult è·å–ç»“æœæœ¬è´¨ä¸Šéœ€è¦å…ˆè·å–å‘é€è¯·æ±‚è¿”å›çš„ CompletableFuture ï¼Œä¹Ÿå°±æ˜¯ responseFuture å±æ€§ï¼Œç„¶åå†ä» responseFuture ä¸­è·å– AppResponse å¯¹è±¡ï¼Œæœ€åè°ƒç”¨å…¶å¯¹åº”çš„æ–¹æ³•ã€‚ è·å– CompletableFuture1234+--- AsyncRpcResult public CompletableFuture&lt;AppResponse&gt; getResponseFuture() &#123; return responseFuture; &#125; è·å– AppResponse123456789101112131415+--- AsyncRpcResult public Result getAppResponse() &#123; try &#123; // å¦‚æœå®Œæˆï¼Œåˆ™è·å– AppResponse if (responseFuture.isDone()) &#123; return responseFuture.get(); &#125; &#125; catch (Exception e) &#123; // This should not happen in normal request process; logger.error(\"Got exception when trying to fetch the underlying result from AsyncRpcResult.\"); throw new RpcException(e); &#125; // è·å–é»˜è®¤çš„ AppResponse return createDefaultValue(invocation); &#125; 12345678910111213141516171819202122232425262728+--- AsyncRpcResult /** * è¯¥æ–¹æ³•å°†å§‹ç»ˆåœ¨æœ€å¤§ timeout ç­‰å¾…ä¹‹åè¿”å›ï¼š * 1. å¦‚æœvalueåœ¨è¶…æ—¶å‰è¿”å›ï¼Œåˆ™æ­£å¸¸è¿”å›ã€‚ * 2. å¦‚æœtimeoutä¹‹åæ²¡æœ‰è¿”å›å€¼ï¼Œåˆ™æŠ›å‡ºTimeoutExceptionã€‚ * * @return * @throws InterruptedException * @throws ExecutionException */ @Override public Result get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123; // é’ˆå¯¹ ThreadlessExecutor çš„ç‰¹æ®Šå¤„ç†ï¼Œè¿™é‡Œè°ƒç”¨ waitAndDrain() ç­‰å¾…å“åº” if (executor != null &amp;&amp; executor instanceof ThreadlessExecutor) &#123; ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor; threadlessExecutor.waitAndDrain(); &#125; return responseFuture.get(timeout, unit); &#125; @Override public Result get() throws InterruptedException, ExecutionException &#123; if (executor != null &amp;&amp; executor instanceof ThreadlessExecutor) &#123; ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor; threadlessExecutor.waitAndDrain(); &#125; return responseFuture.get(); &#125; å…¶ä¸­ ThreadlessExecutor æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„çº¿ç¨‹æ± ï¼Œä¸»è¦ç”¨æ¥è§£å†³åŒæ­¥è°ƒç”¨æ¨¡å¼ä¸‹çš„å“åº”ï¼Œæ˜¯å¯¹çº¿ç¨‹æ¨¡å‹çš„ä¼˜åŒ–ï¼Œæˆ‘ä»¬åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­è¿›è¡Œè¯¦ç»†è¯´æ˜ã€‚ è·å–ç»“æœ123456789101112+--- AsyncRpcResult @Override public Object recreate() throws Throwable &#123; RpcInvocation rpcInvocation = (RpcInvocation) invocation; // 1 å¦‚æœæ˜¯æœåŠ¡ç«¯çš„å¼‚æ­¥å®ç°ï¼Œåˆ™ä»ä¸Šä¸‹æ–‡ä¸­å–ã€‚ // ä¸ºä»€ä¹ˆï¼Ÿ å› ä¸ºæ¥å£è¿”å›çš„ç»“æœæ˜¯ CompletableFuture,å±äºå¼‚æ­¥èŒƒç•´ï¼ˆæœåŠ¡ç«¯çš„å¼‚æ­¥ï¼‰ï¼Œå’Œæ¶ˆè´¹ç«¯å¼‚æ­¥ç±»ä¼¼ã€‚ if (InvokeMode.FUTURE == rpcInvocation.getInvokeMode()) &#123; return RpcContext.getContext().getFuture(); &#125; // 2 è·å– AppResponse ä¸­çš„ç»“æœ return getAppResponse().recreate(); &#125; AsyncRpcResult.recreate() æ–¹æ³•æ˜¯è·å–ç»“æœçš„æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯ä» AppResponse ä¸­è·å–ç»“æœã€‚ æ·»åŠ å›è°ƒå›è°ƒæ˜¯ Dubbo 2.7.x å¼‚æ­¥æ”¹é€ çš„é‡è¦è§’è‰²ï¼ŒAsyncRpcResult æ”¯æŒæ·»åŠ å›è°ƒæ–¹æ³•ï¼Œè€Œè¿™ä¸ªå›è°ƒæ–¹æ³•ä¼šè¢«åŒ…è£…ä¸€å±‚å¹¶æ³¨å†Œåˆ° responseFuture ä¸Šï¼Œå…·ä½“å®ç°å¦‚ä¸‹ï¼š 12345678910111213+--- AsyncRpcResult public Result whenCompleteWithContext(BiConsumer&lt;Result, Throwable&gt; fn) &#123; // åœ¨responseFutureä¹‹ä¸Šæ³¨å†Œå›è°ƒ this.responseFuture = this.responseFuture.whenComplete((v, t) -&gt; &#123; // å°†å½“å‰çº¿ç¨‹çš„ RpcContext è®°å½•åˆ°ä¸´æ—¶å±æ€§ä¸­ï¼Œç„¶åå°†æ„é€ å‡½æ•°ä¸­å­˜å‚¨çš„ RpcContext è®¾ç½®åˆ°å½“å‰çº¿ç¨‹ä¸­ï¼Œä¸ºåé¢çš„å›è°ƒæ‰§è¡Œåšå‡†å¤‡ beforeContext.accept(v, t); // æ‰§è¡Œå›è°ƒ ï¼ˆä½¿ç”¨çš„ RpcContext æ˜¯å›è°ƒæ‰€å±æœåŠ¡æ–¹æ³•çš„è°ƒç”¨çº¿ç¨‹çš„ RpcContextï¼‰ fn.accept(v, t); // æ¢å¤çº¿ç¨‹åŸæœ‰çš„ RpcContext afterContext.accept(v, t); &#125;); return this; &#125; åœ¨æ·»åŠ å›è°ƒæ—¶ï¼Œéœ€è¦ä½¿ç”¨ beforeContext å’Œ afterContext æ¥ä¿è¯æ‰§è¡Œå›è°ƒçš„çº¿ç¨‹çš„ RpcContext æ˜¯æœ€åˆåˆ›å»º AsyncRpcResult å¯¹è±¡çš„çº¿ç¨‹å¯¹åº”çš„ RpcContextï¼Œæ‰§è¡Œå®Œå›è°ƒåéœ€è¦å°†æ‰§è¡Œå›è°ƒçš„çº¿ç¨‹çš„ RpcContext æ¢å¤åˆ°åŸæœ‰å€¼ã€‚å…¶ä¸­ beforeContext ç”¨äºä¿å­˜æ‰§è¡Œå›è°ƒçº¿ç¨‹çš„ RpcContextï¼Œå¹¶å°†æœ€åˆåˆ›å»º AsyncRpcResult å¯¹è±¡çš„çº¿ç¨‹çš„ RpcContext ä¸´æ—¶è®¾ç½®åˆ°æ‰§è¡Œå›è°ƒç”¨çº¿ç¨‹ä¸­ï¼Œä¸ºæ‰§è¡Œå›è°ƒåšå‡†å¤‡ã€‚afterContext ç”¨äºæ¢å¤æ‰§è¡Œå›è°ƒç”¨çš„çº¿ç¨‹åŸæœ‰çš„ RpcContext ã€‚å…·ä½“å®ç°å¦‚ä¸‹ï¼š 12345678910111213141516171819+--- AsyncRpcResult private RpcContext tmpContext; private RpcContext tmpServerContext; private BiConsumer&lt;Result, Throwable&gt; beforeContext = (appResponse, t) -&gt; &#123; // å°†å½“å‰çº¿ç¨‹çš„ RpcContext è®°å½•åˆ° tmpContext ä¸­ tmpContext = RpcContext.getContext(); tmpServerContext = RpcContext.getServerContext(); // å°†æ„é€ å‡½æ•°ä¸­å­˜å‚¨çš„ RpcContext (ä¹Ÿå°±æ˜¯åˆ›å»º AsyncRpcResult çº¿ç¨‹çš„ RpcContext) è®¾ç½®åˆ°å½“å‰çº¿ç¨‹ä¸­ RpcContext.restoreContext(storedContext); RpcContext.restoreServerContext(storedServerContext); &#125;; private BiConsumer&lt;Result, Throwable&gt; afterContext = (appResponse, t) -&gt; &#123; // å°†å½“å‰çº¿ç¨‹çš„ RpcContext æ¢å¤åˆ°åŸå§‹å€¼ RpcContext.restoreContext(tmpContext); RpcContext.restoreServerContext(tmpServerContext); &#125;; å¦‚æ­¤ä¸€æ¥ï¼ŒAsyncRpcResult å°±å¯ä»¥éšæ„æ·»åŠ å›è°ƒï¼Œæ— éœ€æ‹…å¿ƒ RpcContext è¢«æ±¡æŸ“ã€‚ AsyncRpcResult æ•´ä¸ªæ˜¯ä¸ºå¼‚æ­¥è¯·æ±‚è®¾è®¡çš„ï¼Œä½†æ˜¯ Dubbo ä¸­é»˜è®¤çš„è¯·æ±‚æ–¹å¼æ˜¯åŒæ­¥çš„ï¼Œé‚£ä¹ˆ Dubbo åˆæ˜¯å¦‚ä½•æ”¯æŒåŒæ­¥è°ƒç”¨çš„å‘¢ï¼ŸDubbo è¿›è¡ŒæœåŠ¡å¼•ç”¨æ—¶ï¼Œåœ¨ AbstractProtocol.refer() æ–¹æ³•ä¸­ï¼ŒDubbo ä¼šå°† AbstractProtocol.protocolBindingRefer() æ–¹æ³•å®ç°è¿”å›çš„ Invoker å¯¹è±¡ä½¿ç”¨ AsyncToSyncInvoker å°è£…ä¸€å±‚ï¼Œè¯¥å¯¹è±¡ä¸­çš„è°ƒç”¨é€»è¾‘ä¼šå¯¹åŒæ­¥è°ƒç”¨ä¸“é—¨å¤„ç†ï¼Œæˆ‘ä»¬åœ¨ä¸‹é¢çš„å†…å®¹ä¸­è¿›è¡Œä»‹ç»ã€‚ç›¸æ¯”è¾ƒè€Œè¨€ï¼ŒDubbo 2.6.x åœ¨ Dubbo åè®®åšäº†å¼‚æ­¥è½¬åŒæ­¥å¤„ç†ï¼Œå°±æ˜¯åœ¨è°ƒç”¨æ—¶æ‹¿åˆ° DefaultFuture åç«‹å³é˜»å¡ç­‰å¾…ç»“æœã€‚HTTP åè®®å°±æ²¡æœ‰å¼‚æ­¥è°ƒç”¨æ”¯æŒï¼Œè€Œ Dubbo 2.7.x ä½¿ç”¨äº† AbstractInvoker å¯¹ Future åŠŸèƒ½è¿›è¡Œç»Ÿä¸€æ”¯æŒï¼Œä¹Ÿå°±æ˜¯ HTTP åè®®ä¹ŸåŸºæœ¬ä¸Šæ”¯æŒäº†è°ƒç”¨å¼‚æ­¥ã€‚ InvokerAsyncToSyncInvokerAsyncToSyncInvoker æè¿°äº†å¼‚æ­¥è½¬åŒæ­¥çš„é€»è¾‘ï¼Œæ˜¯å¯¹ AsyncRpcResult è·å–ç»“æœçš„è¡¥å……ï¼Œè§¦å‘æ—¶æœºæ˜¯åœ¨æ‰§è¡Œè°ƒç”¨çš„æ—¶å€™ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class AsyncToSyncInvoker&lt;T&gt; implements Invoker&lt;T&gt; &#123; // æœåŠ¡å¼•ç”¨çš„ Invoker private Invoker&lt;T&gt; invoker; public AsyncToSyncInvoker(Invoker&lt;T&gt; invoker) &#123; this.invoker = invoker; &#125; @Override public Class&lt;T&gt; getInterface() &#123; return invoker.getInterface(); &#125; @Override public Result invoke(Invocation invocation) throws RpcException &#123; Result asyncResult = invoker.invoke(invocation); try &#123; // å¦‚æœæ˜¯åŒæ­¥è°ƒç”¨ï¼Œåˆ™è°ƒç”¨ get() æ–¹æ³•ï¼Œé˜»å¡ç­‰å¾…å“åº”è¿”å›ã€‚ // è°ƒç”¨çš„æ˜¯ AsyncRpcResult.get æ–¹æ³•ï¼Œå…¶åº•å±‚è°ƒç”¨çš„æ˜¯ CompletableFuture çš„ get æ–¹æ³• if (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) &#123; /** * NOTICE! * must call &#123;@link java.util.concurrent.CompletableFuture#get(long, TimeUnit)&#125; because * &#123;@link java.util.concurrent.CompletableFuture#get()&#125; è¢«è¯æ˜æœ‰ä¸¥é‡çš„æ€§èƒ½ä¸‹é™ã€‚ */ asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS); &#125; &#125; catch (InterruptedException e) &#123; throw new RpcException(\"Interrupted unexpectedly while waiting for remote result to return! method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; catch (ExecutionException e) &#123; Throwable t = e.getCause(); if (t instanceof TimeoutException) &#123; throw new RpcException(RpcException.TIMEOUT_EXCEPTION, \"Invoke remote method timeout. method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; else if (t instanceof RemotingException) &#123; throw new RpcException(RpcException.NETWORK_EXCEPTION, \"Failed to invoke remote method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; else &#123; throw new RpcException(RpcException.UNKNOWN_EXCEPTION, \"Fail to invoke remote method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; catch (Throwable e) &#123; throw new RpcException(e.getMessage(), e); &#125; // éåŒæ­¥è°ƒç”¨ç›´æ¥è¿”å›è°ƒç”¨ç»“æœ AsyncRpcResult return asyncResult; &#125; // çœç•¥å…¶å®ƒä»£ç &#125; AsyncToSyncInvoker æ˜¯ Invoker çš„è£…é¥°å™¨ï¼Œè´Ÿè´£å°†å¼‚æ­¥è°ƒç”¨è½¬æ¢æˆåŒæ­¥è°ƒç”¨ï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨ AsyncRpcResult ä¸­çš„ CompletableFuture.get æ–¹æ³•å®ç°åŒæ­¥ç­‰å¾…ã€‚ç›¸æ¯” Dubbo 2.6.x è¿˜æ˜¯æœ‰å¾ˆå¤§åŒºåˆ«çš„ï¼ŒDubbo 2.6.x ä½¿ç”¨ Future.get åŠŸèƒ½é˜»å¡ç­‰å¾…ï¼Œä¸šåŠ¡çº¿ç¨‹å°†å¤„äºé˜»å¡ç­‰å¾…çŠ¶æ€ï¼Œè¿”å›ç»“æœæ—¶éœ€è¦æ¶ˆè´¹ç«¯ Dubbo çº¿ç¨‹æ± å°†ç»“æœå†™åˆ° DefaultFuture ä¸­ï¼Œä¸šåŠ¡çº¿ç¨‹æ‰èƒ½å–å‡ºå¹¶è¿”å›ã€‚Dubbo 2.7.x å½»åº•ä¼˜åŒ–äº†è¿™ç§çº¿ç¨‹æ¨¡å‹ï¼Œå…³äºä¼˜åŒ–çš„èƒŒæ™¯å’Œå®ç°ä¼šåœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­è¿›è¡Œä»‹ç»ï¼Œè¿™é‡Œå…ˆäº†è§£å³å¯ã€‚ AbstractProxyInvokerAbstractProxyInvoker æ˜¯ Dubbo æ¡†æ¶åœ¨æœåŠ¡æš´éœ²è¿‡ç¨‹ä¸­åˆ›å»ºçš„å¯¹è±¡ï¼Œç”± ProxyFactory.getInvoker åˆ›å»ºï¼Œæ˜¯å¯¹æœåŠ¡æ¥å£å®ç°çš„å°è£…ã€‚è¯¥è¿‡ç¨‹å¯¹ Dubbo ä¸­æ‰€æœ‰åè®®ä¸€è‡´ã€‚ AbstractInvokerDubbo åœ¨æœåŠ¡å¼•ç”¨æ—¶ä¼šåˆ›å»ºæ¶ˆè´¹ç«¯çš„ Invokerï¼Œå¯¹äºä¸åŒçš„åè®®åˆ›å»ºçš„ Invoker æœ‰æ‰€ä¸åŒã€‚ä¸‹é¢æˆ‘ä»¬å¯¹ Dubbo åè®® å’Œ ä½¿ç”¨ HTTP é€šä¿¡çš„åè®® åˆ›å»º Invoker æµç¨‹è¿›è¡Œåˆ†æã€‚å…¶ä¸­æ¯ä¸ªåè®®åˆ›å»ºçš„ Invoker éƒ½ä¼šç»§æ‰¿ AbstractInvoker æŠ½è±¡ç±»ï¼Œè¯¥æŠ½è±¡ç±»ä¸­å®šä¹‰äº†é€šç”¨çš„æ‰§è¡Œé€»è¾‘ï¼Œå¦‚è°ƒç”¨æ¨¡å¼çš„ç¡®å®šã€‚ æ„é€ æ–¹æ³•12345678910111213141516171819202122232425262728293031323334public abstract class AbstractInvoker&lt;T&gt; implements Invoker&lt;T&gt; &#123; protected final Logger logger = LoggerFactory.getLogger(getClass()); // å½“å‰ Invoker å¯¹è±¡å°è£…çš„ä¸šåŠ¡æ¥å£ç±»å‹ private final Class&lt;T&gt; type; // å½“å‰ Invoker å…³è”çš„ URL å¯¹è±¡ private final URL url; // å½“å‰ Invoker å…³è”çš„ä¸€äº›é™„åŠ ä¿¡æ¯ private final Map&lt;String, Object&gt; attachment; // æ ‡å¿— Invoker çš„çŠ¶æ€ private volatile boolean available = true; private AtomicBoolean destroyed = new AtomicBoolean(false); // æ„é€ æ–¹æ³• public AbstractInvoker(Class&lt;T&gt; type, URL url) &#123; this(type, url, (Map&lt;String, Object&gt;) null); &#125; public AbstractInvoker(Class&lt;T&gt; type, URL url, String[] keys) &#123; this(type, url, convertAttachment(url, keys)); &#125; public AbstractInvoker(Class&lt;T&gt; type, URL url, Map&lt;String, Object&gt; attachment) &#123; if (type == null) &#123; throw new IllegalArgumentException(\"service type == null\"); &#125; if (url == null) &#123; throw new IllegalArgumentException(\"service url == null\"); &#125; this.type = type; this.url = url; this.attachment = attachment == null ? null : Collections.unmodifiableMap(attachment); &#125;&#125; invoke æ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364+--- AbstractInvoker @Override public Result invoke(Invocation inv) throws RpcException &#123; // if invoker is destroyed due to address refresh from registry, let's allow the current invoke to proceed if (destroyed.get()) &#123; logger.warn(\"Invoker for service \" + this + \" on consumer \" + NetUtils.getLocalHost() + \" is destroyed, \" + \", dubbo version is \" + Version.getVersion() + \", this invoker should not be used any longer\"); &#125; RpcInvocation invocation = (RpcInvocation) inv; invocation.setInvoker(this); if (CollectionUtils.isNotEmptyMap(attachment)) &#123; invocation.addObjectAttachmentsIfAbsent(attachment); &#125; // 1 ä»ä¸Šä¸‹æ–‡ä¸­å–å‡º é™„åŠ ä¿¡æ¯ Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments(); if (CollectionUtils.isNotEmptyMap(contextAttachments)) &#123; invocation.addObjectAttachments(contextAttachments); &#125; // 2 è®¾ç½®è°ƒç”¨æ¨¡å¼ SYNC, ASYNC, FUTURE ã€‚æ³¨æ„ï¼Œoneway è°ƒç”¨æ–¹å¼ // æ ¹æ®ä»¥ä¸‹æ–¹å¼ç¡®å®šè°ƒç”¨æ¨¡å¼ï¼š // 1) æ ¹æ®è¿”å›å€¼ç±»å‹æ˜¯å¦æ˜¯ CompletableFuture ï¼Œæˆ–æ–¹æ³•åæ˜¯ $invokeAsyncï¼Œåˆ™æ˜¯ FUTURE æ¨¡å¼ã€‚è¿™ä¸ªå±äºæœåŠ¡ç«¯å¼‚æ­¥ã€‚ // 2) æ ¹æ® async å±æ€§ï¼Œå¦‚æœè®¾ç½® async=true ï¼Œåˆ™æ˜¯ ASYNC æ¨¡å¼ // 3) é»˜è®¤æ˜¯ SYNC æ¨¡å¼ invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation)); // 3 å¦‚æœæ˜¯å¼‚æ­¥è°ƒç”¨çš„æ¨¡å¼ï¼Œåˆ™ç»™æœ¬æ¬¡è°ƒç”¨æ·»åŠ ä¸€ä¸ªå”¯ä¸€id (FUTURE æ¨¡å¼ä¸å±äº) RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation); AsyncRpcResult asyncResult; try &#123; // 4 è°ƒç”¨å­ç±»å®ç°çš„ doInvoker() æ–¹æ³• asyncResult = (AsyncRpcResult) doInvoke(invocation); // å¯¹è°ƒç”¨å¼‚å¸¸çš„å¤„ç† // 4.1 åˆ›å»º CompletableFuture å¯¹è±¡ï¼Œä½¿ç”¨è¯¥å¯¹è±¡åŒ…è£… AppResponse å¯¹è±¡ // 4.2 ä½¿ç”¨ AppResponse å¯¹è±¡åŒ…è£…å¼‚å¸¸ä¿¡æ¯ // 4.3 ä½¿ç”¨ AsyncRpcResult æœ€ååŒ…è£… CompletableFuture å¯¹è±¡ &#125; catch (InvocationTargetException e) &#123; // biz exception Throwable te = e.getTargetException(); if (te == null) &#123; asyncResult = AsyncRpcResult.newDefaultAsyncResult(null, e, invocation); &#125; else &#123; if (te instanceof RpcException) &#123; ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION); &#125; asyncResult = AsyncRpcResult.newDefaultAsyncResult(null, te, invocation); &#125; &#125; catch (RpcException e) &#123; if (e.isBiz()) &#123; asyncResult = AsyncRpcResult.newDefaultAsyncResult(null, e, invocation); &#125; else &#123; throw e; &#125; &#125; catch (Throwable e) &#123; asyncResult = AsyncRpcResult.newDefaultAsyncResult(null, e, invocation); &#125; // 5 ä½¿ç”¨ FutureContext ä¿å­˜ FutureAdapterï¼ŒFutureAdapter ä¸­ä¼šå°è£… AsyncRpcResult ä¸­çš„ CompletableFuture å¯¹è±¡ RpcContext.getContext().setFuture(new FutureAdapter(asyncResult.getResponseFuture())); return asyncResult; &#125; AbstractInvoker çš„ invoke æ–¹æ³•æ˜¯è°ƒç”¨æœåŠ¡çš„æ¨¡ç‰ˆæ–¹æ³•ï¼Œå…·ä½“è°ƒç”¨ç»†èŠ‚äº¤ç»™å…·ä½“å­ç±»å®ç°ã€‚ è®¾ç½®é™„åŠ ä¿¡æ¯åˆ°è°ƒç”¨ä¿¡æ¯ Invocation ä¸­ã€‚ è®¾ç½®è°ƒç”¨æ¨¡å¼ FUTURE: æ ¹æ®è¿”å›å€¼ç±»å‹æ˜¯å¦æ˜¯ CompletableFuture ï¼Œæˆ–æ–¹æ³•åæ˜¯å¦æ˜¯ $invokeAsyncï¼Œåˆ™æ˜¯ FUTURE æ¨¡å¼ã€‚è¿™ä¸ªå±äºæœåŠ¡ç«¯å¼‚æ­¥ã€‚ ASYNC: æ ¹æ® async å±æ€§ï¼Œå¦‚æœè®¾ç½® async=true ï¼Œåˆ™æ˜¯ ASYNC æ¨¡å¼ã€‚ SYNC: é»˜è®¤è°ƒç”¨æ¨¡å¼ã€‚ å¼‚æ­¥è°ƒç”¨æ—¶ï¼Œç»™æœ¬åœ°è°ƒç”¨æ·»åŠ ä¸€ä¸ªå”¯ä¸€idï¼Œå¹¶è®¾ç½®åˆ°é™„åŠ å±æ€§ä¸­ã€‚ è°ƒç”¨å…·ä½“å­ç±» Invoker å¯¹è±¡çš„ doInvoke æ–¹æ³•ï¼Œä¸ç®¡æ˜¯å“ªä¸ªå­ç±»å®ç°ï¼Œè°ƒç”¨çš„ç»“æœéƒ½æ˜¯ AsyncRpcResult ç±»å‹ã€‚ å¦‚æœè°ƒç”¨å¼‚å¸¸ï¼Œåˆ™å¯¹å¼‚å¸¸è¿›è¡Œå¤„ç†ã€‚ ä½¿ç”¨ä¸Šä¸‹æ–‡ä¿å­˜ FutureAdapter ï¼Œå…¶ä¸­ FutureAdapter ä¸­ä¼šå°è£… AsyncRpcResult ä¸­çš„ CompletableFuture å¯¹è±¡ã€‚åœ¨åç»­çš„é“¾è·¯ä¸­å¯ä»¥ä½¿ç”¨ Future çš„å¼‚æ­¥åŠŸèƒ½ã€‚ æ³¨æ„: ç›¸æ¯” Dubbo 2.6.xï¼ŒAbstractInvoker çš„æ¨¡ç‰ˆæ–¹æ³•ä¸­å®ç°äº†å¼‚æ­¥é€»è¾‘ï¼Œä¹Ÿå°±æ˜¯ä»»ä½•åè®®çš„æœåŠ¡è°ƒç”¨éƒ½æ”¯æŒ Future çš„å¼‚æ­¥åŠŸèƒ½ã€‚åœ¨ Dubbo 2.6.x ä¸­é Dubbo åè®®å¤§éƒ½ä¸æ”¯æŒå¼‚æ­¥è°ƒç”¨ç‰¹æ€§ã€‚ Dubboåè®®å¼‚æ­¥å®ç°æ¶ˆè´¹ç«¯DubboInvoker æ˜¯ Dubbo åè®®åœ¨æ¶ˆè´¹ç«¯åˆ›å»ºçš„ Invoker ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768+--- DubboInvoker @Override protected Result doInvoke(final Invocation invocation) throws Throwable &#123; RpcInvocation inv = (RpcInvocation) invocation; // 1 è·å–æ­¤æ¬¡è°ƒç”¨çš„æ–¹æ³•å final String methodName = RpcUtils.getMethodName(invocation); // 2 å‘ Invocation ä¸­æ·»åŠ é™„åŠ ä¿¡æ¯ï¼Œè¿™é‡Œå°† URL çš„ path å’Œ version æ·»åŠ åˆ°é™„åŠ ä¿¡æ¯ä¸­ inv.setAttachment(PATH_KEY, getUrl().getPath()); inv.setAttachment(VERSION_KEY, version); // 3 é€‰æ‹©ä¸€ä¸ª ExchangeClient å®ä¾‹ ExchangeClient currentClient; if (clients.length == 1) &#123; currentClient = clients[0]; &#125; else &#123; currentClient = clients[index.getAndIncrement() % clients.length]; &#125; try &#123; // 4 åˆ¤æ–­æ˜¯å¦æ˜¯ oneway è°ƒç”¨ï¼Œä¸å…³å¿ƒæœåŠ¡ç«¯çš„å“åº”ç»“æœã€‚è°ƒç”¨åç›´æ¥è¿”å›ä¸€ä¸ªç©º AsyncRpcResult boolean isOneway = RpcUtils.isOneway(getUrl(), invocation); // æ ¹æ®è°ƒç”¨æ–¹æ³•åå’Œé…ç½®ï¼Œè®¡ç®—æ­¤æ¬¡è°ƒç”¨çš„è¶…æ—¶æ—¶é—´ int timeout = calculateTimeout(invocation, methodName); // 5 request() æ–¹æ³•ä¼šç›¸åº”åˆ›å»º DefaultFuture å¯¹è±¡ä»¥åŠæ£€æµ‹è¶…æ—¶çš„å®šæ—¶ä»»åŠ¡ï¼Œè€Œ send() æ–¹æ³•åˆ™ä¸ä¼šåˆ›å»ºè¿™äº›ä¸œè¥¿ã€‚ if (isOneway) &#123; // æ˜¯å¦ç­‰å¾…åº•å±‚ NIO å°†è¯·æ±‚å‘å‡ºï¼Œç­‰å¾…æ—¶é—´é»˜è®¤ 1sï¼Œ1sæœªå‘é€åˆ™æŠ›å‡ºå¼‚å¸¸ boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false); currentClient.send(inv, isSent); // è¿”å›å·²å®ŒæˆçŠ¶æ€çš„ AsynRpcResult å³ AsynRpcResult -&gt; CompletableFutureï¼ˆå·²å®ŒæˆçŠ¶æ€ï¼‰ -&gt; AppResponseï¼ˆç©ºç»“æœï¼‰ return AsyncRpcResult.newDefaultAsyncResult(invocation); // éœ€è¦å…³æ³¨è¿”å›å€¼çš„è¯·æ±‚ &#125; else &#123; // 5 è·å–å¤„ç†å“åº”çš„çº¿ç¨‹æ±  ExecutorService executor = getCallbackExecutor(getUrl(), inv); // 6 è°ƒç”¨ ExchangeClient.request() æ–¹æ³•ï¼Œå°† Invocation åŒ…è£…æˆ Request è¯·æ±‚å‘é€å‡ºå»ï¼ŒåŒæ—¶ä¼šåˆ›å»ºç›¸åº”çš„ DefaultFuture è¿”å›ã€‚ CompletableFuture&lt;AppResponse&gt; appResponseFuture = // currentClient.request è¿”å›çš„æ˜¯ DefaultFutureï¼ŒDefaultFuture ç»§æ‰¿äº† CompletableFuture ã€‚ currentClient.request(inv, timeout, executor) // å¢åŠ äº†ä¸€ä¸ªå›è°ƒï¼Œå–å‡ºå…¶ä¸­çš„ AppResponse å¯¹è±¡ã€‚ // thenApply æ˜¯ä¸€ä¸ªå›è°ƒ,obj æ˜¯ ä¸Šä¸€ä¸ªä»»åŠ¡çš„ç»“æœã€‚è¿”å›çš„ AppResponse è¡¨ç¤ºçš„æ˜¯ æœåŠ¡ç«¯è¿”å›çš„å…·ä½“å“åº”ã€‚ .thenApply(obj -&gt; (AppResponse) obj); // save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter FutureContext.getContext().setCompatibleFuture(appResponseFuture); // 7 è¿™é‡Œå°† CompletableFuture ï¼ˆå…¶å®æ˜¯ DefaultFutureï¼‰ å°è£…æˆ AsyncRpcResult å¹¶è¿”å› AsyncRpcResult result = new AsyncRpcResult(appResponseFuture, inv); // 8 è®¾ç½®å¤„ç†å“åº”çš„çº¿ç¨‹æ±  result.setExecutor(executor); // 9 è¿”å›è°ƒç”¨ return result; &#125; &#125; catch (TimeoutException e) &#123; throw new RpcException(RpcException.TIMEOUT_EXCEPTION, \"Invoke remote method timeout. method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; catch (RemotingException e) &#123; throw new RpcException(RpcException.NETWORK_EXCEPTION, \"Failed to invoke remote method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; DubboInvoker è¿›è¡Œè¿œç¨‹è°ƒç”¨æ—¶ï¼Œä¼šåˆ†åˆ«å¯¹ oneway å’Œ twoway è¿›è¡Œå¤„ç†ã€‚ å¤„ç† oneway è°ƒç”¨æ–¹å¼ ä¸éœ€è¦å“åº”ç»“æœï¼Œç›´æ¥ä½¿ç”¨å®¢æˆ·ç«¯çš„ send æ–¹æ³•å³å¯ï¼Œè¯¥æ–¹æ³•ä¸ä¼šè¿”å›æœåŠ¡ç«¯çš„å“åº”ã€‚DubboInvoker ä¼šè¿”å›ä¸€ä¸ªç©ºç»“æœçš„ AsyncRpcResult å¯¹è±¡ç»™ä¸šåŠ¡æ–¹ã€‚ å¤„ç† twoway è°ƒç”¨æ–¹å¼ éœ€è¦å“åº”ç»“æœï¼Œä½¿ç”¨å®¢æˆ·ç«¯çš„ request æ–¹æ³•å‘é€è¯·æ±‚ï¼Œè¯¥æ–¹æ³•ä¼šåˆ›å»ºå¹¶è¿”å›æœ¬æ¬¡è°ƒç”¨çš„ DefaultFuture å¯¹è±¡ï¼Œå½“æœåŠ¡ç«¯å“åº”æ—¶ä¼šæ›´æ–° DefaultFuture ä¸­çš„ç»“æœä¿¡æ¯ã€‚æ­¤å¤–ï¼ŒDubbo å¯¹çº¿ç¨‹æ¨¡å‹è¿›è¡Œäº†ä¼˜åŒ–ï¼Œå¯ä»¥æŒ‡å®šå¤„ç†å“åº”çš„çº¿ç¨‹æ± ï¼Œç‰¹åˆ«æ˜¯åŒæ­¥è°ƒç”¨çš„çº¿ç¨‹æ± ï¼Œè¿™ä¸ªæˆ‘ä»¬åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­è¯¦ç»†ä»‹ç»ã€‚ ç›¸æ¯”è¾ƒ Dubbo 2.6.x ä¸­çš„ DefaultFutureï¼Œå¼•å…¥äº† CompletableFuture å¯ä»¥æ”¯æŒå¤šå¼‚æ­¥åœºæ™¯ï¼Œå¹¶ä¸”æ”¯æŒ Future é—´çš„ç›¸äº’åè°ƒï¼Œæ­¤å¤–æä¾›äº†è‰¯å¥½çš„å›è°ƒæ–¹æ³•ï¼Œé¿å…ç­‰å¾…å“åº”è€Œé˜»å¡ã€‚è¿™æ˜¯å¯¹ ExchangeClient çš„æ”¹é€ ï¼Œå°† Dubbo 2.6.x ä¸­å¼‚æ­¥ç¼–ç¨‹æ¥å£éƒ½æ›¿æ¢æˆäº† CompletableFuture ã€‚ä»‹ç»å®Œæ¶ˆè´¹ç«¯çš„å¼‚æ­¥å®ç°åï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹æœåŠ¡ç«¯çš„å¼‚æ­¥å®ç°ã€‚ æœåŠ¡ç«¯AbstractProxyInvoker æ˜¯ Dubbo åè®®åœ¨æœåŠ¡ç«¯åˆ›å»ºçš„ Invokerï¼Œå®ƒå°è£…çš„æ˜¯æœåŠ¡æ¥å£å®ç°ã€‚Dubbo åè®®ä¸‹çš„æœåŠ¡æš´éœ²ä¼šä½¿ç”¨ ProxyFactory#getInvoker å°†æœåŠ¡æ¥å£å®ç°å°è£…æˆ AbstractProxyInvokerã€‚å½“æ”¶åˆ°è¯·æ±‚æ—¶ï¼Œé€šé“å¤„ç†å™¨é“¾ä¸Šçš„æ¯ä¸ªå¤„ç†å™¨éƒ½ä¼šå¯¹è¯¥è¯·æ±‚è¿›è¡Œå„è‡ªé€»è¾‘çš„å¤„ç†ï¼Œå…¶ä¸­ HeaderExchangeHandler#handleRequest ä¼šå°†è¯·æ±‚äº¤ç»™ DubboProtocol ä¸­çš„ ExchangeHandler å¤„ç†ï¼ŒDubbo åè®®ä¸‹çš„æœåŠ¡ç«¯å¼‚æ­¥å®ç°å¤„ç†é€»è¾‘å°±åœ¨è¿™ä¸‰è€…ä¸­ã€‚åœ¨åˆ†ææºç ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹æœåŠ¡ç«¯å¼‚æ­¥å®ç°çš„ä¾‹å­ï¼š å¼‚æ­¥å®ç°æœåŠ¡æä¾›ç«¯å¼‚æ­¥æ‰§è¡Œå°†é˜»å¡çš„ä¸šåŠ¡ä» Dubbo å†…éƒ¨çº¿ç¨‹æ± åˆ‡æ¢åˆ°ä¸šåŠ¡è‡ªå®šä¹‰çº¿ç¨‹ï¼Œåœ¨ä¸€å®šç¨‹åº¦ä¸Šé¿å… Dubbo çº¿ç¨‹æ± çš„è¿‡åº¦å ç”¨ï¼Œæœ‰åŠ©äºé¿å…ä¸åŒæœåŠ¡é—´çš„äº’ç›¸å½±å“ã€‚ å®šä¹‰ CompletableFuture ç­¾åæ¥å£ æœåŠ¡æ¥å£å®šä¹‰123public interface AsyncService &#123; CompletableFuture&lt;String&gt; sayHello(String name);&#125; æœåŠ¡å®ç°123456789101112131415public class AsyncServiceImpl implements AsyncService &#123; @Override public CompletableFuture&lt;String&gt; sayHello(String name) &#123; RpcContext savedContext = RpcContext.getContext(); // å»ºè®®ä¸ºsupplyAsyncæä¾›è‡ªå®šä¹‰çº¿ç¨‹æ± ï¼Œé¿å…ä½¿ç”¨JDKå…¬ç”¨çº¿ç¨‹æ±  return CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return \"async response from provider.\"; &#125;); &#125;&#125; é€šè¿‡ return CompletableFuture.supplyAsync() ï¼Œä¸šåŠ¡æ‰§è¡Œå·²ä» Dubbo çº¿ç¨‹åˆ‡æ¢åˆ°ä¸šåŠ¡çº¿ç¨‹ï¼Œé¿å…äº†å¯¹ Dubbo çº¿ç¨‹æ± çš„é˜»å¡ã€‚ æœåŠ¡æ¶ˆè´¹æ–¹ CompletableFuture ç­¾åæ¥å£æ˜¯æœåŠ¡æä¾›æ–¹çš„å¼‚æ­¥å®ç°ï¼Œæ¶ˆè´¹ç«¯åŒæ™®é€šæ¶ˆè´¹ä¸€è‡´ï¼ŒDubbo å†…éƒ¨ä¼šæ ¹æ®è°ƒç”¨çš„æ–¹æ³•è¿”å›å€¼ç±»å‹ç­‰æ–¹å¼ç¡®å®š è°ƒç”¨æ¨¡å¼ï¼Œå…·ä½“çš„åœ¨åé¢çš„æºç éƒ¨åˆ†ä»‹ç»ã€‚ ç»“æœDubbo 2.7 è™½ç„¶æ”¯æŒäº†æœåŠ¡ç«¯çš„å¼‚æ­¥ï¼Œä½† Dubbo çš„çº¿ç¨‹æ¨¡å‹æœ¬èº«å°±æ˜¯å¼‚æ­¥å¤„ç†çš„æ–¹å¼ï¼Œå› æ­¤æœåŠ¡ç«¯çš„å¼‚æ­¥ç‰¹æ€§ç›¸å¯¹è¿˜æ˜¯æœ‰ç‚¹é¸¡è‚‹çš„ã€‚ äº†è§£äº†æœåŠ¡ç«¯å¼‚æ­¥å®ç°åï¼Œä¸‹é¢æˆ‘ä»¬ä»ä»£ç å±‚é¢åˆ†æï¼ŒDubbo å¦‚ä½•å°± CompletableFuture ç­¾åæœåŠ¡æ¥å£æ–¹æ³•å®ç°å¼‚æ­¥çš„ã€‚ HeaderExchangeHandler å¤„ç†è¯·æ±‚123456789101112131415161718192021222324252627282930313233+--- HeaderExchangeHandler void handleRequest(final ExchangeChannel channel, Request req) throws RemotingException &#123; Response res = new Response(req.getId(), req.getVersion()); // çœç•¥å¼‚å¸¸å¤„ç†ä»£ç  Object msg = req.getData(); try &#123; // 1 ä½¿ç”¨ä¸Šå±‚é€šé“å¤„ç†å™¨å¤„ç†æ¶ˆæ¯ï¼Œå…¶å®å°±æ˜¯ DubboProtocol ä¸­çš„ ExchangeHandler CompletionStage&lt;Object&gt; future = handler.reply(channel, msg); // 2 è¯·æ±‚å¤„ç†å®Œæˆå›è°ƒï¼Œå°†ç»“æœå‘é€åˆ°å¯¹ç«¯ future.whenComplete((appResult, t) -&gt; &#123; try &#123; if (t == null) &#123; res.setStatus(Response.OK); res.setResult(appResult); &#125; else &#123; res.setStatus(Response.SERVICE_ERROR); res.setErrorMessage(StringUtils.toString(t)); &#125; // 3 å°†å¤„ç†åçš„ç»“æœå‘é€åˆ°å¯¹ç«¯ channel.send(res); &#125; catch (RemotingException e) &#123; logger.warn(\"Send result to consumer failed, channel is \" + channel + \", msg is \" + e); &#125; &#125;); &#125; catch (Throwable e) &#123; res.setStatus(Response.SERVICE_ERROR); res.setErrorMessage(StringUtils.toString(e)); channel.send(res); &#125; &#125; ç›¸æ¯”è¾ƒä¸ Dubbo 2.6.x ä¸­çš„å¤„ç†è¯·æ±‚é€»è¾‘ï¼Œè¿™é‡Œä½¿ç”¨äº† CompletableFuture çš„å®Œæˆå›è°ƒï¼Œé¿å…äº†é˜»å¡ç­‰å¾…è¯·æ±‚å®Œæˆã€‚è¿™å¾—ç›Šäºå¯¹é€šé“å¤„ç† ExchangeHandler çš„å¼‚æ­¥æ–¹æ³•çš„æ”¹é€ ï¼Œä¹Ÿå°±æ˜¯ DubboProtocol ä¸­çš„ ExchangeHandler çš„å®ç°ã€‚ DubboProtocol çš„å¤„ç†å™¨1234567891011121314151617181920+--- DubboProtocolprivate ExchangeHandler requestHandler = new ExchangeHandlerAdapter() &#123; @Override public CompletableFuture&lt;Object&gt; reply(ExchangeChannel channel, Object message) throws RemotingException &#123; Invocation inv = (Invocation) message; // è·å–æš´éœ²çš„ Invokerï¼Œè¿™é‡Œæ˜¯ AbstractProxyInvoker Invoker&lt;?&gt; invoker = getInvoker(channel, inv); RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress()); // å¦‚æœæœåŠ¡ç«¯å¼‚æ­¥å®ç°ï¼Œè¿™é‡Œè¿”å›çš„ result æ˜¯ä¸€ä¸ª AsyncRpcResult ç±»å‹å¯¹è±¡ï¼Œå…¶ä¸­çš„ AppResonse ä¸­çš„å€¼å¹¶é CompletableFuture ç±»å‹ï¼Œè€Œæ˜¯ CompletableFuture å°è£…çš„ AppResponse Result result = invoker.invoke(inv); return result.thenApply(Function.identity()); &#125; // çœç•¥å…¶å®ƒä»£ç &#125; DubboProtocol ä¸­çš„ ExchangeHandler çš„è¯·æ±‚å¤„ç†æ–¹æ³•è¿”å›çš„æ˜¯ CompletableFuture å¯¹è±¡ï¼Œè¿™åŒæ ·æ˜¯ Dubbo 2.7.x ä¸­çš„æ”¹é€ ï¼ŒæœåŠ¡æ–¹æ³•çš„ç»“æœç»Ÿä¸€åŒ…è£…æˆ CompletableFuture ç±»å‹ï¼Œåœ¨æœåŠ¡ç«¯çš„ Invoker çš„æ‰§è¡Œé€»è¾‘ä¸­å°±å¯ä»¥ä½“ç°è¿™ä¸€ç‚¹ï¼Œä¸‹é¢æˆ‘ä»¬å°±æ¥çœ‹ AbstractProxyInvoker ã€‚ AbstractProxyInvokeræœåŠ¡ç«¯çš„ Invokerï¼Œç›´æ¥å°è£…æœåŠ¡æ¥å£å®ç°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839+--- AbstractProxyInvoker @Override public Result invoke(Invocation invocation) throws RpcException &#123; try &#123; // 1 æ‰§è¡ŒæœåŠ¡æ–¹æ³•ï¼Œå¦‚ DemoService.sayHello Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()); // 2 å°†æ–¹æ³•ç»“æœä»¥ CompletableFuture å¯¹è±¡å½¢å¼è¿›è¡Œå°è£…ã€‚ // æ³¨æ„ï¼šå¦‚æœæœåŠ¡æ–¹æ³•è¿”å›ç±»å‹æ˜¯ CompletableFuture ï¼Œåˆ™æ— éœ€å†ä½¿ç”¨ CompletableFuture åŒ…è£…ã€‚è¿™ä¸ªé’ˆå¯¹æœåŠ¡ç«¯çš„å¼‚æ­¥å®ç°ã€‚ CompletableFuture&lt;Object&gt; future = wrapWithFuture(value); // 3 æ‰§è¡Œ future é€»è¾‘ CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123; // 4 ä½¿ç”¨ AppResponse å°è£…å®é™…ç»“æœ AppResponse result = new AppResponse(); if (t != null) &#123; if (t instanceof CompletionException) &#123; result.setException(t.getCause()); &#125; else &#123; result.setException(t); &#125; &#125; else &#123; result.setValue(obj); &#125; return result; &#125;); // 5 ç»Ÿä¸€åŒ…è£…æˆ AsyncRpcResult å¯¹è±¡ return new AsyncRpcResult(appResponseFuture, invocation); &#125; catch (InvocationTargetException e) &#123; if (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123; logger.error(\"Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread.\", e); &#125; return AsyncRpcResult.newDefaultAsyncResult(null, e.getTargetException(), invocation); &#125; catch (Throwable e) &#123; throw new RpcException(\"Failed to invoke remote proxy method \" + invocation.getMethodName() + \" to \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; AbstractProxyInvoker çš„æ‰§è¡Œé€»è¾‘ä¸»è¦æœ‰å››ç‚¹ï¼Œä¸‹é¢è¿›è¡Œæ€»ç»“ï¼š æ‰§è¡ŒæœåŠ¡æ¥å£å®ä¾‹æ–¹æ³•ï¼Œå¦‚ demoService.sayhello æ–¹æ³•ã€‚ å°†æœåŠ¡å®ä¾‹æ–¹æ³•çš„è°ƒç”¨ç»“æœåŒ…è£…æˆ CompletableFuture ï¼Œå¦‚æœæ˜¯æœåŠ¡ç«¯å¼‚æ­¥å®ç°ï¼ˆæœåŠ¡æ¥å£æ–¹æ³•è¿”å›ç±»å‹æ˜¯ CompletableFutureï¼‰ï¼Œåˆ™æ— éœ€å¯¹ç»“æœè¿›è¡ŒåŒ…è£…ï¼Œç›´æ¥ä½¿ç”¨è¿”å›çš„ CompletableFuture å³å¯ã€‚ æ‰§è¡Œ CompletableFuture çš„å›è°ƒæ–¹æ³•ï¼Œå°†å®é™…ç»“æœå°è£…åˆ° AppResponse ä¸­ã€‚ å°†è¿”å›ç»“æœåŒ…è£…æˆ AsyncRpcResult å¯¹è±¡ã€‚ HTTP åè®®å®ç°æ¶ˆè´¹ç«¯Dubbo ä¸­çš„ HTTP åè®®åœ¨æ¶ˆè´¹ç«¯åˆ›å»ºçš„ Invoker æ˜¯ä¸€ä¸ª AbstractInvoker åŒ¿åå¯¹è±¡ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738@Override+--- AbstractProxyProtocol protected &lt;T&gt; Invoker&lt;T&gt; protocolBindingRefer(final Class&lt;T&gt; type, final URL url) throws RpcException &#123; // 1 è°ƒç”¨å­ç±»å®ç°çš„ doRefer() æ–¹æ³•è¿”å›ä¸€ä¸ªç›®æ ‡æœåŠ¡æ¥å£çš„ä»£ç†å¯¹è±¡ // 2 ä½¿ç”¨ ProxyFactory.getInvoker() æ–¹æ³•å°†æœåŠ¡æ¥å£çš„ä»£ç†å¯¹è±¡å°è£…æˆä¸€ä¸ª Invoker ï¼Œç±»å‹æ˜¯ AbstractProxyInvokerã€‚ final Invoker&lt;T&gt; target = proxyFactory.getInvoker(doRefer(type, url), type, url); // 3 åˆ›å»º AbstractInvoker çš„åŒ¿åå¯¹è±¡ Invoker&lt;T&gt; invoker = new AbstractInvoker&lt;T&gt;(type, url) &#123; @Override protected Result doInvoke(Invocation invocation) throws Throwable &#123; try &#123; // 4 è°ƒç”¨ AbstractProxyInvoker.invoke æ–¹æ³•ï¼Œè¿”å›çš„ç»“æœæ˜¯ AsyncRpcResult Result result = target.invoke(invocation); // FIXME result is an AsyncRpcResult instance. Throwable e = result.getException(); if (e != null) &#123; for (Class&lt;?&gt; rpcException : rpcExceptions) &#123; if (rpcException.isAssignableFrom(e.getClass())) &#123; throw getRpcException(type, url, invocation, e); &#125; &#125; &#125; return result; &#125; catch (RpcException e) &#123; if (e.getCode() == RpcException.UNKNOWN_EXCEPTION) &#123; e.setCode(getErrorCode(e.getCause())); &#125; throw e; &#125; catch (Throwable e) &#123; throw getRpcException(type, url, invocation, e); &#125; &#125; &#125;; invokers.add(invoker); return invoker; &#125; Dubbo åè®®ä¸‹çš„æœåŠ¡è°ƒç”¨ä¸ä»…å¼•å…¥ CompletableFuture ï¼Œè¿˜å¯¹æ–¹æ³•ç­‰è¿›è¡Œæ”¹é€ ï¼Œå¦‚ HeaderExchangeClient.request æ–¹æ³•ã€‚HTTP åè®®ä¸‹çš„æœåŠ¡è°ƒç”¨å¼‚æ­¥æ”¹é€ åŠ›åº¦ç›¸å¯¹ä¸å¤§ï¼Œå¼‚æ­¥å®ç°ä¸»è¦ä¾èµ–å¼•å…¥çš„ CompletableFuture ï¼Œä»¥åŠåœ¨ AbstractInvoker ä¸­ç»Ÿä¸€çš„ Future å¼‚æ­¥åŠŸèƒ½ã€‚ ç‰¹åˆ«è¯´æ˜ï¼š ä¸ºä»€ä¹ˆå°† doRefer è¿”å›çš„ä»£ç†å¯¹è±¡é€šè¿‡ ProxyFactory.getInvoker åŒ…è£…æˆ AbstractProxyInvoker å¯¹è±¡ï¼Ÿå› ä¸ºæ­¤ä»£ç†å¯¹è±¡å…·å¤‡å’Œè¿œç¨‹æœåŠ¡é€šä¿¡çš„èƒ½åŠ›ï¼ŒåŸåˆ™ä¸Šå¯ä»¥ä½¿ç”¨è¯¥ä»£ç†å¯¹è±¡è°ƒç”¨æœåŠ¡æ¥å£æ–¹æ³•ï¼Œä½†æ˜¯è°ƒç”¨ä¿¡æ¯æ˜¯å­˜åœ¨ Invocation ä¸­ï¼Œå°†è¯¥ä»£ç†å¯¹è±¡åŒ…è£…æˆ AbstractProxyInvoker å¯ä»¥æ ¹æ® Invocation ä¸­çš„ä¿¡æ¯åŠ¨æ€é€‰æ‹©ç›®æ ‡æœåŠ¡æ–¹æ³•ã€‚æœ¬è´¨ä¸Šå’Œ DubboInvoker ç±»ä¼¼ï¼ŒDubboInvoker å’Œè¿œç¨‹æœåŠ¡é€šä¿¡éœ€è¦ä½¿ç”¨ ExchangeClientï¼Œå°†è°ƒç”¨ä¿¡æ¯ Invocation äº¤ç»™å®ƒå³å¯å®ç°ç›®æ ‡æœåŠ¡çš„è°ƒç”¨ï¼Œè¿™é‡Œçš„ä»£ç†å¯¹è±¡å°±ç›¸å½“äº DubboInvoker ä¸­çš„ ExchangeClient ã€‚ æœåŠ¡ç«¯ä½¿ç”¨ JsonRpcServer æš´éœ²æœåŠ¡ï¼Œå…·ä½“è¿‡ç¨‹å¯å‚è€ƒï¼šHTTPåè®®æœåŠ¡æš´éœ² ã€‚ 1234+--- HttpProtocol.doExport// 5 åˆ›å»º JsonRpcServerï¼Œæš´éœ²æœåŠ¡JsonRpcServer skeleton = new JsonRpcServer(impl, type);JsonRpcServer genericServer = new JsonRpcServer(impl, GenericService.class); å…¶ä¸­çš„å…·æœ‰æœåŠ¡èƒ½åŠ›çš„ impl æ˜¯ ProxyFactory#getProxy(org.apache.dubbo.rpc.Invoker&lt;T&gt;, boolean) åˆ›å»ºçš„ä»£ç†å¯¹è±¡ï¼Œå…·ä½“é€»è¾‘å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031+--- AbstractProxyProtocol // çœç•¥æ— å…³ä»£ç  public &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; invoker) throws RpcException &#123; final String uri = serviceKey(invoker.getUrl()); Exporter&lt;T&gt; exporter = (Exporter&lt;T&gt;) exporterMap.get(uri); if (exporter != null) &#123; // When modifying the configuration through override, you need to re-expose the newly modified service. if (Objects.equals(exporter.getInvoker().getUrl(), invoker.getUrl())) &#123; return exporter; &#125; &#125; // å…¶ä¸­çš„ invoker æ˜¯ç”± ProxyFactory#getInvoker åˆ›å»º final Runnable runnable = doExport(proxyFactory.getProxy(invoker, true), invoker.getInterface(), invoker.getUrl()); exporter = new AbstractExporter&lt;T&gt;(invoker) &#123; @Override public void unexport() &#123; super.unexport(); exporterMap.remove(uri); if (runnable != null) &#123; try &#123; runnable.run(); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125; &#125;; exporterMap.put(uri, exporter); return exporter; &#125; ä¸éš¾çœ‹å‡ºæœ€ç»ˆå¤„ç†è¯·æ±‚çš„è¿˜æ˜¯ä¸Šé¢æ–¹æ³•ä¼ å…¥çš„ invoker å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ä¸­åŒ…å«çœŸæ­£çš„æœåŠ¡å®ä¾‹ã€‚è€Œä¼ å…¥çš„ invoker å¯¹è±¡æ˜¯ç”± ProxyFactory#getInvoker åˆ›å»ºçš„ï¼Œå¯¹è±¡ç±»å‹æ˜¯ AbstractProxyInvoker ï¼Œä¸‹é¢ä»¥ JavassistProxyFactory å·¥å‚ä¸ºä¾‹ã€‚ 1234567891011121314151617public class JavassistProxyFactory extends AbstractProxyFactory &#123; // çœç•¥æ— å…³ä»£ç  @Override public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123; // TODO Wrapper cannot handle this scenario correctly: the classname contains '$' final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') &lt; 0 ? proxy.getClass() : type); return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123; @Override protected Object doInvoke(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments) throws Throwable &#123; return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments); &#125; &#125;; &#125;&#125; æˆ‘ä»¬æŠŠå‰æ–‡çš„ AbstractProxyInvoker çš„ä»£ç å®ç°ç²˜è´´è¿‡æ¥ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839+--- AbstractProxyInvoker @Override public Result invoke(Invocation invocation) throws RpcException &#123; try &#123; // 1 æ‰§è¡ŒæœåŠ¡æ–¹æ³•ï¼Œå¦‚ DemoService.sayHello Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()); // 2 å°†æ–¹æ³•ç»“æœä»¥ CompletableFuture å¯¹è±¡å½¢å¼è¿›è¡Œå°è£…ã€‚ // æ³¨æ„ï¼šå¦‚æœæœåŠ¡æ–¹æ³•è¿”å›ç±»å‹æ˜¯ CompletableFuture ï¼Œåˆ™æ— éœ€å†ä½¿ç”¨ CompletableFuture åŒ…è£…ã€‚è¿™ä¸ªé’ˆå¯¹æœåŠ¡ç«¯çš„å¼‚æ­¥å®ç°ã€‚ CompletableFuture&lt;Object&gt; future = wrapWithFuture(value); // 3 æ‰§è¡Œ future é€»è¾‘ CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123; // 4 ä½¿ç”¨ AppResponse å°è£…å®é™…ç»“æœ AppResponse result = new AppResponse(); if (t != null) &#123; if (t instanceof CompletionException) &#123; result.setException(t.getCause()); &#125; else &#123; result.setException(t); &#125; &#125; else &#123; result.setValue(obj); &#125; return result; &#125;); // 5 ç»Ÿä¸€åŒ…è£…æˆ AsyncRpcResult å¯¹è±¡ return new AsyncRpcResult(appResponseFuture, invocation); &#125; catch (InvocationTargetException e) &#123; if (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123; logger.error(\"Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread.\", e); &#125; return AsyncRpcResult.newDefaultAsyncResult(null, e.getTargetException(), invocation); &#125; catch (Throwable e) &#123; throw new RpcException(\"Failed to invoke remote proxy method \" + invocation.getMethodName() + \" to \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; å¯¹äºä½¿ç”¨ HTTP åè®®çš„æœåŠ¡å®ç°ï¼Œæ›´å¤šçš„æ˜¯åœ¨å½¢å¼ä¸Šä¿æŒç»Ÿä¸€ï¼Œå’Œ Dubbo åè®®çš„æœåŠ¡å®ç°ç±»ä¼¼ã€‚ å°ç»“Dubbo 2.6.x åŠä¹‹å‰ç‰ˆæœ¬ä¸­ä½¿ç”¨ Future å®ç°å¼‚æ­¥åŠŸèƒ½ï¼Œå¹¶ä¸”ä¸æ”¯æŒæœåŠ¡ç«¯çš„å¼‚æ­¥ï¼Œè¿™åœ¨åŠŸèƒ½è®¾è®¡ä¸Šå­˜åœ¨ä¸€äº›é—®é¢˜ï¼ŒDubbo 2.7.x åŸºäº CompletableFuture å¯¹å¼‚æ­¥åŠŸèƒ½è¿›è¡Œäº†å¢å¼ºï¼Œå¼¥è¡¥äº†åŠŸèƒ½è®¾è®¡ä¸Šçš„ä¸€äº›é—®é¢˜ã€‚ç”±äº CompletableFuture å®ç°äº† CompletionStage å’Œ Future æ¥å£ï¼Œå› æ­¤ä»ç„¶æ”¯æŒ Dubbo 2.6 ä¸­é€šè¿‡ get() æˆ–è€… isDone() æ–¹æ³•è½®è¯¢ç»“æœã€‚ä½†æ˜¯ï¼Œä¸å»ºè®®ä½¿ç”¨ get() è¿™æ ·é˜»å¡çš„æ–¹å¼è·å–ç»“æœï¼Œå› ä¸ºè¿™æ ·åšçš„çš„è¯å°±ä¸¢å¤±äº†å¼‚æ­¥æ“ä½œå¸¦æ¥çš„æ€§èƒ½æå‡ã€‚CompletableFuture æä¾›äº†è‰¯å¥½çš„å›è°ƒæ”¯æŒï¼Œå¦‚ whenComplete() ç­‰æ–¹æ³•å¯ä»¥åœ¨é€»è¾‘å®Œæˆåï¼Œæ‰§è¡Œå›è°ƒé€»è¾‘ã€‚åŒæ—¶ CompletableFuture æ”¯æŒ Future é—´çš„ç›¸äº’åè°ƒï¼Œå¦‚ thenApply() ç­‰æ–¹æ³•ã€‚æ­£æ˜¯ç”±äº CompletableFuture å¼ºå¤§çš„åŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥æ›´åŠ æµç•…åœ°ä½¿ç”¨å›è°ƒè€Œæ— éœ€ç­‰å¾…å“åº”è€Œé˜»å¡è°ƒç”¨çº¿ç¨‹ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - çº¿ç¨‹æ¨¡å‹æ”¹é€ ","slug":"rpc/çº¿ç¨‹æ¨¡å‹æ”¹é€ ","date":"2021-02-05T16:00:00.000Z","updated":"2021-04-06T08:30:05.212Z","comments":false,"path":"posts/13d5a11a/","link":"","permalink":"https://gentryhuang.com/posts/13d5a11a/","excerpt":"","text":"å‰è¨€åœ¨ å¼‚æ­¥æ”¹é€  ä¸­å¯¹ Dubbo 2.7.x ä¸­å¼‚æ­¥è°ƒç”¨å’Œå¼‚æ­¥å®ç°è¿›è¡Œäº†è¯¦ç»†è¯´æ˜ã€‚å…¶ä¸­ Dubbo åè®®ä¸‹ï¼Œåœ¨å¯¹å¼‚æ­¥è°ƒç”¨è¿›è¡Œåˆ†ææ—¶ï¼Œæˆ‘ä»¬å‘ç° ThreadlessExecutor è¢«å¤šæ¬¡ä½¿ç”¨ï¼Œæ­¤å¤– ExchangeChannel#request æ–¹æ³•æ”¯æŒè®¾ç½®å¤„ç†å“åº”çš„çº¿ç¨‹æ± ã€‚æœ¬ç¯‡æ–‡ç« æˆ‘ä»¬å°†å¯¹ Dubbo çº¿ç¨‹æ± æ¨¡å‹ä¼˜åŒ–è¿›è¡Œä»‹ç»ï¼Œå…¶ä¸­æ¶ˆè´¹ç«¯çº¿ç¨‹æ± æ¨¡å‹ä¼˜åŒ–å°±æ˜¯ä»è¿™ä¸¤ä¸ªæ–¹é¢è¿›è¡Œæ”¹é€ çš„ã€‚ æ¦‚è¿°Dubbo åè®®ä¸‹åˆ›å»º NIO æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯éƒ½ä¼šåˆ†åˆ«åˆ›å»ºå„è‡ªçš„çº¿ç¨‹æ± ã€‚2.7.x ä¹‹å‰ç‰ˆæœ¬çš„çº¿ç¨‹æ± çš„åˆ›å»ºæ˜¯ç”±æ´¾å‘å™¨ Dispatcher åˆ›å»ºçš„ WrappedChannelHandler å®Œæˆçš„ã€‚Dispatcher å’Œ WrappedChannelHandler ä¹‹é—´çš„å…³ç³»å¯ä»¥å‚è€ƒ çº¿ç¨‹æ¨¡å‹ ã€‚2.7.x æ–°å¢äº† ExecutorRepository ç”¨äºåˆ›å»ºå’Œç®¡ç†çº¿ç¨‹æ± ã€‚ WrappedChannelHandler çš„å­ç±»å®ç°äº†æ¶ˆæ¯æ´¾å‘åŠŸèƒ½ï¼Œå³å†³å®šäº† Dubbo ä»¥å“ªç§çº¿ç¨‹æ¨¡å‹å¤„ç†æ”¶åˆ°çš„æ¶ˆæ¯å’Œäº‹ä»¶ã€‚å› ä¸º NIO æœåŠ¡å™¨ç«¯å’Œå®¢æˆ·ç«¯éƒ½ä¼šåˆå§‹åŒ–çº¿ç¨‹æ± ï¼Œè¿™æ„å‘³ç€æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯éƒ½å¯èƒ½ä½¿ç”¨è‡ªå·±çš„çº¿ç¨‹æ± æ¥å¤„ç†æœ¬ç«¯æ”¶åˆ°çš„æ¶ˆæ¯å’Œäº‹ä»¶ï¼Œå…·ä½“çš„ç­–ç•¥ç”± WrappedChannelHandler çš„å­ç±»å†³å®šã€‚ ä» Issues è°ˆèµ·ç‚¹è¿™é‡Œï¼šæ¶ˆè´¹è€…ä¸­å»ºç«‹äº†å¤ªå¤šDubboClientHandlerçº¿ç¨‹ æè¿° Dubbo Version: 2.5.3æˆ‘æœ‰ä¸€ä¸ªéå¸¸å¤§çš„provider é›†ç¾¤ï¼ˆ30ä¸ªå®ä¾‹ï¼‰ã€‚ç„¶åæˆ‘ä»¬å‘ç°åœ¨å®¢æˆ·ç«¯ï¼Œä¸ºæ¯ä¸€ä¸ªå®ä¾‹ï¼Œéƒ½å‡†å¤‡äº†ä¸€ä¸ªç‹¬ç«‹çº¿ç¨‹æ± ï¼Œæ‰€ä»¥æˆ‘ä»¬çœ‹åˆ°æœ‰30ä¸ªçº¿ç¨‹æ± ä»¥å»å‘èµ·æ¶ˆè´¹è¯·æ±‚ï¼Œè¿™ä¸ªä»jstackå †æ ˆä¸Šå¯ä»¥è¯æ˜ï¼Œå› ä¸ºé‡Œé¢å¾ˆå¤šçº¿ç¨‹ç»„çš„åå­—æ˜¯ç±»ä¼¼DubboClientHandler-IP1-XXXï¼Œå…¶ä¸­ipéƒ½æ˜¯ä¸ä¸€æ ·çš„ã€‚ é—®é¢˜ ä¹‹æ‰€ä»¥æˆ‘ä»¬æä¾›å¦‚æ­¤å¤§çš„æœåŠ¡é›†ç¾¤ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬å¸Œæœ›æœ€å¤§åŒ–TPSï¼Œä½†ç°åœ¨é›†ç¾¤æ˜¯å¤§äº†ï¼Œä½†æ˜¯æ¶ˆè´¹è€…åˆå› æ­¤å¯¼è‡´å·¨å¤§çš„çº¿ç¨‹æ¶ˆè€—ï¼ˆé«˜CPUï¼‰ã€‚æˆ‘ä»¬èƒ½å¦é€šè¿‡é…ç½®æ”¹å˜è¿™ä¸ªçº¿ç¨‹çš„æ¨¡å‹ï¼Œä¾‹å¦‚ç”¨ä¸€ä¸ªå…±äº«çš„çº¿ç¨‹æ± å»å¤„ç†æ‰€æœ‰çš„æœåŠ¡å®ä¾‹ï¼Œè¿™æ ·æœ€å¤§çš„çº¿ç¨‹æ•°ä¾¿å¯æ§äº†ã€‚ å¾…ä¼˜åŒ– å¯¹ 2.7.5 ç‰ˆæœ¬ä¹‹å‰çš„ Dubbo åº”ç”¨ï¼Œåœ¨ WrappedChannelHandler ä¸­ä¼šä¸º æ¯ä¸ªå®¢æˆ·ç«¯è¿æ¥å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œå› ä¸ºä¸ä¼šæ ¹æ® URL å¤ç”¨çº¿ç¨‹æ± ï¼Œè¿™æ„å‘³ç€æ¯ä¸ªæ¶ˆè´¹ç«¯éƒ½æµªè´¹ç€ä¸€å®šçš„èµ„æºã€‚æ­¤å¤–ï¼Œå¯¹äºåŒæ­¥è°ƒç”¨ï¼Œä¸šåŠ¡çº¿ç¨‹å‘èµ·è°ƒç”¨åè¦é˜»å¡ç­‰å¾…å“åº”ï¼ŒæœåŠ¡ç«¯è¿”å›å“åº”åéœ€è¦æ¶ˆè´¹ç«¯çº¿ç¨‹æ± å°†ç»“æœä¿å­˜èµ·æ¥ç„¶åé€šçŸ¥ä¸šåŠ¡çº¿ç¨‹ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸šåŠ¡çº¿ç¨‹å¤„äºç©ºé—²çŠ¶æ€ï¼Œè€Œæ¥æ”¶å“åº”å´æ˜¯æ¶ˆè´¹ç«¯çº¿ç¨‹æ± å®Œæˆï¼Œè¢«é˜»å¡çš„ä¸šåŠ¡çº¿ç¨‹æ²¡æœ‰è¢«æœ‰æ•ˆåˆ©ç”¨ã€‚å½“é¢ä¸´éœ€è¦æ¶ˆè´¹å¤§é‡æœåŠ¡ä¸”å¹¶å‘æ•°æ¯”è¾ƒå¤§çš„å¤§æµé‡åœºæ™¯æ—¶ï¼ˆå…¸å‹å¦‚ç½‘å…³ç±»åœºæ™¯ï¼‰ï¼Œç»å¸¸ä¼šå‡ºç°æ¶ˆè´¹ç«¯çº¿ç¨‹æ•°åˆ†é…è¿‡å¤šçš„é—®é¢˜ã€‚ Dubbo 2.6.x çº¿ç¨‹æ¨¡å‹è¿™é‡Œä»¥ Netty å®ç°ä¸ºä¾‹ï¼ŒMina ç­‰ NIO ç»„ä»¶ç±»ä¼¼ã€‚ æœåŠ¡ç«¯123456+--- NettyServer public NettyServer(URL url, ChannelHandler handler) throws RemotingException &#123; // ChannelHandlers.wrapæ–¹æ³•ï¼Œç”¨æ¥åŒ…è£… ChannelHandlerï¼Œå®ç°Dubbo çº¿ç¨‹æ¨¡å‹çš„åŠŸèƒ½ // çº¿ç¨‹åå‰ç¼€ DubboServerHandler super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME))); &#125; åœ¨åˆ›å»ºã€å¯åŠ¨ Netty æœåŠ¡æ—¶ä¼šé€šè¿‡ ChannelHandlers.wrap æ–¹æ³•ä¸ºä¼ å…¥çš„ ChannelHandler ä¾æ¬¡åŒ…è£… AllChannelHandler(é»˜è®¤)ã€HeartbeatHandlerä»¥åŠ MultiMessageHandler ã€‚å…¶ä¸­ AllChannelHanlder æ˜¯æ¶ˆæ¯æ´¾å‘å¤„ç†å™¨ï¼Œå…¶çˆ¶ç±» WrappedChannelHandler ä¼šå¼€å¯ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œä¹Ÿå°±æ˜¯æ¯å¯åŠ¨ä¸€ä¸ªæœåŠ¡å™¨å°±åˆ›å»ºå¯¹åº”çš„ä¸€ä¸ªçº¿ç¨‹æ± ã€‚ æ¶ˆè´¹ç«¯12345678910111213+--- NettyClient public NettyClient(final URL url, final ChannelHandler handler) throws RemotingException &#123; // wrapChannelHandleræ–¹æ³•ï¼ŒåŒ…è£…ChannelHandlerï¼Œå…¶ä¸­å®ç°äº† Dubbo çº¿ç¨‹æ¨¡å‹çš„åŠŸèƒ½ã€‚ super(url, wrapChannelHandler(url, handler)); &#125; protected static ChannelHandler wrapChannelHandler(URL url, ChannelHandler handler) &#123; // 1 è®¾ç½®çº¿ç¨‹åå‰ç¼€ï¼Œå³URL.threadname=xxx ï¼Œé»˜è®¤ï¼šDubboClientHandler url = ExecutorUtil.setThreadName(url, CLIENT_THREAD_POOL_NAME); // 2 è®¾ç½®ä½¿ç”¨çš„çº¿ç¨‹æ± ç±»å‹ï¼Œå³ URL.threadpool=xxx ï¼Œé»˜è®¤ï¼š cachedã€‚æ³¨æ„è¿™ä¸ªå’ŒServerçš„åŒºåˆ« url = url.addParameterIfAbsent(Constants.THREADPOOL_KEY, Constants.DEFAULT_CLIENT_THREADPOOL); // 3 åŒ…è£…é€šé“å¤„ç†å™¨ return ChannelHandlers.wrap(handler, url); &#125; åœ¨åˆ›å»ºã€å¯åŠ¨ Netty å®¢æˆ·ç«¯æ—¶ä¼šé€šè¿‡ ChannelHandlers.wrap æ–¹æ³•ä¸ºä¼ å…¥çš„ ChannelHandler ä¾æ¬¡åŒ…è£… AllChannelHandler(é»˜è®¤)ã€HeartbeatHandlerä»¥åŠ MultiMessageHandler ã€‚å…¶ä¸­ AllChannelHanlder æ˜¯æ¶ˆæ¯æ´¾å‘å¤„ç†å™¨ï¼Œå…¶çˆ¶ç±» WrappedChannelHandler ä¼šå¼€å¯ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œä¹Ÿå°±æ˜¯æ¯åˆ›å»ºä¸€ä¸ªè¿æ¥å°±åˆ›å»ºå¯¹åº”çš„ä¸€ä¸ªçº¿ç¨‹æ± ã€‚ å¼€å¯çº¿ç¨‹æ± 123456789101112131415161718192021+--- WrappedChannelHandler public WrappedChannelHandler(ChannelHandler handler, URL url) &#123; this.handler = handler; this.url = url; // 1 åŸºäºSPIæœºåˆ¶åˆ›å»ºçº¿ç¨‹æ±  executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool.class).getAdaptiveExtension().getExecutor(url); String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY; // 2 å¦‚æœæ˜¯æ¶ˆè´¹ç«¯ if (Constants.CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(Constants.SIDE_KEY))) &#123; componentKey = Constants.CONSUMER_SIDE; &#125; // 3 åŸºäºSPIæœºåˆ¶åˆ›å»ºçº¿ç¨‹æ± å­˜å‚¨å¯¹è±¡ DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension(); // 4 æ·»åŠ çº¿ç¨‹æ± åˆ° DataStoreä¸­ // æ³¨æ„ï¼š AbstractClient æˆ– AbstractServer ä» DataStore è·å¾—çº¿ç¨‹æ±  dataStore.put(componentKey, Integer.toString(url.getPort()), executor); &#125; ç¼“å­˜çº¿ç¨‹æ± 12345678910111213// DataStore åªæœ‰ä¸€ä¸ªå®ç°public class SimpleDataStore implements DataStore &#123; /** * ç¼“å­˜å·²æœ‰çš„çº¿ç¨‹æ±  * key1: è¡¨ç¤ºçº¿ç¨‹æ± å±äºæœåŠ¡ç«¯ä¾§è¿˜æ˜¯æ¶ˆè´¹ç«¯ä¾§ * key2: çº¿ç¨‹æ± å…³è”æœåŠ¡çš„ç«¯å£ * value: çº¿ç¨‹æ±  */ private ConcurrentMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt; data = new ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt;(); // çœç•¥å…¶å®ƒä»£ç &#125; ä»æºç å±‚é¢ä¸Šä¹Ÿè¯´æ˜äº†ï¼Œåœ¨ WrappedChannelHandler ä¸­ä¼šä¸ºæ¯ä¸ªè¿æ¥å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œå¹¶æ²¡æœ‰æ ¹æ® URL çš„ä¿¡æ¯å¯¹åŒä¸€ä¸ªçº¿ç¨‹æ± è¿›è¡Œå¤ç”¨ï¼Œè€Œæ˜¯ç›´æ¥é€šè¿‡ SPI æœºåˆ¶æ‰¾åˆ° ThreadPool å…·ä½“å®ç°ï¼Œç„¶ååˆ›å»ºçº¿ç¨‹æ± ã€‚æ³¨æ„ï¼Œæœ€ç»ˆç¼“å­˜çš„æ˜¯æœ€æ–°çš„çº¿ç¨‹æ± ã€‚ çº¿ç¨‹æ± æ¨¡å‹æ³¨æ„ï¼Œåˆ›å»º Dubbo çº¿ç¨‹æ± éƒ½æ˜¯å¼ºè°ƒæ¶ˆè´¹ç«¯è€Œæ²¡æœ‰å¼ºè°ƒæœåŠ¡ç«¯ï¼Œå› ä¸ºä¸€ä¸ªèŠ‚ç‚¹éƒ¨ç½² Dubbo åº”ç”¨ï¼Œä¸€èˆ¬åªä¼šåˆ›å»ºä¸€ä¸ª NIO æœåŠ¡ï¼ˆä»¥ä¸»æœºç»‘å®šçš„ipå’Œportå¯åŠ¨NIOæœåŠ¡ï¼‰ï¼Œå¯¹åº”çš„çº¿ç¨‹æ± ä¹Ÿåªä¼šåˆå§‹åŒ–ä¸€ä¸ªã€‚ æ¶ˆè´¹ç«¯åŒæ­¥è¯·æ±‚çš„çº¿ç¨‹æ¨¡å‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š è¯·æ±‚-å“åº”æµç¨‹å¦‚ä¸‹ï¼š ä¸šåŠ¡çº¿ç¨‹å‘å‡ºè¯·æ±‚ï¼Œæ‹¿åˆ°ä¸€ä¸ª Future å®ä¾‹ã€‚ ä¸šåŠ¡çº¿ç¨‹ç´§æ¥ç€è°ƒç”¨ Future.get é˜»å¡ç­‰å¾…è¯·æ±‚ç»“æœè¿”å›ã€‚ å½“å“åº”è¿”å›ä¹‹åï¼Œäº¤ç”±è¿æ¥å…³è”çš„ Consumer ç«¯çº¿ç¨‹æ± è¿›è¡Œååºåˆ—åŒ–ç­‰å¤„ç†ã€‚ å¾…å¤„ç†å®Œæˆä¹‹åï¼Œé€šè¿‡ Future.set æ–¹æ³•å°†ä¸šåŠ¡ç»“æœç½®å›ï¼Œç„¶åé€šçŸ¥ä¸šåŠ¡çº¿ç¨‹å–ç»“æœã€‚ å½“å‰ç‰ˆæœ¬çš„è®¾è®¡ï¼Œæ¶ˆè´¹ç«¯ä¼šç»´æŠ¤ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œè€Œä¸”çº¿ç¨‹æ± æ˜¯æŒ‰ç…§è¿æ¥éš”ç¦»çš„ ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸ªè¿æ¥ç‹¬äº«ä¸€ä¸ªçº¿ç¨‹æ± ã€‚æ­¤å¤–ï¼Œå½“é¢ä¸´éœ€è¦æ¶ˆè´¹å¤§é‡æœåŠ¡ä¸”å¹¶å‘æ•°æ¯”è¾ƒå¤§çš„åœºæ™¯æ—¶ï¼Œå¦‚ ç½‘å…³ç±»åœºæ™¯ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ¶ˆè´¹ç«¯çš„çº¿ç¨‹æ•°ä¸æ–­å¢åŠ ï¼Œæœ€ç»ˆå¼•å‘CPUé£™å‡ã€å†…å­˜æº¢å‡ºã€‚ Dubbo 2.7.5 çº¿ç¨‹æ¨¡å‹ä¸ºäº†è§£å†³ä»¥ä¸Šä¸¤ä¸ªé—®é¢˜ï¼ŒDubbo 2.7.5 å¯¹çº¿ç¨‹æ¨¡å‹è¿›è¡Œäº†æ”¹é€ ï¼Œå¹¶ä¸”å¼•å…¥äº† ThreadlessExecutorï¼Œä»¥åŠ ExchangeChannel#request æ–¹æ³•æ”¯æŒè®¾ç½®å¤„ç†å“åº”çš„çº¿ç¨‹æ± ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡ å¤ç”¨ä¸šåŠ¡ç«¯è¢«é˜»å¡çš„çº¿ç¨‹ï¼Œä»è€Œé¿å…æ¶ˆè´¹ç«¯çº¿ç¨‹æ± è¿‡åº¦å ç”¨ã€‚ ExecutorRepositoryExecutorRepository è´Ÿè´£åˆ›å»ºå¹¶ç®¡ç† Dubbo ä¸­çš„çº¿ç¨‹æ± ï¼Œè¯¥æ‰©å±•æ¥å£åªæœ‰ä¸€ä¸ªå®ç°ã€‚åœ¨ Dubbo 2.6.x ä¸­ä¹‹æ‰€ä»¥æ²¡æœ‰å¤ç”¨åŒä¸€ä¸ªçº¿ç¨‹æ± ï¼Œå¾ˆå¤§åŸå› å°±æ˜¯æ²¡æœ‰ä¸€ä¸ªç®¡ç† Dubbo çº¿ç¨‹æ± çš„å·¥å…·ï¼Œå®ƒä»…æœ‰ä¸€ä¸ªç¼“å­˜ Dubbo çº¿ç¨‹æ± çš„å·¥å…·ã€‚ä¸‹é¢æˆ‘ä»¬çœ‹çœ‹æ˜¯æ€ä¹ˆç®¡ç†çº¿ç¨‹æ± çš„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class DefaultExecutorRepository implements ExecutorRepository &#123; /** * ç¼“å­˜å·²æœ‰çš„çº¿ç¨‹æ±  * key1: è¡¨ç¤ºçº¿ç¨‹æ± å±äºæœåŠ¡ç«¯ä¾§è¿˜æ˜¯æ¶ˆè´¹ç«¯ä¾§ * key2: çº¿ç¨‹æ± å…³è”æœåŠ¡çš„ç«¯å£ * value: çº¿ç¨‹æ±  */ private ConcurrentMap&lt;String, ConcurrentMap&lt;Integer, ExecutorService&gt;&gt; data = new ConcurrentHashMap&lt;&gt;(); /** * å½“æœåŠ¡æˆ–å®¢æˆ·ç«¯åˆå§‹åŒ–æ—¶ï¼Œæ ¹æ® URL å‚æ•°åˆ›å»ºç›¸åº”çš„çº¿ç¨‹æ± å¹¶ç¼“å­˜åœ¨åˆé€‚çš„ä½ç½® * * * @param url * @return */ public synchronized ExecutorService createExecutorIfAbsent(URL url) &#123; // 1 æ ¹æ® URL ä¸­çš„ side å‚æ•°å€¼ç¡®å®šçº¿ç¨‹æ± ç¼“å­˜çš„ç¬¬ä¸€å±‚ key String componentKey = EXECUTOR_SERVICE_COMPONENT_KEY; if (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))) &#123; componentKey = CONSUMER_SIDE; &#125; Map&lt;Integer, ExecutorService&gt; executors = data.computeIfAbsent(componentKey, k -&gt; new ConcurrentHashMap&lt;&gt;()); // 2 æ ¹æ® URL ä¸­çš„ port å€¼ç¡®å®šçº¿ç¨‹æ± ç¼“å­˜çš„ç¬¬äºŒå±‚ key Integer portKey = url.getPort(); // 3 è·å–æˆ–åˆ›å»ºçº¿ç¨‹æ±  ExecutorService executor = executors.computeIfAbsent(portKey, k -&gt; createExecutor(url)); // 4 å¦‚æœç¼“å­˜ä¸­ç›¸åº”çš„çº¿ç¨‹æ± å·²ç»å…³é—­ï¼Œåˆ™åˆ›å»ºæ–°çš„çº¿ç¨‹æ± ï¼Œå¹¶æ›¿æ¢æ‰ç¼“å­˜ä¸­å·²å…³é—­çš„çº¿ç¨‹æ±  if (executor.isShutdown() || executor.isTerminated()) &#123; executors.remove(portKey); executor = createExecutor(url); executors.put(portKey, executor); &#125; return executor; &#125; /** * è·å–çº¿ç¨‹æ±  * * @param url * @return */ public ExecutorService getExecutor(URL url) &#123; // 1 æ ¹æ® URL ä¸­çš„ side å‚æ•°å€¼ç¡®å®šçº¿ç¨‹æ± ç¼“å­˜çš„ç¬¬ä¸€å±‚ key String componentKey = EXECUTOR_SERVICE_COMPONENT_KEY; if (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))) &#123; componentKey = CONSUMER_SIDE; &#125; // 2 ä»ç¼“å­˜ä¸­è·å–çº¿ç¨‹æ±  Map&lt;Integer, ExecutorService&gt; executors = data.get(componentKey); /** * It's guaranteed that this method is called after &#123;@link #createExecutorIfAbsent(URL)&#125;, so data should already * have Executor instances generated and stored. */ if (executors == null) &#123; logger.warn(\"No available executors, this is not expected, framework should call createExecutorIfAbsent first \" + \"before coming to here.\"); return null; &#125; Integer portKey = url.getPort(); ExecutorService executor = executors.get(portKey); if (executor != null) &#123; if (executor.isShutdown() || executor.isTerminated()) &#123; executors.remove(portKey); executor = createExecutor(url); executors.put(portKey, executor); &#125; &#125; return executor; &#125; /** * æ ¹æ® URL åˆ›å»ºçº¿ç¨‹æ±  * * @param url * @return */ private ExecutorService createExecutor(URL url) &#123; // é€šè¿‡ Dubbo SPI æŸ¥æ‰¾ ThreadPool æ¥å£çš„æ‰©å±•å®ç°ï¼Œå¹¶è°ƒç”¨ getExecutor() æ–¹æ³•åˆ›å»ºçº¿ç¨‹æ± ã€‚é»˜è®¤ä½¿ç”¨ FixedThreadPool æ‰©å±•å®ç°ã€‚ return (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool.class).getAdaptiveExtension().getExecutor(url); &#125; // çœç•¥æ— å…³ä»£ç &#125; ExecutorRepository ä¼šæ ¹æ® URL å¤ç”¨åŒä¸€ä¸ªçº¿ç¨‹ï¼Œè¿™è§£å†³äº†æ¯ä¸ªè¿æ¥ï¼ˆè¿æ¥åŒä¸€ä¸ªèŠ‚ç‚¹ä¸ŠæœåŠ¡ï¼‰éƒ½å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹æ± é—®é¢˜ã€‚ åˆ›å»ºçº¿ç¨‹æ± å½“æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯å¯åŠ¨æ—¶ä¼šåˆå§‹åŒ–çº¿ç¨‹æ± ï¼Œéµå¾ªå…ˆç¼“å­˜ååˆ›å»ºçš„åŸåˆ™ã€‚ç›¸æ¯” Dubbo 2.6.x ï¼ŒWrappedChannelHandler ä¸ä¼šåœ¨åˆå§‹åŒ–æ—¶åˆ›å»ºçº¿ç¨‹æ± ï¼Œè€Œæ˜¯å°è£…äº†å…¬å…±çš„è·å–çº¿ç¨‹æ± çš„æ–¹æ³•ã€‚ è·å–çº¿ç¨‹æ± 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class WrappedChannelHandler implements ChannelHandlerDelegate &#123; protected static final Logger logger = LoggerFactory.getLogger(WrappedChannelHandler.class); protected final ChannelHandler handler; protected final URL url; public WrappedChannelHandler(ChannelHandler handler, URL url) &#123; this.handler = handler; this.url = url; &#125; // çœç•¥æ— å…³ä»£ç  /** * è·å–çº¿ç¨‹æ± ï¼ŒThreadlessExecutor æˆ– å…±äº«çº¿ç¨‹æ±  * 1. ä½¿ç”¨ ThreadlessExecutor ï¼Œå°†å›è°ƒç›´æ¥å§”æ‰˜ç»™å‘èµ·è°ƒç”¨çš„çº¿ç¨‹ * 2. ä½¿ç”¨å…±äº«çº¿ç¨‹æ± æ‰§è¡Œå›è°ƒ * * @param msg * @return */ public ExecutorService getPreferredExecutorService(Object msg) &#123; // å¦‚æœæ˜¯å“åº”ï¼Œå°è¯•ä» DefaultFuture ä¸­å–å‡ºçº¿ç¨‹æ± ï¼Œæ²¡æœ‰çš„è¯å†è·å–å…±äº«çº¿ç¨‹æ±  if (msg instanceof Response) &#123; Response response = (Response) msg; DefaultFuture responseFuture = DefaultFuture.getFuture(response.getId()); if (responseFuture == null) &#123; return getSharedExecutorService(); &#125; else &#123; // å¦‚æœè¯·æ±‚å…³è”äº†çº¿ç¨‹æ± ï¼Œåˆ™ä¼šè·å–ç›¸å…³çš„çº¿ç¨‹æ¥å¤„ç†å“åº” ExecutorService executor = responseFuture.getExecutor(); if (executor == null || executor.isShutdown()) &#123; executor = getSharedExecutorService(); &#125; return executor; &#125; // éå“åº”ï¼Œåˆ™ç›´æ¥ä½¿ç”¨å…±äº«çº¿ç¨‹æ±  &#125; else &#123; return getSharedExecutorService(); &#125; &#125; /** * è·å–å½“å‰æœåŠ¡å™¨æˆ–å®¢æˆ·ç«¯çš„å…±äº«çº¿ç¨‹æ±  * * @return */ public ExecutorService getSharedExecutorService() &#123; // ä» ExecutorRepository ä¸­è·å–çº¿ç¨‹æ±  ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension(); ExecutorService executor = executorRepository.getExecutor(url); if (executor == null) &#123; executor = executorRepository.createExecutorIfAbsent(url); &#125; return executor; &#125; @Deprecated public ExecutorService getExecutorService() &#123; return getSharedExecutorService(); &#125;&#125; éœ€è¦æ³¨æ„çš„æ˜¯ getPreferredExecutorService æ–¹æ³•ï¼Œå¦‚æœè¯·æ±‚åœ¨å‘é€çš„æ—¶å€™æŒ‡å®šäº†å…³è”çš„çº¿ç¨‹æ± ï¼Œåˆ™æ”¶åˆ°å“åº”æ—¶ä¼šä¼˜å…ˆæ ¹æ®è¯·æ±‚ ID ä» DefaultFuture ä¸­å–å‡ºå¯¹åº”çš„çº¿ç¨‹æ± ï¼Œå¯èƒ½æ˜¯ ThreadlessExecutorçº¿ç¨‹æ± æˆ–å…±äº«çº¿ç¨‹æ± ã€‚ DefaultFutureæ„é€ æ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839404142/** * åˆå§‹åŒ– DefaultFuture * 1. åˆå§‹åŒ– DefaultFuture * 2. è¶…æ—¶æ£€æŸ¥ * * @param channel channel * @param request the request * @param timeout timeout * @param executor çº¿ç¨‹æ±  * @return a new DefaultFuture */public static DefaultFuture newFuture(Channel channel, Request request, int timeout, ExecutorService executor) &#123; final DefaultFuture future = new DefaultFuture(channel, request, timeout); future.setExecutor(executor); // ThreadlessExecutor éœ€è¦æŒæœ‰æœ¬æ¬¡è¯·æ±‚å…³è”çš„ DefaultFutureï¼Œä¸»è¦ç”¨äºå½“è°ƒç”¨å‡ºç°å¼‚å¸¸æ—¶ï¼ˆå¦‚è°ƒç”¨è¶…æ—¶ï¼‰ï¼ŒThreadlessExecutor å¯ä»¥åŠæ—¶æ›´æ–° DefaultFuture çš„è°ƒç”¨çŠ¶æ€ï¼Œé¿å…ä¸šåŠ¡æ–¹ä¸€ç›´å‚»å‚»åœ°ç­‰å¾… if (executor instanceof ThreadlessExecutor) &#123; ((ThreadlessExecutor) executor).setWaitingFuture(future); &#125; // ä¸ºæ¯æ¬¡è¯·æ±‚åˆ›å»ºä¸€ä¸ªè¶…æ—¶æ£€æŸ¥ä»»åŠ¡ timeoutCheck(future); return future;&#125;private static void timeoutCheck(DefaultFuture future) &#123; // 1 åˆ›å»ºè¶…æ—¶ä»»åŠ¡ TimeoutCheckTask task = new TimeoutCheckTask(future.getId()); // 2 å°†è¶…æ—¶ä»»åŠ¡åŠ å…¥æ—¶é—´è½®ï¼Œåˆ°äº†æŒ‡å®šçš„è¶…æ—¶æ—¶é—´è§¦å‘ä»»åŠ¡ future.timeoutCheckTask = TIME_OUT_TIMER.newTimeout(task, future.getTimeout(), TimeUnit.MILLISECONDS);&#125;private DefaultFuture(Channel channel, Request request, int timeout) &#123; this.channel = channel; this.request = request; this.id = request.getId(); this.timeout = timeout &gt; 0 ? timeout : channel.getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT); // put into waiting map. FUTURES.put(id, this); CHANNELS.put(id, channel);&#125; éœ€è¦è¯´æ˜çš„æ˜¯ï¼ŒDubbo åè®®ä¸‹ twoway è°ƒç”¨ä¸ä»…ä¼šåˆ›å»ºä¸€ä¸ªå’Œæœ¬æ¬¡è°ƒç”¨çš„ç›¸å…³çš„ DefaultFuture å¯¹è±¡ï¼Œè¿˜ä¼šä¸ºå½“å‰è¯·æ±‚åˆ›å»ºä¸€ä¸ªè°ƒç”¨è¶…æ—¶æ£€æµ‹ä»»åŠ¡ï¼Œè¯¥ä»»åŠ¡ç”¨äºå½“è°ƒç”¨è¶…æ—¶æ—¶åŠæ—¶å“åº”ä¸€ä¸ªè¶…æ—¶å¼‚å¸¸ç»“æœç»™è°ƒç”¨æ–¹ï¼Œå°½å¯èƒ½å‡å°‘ä¸šåŠ¡æ–¹ç­‰å¾…æ—¶é—´ï¼Œä¸ä»…åŒæ­¥è°ƒç”¨å¯ä»¥åŠæ—¶æ”¶åˆ°è°ƒç”¨ç»“æœï¼Œå¼‚æ­¥è°ƒç”¨ä¹Ÿæ˜¯ï¼Œåªæ˜¯ä¸€èˆ¬æƒ…å†µä¸‹å¼‚æ­¥è°ƒç”¨ä¸ä¼šç«‹åˆ»é˜»å¡ç­‰å¾…ç»“æœè€Œå·²ã€‚Dubbo 2.6.x æ²¡æœ‰ä½¿ç”¨æ—¶é—´è½®ï¼Œè€Œæ˜¯ä½¿ç”¨å®šæ—¶ä»»åŠ¡æ£€æµ‹ä»»åŠ¡çš„è¶…æ—¶ï¼Œæœ¬è´¨ä¸Šæ˜¯ä¸€æ ·çš„ã€‚ è¶…æ—¶ä»»åŠ¡1234567891011121314151617181920212223242526272829303132333435363738+--- DefaultFuture private static class TimeoutCheckTask implements TimerTask &#123; // è¯·æ±‚id private final Long requestID; TimeoutCheckTask(Long requestID) &#123; this.requestID = requestID; &#125; @Override public void run(Timeout timeout) &#123; // æ ¹æ®è¯·æ±‚idå–å‡ºå¯¹åº”çš„ DefaultFuture DefaultFuture future = DefaultFuture.getFuture(requestID); // åˆ¤æ–­ timeout åˆ°äº†ï¼Œç»“æœæ˜¯å¦è¿”å›ï¼Œæ²¡æœ‰è¿”å›åˆ™è¯·æ±‚è¶…æ—¶äº† if (future == null || future.isDone()) &#123; return; &#125; // è¯·æ±‚è¶…æ—¶éœ€è¦å“åº”ä¸€ä¸ªè¶…æ—¶ç»“æœ if (future.getExecutor() != null) &#123; future.getExecutor().execute(() -&gt; notifyTimeout(future)); &#125; else &#123; notifyTimeout(future); &#125; &#125; private void notifyTimeout(DefaultFuture future) &#123; // åˆ›å»ºä¸€ä¸ªè¶…æ—¶å¼‚å¸¸å“åº” Response timeoutResponse = new Response(future.getId()); // set timeout status. timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT); timeoutResponse.setErrorMessage(future.getTimeoutMessage(true)); // å¤„ç†å“åº” DefaultFuture.received(future.getChannel(), timeoutResponse, true); &#125; &#125; å¤„ç†å“åº”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051+--- DefaultFuture public static void received(Channel channel, Response response, boolean timeout) &#123; try &#123; DefaultFuture future = FUTURES.remove(response.getId()); if (future != null) &#123; Timeout t = future.timeoutCheckTask; // è¯·æ±‚æ²¡æœ‰è¶…æ—¶ï¼Œåˆ™å–æ¶ˆè¶…æ—¶ä»»åŠ¡ if (!timeout) &#123; // decrease Time t.cancel(); &#125; future.doReceived(response); &#125; else &#123; logger.warn(\"The timeout response finally returned at \" + (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\").format(new Date())) + \", response status is \" + response.getStatus() + (channel == null ? \"\" : \", channel: \" + channel.getLocalAddress() + \" -&gt; \" + channel.getRemoteAddress()) + \", please check provider side for detailed result.\"); &#125; &#125; finally &#123; CHANNELS.remove(response.getId()); &#125; &#125; private void doReceived(Response res) &#123; if (res == null) &#123; throw new IllegalStateException(\"response cannot be null\"); &#125; // æ­£å¸¸å“åº”ç»“æœ if (res.getStatus() == Response.OK) &#123; this.complete(res.getResult()); // è¶…æ—¶å¼‚å¸¸ &#125; else if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123; this.completeExceptionally(new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage())); // å…¶å®ƒå¼‚å¸¸ &#125; else &#123; this.completeExceptionally(new RemotingException(channel, res.getErrorMessage())); &#125; // å·²ç»æœ‰äº†è¯·æ±‚ç»“æœï¼Œä½†å¯èƒ½æ˜¯è¶…æ—¶å¼‚å¸¸ç»“æœï¼Œè¿™ç§æƒ…å†µä¸‹åº”è¯¥é€šçŸ¥åœ¨ ThreadlessExecutor.queue ä¸Šç­‰å¾…çš„çº¿ç¨‹ï¼Œé¿å…å…¶ä¸€ç›´ç­‰å¾…ã€‚ if (executor != null &amp;&amp; executor instanceof ThreadlessExecutor) &#123; ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor; // é€šçŸ¥åœ¨ ThreadlessExecutor.queue ä¸Šç­‰å¾…çš„çº¿ç¨‹è¿”å› if (threadlessExecutor.isWaiting()) &#123; threadlessExecutor.notifyReturn(new IllegalStateException(\"The result has returned, but the biz thread is still waiting\" + \" which is not an expected state, interrupt the thread manually by returning an exception.\")); &#125; &#125; &#125; DefaultFuture å¤„ç†å“åº”åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯æ­£å¸¸å“åº”ç»“æœï¼Œå¦ä¸€ç§æ˜¯å¼‚å¸¸å“åº”ç»“æœã€‚å¦‚æœæ˜¯å¼‚å¸¸ç»“æœï¼Œåˆ™è¿˜éœ€è¦åˆ¤æ–­å¤„ç†å“åº”çš„çº¿ç¨‹æ± ç±»å‹ï¼Œå¦‚æœæ˜¯ ThreadlessExecutor ä¸”å…¶çŠ¶æ€æ˜¯ç­‰å¾…çŠ¶æ€ï¼Œåˆ™éœ€è¦é€šçŸ¥é˜»å¡çš„ä¸šåŠ¡çº¿ç¨‹è¿”å›ã€‚æ­¤å¤–ï¼Œå¦‚æœå› ä¸ºè°ƒç”¨è¶…æ—¶è€Œè¿”å›å¼‚å¸¸ç»“æœæ—¶ï¼Œä¹Ÿä¼šå°†æœ¬æ¬¡è°ƒç”¨ç›¸å…³çš„ DefaultFuture ç§»é™¤ï¼Œå½“æœåŠ¡æä¾›æ–¹è¿”å›å“åº”ï¼ˆè¶…æ—¶æ˜¯é’ˆå¯¹æ¶ˆè´¹ç«¯çš„ï¼ŒæœåŠ¡ç«¯ä¸å—å½±å“ï¼‰æ—¶æ˜¯æ‰¾ä¸åˆ°å¯¹åº”çš„ DefaultFuture å¯¹è±¡çš„ã€‚ ç›¸æ¯”è¾ƒ Dubbo 2.6.x , DefaultFuture æ–°ç»´æŠ¤äº†ä¸€ä¸ª ExecutorService çº¿ç¨‹æ± ï¼Œä½œä¸ºå¤„ç†å“åº”çš„çº¿ç¨‹æ± ï¼Œå¯ä»¥å‚è€ƒ WrappedChannelHandler.getPreferredExecutorService æ–¹æ³•ä¸­çš„é€»è¾‘ã€‚ ThreadlessExecutorThreadlessExecutor æ˜¯ä¸€ç§ç‰¹æ®Šç±»å‹çš„çº¿ç¨‹æ± ï¼Œå®ƒå¹¶ä¸ä¼šç®¡ç†ä»»ä½•çº¿ç¨‹ï¼Œä»¥çº¿ç¨‹æ± çš„èº«ä»½ä½œä¸ºä¸€ä¸ªä¸­é—´å®¹å™¨ä½¿ç”¨ã€‚å…¶ä¸­ç»´æŠ¤äº†ä¸€ä¸ªé˜»å¡é˜Ÿåˆ— queue å’Œä¸€ä¸ªå…±äº«çº¿ç¨‹æ±  shareExecutor ã€‚é˜»å¡é˜Ÿåˆ—ç”¨æ¥å­˜å‚¨å“åº”ä»»åŠ¡ï¼Œæœ€ç»ˆä¼šå°†å“åº”ä»»åŠ¡äº¤ç»™ç­‰å¾…çš„ä¸šåŠ¡çº¿ç¨‹å¤„ç†ã€‚å…±äº«çº¿ç¨‹æ± ä¸»è¦ç”¨äºå½“ä¸šåŠ¡çº¿ç¨‹ä¸å†ç­‰å¾…å“åº”æ—¶ï¼Œä¼šç”±è¯¥çº¿ç¨‹æ± å¤„ç†ä»»åŠ¡ã€‚æ•´ä¸ªæ ¸å¿ƒé€»è¾‘åœ¨ execute() æ–¹æ³•å’Œ waitAndDrain() æ–¹æ³•ã€‚ å±æ€§123456789101112131415161718192021222324public class ThreadlessExecutor extends AbstractExecutorService &#123; private static final Logger logger = LoggerFactory.getLogger(ThreadlessExecutor.class.getName()); /** * é˜»å¡é˜Ÿåˆ—ï¼Œç”¨æ¥åœ¨ IOçº¿ç¨‹å’Œä¸šåŠ¡çº¿ç¨‹ä¹‹é—´ä¼ é€’ä»»åŠ¡ */ private final BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;&gt;(); /** * ThreadlessExecutor åº•å±‚å…³è”çš„å…±äº«çº¿ç¨‹æ± ã€‚å½“ä¸šåŠ¡çº¿ç¨‹å·²ç»ä¸å†ç­‰å¾…å“åº”æ—¶ï¼Œä¼šç”±è¯¥å…±äº«çº¿ç¨‹æ‰§è¡Œæäº¤ä»»åŠ¡ã€‚ */ private ExecutorService sharedExecutor; /** * æŒ‡å‘è¯·æ±‚å¯¹åº”çš„ DefaultFuture */ private CompletableFuture&lt;?&gt; waitingFuture; /** * finished å’Œ waiting å­—æ®µæ§åˆ¶ç€ç­‰å¾…ä»»åŠ¡çš„å¤„ç† */ private boolean finished = false; private volatile boolean waiting = true; private final Object lock = new Object();&#125; ä»»åŠ¡é€šçŸ¥1234567891011121314+--- ThreadlessExecutor @Override public void execute(Runnable runnable) &#123; synchronized (lock) &#123; // åˆ¤æ–­ä¸šåŠ¡çº¿ç¨‹æ˜¯å¦è¿˜åœ¨ç­‰å¾…å“åº”ï¼Œä¸ç­‰å¾…åˆ™ç›´æ¥äº¤ç»™å…±äº«çº¿ç¨‹æ± å¤„ç† if (!waiting) &#123; sharedExecutor.execute(runnable); // ä¸šåŠ¡çº¿ç¨‹è¿˜åœ¨ç­‰å¾…ï¼Œåˆ™å°†ä»»åŠ¡å†™å…¥é˜Ÿåˆ—ï¼Œæœ€ç»ˆç”±ä¸šåŠ¡çº¿ç¨‹è‡ªå·±æ‰§è¡Œï¼ˆä¸šåŠ¡çº¿ç¨‹åœ¨ waitAndDrain æ–¹æ³•ä¸Šç­‰å¾…ä»»åŠ¡ï¼‰ &#125; else &#123; queue.add(runnable); &#125; &#125; &#125; ThreadlessExecutor é‡å†™äº† execute(Runnable) æ–¹æ³•ï¼Œé€šè¿‡è¯¥æ–¹æ³•æäº¤ç»™è¿™ä¸ªæ‰§è¡Œå™¨çš„ä»»åŠ¡ä¸ä¼šè¢«è°ƒåº¦åˆ°ç‰¹å®šçš„çº¿ç¨‹ã€‚å¦‚æœä¸šåŠ¡çº¿ç¨‹åœ¨ç­‰å¾…å“åº”åˆ™å°†ä»»åŠ¡æ”¾å…¥é˜»å¡é˜Ÿåˆ—ï¼Œæœ€ç»ˆä¸šåŠ¡çº¿ç¨‹è‡ªå·±æ‰§è¡Œã€‚å¦‚æœä¸šåŠ¡çº¿ç¨‹æ²¡æœ‰ç­‰å¾…ï¼ˆå¯èƒ½ä¸šåŠ¡çº¿ç¨‹å·²ç»æ‰§è¡Œäº†å“åº”ä»»åŠ¡ï¼‰ï¼Œåˆ™ç›´æ¥äº¤ç»™å…±äº«çº¿ç¨‹æ± å¤„ç†ã€‚ ä»»åŠ¡ç­‰å¾…12345678910111213141516171819202122232425262728293031+--- ThreadlessExecutorpublic void waitAndDrain() throws InterruptedException &#123; // æ£€æµ‹å½“å‰ ThreadlessExecutor çŠ¶æ€ if (finished) &#123; return; &#125; // è·å–é˜»å¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ Runnable runnable = queue.take(); synchronized (lock) &#123; // ä¿®æ”¹waiting çŠ¶æ€ waiting = false; // æ‰§è¡Œä»»åŠ¡ runnable.run(); &#125; // å¦‚æœé˜»å¡é˜Ÿåˆ—è¿˜æœ‰å…¶å®ƒä»»åŠ¡ï¼Œåˆ™éœ€è¦ä¸€èµ·æ‰§è¡Œ runnable = queue.poll(); while (runnable != null) &#123; try &#123; runnable.run(); &#125; catch (Throwable t) &#123; logger.info(t); &#125; runnable = queue.poll(); &#125; // æ ‡è®° ThreadlessExecutor æ˜¯å®ŒæˆçŠ¶æ€ï¼Œæ— ä¸šåŠ¡çº¿ç¨‹ç­‰å¾… finished = true; &#125; è¯¥æ–¹æ³•ä¸€èˆ¬ä¸ä¸€æ¬¡ RPC è°ƒç”¨ç»‘å®šï¼Œåªä¼šæ‰§è¡Œä¸€æ¬¡ã€‚å­˜å‚¨åœ¨é˜»å¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼Œåªæœ‰å½“çº¿ç¨‹è°ƒç”¨è¯¥æ–¹æ³•æ—¶æ‰ä¼šæ‰§è¡Œï¼Œæ‰§è¡Œä»»åŠ¡çš„çº¿ç¨‹å’Œè°ƒç”¨è¯¥æ–¹æ³•çš„çº¿ç¨‹æ˜¯åŒä¸€ä¸ªçº¿ç¨‹ã€‚ å…³è” DefaultFuture123public void setWaitingFuture(CompletableFuture&lt;?&gt; waitingFuture) &#123; this.waitingFuture = waitingFuture;&#125; ä¸º ThreadlessExecutor è®¾ç½®æœ¬æ¬¡è°ƒç”¨ç›¸å…³çš„ DefaultFuture å¯¹è±¡ï¼Œä¸»è¦ç”¨äºåŒæ­¥è°ƒç”¨å¼‚å¸¸ï¼ˆå¦‚è¶…æ—¶å¼‚å¸¸ï¼‰æ—¶ï¼Œå¯ä»¥æ›´æ–° DefaultFuture çš„è°ƒç”¨çŠ¶æ€ï¼Œå³ä½¿ç”¨ notifyReturn æ–¹æ³•ã€‚ å¼‚å¸¸ä»»åŠ¡é€šçŸ¥123456789/** * é€šçŸ¥é˜»å¡ &#123;@link #waitAndDrain()&#125; çš„çº¿ç¨‹è¿”å›ï¼Œé¿å…è°ƒç”¨å‡ºç°å¼‚å¸¸è¿˜å‚»å‚»åœ°ç­‰å¾… */public void notifyReturn(Throwable t) &#123; // an empty runnable task. execute(() -&gt; &#123; waitingFuture.completeExceptionally(t); &#125;);&#125; æœåŠ¡è°ƒç”¨AsyncToSyncInvokerå‰é¢å·²ç»å¯¹è¯¥ Invoker è¿›è¡Œäº†ä»‹ç»ï¼Œåœ¨æœåŠ¡å¼•ç”¨æ—¶ä¼šä½¿ç”¨è¯¥ç±»å¯¹æ¶ˆè´¹ç«¯çš„ Invoker è¿›è¡ŒåŒ…è£…ï¼Œè´Ÿè´£å°†å¼‚æ­¥è°ƒç”¨è½¬æ¢æˆåŒæ­¥è°ƒç”¨ã€‚ 123456789101112131415161718192021@Override public Result invoke(Invocation invocation) throws RpcException &#123; Result asyncResult = invoker.invoke(invocation); try &#123; // å¦‚æœæ˜¯åŒæ­¥è°ƒç”¨ï¼Œåˆ™è°ƒç”¨ get() æ–¹æ³•ï¼Œé˜»å¡ç­‰å¾…å“åº”è¿”å›ã€‚ // è°ƒç”¨çš„æ˜¯ AsyncRpcResult.get æ–¹æ³•ï¼Œå…¶åº•å±‚è°ƒç”¨çš„æ˜¯ CompletableFuture çš„ get æ–¹æ³• if (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) &#123; /** * NOTICE! * must call &#123;@link java.util.concurrent.CompletableFuture#get(long, TimeUnit)&#125; because * &#123;@link java.util.concurrent.CompletableFuture#get()&#125; è¢«è¯æ˜æœ‰ä¸¥é‡çš„æ€§èƒ½ä¸‹é™ã€‚ */ asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS); &#125; // çœç•¥å¼‚å¸¸å¤„ç†é€»è¾‘ &#125; catch (Throwable e) &#123; //... &#125; return asyncResult; &#125; ä¸šåŠ¡çº¿ç¨‹è¿›è¡Œ Invoker è°ƒç”¨æ—¶ï¼Œä¼šæ‰§è¡Œåˆ° AsyncToSyncInvoker.invoke æ–¹æ³•ï¼Œæ‰§è¡Œå®Œè°ƒç”¨åä¼šè¿”å›ä¸€ä¸ª AsyncRpcResult å¯¹è±¡ï¼Œå¦‚æœæ˜¯ SYNC åŒæ­¥è°ƒç”¨æ¨¡å¼ï¼Œåˆ™ä¼šè°ƒç”¨å…¶ get æ–¹æ³•ï¼Œæœ¬è´¨ä¸Šæ˜¯è°ƒç”¨ ThreadlessExecutor çš„ waitAndDrain() æ–¹æ³•é˜»å¡ç­‰å¾…å“åº”ä»»åŠ¡ã€‚ Dubbo 2.6.x çš„å¼‚æ­¥è½¬åŒæ­¥æ˜¯é€šè¿‡ ç­‰å¾…é€šçŸ¥æœºåˆ¶ å®ç°çš„ï¼Œä½¿ç”¨çš„æ˜¯ Lock å’Œ Condition çš„ç»„åˆã€‚Dubbo 2.7.x çš„å¼‚æ­¥è½¬åŒæ­¥ä¹Ÿæ˜¯é€šè¿‡ ç­‰å¾…é€šçŸ¥æœºåˆ¶ å®ç°çš„ï¼Œç­‰å¾…éƒ¨åˆ†ä½¿ç”¨çš„æ˜¯ LinkedBlockingQueue.take() æ–¹æ³•å®ç°çš„ï¼Œé€šçŸ¥éƒ¨åˆ†ä½¿ç”¨çš„æ˜¯ LinkedBlockingQueue.add(Runnable) å®ç°çš„ï¼Œç”±äº LinkedBlockingQueue åº•å±‚çš„å®ç°æœºåˆ¶ä¹Ÿæ˜¯åŸºäº Lock å’Œ Condition çš„ç»„åˆï¼Œå› æ­¤æœ¬è´¨ä¸Šå®ç°æœºåˆ¶æ˜¯ä¸€è‡´çš„ã€‚ AsyncRpcResult123456789+--- AsyncRpcResult @Override public Result get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123; if (executor != null &amp;&amp; executor instanceof ThreadlessExecutor) &#123; ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor; threadlessExecutor.waitAndDrain(); &#125; return responseFuture.get(timeout, unit); &#125; è¿™é‡Œå¯èƒ½ä¼šæœ‰ç–‘é—®ï¼Œä¸šåŠ¡çº¿ç¨‹è°ƒç”¨ threadlessExecutor.waitAndDrain() æ–¹æ³•é˜»å¡ç­‰å¾…ç»“æœæ—¶å¹¶æ²¡æœ‰æ—¶é—´é™åˆ¶ï¼Œé‚£æ€ä¹ˆçŸ¥é“è°ƒç”¨æ˜¯å¦è¶…æ—¶å‘¢ï¼Ÿè¿™ä¸ªå°±æ˜¯å‰æ–‡ä»‹ç»çš„ï¼Œåœ¨åˆ›å»ºè¯·æ±‚ç›¸å…³çš„ DefaultFuture æ—¶è¿˜ä¼šåˆ›å»ºä¸€ä¸ªè¶…æ—¶æ£€æµ‹ä»»åŠ¡ï¼Œå½“è¯·æ±‚è¶…æ—¶æ—¶ä¼šç«‹å³è¿”å›ä¸€ä¸ªè¶…æ—¶å¼‚å¸¸ç»“æœï¼Œå¹¶ä¸”ä¼šé€šçŸ¥é˜»å¡ç­‰å¾…çš„ä¸šåŠ¡çº¿ç¨‹ã€‚ DubboInvoker12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061+--- DubboInvoker@Override protected Result doInvoke(final Invocation invocation) throws Throwable &#123; RpcInvocation inv = (RpcInvocation) invocation; // æ­¤æ¬¡è°ƒç”¨çš„æ–¹æ³•åç§° final String methodName = RpcUtils.getMethodName(invocation); // å‘ Invocation ä¸­æ·»åŠ é™„åŠ ä¿¡æ¯ï¼Œè¿™é‡Œå°† URL çš„ path å’Œ version æ·»åŠ åˆ°é™„åŠ ä¿¡æ¯ä¸­ inv.setAttachment(PATH_KEY, getUrl().getPath()); inv.setAttachment(VERSION_KEY, version); // é€‰æ‹©ä¸€ä¸ª ExchangeClient å®ä¾‹ ExchangeClient currentClient; if (clients.length == 1) &#123; currentClient = clients[0]; &#125; else &#123; currentClient = clients[index.getAndIncrement() % clients.length]; &#125; try &#123; // æ˜¯å¦æ˜¯ oneway è°ƒç”¨ ï¼ˆä¸éœ€è¦è¿”å›å€¼ï¼‰ boolean isOneway = RpcUtils.isOneway(getUrl(), invocation); // æ ¹æ®è°ƒç”¨æ–¹æ³•åå’Œé…ç½®ï¼Œè®¡ç®—æ­¤æ¬¡è°ƒç”¨çš„è¶…æ—¶æ—¶é—´ int timeout = calculateTimeout(invocation, methodName); // ä¸éœ€è¦å…³æ³¨è¿”å›å€¼çš„è¯·æ±‚ if (isOneway) &#123; // çœç•¥è°ƒç”¨é€»è¾‘ // éœ€è¦å…³æ³¨è¿”å›å€¼çš„è¯·æ±‚ &#125; else &#123; // 1 å¯¹äºåŒæ­¥è¯·æ±‚ä¼šä½¿ç”¨ ThreadlessExecutor ï¼ˆSYNC æ¨¡å¼ï¼‰ï¼Œ å¯¹äºå¼‚æ­¥è¯·æ±‚ï¼Œåˆ™ä¼šä½¿ç”¨å…±äº«çš„çº¿ç¨‹æ±  ï¼ˆASYNC å’Œ FUTURE æ¨¡å¼ ï¼‰ ExecutorService executor = getCallbackExecutor(getUrl(), inv); // 2 ä½¿ç”¨ä¸Šé¢é€‰å‡ºçš„ ExchangeClient æ‰§è¡Œ request() æ–¹æ³•å°†è¯·æ±‚å‘å‡ºå»ï¼Œå¹¶ä¼ å…¥çº¿ç¨‹æ±  executorã€‚è¯¥çº¿ç¨‹æ± ä¼šä½œä¸ºå¤„ç†å“åº”çš„çº¿ç¨‹æ± ï¼Œå°†ä¿å­˜åˆ° DefaultFuture ä¸­ CompletableFuture&lt;AppResponse&gt; appResponseFuture = // currentClient.request è¿”å›çš„æ˜¯ DefaultFutureï¼ŒDefaultFuture ç»§æ‰¿äº† CompletableFuture ã€‚ currentClient.request(inv, timeout, executor) // å¢åŠ äº†ä¸€ä¸ªå›è°ƒï¼Œå–å‡ºå…¶ä¸­çš„ AppResponse å¯¹è±¡ã€‚ // thenApply æ˜¯ä¸€ä¸ªå›è°ƒ,obj æ˜¯ ä¸Šä¸€ä¸ªä»»åŠ¡çš„ç»“æœã€‚è¿”å›çš„ AppResponse è¡¨ç¤ºçš„æ˜¯ æœåŠ¡ç«¯è¿”å›çš„å…·ä½“å“åº”ã€‚ .thenApply(obj -&gt; (AppResponse) obj); // save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter FutureContext.getContext().setCompatibleFuture(appResponseFuture); // 3 è¿™é‡Œå°† CompletableFuture ï¼ˆå…¶å®æ˜¯ DefaultFutureï¼‰ å°è£…æˆ AsyncRpcResult å¹¶è¿”å› AsyncRpcResult result = new AsyncRpcResult(appResponseFuture, inv); // è®¾ç½®å¤„ç†ç»“æœçš„çº¿ç¨‹æ±  result.setExecutor(executor); return result; &#125; &#125; catch (TimeoutException e) &#123; throw new RpcException(RpcException.TIMEOUT_EXCEPTION, \"Invoke remote method timeout. method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; catch (RemotingException e) &#123; throw new RpcException(RpcException.NETWORK_EXCEPTION, \"Failed to invoke remote method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; DubboInvoker åœ¨å‘èµ·è°ƒç”¨ä¹‹å‰ï¼Œä¼šå…ˆé€šè¿‡ getCallbackExecutor æ–¹æ³•æ ¹æ®è°ƒç”¨æ¨¡å¼è·å–ä¸åŒçš„çº¿ç¨‹æ± å®ç°ï¼Œä»£ç å¦‚ä¸‹ï¼š 12345678910111213+--- AbstractInvoker protected ExecutorService getCallbackExecutor(URL url, Invocation inv) &#123; // 1 ä» ExecutorRepository ä¸­è·å–çº¿ç¨‹æ±  ExecutorService sharedExecutor = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension().getExecutor(url); // 2 å¦‚æœæ˜¯åŒæ­¥è¯·æ±‚ï¼Œåˆ™ä½¿ç”¨ ThreadlessExecutor çº¿ç¨‹æ± ï¼Œå®ƒä¼šå¯¹å…±äº«çº¿ç¨‹æ± è¿›è¡Œå°è£… if (InvokeMode.SYNC == RpcUtils.getInvokeMode(getUrl(), inv)) &#123; return new ThreadlessExecutor(sharedExecutor); // 3 éåŒæ­¥è¯·æ±‚ï¼Œåˆ™ä½¿ç”¨å…±äº«çº¿ç¨‹æ±  &#125; else &#123; return sharedExecutor; &#125; &#125; å“åº”å¤„ç†ç«¯ç‚¹æ”¶åˆ°æ•°æ®æ—¶ï¼ˆè¿™é‡Œå‡è®¾æ˜¯å“åº”æ•°æ®ï¼‰å…ˆç”± IO çº¿ç¨‹ä»äºŒè¿›åˆ¶æµä¸­è§£ç å‡ºå“åº”ï¼Œç„¶åè°ƒç”¨ WrappedChannelHandler.received æ–¹æ³•çš„å®ç°ï¼Œä¸‹é¢æˆ‘ä»¬ä»¥ AllChannelHandler ä¸ºä¾‹ï¼š 123456789101112131415161718192021222324+--- AllChannelHandler /** * å½“å‰ç«¯ç‚¹æ”¶åˆ°æ•°æ® * * @param channel * @param message * @throws RemotingException */ @Override public void received(Channel channel, Object message) throws RemotingException &#123; // 1 è·å–çº¿ç¨‹æ± ï¼Œå¦‚æœæ˜¯å“åº”æ¶ˆæ¯åˆ™ä¼˜å…ˆè·å–å‘é€è¯·æ±‚æ—¶æŒ‡å®šçš„å…³è”çº¿ç¨‹æ±  ExecutorService executor = getPreferredExecutorService(message); try &#123; // 2 å°†æ¶ˆæ¯å°è£…æˆChannelEventRunnableä»»åŠ¡ï¼Œæäº¤åˆ°ç¬¬ 1 æ­¥è·å–çš„çº¿ç¨‹æ± ä¸­ executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message)); &#125; catch (Throwable t) &#123; // 3 å¦‚æœçº¿ç¨‹æ± æ»¡äº†ï¼Œè¯·æ±‚ä¼šè¢«æ‹’ç»ï¼Œè¿™é‡Œä¼šæ ¹æ®è¯·æ±‚é…ç½®å†³å®šæ˜¯å¦è¿”å›ä¸€ä¸ªè¯´æ˜æ€§çš„å“åº” if (message instanceof Request &amp;&amp; t instanceof RejectedExecutionException) &#123; sendFeedback(channel, (Request) message, t); return; &#125; throw new ExecutionException(message, channel, getClass() + \" error when process received event .\", t); &#125; &#125; ç¬¦åˆä»¥ä¸‹æ¡ä»¶ getPreferredExecutorService æ–¹æ³•è·å–çš„çº¿ç¨‹æ± å°±æ˜¯ ThreadlessExecutorï¼Œå¦åˆ™ä¸€å¾‹ä½¿ç”¨å…±äº«çº¿ç¨‹æ±  æ”¶åˆ°çš„æ˜¯å“åº”æ¶ˆæ¯ã€‚ å“åº”å¯¹åº”çš„è¯·æ±‚è°ƒç”¨æ¨¡å¼æ˜¯ SYNC åŒæ­¥è°ƒç”¨ã€‚ ThreadlessExecutor æ‰§è¡Œ execute æ–¹æ³•æ—¶ï¼Œä¼šå°†ä»»åŠ¡æäº¤åˆ°é˜»å¡é˜Ÿåˆ—ä¸­ï¼Œå¤„äºé˜»å¡çš„ä¸šåŠ¡çº¿ç¨‹ä¼šä»é˜»å¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡å¹¶æ‰§è¡Œã€‚ çº¿ç¨‹æ± æ¨¡å‹é€šè¿‡å¤ç”¨ä¸šåŠ¡ç«¯è¢«é˜»å¡çš„çº¿ç¨‹ï¼Œè§£å†³äº†æ¶ˆè´¹ç«¯çº¿ç¨‹æ± è¿‡åº¦å ç”¨é—®é¢˜ã€‚åŒæ­¥è°ƒç”¨ä¼˜åŒ–åçš„çº¿ç¨‹æ¨¡å‹å¦‚ä¸‹ï¼š ä¸šåŠ¡çº¿ç¨‹å‘å‡ºè¯·æ±‚åï¼Œæ‹¿åˆ°ä¸€ä¸ª Future å¯¹è±¡ã€‚ ä¸šåŠ¡çº¿ç¨‹ä¼šè°ƒç”¨ ThreadlessExecutor.waitAndDrain() æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¼šä½¿ä¸šåŠ¡çº¿ç¨‹åœ¨é˜»å¡é˜Ÿåˆ—ä¸Šç­‰å¾…ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸­è¢«åŠ å…¥ä»»åŠ¡ã€‚ å½“æ”¶åˆ°å“åº”æ—¶ï¼ŒIO çº¿ç¨‹ä¼šç”Ÿæˆä¸€ä¸ªä»»åŠ¡å¹¶æ”¾å…¥ ThreadlessExecutor é˜»å¡é˜Ÿåˆ—ä¸­ã€‚ å¤„äºé˜»å¡çš„ä¸šåŠ¡çº¿ç¨‹å°†ç¬¬ 3 æ­¥æ·»åŠ çš„ä»»åŠ¡å–å‡ºï¼Œå¹¶åœ¨æœ¬çº¿ç¨‹ä¸­æ‰§è¡Œã€‚å¾—åˆ°ç»“æœä¹‹åï¼Œè°ƒç”¨ Future.set æ–¹æ³•è¿›è¡Œè®¾ç½®ï¼Œç„¶åä¸šåŠ¡çº¿ç¨‹ä» waitAndDrain() æ–¹æ³•è¿”å›ã€‚ ä¸šåŠ¡çº¿ç¨‹ç»§ç»­æ‰§è¡Œï¼Œæœ€åæ‹¿åˆ°ç»“æœå€¼ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« ä¸»è¦å¯¹ Dubbo çš„çº¿ç¨‹æ¨¡å‹æ”¹é€ è¿›è¡Œäº†ä»‹ç»ï¼Œé¦–å…ˆè§£å†³äº†ä»¥è¿æ¥ç»´åº¦çš„æ¶ˆè´¹ç«¯çº¿ç¨‹æ± ï¼Œæ ¹æ® URL å¤ç”¨çº¿ç¨‹æ± å³åˆç†åœ°ç¼“å­˜çº¿ç¨‹æ± å®ç°ã€‚æ¥ç€è§£å†³äº†æ¶ˆè´¹ç«¯çº¿ç¨‹æ± è¿‡åº¦å ç”¨é—®é¢˜ï¼Œé€šè¿‡å¼•å…¥ ThreadlessExecutor å¤ç”¨ä¸šåŠ¡ç«¯è¢«é˜»å¡çš„çº¿ç¨‹å®ç°ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"JavaåŸºç¡€ - JDKåŠ¨æ€ä»£ç†","slug":"java-base/jdkåŠ¨æ€ä»£ç†","date":"2021-01-03T12:30:35.000Z","updated":"2021-03-17T05:00:26.335Z","comments":false,"path":"posts/d38b32e5/","link":"","permalink":"https://gentryhuang.com/posts/d38b32e5/","excerpt":"","text":"æ¦‚è¿°Java ä¸­ä»£ç†åˆ†ä¸ºä¸¤å¤§ç±»ï¼Œä¸€ç±»æ˜¯é™æ€ä»£ç†ï¼Œå¦ä¸€ç±»æ˜¯åŠ¨æ€ä»£ç†ã€‚é™æ€ä»£ç†æ˜¯é’ˆå¯¹éœ€è¦è¢«ä»£ç†çš„ç±»åœ¨ç¼–è¯‘ä¹‹å‰å°±å·²ç»å†™å¥½äº†å¯¹åº”çš„ä»£ç†ç±»ï¼Œä¹Ÿå°±æ˜¯è¯´ä»£ç†å…³ç³»åœ¨ç¼–è¯‘ä¹‹å‰å°±ç¡®ç«‹äº†ã€‚åŠ¨æ€ä»£ç†æ˜¯é’ˆå¯¹ç›®æ ‡ç±»åœ¨ç¨‹åºè¿è¡ŒæœŸé—´è‡ªåŠ¨ç”Ÿæˆçš„ä»£ç†ç±»ï¼Œç»†åˆ†ä¸ºæœ‰æ¥å£çš„ä»£ç†ç±»å’Œæ— æ¥å£çš„ä»£ç†ç±»ã€‚JDKåŠ¨æ€ä»£ç†æ”¯æŒç›®æ ‡ç±»æœ‰æ¥å£çš„æƒ…å†µï¼Œç›®æ ‡ç±»æ²¡æœ‰æ¥å£æ— æ³•ä¸ºå…¶ç”Ÿæˆä»£ç†ç±»ï¼Œèƒ½å¤Ÿä¸ºæ²¡æœ‰æ¥å£ç”Ÿæˆä»£ç†ç±»çš„å·¥å…·å¦‚ CGLIB ç­‰ã€‚æœ¬ç¯‡æ–‡ç« å°†å¯¹JDKåŠ¨æ€ä»£ç†å®ç°åŸç†è¿›è¡Œä»‹ç»ã€‚ ç¤ºä¾‹æ¥å£12345678public interface IPrintf &#123; /** * æ‰“å°ä¿¡æ¯ * * @param message ä¿¡æ¯ */ void print(String message);&#125; å®ç°ç±»1234567public class PrintfImpl implements IPrintf &#123; @Override public void print(String message) &#123; System.out.println(\"print: \" + message); &#125;&#125; ä»£ç†å¯¹è±¡1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Client &#123; /** * å®ä¾‹åŒ–å¯¹è±¡ */ private static final IPrintf PRINTF = new PrintfImpl(); /** * JDK ç”Ÿæˆä»£ç†å¯¹è±¡ * * @return $Proxy0 */ public static IPrintf getProxy() &#123; // è¿”å›ä»£ç†å¯¹è±¡ return (IPrintf) Proxy.newProxyInstance( // ç±»åŠ è½½å™¨ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶å°†ç”Ÿæˆçš„ä»£ç†ç±»åŠ è½½åˆ°JVMä¸­ PRINTF.getClass().getClassLoader(), // è¢«ä»£ç†ç±»çš„æ‰€æœ‰æ¥å£ä¿¡æ¯ï¼Œç”¨æ¥ç¡®å®šç”Ÿæˆçš„ä»£ç†ç±»å¯ä»¥å…·æœ‰å“ªäº›æ–¹æ³• PRINTF.getClass().getInterfaces(), // è°ƒç”¨å¤„ç†å™¨ï¼Œæ¯ä¸ªä»£ç†å¯¹è±¡éƒ½å…·æœ‰ä¸€ä¸ªå…³è”çš„è°ƒç”¨å¤„ç†å™¨ï¼Œç”¨äºæŒ‡å®šåŠ¨æ€ç”Ÿæˆçš„ä»£ç†ç±»éœ€è¦å®Œæˆçš„å…·ä½“æ“ä½œã€‚ // è¯¥æ¥å£ä¸­æœ‰ä¸€ä¸ª invoke æ–¹æ³•ï¼Œä»£ç†å¯¹è±¡è°ƒç”¨ä»»ä½•ç›®æ ‡æ¥å£çš„æ–¹æ³•æ—¶éƒ½ä¼šè°ƒç”¨è¯¥ invoke æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸­ä¼šé€šè¿‡åå°„è°ƒç”¨ç›®æ ‡æ–¹æ³•ã€‚ new InvocationHandler() &#123; /** * * @param proxy ä»£ç†å¯¹è±¡ * @param method ä»£ç†å¯¹è±¡å½“å‰è°ƒç”¨çš„æ–¹æ³• * @param args æ–¹æ³•å‚æ•° * @return æ–¹æ³•æ‰§è¡Œçš„ç»“æœï¼ˆæ— è¿”å›å€¼åˆ™ä¸º nullï¼‰ * @throws Throwable å¼‚å¸¸ */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // å‰ç½®é€»è¾‘ System.out.println(\"before action ... \"); // å°†æ–¹æ³•æ´¾å‘ç»™ç›®æ ‡æ–¹æ³• Object result = method.invoke(PRINTF, args); // åç½®é€»è¾‘ System.out.println(\"after action ... \"); return result; &#125; &#125; ); &#125;&#125; æµ‹è¯•12345678public class ProxyTest &#123; @Test public void test() &#123; IPrintf proxy = Client.getProxy(); proxy.print(\"hello world!\"); &#125;&#125; æ‰“å°ç»“æœ ä»£ç†ç±»é€šè¿‡é˜¿é‡Œå¼€æº Java åº”ç”¨è¯Šæ–­å·¥å…· Arthas åç¼–è¯‘ä»£ç†ç±»ï¼Œç»“æœå¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* * Decompiled with CFR. */package com.sun.proxy;import com.code.proxy.IPrintf;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy4extends Proxyimplements IPrintf &#123; // é™æ€å±æ€§ï¼Œæ¯ä¸ªå±æ€§å¯¹åº”æ¥å£ä¸­çš„ä¸€ä¸ªæ–¹æ³• private static Method m1; private static Method m2; private static Method m0; private static Method m3; // æ„é€ æ–¹æ³•ï¼Œå…¥å‚ç±»å‹ä¸º InvocationHandler public $Proxy4(InvocationHandler invocationHandler) &#123; // è°ƒç”¨çˆ¶ç±» Proxy çš„æ„é€ æ–¹æ³• super(invocationHandler); &#125; // é™æ€ä»£ç å—ä¸­é€šè¿‡åå°„åˆå§‹åŒ–Methodå±æ€§ static &#123; try &#123; // Object ä¸­çš„ä¸‰å¤§æ–¹æ³• m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); // ç›®æ ‡ç±»çš„æ¥å£ä¸­çš„æ–¹æ³• m3 = Class.forName(\"com.code.proxy.IPrintf\").getMethod(\"print\", Class.forName(\"java.lang.String\")); return; &#125; // å¼‚å¸¸å¤„ç† catch (NoSuchMethodException noSuchMethodException) &#123; throw new NoSuchMethodError(noSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException classNotFoundException) &#123; throw new NoClassDefFoundError(classNotFoundException.getMessage()); &#125; &#125; public final boolean equals(Object object) &#123; try &#123; return (Boolean)this.h.invoke(this, m1, new Object[]&#123;object&#125;); &#125; catch (Error | RuntimeException throwable) &#123; throw throwable; &#125; catch (Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final String toString() &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error | RuntimeException throwable) &#123; throw throwable; &#125; catch (Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final int hashCode() &#123; try &#123; return (Integer)this.h.invoke(this, m0, null); &#125; catch (Error | RuntimeException throwable) &#123; throw throwable; &#125; catch (Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; // ç›®æ ‡ç±»çš„æ‰“å°æ–¹æ³• public final void print(String string) &#123; try &#123; // this.h æ˜¯ Proxy ä¸­çš„å±æ€§ï¼Œå³è°ƒç”¨ Proxy.newProxyInstance æ–¹æ³•ä¼ å…¥çš„ InvocationHandler å¯¹è±¡ this.h.invoke(this, m3, new Object[]&#123;string&#125;); return; &#125; catch (Error | RuntimeException throwable) &#123; throw throwable; &#125; catch (Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125;&#125; é€šè¿‡ä¸Šé¢åç¼–è¯‘åçš„ä»£ç†ç±»ä»£ç ä¸éš¾çœ‹å‡ºï¼ŒJDK åŠ¨æ€ä»£ç†å®ç°å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š ç”Ÿæˆçš„ä»£ç†ç±»ç»§æ‰¿äº† Proxy ç±»ä¸”å®ç°äº† ç›®æ ‡ç±»çš„æ¥å£ï¼Œæœ‰å‚æ„é€ æ–¹æ³•çš„å‚æ•°ç±»å‹æ˜¯ InvocationHandler ï¼Œåå°„åˆ›å»ºä»£ç†å¯¹è±¡æ‰§è¡Œçš„å°±æ˜¯è¯¥æ„é€ æ–¹æ³•ã€‚ ä»£ç†ç±»é€šè¿‡åå°„ä¸ºç›®æ ‡æ¥å£ï¼ˆæ¥å£åˆ—è¡¨ï¼‰ä¸­çš„æ¯ä¸ªæ–¹æ³•éƒ½æ˜ å°„ä¸€ä¸ª Method å¯¹è±¡ã€‚ ä»£ç†ç±»å¯¹æ¥å£ä¸­æ–¹æ³•çš„å®ç°é€»è¾‘éƒ½æ˜¯é€šè¿‡ InvocationHandler.invoke æ–¹æ³•æ´¾å‘æ‰§è¡Œçš„ï¼Œä»£ç†å¯¹è±¡è°ƒç”¨ä»»ä½•ç›®æ ‡æ¥å£çš„æ–¹æ³•æ—¶éƒ½ä¼šè°ƒç”¨è¿™ä¸ªinvokeæ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸­è¿›è¡Œç›®æ ‡ç±»çš„ç›®æ ‡æ–¹æ³•çš„è°ƒç”¨ï¼Œå³æ¯ä¸ªæ–¹æ³•æ‰§è¡Œé€»è¾‘éƒ½ç”±ç¬¬ 2 æ­¥ä¸­çš„ Method å¯¹è±¡æ‰§è¡Œã€‚ å…³äº JDK åŠ¨æ€ä»£ç†ä½¿ç”¨å°±ä»‹ç»å®Œæ¯•äº†ï¼Œä¸‹é¢æˆ‘ä»¬å¯¹åº•å±‚å®ç°åŸç†è¿›è¡Œè¯´æ˜ã€‚å®ç°åŸç†ä¸­çš„éƒ¨åˆ†æè¿°ä¿¡æ¯ä¼šå¼•ç”¨åˆ°ä¸Šè¿°ä»£ç ç‰‡æ®µã€‚ JDK åŠ¨æ€ä»£ç†Java ä¸­éœ€è¦åœ¨è¿è¡ŒæœŸåŠ¨æ€çš„ç”Ÿæˆä¸€ä¸ªç±»å¹¶åˆ›å»ºå…¶å¯¹è±¡ï¼Œä¸€èˆ¬éœ€è¦ä½¿ç”¨å­—èŠ‚ç æŠ€æœ¯å’Œåå°„æœºåˆ¶ã€‚JDK åŠ¨æ€ä»£ç†é€šè¿‡java.lang.reflect.Proxyæä¾›äº†ä¸€ç§åŸç”Ÿçš„åŠ¨æ€ä»£ç†æ¨¡å¼ï¼Œå…¶åº•å±‚é€šè¿‡å¯¹å­—èŠ‚ç çš„æ“ä½œå’Œåå°„çš„ä½¿ç”¨ç»„è£…ä»£ç†ç±»ï¼Œå¦‚å‰æ–‡ä¸­çš„ $Proxy4ï¼Œæœ€åé€šè¿‡åå°„åˆ›å»ºä»£ç†å¯¹è±¡ã€‚ JDKé€šè¿‡è°ƒç”¨é™æ€æ–¹æ³• Proxy.newProxyInstance() åˆ›å»ºåŠ¨æ€ä»£ç†ï¼Œè¯¥æ–¹æ³•éœ€è¦ä¸‰ä¸ªå‚æ•°ï¼š ç±»åŠ è½½å™¨é€šå¸¸å¯ä»¥ä»å·²ç»è¢«åŠ è½½çš„å¯¹è±¡ä¸­è·å–å…¶ç±»åŠ è½½å™¨ã€‚ æ¥å£åˆ—è¡¨é¢„æœŸä»£ç†å®ç°çš„æ¥å£åˆ—è¡¨ã€‚ InvocationHandler æ¥å£çš„å®ç°ä½œä¸ºåŠ¨æ€ä»£ç†å¯¹è±¡çš„è°ƒç”¨å¤„ç†å™¨ï¼Œå³åŠ¨æ€ä»£ç†å¯ä»¥å°†æ‰€æœ‰è°ƒç”¨æ´¾å‘åˆ°è¯¥è°ƒç”¨å¤„ç†å™¨ã€‚å› æ­¤ï¼Œé€šå¸¸ä¼šå‘è°ƒç”¨å¤„ç†å™¨çš„æ„é€ å™¨ä¸­ä¼ å…¥ä¸€ä¸ªç›®æ ‡å¯¹è±¡çš„å¼•ç”¨ï¼Œä»è€Œä½¿å¾—è°ƒç”¨å¤„ç†å™¨åœ¨æ‰§è¡Œä¸­ä»‹ä»»åŠ¡æ—¶å¯ä»¥å°†è¯·æ±‚è½¬å‘ã€‚ ä»‹ç»å®Œä»£ç†ç›¸å…³çš„æ¦‚å¿µå’Œä½¿ç”¨æ–¹å¼åï¼Œä¸‹é¢æˆ‘ä»¬å¯¹ JDK åŠ¨æ€ä»£ç†å®ç°åŸç†è¿›è¡Œè¯´æ˜ã€‚ æºç åˆ†æProxyå±æ€§1234567891011121314151617181920212223242526272829303132333435363738+--- java.lang.reflect.Proxy /** * æ„é€ æ–¹æ³•å‚æ•°ç±»å‹ï¼Œå°±æ˜¯ InvocationHandler */ private static final Class&lt;?&gt;[] constructorParams = &#123;InvocationHandler.class&#125;; /** * ä»£ç†ç±»çš„ç¼“å­˜ */ private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory()); /** * ä»£ç†å¯¹è±¡è°ƒç”¨çš„å¤„ç†å™¨ * * @serial */ protected InvocationHandler h; /** * Prohibits instantiation. */ private Proxy() &#123; &#125; /** * ä¾›ç”Ÿæˆçš„åŠ¨æ€ä»£ç†ç±»è°ƒç”¨ï¼Œä¹Ÿå°±æ˜¯ Proxy çš„å­ç±»ã€‚ * * @param h ç”¨äºä»£ç†å¯¹è±¡çš„è°ƒç”¨å¤„ç†å™¨ * @throws NullPointerException */ protected Proxy(InvocationHandler h) &#123; Objects.requireNonNull(h); this.h = h; &#125; // çœç•¥å…¶å®ƒä»£ç ...&#125; Proxy ä¸­æœ‰ 3 ä¸ªæ ¸å¿ƒå±æ€§ï¼Œä¸‹é¢ç®€å•ä»‹ç»ï¼š constructorParamsProxy ä¸­çš„æœ‰å‚æ„é€ å™¨çš„å‚æ•°ï¼Œæ˜¯ä¸ªå›ºå®šå€¼å³è°ƒç”¨å¤„ç†å™¨ InvocationHandlerï¼Œç”Ÿæˆçš„ä»£ç†ç±»éƒ½ä¼šè°ƒç”¨ Proxy è¿™ä¸ªçˆ¶ç±»çš„æ„é€ æ–¹æ³•ã€‚ proxyClassCacheç¼“å­˜ç”Ÿæˆçš„ä»£ç†ç±»ï¼Œç”¨äºæé«˜æ•ˆç‡ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒKeyFactory å’Œ ProxyClassFactory éƒ½æ˜¯ Proxy çš„å†…éƒ¨ç±»ï¼Œå‰è€…ç”¨äºè¿”å›æ¥å£å¯¹åº”çš„å¼±å¼•ç”¨ï¼Œåè€…æ ¹æ®æŒ‡å®šçš„ç±»åŠ è½½å™¨å’Œæ¥å£åˆ—è¡¨ç”Ÿæˆä»£ç†ç±»ã€‚ hè°ƒç”¨å¤„ç†å™¨ï¼Œè¯¥å¤„ç†å™¨ä¼šå°†ä»£ç†å¯¹è±¡çš„æ–¹æ³•è°ƒç”¨æ´¾å‘ç»™ç›®æ ‡æ–¹æ³•ã€‚ å†…éƒ¨ç±» KeyFactory123456789101112131415161718192021222324private static final class KeyFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Object&gt; &#123; /** * è¿”å›æ¥å£å¯¹åº”çš„å¼±å¼•ç”¨ä¿¡æ¯ã€‚Key1ã€Key2 ä»¥åŠ KeyX éƒ½æŒæœ‰ WeakReference * * @param classLoader * @param interfaces * @return */ @Override public Object apply(ClassLoader classLoader, Class&lt;?&gt;[] interfaces) &#123; switch (interfaces.length) &#123; case 1: return new Key1(interfaces[0]); // the most frequent case 2: return new Key2(interfaces[0], interfaces[1]); case 0: return key0; default: return new KeyX(interfaces); &#125; &#125;&#125; KeyFactory å°±ä¸€ä¸ªå·¥ä½œï¼Œè¿”å›æ¥å£å¯¹åº”çš„å¼±å¼•ç”¨ä¿¡æ¯ï¼ŒKeyN ç»§æ‰¿äº† WeakReference ç±»ã€‚ å†…éƒ¨ç±» ProxyClassFactory1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; // ä»£ç†ç±»åç§°å‰ç¼€ï¼Œå…·ä½“åç§°ä¸ºï¼š $Proxy + Num private static final String proxyClassNamePrefix = \"$Proxy\"; // ç”Ÿæˆä»£ç†åç§°çš„åºå·ï¼Œæ˜¯è‡ªå¢åŸå­ç±» private static final AtomicLong nextUniqueNumber = new AtomicLong(); /** * ç”Ÿæˆä»£ç†ç±»çš„é€»è¾‘ * * @param loader ç±»åŠ è½½å™¨ * @param interfaces æ¥å£é›†åˆ * @return ä»£ç†ç±» */ @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); // éå†æ¥å£é›†åˆ for (Class&lt;?&gt; intf : interfaces) &#123; // 1 éªŒè¯ç±»åŠ è½½å™¨æ˜¯å¦å°†å½“å‰æ¥å£åç§°è§£æä¸ºç›¸åŒçš„ç±»å¯¹è±¡ Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + \" is not visible from class loader\"); &#125; // 2 åˆ¤æ–­æ˜¯å¦æ˜¯æ¥å£ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + \" is not an interface\"); &#125; // 3 éªŒè¯æ¥å£æ˜¯å¦é‡å¤åŠ è½½ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( \"repeated interface: \" + interfaceClass.getName()); &#125; &#125; // 4 ä»£ç†æ‰€åœ¨åŒ…çš„åç§° String proxyPkg = null; int accessFlags = Modifier.PUBLIC | Modifier.FINAL; // 5 è®°å½•épublicç±»å‹çš„æ¥å£ï¼Œå¦‚æœæ˜¯épublicç±»å‹çš„æ¥å£ï¼Œåˆ™ä¼šå°†ä»£ç†ç±»å®šä¹‰åœ¨è¯¥å¯¹åº”çš„åŒ…ä¸­ã€‚å½“ä¸”ä»…å½“æ‰€æœ‰épublicç±»å‹çš„æ¥å£éƒ½åœ¨ä¸€ä¸ªåŒ…ä¸­æ‰è¡Œï¼Œå¦åˆ™ä¸åˆæ³• for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( \"non-public interfaces from different packages\"); &#125; &#125; &#125; // 6 å¦‚æœæ¥å£æ˜¯publicç±»å‹çš„ï¼Œåˆ™ä½¿ç”¨å›ºå®šçš„åŒ…åï¼š com.sun.proxy if (proxyPkg == null) &#123; proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\"; &#125; // 7 ç»„è£…ä»£ç†ç±»åç§°ï¼Œæ ¼å¼ï¼šproxyPkg + $Proxy + Num long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; // 8 æ ¹æ®ä»£ç†ç±»åå’Œæ¥å£åˆ—è¡¨ä½¿ç”¨ ProxyGenerator ç”ŸæˆæŒ‡å®šçš„ä»£ç†ç±»ï¼Œå¯èƒ½è¿”å›null ï¼ˆé…ç½®äº†è™šæ‹Ÿæœºå‚æ•°ï¼Œå°†ä»£ç†ç±»å­—èŠ‚ä¿¡æ¯è¾“å‡ºåˆ°æ–‡ä»¶ï¼‰ byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags); try &#123; // 9 è°ƒç”¨nativeæ–¹æ³•ï¼Œè¿”å›ä»£ç†ç±» return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; // æ’é™¤ä»£ç†ç±»ç”Ÿæˆä»£ç ä¸­çš„bugï¼Œæä¾›ç»™ä»£ç†ç±»åˆ›å»ºçš„å‚æ•°å­˜åœ¨å…¶ä»–é—®é¢˜(ä¾‹å¦‚è¶…å‡ºäº†è™šæ‹Ÿæœºé™åˆ¶)ã€‚ throw new IllegalArgumentException(e.toString()); &#125; &#125; &#125; ProxyClassFactory å®Œæˆç”Ÿæˆå­—èŠ‚ç çš„æ“ä½œï¼Œæ˜¯ç”Ÿæˆä»£ç†ç±»çš„å®Œæ•´æµç¨‹ï¼Œå…·ä½“å·¥ä½œå¦‚ä¸‹ï¼š æ ¹æ®ç›®æ ‡ç±»çš„æ¥å£ç±»å‹ç¡®å®šç”Ÿæˆä»£ç†ç±»å…¨è·¯å¾„å æ‰§è¡Œ ProxyGenerator.generateProxyClass æ–¹æ³•ï¼Œæ ¹æ®ä»£ç†ç±»åå’Œæ¥å£ç”Ÿæˆä»£ç†ç±»å­—èŠ‚ç æ•°ç»„æˆ–æ–‡ä»¶å½¢å¼ è°ƒç”¨ native æ–¹æ³•å°†ä»£ç†ç±»å­—èŠ‚ç æ•°æ®è½¬åŒ–ä¸ºä»£ç†ç±» Class ProxyGeneratorProxyClassFactory.apply é€šè¿‡è°ƒç”¨ ProxyGenerator.generateProxyClass æ–¹æ³•ç»„è£…ä»£ç†ç±»ï¼Œå¯¹æ¥å£çš„ Class å¯¹è±¡ã€Method å¯¹è±¡è¿›è¡Œæ‹†è§£ã€å°è£…è¿›è€Œç”Ÿæˆå­—èŠ‚ç å±‚é¢çš„æ–¹æ³•ã€æ„é€ æ–¹æ³•ä»¥åŠé™æ€ä»£ç å—ã€‚ å±æ€§1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556+--- ProxyGenerator // JVMå‚æ•°ï¼Œæ˜¯å¦å°†ç”Ÿæˆçš„ä»£ç†ç±»ä¿å­˜åˆ°æ–‡ä»¶ private static final boolean saveGeneratedFiles = (Boolean) AccessController.doPrivileged(new GetBooleanAction(\"sun.misc.ProxyGenerator.saveGeneratedFiles\")); // Object ä¸‰å¤§æ–¹æ³• private static Method hashCodeMethod; private static Method equalsMethod; private static Method toStringMethod; // ä»£ç†ç±»å…¨è·¯å¾„å private String className; // æ¥å£æ•°ç»„ private Class&lt;?&gt;[] interfaces; private int accessFlags; /** * ProxyGenerator ä¸­çš„å¸¸é‡æ±  */ private ProxyGenerator.ConstantPool cp = new ProxyGenerator.ConstantPool(); /** * è®°å½•æ–¹æ³•æ ‡è¯†ï¼Œç”¨äºç”Ÿæˆä»£ç†ç±»ä¸­çš„æ–¹æ³•çš„å±æ€§ã€‚ */ private List&lt;ProxyGenerator.FieldInfo&gt; fields = new ArrayList(); /** * ç”Ÿæˆçš„æ–¹æ³•ä¿¡æ¯é›†åˆï¼ŒåŒ…æ‹¬æ„é€ æ–¹æ³•ã€é™æ€ä»£ç å—ã€‚ */ private List&lt;ProxyGenerator.MethodInfo&gt; methods = new ArrayList(); /** * æ–¹æ³•ç­¾ååˆ°æ–¹æ³•ä»£ç†å¯¹è±¡çš„æ˜ å°„ */ private Map&lt;String, List&lt;ProxyGenerator.ProxyMethod&gt;&gt; proxyMethods = new HashMap(); private int proxyMethodCount = 0; static &#123; // åå°„è·å–ä¸‰å¤§æ–¹æ³•å¯¹è±¡ try &#123; hashCodeMethod = Object.class.getMethod(\"hashCode\"); equalsMethod = Object.class.getMethod(\"equals\", Object.class); toStringMethod = Object.class.getMethod(\"toString\"); &#125; catch (NoSuchMethodException var1) &#123; throw new NoSuchMethodError(var1.getMessage()); &#125; &#125; /** * æ„é€ æ–¹æ³• * * @param var1 ä»£ç†ç±»åç§° * @param var2 ç›®æ ‡ç±»æ¥å£é›†åˆ * @param var3 */ private ProxyGenerator(String var1, Class&lt;?&gt;[] var2, int var3) &#123; this.className = var1; this.interfaces = var2; this.accessFlags = var3; &#125; JDK åŠ¨æ€ä»£ç†æ¶‰åŠåˆ°çš„åŸºç¡€ç±»å…ˆä»‹ç»åˆ°è¿™é‡Œï¼Œä¸‹é¢æˆ‘ä»¬ä» Proxy.newProxyInstance å…¥å£å‡ºå‘ï¼Œæ ¹æ®è°ƒç”¨é“¾é€æ­¥åˆ†ææºä»£ç ã€‚ newProxyInstance123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566+--- Proxy /** * åˆ›å»ºä»£ç†å¯¹è±¡ã€‚ * * @param loader ä»£ç†ç±»çš„åŠ è½½å™¨ * @param interfaces ç›®æ ‡ç±»çš„æ¥å£åˆ—è¡¨ * @param h ä»£ç†å¯¹è±¡æ–¹æ³•è°ƒç”¨éƒ½ä¼šåˆ†æ´¾ç»™è¯¥è°ƒç”¨å¤„ç†å™¨ * @return ä»£ç†å¯¹è±¡ * @throws IllegalArgumentException */ @CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; // è°ƒç”¨å¤„ç†å™¨æ˜¯å¿…ä¼ å‚æ•° Objects.requireNonNull(h); // æ¥å£åˆ—è¡¨ final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; // 1. æŸ¥æ‰¾æˆ–ç”ŸæˆæŒ‡å®šçš„ä»£ç†ç±»ã€‚ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); try &#123; // å¯¹ç”Ÿæˆçš„ä»£ç†ç±»è¿›è¡Œå®‰å…¨æ£€æŸ¥ if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; // 2. è·å–ä»£ç†ç±»çš„æŒ‡å®šæ„é€ æ–¹æ³•ï¼Œå³å‚æ•°ç±»å‹ä¸º InvocationHandler çš„æ„é€ æ–¹æ³• final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; // 3. ä¿è¯ä»£ç†ç±»çš„æ„é€ æ–¹æ³• cons å…·æœ‰è®¿é—®æƒé™ï¼Œä¾¿äºåç»­åå°„åˆ›å»ºä»£ç†å¯¹è±¡ if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; // 4. åå°„åˆ›å»ºä»£ç†å¯¹è±¡ï¼Œæ³¨æ„å‚æ•°ä¸º InvocationHandler return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException | InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; Proxy.newProxyInstance æ–¹æ³•æ˜¯ç”Ÿæˆä»£ç†å¯¹è±¡çš„å…¥å£ï¼Œä¸‹é¢å¯¹è¯¥æ–¹æ³•çš„é€»è¾‘è¿›è¡Œç®€å•è¯´æ˜ï¼š è°ƒç”¨ getProxyClass0 æ–¹æ³•æ ¹æ®æŒ‡å®šçš„ç±»åŠ è½½å™¨å’Œæ¥å£åˆ—è¡¨è·å–ä»£ç†ç±»ã€‚è¿™ä¸€æ­¥æ˜¯æ•´ä¸ªä»£ç†é€»è¾‘çš„æ ¸å¿ƒå®ç°ã€‚ åå°„è·å–å‚æ•°ä¸º InvocationHandlerçš„ä»£ç†ç±»çš„æ„é€ æ–¹æ³•ï¼Œå¹¶ä¿è¯è¯¥æ„é€ æ–¹æ³•æ˜¯å¯è®¿é—®çš„ã€‚ é€šè¿‡ newInstance æ–¹æ³•åå°„åˆ›å»ºä»£ç†å¯¹è±¡ï¼Œå‚æ•°ç±»å‹ä¸º InvocationHandler ã€‚ ç¬¬ 2ã€3 æ­¥éƒ½å¾ˆå®¹æ˜“ç†è§£ï¼Œä¸‹é¢æˆ‘ä»¬é‡ç‚¹æ¥åˆ†æè·å–ä»£ç†ç±»çš„ getProxyClass0 æ–¹æ³•ã€‚ getProxyClass0123456789101112131415161718+--- Proxy /** * ç”Ÿæˆä»£ç†ç±»ã€‚åœ¨è°ƒç”¨æ­¤æ–¹æ³•ä¹‹å‰ï¼Œå¿…é¡»è°ƒç”¨checkProxyAccessæ–¹æ³•æ¥æ‰§è¡Œæƒé™æ£€æŸ¥ã€‚ */ private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(\"interface limit exceeded\"); &#125; /** * è·å–ä»£ç†ç±»ï¼š * 1. å¦‚æœä»£ç†ç±»å­˜åœ¨åˆ™è¿”å›ç¼“å­˜çš„å‰¯æœ¬ã€‚ * 2. ä¸å­˜åœ¨ï¼Œåˆ™é€šè¿‡ ProxyClassFactory åˆ›å»ºä»£ç†ç±» */ return proxyClassCache.get(loader, interfaces); &#125; å‰æ–‡ä¸­æœ‰æåˆ°ä»£ç†ç±»ç¼“å­˜å±æ€§ WeakCache proxyClassCache ï¼Œå®ƒçš„ä¸»è¦ä½œç”¨å°±æ˜¯å…ˆæŸ¥æ‰¾å¯¹åº”çš„ä»£ç†ç±»ç¼“å­˜ï¼Œæ²¡æœ‰çš„è¯å°±é€šè¿‡ java.lang.reflect.Proxy.ProxyClassFactory#apply æ–¹æ³•åˆ›å»ºä»£ç†ç±»ï¼Œè¯¥æ–¹æ³•åœ¨å‰æ–‡ä¸­å·²ç»è¯¦ç»†è¯´æ˜ã€‚ä¸‹é¢æˆ‘ä»¬å¯¹ ProxyGenerator.generateProxyClass æ ¹æ®ä»£ç†ç±»åå’Œæ¥å£ç”Ÿæˆä»£ç†ç±»å­—èŠ‚ç æ•°ç»„æˆ–æ–‡ä»¶å½¢å¼ è¿™ä¸€æ­¥éª¤è¿›è¡Œè¯´æ˜ã€‚ generateProxyClass123456789101112131415161718192021222324252627282930313233343536373839404142434445+--- ProxyGenerator/** * ç”Ÿæˆä»£ç†ç±»-å­—èŠ‚ç å½¢å¼ * * @param var0 ä»£ç†ç±»åç§° * @param var1 ç›®æ ‡ç±»æ¥å£ * @param var2 * @return */ public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) &#123; ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2); // ç”Ÿæˆç›®æ ‡ç±»çš„æ¥å£ä¿¡æ¯çš„å­—èŠ‚ç  final byte[] var4 = var3.generateClassFile(); // æ·»åŠ JVM å‚æ•° sun.misc.ProxyGenerator.saveGeneratedFiles ï¼Œåˆ™ä¿å­˜åˆ°æ–‡ä»¶ if (saveGeneratedFiles) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; try &#123; int var1 = var0.lastIndexOf(46); Path var2; if (var1 &gt; 0) &#123; // åˆ›å»ºç›®å½• Path var3 = Paths.get(var0.substring(0, var1).replace('.', File.separatorChar)); Files.createDirectories(var3); var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + \".class\"); &#125; else &#123; var2 = Paths.get(var0 + \".class\"); &#125; // ä¿å­˜åˆ°æ–‡ä»¶ Files.write(var2, var4, new OpenOption[0]); return null; &#125; catch (IOException var4x) &#123; throw new InternalError(\"I/O exception saving generated file: \" + var4x); &#125; &#125; &#125;); &#125; return var4; &#125; generateProxyClass æ–¹æ³•ç”¨äºæ ¹æ®ä»£ç†ç±»åç§°å’Œæ¥å£åˆ—è¡¨ç”Ÿæˆé¢„æœŸçš„ä»£ç†ç±»çš„å­—èŠ‚ç ï¼ˆæ•°ç»„ï¼‰ä¿¡æ¯ï¼Œæœ€åé€šè¿‡ JDK çš„æœ¬åœ°æ–¹æ³•è½¬åŒ–ä¸ºå…·ä½“çš„ä»£ç†ç±»ã€‚è¯¥æ–¹æ³•æ”¯æŒé€šè¿‡é…ç½®JVMå‚æ•°å°†ç›®æ ‡ä»£ç†ç±»è¾“å‡ºåˆ°æ–‡ä»¶ä¸­ã€‚ åœ¨åˆ†æ ProxyGenerator.generateClassFile æ–¹æ³•ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆå¯¹æ¶‰åŠçš„æ ¸å¿ƒç±»å’Œæ–¹æ³•è¿›è¡Œç®€å•è¯´æ˜ã€‚æ³¨æ„è¯¥æ–¹æ³•æ•´ä¸ªæµç¨‹æ¯”è¾ƒå¤æ‚ï¼Œæœ¬æ–‡åªå¯¹æ•´ä½“é€»è¾‘è¿›è¡Œè¯´æ˜ï¼Œå…·ä½“ç»†èŠ‚å¯ä»¥å‚è€ƒæºä»£ç ã€‚ ProxyMethodæ–¹æ³•ä»£ç†ç±»ï¼Œç”¨äºæ‹†è§£ã€å°è£… Method çš„ä¿¡æ¯ï¼Œä½œä¸ºåç»­æ–¹æ³•å­—èŠ‚ç ç”Ÿæˆçš„æ•°æ®æ¥æºã€‚ å±æ€§1234567891011121314151617181920212223242526+--- ProxyGenerator private class ProxyMethod &#123; // æ–¹æ³•å public String methodName; // å‚æ•°ç±»å‹ public Class&lt;?&gt;[] parameterTypes; // è¿”å›å€¼ç±»å‹ public Class&lt;?&gt; returnType; // å¼‚å¸¸ç±»å‹ public Class&lt;?&gt;[] exceptionTypes; // æ–¹æ³•æ‰€åœ¨æ¥å£ public Class&lt;?&gt; fromClass; // å½“å‰æ–¹æ³•å¯¹åº”çš„åºåˆ—å·ï¼Œå¦‚ m0 public String methodFieldName; private ProxyMethod(String var2, Class&lt;?&gt;[] var3, Class&lt;?&gt; var4, Class&lt;?&gt;[] var5, Class&lt;?&gt; var6) &#123; this.methodName = var2; this.parameterTypes = var3; this.returnType = var4; this.exceptionTypes = var5; this.fromClass = var6; this.methodFieldName = \"m\" + ProxyGenerator.this.proxyMethodCount++; &#125; // çœç•¥å…¶å®ƒä»£ç  &#125; generateMethod12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091+--- ProxyMethod private ProxyGenerator.MethodInfo generateMethod() throws IOException &#123; // æ–¹æ³•ç­¾å å¦‚ï¼štoString æ–¹æ³•çš„æè¿°ä¿¡æ¯ Ljava/lang/reflect/Method; void print(String message) æè¿°ä¿¡æ¯ (Ljava/lang/String;)V String var1 = ProxyGenerator.getMethodDescriptor(this.parameterTypes, this.returnType); // åˆ›å»º MethodInfo å¯¹è±¡ï¼ŒåŒæ—¶ä¼šåˆå§‹åŒ– ByteArrayOutputStream å¯¹è±¡ // 1. æ–¹æ³•å + æ–¹æ³•ç­¾å ProxyGenerator.MethodInfo var2 = ProxyGenerator.this.new MethodInfo(this.methodName, var1, 17); // 2. æ–¹æ³•å‚æ•° int[] var3 = new int[this.parameterTypes.length]; int var4 = 1; for (int var5 = 0; var5 &lt; var3.length; ++var5) &#123; var3[var5] = var4; var4 += ProxyGenerator.getWordsPerType(this.parameterTypes[var5]); &#125; byte var7 = 0; // é€šè¿‡å­—èŠ‚è¾“å‡ºæµ ByteArrayOutputStream å†™å…¥æ–¹æ³•çš„äºŒè¿›åˆ¶ä¿¡æ¯ï¼Œå³ MethodInfo ä¸­çš„è¾“å‡ºæµä¸­ DataOutputStream var9 = new DataOutputStream(var2.code); ProxyGenerator.this.code_aload(0, var9); // 3 å†™å…¥æ¥å£æ–¹æ³•çš„ InvocationHandler.invoke å¤„ç†é€»è¾‘ var9.writeByte(180); var9.writeShort(ProxyGenerator.this.cp.getFieldRef(\"java/lang/reflect/Proxy\", \"h\", \"Ljava/lang/reflect/InvocationHandler;\")); ProxyGenerator.this.code_aload(0, var9); var9.writeByte(178); var9.writeShort(ProxyGenerator.this.cp.getFieldRef(ProxyGenerator.dotToSlash(ProxyGenerator.this.className), this.methodFieldName, \"Ljava/lang/reflect/Method;\")); if (this.parameterTypes.length &gt; 0) &#123; ProxyGenerator.this.code_ipush(this.parameterTypes.length, var9); var9.writeByte(189); var9.writeShort(ProxyGenerator.this.cp.getClass(\"java/lang/Object\")); for (int var10 = 0; var10 &lt; this.parameterTypes.length; ++var10) &#123; var9.writeByte(89); ProxyGenerator.this.code_ipush(var10, var9); this.codeWrapArgument(this.parameterTypes[var10], var3[var10], var9); var9.writeByte(83); &#125; &#125; else &#123; var9.writeByte(1); &#125; var9.writeByte(185); var9.writeShort(ProxyGenerator.this.cp.getInterfaceMethodRef(\"java/lang/reflect/InvocationHandler\", \"invoke\", \"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;\")); var9.writeByte(4); var9.writeByte(0); // 4 è¿”å›ç±»å‹ if (this.returnType == Void.TYPE) &#123; var9.writeByte(87); var9.writeByte(177); &#125; else &#123; this.codeUnwrapReturnValue(this.returnType, var9); &#125; // 5 å†™å…¥æ–¹æ³•å¤„ç†å¼‚å¸¸å­—èŠ‚ä¿¡æ¯ short var6; short var8 = var6 = (short) var2.code.size(); List var13 = ProxyGenerator.computeUniqueCatchList(this.exceptionTypes); if (var13.size() &gt; 0) &#123; Iterator var11 = var13.iterator(); while (var11.hasNext()) &#123; Class var12 = (Class) var11.next(); var2.exceptionTable.add(new ProxyGenerator.ExceptionTableEntry(var7, var8, var6, ProxyGenerator.this.cp.getClass(ProxyGenerator.dotToSlash(var12.getName())))); &#125; var9.writeByte(191); var6 = (short) var2.code.size(); var2.exceptionTable.add(new ProxyGenerator.ExceptionTableEntry(var7, var8, var6, ProxyGenerator.this.cp.getClass(\"java/lang/Throwable\"))); ProxyGenerator.this.code_astore(var4, var9); var9.writeByte(187); var9.writeShort(ProxyGenerator.this.cp.getClass(\"java/lang/reflect/UndeclaredThrowableException\")); var9.writeByte(89); ProxyGenerator.this.code_aload(var4, var9); var9.writeByte(183); var9.writeShort(ProxyGenerator.this.cp.getMethodRef(\"java/lang/reflect/UndeclaredThrowableException\", \"&lt;init&gt;\", \"(Ljava/lang/Throwable;)V\")); var9.writeByte(191); &#125; if (var2.code.size() &gt; 65535) &#123; throw new IllegalArgumentException(\"code size limit exceeded\"); &#125; else &#123; var2.maxStack = 10; var2.maxLocals = (short) (var4 + 1); var2.declaredExceptions = new short[this.exceptionTypes.length]; for (int var14 = 0; var14 &lt; this.exceptionTypes.length; ++var14) &#123; var2.declaredExceptions[var14] = ProxyGenerator.this.cp.getClass(ProxyGenerator.dotToSlash(this.exceptionTypes[var14].getName())); &#125; return var2; &#125; &#125; generateMethod æ–¹æ³•æ ¹æ® ProxyMethod ä¿¡æ¯ï¼ŒæŒ‰ç…§æ–¹æ³•çš„æ„é€ ç»„è£…ä»£è¡¨å­—èŠ‚ç ä¿¡æ¯çš„ MethodInfoï¼Œæœ€ç»ˆå°†è¯¥ä¿¡æ¯å†™å…¥åˆ°è¾“å‡ºæµä¸­ã€‚ MethodInfoProxyMethod å¯¹è±¡ç»è¿‡è§£æåä¼šç»„è£…æˆ MethodInfo å¯¹è±¡ï¼Œè¯¥å¯¹è±¡å°è£…äº†ä»£ç†ç±»ä¸­æ–¹æ³•çš„å­—èŠ‚ç ä¿¡æ¯ã€‚ 1234567891011121314151617181920212223242526+--- ProxyGenerator private class MethodInfo &#123; public int accessFlags; // æ–¹æ³•å public String name; // æ–¹æ³•ç­¾å public String descriptor; public short maxStack; public short maxLocals; // è¾“å‡ºæµï¼Œæ–¹æ³•å­—èŠ‚ç ä¼šå†™å…¥åˆ°è¯¥æµä¸­ public ByteArrayOutputStream code = new ByteArrayOutputStream(); public List&lt;ProxyGenerator.ExceptionTableEntry&gt; exceptionTable = new ArrayList(); public short[] declaredExceptions; public MethodInfo(String var2, String var3, int var4) &#123; this.name = var2; this.descriptor = var3; this.accessFlags = var4; ProxyGenerator.this.cp.getUtf8(var2); ProxyGenerator.this.cp.getUtf8(var3); ProxyGenerator.this.cp.getUtf8(\"Code\"); ProxyGenerator.this.cp.getUtf8(\"Exceptions\"); &#125; // çœç•¥å†™å…¥è¾“å‡ºæµé€»è¾‘ &#125; FieldInfoFieldInfo ç”¨äºå°è£…æ–¹æ³•åœ¨ä»£ç†ç±»ä¸­çš„é™æ€å±æ€§ä¿¡æ¯ã€‚ 123456789101112131415161718192021222324+--- ProxyGenerator private class FieldInfo &#123; public int accessFlags; // m + Nï¼Œæ–¹æ³•åœ¨ä»£ç†ç±»ä¸­çš„å­—æ®µå public String name; // å›ºå®šå€¼ Ljava/lang/reflect/Method; public String descriptor; public FieldInfo(String var2, String var3, int var4) &#123; this.name = var2; this.descriptor = var3; this.accessFlags = var4; ProxyGenerator.this.cp.getUtf8(var2); ProxyGenerator.this.cp.getUtf8(var3); &#125; // å†™å…¥è¾“å‡ºæµ public void write(DataOutputStream var1) throws IOException &#123; var1.writeShort(this.accessFlags); var1.writeShort(ProxyGenerator.this.cp.getUtf8(this.name)); var1.writeShort(ProxyGenerator.this.cp.getUtf8(this.descriptor)); var1.writeShort(0); &#125; &#125; ä»‹ç»å®Œå¿…è¦çš„å‰ç½®æ¦‚å¿µå’Œç±»ä¿¡æ¯åï¼Œæˆ‘ä»¬å›åˆ° ProxyGenerator.generateClassFile æ–¹æ³•ï¼Œç»§ç»­æ¥ç€æµç¨‹å¾€ä¸‹åˆ†æã€‚ generateClassFile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138+--- ProxyGeneratorprivate byte[] generateClassFile() &#123; // 1. å°† Object ä¸­çš„ä¸‰å¤§æ–¹æ³•å¯¹è±¡Methodæ‹†è§£ï¼Œç»„è£…æˆ ProxyMethod å¯¹è±¡ this.addProxyMethod(hashCodeMethod, Object.class); this.addProxyMethod(equalsMethod, Object.class); this.addProxyMethod(toStringMethod, Object.class); // 2. å°†ç›®æ ‡ç±»çš„æ¥å£ä¸­çš„æ–¹æ³•å¯¹è±¡Methodæ‹†è§£ï¼Œç»„è£…æˆ ProxyMethod å¯¹è±¡ Class[] var1 = this.interfaces; int var2 = var1.length; int var3; Class var4; // 2.1 éå†æ¥å£ for (var3 = 0; var3 &lt; var2; ++var3) &#123; var4 = var1[var3]; // 2.3 è·å–æ¥å£ä¸­çš„æ–¹æ³•åˆ—è¡¨ Method[] var5 = var4.getMethods(); int var6 = var5.length; // 2.4 éå†å½“å‰æ¥å£ä¸­çš„æ–¹æ³• for (int var7 = 0; var7 &lt; var6; ++var7) &#123; Method var8 = var5[var7]; // 2.5 å¯¹æ¥å£ä¸­çš„æ–¹æ³•æ‹†è§£ã€ç»„è£…æˆ ProxyMethod å¯¹è±¡ï¼Œç„¶ååŠ å…¥ç¼“å­˜ proxyMethods ä¸­ this.addProxyMethod(var8, var4); &#125; &#125; // è·å–ç¼“å­˜çš„æ–¹æ³•ä»£ç†å¯¹è±¡ ProxyMethod é›†åˆ Iterator var11 = this.proxyMethods.values().iterator(); // æ ¡éªŒç›¸åŒæ–¹æ³•ç­¾åçš„è¿”å›ç±»å‹ List var12; while (var11.hasNext()) &#123; var12 = (List) var11.next(); checkReturnTypes(var12); &#125; Iterator var15; try &#123; // 3. ç”Ÿæˆæ„é€ æ–¹æ³•å­—èŠ‚ç ä¿¡æ¯å¹¶åŠ å…¥åˆ° methods ç¼“å­˜èµ·æ¥ this.methods.add(this.generateConstructor()); // 4. éå†æ–¹æ³•ä»£ç†å¯¹è±¡åˆ—è¡¨ï¼Œç”Ÿæˆæ–¹æ³•å­—èŠ‚ç ä¿¡æ¯å¹¶ç¼“å­˜åˆ° methods ä¸­ var11 = this.proxyMethods.values().iterator(); while (var11.hasNext()) &#123; var12 = (List) var11.next(); var15 = var12.iterator(); while (var15.hasNext()) &#123; ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod) var15.next(); // 4.1 ç”Ÿæˆæ–¹æ³•çš„ FieldInfo å¹¶åŠ å…¥åˆ° fields é›†åˆä¸­ï¼Œå³ä»£ç†ç±»ä¸­æ–¹æ³•Methodçš„å­—æ®µå±æ€§ this.fields.add(new ProxyGenerator.FieldInfo(var16.methodFieldName, \"Ljava/lang/reflect/Method;\", 10)); // 4.2 ç”Ÿæˆæ–¹æ³•çš„ MethodInfo å¹¶åŠ å…¥åˆ° methods é›†åˆä¸­ï¼Œæ³¨æ„ MethodInfo ä¸­çš„ ByteArrayOutputStream this.methods.add(var16.generateMethod()); &#125; &#125; // 5. ç”Ÿæˆé™æ€ä»£ç å—å­—èŠ‚ç ä¿¡æ¯ï¼ˆæ ¹æ® proxyMethods ä¸­çš„ä¿¡æ¯ï¼‰ this.methods.add(this.generateStaticInitializer()); &#125; catch (IOException var10) &#123; throw new InternalError(\"unexpected I/O Exception\", var10); &#125; // 6. æ–¹æ³•æ•°é‡é™åˆ¶ if (this.methods.size() &gt; 65535) &#123; throw new IllegalArgumentException(\"method limit exceeded\"); &#125; else if (this.fields.size() &gt; 65535) &#123; throw new IllegalArgumentException(\"field limit exceeded\"); &#125; else &#123; // 7. ä»£ç†ç±»å­—èŠ‚ç ç»„è£… // 7.1. å¤„ç†ä»£ç†ç±» å’Œ Proxy çš„å…¨è·¯å¾„ç±»ï¼Œå¹¶å…¥æ”¾å…¥å¸¸é‡æ±  cp ä¸­ this.cp.getClass(dotToSlash(this.className)); this.cp.getClass(\"java/lang/reflect/Proxy\"); // 7.2. å¤„ç†ä»£ç†ç±»çš„æ¥å£ï¼Œå¹¶æ”¾å…¥å¸¸é‡æ±  cp ä¸­ var1 = this.interfaces; var2 = var1.length; for (var3 = 0; var3 &lt; var2; ++var3) &#123; var4 = var1[var3]; this.cp.getClass(dotToSlash(var4.getName())); &#125; this.cp.setReadOnly(); // 7.3. å­—èŠ‚ç±»å‹æ•°æ®çš„è¾“å‡ºæµï¼Œå†…å­˜æ“ä½œæµ ByteArrayOutputStream var13 = new ByteArrayOutputStream(); DataOutputStream var14 = new DataOutputStream(var13); try &#123; var14.writeInt(-889275714); var14.writeShort(0); var14.writeShort(49); this.cp.write(var14); var14.writeShort(this.accessFlags); // 7.3.1 å†™å…¥ä»£ç†ç±»åç§°ä¿¡æ¯ var14.writeShort(this.cp.getClass(dotToSlash(this.className))); // 7.3.2 å†™å…¥Proxyåç§°ä¿¡æ¯ var14.writeShort(this.cp.getClass(\"java/lang/reflect/Proxy\")); // 7.3.4 å†™å…¥æ¥å£åˆ—è¡¨ var14.writeShort(this.interfaces.length); Class[] var17 = this.interfaces; int var18 = var17.length; // éå†æ¥å£åˆ—è¡¨ for (int var19 = 0; var19 &lt; var18; ++var19) &#123; Class var22 = var17[var19]; // å†™å…¥æ¥å£ä¿¡æ¯ var14.writeShort(this.cp.getClass(dotToSlash(var22.getName()))); &#125; /// 7.3.5 å†™å…¥å­—æ®µä¿¡æ¯ï¼Œå³æ¥å£æ–¹æ³•çš„æ ‡è¯†ï¼Œå¦‚ m1ã€m2 var14.writeShort(this.fields.size()); var15 = this.fields.iterator(); while (var15.hasNext()) &#123; ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo) var15.next(); var20.write(var14); &#125; // 7.3.6 å†™å…¥æ–¹æ³•ï¼ŒåŒ…æ‹¬æ„é€ æ–¹æ³•ã€é™æ€ä»£ç å— var14.writeShort(this.methods.size()); var15 = this.methods.iterator(); while (var15.hasNext()) &#123; ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo) var15.next(); var21.write(var14); &#125; var14.writeShort(0); // 4 è¿”å›å­—èŠ‚æ•°ç»„ä¿¡æ¯ return var13.toByteArray(); &#125; catch (IOException var9) &#123; throw new InternalError(\"unexpected I/O Exception\", var9); &#125; &#125; &#125; generateClassFile æ–¹æ³•é€»è¾‘è¿˜æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œä¸‹é¢å¯¹ä¸»è¦æµç¨‹è¿›è¡Œè¯´æ˜ï¼š å°† Object ä¸­çš„ä¸‰å¤§æ–¹æ³•å¯¹è±¡è§£æã€ç»„è£…æˆ ProxyMethod å¯¹è±¡ã€‚ å°†ç›®æ ‡ç±»çš„æ¥å£ä¸­çš„æ–¹æ³•å¯¹è±¡è§£æã€ç»„è£…æˆ ProxyMethod å¯¹è±¡ã€‚ ç”Ÿæˆæ„é€ æ–¹æ³•å­—èŠ‚ç ä¿¡æ¯å¹¶å°è£…åˆ° MethodInfo å¯¹è±¡ä¸­ã€‚ å°†ç¬¬ 1ã€2 æ­¥éª¤ä¸­ç»„è£…çš„ ProxyMethod å¯¹è±¡è¿›è¡Œè§£æï¼Œç”Ÿæˆä»£è¡¨è¯¥æ–¹æ³•å­—æ®µæ ‡è¯†çš„ FieldInfo å¯¹è±¡å¹¶ç¼“å­˜èµ·æ¥ï¼Œè§£æä¸ºè¯¥æ–¹æ³•çš„å­—èŠ‚ç ä¿¡æ¯çš„ MethodInfo å¯¹è±¡å¹¶ç¼“å­˜èµ·æ¥ã€‚ æ ¹æ®ç¬¬ 1ã€2 æ­¥éª¤ä¸­ç»„è£…çš„ ProxyMethod å¯¹è±¡ç”Ÿæˆé™æ€ä»£ç å—å­—èŠ‚ç ä¿¡æ¯å¹¶å°è£…åˆ° MethodInfo å¯¹è±¡ä¸­å¹¶ç¼“å­˜èµ·æ¥ã€‚ å¯¹ä»£ç†ç±»ä¸­çš„æ–¹æ³•æ•°é‡åšé™åˆ¶ã€‚ ä¾æ¬¡å°†ä»£ç†ç±»ç›¸å…³ç±»è·¯å¾„ã€æ¥å£è·¯å¾„ã€ä»£ç†ç±»åã€Proxyåã€æ¥å£åã€FieldInfoä¿¡æ¯ã€MehodInfoä¿¡æ¯å†™å…¥åˆ°å­—èŠ‚è¾“å‡ºæµä¸­ã€‚ ç”Ÿæˆä»£ç†ç±»å­—èŠ‚ç æ•°ç»„ æ•´ä¸ªè¿‡ç¨‹ä»‹ç»å®Œæ¯•ï¼Œä¸‹é¢å¯¹è¯¥è¿‡ç¨‹ä¸­æ¶‰åŠçš„æ ¸å¿ƒæ–¹æ³•è¿›è¡Œè¯´æ˜ã€‚ addProxyMethod1234567891011121314151617181920212223242526272829303132333435363738394041424344+--- ProxyGenerator /** * å°†æ–¹æ³•å¯¹è±¡æ‹†è§£ï¼Œç»„è£…æˆ ProxyMethod å¯¹è±¡ * * @param var1 æ–¹æ³•å¯¹è±¡ * @param var2 æ–¹æ³•æ‰€åœ¨æ¥å£/ç±» */ private void addProxyMethod(Method var1, Class&lt;?&gt; var2) &#123; // 1 æ–¹æ³•å String var3 = var1.getName(); // 2 æ–¹æ³•å‚æ•°ç±»å‹ Class[] var4 = var1.getParameterTypes(); // 3 æ–¹æ³•è¿”å›ç±»å‹ Class var5 = var1.getReturnType(); // 4 æ–¹æ³•å¼‚å¸¸ç±»å‹ Class[] var6 = var1.getExceptionTypes(); // 5 æ–¹æ³•ç­¾åï¼Œå¦‚ hashCode()ã€equals(Ljava/lang/Object;)ï¼Œæœ€ä¸ºç¼“å­˜çš„ key String var7 = var3 + getParameterDescriptors(var4); Object var8 = (List) this.proxyMethods.get(var7); if (var8 != null) &#123; Iterator var9 = ((List) var8).iterator(); while (var9.hasNext()) &#123; ProxyGenerator.ProxyMethod var10 = (ProxyGenerator.ProxyMethod) var9.next(); if (var5 == var10.returnType) &#123; ArrayList var11 = new ArrayList(); collectCompatibleTypes(var6, var10.exceptionTypes, var11); collectCompatibleTypes(var10.exceptionTypes, var6, var11); var10.exceptionTypes = new Class[var11.size()]; var10.exceptionTypes = (Class[]) var11.toArray(var10.exceptionTypes); return; &#125; &#125; &#125; else &#123; var8 = new ArrayList(3); this.proxyMethods.put(var7, var8); &#125; // åˆ›å»º ProxyMethod å¯¹è±¡ï¼Œå¹¶ä¿å­˜åˆ° proxyMethods ä¸­ ((List) var8).add(new ProxyGenerator.ProxyMethod(var3, var4, var5, var6, var2)); &#125; ä¸Šè¿°æ–¹æ³•ç”¨äºå°† Method å¯¹è±¡æ‹†è§£ã€ç»„è£…ä¸º ProxyMethod å¯¹è±¡ï¼Œä¸ºåç»­ç»„è£…ä»£ç†ç±»çš„æ–¹æ³•å­—èŠ‚ç åšå‡†å¤‡ã€‚ generateConstructor1234567891011121314151617+--- ProxyGenerator private ProxyGenerator.MethodInfo generateConstructor() throws IOException &#123; // åˆ›å»ºæ„é€ æ–¹æ³•å­—èŠ‚ç çš„ MethodInfo ProxyGenerator.MethodInfo var1 = new ProxyGenerator.MethodInfo(\"&lt;init&gt;\", \"(Ljava/lang/reflect/InvocationHandler;)V\", 1); // å†™å…¥ MethodInfo çš„è¾“å‡ºæµä¸­ DataOutputStream var2 = new DataOutputStream(var1.code); this.code_aload(0, var2); this.code_aload(1, var2); var2.writeByte(183); var2.writeShort(this.cp.getMethodRef(\"java/lang/reflect/Proxy\", \"&lt;init&gt;\", \"(Ljava/lang/reflect/InvocationHandler;)V\")); var2.writeByte(177); var1.maxStack = 10; var1.maxLocals = 2; var1.declaredExceptions = new short[0]; return var1; &#125; generateConstructor æ–¹æ³•ç”¨äºç”Ÿæˆæ„é€ æ–¹æ³•çš„å­—èŠ‚ç ä¿¡æ¯ã€‚ generateStaticInitializer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657+--- ProxyGenerator private ProxyGenerator.MethodInfo generateStaticInitializer() throws IOException &#123; ProxyGenerator.MethodInfo var1 = new ProxyGenerator.MethodInfo(\"&lt;clinit&gt;\", \"()V\", 8); byte var2 = 1; byte var4 = 0; DataOutputStream var6 = new DataOutputStream(var1.code); // è·å–æ–¹æ³•åˆ—è¡¨ Iterator var7 = this.proxyMethods.values().iterator(); // æ ¹æ®æ–¹æ³•ä¿¡æ¯åˆå§‹åŒ–å¯¹åº”çš„å­—æ®µ while (var7.hasNext()) &#123; List var8 = (List) var7.next(); Iterator var9 = var8.iterator(); while (var9.hasNext()) &#123; ProxyGenerator.ProxyMethod var10 = (ProxyGenerator.ProxyMethod) var9.next(); // æ–¹æ³•å­—æ®µåˆå§‹åŒ– var10.codeFieldInitialization(var6); &#125; &#125; // å¼‚å¸¸å¤„ç† var6.writeByte(177); short var3; short var5 = var3 = (short) var1.code.size(); var1.exceptionTable.add(new ProxyGenerator.ExceptionTableEntry(var4, var5, var3, this.cp.getClass(\"java/lang/NoSuchMethodException\"))); this.code_astore(var2, var6); var6.writeByte(187); var6.writeShort(this.cp.getClass(\"java/lang/NoSuchMethodError\")); var6.writeByte(89); this.code_aload(var2, var6); var6.writeByte(182); var6.writeShort(this.cp.getMethodRef(\"java/lang/Throwable\", \"getMessage\", \"()Ljava/lang/String;\")); var6.writeByte(183); var6.writeShort(this.cp.getMethodRef(\"java/lang/NoSuchMethodError\", \"&lt;init&gt;\", \"(Ljava/lang/String;)V\")); var6.writeByte(191); var3 = (short) var1.code.size(); var1.exceptionTable.add(new ProxyGenerator.ExceptionTableEntry(var4, var5, var3, this.cp.getClass(\"java/lang/ClassNotFoundException\"))); this.code_astore(var2, var6); var6.writeByte(187); var6.writeShort(this.cp.getClass(\"java/lang/NoClassDefFoundError\")); var6.writeByte(89); this.code_aload(var2, var6); var6.writeByte(182); var6.writeShort(this.cp.getMethodRef(\"java/lang/Throwable\", \"getMessage\", \"()Ljava/lang/String;\")); var6.writeByte(183); var6.writeShort(this.cp.getMethodRef(\"java/lang/NoClassDefFoundError\", \"&lt;init&gt;\", \"(Ljava/lang/String;)V\")); var6.writeByte(191); if (var1.code.size() &gt; 65535) &#123; throw new IllegalArgumentException(\"code size limit exceeded\"); &#125; else &#123; var1.maxStack = 10; var1.maxLocals = (short) (var2 + 1); var1.declaredExceptions = new short[0]; return var1; &#125; &#125; generateStaticInitializer æ–¹æ³•ç”¨äºç”Ÿæˆä»£ç†ç±»çš„é™æ€ä»£ç å—ä¿¡æ¯ã€‚ è‡³æ­¤ï¼ŒJDK åŠ¨æ€ä»£ç†çš„æ•´ä¸ªæµç¨‹ä»‹ç»å®Œæ¯•ã€‚ å°ç»“JDK åŠ¨æ€ä»£ç†æ˜¯é’ˆå¯¹æ¥å£åšçš„ä»£ç†ï¼Œç›®æ ‡ç±»æ²¡æœ‰å®ç°æ¥å£æ˜¯æ— æ³•é€šè¿‡è¿™ä¸ªæ–¹å¼åˆ›å»ºä»£ç†å¯¹è±¡ã€‚é€šè¿‡æ‹¼æ¥å­—èŠ‚ç ç”Ÿæˆç±»æ˜¯ååˆ†çµæ´»çš„ï¼Œç†è®ºä¸Šä¸ç®¡æ˜¯æœ‰æ¥å£çš„ç±»è¿˜æ˜¯æ™®é€šç±»éƒ½æ˜¯å¯ä»¥å®ç°ä»£ç†çš„ï¼ŒCGLIB å°±æ˜¯é€šè¿‡æ‹¼æ¥å­—èŠ‚ç æ¥å®ç°éæ¥å£ç±»çš„ä»£ç†é€»è¾‘ã€‚","categories":[{"name":"JDK","slug":"JDK","permalink":"https://gentryhuang.com/categories/JDK/"}],"tags":[{"name":"ä»£ç†","slug":"ä»£ç†","permalink":"https://gentryhuang.com/tags/%E4%BB%A3%E7%90%86/"}]},{"title":"å¹¶å‘ - çº¿ç¨‹æ± å·¥å…·ç±»","slug":"concurrent/çº¿ç¨‹æ± å·¥å…·ç±»","date":"2020-12-09T16:00:00.000Z","updated":"2020-12-24T13:19:46.316Z","comments":false,"path":"posts/9e3a7d05/","link":"","permalink":"https://gentryhuang.com/posts/9e3a7d05/","excerpt":"","text":"å‰è¨€ä¸Šä¸€ç¯‡æ–‡ç«  çº¿ç¨‹æ±  å¯¹çº¿ç¨‹æ± çš„åŸç†è¿›è¡Œäº†è¯´æ˜ï¼Œå¹¶å¯¹çº¿ç¨‹æ± çš„æºç è¿›è¡Œäº†æ·±å…¥åˆ†æï¼Œæœ¬ç¯‡æ–‡ç« å¯¹çº¿ç¨‹å·¥å…·ç±» Executors è¿›è¡Œåˆ†æï¼Œéœ€è¦è¯´æ˜çš„æ˜¯ Executors ä¸­é™¤äº†å¹¶è¡Œè®¡ç®—çš„ WorkStealingPool çº¿ç¨‹æ± ï¼Œå…¶å®ƒçš„éƒ½æ˜¯ç›´æ¥åŸºäº ThreadPoolExecutor æ¥å®ç°çš„ã€‚æœ¬ç¯‡æ–‡ç« ä¸»è¦è¯´æ˜ Executors åŸºäº ThreadPoolExecutor åˆ›å»ºçš„çº¿ç¨‹æ± ã€‚ FixedThreadPoolFixedThreadPool å±äºå›ºå®šçº¿ç¨‹æ•°çš„çº¿ç¨‹æ± ï¼Œä½¿ç”¨ Executors.newFixedThreadPool() æ–¹æ³•åˆ›å»ºã€‚ æ„é€ æ–¹æ³• æŒ‡å®šçº¿ç¨‹æ•°1234567891011/** * åˆ›å»ºå›ºå®šæ•°é‡çš„çº¿ç¨‹æ±  * * @param nThreads æ ¸å¿ƒçº¿ç¨‹æ•° = æœ€å¤§çº¿ç¨‹æ•° * @return */public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; æŒ‡å®šçº¿ç¨‹æ•°å’Œçº¿ç¨‹å·¥å‚12345678910111213/** * åˆ›å»ºå›ºå®šæ•°é‡çš„çº¿ç¨‹æ±  * * @param nThreads æ ¸å¿ƒçº¿ç¨‹æ•° = æœ€å¤§çº¿ç¨‹æ•° * @param threadFactory çº¿ç¨‹å·¥å‚ * @return */public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);&#125; ç‰¹ç‚¹æ ¸å¿ƒçº¿ç¨‹æ•°å’Œæœ€å¤§çº¿ç¨‹æ•°ä¸€è‡´ï¼Œå¹¶ä¸”ä½¿ç”¨çš„ä»»åŠ¡é˜Ÿåˆ—ä¸ºæ— ç•Œé˜Ÿåˆ—ã€‚çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°éšç€ä»»åŠ¡çš„æäº¤ä¼šä» 0 å¢åŠ åˆ°æ ¸å¿ƒçº¿ç¨‹æ•° nThreadsï¼Œå®Œæˆé¢„çƒ­ä¹‹åï¼Œçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°å°†ä¼šä¿æŒ nThreadsï¼Œä¹‹åçš„ä»»åŠ¡æäº¤ä¸€å¾‹æ”¾å…¥ä»»åŠ¡é˜Ÿåˆ—ä¸­ï¼Œç”±ç©ºé—²çš„æ ¸å¿ƒçº¿ç¨‹ä»é˜Ÿåˆ—å–å‡ºå¹¶æ‰§è¡Œã€‚å¦‚æœæœ‰å·¥ä½œçº¿ç¨‹é€€å‡ºï¼Œçº¿ç¨‹æ± å°†ä¼šåˆ›å»ºæ–°çš„å·¥ä½œçº¿ç¨‹ä»¥è¡¥è¶³æ‰§è¡Œçš„æ•°ç›® nThreads ã€‚æ­¤å¤–ï¼Œç”±äºä½¿ç”¨çš„æ˜¯æ— ç•Œé˜Ÿåˆ—ï¼Œéšè—çš„é»˜è®¤æ‹’ç»ç­–ç•¥æ˜¯æ— æ•ˆçš„ï¼Œå¹¶ä¸”é»˜è®¤æƒ…å†µä¸‹çº¿ç¨‹æ± æ˜¯ä¸ä¼šå›æ”¶æ ¸å¿ƒçº¿ç¨‹æ•°å†…çš„çº¿ç¨‹ï¼ŒkeepAliveTime åŒæ ·æ˜¯ä¸ªæ— æ•ˆå‚æ•°ã€‚ è¿è¡Œç¤ºæ„å›¾ é€‚ç”¨åœºæ™¯é€‚ç”¨äºä¸ºäº†æ»¡è¶³èµ„æºç®¡ç†çš„éœ€æ±‚ï¼Œè€Œéœ€è¦é™åˆ¶çº¿ç¨‹æ•°é‡çš„åº”ç”¨åœºæ™¯ã€‚ å­˜åœ¨é—®é¢˜ç”±äºä½¿ç”¨äº†æ— ç•Œçš„ä»»åŠ¡é˜Ÿåˆ—ï¼Œå½“å¤§é‡çš„ä»»åŠ¡æäº¤åˆ°çº¿ç¨‹æ± ï¼Œå¯èƒ½ä¼šé€ æˆä»»åŠ¡å †ç§¯ï¼Œè€Œçº¿ç¨‹æ± çš„æ‹’ç»ç­–ç•¥åˆå¤„äºå¤±æ•ˆçŠ¶æ€ï¼Œä»è€Œå¯¼è‡´ OOM ã€‚ SingleThreadExecutorSingleThreadExecutor å±äºå›ºå®šçº¿ç¨‹æ•°çš„çº¿ç¨‹æ± ï¼Œä½¿ç”¨ Executors.newSingleThreadExecutor() æ–¹æ³•åˆ›å»ºã€‚ æ„é€ æ–¹æ³•1234567891011121314151617181920212223/** * åˆ›å»ºå•ä¸ªçº¿ç¨‹çš„çº¿ç¨‹æ±  * * @return */ public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; /** * åˆ›å»ºå•ä¸ªçº¿ç¨‹çš„çº¿ç¨‹æ±  * * @param threadFactory çº¿ç¨‹å·¥å‚ * @return */ public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory)); &#125; ç‰¹ç‚¹SingleThreadExecutor å’Œ FixedThreadPool åŸºæœ¬ä¸€è‡´ï¼ŒåŒºåˆ«åœ¨äºå‰è€…çš„æ ¸å¿ƒçº¿ç¨‹æ•°å’Œæœ€å¤§çº¿ç¨‹æ•°å›ºå®šä¸º 1 ï¼Œå¹¶ä¸”æ˜¯ä¸€ä¸ªåŒ…è£… ThreadPoolExecutor çš„çº¿ç¨‹æ± ï¼Œæ”¯æŒè°ƒç”¨ finalize() æ–¹æ³•é€šçŸ¥åƒåœ¾æ”¶é›†å™¨æ—¶å…³é—­çº¿ç¨‹æ± ã€‚ è¿è¡Œç¤ºæ„å›¾ é€‚ç”¨åœºæ™¯ä¿è¯äº†æ‰€æœ‰ä»»åŠ¡éƒ½æ˜¯è¢«é¡ºåºæ‰§è¡Œï¼Œä»»æ„æ—¶é—´ç‚¹æœ€å¤šä¼šæœ‰ä¸€ä¸ªä»»åŠ¡å¤„äºæ´»åŠ¨çŠ¶æ€ã€‚ å­˜åœ¨é—®é¢˜å’Œ FixedThreadPool æ˜¯ä¸€æ ·çš„é—®é¢˜ï¼Œä½¿ç”¨äº†æ— ç•Œçš„ä»»åŠ¡é˜Ÿåˆ—ï¼Œå½“å¤§é‡çš„ä»»åŠ¡æäº¤åˆ°çº¿ç¨‹æ± ï¼Œå¯èƒ½ä¼šé€ æˆä»»åŠ¡å †ç§¯ï¼Œè€Œçº¿ç¨‹æ± çš„æ‹’ç»ç­–ç•¥åˆå¤„äºå¤±æ•ˆçŠ¶æ€ï¼Œä»è€Œå¯¼è‡´ OOM ã€‚ CachedThreadPoolCachedThreadPool å±äºç¼“å†²çº¿ç¨‹æ± ï¼Œä¼šæ ¹æ®éœ€è¦åˆ›å»ºæ–°çº¿ç¨‹ã€‚ä½¿ç”¨ Executors.newCachedThreadPool() æ–¹æ³•åˆ›å»ºã€‚ æ„é€ æ–¹æ³•1234567891011121314public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory);&#125; ç‰¹ç‚¹æ ¸å¿ƒçº¿ç¨‹æ•°ä¸º 0 ï¼Œæœ€å¤§çº¿ç¨‹æ•°ä¸º Integer.MAX_VALUEï¼Œå¯ä»¥è®¤ä¸ºæ˜¯æ— ç•Œçš„ã€‚ä½¿ç”¨çš„ä»»åŠ¡é˜Ÿåˆ—æ˜¯æ²¡æœ‰å®¹é‡çš„ SynchronousQueue ï¼Œå³çº¿ç¨‹æ± ä½¿ç”¨è¿™ä¸ªé˜Ÿåˆ—æ„å‘³ç€æ¯æ¬¡éƒ½è¦åˆ›å»ºæ–°çš„çº¿ç¨‹æ¥å¤„ç†ä»»åŠ¡ã€‚ keepAliveTime è¢«è®¾ç½®ä¸º 60Lï¼Œå•ä½ä¸º TimeUnit.SECONDS ï¼Œæ„å‘³ç€ CachedThreadPool ä¸­çš„ç©ºé—²çº¿ç¨‹ç­‰å¾…ä»»åŠ¡çš„æœ€å¤§æ—¶é•¿ä¸º 60s ã€‚ CachedThreadPool æ€»ä½“ä¸Šæœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹ç‚¹ï¼š æ— æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œä¸”æœ€å¤§çš„çº¿ç¨‹æ•°æ˜¯ Integer.MAX_VALUE ã€‚ ä»»åŠ¡é˜Ÿåˆ—å¹¶ä¸ä¼šå­˜å‚¨ä»»åŠ¡ï¼Œå¦‚æœæœ‰ç©ºé—²çº¿ç¨‹åˆ™é˜Ÿåˆ—ä¼šæŠŠä»»åŠ¡äº¤ç»™ç©ºé—²çº¿ç¨‹æ‰§è¡Œï¼Œå¦‚æœæ²¡æœ‰ç©ºé—²çº¿ç¨‹åˆ™è¿«ä½¿çº¿ç¨‹æ± å°è¯•åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹æ‰§è¡Œä»»åŠ¡ã€‚è¿™ä¸ªç‰¹ç‚¹æ˜¯ä»»åŠ¡é˜Ÿåˆ— SynchronousQueue æä¾›çš„ã€‚ ç”±äº keepAliveTime è¢«è®¾ç½®ä¸º 60Lï¼Œå› æ­¤ä¼šåœ¨è¯¥æ—¶é—´å†…ç¼“å­˜çº¿ç¨‹ï¼Œè¢«ç¼“å­˜çš„çº¿ç¨‹ä¼šç­‰å¾… SynchronousQueue é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ã€‚ çº¿ç¨‹æ± é•¿æ—¶é—´é—²ç½®å¾—è¯ä¹Ÿä¸ä¼šæ¶ˆè€—ä»€ä¹ˆèµ„æºï¼Œå› ä¸ºçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹éƒ½æ˜¯å¯å›æ”¶çš„ï¼Œå’Œå›ºå®šçº¿ç¨‹æ•°çš„çº¿ç¨‹æ± ä¸åŒï¼Œæ ¸å¿ƒçº¿ç¨‹ä¼šä¸æ–­è½®è¯¢ä»»åŠ¡ï¼ˆä¸å¼€å¯å›æ”¶æ ¸å¿ƒçº¿ç¨‹ï¼‰ã€‚ SynchronousQueueä¸€ä¸ªæ¯”è¾ƒç‰¹æ®Šçš„é˜»å¡é˜Ÿåˆ—ï¼Œå…¶æœ¬èº«ä¸å­˜å‚¨å…ƒç´ ã€‚æ¯ä¸ªæ’å…¥æ“ä½œå¿…é¡»ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œç§»é™¤æ“ä½œï¼Œåä¹‹äº¦ç„¶ã€‚å¦‚æœä½¿ç”¨è¯¥é˜»å¡é˜Ÿåˆ—ï¼Œåªæœ‰å½“ä¸¤ä¸ªçº¿ç¨‹æ‰§è¡Œç›¸åæ¨¡å¼çš„æ“ä½œæ‰èƒ½é…å¯¹æˆåŠŸï¼Œå¦åˆ™å…ˆæ‰§è¡Œçš„ä¸€æ–¹åªèƒ½ç­‰å¾…ã€‚ä¸‹å›¾æ˜¯å¯¹çº¿ç¨‹æ± ä½¿ç”¨è¯¥é˜Ÿåˆ—å¤„ç†ä»»åŠ¡è¿‡ç¨‹çš„æè¿°ï¼š è¿è¡Œç¤ºæ„å›¾ é€‚ç”¨åœºæ™¯å¤„ç†å¤§é‡çŸ­æ—¶é—´ä»»åŠ¡ï¼Œæˆ–è€…è´Ÿè½½è¾ƒè½»çš„æœåŠ¡å™¨ã€‚ å­˜åœ¨é—®é¢˜ç”±äºå…è®¸åˆ›å»ºçº¿ç¨‹æ•°é‡ä¸º Integer.MAX_VALUEï¼Œå¯èƒ½ä¼šåˆ›å»ºå¤§é‡çš„çº¿ç¨‹æœ€ç»ˆè¶…è¿‡äº†æ“ä½œç³»ç»Ÿçš„ä¸Šé™è€Œæ— æ³•åˆ›å»ºæ–°çº¿ç¨‹ï¼Œå®¹æ˜“å¯¼è‡´ CPU é£™å‡å’Œ OOMã€‚ Executors åˆ›å»ºçº¿ç¨‹é—®é¢˜Executors å·¥å…·ç±»åˆ›å»ºçš„çº¿ç¨‹æ± éƒ½ä¼šå­˜åœ¨ä¸€å®šçš„é£é™©ï¼Œç›¸æ¯”è¾ƒè€Œè¨€æ‰‹åŠ¨åˆ›å»ºçº¿ç¨‹æ± æ›´åŠ åˆç†ï¼Œå› ä¸ºå¯ä»¥æ ¹æ®ä¸åŒçš„åœºæ™¯å¯¹çº¿ç¨‹æ± è¿›è¡Œå®šåˆ¶ï¼Œæ¥æå‡ç¨‹åºçš„æ€§èƒ½å’Œå‡å°‘èµ„æºæ¶ˆè€—ã€‚ å°ç»“æ— è®ºæ˜¯ä½¿ç”¨ Executors å·¥å…·ç±»è¿˜æ˜¯å®šåˆ¶çº¿ç¨‹æ± ï¼Œéƒ½åº”è¯¥é¿å…ä»»åŠ¡å¤§é‡å †ç§¯ï¼Œå¦åˆ™å¯èƒ½å‡ºç° OOM ï¼›è¿˜åº”è¯¥é¿å…è¿‡åº¦åˆ›å»ºæ–°çº¿ç¨‹ï¼Œå¦åˆ™å¯èƒ½ç”±äºåˆ›å»ºå¤§é‡çº¿ç¨‹å¯¼è‡´ç³»ç»Ÿå´©æºƒã€‚","categories":[{"name":"JDK","slug":"JDK","permalink":"https://gentryhuang.com/categories/JDK/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://gentryhuang.com/tags/JUC/"}]},{"title":"å¹¶å‘ - çº¿ç¨‹æ± ","slug":"concurrent/ThreadPool","date":"2020-12-02T16:00:00.000Z","updated":"2021-03-12T06:10:39.314Z","comments":false,"path":"posts/d7cef21d/","link":"","permalink":"https://gentryhuang.com/posts/d7cef21d/","excerpt":"","text":"å‰è¨€æœ€åˆçš„æ—¶å€™å¹¶æ²¡æœ‰çº¿ç¨‹æ± çš„æ¦‚å¿µï¼Œè€Œæ˜¯å…ˆæœ‰çº¿ç¨‹ã€‚æ¯ä¸ªä»»åŠ¡éƒ½éœ€è¦å¯¹åº”ä¸€ä¸ªçº¿ç¨‹ï¼Œä»»åŠ¡å°‘çš„æƒ…å†µæ²¡æœ‰å¤ªå¤§é—®é¢˜ï¼Œä»»åŠ¡è¿‡å¤šå°±å‡ºç°äº†å„ç§æ€§èƒ½å’Œèµ„æºå¼€é”€é—®é¢˜ï¼Œæ›´é‡è¦çš„æ˜¯å¯åˆ›å»ºçº¿ç¨‹çš„æ•°é‡æ˜¯æœ‰ä¸Šé™çš„ï¼Œä¸å¯èƒ½æ— é™çš„åˆ›å»ºã€‚åœ¨å¹¶å‘ç¯å¢ƒä¸‹ï¼Œç³»ç»Ÿä¸èƒ½å¤Ÿç¡®å®šåœ¨æŸä¸€æ—¶åˆ»æœ‰å¤šå°‘ä»»åŠ¡éœ€è¦æ‰§è¡Œï¼Œæœ‰å¤šå°‘èµ„æºéœ€è¦æŠ•å…¥ã€‚ é’ˆå¯¹ä¸Šè¿°é—®é¢˜ï¼Œäºæ˜¯è¯ç”Ÿäº†çº¿ç¨‹æ± ï¼Œç”¨æ¥å¹³è¡¡çº¿ç¨‹ä¸ç³»ç»Ÿèµ„æºä¹‹é—´çš„å…³ç³»ã€‚çº¿ç¨‹æ± è§£å†³é—®é¢˜æ€è·¯å¦‚ä¸‹ï¼š å¯¹äºåå¤åˆ›å»ºçº¿ç¨‹å¼€é”€é—®é¢˜ï¼Œçº¿ç¨‹æ± é‡‡ç”¨å›ºå®šæ•°é‡çš„çº¿ç¨‹ä¸€ç›´ä¿æŒå·¥ä½œçŠ¶æ€å¹¶èƒ½åå¤æ‰§è¡Œä»»åŠ¡ã€‚ å¯¹äºåˆ›å»ºè¿‡å¤šçº¿ç¨‹å ç”¨å¤ªå¤šèµ„æºé—®é¢˜ï¼Œçº¿ç¨‹æ± ä¼šæ ¹æ®éœ€è¦åˆ›å»ºçº¿ç¨‹ï¼Œçµæ´»åœ°æ§åˆ¶çº¿ç¨‹æ•°é‡ï¼Œé¿å…ä½¿ç”¨è¿‡å¤šèµ„æºã€‚ æ¦‚è¿°çº¿ç¨‹æ± æ˜¯ä¸€ç§ç®¡ç†çº¿ç¨‹å’Œä»»åŠ¡çš„å·¥å…·ï¼Œæ˜¯åº”ç”¨åœºæ™¯æœ€å¤šçš„å¹¶å‘æ¡†æ¶ä¹‹ä¸€ï¼Œå‡ ä¹æ‰€æœ‰éœ€è¦å¼‚æ­¥æˆ–å¹¶å‘æ‰§è¡Œä»»åŠ¡çš„åº”ç”¨ç¨‹åºéƒ½å¯ä»¥ä½¿ç”¨çº¿ç¨‹æ± ï¼Œåˆç†åœ°ä½¿ç”¨çº¿ç¨‹æ± å¯ä»¥å¸¦æ¥å¯è§‚å¾—æ€§èƒ½æå‡å’Œå“åº”é€Ÿåº¦ã€‚å…·ä½“å¥½å¤„å¦‚ä¸‹ï¼š è§£è€¦ï¼šçº¿ç¨‹çš„åˆ›å»ºä¸ä»»åŠ¡æ‰§è¡Œå®Œå…¨åˆ†å¼€ã€‚ é™ä½èµ„æºæ¶ˆè€—ï¼šçº¿ç¨‹çš„å¤ç”¨é™ä½äº†çº¿ç¨‹åˆ›å»ºå’Œé”€æ¯å¸¦æ¥çš„èµ„æºæ¶ˆè€—ã€‚ æé«˜å“åº”é€Ÿåº¦ï¼šå¤§å¤šæƒ…å†µä¸‹ï¼ˆçº¿ç¨‹æ± é¢„çƒ­åï¼‰ï¼Œåˆ°è¾¾çš„ä»»åŠ¡å¯ä»¥ä¸éœ€è¦ç­‰å¾…çº¿ç¨‹åˆ›å»ºå°±èƒ½ç«‹å³æ‰§è¡Œï¼Œæ¶ˆé™¤äº†çº¿ç¨‹åˆ›å»ºæ‰€å¸¦æ¥çš„å»¶è¿Ÿï¼Œæå‡äº†å“åº”é€Ÿåº¦ã€‚ ä¾¿äºçº¿ç¨‹ç®¡ç†ï¼šçº¿ç¨‹æ˜¯ç¨€ç¼ºèµ„æºï¼Œä¸èƒ½æ— é™åˆ¶åœ°åˆ›å»ºï¼Œä½¿ç”¨çº¿ç¨‹æ± å¯ä»¥å¯¹çº¿ç¨‹è¿›è¡Œç»Ÿä¸€åˆ†é…ã€è°ƒä¼˜å’Œç›‘æ§ã€‚ å…³äºçº¿ç¨‹æ± çš„æ¦‚è¿°å°±ä»‹ç»è¿™ä¹ˆå¤šï¼Œæœ¬ç¯‡æ–‡ç« ä»‹ç»çš„çº¿ç¨‹æ± æ ¸å¿ƒæ˜¯ JDK ä¸­æä¾›çš„ ThreadPoolExecutor ç±»ï¼Œå…·ä½“æ¶‰åŠçš„æ¥å£å’Œå®ç°ç±»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œå…³äºScheduledç±»å‹çš„çº¿ç¨‹æ± ç»§æ‰¿ä½“ç³»æœ¬ç¯‡æ–‡ç« æ²¡æœ‰ä»‹ç»åˆ°ï¼Œå®ƒæ˜¯åŸºäºæœ¬ç¯‡æ–‡ç« ç€é‡ä»‹ç»çš„ ThreadPoolExecutor çš„æ‰©å±•å®ç°ï¼Œæ”¯æŒæ—¶é—´çº¬åº¦æ‰§è¡Œä»»åŠ¡ã€‚ æ€»ä½“è®¾è®¡çº¿ç¨‹æ± çš„è®¾è®¡æ²¡æœ‰åŠæ³•ç›´æ¥é‡‡ç”¨ä¸€èˆ¬æ„ä¹‰ä¸Šæ± åŒ–èµ„æºæ–¹æ¡ˆï¼Œè€Œæ˜¯é‡‡ç”¨ç”Ÿäº§è€… - æ¶ˆè´¹è€…æ¨¡å¼ï¼Œå°†ä»»åŠ¡å’Œçº¿ç¨‹è§£è€¦å¹¶ä¸ç›´æ¥å…³è”ï¼Œä»è€Œè‰¯å¥½çš„ç¼“å†²ä»»åŠ¡ã€å¤ç”¨çº¿ç¨‹ï¼Œç¼“å†²ä»»åŠ¡é€šè¿‡é˜»å¡é˜Ÿåˆ—å®ç°ï¼Œå·¥ä½œçº¿ç¨‹ä»é˜»å¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡ä»¥å®ç°çº¿ç¨‹å¤ç”¨ã€‚çº¿ç¨‹æ± çš„ä½¿ç”¨æ–¹æ˜¯ç”Ÿäº§è€…ï¼Œçº¿ç¨‹æ± æœ¬èº«æ˜¯æ¶ˆè´¹è€…ã€‚è‡³äºä¸ºä»€ä¹ˆçº¿ç¨‹æ± æ²¡æœ‰é‡‡ç”¨ä¸€èˆ¬æ„ä¹‰ä¸Šæ± åŒ–èµ„æºçš„è®¾è®¡æ–¹æ³•ï¼Œè¿™ä¸ªå–å†³äºçº¿ç¨‹å¯¹è±¡çš„ç‰¹æ®Šæ€§ï¼Œçº¿ç¨‹æœ‰ç€ç‰¹æ®Šçš„ç”Ÿå‘½å‘¨æœŸï¼Œä¸€æ—¦ä¸€ä¸ªçº¿ç¨‹å¯åŠ¨æ‰§è¡Œä»»åŠ¡å°±ä¸èƒ½å†æ¬¡å¯åŠ¨äº†ã€‚ ä»»åŠ¡æ‰§è¡Œä»»åŠ¡çš„æ‰§è¡Œä¸ä¸€å®šéè¦é€šè¿‡å¼€å¯æ–°çº¿ç¨‹ï¼Œä»»åŠ¡åœ¨çº¿ç¨‹æ‰§è¡Œä¹‹å‰å®ƒä¹Ÿæ˜¯ä¸€ä¸ªå®ç°ç±»ï¼Œä¹Ÿæœ‰å¯¹åº”çš„æ–¹æ³•ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥å®šä¹‰å‡ºæ–¹æ³•çº§åˆ«è°ƒç”¨å’Œçº¿ç¨‹çº§åˆ«è°ƒç”¨ã€‚ çº¿ç¨‹çº§åˆ«è°ƒç”¨123new Thread(() -&gt; &#123; //... &#125;).start(); æ–¹æ³•çº§åˆ«è°ƒç”¨123((Runnable) () -&gt; &#123; //.. &#125;).run(); çº¿ç¨‹æ± å¯¹ä»»åŠ¡çš„å¤„ç†æœ€ç»ˆæ˜¯é€šè¿‡æ–¹æ³•çº§åˆ«è°ƒç”¨çš„æ¥å®Œæˆï¼Œåœ¨åé¢åˆ†ææºç çš„æ—¶å€™æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ã€‚ Executor æ¡†æ¶Executor æ˜¯ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡çš„æ¡†æ¶ï¼Œæ ¹æ®ä¸€ç»„æ‰§è¡Œç­–ç•¥è¿›è¡Œè°ƒç”¨ã€è°ƒåº¦ã€æ‰§è¡Œå’Œæ§åˆ¶ï¼Œç›®çš„æ˜¯æä¾›ä¸€ç§å°†ä»»åŠ¡æäº¤å’Œä»»åŠ¡æ‰§è¡Œåˆ†ç¦»çš„æœºåˆ¶ã€‚ ä¸¤çº§è°ƒåº¦æ¨¡å‹æœ€æ—© Java çš„çº¿ç¨‹æ—¢æ˜¯ä»»åŠ¡ä½“ä¹Ÿæ˜¯æ‰§è¡Œæœºåˆ¶ï¼Œä» JDK5 å¼€å§‹ï¼ŒæŠŠä»»åŠ¡ä½“å’Œæ‰§è¡Œæœºåˆ¶è¿›è¡Œäº†åˆ†ç¦»ã€‚ä»»åŠ¡ä½“åŒ…æ‹¬ Runnable å’Œ Callableï¼Œè€Œæ‰§è¡Œæœºåˆ¶ç”± Executor æ¡†æ¶æä¾›ï¼Œå³ Executoræ˜¯ Runnable å’Œ Callable çš„è°ƒåº¦å®¹å™¨ã€‚ Java çº¿ç¨‹ä¼šè¢«ä¸€å¯¹ä¸€æ˜ å°„ä¸ºæ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼Œåœ¨ Java çº¿ç¨‹å¯åŠ¨æ—¶åˆ›å»ºå¯¹åº”çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼ŒåŒæ ·åœ°ï¼Œå½“è¯¥ Java çº¿ç¨‹ç»ˆæ­¢æ—¶å¯¹åº”çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹ä¹Ÿä¼šè¢«å›æ”¶ã€‚æ“ä½œç³»ç»Ÿä¼šè°ƒåº¦æ‰€æœ‰çº¿ç¨‹å¹¶å°†å®ƒä»¬åˆ†é…ç»™å¯ç”¨çš„ CPU ã€‚å¯¹äºè®¡ç®—å¤æ‚çš„åº”ç”¨ï¼Œæˆ‘ä»¬é€šå¸¸ä¼šå°†å…¶æ‹†è§£ä¸ºè‹¥å¹²ä¸ªä»»åŠ¡å¹¶äº¤ç»™ Java å¤šä¸ªçº¿ç¨‹ï¼Œè¿™ä¸ªåŠ¨ä½œæ˜¯ç”±ç”¨æˆ·çº§åˆ«çš„è°ƒåº¦å™¨ Executor æ¡†æ¶å®Œæˆçš„ï¼Œå®ƒä¼šå°†è¿™è‹¥å¹²ä¸ªä»»åŠ¡æ˜ å°„ä¸ºå¯¹åº”æ•°é‡çš„çº¿ç¨‹ã€‚åœ¨åº•å±‚ï¼Œæ“ä½œç³»ç»Ÿå†…æ ¸å°†è¿™äº›çº¿ç¨‹æ˜ å°„åˆ°ç¡¬ä»¶å¤„ç†å™¨ä¸Šã€‚ç”±æ­¤å¯è§ï¼Œåˆ›å»ºä¸€ä¸ªçº¿ç¨‹è¿œæ¯”åˆ›å»ºä¸€ä¸ªå¯¹è±¡è¦å¤æ‚å¾—å¤šï¼Œä¸ä»…è¦åœ¨ JVM å †ä¸­åˆ†é…å†…å­˜ï¼Œè¿˜éœ€è¦è°ƒç”¨æ“ä½œç³»ç»Ÿå†…æ ¸ API æ¥ä¸ºçº¿ç¨‹åˆ†é…èµ„æºï¼Œå› æ­¤åº”è¯¥é¿å…é¢‘ç¹åˆ›å»ºå’Œé”€æ¯ã€‚ è¿™ä¸ªè¿‡ç¨‹å±äºä¸¤çº§è°ƒåº¦æ¨¡å‹ï¼Œå¯¹åº”çš„ç¤ºæ„å›¾å¦‚ä¸‹ï¼š ä»ç¤ºæ„å›¾å¯çœ‹å‡ºï¼Œåº”ç”¨ç¨‹åºé€šè¿‡ Executor æ¡†æ¶æ§åˆ¶ä¸Šå±‚çš„è°ƒåº¦ã€‚è€Œä¸‹å±‚çš„è°ƒåº¦ç”±æ“ä½œç³»ç»Ÿå†…æ ¸æ§åˆ¶ï¼Œåº”ç”¨ç¨‹åºæ˜¯æ— æ³•æ§åˆ¶çš„ã€‚ Executor æ¡†æ¶ç»“æ„Executor æ¡†æ¶ä¸»è¦ç”±ä¸‰å¤§éƒ¨åˆ†ç»„æˆï¼Œå…·ä½“å¦‚ä¸‹ï¼š ä»»åŠ¡ä½“åŒ…æ‹¬ Runnable æ¥å£å’Œ Callable æ¥å£åŠå…¶å®ç°ã€‚ ä»»åŠ¡çš„æ‰§è¡ŒåŒ…æ‹¬ä»»åŠ¡æ‰§è¡Œæœºåˆ¶çš„æ ¸å¿ƒæ¥å£ Executorï¼Œç»§æ‰¿ Executor çš„ ExecutorService æ¥å£å’Œå®ƒçš„å®ç°ä»¬ã€‚ å¼‚æ­¥è®¡ç®—ç»“æœåŒ…æ‹¬æ ¸å¿ƒæ¥å£ Future ä»¥åŠå¯¹åº”çš„å®ç°ä»¬ï¼Œç‰¹åˆ«æ˜¯ FutureTask å®ç°ç±»ã€‚æ˜¯å¯¹å…·ä½“ Runnable æˆ–è€… Callable ä»»åŠ¡çš„æ‰§è¡Œç»“æœè¿›è¡Œå–æ¶ˆã€æŸ¥è¯¢æ˜¯å¦å®Œæˆã€è·å–ç»“æœã€è®¾ç½®ç»“æœæ“ä½œã€‚ Executor æ¡†æ¶æˆå‘˜Executor æ¡†æ¶æ˜¯çº¿ç¨‹æ± å®ç°çš„åŸºç¡€ï¼Œå®ƒçš„ä¸»è¦æˆå‘˜æœ‰ ThreadPoolExecutorã€ScheduledThreadPoolExecutorã€Executorsã€Runnableã€Callable ä»¥åŠ Future ã€‚ ä¸‹é¢æ­£å¼è¿›å…¥åˆ°ä»£ç å±‚é¢çš„ä»‹ç»ï¼Œå®šæ—¶ä»»åŠ¡å®ç°ç±» ScheduledThreadPoolExecutor ç»§æ‰¿è‡ª ThreadPoolExecutor ï¼Œç”¨äºå®ç°å®šæ—¶æ‰§è¡Œï¼Œæœ¬æ–‡æš‚ä¸ä»‹ç»å®ƒçš„å®ç°ã€‚ Executor æ¥å£1234567public interface Executor &#123; /** * @param Runable æ¥å£ */ void execute(Runnable command);&#125; Executor æ¥å£ä»…å®šä¹‰äº†ä¸€ä¸ªæ–¹æ³•ï¼Œå‚æ•°æ˜¯ Runnable ç±»å‹ï¼Œè¯¥æ–¹æ³•çš„ç›®çš„æ˜¯å°†ä»»åŠ¡æäº¤å’Œä»»åŠ¡æ‰§è¡Œç»†èŠ‚è§£è€¦ã€‚ç”¨æˆ·æ— éœ€å…³æ³¨å¦‚ä½•åˆ›å»ºçº¿ç¨‹ï¼Œå¦‚ä½•è°ƒåº¦çº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ï¼Œç”¨æˆ·åªéœ€å°†ä»»åŠ¡æäº¤åˆ°æ‰§è¡Œå™¨ Executor ä¸­ï¼Œç”±æ‰§è¡Œå™¨å®Œæˆçº¿ç¨‹çš„è°ƒé…å’Œä»»åŠ¡çš„æ‰§è¡Œã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¯¥æ¥å£æ˜¯æ²¡æœ‰è¿”å›å€¼çš„ï¼Œä¹Ÿå°±æ„å‘³ç€æ— æ³•åˆ¤æ–­æäº¤çš„ä»»åŠ¡æ˜¯å¦è¢«çº¿ç¨‹æ± æ‰§è¡ŒæˆåŠŸã€‚ ExecutorService æ¥å£ExecutorService æ¥å£ç»§æ‰¿è‡ª Executor æ¥å£ï¼Œä¸€èˆ¬æˆ‘ä»¬è‡ªå®šä¹‰çº¿ç¨‹æ± æ—¶ä½¿ç”¨çš„å°±æ˜¯è¿™ä¸ªæ¥å£ï¼Œè¯¥æ¥å£ä¸­å®šä¹‰çš„æ–¹æ³•åŠ ä¸Šç»§æ‰¿è¿‡æ¥çš„ execute æ–¹æ³•åœ¨å¾ˆå¤šåœºæ™¯ä¸­å·²ç»å¯ä»¥æ»¡è¶³éœ€æ±‚äº†ã€‚ è¯¥æ¥å£ä¸­çš„æ–¹æ³•å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸Šå›¾ä¸­çš„æ–¹æ³•å¤§è‡´åˆ†ç±»å¦‚ä¸‹ï¼š å‘çº¿ç¨‹æ± æäº¤ä»»åŠ¡æ–¹æ³• submit æ–¹æ³•å’Œå‰æ–‡ä¸­çš„ Executor æ¥å£ä¸­çš„ execute æ–¹æ³•æœ‰æ‰€ä¸åŒï¼Œè™½ç„¶ä¹Ÿæ˜¯å‘çº¿ç¨‹æ± æäº¤ä»»åŠ¡ï¼Œä½†æ˜¯æœ‰è¿”å›å€¼ Future ï¼Œå¹¶ä¸”å‚æ•°ç±»å‹ä¸ä»…æ”¯æŒ Runnable ç±»å‹è¿˜æ”¯æŒ Callable ç±»å‹ã€‚ æ‰§è¡Œä»»åŠ¡æ–¹æ³• invokeAll æ–¹æ³•ç”¨äºæ‰§è¡Œå¤šä¸ªä»»åŠ¡ï¼ŒåŒæ—¶æ”¯æŒè®¾ç½®è¶…æ—¶æ—¶é—´ã€‚invokeAny æ–¹æ³•ç”¨äºæ‰§è¡Œå¤šä¸ªæ–¹æ³•ä¸­çš„ä¸€ä¸ªå³å¯ï¼Œä»»åŠ¡æ‰§è¡Œå®Œæˆå°±å¯ä»¥è¿”å›ï¼ŒåŒæ ·æ”¯æŒè®¾ç½®è¶…æ—¶æ—¶é—´ã€‚è¿™ä¸¤ç±»æ–¹æ³•çš„åº•å±‚éœ€è¦ä¾èµ– execute æ–¹æ³•ã€‚ å…³é—­çº¿ç¨‹æ± æ–¹æ³• shutdown å’Œ shutdownNow æ–¹æ³•ç”¨äºå…³é—­çº¿ç¨‹æ± ã€‚ åˆ¤æ–­çº¿ç¨‹æ± æ˜¯å¦å…³é—­ isShutdown åˆ¤æ–­çº¿ç¨‹æ± æ˜¯å¦å·²ç»å¼€å§‹äº†å…³é—­å·¥ä½œï¼Œå³æ˜¯å¦æ‰§è¡Œäº† shutdown æˆ–è€… shutdownNow æ–¹æ³•ã€‚æ³¨æ„ï¼Œè¯¥æ–¹æ³•è¿”å› true å¹¶ä¸ä»£è¡¨çº¿ç¨‹æ± æ­¤æ—¶å·²ç»å½»åº•å…³é—­äº†ï¼Œä»…è¯´æ˜çº¿ç¨‹æ± å¼€å§‹äº†å…³é—­çš„æµç¨‹ï¼Œæ­¤æ—¶çº¿ç¨‹æ± ä¸­å¯èƒ½ä¾ç„¶æœ‰çº¿ç¨‹åœ¨æ‰§è¡Œä»»åŠ¡ï¼Œé˜Ÿåˆ—ä¸­ä»æœ‰ç­‰å¾…è¢«æ‰§è¡Œçš„ä»»åŠ¡ã€‚ åˆ¤æ–­çº¿ç¨‹æ± æ˜¯å¦ç»ˆæ­¢æ–¹æ³• isTerminated å’Œ awaitTermination æ–¹æ³•ç”¨äºåˆ¤æ–­çº¿ç¨‹æ± æ˜¯å¦ç»ˆæ­¢ã€‚åªæœ‰åœ¨è°ƒç”¨å…³é—­æ–¹æ³•åæ‰æœ‰è°ƒç”¨çš„æ„ä¹‰ã€‚ FutureFuture çš„ç»§æ‰¿ä½“ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ç”±ä¸Šå›¾çš„UMLå¯çŸ¥ï¼ŒFutureTask é€šè¿‡ RunnableFuture é—´æ¥å®ç°äº† Runnable æ¥å£ï¼Œå› æ­¤ Executor.execute æ–¹æ³•æ”¯æŒå°† FutureTask æäº¤åˆ°çº¿ç¨‹æ± ã€‚æ¥ä¸‹æ¥ä»‹ç» AbstractExecutorService æŠ½è±¡å®ç°ç±»å°±èƒ½å¾ˆæ¸…æ™°çœ‹å‡º FutureTask çš„ä½œç”¨ã€‚ AbstractExecutorService å®ç°AbstractExecutorService æŠ½è±¡ç±»å®ç°è‡ª ExecutorService æ¥å£ï¼Œåœ¨å…¶åŸºç¡€ä¸Šå®ç°äº†å‡ ä¸ªå¸¸ç”¨çš„æ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•ä¾›å­ç±»è¿›è¡Œè°ƒç”¨ã€‚å°†æ‰§è¡Œä»»åŠ¡çš„æµç¨‹ä¸²è”èµ·æ¥ï¼Œä¿è¯ä¸‹å±‚çš„å®ç°ï¼ˆå¦‚ ThreadPoolExecutorï¼‰åªéœ€å…³æ³¨æ‰§è¡Œä»»åŠ¡çš„æ–¹æ³•å³å¯ã€‚å…·ä½“æ–¹æ³•å¦‚ä¸‹ï¼š ç”±äº invokeAll æ–¹æ³•å’Œ invokeAny æ–¹æ³•æ›´å¤šçš„æ˜¯æ‰§è¡Œå°†ä»»åŠ¡æäº¤ç»™çº¿ç¨‹æ± å‰çš„å·¥ä½œï¼Œå®ƒä»¬å¹¶æ²¡æœ‰å°†ä»»åŠ¡æäº¤ç»™çº¿ç¨‹æ± ï¼Œéœ€è¦é€šè¿‡ Executor ä¸­çš„ execute æ–¹æ³•å®ç°ï¼Œè€Œ execute æ–¹æ³•æœ€ç»ˆè¦äº¤ç»™å…·ä½“å­ç±»å®ç°ã€‚å› æ­¤ï¼Œä¸å†å¯¹è¿™ä¸¤ç±»æ–¹æ³•å±•å¼€è¯´æ˜ã€‚ä¸‹é¢é‡ç‚¹ä»‹ç»ä¸‹ newTaskFor æ–¹æ³•å’Œ submit æ–¹æ³•ã€‚ newTaskFor æ–¹æ³•123456789101112131415161718192021--- AbstractExecutorService /** * å°† Runnable åŒ…è£…æˆ FutureTask * * @param runnable ä»»åŠ¡ * @param value ä»»åŠ¡æ‰§è¡ŒæˆåŠŸçš„è¿”å›å€¼ * @return Future */ protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value); &#125; /** * å°† Callable åŒ…è£…æˆ FutureTask * * @param callable ä»»åŠ¡ * @return Future */ protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable); &#125; ä»ä¸Šé¢ä»£ç å¯ä»¥çœ‹å‡ºï¼ŒnewTaskFor æ–¹æ³•ç”¨äºå°† Runnable å’Œ Callable ç±»å‹çš„ä»»åŠ¡ç»Ÿä¸€åŒ…è£…æˆ FutureTask ï¼ŒFutureTask åˆé—´æ¥ç»§æ‰¿äº† Runnable æ¥å£ã€‚æˆ‘ä»¬çŸ¥é“ï¼ŒRunnable çš„ void run() æ–¹æ³•æ˜¯æ²¡æœ‰è¿”å›å€¼çš„ï¼Œ è€Œ Callable çš„ V call() æ–¹æ³•æ˜¯æœ‰è¿”å›å€¼çš„ï¼Œä½† Executor ä¸­çš„ void execute(Runnable command)æ–¹æ³•æ˜¯ä¸å…³å¿ƒè¿”å›ç»“æœçš„ï¼Œå®ƒåªè´Ÿè´£å¤„ç† Runnable ç±»å‹çš„ä»»åŠ¡ã€‚ç»¼ä¸Šï¼Œä¸éš¾çœ‹å‡º newTaskFor æ–¹æ³•å°±æ˜¯ä¸ºäº†å±è”½ä¸åŒç±»å‹ä»»åŠ¡çš„å·®å¼‚ï¼Œä»¥è¾¾åˆ°ç»Ÿä¸€äº¤ç»™ Executor.execute æ‰§è¡Œçš„ç›®çš„ã€‚ä¸‹é¢æˆ‘ä»¬ç»§ç»­çœ‹æäº¤ä»»åŠ¡çš„å¦å¤–ä¸€ç§æ–¹å¼ã€‚ submit æäº¤ä»»åŠ¡123456789101112131415161718192021222324252627282930313233--- AbstractExecutorService /** * æäº¤ Runnable ä»»åŠ¡ï¼Œä¸éœ€è¦è¿”å›ç»“æœã€‚ */ public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask; &#125; /** * æäº¤ Runnable ä»»åŠ¡ï¼Œä»»åŠ¡æ‰§è¡ŒæˆåŠŸçš„è¿”å›ç»“æœä¸º result */ public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result); execute(ftask); return ftask; &#125; /** * æäº¤ Callable ä»»åŠ¡ï¼Œä»»åŠ¡æ‰§è¡ŒæˆåŠŸè¿”å›ç»“æœæ˜¯Callable#call æ–¹æ³•è¿”å›å€¼ * * @throws RejectedExecutionException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; */ public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask; &#125; Runnable çš„ void run() æ–¹æ³•æ²¡æœ‰è¿”å›å€¼ï¼Œä½†æ˜¯æœ‰çš„æ—¶å€™æˆ‘ä»¬éœ€è¦è¿”å›å€¼ï¼Œè¿™ä¸ªæ—¶å€™ submit æ–¹æ³•å°±å¯ä»¥å®ç°ï¼Œåªéœ€åœ¨è¯¥æ–¹æ³•çš„ç¬¬äºŒä¸ªå‚æ•°ä¼ å…¥é¢„æœŸç»“æœï¼Œå½“ä»»åŠ¡æ‰§è¡Œå®Œæˆåä¼šè‡ªåŠ¨è¿”å›ã€‚ 1&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) æ­¤å¤–ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡º submit æ–¹æ³•æäº¤ä»»åŠ¡çš„èƒ½åŠ›æ˜¯é€šè¿‡ execute æ–¹æ³•å®ç°çš„ã€‚å®šä¹‰äºæœ€ä¸Šå±‚æ¥å£ Executor ä¸­çš„ void execute(Runnable command) æ–¹æ³•ä¸ä¼šè¿”å›æ‰§è¡Œç»“æœï¼Œæƒ³è¦æ‰§è¡Œç»“æœå°±éœ€è¦é€šè¿‡ FutureTask åŒ…è£…ä»»åŠ¡ï¼Œç„¶åå°†åŒ…è£…åçš„ä»»åŠ¡ FutureTask äº¤ç»™ Executor.execute æ–¹æ³•æ‰§è¡Œï¼Œæ‰§è¡Œåçš„ç»“æœä¹Ÿä¼šä¿å­˜åˆ° FutureTask ä¸­ã€‚å…³äº Future çš„ç»§æ‰¿ä½“ç³»ä¸å±•å¼€åˆ†æï¼Œä¸‹é¢æ¦‚è¿°ä¸‹ submit æäº¤ä»»åŠ¡çš„åŸç†ã€‚ è°ƒç”¨ newTaskFor æ–¹æ³•å°† Runnable å’Œ Callable ç±»å‹çš„ä»»åŠ¡ç»Ÿä¸€åŒ…è£…æˆ FutureTask å¯¹è±¡ã€‚12345678910111213141516171819202122232425262728293031// Callable public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; &#125;// Runnable public FutureTask(Runnable runnable, V result) &#123; // å°† Runnable é€‚é…æˆ Callable this.callable = Executors.callable(runnable, result); this.state = NEW; &#125; public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result); &#125; static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; this.result = result; &#125; // ä»»åŠ¡æ‰§è¡Œè¿˜æ˜¯è°ƒç”¨ run æ–¹æ³•ï¼Œè¿”å›ç»“æœæ˜¯ä¼ å…¥çš„é¢„æœŸå€¼ public T call() &#123; task.run(); return result; &#125; &#125; åŒ…è£…çš„æœ¬è´¨æ˜¯å°†ä»»åŠ¡ç»Ÿä¸€é€‚é…ä¸ºCallableç±»å‹ï¼Œå› ä¸ºCallableç±»å‹ä»»åŠ¡å¯ä»¥é€šè¿‡callæ–¹æ³•è¿”å›æ‰§è¡Œç»“æœã€‚ å½“ä»»åŠ¡æ‰§è¡Œçš„æ—¶å€™ï¼ŒFutureTask ä¸­çš„ run æ–¹æ³•ä¼šæ‰§è¡Œï¼Œè¿™ä¸ªè¿‡ç¨‹æ˜¯æœ€å…³é”®çš„ä¸€æ­¥ã€‚12345678910111213141516171819202122232425262728293031323334public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; // è¢«é€‚é…çš„Runnable å’Œ Callable æ–¹æ³•çº§åˆ«è°ƒç”¨ result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) // å°†æ‰§è¡Œç»“æœä¿å­˜åˆ° FutureTask ä¸­ set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125; é€šè¿‡FutureTask#getæ–¹æ³•ä» FutureTask ä¸­å–å‡ºä»»åŠ¡æ‰§è¡Œç»“æœ12345678910111213141516171819202122232425/** * @throws CancellationException &#123;@inheritDoc&#125; */ public V get() throws InterruptedException, ExecutionException &#123; int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); // ä» FutureTask ä¸­å–å‡ºä»»åŠ¡æ‰§è¡Œç»“æœ return report(s); &#125; /** * @throws CancellationException &#123;@inheritDoc&#125; */ public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123; if (unit == null) throw new NullPointerException(); int s = state; if (s &lt;= COMPLETING &amp;&amp; (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING) throw new TimeoutException(); // ä» FutureTask ä¸­å–å‡ºä»»åŠ¡æ‰§è¡Œç»“æœ return report(s); &#125; æäº¤ä»»åŠ¡æ–¹å¼æœ€ä¸Šå±‚æ¥å£ Executor ä¸­çš„ void execute(Runnable) ä¸éœ€è¦è·å–ç»“æœï¼Œä¸ä¼šä½¿ç”¨ FutureTask åŒ…è£…ä»»åŠ¡ã€‚æŠ½è±¡å®ç°ç±» AbstractExecutorService ä¸­çš„ Future&lt;?&gt; submit() éœ€è¦è·å–ç»“æœï¼Œå› æ­¤ä½¿ç”¨äº† FutureTask åŒ…è£…ä»»åŠ¡ã€‚ éœ€è¦è·å–ä»»åŠ¡ç»“æœç”¨ submit æ–¹æ³•ï¼Œä¸éœ€è¦è·å–ç»“æœç”¨ execute æ–¹æ³•ã€‚ è¿è¡Œæœºåˆ¶ ä¸Šå›¾å±•ç¤ºäº†çº¿ç¨‹æ± çš„è¿è¡Œæœºåˆ¶ï¼Œçº¿ç¨‹æ± è¿è¡Œæœºåˆ¶ä¸»è¦åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†ï¼Œçº¿ç¨‹ç®¡ç†å’Œä»»åŠ¡ç®¡ç†ã€‚ä¸‹é¢å¯¹çº¿ç¨‹æ± çš„ä¸»è¦å¤„ç†æµç¨‹è¿›è¡Œè¯´æ˜ï¼š ä¸»çº¿ç¨‹æäº¤ä»»åŠ¡åˆ°çº¿ç¨‹æ± ã€‚ å¦‚æœå½“å‰çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹å°‘äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œåˆ™åˆ›å»ºæ–°çš„çº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ã€‚ å¦‚æœçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹è¾¾åˆ°æˆ–è¶…è¿‡æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œåˆ™å°†ä»»åŠ¡åŠ å…¥åˆ°é˜»å¡é˜Ÿåˆ—ä¸­ã€‚ å¦‚æœåœ¨ç¬¬ 2 æ­¥ä¸­æ— æ³•å°†ä»»åŠ¡åŠ å…¥é˜»å¡é˜Ÿåˆ—ï¼Œåˆ™ä¾æ®æœ€å¤§çº¿ç¨‹æ•°åˆ›å»ºæ–°çš„çº¿ç¨‹æ¥å¤„ç†ä»»åŠ¡ã€‚ å¦‚æœåœ¨ç¬¬ 3 æ­¥åˆ›å»ºæ–°çº¿ç¨‹ä¼šä½¿çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°è¶…å‡ºæœ€å¤§çº¿ç¨‹æ•°ï¼Œä»»åŠ¡å°†è¢«æ‹’ç»å¹¶ä½¿ç”¨é¥±å’Œç­–ç•¥å¤„ç†ï¼ˆæ‹’ç»ç­–ç•¥ï¼‰ã€‚ å¤„ç†å®Œä»»åŠ¡çš„çº¿ç¨‹ä¼šè‡ªæ—‹è·å–æ–°çš„ä»»åŠ¡å»æ‰§è¡Œï¼Œå½“çº¿ç¨‹è·å–ä¸åˆ°ä»»åŠ¡æ—¶ï¼Œçº¿ç¨‹ä¼šè¢«å›æ”¶ï¼ˆä¸€èˆ¬é’ˆå¯¹éæ ¸å¿ƒçº¿ç¨‹ï¼‰ã€‚ å…¶ä¸­ç¬¬ 1 æ­¥å’Œç¬¬ 3 æ­¥æ¶‰åŠåˆ°åˆ›å»ºçº¿ç¨‹ï¼Œè¯¥è¿‡ç¨‹éœ€è¦è·å–å…¨å±€é”ï¼Œå› ä¸ºå…³é—­çº¿ç¨‹æ± ä¹Ÿéœ€è¦è·å–è¿™ä¸ªå…¨å±€é”ã€‚å½“çº¿ç¨‹æ± å®Œæˆäº†é¢„çƒ­å³æ ¸å¿ƒçº¿ç¨‹æ•°åˆ›å»ºå®Œæ¯•ï¼Œåœ¨ä¸€å®šç¨‹åº¦ä¸Šå°±ä¸éœ€è¦é¢‘ç¹åˆ›å»ºçº¿ç¨‹ï¼Œä¹Ÿå°±é™ä½äº†è·å–å…¨å±€é”çš„é¢‘æ¬¡ï¼Œå¯¹äºçº¿ç¨‹æ± æ¥è¯´å…¨å±€é”æ˜¯ä¸€ä¸ªä¸¥é‡çš„å¯ä¼¸ç¼©ç“¶é¢ˆã€‚å…³äºæµç¨‹ä¸­çš„æ¦‚å¿µä¸‹æ–‡ä¼šé™†ç»­è¯´æ˜ã€‚ ThreadPoolExecutorçº¿ç¨‹æ± æ ¸å¿ƒå®ç°å°±åœ¨ ThreadPoolExecutor å®ç°ç±»ä¸­ï¼Œè¯¥ç±»å®ç°äº†çº¿ç¨‹æ± æ‰€éœ€çš„å„ä¸ªæ–¹æ³•ï¼ŒåŒ…æ‹¬æœ€æ ¸å¿ƒçš„ execute æ–¹æ³•ã€‚å¼€å‘è€…å¯ä»¥åŸºäºè¯¥å®ç°ç±»æ¥è¿›è¡ŒåŠŸèƒ½ä¸Šçš„æ‰©å±•ï¼Œå®šæ—¶ä»»åŠ¡å®ç°ç±» ScheduledThreadPoolExecutor å°±æ˜¯åŸºäº ThreadPoolExecutor æ‰©å±•çš„åŠŸèƒ½ã€‚ åœ¨è¯¦ç»†ä»‹ç» ThreadPoolExecutor è¿è¡Œæœºåˆ¶ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆå¯¹å…¶æ ¸å¿ƒæ¦‚å¿µï¼Œå±æ€§ã€æ–¹æ³•ç­‰è¿›è¡Œç®€å•ä»‹ç»ã€‚ æ ¸å¿ƒå‚æ•°12345678 public ThreadPoolExecutor(int corePoolSize, // æ ¸å¿ƒçº¿ç¨‹æ•° int maximumPoolSize, // æœ€å¤§çº¿ç¨‹æ•° long keepAliveTime, // ç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´ TimeUnit unit, // ç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´çš„å•ä½ BlockingQueue&lt;Runnable&gt; workQueue, // é˜»å¡é˜Ÿåˆ— ThreadFactory threadFactory, // çº¿ç¨‹å·¥å‚ RejectedExecutionHandler handler // é¥±å’Œç­–ç•¥) &#123;//...&#125; corePoolSize æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œçº¿ç¨‹æ± çš„åŸºæœ¬å¤§å°ã€‚å½“æäº¤ä¸€ä¸ªä»»åŠ¡åˆ°çº¿ç¨‹æ± æ—¶ï¼Œçº¿ç¨‹æ± ä¼šåˆ›å»ºä¸€ä¸ªåŸºæœ¬çº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ï¼Œå³ä½¿å…¶å®ƒç©ºé—²çš„åŸºæœ¬çº¿ç¨‹èƒ½å¤Ÿæ‰§è¡Œæ–°ä»»åŠ¡ä¹Ÿä¼šåˆ›å»ºçº¿ç¨‹ï¼Œåªæœ‰çº¿ç¨‹æ± é¢„çƒ­å®Œæ¯•ï¼ˆçº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°è¾¾åˆ°æ ¸å¿ƒçº¿ç¨‹æ•°ï¼‰æ‰ä¸å†åˆ›å»ºæ ¸å¿ƒçº¿ç¨‹ã€‚ ç‰¹åˆ«è¯´æ˜ï¼š æ ¸å¿ƒçº¿ç¨‹å¹¶ä¸æ˜¯ç‰¹æŒ‡æŸä¸€ä¸ªæˆ–æŸå‡ ä¸ªçº¿ç¨‹ï¼Œè€Œæ˜¯é’ˆå¯¹è®¾ç½®çš„æ ¸å¿ƒçº¿ç¨‹æ•°è€Œè¨€ï¼Œä»»ä½•ä¸€ä¸ªçº¿ç¨‹éƒ½å¯ä»¥æ˜¯æ ¸å¿ƒçº¿ç¨‹ã€‚ corePoolSize è¡¨ç¤ºçš„æ˜¯çº¿ç¨‹æ± çš„å¸¸é©»çº¿ç¨‹æ•°ï¼Œå¦‚æœè®¾ç½®ä¸º 0 åˆ™è¡¨ç¤ºåœ¨æ²¡æœ‰ä»»ä½•ä»»åŠ¡æ—¶éœ€è¦é”€æ¯çº¿ç¨‹æ± ã€‚å¦‚æœå¤§äº 0 ï¼Œå³ä½¿æ²¡æœ‰ä»»åŠ¡æ—¶ä¹Ÿä¼šä¿è¯çº¿ç¨‹æ± çš„çº¿ç¨‹æ•°ç­‰äºæ­¤å€¼ã€‚ å…³äºæ­¤å€¼è®¾ç½®çš„åˆç†æ€§ï¼Œå¦‚æœè®¾ç½®çš„è¾ƒå°ï¼Œåˆ™ä¼šé¢‘ç¹çš„åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹ï¼ˆéæ ¸å¿ƒçº¿ç¨‹ï¼‰ï¼›è®¾ç½®è¿‡å¤§ï¼Œåˆ™ä¼šæµªè´¹èµ„æºã€‚ maximumPoolSize æœ€å¤§çº¿ç¨‹æ•°ï¼Œçº¿ç¨‹æ± å…è®¸åˆ›å»ºçš„æœ€å¤§çº¿ç¨‹æ•°ï¼Œæœ€å¤§çº¿ç¨‹æ•° = æ ¸å¿ƒçº¿ç¨‹æ•° + éæ ¸å¿ƒçº¿ç¨‹æ•°ã€‚æ­¤å€¼åªæœ‰åœ¨ä»»åŠ¡æ¯”è¾ƒå¤šä¸”é˜»å¡é˜Ÿåˆ—æ”¾ä¸ä¸‹æ—¶æ‰ä¼šç”¨åˆ°ã€‚ keepAliveTime ç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´ï¼Œçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹ç©ºé—²æ—¶é—´è¶…è¿‡è¯¥å€¼ä¹Ÿæ²¡ä»»åŠ¡å¯åšé‚£ä¹ˆå°±éœ€è¦å›æ”¶é”€æ¯ã€‚å¦‚æœè®¾ç½®ä¸º 0ï¼Œè¡¨ç¤ºä¸€æ—¦ç©ºé—²ç«‹å³å›æ”¶ã€‚è¯¥å‚æ•°ä¸€èˆ¬åªä¼šå¯¹éæ ¸å¿ƒçº¿ç¨‹èµ·ä½œç”¨ï¼Œæ ¸å¿ƒçº¿ç¨‹ä¸ä¼šå› ä¸ºç©ºé—²å¤ªé•¿æ—¶é—´è€Œè¢«å…³é—­ï¼Œå½“æœ€å¤§çº¿ç¨‹æ•°ç­‰äºæ ¸å¿ƒçº¿ç¨‹æ•°æ—¶ï¼Œé‚£ä¹ˆçº¿ç¨‹æ± åœ¨ç©ºé—²çš„æ—¶å€™ä¹Ÿä¸ä¼šé”€æ¯ä»»ä½•çº¿ç¨‹ã€‚ä½†æ˜¯å¯é€šè¿‡è°ƒç”¨ allowCoreThreadTimeOut(true) æ–¹æ³•ä½¿æ ¸å¿ƒçº¿ç¨‹æ•°å†…çš„çº¿ç¨‹ä¹Ÿå¯ä»¥è¢«å›æ”¶ã€‚ unit å’Œ keepAliveTime å‚æ•°ä¸€èµ·ä½¿ç”¨ï¼Œæ˜¯æ—¶é—´å•ä½ã€‚å¦‚ï¼šå¤©ï¼ˆDAYSï¼‰ã€å°æ—¶ï¼ˆHOURSï¼‰ã€åˆ†é’Ÿï¼ˆMINUTESï¼‰ã€æ¯«ç§’ï¼ˆMILLISECONDSï¼‰ç­‰ã€‚ workQueue ç”¨äºå­˜æ”¾ç­‰å¾…æ‰§è¡Œçš„ä»»åŠ¡çš„é˜»å¡é˜Ÿåˆ—ï¼Œæ˜¯ BlockingQueue æ¥å£çš„å®ç°ã€‚å½“çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°å¤§äºç­‰äºæ ¸å¿ƒçº¿ç¨‹æ•°æ—¶æ‰ä¼šç”¨åˆ°è¯¥é˜Ÿåˆ—ï¼Œæ³¨æ„å’Œæœ‰æ²¡æœ‰ç©ºé—²æ ¸å¿ƒçº¿ç¨‹æ— å…³ã€‚ threadFactory çº¿ç¨‹å·¥å‚ï¼Œçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹å°±ç”±å®ƒåˆ›å»ºã€‚å¦‚æœæ²¡æœ‰è®¾ç½®å°±ä½¿ç”¨é»˜è®¤çš„çº¿ç¨‹å·¥å‚ã€‚ handler é¥±å’Œç­–ç•¥ï¼ˆæ‹’ç»ç­–ç•¥ï¼‰ï¼Œå½“é˜»å¡é˜Ÿåˆ—å’Œçº¿ç¨‹æ± éƒ½æ»¡äº†ï¼Œè¯´æ˜çº¿ç¨‹æ± å¤„äºé¥±å’ŒçŠ¶æ€ï¼Œéœ€è¦é‡‡å–ä¸€ç§ç­–ç•¥å¤„ç†æäº¤çš„æ–°ä»»åŠ¡ï¼Œé»˜è®¤æ˜¯ç›´æ¥æŠ›å‡ºå¼‚å¸¸ã€‚ é€šè¿‡é…ç½®ä¸åŒçš„å‚æ•°ï¼Œå°±å¯ä»¥åˆ›å»ºå‡ºè¡Œä¸ºä¸åŒçš„çº¿ç¨‹æ± ï¼Œè¿™ä¹Ÿæ˜¯çº¿ç¨‹æ± é«˜åº¦çµæ´»æ€§çš„åŸºç¡€ã€‚ æ ¸å¿ƒå±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164--- ThreadPoolExecutor //======= çº¦å®šä½¿ç”¨32ä½è¡¨ç¤ºçº¿ç¨‹æ± çŠ¶æ€å’Œæ•°é‡ï¼Œé«˜3ä½è¡¨ç¤ºçŠ¶æ€ ï¼Œä½29ä½è¡¨ç¤ºæ•°é‡ =============/ /** * çº¿ç¨‹æ± åˆå§‹åŒ–çŠ¶æ€ç ï¼ŒçŠ¶æ€ä¸º RUNNINGï¼Œçº¿ç¨‹æ•°ä¸º 0 */ private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); /** * COUNT_BITS ä¸º 29 (0001 1101) */ private static final int COUNT_BITS = Integer.SIZE - 3; /** * çº¿ç¨‹æ± å…è®¸æœ€å¤§çº¿ç¨‹æ± ä¸´ç•Œå€¼ï¼Œ1 * 2^29 = 536870912 * è¿‡ç¨‹ï¼šï¼ˆ1ï¼‰001 ï¼ˆ2ï¼‰å·¦ç§»29ä½å¾—åˆ°001åè·Ÿ29ä¸ª0 -&gt; 0010 0000 0000 0000 0000 0000 0000 0000 ï¼ˆ3ï¼‰å‡å»1å¾—0001 1111 1111 1111 1111 1111 1111 1111 */ private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; /** * è¿è¡ŒçŠ¶æ€ï¼š111 00000000000000000000000000000 */ private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; /** * å…³é—­çŠ¶æ€ï¼š000 00000000000000000000000000000 */ private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; /** * åœæ­¢çŠ¶æ€ï¼š001 00000000000000000000000000000 */ private static final int STOP = 1 &lt;&lt; COUNT_BITS; /** * æ•´ç†çŠ¶æ€ï¼š010 00000000000000000000000000000 */ private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; /** * ç»ˆæ­¢çŠ¶æ€ï¼š011 00000000000000000000000000000 */ private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // è·å–çº¿ç¨‹æ± çš„çŠ¶æ€ã€‚å°†æ•´æ•° c çš„ä½ 29 ä½ç½®ä¸º 0 å°±å¾—åˆ°äº†çº¿ç¨‹æ± çš„çŠ¶æ€ private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125; // ç”¨äºè®¡ç®—çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°é‡ã€‚å°†æ•´æ•° c çš„é«˜ 3 ä½ç½®ä¸º 0ï¼Œå°±å¾—åˆ°äº†çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•° private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; // è·å–çº¿ç¨‹æ± çŠ¶æ€ç  private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; /** * æ¯”è¾ƒçŠ¶æ€ * * @param c * @param s * @return */ private static boolean runStateLessThan(int c, int s) &#123; return c &lt; s; &#125; private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s; &#125; /** * å½“å‰çº¿ç¨‹æ± æ˜¯å¦å¤„äºè¿è¡ŒçŠ¶æ€ * * @param c * @return */ private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN; &#125; /** * å¢åŠ çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡ */ private boolean compareAndIncrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect + 1); &#125; /** * å‡å°‘çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡ * Attempts to CAS-decrement the workerCount field of ctl. */ private boolean compareAndDecrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect - 1); &#125; private void decrementWorkerCount() &#123; do &#123; &#125; while (!compareAndDecrementWorkerCount(ctl.get())); &#125; /** * çº¿ç¨‹æ± é˜»å¡é˜Ÿåˆ— */ private final BlockingQueue&lt;Runnable&gt; workQueue; /** * çº¿ç¨‹æ± å…¨å±€é” */ private final ReentrantLock mainLock = new ReentrantLock(); /** * 1.ç”¨äºä¿å­˜å’Œç§»é™¤çº¿ç¨‹æ± åˆ›å»ºçš„Workerï¼Œç”¨æ¥æ§åˆ¶çº¿ç¨‹çš„ç”Ÿå‘½å‘¨æœŸã€‚ * 2.å¯¹äºåƒåœ¾å›æ”¶æ¥è¯´ï¼Œå³ä½¿Workerä¸­å°è£…çš„threadå®Œæˆäº†ä»»åŠ¡çš„æ‰§è¡Œï¼ˆåŒ…æ‹¬å¼‚å¸¸æƒ…å†µï¼‰ï¼Œä½†æ˜¯å¦‚æœWorkerä¸è¢«å›æ”¶é‚£ä¹ˆthreadä»ç„¶è¢«å¼ºå¼•ç”¨ç€ã€‚ * 3.è¯¥Hashè¡¨æ˜¯çº¿ç¨‹ä¸å®‰å…¨çš„ï¼Œæ“ä½œæ—¶éœ€è¦åŠ å…¨å±€é” */ private final HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;(); /** * å…¨å±€é”æ¡ä»¶ - æ¡ä»¶é˜Ÿåˆ— */ private final Condition termination = mainLock.newCondition(); /** * è¿½è¸ªçº¿ç¨‹æ± æœ€å¤§å€¼ï¼Œä»…åœ¨è·å–åˆ°å…¨å±€é”æ¡ä»¶ä¸‹æ‰§è¡Œ */ private int largestPoolSize; /** * çº¿ç¨‹æ± å®Œæˆä»»åŠ¡æ•°é‡ */ private long completedTaskCount; /** * çº¿ç¨‹å·¥å‚ */ private volatile ThreadFactory threadFactory; /** * é¥±å’Œç­–ç•¥ */ private volatile RejectedExecutionHandler handler; /** * ä¿æ´»æ—¶é—´ï¼Œå³æœ€å¤§å…è®¸ç©ºé—²æ—¶é—´ */ private volatile long keepAliveTime; /** * æ˜¯å¦å…è®¸æ ¸å¿ƒçº¿ç¨‹è¢«å›æ”¶ */ private volatile boolean allowCoreThreadTimeOut; /** * æ ¸å¿ƒçº¿ç¨‹æ± æ•°ï¼Œä¸ä¼šè¢«å›æ”¶ï¼Œå³ workersçš„æœ€å°å€¼ã€‚é™¤éè®¾ç½® allowCoreThreadTimeOut ã€‚ */ private volatile int corePoolSize; /** * æœ€å¤§çº¿ç¨‹æ•° */ private volatile int maximumPoolSize; /** * é»˜è®¤çš„é¥±å’Œç­–ç•¥ï¼Œç›´æ¥æŠ›å‡ºå¼‚å¸¸ */ private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); ä¸Šé¢çš„å±æ€§éƒ½å¾ˆé‡è¦ï¼Œå…¶ä¸­è¿˜åŒ…å«äº†éƒ¨åˆ†å±æ€§çš„æ“ä½œæ–¹æ³•ï¼Œè¿™äº›éƒ½ä¼šåœ¨ä¸‹é¢çš„æºç åˆ†æä¸­ä¸æ–­å‡ºç°ã€‚ æ„é€ æ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Public constructors and methods æ„é€ æ–¹æ³•ä»¬ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); &#125; public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); &#125; public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, // å½“æ²¡æœ‰æŒ‡å®šçº¿ç¨‹å·¥å‚æ—¶ï¼Œä½¿ç”¨é»˜è®¤çš„çº¿ç¨‹åˆ›å»ºå·¥å‚ Executors.defaultThreadFactory(), handler); &#125; public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; åˆ›å»ºçº¿ç¨‹æ± æ—¶å¦‚æœä¸æŒ‡å®šçº¿ç¨‹å·¥å‚åˆ™ä¼šä½¿ç”¨é»˜è®¤çš„çº¿ç¨‹å·¥å‚ï¼Œé»˜è®¤çº¿ç¨‹å·¥å‚åˆ›å»ºçš„çº¿ç¨‹éƒ½å±äºåŒä¸€ä¸ªçº¿ç¨‹ç»„ï¼Œæ‹¥æœ‰ç›¸åŒçš„ä¼˜å…ˆçº§ï¼Œå¹¶ä¸”éƒ½æ˜¯éå®ˆæŠ¤çº¿ç¨‹ï¼Œå…·ä½“ä»£ç å®ç°å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031--- Executors static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); // çº¿ç¨‹ç»„ group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; &#125; public Thread newThread(Runnable r) &#123; // åˆ›å»ºçº¿ç¨‹ Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); // è®¾ç½®ä¸ºéå®ˆæŠ¤çº¿ç¨‹ if (t.isDaemon()) t.setDaemon(false); // è®¾ç½®ä¼˜å…ˆçº§ if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125; &#125; ç”Ÿå‘½å‘¨æœŸè®¾è®¡æ€æƒ³çº¿ç¨‹æ± é‡‡ç”¨çš„æ˜¯ Integer.SIZE 32 ä½çš„æ•´æ•°æ¥å­˜æ”¾çº¿ç¨‹æ± çš„çŠ¶æ€å’Œæ± ä¸­çš„çº¿ç¨‹æ•°ï¼Œå…¶ä¸­é«˜ 3 ä½è¡¨ç¤ºçº¿ç¨‹æ± çŠ¶æ€å³å¯ä»¥è¡¨ç¤º 7 ç§çŠ¶æ€ï¼Œä½ 29 ä½è¡¨ç¤ºçº¿ç¨‹æ•°å³å¯ä»¥å­˜æ”¾ 5 äº¿å¤šä¸ªçº¿ç¨‹ã€‚è¿™ç§è®¾è®¡æ€æƒ³å¯¹æ•´æ•°èµ‹äºˆäº†åŒé‡è§’è‰²ï¼Œé€šè¿‡é«˜ä½ä½çš„ä¸åŒï¼Œæ—¢è¡¨ç¤ºçº¿ç¨‹æ± çŠ¶æ€ï¼Œåˆè¡¨ç¤ºå·¥ä½œçº¿ç¨‹æ•°ç›®ï¼Œè¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„é«˜æ•ˆä¼˜åŒ–ã€‚è¦çŸ¥é“ç”¨ä¸€ä¸ªå˜é‡å­˜å‚¨ä¸¤ä¸ªå€¼ï¼Œå¯ä»¥é¿å…åœ¨åšç›¸å…³å†³ç­–æ—¶å‡ºç°ä¸ä¸€è‡´çš„æƒ…å†µï¼Œçœå»äº†å ç”¨é”èµ„æºå»ç»´æŠ¤ä¸¤ä¸ªå˜é‡çš„ä¸€è‡´æ€§ã€‚è¿™ç§æ–¹å¼åœ¨å…¶å®ƒæ¡†æ¶ä¸­ä¹Ÿå¤šæœ‰ä½¿ç”¨ï¼Œå¦‚ Dubbo åè®®å°±ä½¿ç”¨ 16 ä¸ªå­—èŠ‚å…± 128 ä½ï¼Œæ¯ä¸€ä½ç”¨æ¥è¡¨ç¤ºä¸åŒæ„ä¹‰çš„æ•°å€¼ã€‚ çº¿ç¨‹æ± çŠ¶æ€çº¿ç¨‹æ± çš„çŠ¶æ€è¡¨ç¤ºå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ³¨æ„ï¼Œçº¿ç¨‹æ± çš„çŠ¶æ€å¹¶éç”¨æˆ·æ˜¾ç¤ºé…ç½®ï¼ˆç”¨æˆ·è°ƒç”¨å…³é—­æ–¹æ³•é™¤å¤–ï¼‰ï¼Œè€Œæ˜¯éšç€çº¿ç¨‹æ± çš„è¿è¡Œç”±å†…éƒ¨è‡ªè¡Œç»´æŠ¤ï¼Œå’Œçº¿ç¨‹çš„æ‰§è¡Œå¯†åˆ‡ç›¸å…³ï¼Œä¸‹é¢åˆ†åˆ«è¯´æ˜çº¿ç¨‹æ± çš„çŠ¶æ€åŠå…¶çŠ¶æ€æµè½¬ã€‚ RUNNING çŠ¶æ€è¯´æ˜çº¿ç¨‹æ± å¤„äº RUNNING çŠ¶æ€å…è®¸æ¥å—æ–°çš„ä»»åŠ¡ï¼Œå¤„ç†ä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ã€‚ çŠ¶æ€è½¬æ¢çº¿ç¨‹æ± ä¸€æ—¦è¢«åˆ›å»ºå°±å¤„äº RUNNING çŠ¶æ€ï¼Œå¹¶ä¸”çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°ä¸º 0 ã€‚ SHUTDOWN çŠ¶æ€è¯´æ˜çº¿ç¨‹æ± å¤„äº SHUTDOWN çŠ¶æ€æ—¶ï¼Œä¸å†æ¥æ”¶æ–°ä»»åŠ¡ï¼Œä½†èƒ½å¤„ç†ä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ã€‚ çŠ¶æ€è½¬æ¢è°ƒç”¨çº¿ç¨‹æ± çš„shutdown()æ–¹æ³•æ—¶ï¼Œçº¿ç¨‹æ± ç”±RUNNING -&gt; SHUTDOWN ã€‚ STOP çŠ¶æ€è¯´æ˜çº¿ç¨‹æ± å¤„åœ¨ STOP çŠ¶æ€æ—¶ï¼Œä¸èƒ½æ¥æ”¶æ–°ä»»åŠ¡ï¼Œä¹Ÿä¸å¤„ç†ä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼Œå¹¶ä¸”ä¼šä¸­æ–­æ­£åœ¨å¤„ç†ä»»åŠ¡çš„çº¿ç¨‹ã€‚ çŠ¶æ€è½¬æ¢è°ƒç”¨çº¿ç¨‹æ± çš„shutdownNow()æ–¹æ³•æ—¶ï¼Œçº¿ç¨‹æ± ç”±(RUNNING or SHUTDOWN ) -&gt; STOP ã€‚ TIDYING çŠ¶æ€è¯´æ˜æ‰€æœ‰çš„ä»»åŠ¡å·²ç»ˆæ­¢ï¼Œçº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°ä¸º 0 ï¼Œçº¿ç¨‹æ± ä¼šå˜ä¸ºTIDYINGçŠ¶æ€ï¼ˆçº¿ç¨‹æ± å†…éƒ¨è‡ªåŠ¨æ›´æ–°çŠ¶æ€ï¼‰ã€‚å½“çº¿ç¨‹æ± å˜ä¸ºTIDYINGçŠ¶æ€åï¼Œä¼šç´§æ¥ç€æ‰§è¡Œé’©å­æ–¹æ³•terminated()ã€‚è‹¥ç”¨æˆ·éœ€è¦åœ¨çº¿ç¨‹æ± å˜ä¸ºTIDYINGæ—¶ï¼Œè¿›è¡Œç›¸åº”çš„å¤„ç†ï¼Œå¯ä»¥é€šè¿‡é‡å†™terminated()æ–¹æ³•æ¥å®ç°ã€‚ çŠ¶æ€è½¬æ¢å½“çº¿ç¨‹æ± åœ¨ SHUTDOWN çŠ¶æ€ä¸‹æ—¶ï¼Œé˜»å¡é˜Ÿåˆ—ä¸ºç©ºå¹¶ä¸”çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°ä¸º 0 æ—¶ï¼Œå°±ä¼šç”± SHUTDOWN -&gt; TIDYINGã€‚ å½“çº¿ç¨‹æ± åœ¨ STOP çŠ¶æ€ä¸‹ï¼Œçº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°ä¸º 0 æ—¶ï¼Œå°±ä¼šç”±STOP -&gt; TIDYINGã€‚ TERMINATED çŠ¶æ€è¯´æ˜çº¿ç¨‹æ± å½»åº•ç»ˆæ­¢ï¼Œå°±å˜æˆ TERMINATED çŠ¶æ€ã€‚ çŠ¶æ€è½¬æ¢çº¿ç¨‹æ± å¤„åœ¨TIDYINGçŠ¶æ€æ—¶ï¼Œæ‰§è¡Œå®Œ terminated() æ–¹æ³•ä¹‹åï¼Œå°±ä¼šç”± TIDYING -&gt; TERMINATEDã€‚ ä¸‹é¢è¿›è¡Œå°ç»“ï¼Œçº¿ç¨‹æ± çŠ¶æ€åŠæµè½¬ï¼ˆçº¿ç¨‹æ± çš„ç”Ÿå‘½å‘¨æœŸï¼‰å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä»»åŠ¡æ‰§è¡Œæœºåˆ¶ä»»åŠ¡è°ƒåº¦ä»»åŠ¡è°ƒåº¦æ˜¯çº¿ç¨‹æ± çš„ä¸»è¦å…¥å£ï¼Œæ‰€æœ‰ä»»åŠ¡çš„è°ƒåº¦éƒ½æ˜¯ç”±executeæ–¹æ³•å®Œæˆçš„ï¼Œå½“ç”¨æˆ·æäº¤äº†ä¸€ä¸ªä»»åŠ¡åï¼Œä»»åŠ¡è°ƒåº¦é˜¶æ®µå°†å†³å®šå¦‚ä½•æ‰§è¡Œè¯¥ä»»åŠ¡ã€‚ 12345678910111213141516171819202122232425262728293031323334public void execute(Runnable command) &#123; // ä»»åŠ¡ä½“ä¸å…è®¸ä¸º null if (command == null) throw new NullPointerException(); // è·å–çº¿ç¨‹æ± çš„çŠ¶æ€ç ,è¯¥å€¼åŒ…å«äº†çº¿ç¨‹æ± çš„çŠ¶æ€å’Œçº¿ç¨‹æ•° int c = ctl.get(); // 1 å¦‚æœå½“å‰çº¿ç¨‹æ•°å°‘äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œåˆ™åˆ›å»ºä¸€ä¸ª Worker æ¥æ‰§è¡Œä»»åŠ¡ï¼Œå³åˆ›å»ºä¸€ä¸ªçº¿ç¨‹å¹¶å°† command ä½œä¸ºè¯¥çº¿ç¨‹çš„ç¬¬ä¸€ä¸ªä»»åŠ¡ if (workerCountOf(c) &lt; corePoolSize) &#123; // è¿”å› false è¯´æ˜çº¿ç¨‹æ± ä¸å…è®¸åˆ›å»ºçº¿ç¨‹ï¼Œå¯èƒ½åŸå› ï¼šï¼ˆ1ï¼‰çº¿ç¨‹æ± å…³é—­ï¼ˆ2ï¼‰å½“å‰çº¿ç¨‹æ•°å·²ç»è¾¾åˆ°ä¸´ç•Œå€¼ if (addWorker(command, true)) return; // åˆ›å»ºå¤±è´¥ï¼Œé‡è¯»çº¿ç¨‹æ± çŠ¶æ€ç  c = ctl.get(); &#125; // 2 å¦‚æœçº¿ç¨‹æ± å¤„äºè¿è¡ŒçŠ¶æ€ï¼Œåˆ™å°è¯•å°†ä»»åŠ¡æ·»åŠ åˆ°é˜»å¡é˜Ÿåˆ— workQueue ä¸­ if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // å†æ¬¡è·å–çº¿ç¨‹æ± çŠ¶æ€ç  int recheck = ctl.get(); // åŒé‡æ£€æŸ¥ï¼Œå†æ¬¡åˆ¤æ–­çº¿ç¨‹æ± çŠ¶æ€ã€‚å¦‚æœçº¿ç¨‹çŠ¶æ€å˜äº†ï¼ˆéè¿è¡ŒçŠ¶æ€ï¼‰å°±éœ€è¦ä»é˜»å¡é˜Ÿåˆ—ç§»é™¤ä»»åŠ¡ï¼ŒåŒæ—¶æ‰§è¡Œæ‹’ç»ç­–ç•¥ã€‚é˜²æ­¢çº¿ç¨‹æ± å…³é—­ã€‚ if (!isRunning(recheck) &amp;&amp; remove(command)) reject(command); // å¦‚æœçº¿ç¨‹æ± çŠ¶æ€ä»ç„¶æ˜¯è¿è¡ŒçŠ¶æ€ï¼Œå¹¶ä¸”çº¿ç¨‹æ± ä¸ºç©ºåˆ™åˆ›å»ºä¸€ä¸ªéæ ¸å¿ƒçº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ï¼Œé˜²æ­¢çº¿ç¨‹æäº¤åˆ°é˜»å¡é˜Ÿåˆ—åçº¿ç¨‹éƒ½å…³é—­äº†ã€‚ // ä¸€èˆ¬è¿™ç§æƒ…å†µæ˜¯è®¾ç½®æ ¸å¿ƒçº¿ç¨‹æ•°ä¸º 0 else if (workerCountOf(recheck) == 0) addWorker(null, false); // 3 å¦‚æœä»»åŠ¡é˜Ÿåˆ—æ»¡äº†ï¼Œåˆ™æ ¹æ® maximumPoolSize åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹ã€‚å¦‚æœåˆ›å»ºå¤±è´¥ï¼Œè¯´æ˜å½“å‰çº¿ç¨‹æ•°å·²ç»è¾¾åˆ° maximumPoolSize æˆ–çº¿ç¨‹æ± å…³é—­ï¼Œéœ€è¦æ‰§è¡Œæ‹’ç»ç­–ç•¥ &#125; else if (!addWorker(command, false)) reject(command); &#125; execute æ–¹æ³•é€»è¾‘ä½“ç°äº†æäº¤ä»»åŠ¡åˆ°çº¿ç¨‹æ± çš„æµç¨‹ï¼Œä¸Šé¢ä»£ç å·²ç»è¯¦ç»†æ³¨é‡Šã€‚éœ€è¦å¼ºè°ƒçš„æ˜¯ï¼Œç¬¦åˆå°†ä»»åŠ¡åŠ å…¥é˜»å¡é˜Ÿåˆ—ä¸­çš„æƒ…å†µï¼Œä¼šè¿›è¡ŒåŒé‡æ£€æŸ¥çº¿ç¨‹æ± çš„çŠ¶æ€ï¼Œå› ä¸ºæ˜¯ç›´æ¥å°†ä»»åŠ¡å…¥é˜Ÿï¼Œå’Œå‰åä¸¤ç§æƒ…å†µä¸ä¸€æ ·ï¼Œå³ä½¿ä»»åŠ¡æˆåŠŸæ’é˜Ÿï¼Œä¹Ÿæœ‰å¯èƒ½å‡ºç°çº¿ç¨‹æ± å…³é—­æˆ–çº¿ç¨‹æ± ä¸ºç©ºçš„æƒ…å†µã€‚ ä¸‹é¢é€šè¿‡ä¸€å¼ å›¾è¿›è¡Œé˜è¿°æ­£å¸¸æµï¼ˆä¸è€ƒè™‘çº¿ç¨‹æ± å…³é—­ç­‰æƒ…å†µï¼‰çš„æµç¨‹ï¼š ä»»åŠ¡ç¼“å†²ä»»åŠ¡ç¼“å†²æ˜¯çº¿ç¨‹æ± ç®¡ç†ä»»åŠ¡çš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œé€šè¿‡ä¸€ä¸ªé˜»å¡é˜Ÿåˆ—æ¥å®ç°ã€‚çº¿ç¨‹æ± çš„æœ¬è´¨æ˜¯å¯¹ä»»åŠ¡å’Œçº¿ç¨‹çš„ç®¡ç†ï¼Œè€Œåšåˆ°è¿™ä¸€ç‚¹å…³é”®çš„æ€æƒ³æ˜¯å°†ä»»åŠ¡å’Œçº¿ç¨‹è§£è€¦ï¼Œé˜»å¡é˜Ÿåˆ—ç¼“å†²ä»»åŠ¡ï¼Œå·¥ä½œçº¿ç¨‹è‡ªæ—‹ä»é˜»å¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡ã€‚ é˜»å¡é˜Ÿåˆ—(BlockingQueue)æ˜¯ä¸€ä¸ªæ”¯æŒä¸¤ä¸ªé™„åŠ æ“ä½œçš„é˜Ÿåˆ—ã€‚åœ¨é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œè·å–å…ƒç´ çš„çº¿ç¨‹ä¼šç­‰å¾…é˜Ÿåˆ—å˜ä¸ºéç©ºã€‚å½“é˜Ÿåˆ—æ»¡æ—¶ï¼Œå­˜å‚¨å…ƒç´ çš„çº¿ç¨‹ä¼šç­‰å¾…é˜Ÿåˆ—å¯ç”¨ã€‚é˜»å¡é˜Ÿåˆ—å¸¸ç”¨äºç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…çš„åœºæ™¯ï¼Œç”Ÿäº§è€…æ˜¯å¾€é˜Ÿåˆ—é‡Œæ·»åŠ å…ƒç´ çš„çº¿ç¨‹ï¼Œæ¶ˆè´¹è€…æ˜¯ä»é˜Ÿåˆ—é‡Œæ‹¿å…ƒç´ çš„çº¿ç¨‹ã€‚ çº¿ç¨‹æ± ä¸­çš„é˜»å¡é˜Ÿåˆ—å‚æ•°éå¸¸é‡è¦ï¼Œä¸åŒçš„é˜»å¡é˜Ÿåˆ—å¯¹çº¿ç¨‹æ± æœ‰ä¸åŒå½±å“ï¼Œä¸‹é¢å¯¹çº¿ç¨‹æ± å¸¸ç”¨çš„é˜»å¡é˜Ÿåˆ—è¿›è¡Œè¯´æ˜ã€‚ ArrayBlockingQueueåŸºäºæ•°ç»„ç»“æ„çš„æœ‰ç•Œé˜»å¡é˜Ÿåˆ—ï¼Œè¯¥é˜Ÿåˆ—æŒ‰ç…§å…ˆè¿›å…ˆå‡ºåŸåˆ™å¯¹å…ƒç´ è¿›è¡Œæ’åºã€‚ LinkedBlockingQueueåŸºäºé“¾è¡¨ç»“æ„çš„æ— ç•Œé˜»å¡é˜Ÿåˆ—ï¼Œè¯¥é˜Ÿåˆ—æŒ‰ç…§å…ˆè¿›å…ˆå‡ºè§„åˆ™å¯¹å…ƒç´ è¿›è¡Œæ’åºã€‚æ­¤é˜Ÿåˆ—çš„é»˜è®¤é•¿åº¦ä¸º Integer.MAX_VALUEï¼Œä½¿ç”¨è¯¥é˜Ÿåˆ—ä½œä¸ºä»»åŠ¡é˜Ÿåˆ—æœ‰å®¹é‡å±é™©ã€‚ SynchronousQueueä¸€ä¸ªæ¯”è¾ƒç‰¹æ®Šçš„é˜»å¡é˜Ÿåˆ—ï¼Œå…¶æœ¬èº«ä¸å­˜å‚¨å…ƒç´ ã€‚æ¯ä¸ªæ’å…¥æ“ä½œå¿…é¡»ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œç§»é™¤æ“ä½œï¼Œåä¹‹äº¦ç„¶ã€‚å¦‚æœä½¿ç”¨è¯¥é˜»å¡é˜Ÿåˆ—ï¼Œåªæœ‰å½“ä¸¤ä¸ªçº¿ç¨‹æ‰§è¡Œç›¸åæ¨¡å¼çš„æ“ä½œæ‰èƒ½é…å¯¹æˆåŠŸï¼Œå¦åˆ™å…ˆæ‰§è¡Œçš„ä¸€æ–¹åªèƒ½ç­‰å¾…ã€‚ä¸‹å›¾æ˜¯å¯¹çº¿ç¨‹æ± ä½¿ç”¨è¯¥é˜Ÿåˆ—å¤„ç†ä»»åŠ¡è¿‡ç¨‹çš„æè¿°ï¼š PriorityBlockingQueueæ”¯æŒä¼˜å…ˆçº§æ’åºçš„æ— ç•Œé˜»å¡é˜Ÿåˆ—ï¼Œé»˜è®¤è‡ªç„¶æ’åºè§„åˆ™ï¼Œä¸èƒ½ä¿è¯åŒä¼˜å…ˆçº§å…ƒç´ çš„é¡ºåºã€‚ DelayQueueä¸€ä¸ªå®ç° PriorityBlockingQueue å®ç°å»¶è¿Ÿè·å–çš„æ— ç•Œé˜Ÿåˆ—ï¼Œåœ¨åˆ›å»ºå…ƒç´ æ—¶å¯ä»¥æŒ‡å®šå¤šä¹…æ‰èƒ½ä»é˜Ÿåˆ—ä¸­ç§»é™¤ï¼Œåªæœ‰å»¶æ—¶æœŸæ»¡åæ‰èƒ½ä»é˜Ÿåˆ—ä¸­è·å–å…ƒç´ ã€‚ LinkedBlockingDequeä¸€ä¸ªç”±é“¾è¡¨ç»“æ„æ„æˆçš„åŒå‘é˜»å¡é˜Ÿåˆ—ã€‚é˜Ÿåˆ—å¤´éƒ¨å’Œå°¾éƒ¨éƒ½å¯ä»¥æ·»åŠ å’Œç§»é™¤å…ƒç´ ã€‚ ä»»åŠ¡ç”³è¯·ä»»åŠ¡æ‰§è¡Œæœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯ä»»åŠ¡ç›´æ¥äº¤ç»™æ–°åˆ›å»ºçš„çº¿ç¨‹æ‰§è¡Œã€‚å¦ä¸€ç§æ˜¯çº¿ç¨‹æ‰§è¡Œ getTask æ–¹æ³•ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡å¹¶æ‰§è¡Œï¼Œæ‰§è¡Œå®Œä»»åŠ¡çš„çº¿ç¨‹ä¼šç»§ç»­å°è¯•ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­ç”³è¯·ä»»åŠ¡å†å»æ‰§è¡Œã€‚ç¬¬ä¸€ç§æƒ…å†µä»…å‡ºç°åœ¨ç”¨æˆ·æäº¤ä»»åŠ¡åˆ°çº¿ç¨‹æ± ï¼Œçº¿ç¨‹æ± ä¸ºè¯¥ä»»åŠ¡åˆ›å»ºçº¿ç¨‹çš„æ—¶å€™ã€‚ç¬¬äºŒç§æƒ…å†µæ˜¯çº¿ç¨‹æ‰§è¡Œä»»åŠ¡æœ€å¤šçš„æƒ…å†µï¼ŒåŒ…æ‹¬çº¿ç¨‹æ± å­˜åœ¨çš„çº¿ç¨‹æ‰§è¡Œä»»åŠ¡ï¼Œåˆ›å»ºçš„éæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œä»»åŠ¡ã€‚ ä»»åŠ¡ç”³è¯·çš„æ ¸å¿ƒæ–¹æ³• getTask æ˜¯é…åˆ Workerçº¿ç¨‹ å·¥ä½œçš„ï¼Œç”¨äº Workerçº¿ç¨‹ æ‹‰å–ä»»åŠ¡é˜Ÿåˆ—ï¼Œä¸‹é¢å¯¹è¯¥æ–¹æ³•è¿›è¡Œåˆ†æã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 /** * @return è¿”å›null è¡¨ç¤ºå¯ä»¥å¯¹å½“å‰çº¿ç¨‹è¿›è¡Œå›æ”¶ */private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (; ; ) &#123; // è·å–çº¿ç¨‹æ± çŠ¶æ€ç  int c = ctl.get(); // è·å–çº¿ç¨‹æ± çŠ¶æ€ int rs = runStateOf(c); // çº¿ç¨‹æ± çŠ¶æ€ä¸ºSHUTDOWNä¸”é˜Ÿåˆ—ä¸ºç©º æˆ– çº¿ç¨‹æ± çŠ¶æ€ä¸º STOPï¼Œåº”è¯¥å›æ”¶çº¿ç¨‹ã€‚è¿™ä¸ªæ¡ä»¶ä¸ä»…å¯ä»¥å›æ”¶éæ ¸å¿ƒçº¿ç¨‹ï¼Œä¹Ÿå¯ä»¥å›æ”¶æ ¸å¿ƒçº¿ç¨‹ã€‚todo æ ¸å¿ƒçº¿ç¨‹å”¯ä¸€å›æ”¶æ¡ä»¶ if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; // å‡å°‘çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•° decrementWorkerCount(); return null; &#125; // çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•° int wc = workerCountOf(c); // æ˜¯å¦éœ€è¦è¿›è¡Œè¶…æ—¶æ§åˆ¶ã€‚å³å…è®¸æ ¸å¿ƒçº¿ç¨‹æ•°å†…çš„çº¿ç¨‹å›æ”¶ï¼Œæˆ–çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°è¶…è¿‡äº†æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œé‚£ä¹ˆæœ‰å¯èƒ½å‘ç”Ÿè¶…æ—¶å…³é—­ boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; // æ§åˆ¶çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°çš„å…³é”® //1. wc &gt; maximumPoolSize ï¼Œå¯èƒ½æ˜¯åœ¨æ­¤æ–¹æ³•æ‰§è¡Œé˜¶æ®µåŒæ—¶æ‰§è¡Œ setMaximumPoolSize æ–¹æ³•ä¿®æ”¹äº†æœ€å¤§å€¼ã€‚ //2. timed &amp;&amp; timedOut å¦‚æœä¸ºtrueï¼Œè¡¨ç¤ºå½“å‰æ“ä½œéœ€è¦è¿›è¡Œè¶…æ—¶æ§åˆ¶ï¼Œä¸”çº¿ç¨‹ä¸Šä¸€è½®è·å–ä»»åŠ¡è¶…æ—¶ //3. ç»“æœï¼šå¦‚æœçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°å¤§äºæœ€å¤§çº¿ç¨‹æ•°æˆ–è·å–ä»»åŠ¡è¶…æ—¶ï¼ˆä¸è®¾ç½® allowCoreThreadTimeOutï¼Œæ ¸å¿ƒçº¿ç¨‹æ²¡æœ‰è¶…æ—¶æ¦‚å¿µï¼‰ï¼Œå¹¶ä¸”ï¼ˆçº¿ç¨‹æ•° &gt; 1 æˆ– ä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºï¼‰ï¼Œåˆ™åº”è¯¥å›æ”¶å½“å‰çº¿ç¨‹ã€‚ if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; // å‡å°‘å·¥ä½œçº¿ç¨‹æ•° if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; // æ ¹æ®timedæ¥åˆ¤æ–­ï¼š // 1. å¦‚æœä¸ºtrueï¼Œåˆ™é€šè¿‡é˜»å¡é˜Ÿåˆ—çš„pollæ–¹æ³•è¿›è¡Œè¶…æ—¶æ§åˆ¶ï¼Œå¦‚æœåœ¨keepAliveTimeæ—¶é—´å†…æ²¡æœ‰è·å–åˆ°ä»»åŠ¡åˆ™è¿”å›null // 2. å¦åˆ™é€šè¿‡takeæ–¹æ³•è·å–ä»»åŠ¡ï¼Œå¦‚æœé˜Ÿåˆ—ä¸ºç©ºåˆ™takeæ–¹æ³•ä¼šé˜»å¡ç›´åˆ°é˜Ÿåˆ—ä¸ä¸ºç©º Runnable r = timed ? // è¶…æ—¶è·å–ä»»åŠ¡ï¼Œå› ä¸ºçº¿ç¨‹è¶…æ—¶è¦è¢«å›æ”¶ã€‚å¦‚æœçº¿ç¨‹åœ¨ç­‰å¾…çš„è¿‡ç¨‹å‘ç”Ÿäº†ä¸­æ–­ï¼Œä¼šæŠ›å‡ºä¸­æ–­å¼‚å¸¸ workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : // ä¸éœ€è¦è¶…æ—¶ï¼Œå¦‚æœçº¿ç¨‹åœ¨ç­‰å¾…çš„è¿‡ç¨‹å‘ç”Ÿäº†ä¸­æ–­ï¼Œä¼šæŠ›å‡ºä¸­æ–­å¼‚å¸¸ workQueue.take(); if (r != null) return r; // å¦‚æœ r == null ï¼Œè¯´æ˜è·å–ä»»åŠ¡è¶…æ—¶ timedOut = true; &#125; catch (InterruptedException retry) &#123; // è·å–ä»»åŠ¡æ—¶å½“å‰çº¿ç¨‹å‘ç”Ÿä¸­æ–­ï¼Œé‡ç½®è¶…æ—¶æ ‡è®°å¹¶é‡è¯• timedOut = false; &#125; &#125; &#125; ä¸Šè¿°æ–¹æ³•ç”¨äºä»ä»»åŠ¡é˜Ÿåˆ—ä¸­ä¸æ–­æ‹‰å–å¾…æ‰§è¡Œçš„ä»»åŠ¡ï¼Œå…·ä½“æ‰§è¡Œæµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸‹é¢å¯¹ä¸»è¦é€»è¾‘è¿›è¡Œè¯´æ˜ï¼š è¯¥æ–¹æ³•è¿”å› null æ—¶ï¼Œè¡¨ç¤ºå½“å‰çº¿ç¨‹å¯ä»¥è¢«å›æ”¶äº†ï¼ŒåŒ…æ‹¬æ ¸å¿ƒçº¿ç¨‹ã€‚è¿™ä¹Ÿæ˜¯è¯¥æ–¹æ³•å¤šæ¬¡åˆ¤æ–­çš„åŸå› ï¼Œæ§åˆ¶çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°é‡ï¼Œè¿›è€Œæ§åˆ¶çº¿ç¨‹æ± çš„çŠ¶æ€ã€‚ åœ¨æ²¡æœ‰è®¾ç½® allowCoreThreadTimeOut æ—¶ï¼Œæ ¸å¿ƒçº¿ç¨‹æ•°çš„çº¿ç¨‹ä¼šé˜»å¡ç­‰å¾…ä»»åŠ¡ï¼Œä¸ä¼šè¢«å›æ”¶ã€‚ è¶…æ—¶å›æ”¶ï¼Œåœ¨ keepAliveTime å¯¹åº”çš„å…·ä½“æ—¶é—´å†…éƒ½æ²¡æœ‰ä»»åŠ¡ï¼Œåº”è¯¥å›æ”¶éæ ¸å¿ƒçº¿ç¨‹ã€‚ ä»¥ä¸‹æƒ…å†µéœ€è¦è¿”å› nullï¼Œå›æ”¶å½“å‰çº¿ç¨‹ã€‚ çº¿ç¨‹æ± å¤„äº STOP çŠ¶æ€ã€‚ çº¿ç¨‹æ± å¤„äº SHUTDOWN çŠ¶æ€ï¼Œä¸”é˜»å¡é˜Ÿåˆ—ä¸ºç©ºã€‚ çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°å¤§äºæœ€å¤§çº¿ç¨‹æ•°ã€‚ çº¿ç¨‹è·å–ä»»åŠ¡è¶…æ—¶å†æ¬¡é‡è¯•æ—¶ï¼Œä»ä¸ºå¯å›æ”¶çº¿ç¨‹ã€‚ getTask æ–¹æ³•è¿˜æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œæ•´ä¸ªé€»è¾‘ä¸­è¿›è¡Œäº†å¤šæ¬¡åˆ¤æ–­ï¼Œç›®çš„æ˜¯æ§åˆ¶çº¿ç¨‹çš„æ•°é‡ï¼Œè¿›è€Œç»´æŠ¤çº¿ç¨‹æ± çš„çŠ¶æ€ã€‚éœ€è¦ç‰¹æ®Šè¯´æ˜çš„æ˜¯ï¼Œå½“çº¿ç¨‹è·å–ä»»åŠ¡è¶…æ—¶æ—¶å¹¶æ²¡æœ‰ç«‹åˆ»å›æ”¶è¯¥çº¿ç¨‹ï¼Œè€Œæ˜¯è®©çº¿ç¨‹é‡è¯•ï¼Œè¿™ä¹ˆåšæ˜¯ä¸ºäº†é˜²æ­¢è¯¥çº¿ç¨‹å¯èƒ½ä¼šæˆä¸ºæ ¸å¿ƒçº¿ç¨‹ï¼Œé¿å…è¯¯å›æ”¶ï¼Œå¦‚æœè¯¯å›æ”¶åœ¨åç»­æµç¨‹ä¸­è¿˜éœ€è¦é‡æ–°åˆ›å»ºçº¿ç¨‹ï¼Œå› æ­¤é‡è¯•ä¸€æ¬¡ä»£ä»·ä¼šå°ä¸€äº›ã€‚ ä»»åŠ¡æ‰§è¡Œä»»åŠ¡æ‰§è¡Œæ˜¯ Workerçº¿ç¨‹ çš„å·¥ä½œï¼Œæˆ‘ä»¬ä¼šåœ¨ä¸‹é¢è¯¦ç»†ä»‹ç»ã€‚ ä»»åŠ¡æ‹’ç»æ‹’ç»ç­–ç•¥çº¿ç¨‹æ± çš„æ‹’ç»ç­–ç•¥å±äºä¸€ç§é™æµä¿æŠ¤æœºåˆ¶ï¼Œé˜²æ­¢çº¿ç¨‹æ± å´©æºƒã€‚çº¿ç¨‹æ± æ‹’ç»ä»»åŠ¡çš„æ—¶æœºå¦‚ä¸‹ï¼š æ‰§è¡Œå…³é—­æ–¹æ³•åçº¿ç¨‹æ± å¤„äºå…³é—­çŠ¶æ€åŠä»¥ä¸ŠçŠ¶æ€ çº¿ç¨‹æ± å¤„äºè¿è¡ŒçŠ¶æ€ï¼Œä½†æ˜¯æ²¡æœ‰èƒ½åŠ›ï¼ˆé˜»å¡é˜Ÿåˆ—å·²æ»¡ï¼Œçº¿ç¨‹æ•°è¾¾åˆ°æœ€å¤§å€¼ï¼‰å¤„ç†æ–°æäº¤çš„ä»»åŠ¡äº†ã€‚ JDK å†…ç½®äº† 4 ç§æ‹’ç»ç­–ç•¥ï¼Œé»˜è®¤ä½¿ç”¨ AbortPolicy ç­–ç•¥ã€‚æ‹’ç»ç­–ç•¥å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š AbortPolicy12345678910111213141516171819/** * ä¸¢å¼ƒä»»åŠ¡å¹¶æŠ›å‡ºå¼‚å¸¸ï¼ˆé»˜è®¤ç­–ç•¥ï¼‰ */ public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; /** * ç›´æ¥æŠ›å‡ºå¼‚å¸¸ * * @param r ä»»åŠ¡ * @param e te */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(\"Task \" + r.toString() + \" rejected from \" + e.toString()); &#125; &#125; AbortPolicy ç­–ç•¥æ˜¯çº¿ç¨‹æ± é»˜è®¤çš„æ‹’ç»ç­–ç•¥ï¼Œåœ¨ä»»åŠ¡ä¸èƒ½å†æäº¤åˆ°çº¿ç¨‹æ± æ—¶æŠ›å‡ºå¼‚å¸¸ï¼Œèƒ½å¤ŸåŠæ—¶åé¦ˆç¨‹åºçš„è¿è¡ŒçŠ¶æ€ã€‚å¯¹äºæ¯”è¾ƒæ ¸å¿ƒçš„ä¸šåŠ¡æ¨èä½¿ç”¨æ­¤æ‹’ç»ç­–ç•¥ï¼Œå› ä¸ºå½“ç³»ç»Ÿä¸èƒ½æ‰¿è½½æ›´å¤§çš„å¹¶å‘æµé‡æ—¶ï¼Œä¸šåŠ¡æ–¹èƒ½å¤ŸåŠæ—¶åœ°é€šè¿‡å¼‚å¸¸å‘ç°ã€‚ CallerRunsPolicy123456789101112131415161718192021/** * ç”±æäº¤ä»»åŠ¡çš„çº¿ç¨‹è‡ªå·±æ¥æ‰§è¡Œä»»åŠ¡ */ public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123; &#125; /** * åªè¦çº¿ç¨‹æ± æ²¡æœ‰è¢«å…³é—­ï¼Œå°±ç”±æäº¤ä»»åŠ¡çš„çº¿ç¨‹è‡ªå·±æ¥æ‰§è¡Œè¿™ä¸ªä»»åŠ¡ã€‚ * * @param r * @param e */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; // çº¿ç¨‹æ± æ²¡æœ‰å…³é—­ if (!e.isShutdown()) &#123; // æ–¹æ³•çº§åˆ«è°ƒç”¨ r.run(); &#125; &#125; &#125; CallerRunsPolicy ç­–ç•¥æ˜¯ç”±æäº¤ä»»åŠ¡çš„çº¿ç¨‹å¤„ç†ä»»åŠ¡ï¼Œæ­¤ç­–ç•¥é€‚åˆè®©æ‰€æœ‰ä»»åŠ¡éƒ½æ‰§è¡Œå®Œæ¯•ã€‚ DiscardPolicy12345678910111213141516/** * ç›´æ¥å¿½ç•¥ä»»åŠ¡ */ public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123; &#125; /** * ç›´æ¥å¿½ç•¥ * * @param r * @param e */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125; &#125; DiscardPolicy ç­–ç•¥ä¼šç›´æ¥ä¸¢å¼ƒä»»åŠ¡ï¼Œå¹¶ä¸”ä¸ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚æ­¤ç­–ç•¥ä¼šå¯¼è‡´ä¸šåŠ¡æ–¹æ— æ³•å‘ç°å¼‚å¸¸ï¼Œä¸å»ºè®®æ ¸å¿ƒä¸šåŠ¡é‡‡ç”¨æ­¤ç­–ç•¥ã€‚ DiscardOldestPolicy1234567891011121314151617181920/** * å°†é˜»å¡é˜Ÿåˆ—å¤´çš„ä»»åŠ¡æ‰”æ‰ï¼Œç„¶åå°†å½“å‰ä»»åŠ¡æäº¤åˆ°çº¿ç¨‹æ± å°è¯•æ‰§è¡Œã€‚ */ public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123; &#125; /** * å°†é˜Ÿåˆ—éƒ½ä»»åŠ¡ç§»é™¤ï¼Œå¹¶å°†å½“å‰ä»»åŠ¡æäº¤åˆ°çº¿ç¨‹æ±  * * @param r * @param e */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125; &#125; DiscardOldestPolicy ç­–ç•¥ä¼šä¸¢å¼ƒé˜Ÿåˆ—æœ€å‰é¢çš„ä»»åŠ¡ï¼Œç„¶åé‡æ–°æäº¤è¢«æ‹’ç»çš„ä»»åŠ¡ã€‚è¿™ç§ç­–ç•¥å­˜åœ¨ä¸¢å¤±ä»»åŠ¡çš„é£é™©ã€‚ è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥åªéœ€è¦å®ç° RejectedExecutionHandler æ¥å£ï¼Œé‡å†™ rejectedExecution æ–¹æ³•å³å¯ã€‚å¦‚æœä¸è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥ï¼Œçº¿ç¨‹æ± å°†ä½¿ç”¨é»˜è®¤çš„æ‹’ç»ç­–ç•¥ã€‚ Workerçº¿ç¨‹ç®¡ç†å‰æ–‡åœ¨ä»‹ç»ä»»åŠ¡æ‰§è¡Œæœºåˆ¶çš„æ—¶å€™æ¶‰åŠåˆ° Workerçº¿ç¨‹ï¼Œçº¿ç¨‹æ± ç»´æŠ¤çš„çº¿ç¨‹æ¨¡å—å…¶å®å°±æ˜¯ä¸€ç»„ Workerå¯¹è±¡ ï¼Œä¸‹é¢æˆ‘ä»¬å°±æ¥çœ‹çœ‹ ThreadPoolExecutor çš„å†…éƒ¨ç±» Worker ã€‚ Workerçº¿ç¨‹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** * WorkeræŒæœ‰çš„çº¿ç¨‹ï¼Œå³ä»»åŠ¡æ‰§è¡Œçš„çœŸæ­£çº¿ç¨‹ */ final Thread thread; /** * ä¸»çº¿ç¨‹æäº¤ä»»åŠ¡åˆ°çº¿ç¨‹æ± ï¼Œä»»åŠ¡å°±ä¼šå­˜æ”¾åˆ°è¿™é‡Œã€‚ */ Runnable firstTask; /** * ç”¨äºå­˜æ”¾å½“å‰çº¿ç¨‹å®Œæˆçš„ä»»åŠ¡æ•°ã€‚æ³¨æ„å’Œ completedTaskCount çš„åŒºåˆ« */ volatile long completedTasks; /** * Worker å”¯ä¸€çš„æ„é€ æ–¹æ³• * * @param firstTask ä»»åŠ¡ï¼Œå¯èƒ½ä¸º null */ Worker(Runnable firstTask) &#123; // è®¾ç½®çŠ¶æ€å€¼ä¸º -1ï¼Œé˜²æ­¢åœ¨å¯åŠ¨çº¿ç¨‹ä¹‹å‰ï¼Œçº¿ç¨‹å°±è¢«ä¸­æ–­ã€‚å› ä¸ºAQSä¸­é»˜è®¤çš„ state ä¸º 0ï¼ŒWorkerä¸­å®ç°çš„ tryAcquire æ–¹æ³•å†…å­˜å€¼å°±æ˜¯ 0ï¼Œä¿®æ”¹å€¼ä¸º 1 setState(-1); this.firstTask = firstTask; // ä½¿ç”¨å·¥å‚åˆ›å»ºçº¿ç¨‹ï¼Œæ³¨æ„åˆ›å»ºå‡ºæ¥çš„çº¿ç¨‹çš„ä»»åŠ¡ä½“å°±æ˜¯ Worker æœ¬èº«ã€‚è¿™æ„å‘³ç€å½“çº¿ç¨‹å¯åŠ¨æ—¶ï¼ŒWorker#runæ–¹æ³•å°±ä¼šæ‰§è¡Œ this.thread = getThreadFactory().newThread(this); &#125; /** * Worker å®ç°äº† Runnable æ¥å£ï¼Œé‡å†™äº†run() æ–¹æ³•ã€‚ */ public void run() &#123; // è¿™é‡Œè°ƒç”¨äº†å¤–éƒ¨ç±»çš„ runWorker æ–¹æ³• runWorker(this); &#125; // ------- Workerç»§æ‰¿äº†AQSç±»ï¼Œä¸‹é¢çš„æ ¸å¿ƒæ–¹æ³•æ˜¯é‡å†™äº†AQSçš„æ–¹æ³•ï¼Œä½¿ç”¨ç‹¬å é”è·å¾—æ‰§è¡Œæƒï¼Œä¸æ”¯æŒé”çš„é‡å…¥ -----------------/ protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; /** * ç‹¬å å¼è·å–èµ„æºã€‚AQS ä¸­é»˜è®¤çš„ state ä¸º 0ã€‚ * * @param unused * @return */ protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; /** * é‡Šæ”¾èµ„æº * * @param unused * @return */ protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; /** * lock */ public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; /** * unlock */ public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; /** * ä¸­æ–­çº¿ç¨‹ */ void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125;&#125; çº¿ç¨‹æ± åœ¨åˆ›å»ºçº¿ç¨‹æ—¶ï¼Œä¼šå°†çº¿ç¨‹å°è£…æˆå·¥ä½œçº¿ç¨‹Workerï¼Œç›®çš„æ˜¯ç®¡ç†çº¿ç¨‹çš„çŠ¶æ€å¹¶ç»´æŠ¤çº¿ç¨‹çš„ç”Ÿå‘½å‘¨æœŸã€‚ å·¥ä½œçº¿ç¨‹Worker æ¯”è¾ƒç‰¹åˆ«ï¼Œä¸‹é¢å¯¹å…¶å…³é”®ç‚¹è¿›è¡Œè¯´æ˜ï¼š ç»§æ‰¿äº† AQS ï¼Œå®ç°äº†ä¸€å¥—ç‹¬å é”æœºåˆ¶ã€‚ 1.Worker å¹¶æ²¡æœ‰ç›´æ¥ä½¿ç”¨å¯é‡å…¥é” ReentrantLock ï¼Œè€Œæ˜¯é€šè¿‡ç»§æ‰¿ AQS å®ç°äº†ä¸å¯é‡å…¥çš„ç‹¬å é”ï¼Œç›®çš„å°±æ˜¯é€šè¿‡ä¸å¯é‡å…¥çš„ç‰¹æ€§åˆ¤æ–­ Worker ä¸­å°è£…çº¿ç¨‹çš„æ‰§è¡ŒçŠ¶æ€ã€‚2.åœ¨çº¿ç¨‹æ‰§è¡Œä»»åŠ¡æœŸé—´ä¼šåŠ  Workeréé‡å…¥é”ï¼Œè¡¨ç¤ºå½“å‰çº¿ç¨‹æ­£åœ¨æ‰§è¡Œä»»åŠ¡ä¸­ï¼Œå¹¶ä¸æ˜¯å¤„äºç©ºé—²çŠ¶æ€ï¼Œä¸åº”è¯¥ä¸­æ–­è¯¥çº¿ç¨‹ã€‚3.å¦‚æœçº¿ç¨‹ä¸æ˜¯ç‹¬å é”çš„çŠ¶æ€åˆ™è¡¨æ˜è¯¥çº¿ç¨‹å¤„äºç©ºé—²çŠ¶æ€ï¼Œå¯ä»¥å¯¹è¯¥çº¿ç¨‹è¿›è¡Œä¸­æ–­ å®ç°äº† Runnable æ¥å£ï¼Œå®ƒæ˜¯ä¸€ä¸ªä»»åŠ¡ä½“å¹¶é‡å†™çš„ run æ–¹æ³•ï¼Œè¯¥æ–¹æ³•æ˜¯çº¿ç¨‹æ± æ‰§è¡Œä»»åŠ¡çš„å…³é”®ã€‚ åœ¨åˆ›å»º Worker æˆåŠŸåï¼Œç´§æ¥ç€å°±ä¼šå¯åŠ¨ Worker å°è£…çš„çœŸå® Thread ï¼Œå¯åŠ¨æˆåŠŸå Worker ä¸­çš„ run æ–¹æ³•å°±ä¼šæ‰§è¡Œã€‚ å†…éƒ¨å°è£…äº†å®é™…æ‰§è¡Œä»»åŠ¡çš„çº¿ç¨‹ã€‚ å†…éƒ¨å°è£…çš„çº¿ç¨‹æ˜¯çº¿ç¨‹æ± çš„å·¥å‚åˆ›å»ºå‡ºæ¥çš„ï¼Œå®ƒçš„ä½¿å‘½å°±æ˜¯æ‰§è¡Œ Worker ä¸­çš„ run æ–¹æ³•ä¸­çš„ä»»åŠ¡ã€‚é‚£ä¸šåŠ¡ä»»åŠ¡è°æ¥æ‰§è¡Œï¼Ÿ åŒæ ·åœ°ï¼Œä¹Ÿæ˜¯è¯¥çº¿ç¨‹æ‰§è¡Œï¼Œåªä¸è¿‡å®ƒä½¿ç”¨çš„æ˜¯æ–¹æ³•çº§åˆ«çš„è°ƒç”¨ã€‚ å†…éƒ¨å°è£…äº†åˆå§‹åŒ–ä»»åŠ¡ä½“ Worker ä½¿ç”¨ firstTask ä¿å­˜ä¼ å…¥çš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œè¯¥ä»»åŠ¡å…è®¸ä¸ºnullã€‚å¦‚æœè¯¥ä»»åŠ¡éç©ºï¼Œé‚£ä¹ˆçº¿ç¨‹å°±ä¼šåœ¨å¯åŠ¨åä¼˜å…ˆæ‰§è¡Œè¿™ä¸ªä»»åŠ¡ï¼Œä¸€èˆ¬å¯¹åº”äºæ ¸å¿ƒçº¿ç¨‹çš„åˆ›å»ºï¼›å¦‚æœè¯¥ä»»åŠ¡ä¸ºç©ºï¼Œå¯¹åº”äºéæ ¸å¿ƒçº¿ç¨‹çš„åˆ›å»ºï¼Œç”¨äºå»æ‰§è¡Œä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ã€‚ çº¿ç¨‹å¤ç”¨ ä¸€ä¸ª Worker å¯¹åº”çº¿ç¨‹æ± ä¸­çš„ä¸€ä¸ªçº¿ç¨‹ï¼Œçº¿ç¨‹å¤ç”¨çš„é€»è¾‘å®ç°æ˜¯åœ¨ Worker ç±»ä¸­çš„ run æ–¹æ³•ä¸­æ‰§è¡Œ runWorker æ–¹æ³•ã€‚ç”±ä¸Šé¢çš„ç¬¬ 2ã€3 ä¸¤ä¸ªè¯´æ˜ï¼Œå¾ˆå®¹æ˜“å¾—å‡ºï¼Œå½“ Worker ä¸­çš„çº¿ç¨‹å¯åŠ¨åä¼šæ‰§è¡Œ Worker è¿™ä¸ªä»»åŠ¡ä½“çš„ run æ–¹æ³•ï¼Œè¿›è€Œè¯¥çº¿ç¨‹å°±ä¼šæ‰§è¡Œ runWorker æ–¹æ³•ï¼Œç„¶åè¿›å…¥åˆ° while è‡ªæ—‹ï¼Œå®ç°çº¿ç¨‹çš„å¤ç”¨ã€‚ çº¿ç¨‹å›æ”¶ çº¿ç¨‹æ± ç®¡ç†ç€çº¿ç¨‹çš„ç”Ÿå‘½å‘¨æœŸï¼Œéœ€è¦å¯¹é•¿æ—¶é—´ç©ºé—²çš„çº¿ç¨‹ã€å¯åŠ¨å¤±è´¥çš„çº¿ç¨‹ä»¥åŠæ‰§è¡Œä»»åŠ¡å‡ºç°å¼‚å¸¸çš„çº¿ç¨‹è¿›è¡Œå›æ”¶ã€‚çº¿ç¨‹æ± ä½¿ç”¨äº†HashSetè¿™ä¸ªHashè¡¨å»æŒæœ‰Workerçš„å¼•ç”¨ï¼Œè¿™æ ·å¯ä»¥é€šè¿‡æ·»åŠ å¼•ç”¨å’Œç§»é™¤å¼•ç”¨çš„æ“ä½œæ¥æ§åˆ¶çº¿ç¨‹çš„ç”Ÿå‘½å‘¨æœŸã€‚ å‰æ–‡å¯¹çº¿ç¨‹æ± çš„ä»»åŠ¡æ‰§è¡Œæœºåˆ¶è¿›è¡Œäº†ä»‹ç»ï¼Œä¸‹å›¾æ˜¯ Worker æ‰§è¡Œä»»åŠ¡çš„æ¨¡å‹ï¼š æ–°å¢çº¿ç¨‹å¦‚æœè¯´ execute æ–¹æ³•é€»è¾‘ä½“ç°äº†æäº¤ä»»åŠ¡åˆ°çº¿ç¨‹æ± çš„æµç¨‹ï¼Œé‚£ä¹ˆ addWorker æ–¹æ³•åˆ™ä½“ç°äº†çº¿ç¨‹æ± æ‰§è¡Œä»»åŠ¡çš„å¼€ç«¯ï¼Œå³æ¥æ”¶ä»»åŠ¡ã€åˆ›å»ºçº¿ç¨‹ã€å¯åŠ¨çº¿ç¨‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128private boolean addWorker(Runnable firstTask, boolean core) &#123; //------------------------------- 1 åˆ›å»ºçº¿ç¨‹å‰çš„æ£€æµ‹å·¥ä½œ -------------------------------------/ // for è·³å‡ºæ ‡å¿— retry: for (; ; ) &#123; //------------------------- 1.1 åˆ›å»ºçº¿ç¨‹å‰ï¼Œå¯¹çº¿ç¨‹æ± çŠ¶æ€å’Œé˜Ÿåˆ—è¿›è¡Œæ£€æŸ¥ï¼Œåˆ¤æ–­æ˜¯å¦è¿˜å¯ä»¥åˆ›å»ºçº¿ç¨‹ ----------------------/ // è·å–çº¿ç¨‹æ± çŠ¶æ€ç  int c = ctl.get(); // è·å–çº¿ç¨‹æ± çŠ¶æ€ int rs = runStateOf(c); /** * * å¦‚æœçº¿ç¨‹æ± çŠ¶æ€èŒƒå›´æ˜¯ï¼š[SHUTDOWNï¼ŒTERMINATED]ï¼Œå‡ºç°ä¸‹åˆ—ä»»ä¸€ç§æƒ…å†µéƒ½ä¸å…è®¸åˆ›å»ºWorker: * 1 firstTask != null * 2 workQueue ä¸ºç©º * *å°ç»“ï¼š * 1 çº¿ç¨‹æ± å¤„äº SHUTDOWN çŠ¶æ€æ—¶ï¼Œä¸å…è®¸æäº¤ä»»åŠ¡ï¼Œä½†æ˜¯å·²ç»å­˜åœ¨çš„ä»»åŠ¡éœ€è¦ç»§ç»­æ‰§è¡Œã€‚ * 1.1 å½“ firstTask == null æ—¶ä¸”é˜»å¡é˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œè¯´æ˜éæäº¤ä»»åŠ¡åˆ›å»ºçº¿ç¨‹ï¼Œæ‰§è¡Œé˜»å¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼Œå…è®¸åˆ›å»º Worker * 1.2 å½“ firstTask == null ä½†é˜»å¡é˜Ÿåˆ—ä¸ºç©ºï¼Œä¸èƒ½åˆ›å»º Worker * 1.3 å½“ firstTask ï¼= null æ—¶ï¼Œä¸èƒ½åˆ›å»º * 2 çº¿ç¨‹æ± çŠ¶æ€å¤§äº SHUTDOWN çŠ¶æ€æ—¶ï¼Œä¸å…è®¸æäº¤ä»»åŠ¡ï¼Œä¸”ä¸­æ–­æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ã€‚ */ if (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty())) return false; //---------------------------- 2 åˆ›å»ºçº¿ç¨‹å‰ï¼Œå¯¹çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°æ£€æŸ¥ï¼Œåˆ¤æ–­æ˜¯å¦è¿˜å¯ä»¥åˆ›å»ºçº¿ç¨‹ ---------------------/ for (; ; ) &#123; // è·å–çº¿ç¨‹æ± çº¿ç¨‹æ•° int wc = workerCountOf(c); // åˆ¤æ–­çº¿ç¨‹æ± çº¿ç¨‹æ•°æ˜¯å¦è¾¾åˆ°è¾¹ç•Œå€¼ï¼š1 ä¸´ç•Œå€¼ 2 æ ¸å¿ƒçº¿ç¨‹æ•°æˆ–æœ€å¤§çº¿ç¨‹æ•° if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; // å¢åŠ çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°å¦‚æœæˆåŠŸï¼Œåˆ™è¡¨ç¤ºåˆ›å»º Worker å‰çš„æ ¡éªŒå·¥ä½œå®Œæˆï¼Œå¯ä»¥è¿›è¡Œåˆ›å»º Worker æµç¨‹äº†ã€‚ if (compareAndIncrementWorkerCount(c)) break retry; // å¢åŠ çº¿ç¨‹æ•°å¤±è´¥ï¼Œè¯´æ˜å¯èƒ½å…¶å®ƒçº¿ç¨‹ä¹Ÿåœ¨å°è¯•åˆ›å»ºWorkerï¼Œå°±éœ€è¦å›åˆ°èµ·ç‚¹ï¼Œé‡æ–°æ ¡éªŒã€‚ //å¹¶å‘å½±å“ï¼Œéœ€è¦é‡æ–°è·å–çº¿ç¨‹æ± çŠ¶æ€ç  c = ctl.get(); //çº¿ç¨‹æ± çŠ¶æ€æ˜¯å¦æ”¹å˜ï¼Œæ”¹å˜äº†åˆ™éœ€è¦é‡å¤´æ ¡éªŒï¼Œå¦åˆ™åªéœ€è¦å†æ¬¡æ ¡éªŒçº¿ç¨‹æ•°å³å¯ if (runStateOf(c) != rs) continue retry; &#125; &#125; //---------------------------------- åˆ›å»º Worker æµç¨‹ ------------------------------------/ // Worker ä¸­çš„çº¿ç¨‹æ˜¯å¦å¯åŠ¨çš„æ ‡å¿— boolean workerStarted = false; // Worker æ˜¯å¦æ·»åŠ åˆ° workers é›†åˆä¸­çš„æ ‡å¿— boolean workerAdded = false; Worker w = null; try &#123; // åˆ›å»º Workerï¼Œå°†ä»»åŠ¡ä¼ å…¥ã€‚æ³¨æ„ï¼Œå¦‚æœæ˜¯éæäº¤ä»»åŠ¡åˆ›å»ºWorkerçš„è¯ï¼ŒfirstTask ä¸ºnull w = new Worker(firstTask); // å°†åˆ›å»ºçš„Workerä¸­çš„çº¿ç¨‹ä¸´æ—¶ä¿å­˜åˆ° tï¼Œè¿™ä¸ªæ˜¯çœŸæ­£çš„çº¿ç¨‹ï¼ŒWorker åªæ˜¯å¯¹çº¿ç¨‹è¿›è¡Œäº†åŒ…è£…ã€‚ final Thread t = w.thread; // Worker ä¸­çš„çº¿ç¨‹åˆ›å»ºæˆåŠŸ if (t != null) &#123; // åŠ é”ï¼Œæ³¨æ„è¿™ä¸ªé”çš„ç²’åº¦æ˜¯å…¨å±€çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“è¿™é‡Œè·å–åˆ°é”ï¼Œçº¿ç¨‹æ± ä¸èƒ½å…³é—­ï¼Œå› ä¸ºçº¿ç¨‹æ± å…³é—­ä¹Ÿéœ€è¦é”ã€‚ final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // å†æ¬¡è·å–çº¿ç¨‹æ± çŠ¶æ€ int rs = runStateOf(ctl.get()); // å¦‚æœçº¿ç¨‹æ± æ˜¯è¿è¡ŒçŠ¶æ€ï¼Œæˆ–è€…æ˜¯å…³é—­çŠ¶æ€ä¸”ä¼ å…¥çš„ä»»åŠ¡ä¸ºnull(ä¸æ¥æ”¶æ–°ä»»åŠ¡ï¼Œä½†æ˜¯ä¼šç»§ç»­æ‰§è¡Œä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡)ï¼Œç¬¦åˆæ¡ä»¶ã€‚ // æ­¤å¤–éƒ½ä¸ç¬¦åˆæ¡ä»¶ï¼Œçº¿ç¨‹æ± ä¸ä¼šç»´æŠ¤å½“å‰åˆ›å»ºçš„Workerçº¿ç¨‹ï¼Œè¯¥Workerçº¿ç¨‹ç”±äºæ²¡æœ‰è¢«å¼•ç”¨æœ€åä¼šè¢«JVMå›æ”¶ if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; // æå‰æ£€æŸ¥æ–°åˆ›å»ºçš„Workerä¸­çš„çº¿ç¨‹æ˜¯å¦æ˜¯å¯åŠ¨çŠ¶æ€ if (t.isAlive()) throw new IllegalThreadStateException(); // å°†æ–°åˆ›å»ºçš„ Worker åŠ å…¥åˆ° workers é›†åˆï¼Œæ„å‘³ç€çº¿ç¨‹æ± æŒæœ‰å½“å‰ Worker çš„å¼•ç”¨ï¼Œå½“å‰ Worker ä¸ä¼šè¢« GCã€‚ workers.add(w); // æ›´æ–° largestPoolSize çš„å€¼ï¼Œè¯¥å€¼ç”¨äºè¿½è¸ªçº¿ç¨‹æ± ä¸­å‡ºç°è¿‡çš„æœ€å¤§çº¿ç¨‹æ•°é‡ int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; // æ›´æ–°æ ‡è®°å€¼ workerAdded = true; &#125; &#125; finally &#123; // å…¨å±€é”é‡Šæ”¾ï¼Œæ³¨æ„å…¨å±€é”é‡Šæ”¾çš„æ—¶æœº mainLock.unlock(); &#125; // Workerçº¿ç¨‹åªæœ‰æ·»åŠ åˆ°Workeré›†åˆåæ‰èƒ½å¯åŠ¨çº¿ç¨‹ if (workerAdded) &#123; // å¯åŠ¨Workerä¸­çš„çº¿ç¨‹ï¼Œè¿™ä¸€æ­¥çš„æ„ä¹‰é‡å¤§ t.start(); // æ ‡è®°çº¿ç¨‹å¯åŠ¨æˆåŠŸ workerStarted = true; &#125; &#125; &#125; finally &#123; // çº¿ç¨‹åŠ å…¥çº¿ç¨‹æ± å¤±è´¥æˆ–å¯åŠ¨å¤±è´¥ï¼Œéœ€è¦æ¸…ç†å·¥ä½œ if (!workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; çº¿ç¨‹æ± é€šè¿‡ä¸Šè¿°æ–¹æ³•å¢åŠ çº¿ç¨‹ï¼Œè¯¥æ–¹æ³•ä»…å®Œæˆåˆ›å»ºçº¿ç¨‹å¹¶ä½¿å®ƒè¿è¡Œï¼Œæœ€åè¿”å›æ˜¯å¦æˆåŠŸã€‚è‡³äºæ˜¯å“ªç§æƒ…å†µä¸‹å¢åŠ çº¿ç¨‹ï¼Œè¯¥æ–¹æ³•å¹¶ä¸å…³å¿ƒã€‚ä¸‹å›¾æ˜¯æ–°å¢Workerçº¿ç¨‹çš„æµç¨‹å›¾ï¼š è¿˜éœ€è¦å¼ºè°ƒä¸€ç‚¹ï¼Œè¯¥æ–¹æ³•åªæ˜¯åˆ›å»ºå¹¶å¯åŠ¨çº¿ç¨‹ï¼Œçº¿ç¨‹è¿˜æ²¡æœ‰æ‰§è¡Œä»»åŠ¡ã€‚å†åˆ†ææ‰§è¡Œä»»åŠ¡é€»è¾‘ä¹‹å‰ï¼Œå…ˆæ¥çœ‹çœ‹åˆ›å»º Worker çš„å¼‚å¸¸æµç¨‹ï¼ŒaddWorkerFailed æ–¹æ³•ã€‚ 12345678910111213141516171819private void addWorkerFailed(Worker w) &#123; // è·å¾—å…¨å±€é” final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (w != null) // ä» workers ç¼“å­˜ä¸­ç§»é™¤å¯åŠ¨å¤±è´¥çš„ Worker workers.remove(w); // å‡å°‘çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°ï¼Œå› ä¸ºåœ¨æ­¤ä¹‹å‰é€’å¢äº† decrementWorkerCount(); // å°è¯•ç»ˆæ­¢çº¿ç¨‹æ±  tryTerminate(); &#125; finally &#123; mainLock.unlock(); &#125;&#125; æ–¹æ³•åéå¸¸ç›´è§‚ï¼Œå°±æ˜¯æ‰§è¡Œ addWorker å¤±è´¥çš„å¤„ç†æ–¹æ³•ã€‚è¯¥æ–¹æ³•ä¸»è¦åšäº†ä»¥ä¸‹å·¥ä½œï¼š ä» Worker ç¼“å­˜é›†åˆä¸­ç§»é™¤å¯åŠ¨å¤±è´¥çš„ Worker ä¾¿äº GC ã€‚ é€’å‡çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°ï¼Œåœ¨æ ¡éªŒæ˜¯å¦å…è®¸åˆ›å»º Worker æµç¨‹ä¸­é€’å¢äº†çº¿ç¨‹æ•°ï¼Œè¿™é‡Œéœ€è¦é€’å‡ã€‚ å°è¯•ç»ˆæ­¢çº¿ç¨‹æ± ï¼Œæ–°å¢çº¿ç¨‹å¤±è´¥çš„åŸå› å¯èƒ½æ˜¯çº¿ç¨‹æ± çŠ¶æ€å¤„äº[SHUTDOWN,TERMINATED]ï¼Œè¿™ç§æƒ…å†µä¸‹è¦å°è¯•æ›´æ–°çº¿ç¨‹æ± çš„çŠ¶æ€ä¸ºç»ˆæ­¢çŠ¶æ€ã€‚ æ‰§è¡Œä»»åŠ¡Worker ä¸­çš„çº¿ç¨‹å¯åŠ¨æˆåŠŸåï¼Œå…¶ run æ–¹æ³•ä¼šè°ƒç”¨ runWorker æ–¹æ³•ï¼š 1234567/** * Worker å®ç°äº† Runnable æ¥å£ï¼Œé‡å†™äº†run() æ–¹æ³•ã€‚ */public void run() &#123; // è¿™é‡Œè°ƒç”¨äº†å¤–éƒ¨ç±»çš„ runWorker æ–¹æ³• runWorker(this); &#125; runWorker æ–¹æ³•æ˜¯æ‰§è¡Œæäº¤ä»»åŠ¡å’Œé˜»å¡é˜Ÿåˆ—ä¸­ç­‰å¾…ä»»åŠ¡çš„æ ¸å¿ƒå®ç°ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬åˆ†æå®ƒçš„å…·ä½“å®ç°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475final void runWorker(Worker w) &#123; // å½“å‰çº¿ç¨‹ï¼Œå³ w ä¸­çš„çº¿ç¨‹ Thread wt = Thread.currentThread(); // è·å–è¯¥çº¿ç¨‹çš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œå¯èƒ½æ²¡æœ‰ã€‚å¦‚æœæœ‰çš„è¯ï¼Œä¼˜å…ˆæ‰§è¡Œè¯¥ä»»åŠ¡ã€‚ Runnable task = w.firstTask; w.firstTask = null; // å°† state å€¼ç”±ç”± -1 è®¾ç½®ä¸º 0ï¼Œè¿™æ ·å°±å¯ä»¥å…è®¸ä¸­æ–­äº† ã€‚ w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; // å¾ªç¯è°ƒç”¨getTask() æ–¹æ³•ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡å¹¶æ‰§è¡Œ while (task != null || (task = getTask()) != null) &#123; // ç”³è¯·Workeréé‡å…¥é”ï¼Œæ ‡å¿—ç€è‡ªå·±å¤„äºå·¥ä½œçŠ¶æ€ã€‚ w.lock(); /** * è¯¥ifåˆ¤æ–­ä¿è¯äº†ï¼šå¦‚æœçº¿ç¨‹æ± æ­£åœ¨åœæ­¢ï¼Œéœ€è¦ç¡®ä¿å½“å‰çº¿ç¨‹æ˜¯ä¸­æ–­çŠ¶æ€ï¼Œå¦åˆ™è¦ä¿è¯å½“å‰çº¿ç¨‹ä¸æ˜¯ä¸­æ–­çŠ¶æ€ã€‚ * * å‡ºç°ä»¥ä¸‹ä»»ä½•ä¸€ç§æƒ…å†µéƒ½éœ€è¦ä¸­æ–­çº¿ç¨‹ï¼š * 1 å¦‚æœçº¿ç¨‹æ± çŠ¶æ€å¤§äºç­‰äº STOPï¼Œå¹¶ä¸”å½“å‰çº¿ç¨‹æ²¡æœ‰è¢«ä¸­æ–­ * 2 å¦‚æœå½“å‰çº¿ç¨‹è¢«ä¸­æ–­äº†å¹¶ä¸”çº¿ç¨‹æ± çŠ¶æ€å¤§äºç­‰äº STOP çŠ¶æ€ï¼ˆæ¢å¤ä¸­æ–­æ ‡è¯†ï¼‰ * ä½¿ç”¨interrupted()æ–¹æ³•åˆ¤æ–­çº¿ç¨‹æ˜¯å¦è¢«ä¸­æ–­ï¼Œè¯¥æ–¹æ³•ä¼šæ¸…é™¤ä¸­æ–­æ ‡å¿—ä½ï¼Œæ—¢ç¡®ä¿äº†åœ¨çº¿ç¨‹RUNNINGæˆ–è€…SHUTDOWNçŠ¶æ€æ—¶çº¿ç¨‹æ˜¯éä¸­æ–­çŠ¶æ€çš„ï¼Œåˆæ”¯æŒäº†çº¿ç¨‹æ± æ˜¯STOPçŠ¶æ€ä¸‹çš„åˆ¤æ–­ */ if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) // ä¸­æ–­å½“å‰çº¿ç¨‹ï¼Œè¿›è¡Œä¸­æ–­æ ‡å¿—å¤ä½ wt.interrupt(); try &#123; // ThreadPoolExecutor çš„æ‰©å±•æ–¹æ³• beforeExecute(wt, task); Throwable thrown = null; try &#123; // æ‰§è¡Œç›®æ ‡ä»»åŠ¡,æ–¹æ³•çº§åˆ«è°ƒç”¨ã€‚ task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; // ThreadPoolExecutor çš„æ‰©å±•æ–¹æ³• afterExecute(task, thrown); &#125; &#125; finally &#123; // ç½®ç©º task,ä¸ºä¸‹ä¸€ä¸ªä»»åŠ¡åšå‡†å¤‡ task = null; // æ›´æ–°Workerçº¿ç¨‹å®Œæˆä»»åŠ¡æ•°é‡ w.completedTasks++; // é‡Šæ”¾ Workeréé‡å…¥é” w.unlock(); &#125; &#125; // while å¾ªç¯æ²¡æœ‰å‡ºç°å¼‚å¸¸ï¼ŒcompletedAbruptly æ‰ä¼šè¢«è®¾ç½®ä¸º false completedAbruptly = false; &#125; finally &#123; /** * çº¿ç¨‹é€€å‡º while å¾ªç¯åéœ€è¦è¿›è¡Œå›æ”¶ï¼Œå¯èƒ½æƒ…å†µå¦‚ä¸‹ï¼š * 1 ä»»åŠ¡é˜Ÿåˆ—ä¸­å·²ç»æ²¡æœ‰è¦æ‰§è¡Œçš„ä»»åŠ¡äº† * 2 ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹å‡ºç°å¼‚å¸¸ */ processWorkerExit(w, completedAbruptly); &#125; &#125; çº¿ç¨‹æ‰§è¡Œä»»åŠ¡çš„æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ‰§è¡Œä»»åŠ¡é€»è¾‘å·²ç»è¯¦ç»†æ³¨é‡Šï¼Œä¸‹é¢å¯¹è¯¥æ–¹æ³•ç®€è¦åˆ†æï¼š çº¿ç¨‹æ‰§è¡Œä»»åŠ¡æœ‰ä¸¤ä¸ªé€”å¾„ï¼Œé€šè¿‡å– Worker çš„ firstTask æˆ–è€…è°ƒç”¨ getTask æ–¹æ³•ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­å–å‡ºå¾…æ‰§è¡Œçš„ä»»åŠ¡ã€‚ çº¿ç¨‹å¤ç”¨å¾—ç›Šäºå¯¹çº¿ç¨‹çš„å°è£…ï¼Œå°è£…åçš„çº¿ç¨‹ä¸å†å±€é™äºæ‰§è¡Œå½“å‰ä»»åŠ¡ï¼Œè€Œæ˜¯whileå¾ªç¯ä¸æ–­åœ°é€šè¿‡getTask()æ–¹æ³•è·å–ä»»åŠ¡ï¼Œç„¶åæ‰§è¡Œä»»åŠ¡ï¼Œä»è€Œå®ç°äº†çº¿ç¨‹çš„å¤ç”¨ã€‚ çº¿ç¨‹åœ¨æ‰§è¡Œä»»åŠ¡å‰ä¼šå…ˆç”³è¯·å¯¹åº” Worker ç‹¬å é”ï¼Œæ ‡å¿—è‡ªå·±å¤„äºå·¥ä½œçŠ¶æ€ï¼Œä¸åº”è¯¥ä¸­æ–­è¯¥çº¿ç¨‹ï¼Œè¿™æ˜¯å¯¹çº¿ç¨‹å°è£…çš„å¥½å¤„ã€‚ å½“çº¿ç¨‹æ± çŠ¶æ€å¤§äºç­‰äº STOP çŠ¶æ€ï¼Œè¦ä¿è¯å½“å‰çº¿ç¨‹æ˜¯ä¸­æ–­çŠ¶æ€ï¼Œå¦åˆ™è¦ä¿è¯å½“å‰çº¿ç¨‹ä¸æ˜¯ä¸­æ–­çŠ¶æ€ã€‚ çº¿ç¨‹é€šè¿‡è°ƒç”¨ä»»åŠ¡çš„ run æ–¹æ³•æ¥æ‰§è¡Œå¯¹åº”çš„ä»»åŠ¡ï¼Œè€Œä¸æ˜¯å¯åŠ¨çº¿ç¨‹ï¼Œè¿™ä¸ªæ­£æ˜¯å‰æ–‡ç‰¹åˆ«è¯´æ˜çš„æ–¹æ³•çº§åˆ«è°ƒç”¨ã€‚ å½“ Worker å°è£…çš„çº¿ç¨‹é€€å‡ºå¾ªç¯åï¼Œæ‰§è¡Œ processWorkerExit() æ–¹æ³•å¯¹è¯¥çº¿ç¨‹è¿›è¡Œå›æ”¶ã€‚ å¯ä»¥é€šè¿‡é‡å†™ beforeExecute() å’Œ afterExecute() æ–¹æ³•æ¥å®ç° ThreadPoolExecutor çš„æ‰©å±•åŠŸèƒ½ã€‚ å†è°ˆçº¿ç¨‹å¤ç”¨çº¿ç¨‹æ± ä¼šä½¿ç”¨ä¸€å®šæ•°é‡çš„çº¿ç¨‹å»æ‰§è¡Œä»»åŠ¡ï¼Œé€šå¸¸çº¿ç¨‹æ•°é‡è¿œå°äºä»»åŠ¡æ•°é‡ï¼Œé’ˆå¯¹è¿™ç§æƒ…å†µçº¿ç¨‹æ± é€šè¿‡çº¿ç¨‹å¤ç”¨çš„æ–¹å¼è®©åŒä¸€ä¸ªçº¿ç¨‹å»æ‰§è¡Œä¸åŒçš„ä»»åŠ¡ã€‚æˆ‘ä»¬çŸ¥é“çº¿ç¨‹æ± æ˜¯å°†çº¿ç¨‹å’Œä»»åŠ¡è§£è€¦ï¼Œæ‘†è„±äº†ä¸€ä¸ªä»»åŠ¡å¿…é¡»ä¸€ä¸ªçº¿ç¨‹çš„é™åˆ¶ï¼Œè¿™ä¹Ÿæ˜¯çº¿ç¨‹å¤ç”¨çš„å¿…è¦æ¡ä»¶ã€‚çº¿ç¨‹æ± ä½¿ç”¨Workerå¯¹çº¿ç¨‹çš„å°è£…ï¼Œä¹Ÿå°±æ˜¯Workerçº¿ç¨‹ï¼Œçº¿ç¨‹å¯åŠ¨åä¼šå»æ‰§è¡Œä¸€ä¸ªå¾ªç¯ä»»åŠ¡ï¼Œè¯¥ä»»åŠ¡å¯ä»¥æ‰§è¡Œçº¿ç¨‹çš„é¦–ä¸ªä»»åŠ¡å’Œè½®è¯¢ä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼Œçº¿ç¨‹é€šè¿‡è°ƒç”¨ä»»åŠ¡çš„ run æ–¹æ³•å®ç°ä»»åŠ¡çš„æ‰§è¡Œã€‚ çº¿ç¨‹å¤ç”¨çš„é€»è¾‘ä¸»è¦åœ¨ runWorker æ–¹æ³•ä¸­ï¼Œè¯¥æ–¹æ³•æ˜¯ Worker ç±»çš„ run æ–¹æ³•ä¸­çš„é€»è¾‘ï¼ŒWorker ä¸­å°è£…çš„çº¿ç¨‹å¯åŠ¨åä¼šæ‰§è¡Œ Worker çš„ run æ–¹æ³•è¿›è€Œæ‰§è¡Œ runWorker æ–¹æ³•ã€‚æ•´ä¸ªé€»è¾‘ç®€åŒ–åçš„ä»£ç å¦‚ä¸‹ï¼š 12345678910111213runWorker(Worker w) &#123; // çº¿ç¨‹é¦–ä¸ªä»»åŠ¡ Runnable task = w.firstTask; // è½®è¯¢ä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ while (task != null || (task = getTask()) != null) &#123; try &#123; // çº¿ç¨‹æ‰§è¡Œä»»åŠ¡çš„ run æ–¹æ³•ï¼Œå³æ–¹æ³•çº§åˆ«çš„è°ƒç”¨ task.run(); &#125; finally &#123; task = null; &#125; &#125;&#125; çº¿ç¨‹å›æ”¶çº¿ç¨‹æ± ä¸­çº¿ç¨‹çš„é”€æ¯ä¾èµ–JVMè‡ªåŠ¨å›æ”¶ï¼ŒWorker çº¿ç¨‹ç»“æŸä»»åŠ¡æˆ–å¼‚å¸¸é€€å‡ºåï¼ŒWorker ä¼šä¸»åŠ¨æ¸…é™¤è‡ªèº«åœ¨çº¿ç¨‹æ± ä¸­çš„å¼•ç”¨ï¼Œè¿™æ„å‘³ç€çº¿ç¨‹æ± å¯ä»¥å›æ”¶è¯¥çº¿ç¨‹äº†ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; // çº¿ç¨‹æ‰§è¡Œä»»åŠ¡æŠ›å‡ºäº†å¼‚å¸¸ if (completedAbruptly) // å‡å°‘çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°é‡ decrementWorkerCount(); // è·å–å…¨å±€é” final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // ç´¯è®¡çº¿ç¨‹æ± å®Œæˆçš„ä»»åŠ¡æ•°é‡ completedTaskCount += w.completedTasks; // å°†çº¿ç¨‹å¼•ç”¨ç§»å‡ºçº¿ç¨‹æ±  workers.remove(w); &#125; finally &#123; // é‡Šæ”¾å…¨å±€é” mainLock.unlock(); &#125; // å°è¯•ç»ˆæ­¢çº¿ç¨‹æ±  tryTerminate(); int c = ctl.get(); // å¦‚æœçº¿ç¨‹æ± çŠ¶æ€å°äº STOP çŠ¶æ€ï¼Œè¯´æ˜è¿˜å¯ä»¥å¤„ç†ä»»åŠ¡ if (runStateLessThan(c, STOP)) &#123; // 1. å½“å‰çº¿ç¨‹å¤„ç†ä»»åŠ¡æ²¡æœ‰å‡ºç°å¼‚å¸¸ if (!completedAbruptly) &#123; // è·å–æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œå¦‚æœè®¾ç½®äº†å…è®¸å›æ”¶æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œåˆ™è¿”å› 0ï¼Œå¦åˆ™å–æ ¸å¿ƒçº¿ç¨‹æ•° int min = allowCoreThreadTimeOut ? 0 : corePoolSize; // 1.1 å¦‚æœ allowCoreThreadTimeOut=trueï¼Œå¹¶ä¸”ä»»åŠ¡é˜Ÿåˆ—ä¸­æœ‰ä»»åŠ¡ï¼Œè‡³å°‘ä¿ç•™ä¸€ä¸ªworkerçº¿ç¨‹ if (min == 0 &amp;&amp; !workQueue.isEmpty()) min = 1; // 1.2 å¦‚æœ allowCoreThreadTimeOut=falseï¼Œçº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°ä¸èƒ½å°‘äº corePoolSize // çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°å¤§äºç­‰äº min ï¼Œè¯´æ˜æ— éœ€åˆ›å»ºçº¿ç¨‹ã€‚ if (workerCountOf(c) &gt;= min) return; // replacement not needed &#125; // æ‰§è¡Œåˆ°è¿™é‡Œçš„å¯èƒ½æƒ…å†µï¼š // 1 çº¿ç¨‹æ± ä¸­æ²¡æœ‰çº¿ç¨‹æ‰§è¡Œä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼Œéœ€è¦åˆ›å»ºçº¿ç¨‹å–æ‰§è¡Œã€‚ï¼ˆæ ¸å¿ƒçº¿ç¨‹æ•°è®¾ç½®ä¸º 0 æˆ– å…è®¸å›æ”¶æ ¸å¿ƒçº¿ç¨‹ï¼‰ // 2 çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°å°äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œéœ€è¦åˆ›å»ºçº¿ç¨‹è¡¥å……æ ¸å¿ƒçº¿ç¨‹æ•°ã€‚ï¼ˆæ ¸å¿ƒçº¿ç¨‹æ•° &gt; 0ï¼‰ // 3 å½“å‰çº¿ç¨‹æ‰§è¡Œä»»åŠ¡è¿‡ç¨‹å‡ºç°å¼‚å¸¸ï¼Œè€Œä¸”å½“å‰çº¿ç¨‹è¢«å›æ”¶äº†ï¼Œä¸ºäº†ç¡®ä¿æœ‰çº¿ç¨‹æ‰§è¡Œä»»åŠ¡ï¼Œè¿™é‡Œéœ€è¦åˆ›å»ºçº¿ç¨‹ã€‚ addWorker(null, false); &#125; &#125; çº¿ç¨‹å›æ”¶æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œçº¿ç¨‹é”€æ¯å·¥ä½œä¸æ˜¯åªæœ‰ processWorkerExit æ–¹æ³•æ‰èƒ½å®Œæˆï¼Œå‰æ–‡ä»‹ç»çš„æ–°å¢Workerçº¿ç¨‹é€»è¾‘ä¸­å¯¹å¼‚å¸¸æµå¤„ç†çš„ addWorkerFailed æ–¹æ³•ä¹Ÿå¯ä»¥åšåˆ°ã€‚è¿™ä¸¤è€…é”€æ¯çº¿ç¨‹çš„æ—¶æœºä¸åŒï¼Œå‰è€…æ˜¯çº¿ç¨‹æ‰§è¡Œä»»åŠ¡çš„é€»è¾‘ä¸­é”€æ¯ï¼Œåè€…æ˜¯åˆ›å»ºçº¿ç¨‹åå¯åŠ¨å¤±è´¥çš„å¤„ç†ã€‚ ä¸Šè¿° processWorkerExit æ–¹æ³•åœ¨å°†Workerçº¿ç¨‹ç§»é™¤çº¿ç¨‹æ± åä¹Ÿå°±å®Œæˆäº†çº¿ç¨‹çš„å›æ”¶å·¥ä½œï¼Œä½†ç”±äºæ‰§è¡Œè¯¥æ–¹æ³•çš„åŸå› å¾ˆå¤šï¼Œçº¿ç¨‹æ­£å¸¸é€€å‡ºgetTaskæ–¹æ³•æˆ–è€…æ‰§è¡Œä»»åŠ¡å¼‚å¸¸éƒ½ä¼šæ‰§è¡Œè¯¥æ–¹æ³•ï¼Œå› æ­¤åœ¨è¯¥æ–¹æ³•ä¸­éœ€è¦é¢å¤–å®Œæˆä¸¤ä¸ªå·¥ä½œã€‚ä¸€æ˜¯ä½¿çº¿ç¨‹æ± è‡ªé€‚åº”å½“å‰çŠ¶æ€ï¼Œå¦ä¸€ä¸ªæ˜¯æ ¹æ®éœ€è¦åˆ›å»ºçº¿ç¨‹ã€‚ è‡³æ­¤ï¼ŒprocessWorkerExit æ‰§è¡Œå®Œä¹‹åWorkerçº¿ç¨‹è¢«é”€æ¯ï¼Œè¯¥çº¿ç¨‹çš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸç»“æŸã€‚ä¸‹é¢å¯¹æ•´ä¸ªè¿‡ç¨‹ä½¿ç”¨æµç¨‹å›¾çš„å½¢å¼è¿›è¡Œæ€»ç»“ï¼Œæµç¨‹å›¾å¦‚ä¸‹ï¼š å…³é—­çº¿ç¨‹æ± è°ƒç”¨çº¿ç¨‹æ± çš„ shutdown æˆ– shutdownNow æ–¹æ³•æ¥å…³é—­çº¿ç¨‹æ± ï¼Œä¸¤è€…çš„åŸç†æœ‰ç‚¹å·®å¼‚ï¼Œä¸‹é¢æˆ‘ä»¬åˆ†åˆ«è¯´æ˜è¿™ä¸¤ä¸ªæ–¹æ³•ã€‚ shutdown12345678910111213141516171819public void shutdown() &#123; // å…¨å±€é” final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); // è®¾ç½®çº¿ç¨‹æ± çŠ¶æ€ä¸º SHUTDOWN advanceRunState(SHUTDOWN); // å°è¯•ä¸­æ–­çº¿ç¨‹æ± æ‰€æœ‰ä¸­é—²ç½®çš„çº¿ç¨‹ interruptIdleWorkers(); // hook onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; // å°è¯•ç»ˆæ­¢çº¿ç¨‹æ±  tryTerminate(); &#125; shutdown() æ–¹æ³•å¯ä»¥å®‰å…¨åœ°å…³é—­ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œä½“ç°åœ¨ä¸‹é¢å‡ ä¸ªæ–¹é¢ï¼š åªæ˜¯å°†çº¿ç¨‹æ± çš„çŠ¶æ€ç½®ä¸º SHUTDOWN ï¼Œè¿™æ„å‘³ç€çº¿ç¨‹æ± ä¸èƒ½æ¥æ”¶æ–°çš„ä»»åŠ¡ï¼Œå†æœ‰æ–°çš„ä»»åŠ¡è¢«æäº¤åˆ™æ ¹æ®æ‹’ç»ç­–ç•¥è¿›è¡Œå¤„ç†ã€‚ ä¼šæ‰§è¡Œå®Œæ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡å’Œé˜Ÿåˆ—ä¸­ç­‰å¾…çš„ä»»åŠ¡ï¼Œä»»åŠ¡å…¨éƒ¨ç»“æŸåæ‰ä¼šå½»åº•å…³é—­çº¿ç¨‹æ± ã€‚ å°è¯•ä¸­æ–­çº¿ç¨‹æ± ä¸­æ‰€æœ‰é—²ç½®çš„çº¿ç¨‹ã€‚ è°ƒç”¨tryTerminateå°è¯•ç»ˆæ­¢çº¿ç¨‹æ± ï¼Œç”¨äºå°†çº¿ç¨‹æ± çš„çŠ¶æ€æ›´æ–°ä¸º TERMINATED ã€‚ shutdownNow123456789101112131415161718192021public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; // å…¨å±€é” final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); // è®¾ç½®çº¿ç¨‹æ± çŠ¶æ€ä¸º STOP advanceRunState(STOP); // å°è¯•ä¸­æ–­çº¿ç¨‹æ± ä¸­æ‰€æœ‰å¯åŠ¨çŠ¶æ€çš„çº¿ç¨‹ interruptWorkers(); // å°†é˜»å¡é˜Ÿåˆ—ä¸­æ­£åœ¨ç­‰å¾…çš„æ‰€æœ‰ä»»åŠ¡è¿›è¡Œå¤‡ä»½ï¼Œç„¶åæ¸…ç©ºé˜»å¡é˜Ÿåˆ—å¹¶è¿”å›å¤‡ä»½ã€‚æœ‰äº†è¿™ä¸ªå¤‡ä»½ï¼Œå¯ä»¥æ ¹æ®éœ€è¦åšè¡¥æ•‘æªæ–½ã€‚ tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; // å°è¯•ç»ˆæ­¢çº¿ç¨‹æ±  tryTerminate(); return tasks; &#125; shutdownNow() æ–¹æ³•è¡¨ç¤ºç«‹å³å…³é—­çº¿ç¨‹æ± ï¼Œå·¥ä½œå¦‚ä¸‹ï¼š å°†çº¿ç¨‹æ± çŠ¶æ€ç½®ä¸º STOP çŠ¶æ€ã€‚ ä¸­æ–­æ‰€æœ‰Workerçº¿ç¨‹ï¼ŒåŒ…æ‹¬ç©ºé—²å’Œéç©ºé—²ã€‚ æ¸…ç©ºé˜»å¡é˜Ÿåˆ—å¹¶è¿”å›ç­‰å¾…æ‰§è¡Œçš„ä»»åŠ¡å¤‡ä»½ã€‚ è°ƒç”¨tryTerminateå°è¯•ç»ˆæ­¢çº¿ç¨‹æ± ï¼Œç”¨äºå°†çº¿ç¨‹æ± çš„çŠ¶æ€æ›´æ–°ä¸º TERMINATED ã€‚ tryTerminate()å¯¹äº tryTerminate() æ–¹æ³•çš„è°ƒç”¨ï¼Œå‰æ–‡ä¸­çš„æ–°å¢çº¿ç¨‹å¤±è´¥é€»è¾‘ã€çº¿ç¨‹é€€å‡ºwhileé€»è¾‘ä»¥åŠä¸¤ç§å…³é—­çº¿ç¨‹æ± çš„æ–¹æ³•éƒ½ä¼šè°ƒç”¨äº†è¯¥æ–¹æ³•ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹è¿™ä¸ªæ–¹æ³•çš„å…·ä½“é€»è¾‘ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final void tryTerminate() &#123; for (; ; ) &#123; // çº¿ç¨‹æ± çŠ¶æ€ç  int c = ctl.get(); // ä»¥ä¸‹å‡ ç§æƒ…å†µä¸èƒ½ç»ˆæ­¢çº¿ç¨‹æ± ï¼Œç›´æ¥è¿”å›ï¼ˆSTOP çŠ¶æ€å¯ä¸ä¼šç›´æ¥è¿”å›ï¼‰ //1. çº¿ç¨‹æ± æ˜¯è¿è¡ŒçŠ¶æ€ RUNNING //2. å¤§äºç­‰äº TIDYING çŠ¶æ€ï¼Œæ­¤æ—¶çº¿ç¨‹æ± ä¸­å·²ç»æ²¡æœ‰æ­£åœ¨è¿è¡Œçš„çº¿ç¨‹äº† //3. SHUTDOWN çŠ¶æ€ä¸”é˜»å¡é˜Ÿåˆ—éç©ºï¼Œè¿™ç§æƒ…å†µéœ€è¦æ‰§è¡Œå®Œä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty())) return; // æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜å·²ç»å…·å¤‡ç»ˆæ­¢çº¿ç¨‹æ± çš„æ¡ä»¶ï¼Œåªå·®çº¿ç¨‹å›æ”¶äº†ã€‚ // çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°é‡ä¸ä¸º 0ï¼Œå‘ä»»æ„ç©ºé—²çº¿ç¨‹å‘å‡ºä¸­æ–­ä¿¡å·ï¼Œæ‰€æœ‰è¢«é˜»å¡çš„çº¿ç¨‹ï¼ˆæ‰§è¡Œpoll/takeï¼‰æœ€ç»ˆéƒ½ä¼šè¢«ä¸€ä¸ªä¸ªå”¤é†’ï¼Œå›æ”¶ã€‚ if (workerCountOf(c) != 0) &#123; // Eligible to terminate // è¿™é‡Œæ—¢ä¸æ˜¯ä¸­æ–­æ‰€æœ‰çº¿ç¨‹ï¼Œä¹Ÿä¸æ˜¯ä¸­æ–­æ‰€æœ‰ç©ºé—²çº¿ç¨‹ï¼Œè€Œæ˜¯ä¸­æ–­ä»»æ„ä¸€ä¸ªç©ºé—²çº¿ç¨‹ï¼ŒåŸå› å¦‚ä¸‹ï¼š // 1. tryTerminate() æ–¹æ³•å¤šå¤„è¢«è°ƒç”¨ï¼Œéœ€è¦ä¸­æ–­çº¿ç¨‹é€»è¾‘åœ¨ä¸Šå±‚å·²ç»è¿›è¡Œäº†å¤„ç†ï¼Œå¦‚ shutdown æ–¹æ³•è°ƒç”¨æ—¶ä¼šä¸­æ–­æ‰€æœ‰ç©ºé—²çº¿ç¨‹ // 2. interruptIdleWorkers(ONLY_ONE) æ–¹æ³•ç”¨åœ¨ tryTerminate() æ–¹æ³•ä¸­ä¸»è¦ä¸ºäº†å”¤é†’ getTask()æ–¹æ³•ä¸­å­˜åœ¨æ‰§è¡ŒworkQueue.take()ç­‰å¾…çš„çº¿ç¨‹ï¼Œé˜²æ­¢ä¸€ç›´ç­‰å¾…é€ æˆçº¿ç¨‹æ— æ³•å›æ”¶ã€‚ // å³ä½¿æœ‰å¤šä¸ªçº¿ç¨‹é˜»å¡ç­‰å¾…ï¼Œå”¤é†’ä»»æ„ä¸€ä¸ªä¹Ÿè¶³å¤Ÿäº†ï¼Œè¢«å”¤é†’çš„çº¿ç¨‹åœ¨é€€å‡ºwhileå¾ªç¯åä¼šå†æ¬¡è°ƒç”¨tryTerminate()æ–¹æ³•ï¼Œç»§ç»­ä¸­æ–­é˜»å¡ç­‰å¾…çº¿ç¨‹ã€‚æ­¤å¤–çº¿ç¨‹é€€å‡ºåè¿›å…¥åˆ°processWorkerExit()æ–¹æ³•ä¸­ // ä¼šè¦ç”³è¯·å…¨å±€é”çš„ï¼Œå¦‚æœå…¨éƒ¨å”¤é†’ä¼šå‡ºç°ç«äº‰é”çš„æƒ…å†µã€‚ interruptIdleWorkers(ONLY_ONE); return; &#125; // å…¨å±€é” final ReentrantLock mainLock = this.mainLock; // ç»ˆæ­¢çº¿ç¨‹æ± æ—¶åŠ å…¨å±€é”ï¼Œä¿è¯CASæ‰§è¡ŒæˆåŠŸï¼Œå³çº¿ç¨‹æ± çŠ¶æ€ä¾æ¬¡æ›´æ–°ä¸º TIDYING å’Œ TERMINATED ã€‚ // è¿™é‡Œå¯èƒ½å‘ç”Ÿå¹¶å‘é—®é¢˜ï¼Œå¦‚ä¸¤ä¸ªçº¿ç¨‹éƒ½é€šè¿‡äº† workerCountOf(c) != 0 æ¡ä»¶ï¼Œæ‰§è¡Œåˆ°è¿™é‡Œå°±éœ€è¦åŠ é”ã€‚ mainLock.lock(); try &#123; // è®¾ç½®çº¿ç¨‹æ± çŠ¶æ€ç ä¸º TIDYING if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; // çŠ¶æ€è®¾ç½®æˆåŠŸåæ‰§è¡Œ terminated() é’©å­æ–¹æ³• terminated(); &#125; finally &#123; // è®¾ç½®çº¿ç¨‹æ± çŠ¶æ€ç ä¸º TERMINATED ç»ˆæ­¢çŠ¶æ€ ctl.set(ctlOf(TERMINATED, 0)); termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // else retry on failed CAS &#125; &#125; tryTerminate() æ–¹æ³•ä¸»è¦æ ¹æ®çº¿ç¨‹æ± çŠ¶æ€åˆ¤æ–­æ˜¯å¦ç»ˆæ­¢çº¿ç¨‹æ± ï¼Œä¸‹é¢è¿›è¡Œç®€å•æ€»ç»“ï¼š åˆ¤æ–­çº¿ç¨‹æ± æ˜¯å¦å¯ä»¥ç»ˆæ­¢ï¼ŒåŸåˆ™æ˜¯çº¿ç¨‹æ± å¤„äºå…³é—­çŠ¶æ€ã€é˜Ÿåˆ—ä¸­æ²¡æœ‰ä»»åŠ¡çš„æƒ…å†µä¸‹å¯ä»¥ç»ˆæ­¢ã€‚ interruptIdleWorkers()æ–¹æ³•çš„æ‰§è¡Œè¡¨ç¤ºçº¿ç¨‹æ± å…·å¤‡ç»ˆæ­¢æ¡ä»¶ï¼Œå‘ä»»æ„ç©ºé—²çº¿ç¨‹å‘é€ä¸­æ–­ä¿¡å·é˜²æ­¢ getTask æ–¹æ³•ä¸­å­˜åœ¨æ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ workQueue.take()æ—¶ä¸€ç›´é˜»å¡ï¼Œå¯¼è‡´çº¿ç¨‹æ— æ³•å›æ”¶ã€‚ ç¬¦åˆç»ˆæ­¢çº¿ç¨‹æ± çš„æ¡ä»¶æ—¶ï¼Œå…ˆè·å–å…¨å±€é”ï¼Œç„¶åå…ˆå°†çº¿ç¨‹æ± çŠ¶æ€ç½®ä¸º TIDYING çŠ¶æ€ï¼Œè®¾ç½®æˆåŠŸåä¼šæ‰§è¡Œ terminated() é’©å­æ–¹æ³•ï¼Œæœ€åå°†çº¿ç¨‹æ± çŠ¶æ€è®¾ç½®ä¸º TERMINATED çŠ¶æ€ï¼Œå®Œæˆçº¿ç¨‹æ± çŠ¶æ€æ›´æ–°åé‡Šæ”¾å…¨å±€é”ã€‚ ä¸‹é¢æˆ‘ä»¬æ¥ç®€å•åˆ†æä¸€ä¸‹interruptIdleWorkersæ–¹æ³•ã€‚ 12345678910111213141516171819202122232425262728293031323334+--- ThreadPoolExecutor private void interruptIdleWorkers() &#123; interruptIdleWorkers(false); &#125; /** * ä¸­æ–­æ‰€æœ‰é—²ç½®çš„Worker * * @param onlyOne æ˜¯å¦ä»…ä¸­æ–­ä¸€ä¸ª */ private void interruptIdleWorkers(boolean onlyOne) &#123; final ReentrantLock mainLock = this.mainLock; // å…¨å±€é”ï¼Œæ¶‰åŠåˆ° workers æ“ä½œçº¿ç¨‹æ± éƒ½ä¼šåŠ è¯¥é” mainLock.lock(); try &#123; // éå† workers ï¼Œå¯¹æ¯ä¸ªéä¸­æ–­çº¿ç¨‹è¿›è¡Œä¸­æ–­æ“ä½œã€‚ for (Worker w : workers) &#123; Thread t = w.thread; // å¦‚æœçº¿ç¨‹éä¸­æ–­çŠ¶æ€ï¼Œä¸”èƒ½ tryLock() æˆåŠŸï¼Œè¯´æ˜è¯¥çº¿ç¨‹é—²ç½®ï¼Œéœ€è¦è¿›è¡Œä¸­æ–­ if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; w.unlock(); &#125; &#125; if (onlyOne) break; &#125; &#125; finally &#123; mainLock.unlock(); &#125; &#125; å‰æ–‡ä¹Ÿè¿›è¡Œäº†è¯´æ˜ï¼ŒWorker ç»§æ‰¿äº†AQSï¼Œåœ¨Workerçº¿ç¨‹å¤„ç†ä»»åŠ¡æ—¶ä¼šç”³è¯·Workerç‹¬å é”ï¼ŒinterruptIdleWorkers åœ¨è¿›è¡Œä¸­æ–­æ—¶ä¼šä½¿ç”¨ tryLock() æ¥åˆ¤æ–­è¯¥Workerçº¿ç¨‹æ˜¯å¦æ­£åœ¨å¤„ç†ä»»åŠ¡ï¼Œå¦‚æœ tryLock() è¿”å›trueï¼Œè¯´æ˜è¯¥Workerçº¿ç¨‹å¤„äºç©ºé—²çŠ¶æ€ï¼Œå¯ä»¥è¢«ä¸­æ–­ã€‚ æ³¨æ„äº‹é¡¹ï¼š çº¿ç¨‹æ± ä¸­å¤šå¤„æ‰§è¡Œ tryTerminate æ–¹æ³•çš„ç›®çš„æ˜¯å°†ç¬¦åˆæ¡ä»¶çš„çº¿ç¨‹æ± ç»ˆæ­¢ï¼Œå‰æ–‡ä¹Ÿæåˆ°çº¿ç¨‹æ± çš„çŠ¶æ€æ˜¯å†…éƒ¨è‡ªè¡Œç»´æŠ¤çš„ï¼Œå¹¶éäººä¸ºè®¾ç½®ã€‚å¦‚ç”¨æˆ·æ‰§è¡Œ shutdown å’Œ shutdownNow æ–¹æ³•åªæ˜¯å°†çº¿ç¨‹æ± çš„çŠ¶æ€è®¾ç½®ä¸º SHUTDOWN å’Œ STOP ï¼Œåç»­çš„ TIDYING å’Œ TERMINATED çŠ¶æ€çš„è®¾ç½®å°±åœ¨äºæ­¤ã€‚ tryTerminate æ–¹æ³•ä¸­çš„ interruptIdleWorkers(ONLY_ONE) çš„ä½œç”¨æ˜¯é˜²æ­¢çº¿ç¨‹æ± åœ¨ç»ˆæ­¢çš„è¿‡ç¨‹ä¸­ getTask æ–¹æ³•ä¸­å­˜åœ¨æ‰§è¡Œ workQueue.take() é˜»å¡çš„çº¿ç¨‹ï¼Œå› ä¸ºæ­¤æ—¶çº¿ç¨‹æ± ä¸å…è®¸å†æœ‰æ–°çš„ä»»åŠ¡æ·»åŠ åˆ°é˜»å¡é˜Ÿåˆ—ä¸­ï¼Œè¿™æ ·ä¸€æ¥çº¿ç¨‹å°†ä¸€ç›´é˜»å¡ä¸‹å»ï¼Œçº¿ç¨‹æ± æ°¸è¿œéƒ½ç»ˆæ­¢ä¸äº†ã€‚ çº¿ç¨‹æ± ä¸­è™½ç„¶å¤šå¤„ä½¿ç”¨ä¸­æ–­æ¥æœŸæœ›ä¸­æ–­ä»»åŠ¡çš„æ‰§è¡Œï¼Œä½†ç”±äº Java ä¸­ä¸æ¨èå¼ºè¡Œåœæ­¢çº¿ç¨‹çš„æœºåˆ¶çš„é™åˆ¶ï¼Œå› ä¸ºå¼ºåˆ¶çš„è®©ä¸€ä¸ªçº¿ç¨‹è¢«åŠ¨çš„é€€å‡ºæ˜¯å¾ˆä¸å®‰å…¨çš„ï¼Œå†…éƒ¨çš„æ•°æ®ä¸ä¸€è‡´ä¼šå¯¹ç¨‹åºé€ æˆä¸å¯é¢„çŸ¥çš„åæœã€‚å³ä½¿è°ƒç”¨äº† shutdownNow æ–¹æ³•ï¼Œå¦‚æœè¢«ä¸­æ–­çš„çº¿ç¨‹å¯¹äºä¸­æ–­ä¿¡å·ä¸æ•æ„Ÿï¼Œé‚£ä¹ˆä¾ç„¶æœ‰å¯èƒ½å¯¼è‡´ä»»åŠ¡ä¸ä¼šåœæ­¢ã€‚ çº¿ç¨‹æ± é…ç½®çº¿ç¨‹æ± å¤ªå¤§æˆ–å¤ªå°éƒ½ä¼šå¯¼è‡´éº»çƒ¦ï¼Œé€‰æ‹©ä¸€ä¸ªåˆé€‚çš„çº¿ç¨‹æ± æ˜¯éå¸¸æœ‰å¿…è¦çš„ã€‚è°ƒæ•´çº¿ç¨‹æ± ä¸­çš„æ•°é‡æ˜¯ä¸ºäº†å……åˆ†å¹¶åˆç†åœ°ä½¿ç”¨ CPU å’Œå†…å­˜èµ„æºï¼Œä»è€Œæœ€å¤§é™åº¦åœ°æé«˜ç¨‹åºæ€§èƒ½ã€‚é€šå¸¸æˆ‘ä»¬éœ€è¦æ ¹æ®ä»»åŠ¡æ‰§è¡Œçš„æ€§è´¨æ¥é€‰æ‹©å¯¹åº”çš„ç­–ç•¥ã€‚ CPU å¯†é›†å‹ä»»åŠ¡å¦‚æœä»»åŠ¡ä¸»è¦è¿›è¡Œå¤§é‡å¤æ‚çš„è®¡ç®—ï¼Œä¾‹å¦‚åŠ å¯†ã€è§£å¯†ã€å‹ç¼©ç­‰ï¼Œé‚£ä¹ˆæ„å‘³ç€ CPU çš„å¤„ç†èƒ½åŠ›æ˜¯ç¨€ç¼ºçš„èµ„æºï¼Œåº”å½“åˆ†é…è¾ƒå°‘çš„çº¿ç¨‹ï¼Œé€šå¸¸æŒ‰ç…§ CPU æ ¸æ•° æˆ–è€… CPU æ ¸æ•° + 1 è¿›è¡Œè®¾ç½®ã€‚ è®¡ç®—ä»»åŠ¡ä¼šå ç”¨å¤§é‡çš„ CPU èµ„æºï¼ŒCPU çš„æ¯ä¸ªæ ¸å·¥ä½œåŸºæœ¬éƒ½æ˜¯é«˜è´Ÿè·çš„ï¼Œå¦‚æœè®¾ç½®è¿‡å¤šçš„çº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½ä¼šå°è¯•æŠ¢å  CPU èµ„æºï¼Œè¿™å°±é€ æˆäº†ä¸å¿…è¦çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼ˆCPUå¹¶æ²¡æœ‰å¤ªå¤šç©ºé—²ï¼‰ï¼Œæ€§èƒ½åè€Œç”±äºçº¿ç¨‹æ•°é‡è¿‡å¤šå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚ IO å¯†é›†å‹ä»»åŠ¡I/O æ“ä½œæ¯”è¾ƒå¤šçš„ä»»åŠ¡ï¼Œå¦‚æ•°æ®åº“æ“ä½œã€æ–‡ä»¶è¯»å†™ã€ç½‘ç»œé€šä¿¡ç­‰ï¼Œä¸€èˆ¬ä¸ä¼šæ¶ˆè€—å¤ªå¤š CPU èµ„æºï¼Œä½†æ˜¯æ™®ééœ€è¦è¾ƒé•¿æ—¶é—´çš„ç­‰å¾…ï¼Œå¯¹äºè¿™ç±»ä»»åŠ¡å¯ä»¥é…ç½®é€‚å½“å¤šçš„çº¿ç¨‹ï¼Œå¦‚ CPU æ ¸æ•° * 2 ã€‚ç”±äº IO è¯»å†™é€Ÿåº¦ç›¸æ¯”äº CPU çš„é€Ÿåº¦æ˜¯æ¯”è¾ƒæ…¢çš„ï¼Œè®¾ç½®è¿‡å°‘çš„çº¿ç¨‹æ•°æ˜¯ä¸èƒ½å……åˆ†åˆ©ç”¨ CPU èµ„æºã€‚ åˆé€‚çº¿ç¨‹æ•°Brain Goetz æ¨èçš„è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼š çº¿ç¨‹æ•° = CPUæ ¸æ•° Ã— ç›®æ ‡CPUåˆ©ç”¨ç‡ Ã—ï¼ˆ1 + å¹³å‡ç­‰å¾…æ—¶é—´/å¹³å‡å·¥ä½œæ—¶é—´ï¼‰ é€šè¿‡ä¸Šé¢çš„å…¬å¼å¯ä»¥å¤§è‡´è®¡ç®—å‡ºä¸€ä¸ªåˆç†çš„çº¿ç¨‹æ•°ï¼ˆæ ¸å¿ƒçº¿ç¨‹æ•°å’Œæœ€å¤§çº¿ç¨‹æ•°ç»Ÿç§°ï¼‰ã€‚å¦‚æœä»»åŠ¡å¹³å‡ç­‰å¾…æ—¶é—´é•¿åˆ™çº¿ç¨‹æ•°å°±åº”è¯¥å¤šï¼Œå¯¹åº”äº IO å¯†é›†å‹ä»»åŠ¡ã€‚å¦‚æœå¹³å‡å·¥ä½œæ—¶é—´é•¿åˆ™çº¿ç¨‹æ•°å°±åº”è¯¥å°‘ï¼Œå¯¹åº”äº CPU å¯†é›†å‹ä»»åŠ¡ã€‚ çº¿ç¨‹æ•°å¤ªå°‘å¯èƒ½ä¼šä½¿å¾—ç¨‹åºæ•´ä½“æ€§èƒ½é™ä½ï¼Œçº¿ç¨‹æ•°å¤ªå¤šå¯èƒ½ä¼šæ¶ˆè€—å†…å­˜èµ„æºä»¥åŠé€ æˆä¸å¿…è¦çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚æƒ³ç”¨å‡†ç¡®å®šåˆ¶çº¿ç¨‹æ± éœ€è¦åšçš„å·¥ä½œå¾ˆå¤šï¼Œé™¤äº†è€ƒè™‘çº¿ç¨‹æ•°è¿˜å¯ä»¥åˆç†ä½¿ç”¨çº¿ç¨‹æ± çš„é˜»å¡é˜Ÿåˆ—å®ç°ä»»åŠ¡çš„è°ƒåº¦ï¼Œè¿˜å¯ä»¥æ ¹æ®ä¸šåŠ¡ç­‰çº¬åº¦å®ç°çº¿ç¨‹æ± éš”ç¦»ã€‚ çº¿ç¨‹æ± ç›‘æ§çº¿ç¨‹æ± æä¾›äº†ä¸€äº›ç”¨äºè·å–å±æ€§çš„æ–¹æ³•ï¼Œè¿™äº›å±æ€§å¯ä»¥ç”¨æ¥å¯¹çº¿ç¨‹æ± è¿›è¡Œç›‘æ§ã€‚ çº¿ç¨‹æ± è¿˜æä¾›äº†ä¸€äº›ç”¨äºè®¾ç½®æ ¸å¿ƒå±æ€§çš„æ–¹æ³•ï¼Œä½¿ç”¨æ–¹å¯ä»¥é€šè¿‡è¿™äº›æ–¹æ³•åŠ¨æ€è®¾ç½®çº¿ç¨‹æ± çš„æ ¸å¿ƒç­–ç•¥ï¼Œçº¿ç¨‹æ± å†…éƒ¨ä¼šå¤„ç†å¥½å½“å‰çŠ¶æ€å¹¶åšåˆ°å¹³æ»‘ä¿®æ”¹ã€‚ åŠ¨æ€è®¾ç½®æ ¸å¿ƒçº¿ç¨‹æ•°123456789101112131415161718192021222324252627+--- ThreadPoolExecutor public void setCorePoolSize(int corePoolSize) &#123; if (corePoolSize &lt; 0) throw new IllegalArgumentException(); // è®¡ç®—æ ¸å¿ƒçº¿ç¨‹æ•°å˜åŒ–å€¼ int delta = corePoolSize - this.corePoolSize; // è¦†ç›–åŸæ¥çš„corePoolSize this.corePoolSize = corePoolSize; //çº¿ç¨‹æ± çš„çº¿ç¨‹æ•°å¤§äºå˜æ›´çš„æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œè¯´æ˜æœ‰å¤šä½™çš„workerçº¿ç¨‹ï¼Œæ­¤æ—¶ä¼šå‘ç©ºé—²çš„workerçº¿ç¨‹å‘èµ·ä¸­æ–­è¯·æ±‚ä»¥å®ç°å›æ”¶ if (workerCountOf(ctl.get()) &gt; corePoolSize) interruptIdleWorkers(); // æ ¸å¿ƒçº¿ç¨‹æ•°å¤§äºåŸæ¥å€¼ï¼Œå°è¯•å¢åŠ æ ¸å¿ƒçº¿ç¨‹ else if (delta &gt; 0) &#123; // å– ä»»åŠ¡æ•°å’Œ delta ä¸¤è€…çš„æœ€å°å€¼ int k = Math.min(delta, workQueue.size()); // é¢„å…ˆåˆ›å»ºè¶³å¤Ÿå¤šçš„æ–°Workerä»¥è¾¾åˆ°æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œå¹¶å¤„ç†é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ã€‚é˜Ÿåˆ—ç©ºäº†åˆ™åœæ­¢ while (k-- &gt; 0 &amp;&amp; addWorker(null, true)) &#123; if (workQueue.isEmpty()) break; &#125; &#125; &#125; åŠ¨æ€è®¾ç½®æœ€å¤§çº¿ç¨‹æ•°123456789101112+--- ThreadPoolExecutor public void setMaximumPoolSize(int maximumPoolSize) &#123; if (maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize) throw new IllegalArgumentException(); // è¦†ç›–åŸæ¥çš„ maximumPoolSize this.maximumPoolSize = maximumPoolSize; // å¦‚æœæ˜¯è®¾ç½®å°äº†çš„è¯ï¼Œæ­¤æ—¶ä¼šå‘ç©ºé—²çš„workerçº¿ç¨‹å‘èµ·ä¸­æ–­è¯·æ±‚ä»¥å®ç°å›æ”¶ if (workerCountOf(ctl.get()) &gt; maximumPoolSize) interruptIdleWorkers(); &#125; åŠ¨æ€è®¾ç½®ç©ºé—²æ—¶é—´1234567891011121314151617+--- ThreadPoolExecutor public void setKeepAliveTime(long time, TimeUnit unit) &#123; if (time &lt; 0) throw new IllegalArgumentException(); if (time == 0 &amp;&amp; allowsCoreThreadTimeOut()) throw new IllegalArgumentException(\"Core threads must have nonzero keep alive times\"); // è®¡ç®—è¶…æ—¶æ—¶é—´ long keepAliveTime = unit.toNanos(time); // è®¡ç®—å·®å€¼ long delta = keepAliveTime - this.keepAliveTime; // è¦†ç›–åŸæ¥çš„ keepAliveTime this.keepAliveTime = keepAliveTime; // å¦‚æœæ—¶é—´è®¾ç½®æ¯”åŸæ¥å°ï¼Œåˆ™å‘ç©ºé—²çš„workerçº¿ç¨‹å‘èµ·ä¸­æ–­è¯·æ±‚ä»¥å®ç°å›æ”¶ if (delta &lt; 0) interruptIdleWorkers(); &#125; å…è®¸æ ¸å¿ƒçº¿ç¨‹è¶…æ—¶å›æ”¶12345678910111213+--- ThreadPoolExecutor public void allowCoreThreadTimeOut(boolean value) &#123; // æ ¸å¿ƒçº¿ç¨‹å¿…é¡»è¦æœ‰ä¿æ´»æ—¶é—´ if (value &amp;&amp; keepAliveTime &lt;= 0) throw new IllegalArgumentException(\"Core threads must have nonzero keep alive times\"); if (value != allowCoreThreadTimeOut) &#123; allowCoreThreadTimeOut = value; // å…è®¸å›æ”¶åˆ™ç«‹å³ä¸­æ–­ç©ºé—²çº¿ç¨‹ if (value) interruptIdleWorkers(); &#125; &#125; å°ç»“æœ¬ç¯‡æ–‡ç« å¯¹çº¿ç¨‹æ± æ ¸å¿ƒç‚¹è¿›è¡Œäº†è¯¦ç»†åˆ†æï¼Œå…ˆæ˜¯ç®€å•ä»‹ç»äº†çº¿ç¨‹æ± äº§ç”Ÿçš„èƒŒæ™¯ï¼Œæ¥ç€è¯´æ˜äº†çº¿ç¨‹æ± çš„ä¼˜åŠ¿ï¼Œæœ€åå¯¹çº¿ç¨‹æ± æºç è¿›è¡Œäº†åˆ†æã€‚ä»ä»»åŠ¡æäº¤åˆ°çº¿ç¨‹æ± ï¼Œåˆ°çº¿ç¨‹æ± åˆ›å»ºçº¿ç¨‹å¹¶å¤„ç†ä»»åŠ¡ï¼Œåˆ°æœ€åçº¿ç¨‹è¢«å›æ”¶ï¼Œæœ€åç®€å•ä»‹ç»äº†çº¿ç¨‹æ± çš„é…ç½®ä»¥åŠçº¿ç¨‹æ± çš„ç›‘æ§ã€‚","categories":[{"name":"JDK","slug":"JDK","permalink":"https://gentryhuang.com/categories/JDK/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://gentryhuang.com/tags/JUC/"}]},{"title":"å¹¶å‘ - Javaå¹¶å‘å·¥å…·ç±»","slug":"concurrent/Javaå¹¶å‘å·¥å…·ç±»","date":"2020-11-05T16:00:00.000Z","updated":"2020-12-24T13:49:23.117Z","comments":false,"path":"posts/37f29896/","link":"","permalink":"https://gentryhuang.com/posts/37f29896/","excerpt":"","text":"å‰è¨€åœ¨ JDK çš„å¹¶å‘åŒ…ä¸­æä¾›äº†å‡ ä¸ªéå¸¸æœ‰ç”¨çš„å¹¶å‘å·¥å…·ç±»ã€‚ CountDownLatchã€CyclicBarrier å’Œ Semaphore å·¥å…·ç±»æä¾›äº†å¹¶å‘æµç¨‹æ§åˆ¶çš„æ‰‹æ®µï¼Œå®ƒä»¬éƒ½æ˜¯å¯¹ AQS åº”ç”¨ã€‚æœ¬ç¯‡æ–‡ç« å°†ä»‹ç»å…¶ç®€å•ä½¿ç”¨ä»¥åŠå†…éƒ¨åŸç†ã€‚ å·¥å…·ç±» ä½œç”¨ è¯´æ˜ Semaphore ä¿¡å·é‡ï¼Œé€šè¿‡æ§åˆ¶ â€˜è®¸å¯è¯â€™ çš„æ•°é‡æ¥åè°ƒå„ä¸ªçº¿ç¨‹ï¼Œä»¥ä¿è¯åˆç†çš„ä½¿ç”¨å…¬å…±èµ„æºã€‚ çº¿ç¨‹åªæœ‰æ‹¿åˆ° â€˜è®¸å¯è¯â€™ æ‰èƒ½ç»§ç»­è¿è¡Œ CyclicBarrier å¾ªç¯æ …æ ï¼Œè®©ä¸€ç»„çº¿ç¨‹åˆ°è¾¾ä¸€ä¸ªæ …æ ï¼ˆåŒæ­¥ç‚¹ï¼‰æ—¶è¢«é˜»å¡ï¼Œç›´åˆ°æœ€åä¸€ä¸ªçº¿ç¨‹åˆ°è¾¾æ …æ æ—¶ï¼Œè¢«æ …æ æ‹¦æˆªçš„çº¿ç¨‹æ‰ä¼šç»§ç»­è¿è¡Œã€‚ å¼ºè°ƒä¸€ç»„çº¿ç¨‹éƒ½åˆ°è¾¾åŒæ­¥ç‚¹æ‰ä¼šç»§ç»­å¾€ä¸‹æ‰§è¡Œ CountDownLatch é—¨æ “ï¼Œç­‰å¾…å¤šçº¿ç¨‹å®Œæˆ å¼ºè°ƒä¸€ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹ç­‰å¾…å…¶å®ƒçº¿ç¨‹å®Œæˆæ“ä½œ CountDownLatchä½¿ç”¨ä¾‹å­åœºæ™¯ åŠ å·¥å‚ç”Ÿäº§äº§å“ï¼Œäº§å“éœ€è¦ä¸‰é“å·¥åºè¿›è¡Œæ£€æµ‹ï¼Œåªæœ‰ä¸‰é“å·¥åºæ£€æµ‹é€šè¿‡æ‰èƒ½è¿›å…¥ä¸‹ä¸€ä¸ªç¯èŠ‚ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243@Slf4jpublic class CountDownLatchDemo &#123; /** * å›ºå®šçº¿ç¨‹æ•°çº¿ç¨‹æ±  */ public static ExecutorService service = Executors.newFixedThreadPool(5); /** * äº§å“è´¨é‡æ£€æµ‹ * * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; // éœ€è¦3ä¸ªå·¥äººè¿›è¡Œæ£€æµ‹ï¼Œå°±ç”¨3æ¥åˆå§‹åŒ–ä¸€ä¸ª CountDownLatch CountDownLatch latch = new CountDownLatch(3); for (int i = 1; i &lt;= 3; i++) &#123; final int no = i; service.submit(() -&gt; &#123; try &#123; // æ£€æµ‹ Thread.sleep((long) (Math.random() * 10000)); log.info(\"No.\" + no + \" å®Œæˆæ£€æµ‹ã€‚\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; // è°ƒç”¨ countDown() ä»£è¡¨å®Œæˆã€‚è¿™é‡ŒæŒ‡æŸä¸ªå‘˜å·¥å®Œæˆæ£€æµ‹ä»»åŠ¡ latch.countDown(); &#125; &#125; ); &#125; log.info(\"äº§å“è´¨é‡æ£€æµ‹ä¸­.....\"); // è°ƒç”¨await() ä»£è¡¨çº¿ç¨‹é˜»å¡ç­‰å¾…å…¶å®ƒçº¿ç¨‹å®Œæˆï¼Œå³åŒæ­¥çŠ¶æ€ state å‡ä¸º 0ã€‚è¿™é‡ŒæŒ‡äº§å“ç­‰å¾…æ£€æµ‹å®Œæˆ latch.await(); log.info(\"äº§å“è´¨é‡æ£€æµ‹å®Œæ¯•ï¼Œè¿›å…¥ä¸‹ä¸€ä¸ªç¯èŠ‚ã€‚\"); &#125;&#125; æ‰“å°ç»“æœ 12345[main] INFO com.code.juc.tool.CountDownLatchDemo - äº§å“è´¨é‡æ£€æµ‹ä¸­.....[pool-1-thread-2] INFO com.code.juc.tool.CountDownLatchDemo - No.2 å®Œæˆæ£€æµ‹ã€‚[pool-1-thread-3] INFO com.code.juc.tool.CountDownLatchDemo - No.3 å®Œæˆæ£€æµ‹ã€‚[pool-1-thread-1] INFO com.code.juc.tool.CountDownLatchDemo - No.1 å®Œæˆæ£€æµ‹ã€‚[main] INFO com.code.juc.tool.CountDownLatchDemo - äº§å“è´¨é‡æ£€æµ‹å®Œæ¯•ï¼Œè¿›å…¥ä¸‹ä¸€ä¸ªç¯èŠ‚ã€‚ è¯´æ˜ ä»¥ä¸Šä¾‹å­ä¸­ï¼Œmain çº¿ç¨‹è°ƒç”¨äº† latch.await() è¿›è¡Œé˜»å¡ç­‰å¾…ï¼Œå³å®ƒé˜»å¡åœ¨é—¨æ “ä¸Šï¼ˆå«å•¥æ— æ‰€è°“ï¼Œä¸­æ–‡æ˜¯é—¨æ “ã€æ …æ ï¼‰ï¼Œåªæœ‰å½“æ¡ä»¶æ»¡è¶³æ—¶ï¼ˆå…¶å®ƒçº¿ç¨‹è°ƒç”¨ latch.countDown() é€’å‡ state ä¸º0ï¼‰å®ƒæ‰èƒ½é€šè¿‡è¿™ä¸ªé—¨æ “ã€‚è¿™ä¸ªä¾‹å­æ¯”è¾ƒç®€å•ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ await æ–¹æ³•ç­‰å¾…å…¶å®ƒçº¿ç¨‹å®Œæˆï¼Œè¿™å±äº ä¸€å¯¹å¤š å…³ç³»ã€‚CountDownLatch è¿˜å¯ä»¥å®ç°å¤æ‚çš„ å¤šå¯¹å¤š å…³ç³»çš„åœºæ™¯ï¼Œæœ‰ m ä¸ªçº¿ç¨‹åœ¨é—¨æ “ä¸Šç­‰å¾… n ä¸ªçº¿ç¨‹å®Œæˆä»»åŠ¡ï¼Œç›´åˆ° n ä¸ªçº¿ç¨‹éƒ½å®Œæˆä»»åŠ¡ï¼Œè¿™ m ä¸ªçº¿ç¨‹æ‰èƒ½åŒæ—¶é€šè¿‡é—¨æ “ã€‚ æºç åˆ†ææ ¹æ® CountDownLatch çš„ä½¿ç”¨ä¾‹å­åˆ†ææºç ï¼ŒæŒ‰ç…§æ‰§è¡Œæµç¨‹é€ä¸€åˆ†æã€‚ å±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class CountDownLatch &#123; /** * Synchronization control For CountDownLatch. // ç»§æ‰¿AQSçš„å†…éƒ¨ç±» * Uses AQS state to represent count. // ä½¿ç”¨ AQS çš„çŠ¶æ€è¡¨ç¤º æ•°é‡ */ private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; /** * æœ‰å‚æ„é€ æ–¹æ³• * * @param count æ•°é‡ */ Sync(int count) &#123; // è°ƒç”¨çˆ¶ç±»æ–¹æ³•ï¼Œè®¾ç½®çŠ¶æ€å€¼ setState(count); &#125; /** * è·å–æ•°é‡ * * @return */ int getCount() &#123; // è°ƒç”¨çˆ¶ç±»æ–¹æ³•ï¼Œè·å–çŠ¶æ€å€¼ return getState(); &#125; /** * è¦†å†™çˆ¶ç±»æ–¹æ³• ï¼ˆè·å–åŒæ­¥çŠ¶æ€ï¼ˆè¿™é‡Œè¡¨ç¤ºæ•°é‡ï¼‰ - å…±äº«æ–¹å¼ï¼‰ * * @param acquires * @return */ @Override protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; /** * è¦†å†™çˆ¶ç±»æ–¹æ³•ï¼ˆé‡Šæ”¾åŒæ­¥çŠ¶æ€ï¼ˆè¿™é‡Œè¡¨ç¤ºæ•°é‡ï¼‰ - å…±äº«æ–¹å¼ï¼‰ * * @param releases æ²¡æœ‰æ„ä¹‰çš„å‚æ•°ï¼Œç”¨ä¸åˆ° * @return */ @Override protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (; ; ) &#123; // æ‰§è¡Œé€’å‡æ•°é‡æ—¶ï¼Œå¦‚æœæ•°é‡å·²ç»æ˜¯ 0 ï¼Œåˆ™ç›´æ¥è¿”å› falseï¼Œè¯´æ˜çŠ¶æ€å·²ç»è¢«å…¶å®ƒçº¿ç¨‹é€’å‡ä¸º 0 äº†ï¼Œå½“å‰çº¿ç¨‹æ— éœ€å”¤é†’ await() é˜»å¡çš„çº¿ç¨‹ï¼ˆä»¬ï¼‰ int c = getState(); if (c == 0) &#123; return false; &#125; int nextc = c - 1; if (compareAndSetState(c, nextc)) &#123; return nextc == 0; &#125; &#125; &#125; &#125; /** * AQS å¯¹è±¡ */ private final Sync sync; /** * æ„é€ æ–¹æ³•ï¼Œéœ€è¦ä¸€ä¸ª &gt;= 0 çš„æ•´æ•° * * @param count the number of times &#123;@link #countDown&#125; must be invoked * before threads can pass through &#123;@link #await&#125; * @throws IllegalArgumentException if &#123;@code count&#125; is negative */ public CountDownLatch(int count) &#123; if (count &lt; 0) &#123; throw new IllegalArgumentException(\"count &lt; 0\"); &#125; this.sync = new Sync(count); &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; &#125; CountDownLatch ç±»æ˜¯å¯¹ AQS å…±äº«æ¨¡å¼çš„ä½¿ç”¨ã€‚æ—¢ç„¶æ˜¯ä½¿ç”¨ AQS æ¡†æ¶ï¼Œé‚£ä¹ˆå°±æ˜¯ä¸€ä¸ªå›ºå®šçš„æ¨¡å¼ï¼ŒAQS å·²ç»å¤„ç†å¥½äº†åŒæ­¥çŠ¶æ€çš„è·å–ä¸é‡Šæ”¾ä»¥åŠé˜»å¡ä¸å”¤é†’ï¼Œè‡ªå®šä¹‰ç»„ä»¶åªéœ€ç»§æ‰¿ AQS ä»¥åŠæ ¹æ®åŒæ­¥çŠ¶æ€è·å–æ–¹å¼ï¼ˆç‹¬å /å…±äº«ï¼‰å®ç°æ¨¡ç‰ˆæ–¹æ³•å³å¯ã€‚å‰é¢ä¹Ÿè¯´äº†ï¼ŒAQS å‡†å¤‡å¥½äº†ä¸€åˆ‡ï¼Œåªéœ€è¦æ¡ä»¶è§¦å‘å°±å¯ä»¥æ‰§è¡Œå¯¹åº”çš„ä»»åŠ¡ï¼Œè€Œå®ç°çš„æ¨¡ç‰ˆæ–¹æ³•æ­£æ˜¯è§¦å‘æ¡ä»¶ã€‚ CountDownLatch ä¸»è¦æœ‰ä¸¤ä¸ªæ ¸å¿ƒæ–¹æ³•ï¼Œawait å’Œ countDown ã€‚countDown æ–¹æ³•æ¯æ¬¡è°ƒç”¨éƒ½ä¼šå°† state å‡ 1 ï¼Œç›´åˆ° state çš„å€¼ä¸º 0ã€‚await æ–¹æ³•å¯ä»¥è¢«å¤šä¸ªçº¿ç¨‹è°ƒç”¨ï¼Œè°ƒç”¨ await æ–¹æ³•çš„çº¿ç¨‹è¿›å…¥ AQS çš„é˜»å¡é˜Ÿåˆ—ä¸­å¹¶æŒ‚èµ·ï¼Œå½“ä¸”ä»…å½“ state ä¸º 0 æ—¶ï¼Œçº¿ç¨‹ä¼šä»é˜»å¡é˜Ÿåˆ—ä¸­ä¾æ¬¡è¢«å”¤é†’è¿‡æ¥ã€‚ await ç­‰å¾…await æ–¹æ³•æ˜¯ä¸€ä¸ªé˜»å¡æ–¹æ³•ï¼Œå½“ä¸”ä»…å½“åŒæ­¥çŠ¶æ€ state å‡è‡³ 0ï¼Œè¯¥æ–¹æ³•æ‰ä¼šè¿”å›ï¼Œå¦åˆ™è°ƒç”¨è¯¥æ–¹æ³•çš„çº¿ç¨‹å°†é˜»å¡ã€‚ 1234567891011121314151617--- CountDownLatch public void await() throws InterruptedException &#123; // å¯ä¸­æ–­è·å–åŒæ­¥çŠ¶æ€ sync.acquireSharedInterruptibly(1); &#125;--- AbstractQueuedSynchronizer public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; // ä¸­æ–­åˆ™æŠ›å‡ºä¸­æ–­å¼‚å¸¸ if (Thread.interrupted()) throw new InterruptedException(); // main çº¿ç¨‹è°ƒç”¨ await æ—¶ï¼Œstate = 3ï¼Œæ¡ä»¶æˆç«‹ if (tryAcquireShared(arg) &lt; 0) // æ¥ä¸‹æ¥å°±æ˜¯ AQS çš„å·¥ä½œäº†ï¼Œå…±äº«æ–¹å¼å¯ä¸­æ–­è·å–åŒæ­¥çŠ¶æ€ doAcquireSharedInterruptibly(arg); &#125; CountDownLatch çš„ await æ–¹æ³•ç®€å•ï¼Œç›´æ¥ä¼ å…¥æ•°é‡å€¼ä¸º 1 å°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼ˆå…¶å®ä¼ å…¥å€¼æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œç”¨ä¸åˆ°ï¼‰ã€‚CountDownLatch è¦†å†™äº†æ¨¡ç‰ˆæ–¹æ³•å³æ¡ä»¶ï¼Œæ¡ä»¶æˆç«‹åˆ™ AQS å®Œæˆé˜»å¡ä»»åŠ¡ã€‚ 123456789101112131415161718192021222324252627282930313233343536--- AbstractQueuedSynchronizer /** * Acquires in shared interruptible mode. * @param arg the acquire argument */ private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 1 å…¥é˜Ÿ ï¼Œå³å½“å‰çº¿ç¨‹åŠ å…¥é˜»å¡é˜Ÿåˆ—ï¼Œå…±äº«æ–¹å¼ final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; // å°è¯•è·å–å‰é©±èŠ‚ç‚¹ final Node p = node.predecessor(); if (p == head) &#123; // CountDownLatch å®ç°çš„æ¡ä»¶ï¼Œstate != 0 æ—¶ï¼Œè¿”å› -1 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; // 2 æ‰¾å¤§å“¥ï¼Œæ‰¾åˆ°å¤§å“¥å°±æŒ‚èµ·è‡ªå·±ï¼Œç„¶åç­‰å¾…å¤§å“¥å”¤é†’è‡ªå·±ã€‚æ²¡æœ‰æ‰¾åˆ°åˆ™ç»§ç»­æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°æˆ–å…¶å‰é©±èŠ‚ç‚¹æ˜¯ head èŠ‚ç‚¹ï¼Œæ‰¾åˆ°åˆ™æŒ‚èµ·ç­‰å¾…ï¼Œæ˜¯ head åˆ™å°è¯•è·å–åŒæ­¥çŠ¶æ€ã€‚ if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) // çº¿ç¨‹è¢«ä¸­æ–­åˆ™æŠ›å‡ºå¼‚å¸¸ throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; CountDownLatch çš„ await æ–¹æ³•åˆ°æ­¤å°±ç»“æŸäº†ï¼Œä¸‹é¢æ€»ç»“ä¸‹è¯¥æ–¹æ³•çš„æ ¸å¿ƒæ­¥éª¤ã€‚ main çº¿ç¨‹æ²¡æœ‰è·å–åˆ°åŒæ­¥çŠ¶æ€ä¼šè¿›å…¥é˜»å¡é˜Ÿåˆ—main çº¿ç¨‹å¯¹åº”çš„èŠ‚ç‚¹å…¥é˜Ÿå®Œæˆï¼Œå¦‚ä¸Šå›¾ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå› ä¸º main çº¿ç¨‹å¯¹åº”èŠ‚ç‚¹å…¥é˜Ÿæ—¶é˜»å¡é˜Ÿåˆ—ä¸ºç©ºï¼Œå› æ­¤éœ€è¦æ„å»ºé˜»å¡é˜Ÿåˆ—ï¼Œä½¿ç”¨ä¸€ä¸ªè™šèŠ‚ç‚¹ä½œä¸º head ã€‚å¦‚æœèŠ‚ç‚¹åœ¨å…¥é˜Ÿæ—¶å·²ç»å­˜åœ¨é˜»å¡é˜Ÿåˆ—ï¼Œé‚£ä¹ˆç›´æ¥æŒ‚åˆ°é˜»å¡é˜Ÿåˆ—å°¾éƒ¨å³å¯ã€‚ å°è¯•è·å–åŒæ­¥çŠ¶æ€å…¥é˜Ÿåè¿›å…¥for å¾ªç¯ï¼Œæ­¤æ—¶mainçº¿ç¨‹å¯¹åº”çš„èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹æ˜¯ headï¼Œä½† tryAcquireShared è¿”å› -1,æ­¤æ—¶è¿›å…¥ æ‰¾å¤§å“¥ çš„æµç¨‹ä¸­ã€‚æ‰¾å¤§å“¥ å°±æ˜¯å°†å½“å‰èŠ‚ç‚¹çš„æœ‰æ•ˆå‰é©±èŠ‚ç‚¹ç­‰å¾…çŠ¶æ€ waitStatus è®¾ç½®ä¸º -1ã€‚è¿™é‡Œæ˜¯å°† main çº¿ç¨‹å¯¹åº”èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹ head çš„ waitStatus è®¾ç½®ä¸º -1ã€‚ æŒ‚èµ·ï¼Œç­‰å¾…å‰ç½®èŠ‚ç‚¹å”¤é†’æ‰¾åˆ°å¤§å“¥åæŒ‚èµ·è‡ªå·±ï¼Œç­‰å¾…å¤§å“¥ï¼ˆæœ‰æ•ˆå‰ç½®èŠ‚ç‚¹ï¼‰å”¤é†’è‡ªå·±ã€‚ ä»¥ä¸Šæ˜¯ main çº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€å¤±è´¥åï¼Œè¿›å…¥é˜»å¡é˜Ÿåˆ—ç­‰å¾…å”¤é†’çš„è¿‡ç¨‹ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼ŒCountDownLatch å¯ä»¥æœ‰å¤šä¸ªçº¿ç¨‹ç­‰å¾…å…¶å®ƒçº¿ç¨‹å®Œæˆï¼Œä¾‹å­ä¸­åªæ˜¯ä½¿ç”¨ä¸€ä¸ªçº¿ç¨‹ç­‰å¾…è€Œå·²ã€‚ countDown å”¤é†’countDown æ–¹æ³•æ¯æ¬¡è°ƒç”¨éƒ½ä¼šå°†åŒæ­¥çŠ¶æ€ state å‡ 1ï¼Œç›´åˆ°å‡å°‘è‡³ 0 ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041--- CountDownLatch public void countDown() &#123; // é‡Šæ”¾åŒæ­¥çŠ¶æ€ sync.releaseShared(1); &#125;--- AbstractQueuedSynchronizer public final boolean releaseShared(int arg) &#123; //åªæœ‰å½“ state å‡åˆ° 0 æ—¶ï¼Œ tryReleaseShared æ–¹æ³•æ‰è¿”å› trueï¼Œå¦åˆ™ä»…æ˜¯å°† state å‡ 1 å¹¶è¿”å› false if (tryReleaseShared(arg)) &#123; // state == 0 æ—¶ï¼Œå”¤é†’é˜»å¡çš„çº¿ç¨‹ã€‚ æ³¨æ„ï¼Œè¿™é‡Œæ˜¯ t1 çº¿ç¨‹å”¤é†’é˜»å¡çš„çº¿ç¨‹å³ main çº¿ç¨‹ doReleaseShared(); return true; &#125; return false; &#125; private void doReleaseShared() &#123; // t1 çº¿ç¨‹æ‰§è¡Œåˆ°è¿™é‡Œï¼Œå”¤é†’é˜»å¡é˜Ÿåˆ—ä¸­ç­‰å¾…çš„ main çº¿ç¨‹ for (;;) &#123; // å°†å½“å‰ head ä¿å­˜èµ·æ¥ï¼Œå› ä¸ºå…¶å®ƒçº¿ç¨‹å¯èƒ½ä¼šå é¢†å®ƒï¼Œæ­¤æ—¶æ˜¯è™šèŠ‚ç‚¹ Node h = head; if (h != null &amp;&amp; h != tail) &#123; // main çº¿ç¨‹å…¥é˜Ÿæ—¶å·²ç»æŠŠ head å½“ä½œå¤§å“¥äº†ï¼Œå³ å°† head çš„ waitStatus è®¾ç½®ä¸º -1 (Node.SIGNAL) int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; // cas å°† head çš„ waitStatus è®¾ç½® ä¸º 0ã€‚ if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases // å”¤é†’ head ä¸‹ä¸€ä¸ªæœ‰æ•ˆèŠ‚ç‚¹ã€‚è¿™é‡Œæ˜¯ main çº¿ç¨‹å¯¹åº”çš„èŠ‚ç‚¹ unparkSuccessor(h); &#125;else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125; &#125; ä¸Šé¢ä»£ç åªæ˜¯æ­£å¸¸æƒ…å†µä¸‹ä¸€ä¸ªå®Œæ•´æµç¨‹ï¼Œå³ main çº¿ç¨‹åŠ å…¥é˜»å¡é˜Ÿåˆ—å¹¶æŒ‚èµ·åï¼Œt2ã€t3ã€t1 åˆ†åˆ«æ‰§è¡Œ countDown æ–¹æ³•é€’å‡ state çš„å€¼ï¼Œåˆ°äº† t1 è°ƒç”¨è¯¥æ–¹æ³•æ—¶ï¼Œåˆšå¥½ state çš„å€¼è¢«å‡è‡³ 0 ï¼Œç„¶åçº¿ç¨‹ t1 æ‰§è¡Œå”¤é†’é˜»å¡é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹é€»è¾‘ã€‚ä¸‹é¢å¯¹è¯¥è¿‡ç¨‹è¿›è¡Œæ€»ç»“ã€‚ è‡³æ­¤ï¼Œå”¤é†’æ¡ä»¶å·²ç»å…·å¤‡ï¼Œå³ state = 0 ï¼Œä¸‹é¢æˆ‘ä»¬å›åˆ°ä¹‹å‰çº¿ç¨‹æŒ‚èµ·çš„ä»£ç å¤„ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536--- AbstractQueuedSynchronizer /** * Acquires in shared interruptible mode. * @param arg the acquire argument */ private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; // å°è¯•è·å–å‰é©±èŠ‚ç‚¹ final Node p = node.predecessor(); if (p == head) &#123; // CountDownLatch å®ç°çš„æ¡ä»¶ï¼Œstate != 0 æ—¶ï¼Œè¿”å› -1 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // 2 main å æ® head å¹¶ç»§ç»­å”¤é†’åç½®é˜»å¡çš„çº¿ç¨‹ setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; // 1 çº¿ç¨‹ t1 å”¤é†’é˜»å¡çš„ main çº¿ç¨‹ï¼Œè¯¥æ–¹æ³•è¿”å›ï¼Œå³ main çº¿ç¨‹ç»§ç»­æ‰§è¡Œå°è¯•å†æ¬¡è·å–åŒæ­¥çŠ¶æ€ parkAndCheckInterrupt()) // å¦‚æœçº¿ç¨‹è¢«ä¸­æ–­åˆ™æŠ›å‡ºå¼‚å¸¸ throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; main çº¿ç¨‹è¢«å”¤é†’åä» parkAndCheckInterrupt æ–¹æ³•è¿”å›ï¼Œå¦‚æœæ²¡æœ‰è¢«ä¸­æ–­ï¼Œåˆ™ç»§ç»­å°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼Œæ­¤æ—¶å¯ä»¥è·å–åˆ°åŒæ­¥çŠ¶æ€ï¼ˆr &gt;= 0 æˆç«‹ï¼‰ã€‚æ¥ä¸‹æ¥ main çº¿ç¨‹ä¼šè¿›å…¥åˆ° setHeadAndPropagate æ–¹æ³•ä¸­ã€‚ 123456789101112131415161718192021222324252627282930313233--- AbstractQueuedSynchronizer private void setHeadAndPropagate(Node node, int propagate) &#123; // å°†å½“å‰ head ä¿å­˜èµ·æ¥ï¼Œå› ä¸ºå…¶å®ƒçº¿ç¨‹å¯èƒ½ä¼šå é¢†å®ƒ Node h = head; // Record old head for check below // node èŠ‚ç‚¹å é¢† headï¼Œå³ main çº¿ç¨‹å é¢† head setHead(node); /* * è¿™é‡Œæ¡ä»¶åˆ¤æ–­å¯¹åº”çš„åœºæ™¯æ¯”è¾ƒå¤šï¼Œæ¯•ç«Ÿæ˜¯ AQS ç»Ÿä¸€å¤„ç†æ–¹æ³•ï¼Œå› æ­¤è€ƒè™‘çš„æƒ…å†µæ¯”è¾ƒå…¨é¢ã€‚å¯¹äº CountDownLatch ï¼Œå°±æ˜¯å”¤é†’ node ä¹‹åçš„æœ‰æ•ˆèŠ‚ç‚¹ã€‚ */ if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; // å½“å‰èŠ‚ç‚¹çš„åç½®èŠ‚ç‚¹ Node s = node.next; // å¦‚æœä¸º null æˆ–è€… æ˜¯å…±äº«æ–¹å¼çš„èŠ‚ç‚¹ if (s == null || s.isShared()) // æ¥ç€å”¤é†’é˜»å¡çº¿ç¨‹ ï¼ˆå…±äº«å¼ï¼‰ã€‚æ³¨æ„ï¼Œè¿™é‡Œæ˜¯é†’æ¥çš„é˜»å¡çº¿ç¨‹ç»§ç»­å”¤é†’åç½®è¿˜åœ¨é˜»å¡çš„çº¿ç¨‹ã€‚ doReleaseShared(); &#125; &#125; /** * å é¢† head * Sets head of queue to be node, thus dequeuing. Called only by * acquire methods. Also nulls out unused fields for sake of GC * and to suppress unnecessary signals and traversals. * * @param node the node */ private void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null; &#125; setHeadAndPropagate æ–¹æ³•ä¸»è¦åšäº†ä¸¤ä»¶äº‹ï¼Œnode å é¢† head å¹¶å”¤é†’ node åç½®çš„æœ‰æ•ˆèŠ‚ç‚¹ã€‚ç”±äºä¾‹å­ä¸­åªæœ‰ main çº¿ç¨‹è¿›å…¥äº†é˜»å¡é˜Ÿåˆ—ï¼Œå®ƒåé¢æ²¡æœ‰ç­‰å¾…å”¤é†’çš„çº¿ç¨‹èŠ‚ç‚¹ï¼Œä½†ä¸ºäº†ç ”ç©¶æºç æˆ‘ä»¬å‡è®¾ main çº¿ç¨‹å¯¹åº”èŠ‚ç‚¹åé¢è¿˜æœ‰ä¸€ä¸ª çº¿ç¨‹ t èŠ‚ç‚¹ç­‰å¾…å”¤é†’ï¼Œé‚£ä¹ˆ main çº¿ç¨‹ä¼šæ‰§è¡Œ doReleaseShared æ–¹æ³•æ¥å”¤é†’çº¿ç¨‹ t ï¼Œæ­¤æ—¶ head æ˜¯ main çº¿ç¨‹å¯¹åº”çš„èŠ‚ç‚¹ã€‚ 1234567891011121314151617181920212223242526272829private void doReleaseShared() &#123; for (;;) &#123; // å°†å½“å‰ head ä¿å­˜èµ·æ¥ï¼Œå› ä¸ºå…¶å®ƒçº¿ç¨‹å¯èƒ½ä¼šå é¢†å®ƒ Node h = head; // h == null è¯´æ˜é˜»å¡é˜Ÿåˆ—ä¸ºç©ºï¼Œh == tail è¯´æ˜å¤´èŠ‚å·²ç»æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹æˆ–è€…æ˜¯åˆšåˆšåˆå§‹åŒ–çš„èŠ‚ç‚¹ï¼Œè¿™å¯¹åº” CountDownLatch æ¥è¯´éƒ½åº”è¯¥ç»“æŸã€‚ // æŒ‰ç…§ä¾‹å­èµ°åˆ°è¿™é‡Œï¼Œhead å°± mainçº¿ç¨‹å¯¹åº”çš„èŠ‚ç‚¹ï¼ŒåŒæ—¶ tail ä¹Ÿæ˜¯ main çº¿ç¨‹å¯¹åº”çš„èŠ‚ç‚¹ã€‚ä¸è¿‡æˆ‘ä»¬å‡è®¾äº† çº¿ç¨‹ t ï¼Œå› æ­¤æ¡ä»¶æ˜¯æˆç«‹çš„ if (h != null &amp;&amp; h != tail) &#123; // h çš„çŠ¶æ€ï¼Œå³ main çº¿ç¨‹å¯¹åº”èŠ‚ç‚¹çŠ¶æ€ï¼Œç”±å…¥é˜Ÿæ–¹æ³•å¯çŸ¥ï¼Œt çº¿ç¨‹å¯¹åº”èŠ‚ç‚¹ä¼šæŠŠ main çº¿ç¨‹å¯¹åº”èŠ‚ç‚¹ä½œä¸º å¤§å“¥èŠ‚ç‚¹ï¼Œå³ waitStatus è®¾ç½®ä¸º -1ï¼ˆNode.SIGNAL) int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; // å¯èƒ½ä¼šå¤±è´¥ if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases // å”¤é†’ h çš„åç½®èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯é˜»å¡é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚è¿™é‡Œæ˜¯çº¿ç¨‹ t å¯¹åº”çš„èŠ‚ç‚¹ unparkSuccessor(h); &#125;else if (ws == 0 &amp;&amp; // todo è¿™é‡Œå¯èƒ½ä¼šå¤±è´¥ !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; // çº¿ç¨‹æ‰§è¡Œåˆ°è¿™é‡Œï¼Œå¦‚æœå”¤é†’çš„çº¿ç¨‹å·²ç»å é¢†äº† headï¼Œæ­¤æ—¶ h != headï¼Œå½“å‰çº¿ç¨‹ç»§ç»­å¾ªç¯ã€‚å¦‚æœ h == head ï¼Œè¯´æ˜ï¼Œå”¤é†’çš„çº¿ç¨‹è¿˜æ²¡æœ‰å é¢† headï¼Œå½“å‰çº¿ç¨‹é€€å‡ºå¾ªç¯ // è¿™é‡Œå¯èƒ½ main çº¿ç¨‹æ‰§è¡Œåˆ°è¿™é‡Œæ—¶ï¼Œmain çº¿ç¨‹å”¤é†’çš„çº¿ç¨‹ t å·²ç»å é¢†äº† head ,æ­¤æ—¶ h != head if (h == head) // loop if head changed break; &#125;&#125; setHeadAndPropagate æ–¹æ³•å’Œ doReleaseShared æ–¹æ³•é…åˆï¼Œä¾æ¬¡å”¤é†’é˜»å¡çš„çº¿ç¨‹ï¼Œå³ æ‰§è¡Œ doReleaseShared æ–¹æ³•çš„çº¿ç¨‹å”¤é†’å®ƒçš„åç½®é˜»å¡çº¿ç¨‹ï¼Œé†’æ¥çš„çº¿ç¨‹ä¼šå†æ¬¡å°è¯•è·å–åŒæ­¥çŠ¶æ€ç„¶åè¿›å…¥åˆ° setHeadAndPropagate æ–¹æ³•ä¸­å…ˆå é¢† headï¼Œç„¶åè°ƒç”¨ doReleaseShared æ–¹æ³•ç»§ç»­å”¤é†’å®ƒçš„åç½®é˜»å¡èŠ‚ç‚¹ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼ŒAQS çš„ doReleaseShared æ–¹æ³•æç«¯åœºæ™¯è¿˜æ˜¯æŒºå¤šçš„ï¼Œè¿™é‡Œç»“åˆ CountDownLatch æ¥è¯´æ˜ã€‚ æˆ‘ä»¬æŠ›å¼€ç»™å‡ºçš„ä¾‹å­ï¼Œæ ¹æ®ä»¥ä¸‹åœºæ™¯åˆ†æå‡ ä¸ªç‰¹æ®Šçš„æƒ…å†µ è¦è¿›è¡Œä½“èƒ½æµ‹è¯•ï¼Œæ¯ç»„ä¸‰ä¸ªåŒå­¦è¿›è¡ŒçŸ­è·‘ï¼Œåœ¨ä½“è‚²è€å¸ˆå‘å‡ºèµ·è·‘æŒ‡ä»¤å‰ï¼Œè¿™ä¸‰ä¸ªåŒå­¦éƒ½è¦åœ¨èµ·è·‘çº¿å¾…ç€ï¼Œå½“ä½“è‚²è€å¸ˆå‡†å¤‡å®Œæ¯•åä¼šå‘å‡ºå¼€å§‹è·‘çš„æŒ‡ä»¤ï¼Œé‚£è¿™ä¸‰ä¸ªåŒå­¦å°±ä¼šä¸€èµ·è·‘å‘ç»ˆç‚¹çš„æµ‹è¯•ä»ªã€‚è¿™é‡Œ CountDownLatch çš„æ•°é‡ ä¸º 1ï¼Œå³åŒæ­¥çŠ¶æ€ä¸º 1 ã€‚ h != head çš„æƒ…å†µå½“ t1 è¢«å”¤é†’åï¼Œå”¤é†’ t1 çš„çº¿ç¨‹ t æ‰§è¡Œåˆ°ä¸Šå›¾ä¸­çš„ä»£ç å¤„ï¼Œè¿˜æ²¡æœ‰é€€å‡ºå¾ªç¯ï¼Œt1 å·²ç»å é¢†äº† headï¼ˆæ­¤æ—¶å›¾ä¸­çš„ head è¦æŒ‡å‘ t1 çº¿ç¨‹å¯¹åº”çš„èŠ‚ç‚¹ï¼Œä¸” t1 çº¿ç¨‹èŠ‚ç‚¹ thread ç½®ç©ºï¼Œprev ç½®ç©ºã€‚å›¾ä¸­æ²¡æœ‰ä½“ç°å‡ºæ¥ï¼‰ï¼Œæ­¤æ—¶ head != h ï¼Œçº¿ç¨‹ t å°†ä¼šè¿›è¡Œä¸‹ä¸€è½®å¾ªç¯ã€‚ compareAndSetWaitStatus(h, Node.SIGNAL, 0) å¤±è´¥çº¿ç¨‹ t è¿›è¡Œç¬¬äºŒè½®å¾ªç¯æ—¶ï¼Œåˆšå¥½è¢«å”¤é†’çš„çº¿ç¨‹ t1 ä¹Ÿè¿›å…¥è¯¥å¾ªç¯ï¼Œæ­¤æ—¶ä¸¤ä¸ªçº¿ç¨‹å¹¶å‘æ‰§è¡Œï¼Œå‡è®¾çº¿ç¨‹ t CAS æ“ä½œæˆåŠŸï¼Œç„¶åé€€å‡ºå¾ªç¯ï¼Œçº¿ç¨‹ t1 å¤±è´¥ï¼Œå°†ä¼šè¿›è¡Œä¸‹ä¸€è½®å¾ªç¯ã€‚æ³¨æ„ï¼Œæ­¤æ—¶è™šèŠ‚ç‚¹çš„ next æŒ‡é’ˆè¿˜å­˜åœ¨ï¼Œå› ä¸ºæˆ‘ä»¬å‡è®¾çš„æ˜¯ t1 çº¿ç¨‹å¤±è´¥äº†ï¼Œt çº¿ç¨‹æˆåŠŸé€€å‡ºäº†ï¼Œt çº¿ç¨‹ä¸å±äºé˜»å¡é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹ï¼Œå®ƒä¸ä¼šç»´æŠ¤é˜»å¡é˜Ÿåˆ—èŠ‚ç‚¹å…³ç³»ï¼Œå¦‚æœæ˜¯ t1 çº¿ç¨‹æˆåŠŸå¹¶é€€å‡ºå¾ªç¯å°±ä¼šæ¸…é™¤å®ƒä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„ next ï¼Œè¿™é‡Œå°±æ˜¯è™šèŠ‚ç‚¹ã€‚ æ‰§è¡Œ else if (ws == 0 &amp;&amp;..) åˆ†æ”¯t1 çº¿ç¨‹ç¬¬äºŒæ¬¡å¾ªç¯æ—¶ï¼Œå”¤é†’çš„ t2 çº¿ç¨‹è¿˜æ²¡æœ‰å é¢† headï¼Œæ­¤æ—¶çš„ head è¿˜æ˜¯ t1 çº¿ç¨‹å¯¹åº”çš„èŠ‚ç‚¹ï¼Œä½†æ˜¯ waitStatus è¢«ä¹‹å‰çš„ t çº¿ç¨‹é€šè¿‡ CAS è®¾ç½®ä¸º 0 äº†ï¼Œå› æ­¤è¿›å…¥åˆ° else if åˆ†æ”¯ï¼Œç„¶åå†æ¬¡æŠŠèŠ‚ç‚¹ watiStatus è®¾ç½®ä¸º -3 ã€‚æ‰§è¡Œåˆ° h == head åˆ¤æ–­å¤„æ—¶ï¼Œå‡è®¾ t2 è¿˜æ˜¯æ²¡æœ‰å é¢† head ï¼Œæ­¤æ—¶ t1 é€€å‡ºå¾ªç¯ï¼Œç„¶åæ¸…é™¤å…¶å‰ç½®èŠ‚ç‚¹çš„ next æŒ‡é’ˆï¼Œå³è™šèŠ‚ç‚¹ã€‚ compareAndSetWaitStatus(h, 0, Node.PROPAGATE) å¤±è´¥è¿›å…¥è¿™ä¸ªæ–¹æ³•çš„å‰ææ˜¯ ws == 0ï¼Œå³ head çš„ waitStatus å‡ºç°äº† 0ï¼Œæ­¤æ—¶å¦‚æœ CAS å¤±è´¥ï¼Œä¸€èˆ¬æœ‰ä¸¤ç§å¯èƒ½ï¼Œä¸€ç§æ˜¯çº¿ç¨‹å¹¶å‘æ‰§è¡Œ CAS åªæœ‰ä¸€ä¸ªä¼šæˆåŠŸï¼Œå¦ä¸€ç§æ˜¯å…¶å®ƒçš„çº¿ç¨‹æŠŠè¯¥èŠ‚ç‚¹çš„ waitStatus å€¼ä¿®æ”¹äº†ï¼Œæ­¤æ—¶èƒ½æ”¹ head çš„çŠ¶æ€å€¼çš„å¾ˆå¯èƒ½æ˜¯èŠ‚ç‚¹å…¥é˜Ÿå¼•èµ·çš„ä¿®æ”¹ï¼Œå› ä¸ºæ–°èŠ‚ç‚¹è¦æŠŠæœ‰æ•ˆçš„å‰é©±èŠ‚ç‚¹çŠ¶æ€å€¼è®¾ç½®ä¸º -1 ã€‚åœ¨ CountDownLatch ä¸­ä¸€èˆ¬ä¸ä¼šå‘ç”Ÿç¬¬äºŒç§å¯èƒ½ï¼Œå› ä¸ºä¸€æ—¦å”¤é†’æ¡ä»¶æˆç«‹ï¼Œå°±ä¸ä¼šå†æœ‰èŠ‚ç‚¹éœ€è¦å…¥é˜Ÿé˜»å¡äº†ã€‚ å‰©ä¸‹çš„ t2 çº¿ç¨‹ã€t3 çº¿ç¨‹ä¾æ¬¡ä¼šè¢«å”¤é†’ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ t3 çº¿ç¨‹è¢«å”¤é†’å é¢†å¤´èŠ‚ç‚¹åä¹Ÿä¼šè¿›å…¥åˆ° doReleaseShared æ–¹æ³•çš„å¾ªç¯ä¸­ï¼Œæ­¤æ—¶å®ƒå¯¹åº”çš„èŠ‚ç‚¹æ—¢æ˜¯ head åˆæ˜¯ tailï¼Œå°±ç›´æ¥é€€å‡ºå¾ªç¯ï¼Œç»“æŸæ•´ä¸ªæµç¨‹äº†ã€‚ å°ç»“CountDownLatch çš„æ„é€ å‡½æ•°éœ€è¦ä¸€ä¸ª int ç±»å‹çš„å‚æ•°ä½œä¸ºæ•°é‡ï¼ˆç”¨æ¥è®¡æ•°ï¼‰ï¼Œå¦‚æœæƒ³ç­‰å¾… N ä¸ªä»»åŠ¡å®Œæˆï¼ˆN ä¸ªçº¿ç¨‹æ‰§è¡Œå®Œä»»åŠ¡ï¼‰ï¼Œå°±éœ€è¦ä¼ å…¥ N ã€‚CountDownLatch çš„ countDown æ–¹æ³•ç”¨äºå°† N å‡ 1 ,await æ–¹æ³•ä¼šé˜»å¡å½“å‰è°ƒç”¨çº¿ç¨‹ï¼ˆé˜»å¡åœ¨é—¨æ “ä¸Šï¼Œé—¨æ “æ˜¯ä¸€ä¸ªåŒæ­¥ç‚¹çš„æ¦‚å¿µï¼‰ï¼Œç›´åˆ° N å‡è‡³ 0 è¢«é˜»å¡çš„çº¿ç¨‹æ‰ä¼šç»§ç»­å¾€ä¸‹æ‰§è¡Œã€‚æ­¤å¤–ï¼ŒCountDownLatch è¿˜æä¾›äº†ä¸€ä¸ªå¸¦æœ‰æŒ‡å®šæ—¶é—´çš„ await æ–¹æ³•ï¼Œç”¨äºç­‰å¾…è¶…æ—¶çš„åœºæ™¯ï¼Œè¶…è¿‡ç­‰å¾…æ—¶é—´å°±ä¸ä¼šå†ç­‰ï¼Œè¢«é˜»å¡çº¿ç¨‹ç»§ç»­å¾€ä¸‹æ‰§è¡Œã€‚è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ï¼Œå°±æ˜¯åœ¨ await æ–¹æ³•çš„åŸºç¡€ä¸Šå¢åŠ äº†è¶…æ—¶åˆ¤æ–­ï¼Œä¸‹é¢ç²˜è´´ä¸‹ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859--- CountDownLatch public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); &#125;--- AbstractQueuedSynchronizer public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquireShared(arg) &gt;= 0 || doAcquireSharedNanos(arg, nanosTimeout); &#125; /** * Acquires in shared timed mode. * * @param arg the acquire argument * @param nanosTimeout max wait time * @return &#123;@code true&#125; if acquired */ private boolean doAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; // è®¡ç®—å‡ºç­‰å¾…çš„æœ€è¿Ÿæ—¶é—´ final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return true; &#125; &#125; // è®¡ç®—å‡ºç­‰å¾…å‰©ä½™æ—¶é—´ nanosTimeout = deadline - System.nanoTime(); // è¶…è¿‡ç­‰å¾…æ—¶é—´ï¼Œåˆ™ä¸å†ç­‰å¾…ï¼Œç›´æ¥è¿”å› if (nanosTimeout &lt;= 0L) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; // æ‰§è¡ŒæŒ‚èµ·çš„æœ€å°æ—¶é—´ç²’åº¦ nanosTimeout &gt; spinForTimeoutThreshold) // æŒ‚èµ· nanosTimeout æ—¶é—´åè‡ªåŠ¨é†’æ¥ LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; éœ€è¦æ³¨æ„ï¼ŒN å€¼å¿…é¡» å¤§äºç­‰äº 0ï¼Œå¦‚æœ N ç­‰äº 0 ï¼Œè°ƒç”¨ await æ–¹æ³•æ—¶å½“å‰çº¿ç¨‹ä¸ä¼šè¢«é˜»å¡ï¼Œæ­¤å¤– CountDownLatch ä¸æ”¯æŒé‡æ–°åˆå§‹åŒ–ï¼Œä¹Ÿä¸æ”¯æŒä¿®æ”¹æ•°é‡çš„å€¼ã€‚ CyclicBarrierä½¿ç”¨ä¾‹å­åœºæ™¯ æŸä¸ªå…¬å¸éƒ¨é—¨ä¸¾åŠå›¢å»ºæ´»åŠ¨ï¼Œéœ€è¦å‘˜å·¥è‡ªè¡Œæ‹¼è½¦å‰å¾€ç›®çš„åœ°ï¼Œå¸æœºä¼šåœ¨æŒ‡å®šçš„åœ°ç‚¹ç­‰å¾…æ‹¼è½¦çš„ 4 ä¸ªäººåˆ°é½åæ‰å‘è½¦ã€‚æˆ‘ä»¬å‡è®¾è¯¥éƒ¨é—¨æŸä¸ªå›¢é˜Ÿæœ‰ 8 ä¸ªäººï¼Œé‚£ä¹ˆå°±éœ€è¦æ‹¼ 2 è¾†è½¦å‰å¾€ç›®çš„åœ°ã€‚ 123456789101112131415161718192021222324252627282930313233@Slf4jpublic class CyclicBarrierDemo &#123; /** * å›ºå®šçº¿ç¨‹æ•°çº¿ç¨‹æ±  */ public static ExecutorService service = Executors.newFixedThreadPool(8); public static void main(String[] args) &#123; // è¦ç­‰å¾… 4 ä¸ªåŒå­¦åˆ°é½ï¼Œåˆ°é½åå‘è½¦ï¼Œå› æ­¤è¿™é‡Œåˆå§‹åŒ–ä¸€ä¸ªå¸¦æœ‰ Runnable å‚æ•°çš„ CyclicBarrier CyclicBarrier cyclicBarrier = new CyclicBarrier(4, () -&gt; log.info(\"4äººå·²åˆ°é½ï¼Œè¯·ç³»å¥½å®‰å…¨å¸¦ï¼Œç°åœ¨å‡ºå‘èµ¶å¾€ç›®çš„åœ° !\")); // 8ä¸ªäººï¼Œéœ€è¦ 2 è¾†è½¦ã€‚è¿™é‡Œä¼šå¾ªç¯ä½¿ç”¨ CyclicBarrier for (int i = 0; i &lt; 8; i++) &#123; service.submit(() -&gt; &#123; try &#123; // èµ¶å¾€æ‹¼è½¦åœ°ç‚¹ Thread.sleep((long) (Math.random() * 10000)); log.info(\"åˆ°è¾¾æŒ‡å®šæ‹¼è½¦åœ°ç‚¹ !\"); cyclicBarrier.await(); // ä¸€ç»„äººå‘˜å…¨éƒ¨åˆ°è¾¾åï¼Œæ‰èƒ½å‡ºå‘ã€‚ å³ ä¸€ç»„çº¿ç¨‹å…¨éƒ¨åˆ°è¾¾æ …æ åï¼Œè¢«é˜»å¡çš„çº¿ç¨‹æ‰èƒ½ç»§ç»­æ‰§è¡Œ log.info(\"å‡ºå‘äº† !\"); &#125; catch (InterruptedException | BrokenBarrierException exception) &#123; exception.printStackTrace(); &#125; &#125;); &#125; &#125;&#125; æ‰“å°ç»“æœ 123456789101112131415161718[pool-1-thread-6] INFO com.code.juc.tool.CyclicBarrierDemo - åˆ°è¾¾æŒ‡å®šæ‹¼è½¦åœ°ç‚¹ ![pool-1-thread-5] INFO com.code.juc.tool.CyclicBarrierDemo - åˆ°è¾¾æŒ‡å®šæ‹¼è½¦åœ°ç‚¹ ![pool-1-thread-4] INFO com.code.juc.tool.CyclicBarrierDemo - åˆ°è¾¾æŒ‡å®šæ‹¼è½¦åœ°ç‚¹ ![pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - åˆ°è¾¾æŒ‡å®šæ‹¼è½¦åœ°ç‚¹ ![pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 4äººå·²åˆ°é½ï¼Œè¯·ç³»å¥½å®‰å…¨å¸¦ï¼Œç°åœ¨å‡ºå‘èµ¶å¾€ç›®çš„åœ° ![pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - å‡ºå‘äº† ![pool-1-thread-6] INFO com.code.juc.tool.CyclicBarrierDemo - å‡ºå‘äº† ![pool-1-thread-5] INFO com.code.juc.tool.CyclicBarrierDemo - å‡ºå‘äº† ![pool-1-thread-4] INFO com.code.juc.tool.CyclicBarrierDemo - å‡ºå‘äº† ![pool-1-thread-8] INFO com.code.juc.tool.CyclicBarrierDemo - åˆ°è¾¾æŒ‡å®šæ‹¼è½¦åœ°ç‚¹ ![pool-1-thread-2] INFO com.code.juc.tool.CyclicBarrierDemo - åˆ°è¾¾æŒ‡å®šæ‹¼è½¦åœ°ç‚¹ ![pool-1-thread-3] INFO com.code.juc.tool.CyclicBarrierDemo - åˆ°è¾¾æŒ‡å®šæ‹¼è½¦åœ°ç‚¹ ![pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - åˆ°è¾¾æŒ‡å®šæ‹¼è½¦åœ°ç‚¹ ![pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 4äººå·²åˆ°é½ï¼Œè¯·ç³»å¥½å®‰å…¨å¸¦ï¼Œç°åœ¨å‡ºå‘èµ¶å¾€ç›®çš„åœ° ![pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - å‡ºå‘äº† ![pool-1-thread-8] INFO com.code.juc.tool.CyclicBarrierDemo - å‡ºå‘äº† ![pool-1-thread-2] INFO com.code.juc.tool.CyclicBarrierDemo - å‡ºå‘äº† ![pool-1-thread-3] INFO com.code.juc.tool.CyclicBarrierDemo - å‡ºå‘äº† ! è¯´æ˜ ä»¥ä¸Šä¾‹å­ä¸­ï¼Œä½¿ç”¨å¾ªç¯ä½“å’Œçº¿ç¨‹æ± æ¨¡æ‹Ÿ 8 ä¸ªçº¿ç¨‹æ‰§è¡Œä»»åŠ¡ï¼Œå…¶ä¸­æ¯ 4 ä¸ªçº¿ç¨‹ä¸ºä¸€ç»„ï¼Œåªæœ‰è¿™ 4 ä¸ªçº¿ç¨‹éƒ½åˆ°è¾¾æ …æ ï¼Œä¾‹å­ä¸­æ˜¯åˆ°è¾¾æŒ‡å®šæ‹¼è½¦ç‚¹ï¼Œæ‰èƒ½ç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œå¦åˆ™éƒ½ä¼šé˜»å¡åœ¨æ …æ ä¸Šç­‰å¾…å…¶å®ƒçº¿ç¨‹åˆ°è¾¾æ …æ ã€‚åˆ°è¾¾æ …æ çš„å®šä¹‰æ˜¯ çº¿ç¨‹è°ƒç”¨ await æ–¹æ³•ã€‚ä¸€ç»„çº¿ç¨‹éƒ½åˆ°è¾¾æ …æ åï¼Œç”±æœ€ååˆ°è¾¾çš„çº¿ç¨‹æ‰§è¡ŒåŠæ—¶ä»»åŠ¡ï¼Œæ²¡æœ‰ä»»åŠ¡åˆ™ä¸æ‰§è¡Œã€‚CyclicBarrier æ˜¯å¯å¾ªç¯ä½¿ç”¨çš„æ …æ ï¼Œå½“ä¸€ç»„çº¿ç¨‹éƒ½åˆ°é½åï¼ŒCyclicBarrier è¿›è¡Œä¸‹ä¸€ä¸ªå¾ªç¯ï¼Œä¸‹ä¸€ç»„çº¿ç¨‹è¿›è¡ŒåŒæ ·çš„æ“ä½œã€‚ æºç åˆ†æCyclicBarrier çš„å­—é¢æ„æ€æ˜¯å¯å¾ªç¯ä½¿ç”¨çš„æ …æ ï¼Œå› ä¸ºå®ƒçš„æ …æ å¯ä»¥é‡å¤ä½¿ç”¨ï¼ˆé€šè¿‡é‡ç½®å…³é”®å±æ€§ï¼‰ã€‚å®ƒè¦åšçš„äº‹æƒ…æ˜¯ï¼Œè®©ä¸€ç»„çº¿ç¨‹åˆ°è¾¾ä¸€ä¸ªæ …æ ï¼ˆæ˜¯ä¸€ä¸ªåŒæ­¥ç‚¹ï¼‰æ—¶è¢«é˜»å¡ï¼Œç›´åˆ°æœ€åä¸€ä¸ªçº¿ç¨‹åˆ°è¾¾æ …æ æ—¶ï¼Œæ …æ æ‰ä¼šæ‰“å¼€ï¼Œæ‰€æœ‰è¢«æ …æ æ‹¦æˆªçš„çº¿ç¨‹æ‰èƒ½ç»§ç»­è¿è¡Œã€‚å®ƒçš„åŠŸèƒ½æ˜¯é€šè¿‡ç»„åˆ ReentrantLock å’Œ Condition æ¥è¾¾åˆ°çš„ã€‚æˆ‘ä»¬è¿˜æ˜¯åŸºäºä½¿ç”¨ä¾‹å­æ¥åˆ†ææºç ã€‚ å±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class CyclicBarrier &#123; /** * æ …æ æ‰€å¤„çš„ä»£ã€‚æ …æ ä¸Šé˜»å¡çš„çº¿ç¨‹è¢«å”¤é†’æˆ–è€…æ …æ è¢«é‡ç½®ï¼Œå°±å¼€å¯æ–°çš„ä¸€ä»£ */ private static class Generation &#123; // æ …æ æ˜¯å¦è¢«æ‰“ç ´ï¼Œé»˜è®¤ä¸º false boolean broken = false; &#125; /** * é” */ private final ReentrantLock lock = new ReentrantLock(); /** * é”å¯¹åº”çš„æ¡ä»¶ï¼Œé˜»å¡çº¿ç¨‹åœ¨æ …æ æˆ–è€…å”¤é†’é˜»å¡åœ¨æ …æ ä¸Šçš„çº¿ç¨‹ */ private final Condition trip = lock.newCondition(); /** * æ …æ è¦æ‹¦æˆªçš„çº¿ç¨‹æ•° */ private final int parties; /** * ä¸€ç»„çº¿ç¨‹éƒ½åˆ°è¾¾æ …æ åä¼˜å…ˆæ‰§è¡Œçš„ä»»åŠ¡ï¼Œå³å¦‚æœè®¾ç½®è¿™ä¸ªè¿™ä¸ªä»»åŠ¡ï¼Œé‚£ä¹ˆè¢«é˜»å¡åœ¨æ …æ ä¸Šçš„çº¿ç¨‹è¦ç­‰è¿™ä¸ªä»»åŠ¡ç»“æŸåæ‰èƒ½è¢«å”¤é†’ã€‚æ³¨æ„ï¼Œè¿™ä¸ªä»»åŠ¡æ˜¯è¢«æœ€ååˆ°è¾¾çš„çº¿ç¨‹æ‰§è¡Œ */ private final Runnable barrierCommand; /** * å½“å‰æ …æ æ‰€å¤„çš„ä»£ï¼Œå¦‚æœç¬¬ä¸€æ¬¡å°±æ˜¯ 1 ä»£ï¼Œå¦‚æœç¬¬2æ¬¡ä½¿ç”¨å°±æ˜¯ 2 ä»£ */ private Generation generation = new Generation(); /** * è¿˜è¦ç­‰å¾…çš„çº¿ç¨‹æ•°ï¼Œå³è¿˜æ²¡æœ‰åˆ°æ …æ çš„çº¿ç¨‹æ•°ã€‚è¿™ä¸ªåˆå§‹å€¼ æ˜¯ parties å€¼ï¼Œæ¯ä¸ªçº¿ç¨‹åˆ°æ …æ å°±å‡ 1 */ private int count; // CyclicBarrier é«˜çº§æ„é€ å‡½æ•°ï¼Œæ”¯æŒä¼˜å…ˆæ‰§è¡Œä»»åŠ¡ public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction; &#125; // CyclicBarrier é»˜è®¤çš„æ„é€ æ–¹æ³• public CyclicBarrier(int parties) &#123; this(parties, null); &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; CyclicBarrier é»˜è®¤çš„æ„é€ æ–¹æ³•çš„å‚æ•°è¡¨ç¤ºæ …æ æ‹¦æˆªçš„çº¿ç¨‹æ•°ï¼Œæ¯ä¸ªçº¿ç¨‹è°ƒç”¨ await æ–¹æ³•éƒ½ä¼šå‘Šè¯‰ CyclicBarrier æˆ‘å·²ç»åˆ°è¾¾æ …æ ï¼Œæ­¤æ—¶æ …æ è¦æŠŠæ‹¦æˆªçš„çº¿ç¨‹æ•°å‡ 1 ï¼Œç„¶åé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°è¦æ‹¦æˆªçš„çº¿ç¨‹éƒ½åˆ°è¾¾æ …æ æ—¶ï¼Œæ …æ æ‰ä¼šæ‰“å¼€ï¼Œå³æœ€ååˆ°è¾¾çš„çº¿ç¨‹å”¤é†’é˜»å¡åœ¨æ …æ ä¸Šçš„çº¿ç¨‹ï¼Œç„¶åè¿™ç»„çº¿ç¨‹éƒ½ä» await æ–¹æ³•å¤„ç»§ç»­å¾€ä¸‹æ‰§è¡Œã€‚ CyclicBarrier è¿˜æä¾›ä¸€ä¸ªé«˜çº§æ„é€ å‡½æ•°ï¼Œç”¨äºåœ¨æœ€åä¸€ä¸ªçº¿ç¨‹åˆ°è¾¾æ …æ æ—¶ï¼Œä¼˜å…ˆæ‰§è¡Œçš„ä»»åŠ¡ï¼Œä¾¿äºå¤„ç†å¤æ‚çš„ä¸šåŠ¡åœºæ™¯ã€‚æ³¨æ„ï¼Œæ‰§è¡Œä¼˜å…ˆä»»åŠ¡å…ˆäºå”¤é†’é˜»å¡çº¿ç¨‹ ï¼Œä»£ç ä¸­æ‰€æœ‰ä½“ç°ã€‚ ä¸‹ä¸€ä»£æ …æ 12345678910111213---CyclicBarrier /** * å¼€å¯ä¸‹ä¸€ä»£æ …æ  * 1 å”¤é†’é˜»å¡åœ¨ä¸Šä¸€ä»£æ …æ ä¸Šçš„çº¿ç¨‹ * 2 é‡ç½® count å’Œ generation */ private void nextGeneration() &#123; // signal completion of last generation trip.signalAll(); // set up next generation count = parties; generation = new Generation(); &#125; å¼€å¯ä¸‹ä¸€ä»£æ …æ å¾ˆå¥½ç†è§£ï¼Œå› ä¸ºè¦å¼€å¯ä¸‹ä¸€ä»£æ …æ äº†ï¼Œå½“å‰ä»£æ …æ ä¸Šé˜»å¡çš„çº¿ç¨‹éœ€è¦è¢«å”¤é†’ï¼ŒåŒæ—¶åˆå§‹åŒ–å¥½ä¸‹ä¸€ä»£æ …æ ã€‚ æ‰“ç ´æ …æ 123456789101112---CyclicBarrier /** * æ‰“ç ´æ …æ  */ private void breakBarrier() &#123; // è®¾ç½®æ …æ å·²ç ´æ ‡å¿— generation.broken = true; // é‡ç½® count count = parties; // å”¤é†’é˜»å¡åœ¨æ …æ ä¸Šçš„çº¿ç¨‹ trip.signalAll(); &#125; æ‰“ç ´æ …æ éœ€è¦æ ‡è®°å½“å‰ä»£çš„æ …æ ä¸å¯ç”¨ï¼Œå¹¶ä¸”è¦å”¤é†’é˜»å¡åœ¨è¿™ä¸ªä¸å¯ç”¨çš„æ …æ ä¸Šçš„çº¿ç¨‹ï¼Œå› ä¸ºè¿™é‡Œä¸è¿›è¡Œå”¤é†’çš„è¯ï¼Œé˜»å¡çš„çº¿ç¨‹å°†ä¸€ç›´æŒ‚èµ·ã€‚è¿™é‡Œé‡åˆ¶ count ä¸æ˜ç™½æ˜¯å¹²å˜›çš„ã€‚ await12345678910111213141516171819--- CyclicBarrier // ä¸å¸¦è¶…æ—¶æœºåˆ¶çš„æ–¹æ³•ï¼Œä¾‹å­ä¸­ä½¿ç”¨çš„å°±æ˜¯è¿™ä¸ª public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; // false , 0 return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125; &#125; // å¸¦æœ‰è¶…æ—¶æœºåˆ¶çš„æ–¹æ³•ï¼Œå¦‚æœè¶…è¿‡ç­‰å¾…æ—¶é—´ï¼Œå½“å‰çº¿ç¨‹æ²¡æœ‰è¢«å”¤é†’åˆ™ æŠ›å‡º TimeoutException public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; return dowait(true, unit.toNanos(timeout)); &#125; CyclicBarrier æä¾›äº† await ä¸¤ä¸ªé‡è½½æ–¹æ³•ï¼Œä¸€ä¸ªæ˜¯ä¸å¸¦è¶…æ—¶æœºåˆ¶çš„æ–¹æ³•ï¼Œå¦ä¸€ä¸ªæ˜¯å¸¦æœ‰è¶…æ—¶æœºåˆ¶çš„æ–¹æ³•ã€‚ä¸‹é¢æˆ‘ä»¬åˆ†æ CyclicBarrier æ ¸å¿ƒä»£ç  dowait æ–¹æ³•ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107--- CyclicBarrier private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; // ä½¿ç”¨å¯é‡å…¥é” final ReentrantLock lock = this.lock; // åŠ é” lock.lock(); try &#123; // è·å–æ ‡å¿—ç€å½“å‰æ …æ çš„ ä»£ final Generation g = generation; // æ£€æŸ¥å½“å‰ä»£çš„æ …æ æ˜¯å¦è¢«æ‰“ç ´ï¼Œå¦‚æœå½“å‰ä»£çš„æ …æ è¢«æ‰“ç ´éœ€è¦ æŠ›å‡º BrokenBarrierException å¼‚å¸¸ if (g.broken) throw new BrokenBarrierException(); // æ£€æŸ¥å½“å‰çº¿ç¨‹ä¸­æ–­çŠ¶æ€ï¼Œå¦‚æœè¢«ä¸­æ–­äº†ï¼Œåˆ™è¦æŠ›å‡º InterruptedException å¼‚å¸¸ï¼Œå¹¶ä¸”æ‰“ç ´æ …æ  if (Thread.interrupted()) &#123; breakBarrier(); throw new InterruptedException(); &#125; // é€’å‡ count çš„å€¼ int index = --count; // å¦‚æœ count é€’å‡åçš„å€¼ä¸º 0 ï¼Œè¯´æ˜å½“å‰ä»£çš„æ …æ è¦æ‹¦æˆªçš„æœ€åä¸€ä¸ªçº¿ç¨‹ä¹Ÿåˆ°è¾¾æ …æ  if (index == 0) &#123; // tripped // æ ‡å¿—ä¼˜å…ˆä»»åŠ¡æ˜¯å¦å¤±è´¥ï¼Œé»˜è®¤æ˜¯ false boolean ranAction = false; try &#123; // å¦‚æœæŒ‡å®šäº†ä¼˜å…ˆä»»åŠ¡ï¼Œå°±äº¤ç»™æœ€ååˆ°è¾¾çš„çº¿ç¨‹æ‰§è¡Œ final Runnable command = barrierCommand; if (command != null) command.run(); // è®¾ç½®æ ‡å¿— ranAction = true; // å”¤é†’å½“å‰ä»£çš„æ …æ ä¸Šé˜»å¡çš„ä»»åŠ¡ï¼Œå¹¶å¼€å¯ä¸‹ä¸€ä»£ ï¼ˆæ …æ å¯ä»¥é‡å¤ä½¿ç”¨ï¼‰ nextGeneration(); return 0; &#125; finally &#123; // å¦‚æœæ‰§è¡Œä¼˜å…ˆä»»åŠ¡å¤±è´¥ï¼Œåˆ™æ‰“ç ´æ …æ  if (!ranAction) breakBarrier(); &#125; &#125; // ---------------------- æ‰§è¡Œåˆ°è¿™é‡Œçš„çº¿ç¨‹ä¸æ˜¯æœ€åä¸€ä¸ªçº¿ç¨‹ï¼Œå› æ­¤éœ€è¦é˜»å¡ï¼Œç­‰å¾…æœ€åä¸€ä¸ªçº¿ç¨‹åˆ°æ¥å¹¶å”¤é†’è‡ªå·± ---------------/ // loop until tripped, broken, interrupted, or timed out for (;;) &#123; try &#123; // ä¸å¸¦è¶…æ—¶æœºåˆ¶ if (!timed) // é‡Šæ”¾é”ï¼ŒåŠ å…¥ç­‰å¾…é˜Ÿåˆ— (ConditionObject) trip.await(); // å¸¦è¶…æ—¶æœºåˆ¶ï¼Œå¹¶ä¸”è¶…æ—¶æ—¶é—´ &gt; 0 else if (nanos &gt; 0L) // é‡Šæ”¾é”ï¼ŒåŠ å…¥ç­‰å¾…é˜Ÿåˆ— (ConditionObject)ï¼Œå¦‚æœåˆ°æ—¶é—´è¿˜æ²¡æœ‰è¢«å”¤é†’åˆ™ä¸å†é˜»å¡ nanos = trip.awaitNanos(nanos); // æ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜ï¼Œçº¿ç¨‹è¿›å…¥ç­‰å¾…é˜Ÿåˆ—åè¢«ä¸­æ–­äº† &#125; catch (InterruptedException ie) &#123; // æ …æ ä»æ˜¯è¿›å…¥ç­‰å¾…é˜Ÿåˆ—çš„å‰çš„æ …æ ï¼Œæ­¤æ—¶åº”è¯¥æ‰“ç ´æ …æ ï¼Œå¹¶ä¸”æŠ›å‡ºä¸­æ–­å¼‚å¸¸ if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; // 1 g != generationï¼Œè¯´æ˜æ–°ä¸€ä»£çš„æ …æ ç”Ÿæˆäº†ï¼Œå³æœ€åä¸€ä¸ªçº¿ç¨‹ä¹Ÿåˆ°è¾¾äº†æ …æ ï¼Œæ­¤æ—¶åªéœ€å¤ä½è¢«ä¸­æ–­çº¿ç¨‹çš„ä¸­æ–­æ ‡å¿— // 2 æ …æ è¢«æ‰“ç ´äº†ï¼ˆä¸€å®šè¦æŠ›å‡ºå¼‚å¸¸ï¼‰ï¼Œè¢«æ‰“ç ´å¼‚å¸¸äº¤ç”±åç»­é€»è¾‘å¤„ç†ï¼Œæ­¤æ—¶åªéœ€å¤ä½è¢«ä¸­æ–­çº¿ç¨‹çš„ä¸­æ–­æ ‡å¿— Thread.currentThread().interrupt(); &#125; &#125; // çº¿ç¨‹è¢«å”¤é†’åï¼Œè¿˜æ²¡ä» await æ–¹æ³•è¿”å›æ …æ å°±è¢«æ‰“ç ´äº†ï¼Œç›´æ¥æŠ›å‡ºå¼‚å¸¸ if (g.broken) throw new BrokenBarrierException(); /** * è¿™ä¸ªæ–¹æ³•å¾ˆé‡è¦ï¼Œè¢«å”¤é†’åçš„çº¿ç¨‹æ­£å¸¸é€»è¾‘éƒ½ä¼šä»è¯¥æ–¹æ³•è¿”å›å‡ºå» * 1 æœ€åä¸€ä¸ªçº¿ç¨‹åˆ°è¾¾åä¼šåšä¸‰ä»¶äº‹ï¼šæ‰§è¡Œä¼˜å…ˆä»»åŠ¡ã€å”¤é†’å½“å‰ä»£çš„æ …æ ä¸Šé˜»å¡çš„çº¿ç¨‹ã€å¼€å¯æ …æ çš„ä¸‹ä¸€ä»£ * 2 å½“å‰æ‰€åœ¨çš„æ–¹æ³•æ˜¯åŠ äº† ReentrantLock é”çš„ï¼Œå› æ­¤æˆ‘ä»¬è¦çŸ¥é“ä»¥ä¸‹ä¿¡æ¯ï¼š * 1ï¼‰æœ€åä¸€ä¸ªåˆ°è¾¾çº¿ç¨‹åœ¨æ²¡æœ‰æ‰§è¡Œå®Œä¸‰ä»¶äº‹å‰ï¼Œæ˜¯ä¸ä¼šé‡Šæ”¾é”çš„ * 2ï¼‰å”¤é†’çš„é˜»å¡çº¿ç¨‹å¹¶ä¸èƒ½é©¬ä¸Šä» await æ–¹æ³•è¿”å›ï¼Œå®ƒéœ€è¦å…ˆå»ç«äº‰é”ï¼Œè·å–é”åæ‰èƒ½ä» await æ–¹æ³•è¿”å› * 3ï¼‰å³ä½¿æœ€åä¸€ä¸ªçº¿ç¨‹å¼€å¯äº†æ …æ çš„ä¸‹ä¸€ä»£ï¼Œåœ¨å®ƒæ²¡æœ‰é‡Šæ”¾é”å‰ï¼Œå…¶å®ƒç»„çš„çº¿ç¨‹ä¹Ÿè¦é˜»å¡ï¼Œæ¯”å¦‚ä¾‹å­ä¸­çš„åå››ä¸ªçº¿ç¨‹ * 3 è¢«æœ€åä¸€ä¸ªçº¿ç¨‹å”¤é†’çš„çº¿ç¨‹æ‰§è¡Œåˆ°è¿™é‡Œæ—¶ï¼Œæ–°ä¸€ä»£çš„æ …æ ä¸€å®šå·²ç»å­˜åœ¨äº†ã€‚æ³¨æ„ï¼Œè¿™é‡Œè¯´çš„æ˜¯è¢«æœ€åä¸€ä¸ªçº¿ç¨‹å”¤é†’çš„çº¿ç¨‹ï¼Œå¹¶ä¸æ˜¯ç”±äºè¶…æ—¶æœºåˆ¶é†’æ¥çš„çº¿ç¨‹ */ if (g != generation) return index; // è¶…æ—¶æœºåˆ¶é†’æ¥çš„çº¿ç¨‹ï¼Œå¦‚æœå‘ç°å·²ç»è¶…æ—¶äº†ï¼Œåˆ™æ‰“ç ´æ …æ ï¼ŒæŠ›å‡ºå¼‚å¸¸ if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; æ¶‰åŠåˆ°çš„æºç å·²ç»åˆ†æè¿‡äº†ï¼Œä¸‹é¢ç»“åˆä½¿ç”¨ä¾‹å­ç®€å•åˆ†æä¸‹è¿‡ç¨‹ CyclicBarrier æ•´ä¸ªè¿‡ç¨‹è¿˜æ˜¯æŒºæ¸…æ™°çš„ï¼Œæ²¡æœ‰ä½¿ç”¨ CAS é‡è¯•ç­‰æœºåˆ¶ï¼Œå› ä¸ºæ …æ ç­‰å¾…çº¿ç¨‹çš„ await æ–¹æ³•ç›´æ¥ä½¿ç”¨äº†ReentrantLock é”ï¼Œçº¿ç¨‹è¦åˆ°è¾¾æ …æ å¿…é¡»æ‹¿åˆ°é”æ‰è¡Œï¼Œæ•´ä¸ªè¿‡ç¨‹æ˜¯ä¸²è¡ŒåŒ–çš„ã€‚åˆ†æå®Œæ ¸å¿ƒæ–¹æ³•åï¼Œæˆ‘ä»¬å†çœ‹ä¸‹å…¶å®ƒå‡ ä¸ªæ–¹æ³•ã€‚ 12345678910111213141516171819202122232425262728293031323334--- CyclicBarrier // é‡ç½®æ …æ  public void reset() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; breakBarrier(); // break the current generation nextGeneration(); // start a new generation &#125; finally &#123; lock.unlock(); &#125; &#125; // åœ¨æ …æ ä¸Šç­‰å¾…çº¿ç¨‹æ•° public int getNumberWaiting() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return parties - count; &#125; finally &#123; lock.unlock(); &#125; &#125; // åˆ¤æ–­æ …æ æ˜¯å¦è¢«æ‰“ç ´ public boolean isBroken() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return generation.broken; &#125; finally &#123; lock.unlock(); &#125;&#125; å°ç»“CyclicBarrier å’Œ CountDownLatch è¿˜æ˜¯æœ‰ç‚¹åƒçš„ï¼Œå‰è€…å¼ºè°ƒçš„æ˜¯ä¸€ç»„çº¿ç¨‹åˆ°è¾¾åŒæ­¥ç‚¹å³æ …æ ï¼Œåè€…å¼ºè°ƒçš„æ˜¯é˜»å¡åœ¨åŒæ­¥ç‚¹çš„çº¿ç¨‹ç­‰å¾…å…¶å®ƒçº¿ç¨‹å®Œæˆä»»åŠ¡ã€‚å…·ä½“åŒºåˆ«å¦‚ä¸‹ï¼š ä½œç”¨ä¸åŒCyclicBarrier è¦ç­‰å›ºå®šæ•°é‡çº¿ç¨‹åˆ°è¾¾åŒæ­¥ç‚¹ï¼ŒCountDownLatch ç­‰å¾…çš„ä¸æ˜¯çº¿ç¨‹è€Œæ˜¯åŒæ­¥çŠ¶æ€stateé€’å‡ä¸º 0ã€‚å‰è€…é’ˆå¯¹çº¿ç¨‹ï¼Œåè€…é’ˆå¯¹äº‹ä»¶/ä»»åŠ¡ï¼ˆæ ¹æ®éœ€è¦è°ƒç”¨ countDown æ–¹æ³•ï¼‰ã€‚ é‡ç”¨æ€§ä¸åŒCyclicBarrier å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œä¸Šä¸€ä»£ä½¿ç”¨å®Œåè‡ªåŠ¨åˆå§‹åŒ–ä¸‹ä¸€ä»£ï¼Œä¹Ÿå¯ä»¥è°ƒç”¨ reset æ–¹æ³•é‡ç½®ã€‚ CountDownLatch åªèƒ½ä½¿ç”¨ä¸€æ¬¡ï¼Œåœ¨åŒæ­¥çŠ¶æ€å‡ä¸º 0 åé—¨æ “æ‰“å¼€åï¼Œå°±ä¸èƒ½å†æ¬¡ä½¿ç”¨ï¼Œæƒ³è¦ä½¿ç”¨éœ€è¦æ–°å»ºå®ä¾‹ã€‚ å”¤èµ·ä»»åŠ¡æ•°ä¸åŒCyclicBarrier åªèƒ½å”¤é†’ä¸€ä¸ªä»»åŠ¡ï¼ŒCountDownLatch å¯ä»¥å”¤é†’å¤šä¸ªä»»åŠ¡ Semaphoreä½¿ç”¨ä¾‹å­åœºæ™¯ æœ‰ä¸€äº›åŠ å·¥å‚æ˜¯å¯¹ç¯å¢ƒæœ‰å¾ˆå¤§æ±¡æŸ“çš„ï¼Œå¦‚æœè¦ç”Ÿäº§äº§å“å¿…é¡»è¦æœ‰å…³æœºæ„ç”³è¯·ç”Ÿäº§è®¸å¯è¯ï¼Œæ‹¿åˆ°è®¸å¯è¯åæ‰å¯ä»¥ç”Ÿäº§ï¼Œå®Œæˆä¸€å®šè§„æ¨¡åéœ€è¦å½’è¿˜è®¸å¯è¯ï¼Œä¾¿äºå…¶å®ƒå·¥å‚å¯ä»¥ç”³è¯·ã€‚ 123456789101112131415161718192021222324252627282930313233343536@Slf4jpublic class SemaphoreDemo &#123; /** * å›ºå®šçº¿ç¨‹æ•°çº¿ç¨‹æ±  */ public static ExecutorService service = Executors.newFixedThreadPool(10); public static void main(String[] args) &#123; // æœ‰ 3 ä¸ªè®¸å¯è¯ä¹¦ï¼Œæ¯ä¸ªåŠ å·¥å‚å…¬å¹³è·å–ã€‚ Semaphore semaphore = new Semaphore(3, true); // æœ‰ 6 ä¸ªåŠ å·¥å‚æƒ³è¦è·å– for (int i = 0; i &lt; 6; i++) &#123; service.submit(() -&gt; &#123; try &#123; // è·å–è®¸å¯è¯ semaphore.acquire(); log.info(\"æ‹¿åˆ°äº†è®¸å¯è¯\"); // å¤„ç†ä»»åŠ¡ log.warn(\"å‡­å€Ÿè®¸å¯è¯å¤„ç†ä»»åŠ¡...\"); Thread.sleep((long) (Math.random() * 10000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; log.info(\"å½’è¿˜è®¸å¯è¯\"); semaphore.release(); &#125; &#125;); &#125; &#125;&#125; æ‰“å°ç»“æœ 123456789101112131415161718[pool-1-thread-1] INFO com.code.juc.tool.SemaphoreDemo - æ‹¿åˆ°äº†è®¸å¯è¯[pool-1-thread-1] WARN com.code.juc.tool.SemaphoreDemo - å‡­å€Ÿè®¸å¯è¯å¤„ç†ä»»åŠ¡...[pool-1-thread-2] INFO com.code.juc.tool.SemaphoreDemo - æ‹¿åˆ°äº†è®¸å¯è¯[pool-1-thread-2] WARN com.code.juc.tool.SemaphoreDemo - å‡­å€Ÿè®¸å¯è¯å¤„ç†ä»»åŠ¡...[pool-1-thread-3] INFO com.code.juc.tool.SemaphoreDemo - æ‹¿åˆ°äº†è®¸å¯è¯[pool-1-thread-3] WARN com.code.juc.tool.SemaphoreDemo - å‡­å€Ÿè®¸å¯è¯å¤„ç†ä»»åŠ¡...[pool-1-thread-3] INFO com.code.juc.tool.SemaphoreDemo - å½’è¿˜è®¸å¯è¯[pool-1-thread-4] INFO com.code.juc.tool.SemaphoreDemo - æ‹¿åˆ°äº†è®¸å¯è¯[pool-1-thread-4] WARN com.code.juc.tool.SemaphoreDemo - å‡­å€Ÿè®¸å¯è¯å¤„ç†ä»»åŠ¡...[pool-1-thread-1] INFO com.code.juc.tool.SemaphoreDemo - å½’è¿˜è®¸å¯è¯[pool-1-thread-5] INFO com.code.juc.tool.SemaphoreDemo - æ‹¿åˆ°äº†è®¸å¯è¯[pool-1-thread-5] WARN com.code.juc.tool.SemaphoreDemo - å‡­å€Ÿè®¸å¯è¯å¤„ç†ä»»åŠ¡...[pool-1-thread-4] INFO com.code.juc.tool.SemaphoreDemo - å½’è¿˜è®¸å¯è¯[pool-1-thread-6] INFO com.code.juc.tool.SemaphoreDemo - æ‹¿åˆ°äº†è®¸å¯è¯[pool-1-thread-6] WARN com.code.juc.tool.SemaphoreDemo - å‡­å€Ÿè®¸å¯è¯å¤„ç†ä»»åŠ¡...[pool-1-thread-2] INFO com.code.juc.tool.SemaphoreDemo - å½’è¿˜è®¸å¯è¯[pool-1-thread-6] INFO com.code.juc.tool.SemaphoreDemo - å½’è¿˜è®¸å¯è¯[pool-1-thread-5] INFO com.code.juc.tool.SemaphoreDemo - å½’è¿˜è®¸å¯è¯ è¯´æ˜ ä»¥ä¸Šä¾‹å­ä¸­ï¼Œä½¿ç”¨å¾ªç¯ä½“å’Œçº¿ç¨‹æ± æ¨¡æ‹Ÿ 6 ä¸ªçº¿ç¨‹ï¼Œå³ 6 ä¸ªåŠ å·¥å‚è·å–ç”Ÿäº§è®¸å¯è¯ã€‚Semaphore çš„è®¸å¯è¯æ•°é‡ä¸º 3ï¼Œå³ç›‘ç®¡éƒ¨é—¨ç›®å‰åªæœ‰ 3 ä¸ªç”Ÿäº§è®¸å¯è¯ï¼Œæ­¤æ—¶ 6 ä¸ªå·¥å‚åªèƒ½æœ‰å…¶ä¸­ä¸‰ä¸ªå¯ä»¥è·å–åˆ°ï¼Œå¦å¤– 3 ä¸ªå·¥å‚åªèƒ½ç­‰å¾…ç”Ÿäº§è®¸å¯è¯çš„å½’è¿˜ï¼Œå¦‚æœä¸å½’è¿˜å°†ä¸€ç›´ç­‰ç€ã€‚ æºç åˆ†æSemaphore æ˜¯ç”¨æ¥æ§åˆ¶åŒæ—¶è®¿é—®ç‰¹å®šèµ„æºçš„çº¿ç¨‹æ•°é‡ï¼Œå®ƒé€šè¿‡åè°ƒå„ä¸ªçº¿ç¨‹æ¥ä¿è¯åˆç†çš„ä½¿ç”¨æœ‰é™çš„å…¬å…±èµ„æºã€‚Semaphore ä¹Ÿæ˜¯å¯¹ AQS å…±äº«æ¨¡å¼çš„ä½¿ç”¨ï¼Œå› æ­¤å¥—è·¯ä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚å®ƒæ¥æ”¶ä¸€ä¸ªæ•´å½¢çš„æ•°å­— permitsï¼Œä¹Ÿæ˜¯ AQS çš„ stateï¼Œè¡¨ç¤ºå¯ç”¨çš„è®¸å¯è¯æ•°é‡ï¼Œå³å…è®¸ permits ä¸ªçº¿ç¨‹è·å–è®¸å¯è¯ï¼Œä¹Ÿå°±æ˜¯æœ€å¤§å¹¶å‘æ•°æ˜¯ permitsã€‚å› ä¸ºæ˜¯å…±äº«æ¨¡å¼çš„ä½¿ç”¨ï¼Œå› æ­¤éœ€è¦é‡å†™å¯¹åº”çš„æ¨¡ç‰ˆæ–¹æ³• tryAcquireShared å’Œ tryReleaseShared ï¼Œå‰è€…ç”¨æ¥åˆ¤æ–­èƒ½å¦è·å–åˆ°è®¸å¯è¯ï¼Œåè€…ç”¨æ¥åˆ¤æ–­èƒ½å¦å½’è¿˜è®¸å¯æ•´ï¼ˆæ€»æ˜¯è¿”å›trueï¼‰ã€‚æ­¤å¤–ï¼ŒSemaphore åœ¨æ­¤åŸºç¡€ä¸Šå¢åŠ äº†å…¬å¹³å’Œéå…¬å¹³è·å–åŒæ­¥çŠ¶æ€çš„åŠŸèƒ½ã€‚Semaphore çš„ç”¨æ³•å¾ˆç®€å•ï¼Œå®ƒçš„ acquire æ–¹æ³•è·å–è®¸å¯è¯ï¼Œrelease æ–¹æ³•å½’è¿˜è®¸å¯è¯ï¼Œè·å–ä¸åˆ°è®¸å¯è¯çš„çº¿ç¨‹å°±åŠ å…¥é˜»å¡é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…å…¶å®ƒçº¿ç¨‹é‡Šæ”¾è®¸å¯è¯ã€‚ ç±»ç»“æ„ å‰é¢ä¹Ÿæåˆ°äº†ï¼ŒSemaphore æ˜¯å¯¹ AQS å…±äº«æ¨¡å¼çš„ä½¿ç”¨ï¼Œå¹¶ä¸”æ”¯æŒå…¬å¹³å’Œéå…¬å¹³çš„çŠ¶æ€ç®¡ç†æ–¹å¼ï¼Œå³å¯¹åŒæ­¥çŠ¶æ€ state çš„æ“ä½œã€‚é€šè¿‡ä¸Šå›¾çš„ UML ç±»å›¾æ›´åŠ æ¸…æ™°ï¼ŒSemaphore æ—¢å¯ä»¥å…¬å¹³å®ç°æ–¹å¼åˆ›å»ºå¯¹è±¡ï¼Œåˆèƒ½ä»¥éå…¬å¹³æ–¹å¼åˆ›å»ºå¯¹è±¡ã€‚ Sync å†…éƒ¨ç±»123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Semaphore implements java.io.Serializable &#123; private static final long serialVersionUID = -3222578661600680210L; /** * ç»§æ‰¿ AQS çš„å†…éƒ¨ç±»å¯¹è±¡ */ private final Sync sync; /** * ä¿¡å·é‡çš„åŒæ­¥å®ç°ã€‚ä½¿ç”¨ AQS çš„åŒæ­¥çŠ¶æ€ state è¡¨ç¤ºè®¸å¯è¯ã€‚åˆ†ä¸º å…¬å¹³å’Œéå…¬å¹³ä¸¤ç§å®ç° */ abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 1192457210091910933L; // æ„é€ æ–¹æ³•ï¼Œè®¾ç½® AQS çš„åŒæ­¥çŠ¶æ€ stateã€‚å¯¹äº Semaphore æ¥è¯´è¡¨ç¤ºè®¸å¯è¯ Sync(int permits) &#123; setState(permits); &#125; // è·å–åŒæ­¥çŠ¶æ€ï¼Œå³è®¸å¯è¯ final int getPermits() &#123; return getState(); &#125; // éå…¬å¹³å®ç°ï¼Œå…±äº«å¼è·å–è®¸å¯è¯ã€‚è¿”å›å‰©ä½™è®¸å¯è¯æ•°é‡ final int nonfairTryAcquireShared(int acquires) &#123; for (; ; ) &#123; int available = getState(); // å‡å°‘ acquires ä¸ªè®¸å¯è¯ int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125; // é‡å†™ AQS çš„å…±äº«å¼é‡Šæ”¾åŒæ­¥çŠ¶æ€æ–¹æ³•ï¼Œå³å½’è¿˜è®¸å¯è¯ã€‚è¯¥æ–¹æ³•æ€»æ˜¯è¿”å› true protected final boolean tryReleaseShared(int releases) &#123; for (; ; ) &#123; int current = getState(); // å½’è¿˜ releases ä¸ªè®¸å¯è¯ (æ³¨æ„ï¼Œå¦‚æœä¸è·å–å…ˆé‡Šæ”¾çš„è¯ï¼Œè®¸å¯è¯ä¼šå˜å¤šçš„) int next = current + releases; // è¿™é‡Œåˆ¤æ–­å½’è¿˜æ•°é‡ä¸èƒ½å°äº 0 if (next &lt; current) // overflow throw new Error(\"Maximum permit count exceeded\"); // CAS æ›´æ–° state ï¼ˆAQS ä¸­çš„æ–¹æ³• ï¼‰ if (compareAndSetState(current, next)) return true; &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; Sync å†…éƒ¨ç±»é¦–å…ˆå¯¹åŒæ­¥çŠ¶æ€ state è¿›è¡Œäº†åˆå§‹åŒ–ï¼Œå…ˆç¡®å®šåŒæ­¥çŠ¶æ€ state çš„å€¼ï¼Œå³è¡¨ç¤ºçš„æ„ä¹‰ï¼Œè¿™é‡ŒæŒ‡è®¸å¯è¯ã€‚ç¬¬äºŒä¸ªæ˜¯è·å–åŒæ­¥çŠ¶æ€ - tryAcquireSharedï¼Œè¿™é‡ŒæŒ‡è·å–è®¸å¯è¯ï¼ŒSync ä¸­æ²¡æœ‰è¿›è¡Œå®ç°è€Œæ˜¯äº¤ç»™äº†ä¸¤ä¸ªå­ç±»ã€‚ç¬¬ä¸‰ä¸ªæ˜¯é‡Šæ”¾åŒæ­¥çŠ¶æ€ - tryReleaseSharedï¼Œè¿™é‡ŒæŒ‡å½’è¿˜è®¸å¯è¯ï¼ŒSync ä¸­ç»Ÿä¸€å®ç°äº†è¿™ä¸ªé€»è¾‘ã€‚ä¸‹é¢æˆ‘ä»¬åˆ†åˆ«çœ‹ä¸‹å…¶å­ç±»å®ç°ã€‚ NonfairSync å†…éƒ¨ç±»1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Semaphore implements java.io.Serializable &#123; private static final long serialVersionUID = -3222578661600680210L; /** * ç»§æ‰¿ AQS çš„å†…éƒ¨ç±»å¯¹è±¡ */ private final Sync sync; /** * ä¿¡å·é‡çš„åŒæ­¥å®ç°ã€‚ä½¿ç”¨ AQS çš„åŒæ­¥çŠ¶æ€ state è¡¨ç¤ºè®¸å¯è¯ã€‚åˆ†ä¸º å…¬å¹³å’Œéå…¬å¹³ä¸¤ç§å®ç° */ abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 1192457210091910933L; // æ„é€ æ–¹æ³•ï¼Œè®¾ç½® AQS çš„åŒæ­¥çŠ¶æ€ stateã€‚å¯¹äº Semaphore æ¥è¯´è¡¨ç¤ºè®¸å¯è¯ Sync(int permits) &#123; setState(permits); &#125; // è·å–åŒæ­¥çŠ¶æ€ï¼Œå³è®¸å¯è¯ final int getPermits() &#123; return getState(); &#125; // éå…¬å¹³å®ç°è¦æ‰§è¡Œçš„æ–¹æ³•ï¼Œå…±äº«å¼è·å–è®¸å¯è¯ã€‚è¿”å›å‰©ä½™è®¸å¯è¯æ•°é‡ final int nonfairTryAcquireShared(int acquires) &#123; for (; ; ) &#123; int available = getState(); // å‡å°‘ acquires ä¸ªè®¸å¯è¯ int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125; // é‡å†™ AQS çš„å…±äº«å¼é‡Šæ”¾åŒæ­¥çŠ¶æ€æ–¹æ³•ï¼Œå³å½’è¿˜è®¸å¯è¯ã€‚è¯¥æ–¹æ³•æ€»æ˜¯è¿”å› true protected final boolean tryReleaseShared(int releases) &#123; for (; ; ) &#123; int current = getState(); // å½’è¿˜ releases ä¸ªè®¸å¯è¯ (æ³¨æ„ï¼Œå¦‚æœä¸è·å–å…ˆé‡Šæ”¾çš„è¯ï¼Œè®¸å¯è¯ä¼šå˜å¤šçš„) int next = current + releases; // è¿™é‡Œåˆ¤æ–­å½’è¿˜æ•°é‡ä¸èƒ½å°äº 0 if (next &lt; current) // overflow throw new Error(\"Maximum permit count exceeded\"); // CAS æ›´æ–° state ï¼ˆAQS ä¸­çš„æ–¹æ³• ï¼‰ if (compareAndSetState(current, next)) return true; &#125; &#125; /** * éå…¬å¹³å®ç° */ static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L; // æ„é€ æ–¹æ³• NonfairSync(int permits) &#123; super(permits); &#125; // é‡å†™ AQS çš„å…±äº«å¼è·å–åŒæ­¥çŠ¶æ€çš„æ–¹æ³•ï¼Œè¿™é‡Œæ˜¯éå…¬å¹³æ–¹å¼è·å–è®¸å¯è¯ protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires); &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; NonfairSync å†…éƒ¨ç±»åªåšäº†ä¸€ä»¶äº‹æƒ…ï¼Œé‡å†™ AQS çš„ tryAcquireShared æ–¹æ³•ï¼Œéœ€è¦æ³¨æ„å®ƒçš„éå…¬å¹³æ€§ï¼Œä¹Ÿå°±æ˜¯ä¸å…³å¿ƒé˜»å¡é˜Ÿåˆ—ä¸­æœ‰æ²¡æœ‰è¿˜åœ¨ç­‰å¾…çš„çº¿ç¨‹ï¼Œç›´æ¥å°è¯•è·å–è®¸å¯è¯ã€‚ FairSync å†…éƒ¨ç±»123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class Semaphore implements java.io.Serializable &#123; private static final long serialVersionUID = -3222578661600680210L; /** * ç»§æ‰¿ AQS çš„å†…éƒ¨ç±»å¯¹è±¡ */ private final Sync sync; /** * ä¿¡å·é‡çš„åŒæ­¥å®ç°ã€‚ä½¿ç”¨ AQS çš„åŒæ­¥çŠ¶æ€ state è¡¨ç¤ºè®¸å¯è¯ã€‚åˆ†ä¸º å…¬å¹³å’Œéå…¬å¹³ä¸¤ç§å®ç° */ abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 1192457210091910933L; // æ„é€ æ–¹æ³•ï¼Œè®¾ç½® AQS çš„åŒæ­¥çŠ¶æ€ stateã€‚å¯¹äº Semaphore æ¥è¯´è¡¨ç¤ºè®¸å¯è¯ Sync(int permits) &#123; setState(permits); &#125; // è·å–åŒæ­¥çŠ¶æ€ï¼Œå³è®¸å¯è¯ final int getPermits() &#123; return getState(); &#125; // éå…¬å¹³å®ç°ï¼Œå…±äº«å¼è·å–è®¸å¯è¯ã€‚è¿”å›å‰©ä½™è®¸å¯è¯æ•°é‡ final int nonfairTryAcquireShared(int acquires) &#123; for (; ; ) &#123; int available = getState(); // å‡å°‘ acquires ä¸ªè®¸å¯è¯ int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125; // é‡å†™ AQS çš„å…±äº«å¼é‡Šæ”¾åŒæ­¥çŠ¶æ€æ–¹æ³•ï¼Œå³å½’è¿˜è®¸å¯è¯ã€‚è¯¥æ–¹æ³•æ€»æ˜¯è¿”å› true protected final boolean tryReleaseShared(int releases) &#123; for (; ; ) &#123; int current = getState(); // å½’è¿˜ releases ä¸ªè®¸å¯è¯ (æ³¨æ„ï¼Œå¦‚æœä¸è·å–å…ˆé‡Šæ”¾çš„è¯ï¼Œè®¸å¯è¯ä¼šå˜å¤šçš„) int next = current + releases; // è¿™é‡Œåˆ¤æ–­å½’è¿˜æ•°é‡ä¸èƒ½å°äº 0 if (next &lt; current) // overflow throw new Error(\"Maximum permit count exceeded\"); // CAS æ›´æ–° state ï¼ˆAQS ä¸­çš„æ–¹æ³• ï¼‰ if (compareAndSetState(current, next)) return true; &#125; &#125; /** * éå…¬å¹³å®ç° */ static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L; // æ„é€ æ–¹æ³• NonfairSync(int permits) &#123; super(permits); &#125; // é‡å†™ AQS çš„å…±äº«å¼è·å–åŒæ­¥çŠ¶æ€çš„æ–¹æ³•ï¼Œè¿™é‡Œæ˜¯éå…¬å¹³æ–¹å¼è·å–è®¸å¯è¯ protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires); &#125; &#125; /** * å…¬å¹³å®ç° */ static final class FairSync extends Sync &#123; private static final long serialVersionUID = 2014338818796000944L; // æ„é€ æ–¹æ³• FairSync(int permits) &#123; super(permits); &#125; // é‡å†™ AQS çš„å…±äº«å¼è·å–åŒæ­¥çŠ¶æ€çš„æ–¹æ³•ï¼Œ è¿™é‡Œæ˜¯ å…¬å¹³æ–¹å¼è·å–è®¸å¯è¯ã€‚è¿”å›å‰©ä½™è®¸å¯è¯æ•° protected int tryAcquireShared(int acquires) &#123; for (; ; ) &#123; // æ˜¯å¦æœ‰çº¿ç¨‹åœ¨æ’é˜Ÿç­‰å¾…è®¸å¯è¯ if (hasQueuedPredecessors()) return -1; int available = getState(); // å‡å°‘ acquires ä¸ªè®¸å¯è¯ int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; FairSync å†…éƒ¨ç±»åŒæ ·åªåšäº†ä¸€ä»¶äº‹æƒ…ï¼Œé‡å†™ AQS çš„ tryAcquireShared æ–¹æ³•ï¼Œä»¥å…¬å¹³çš„æ–¹å¼å®ç°ï¼Œä¹Ÿå°±æ˜¯çº¿ç¨‹åœ¨è·å–è®¸å¯è¯ä¹‹å‰ï¼Œå…ˆåˆ¤æ–­é˜»å¡é˜Ÿåˆ—ä¸­æ˜¯å¦è¿˜æœ‰ç­‰å¾…çš„çº¿ç¨‹ï¼Œæœ‰çš„è¯å°±ç›´æ¥è¿”å› -1 è¿›å…¥é˜»å¡é˜Ÿåˆ—ä¸­ç­‰å¾…ã€‚ æ„é€ æ–¹æ³•12345678910111213/** * ä»¥éå…¬å¹³æ–¹å¼åˆ›å»º Semaphore */ public Semaphore(int permits) &#123; sync = new NonfairSync(permits); &#125; /** * å¯é€‰æ‹©å…¬å¹³/éå…¬å¹³æ–¹å¼åˆ›å»º Semaphore */ public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits); &#125; å’Œ ReentrantLock æœ‰ç‚¹ç±»ä¼¼ï¼Œå®ç°äº†å…¬å¹³å’Œéå…¬å¹³æ–¹å¼ï¼Œé»˜è®¤ä½¿ç”¨éå…¬å¹³å®ç°ã€‚ acquire ç³»åˆ—æ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115--- Semaphore /** * å¯å“åº”ä¸­æ–­åœ°è·å–è®¸å¯è¯ï¼ˆè·å–ä¸€ä¸ªè®¸å¯è¯ï¼‰ */ public void acquire() throws InterruptedException &#123; // AQS çš„æ–¹æ³• sync.acquireSharedInterruptibly(1); &#125;--- AbstractQueuedSynchronizer public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); // Semaphore å®ç°çš„è·å–åŒæ­¥çŠ¶æ€ï¼Œå…¬å¹³è¿˜æ˜¯ä¸å…¬å¹³çœ‹Semaphoreçš„å…·ä½“å®ç° if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); &#125; /** * Acquires in shared interruptible mode. * @param arg the acquire argument */ private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // Semaphore å®ç°çš„è·å–åŒæ­¥çŠ¶æ€ï¼Œå…¬å¹³è¿˜æ˜¯ä¸å…¬å¹³çœ‹Semaphoreçš„å…·ä½“å®ç° setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125;--- Semaphore /** * è·å–è®¸å¯è¯ï¼ˆè·å–ä¸€ä¸ªè®¸å¯è¯ï¼‰ï¼Œå¯¹ä¸­æ–­ä¸æ•æ„Ÿ */ public void acquireUninterruptibly() &#123; // AQS çš„æ–¹æ³• sync.acquireShared(1); &#125;--- AbstractQueuedSynchronizer public final void acquireShared(int arg) &#123; // Semaphore å®ç°çš„è·å–åŒæ­¥çŠ¶æ€ï¼Œå…¬å¹³è¿˜æ˜¯ä¸å…¬å¹³çœ‹Semaphoreçš„å…·ä½“å®ç° if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125; /** * Acquires in shared uninterruptible mode. * @param arg the acquire argument */ private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; // Semaphore å®ç°çš„è·å–åŒæ­¥çŠ¶æ€ï¼Œå…¬å¹³è¿˜æ˜¯ä¸å…¬å¹³çœ‹Semaphoreçš„å…·ä½“å®ç° int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // å†…éƒ¨ä¼šè°ƒç”¨ doReleaseShared æ–¹æ³• setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125;--- Semaphore /** * ä» Semaphore è·å–ç»™å®šæ•°é‡çš„è®¸å¯è¯ï¼Œä¸å¤Ÿå°±é˜»å¡ç­‰å¾…ï¼Œå¯¹ä¸­æ–­æ•æ„Ÿ */ public void acquire(int permits) throws InterruptedException &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.acquireSharedInterruptibly(permits); &#125; /** * ä» Semaphore è·å–ç»™å®šæ•°é‡çš„è®¸å¯è¯ï¼Œä¸å¤Ÿå°±é˜»å¡ç­‰å¾…ï¼Œå¯¹ä¸­æ–­ä¸æ•æ„Ÿ */ public void acquireUninterruptibly(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.acquireShared(permits); &#125; é€šè¿‡ acquire æ–¹æ³•ä¹Ÿå¯ä»¥çœ‹å‡ºï¼ŒAQS æ¡†æ¶åœ¨å®ç°å…±äº«å¼è·å–åŒæ­¥çŠ¶æ€æ—¶ï¼Œå½“ä¸”ä»…å½“åŒæ­¥çŠ¶æ€å¤„ç†ç»“æœå°äº 0 æ—¶ï¼Œçº¿ç¨‹æ‰ä¼šèµ°å…¥é˜Ÿæµç¨‹ã€‚å› ä¸ºéƒ½æ˜¯å…±äº«å¼å®ç°ï¼ŒAQS åº•å±‚å¤„ç†æ˜¯ä¸€æ ·çš„ï¼Œå› æ­¤åç»­çš„å…¥é˜Ÿã€æ‰¾æœ‰æ•ˆå‰é©±èŠ‚ç‚¹ä»¥åŠæŒ‚èµ·æ“ä½œå’Œ CountDownLatch æ˜¯ä¸€æ ·çš„ï¼Œå°±ä¸å†åˆ†æäº†ã€‚ç»§ç»­çœ‹å®ƒçš„é‡Šæ”¾åŒæ­¥çŠ¶æ€çš„æ–¹æ³•ã€‚ release ç³»åˆ—æ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546--- Semaphore /** * å½’è¿˜è®¸å¯è¯ */ public void release() &#123; // AQS æ–¹æ³• sync.releaseShared(1); &#125; /** * å½’è¿˜ç»™å®šæ•°é‡çš„è®¸å¯è¯åˆ° Semaphore */ public void release(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); // AQS æ–¹æ³• sync.releaseShared(permits); &#125;--- AbstractQueuedSynchronizer public final boolean releaseShared(int arg) &#123; // Semaphore å®ç°çš„é‡Šæ”¾åŒæ­¥çŠ¶æ€æ–¹æ³• if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false; &#125; private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125; &#125; é€šè¿‡ release ç³»åˆ—æ–¹æ³•ä¹Ÿå¯ä»¥çœ‹å‡ºï¼ŒAQS æ¡†æ¶åœ¨å®ç°å…±äº«å¼é‡Šæ”¾åŒæ­¥çŠ¶æ€æ—¶ï¼Œå½“ä¸”ä»…å½“åŒæ­¥çŠ¶æ€å¤„ç†ç»“æœä¸º true æ—¶ï¼Œæ‰ä¼šå”¤é†’é˜»å¡é˜Ÿåˆ—çš„çº¿ç¨‹ã€‚å› ä¸ºéƒ½æ˜¯å…±äº«å¼å®ç°ï¼ŒAQS åº•å±‚å¤„ç†æ˜¯ä¸€æ ·çš„ï¼Œå› æ­¤å”¤é†’çš„æµç¨‹å’Œ CountDownLatch æ˜¯ä¸€æ ·çš„ã€‚ ä¾‹å­æµç¨‹ Semaphore åˆå§‹åŒ– 3 ä¸ª è®¸å¯è¯åŒä¸€ä¸ªJVMè¿›ç¨‹ä¸­ï¼ŒæŸä¸€æ—¶åˆ»å¯¹ resource è®¿é—®çš„æœ€å¤§å¹¶å‘è¯·æ±‚æ•°ä¸º3 æŸä¸€æ—¶åˆ»t1ã€t2ã€t3è·å–åˆ°è®¸å¯è¯ï¼Œt4è¿›å…¥é˜»å¡é˜Ÿåˆ—ç­‰å¾…çº¿ç¨‹t1ã€t2ã€t3æ‹¿åˆ°è®¸å¯è¯å»è®¿é—®èµ„æºï¼Œæ­¤æ—¶ Semaphore ä¸­å·²ç»æ²¡æœ‰å¯ç”¨çš„è®¸å¯è¯äº†ï¼Œt4åªèƒ½åŠ å…¥é˜»å¡é˜Ÿåˆ—ç­‰å¾…è®¸å¯è¯çš„é‡Šæ”¾ã€‚è¿™é‡Œ t4 è¦å…¥é˜Ÿã€‚ t3 è®¿é—®èµ„æºåå½’è¿˜è®¸å¯è¯ï¼Œt4 è·å–åˆ°è·å–åˆ°è®¸å¯è¯è¿™ä¸ªè¿‡ç¨‹å¯èƒ½ä¼šæœ‰å¤šç§æƒ…å†µï¼Œå¦‚ï¼Œt4 åœ¨æ²¡æœ‰æŒ‚èµ·ä¹‹å‰ï¼Œt3 å·²ç»å½’è¿˜äº†è®¸å¯è¯ï¼Œæ­¤æ—¶ t4 ç›´æ¥å°±å¯ä»¥æ‹¿åˆ°ã€‚å¦‚æœ t4 ä¸å¤ªå¹¸è¿çš„è¯ï¼Œä¼šæŒ‚èµ·ç„¶åç­‰å¾…t3æ¥å”¤é†’ã€‚Semaphore çš„ä¸€äº›ç‰¹æ®Šæƒ…å†µå¯ä»¥å‚è€ƒ CountDownLatchã€‚ å…¶å®ƒçº¿ç¨‹è·å–è®¸å¯è¯ä¾æ¬¡ç±»æ¨ å°ç»“Semaphore ä½¿ç”¨çš„æ³¨æ„äº‹é¡¹ï¼š è·å–å’Œé‡Šæ”¾çš„è®¸å¯è¯æ•°é‡å¿…é¡»ä¸€è‡´ï¼Œå¦åˆ™éšç€è®¸å¯è¯çš„è·å–å’Œå½’è¿˜æµç¨‹æ¨è¿›ï¼Œæœ€åä¼šå¯¼è‡´è®¸å¯è¯æ•°é‡ä¸å¤Ÿï¼Œå°†å‡ºç°ç¨‹åºå¡æ­»ã€‚ åœ¨åˆå§‹åŒ– Semaphore çš„æ—¶å€™å¯ä»¥è®¾ç½®é‡Šæ”¾å…¬å¹³ï¼Œè¿™ä¸ªå¯ä»¥æ ¹æ®æƒ…æ™¯é€‰æ‹©ï¼Œä¸€èˆ¬è®¾ç½®ä¸º true æ›´åˆç†ï¼Œå› ä¸º Semaphore æœ¬èº«å°±æ˜¯é™åˆ¶åŒæ—¶è¯·æ±‚é‡çš„ï¼Œä¸é’ˆå¯¹æŸä¸ªè¯·æ±‚çš„ã€‚ è·å–å’Œé‡Šæ”¾è®¸å¯è¯ä¸ä¸€å®šéè¦åŒä¸€ä¸ªçº¿ç¨‹æ¥å®Œæˆï¼Œå¯ä»¥æ˜¯ çº¿ç¨‹ A è·å–ï¼Œçº¿ç¨‹ B é‡Šæ”¾ï¼Œé€»è¾‘åˆç†å³å¯ã€‚ æ€»ç»“æ— è®ºæ˜¯ ReentrantLockï¼Œè¿˜æ˜¯ CountDownLatchã€CyclicBarrierã€Semaphore ç­‰ ï¼Œå®ƒä»¬éƒ½æ˜¯å¯¹ AQS åº”ç”¨ï¼Œè‡³äºæ˜¯å®ç°é”çš„åŠŸèƒ½ï¼Œè¿˜æ˜¯å®ç°åŒæ­¥ç»„ä»¶æ ¹æ®å…·ä½“åœºæ™¯è¿›è¡Œè®¾è®¡ã€‚æœ¬è´¨ä¸Šéƒ½ç¦»ä¸å¼€åŒæ­¥çŠ¶æ€ stateã€ç‹¬å æ–¹å¼ tryAcquire-tryRelease è·å–ä¸é‡Šæ”¾æ–¹æ³•ï¼Œå…±äº«æ–¹å¼ tryAcquireShared-tryReleaseShared è·å–ä¸é‡Šæ”¾æ–¹æ³•ï¼Œæ­¤å¤– AQS ä¹Ÿæ”¯æŒè‡ªå®šä¹‰åŒæ­¥ç»„ä»¶åŒæ—¶å®ç°ç‹¬å å’Œå…±äº«ä¸¤ç§æ–¹å¼ï¼Œä»¥åŠå…¬å¹³å’Œéå…¬å¹³å®ç°ï¼Œä¸åŒç»„ä»¶è¡¨ç¤ºçš„æ„ä¹‰æ˜¯ä¸åŒçš„ã€‚AQS è¿˜æä¾›äº† ç­‰å¾…é˜Ÿåˆ— æœºåˆ¶ï¼ŒReentrantLock å°±åŸºäºè¯¥æœºåˆ¶å®ç°äº†ç­‰å¾…ä¸å”¤é†’æœºåˆ¶ã€‚","categories":[{"name":"JDK","slug":"JDK","permalink":"https://gentryhuang.com/categories/JDK/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://gentryhuang.com/tags/JUC/"},{"name":"AQS","slug":"AQS","permalink":"https://gentryhuang.com/tags/AQS/"}]},{"title":"AQS åŸç†åˆ†æ - Conditionå®ç°åŸç†","slug":"concurrent/aqs-condition","date":"2020-10-26T13:45:45.000Z","updated":"2021-01-04T08:50:29.888Z","comments":false,"path":"posts/40e44c1f/","link":"","permalink":"https://gentryhuang.com/posts/40e44c1f/","excerpt":"","text":"æ¦‚è¿°åœ¨ JUC ä¹‹å‰ï¼ŒJava å®ç°ç­‰å¾…/é€šçŸ¥æ¨¡å¼æ˜¯é€šè¿‡å®šä¹‰åœ¨ Object ä¸­çš„ä¸€ç»„ç›‘è§†å™¨æ–¹æ³• waitæ–¹æ³•ã€notify()ä»¥åŠ notifyAll() ä¸ synchronized å…³é”®é…åˆå®Œæˆã€‚åœ¨ JUC ä¸­å•ç‹¬æä¾›äº†ä¸€å¥—ç­‰å¾…/é€šçŸ¥æ¨¡å¼çš„å®ç°æ–¹å¼ï¼Œå…·ä½“å®ç°æ˜¯ Condition æ¥å£ä¸ Lock æ¥å£é…åˆå®Œæˆã€‚ Condition æ¥å£æä¾›äº†ç±»ä¼¼ Object çš„ç›‘è§†å™¨æ–¹æ³•ï¼Œä½†è¯¥æ¥å£ä¸­å®šä¹‰çš„æ–¹æ³•åŠŸèƒ½ä¸Šæ›´å¼ºå¤§ã€‚æ¯”å¦‚ï¼ŒCondition æ”¯æŒå“åº”/ä¸å“åº”ä¸­æ–­ä»¥åŠç­‰å¾…è¶…æ—¶ç­‰æ¥å£ã€‚ åœºæ™¯ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ˜¯ Condition å…¶ä¸­çš„ä¸€ä¸ªç»å…¸ä½¿ç”¨åœºæ™¯ï¼Œä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class BoundedBuffer &#123; /** * é” */ final Lock lock = new ReentrantLock(); /** * notFull Condition */ final Condition notFull = lock.newCondition(); /** * notEmpty Condition */ final Condition notEmpty = lock.newCondition(); /** * æ•°ç»„ï¼Œå¤§å°ä¸º 100 */ final Object[] items = new Object[100]; /** * åˆ†åˆ«ä¸ºæ·»åŠ çš„ä¸‹æ ‡ã€ç§»é™¤çš„ä¸‹æ ‡å’Œæ•°ç»„å½“å‰æ•°é‡ */ int putptr, takeptr, count; /** * ç”Ÿäº§ * å¦‚æœæ•°ç»„æ»¡äº†ï¼Œåˆ™æ·»åŠ çº¿ç¨‹è¿›å…¥ç­‰å¾…çŠ¶æ€ï¼Œç›´åˆ°æœ‰ç©ºä½æ‰èƒ½ç”Ÿäº§ * * @param x item * @throws InterruptedException */ public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; // å…ƒç´ æ•°é‡ç­‰äºæ•°ç»„é•¿åº¦ï¼Œçº¿ç¨‹ç­‰å¾… while (count == items.length) notFull.await(); // æ·»åŠ å…ƒç´  items[putptr] = x; // æ·»åŠ ä¸‹æ ‡ putptr é€’å¢ï¼Œå’Œç§»é™¤çš„ä¸‹æ ‡ takeptr å¯¹åº”ã€‚ if (++putptr == items.length) putptr = 0; // æ•°ç»„å…ƒç´ ä¸ªæ•°é€’å¢ ++count; // ç”Ÿäº§åé€šçŸ¥æ¶ˆè´¹ notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; /** * æ¶ˆè´¹ * å¦‚æœæ•°ç»„ä¸ºç©ºï¼Œåˆ™æ¶ˆè´¹çº¿ç¨‹è¿›å…¥ç­‰å¾…çŠ¶æ€ï¼Œç›´åˆ°æ•°ç»„ä¸­æœ‰å…ƒç´ æ‰èƒ½ç»§ç»­æ¶ˆè´¹ * * @return item * @throws InterruptedException */ public Object take() throws InterruptedException &#123; lock.lock(); try &#123; // æ•°ç»„ä¸ºç©ºï¼Œçº¿ç¨‹ç­‰å¾… while (count == 0) notEmpty.await(); // å–å‡ºå…ƒç´  Object x = items[takeptr]; // ç§»é™¤ä¸‹æ ‡é€’å¢ if (++takeptr == items.length) takeptr = 0; // æ•°ç»„å…ƒç´ ä¸ªæ•°é€’å‡ --count; // æ¶ˆè´¹åé€šçŸ¥ç”Ÿäº§ notFull.signal(); return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; ä¸Šè¿°ç¤ºä¾‹ä¸­ï¼ŒBoundedBuffer å®ç°äº†ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ï¼Œä¸‹é¢è¿›è¡Œç®€å•æ¦‚è¿°ï¼š ä½¿ç”¨ Condition æ—¶å…ˆè·å–ç›¸åº”çš„ Lock é”ï¼Œå’Œ Object ç±»ä¸­çš„æ–¹æ³•ç±»ä¼¼ï¼Œéœ€è¦å…ˆè·å–æŸä¸ªå¯¹è±¡çš„ç›‘è§†å™¨é”æ‰èƒ½æ‰§è¡Œç­‰å¾…ã€é€šçŸ¥æ–¹æ³•ã€‚ ç”Ÿäº§å’Œæ¶ˆè´¹æ–¹æ³•ä¸­åˆ¤æ–­æ•°ç»„çŠ¶æ€ä½¿ç”¨çš„æ˜¯ while è‡ªæ—‹è€Œé if åˆ¤æ–­ï¼Œç›®çš„æ˜¯é˜²æ­¢è¿‡æ—©æˆ–æ„å¤–çš„é€šçŸ¥ï¼Œå½“ä¸”ä»…å½“æ¡ä»¶æ»¡è¶³æ‰èƒ½ä» await() è¿”å›ã€‚ å®ç°åŸç†Condition ç»“åˆ Lock å®ç°çš„ç­‰å¾…é€šçŸ¥æœºåˆ¶åŒ…æ‹¬ä¸¤éƒ¨åˆ†å†…å®¹å³ç­‰å¾…å’Œé€šçŸ¥ï¼Œåˆ†åˆ«ä¾èµ–å•å‘é“¾è¡¨å’ŒåŒå‘é“¾è¡¨ã€‚Condition æ¥å£çš„å®ç°ç±»æ˜¯ AQS å†…éƒ¨ç±» ConditionObjectï¼Œå®ƒå†…éƒ¨ç»´æŠ¤çš„é˜Ÿåˆ—ç§°ä¸ºæ¡ä»¶é˜Ÿåˆ—ï¼ŒåŸºäºå•å‘é“¾è¡¨å®ç°ã€‚Lock æ˜¯åŸºäº AQS å®ç°çš„ï¼Œå®ƒå†…éƒ¨ç»´æŠ¤çš„é˜Ÿåˆ—ç§°ä¸ºåŒæ­¥é˜Ÿåˆ—ï¼ŒåŸºäºåŒå‘é“¾è¡¨å®ç°ã€‚Condition å¯¹è±¡æ˜¯ç”± Lock å¯¹è±¡åˆ›å»ºå‡ºæ¥çš„ï¼Œå¹¶ä¸”ä¸€ä¸ª Lock å¯¹è±¡å¯ä»¥åˆ›å»ºå¤šä¸ª Condition å¯¹è±¡ï¼Œæ¯ä¸ª Condition å¯¹è±¡å…±äº« Lock è¿™ä¸ªå¤–éƒ¨èµ„æºã€‚ è·å–åˆ°åŒæ­¥çŠ¶æ€ï¼ˆé”ï¼‰çš„çº¿ç¨‹è°ƒç”¨ await æ–¹æ³•è¿›è¡Œç­‰å¾…æ—¶ï¼Œä¼šå…ˆå°†è‡ªå·±æ‰“åŒ…æˆä¸€ä¸ªèŠ‚ç‚¹å¹¶åŠ å…¥åˆ°å¯¹åº”çš„æ¡ä»¶é˜Ÿåˆ—ä¸­ï¼ŒåŠ å…¥æˆåŠŸåä¼šå®Œå…¨é‡Šæ”¾åŒæ­¥çŠ¶æ€ï¼Œé‡Šæ”¾åŒæ­¥çŠ¶æ€æˆåŠŸåä¼šåœ¨è¯¥æ¡ä»¶é˜Ÿåˆ—çš„å°¾éƒ¨ç­‰å¾…ï¼Œäºæ­¤åŒæ—¶è¯¥çº¿ç¨‹åœ¨åŒæ­¥é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ä¹Ÿä¼šè¢«ç§»é™¤ã€‚åœ¨æŸä¸ª Condition ä¸Šï¼ˆæ¡ä»¶é˜Ÿåˆ—ï¼‰ç­‰å¾…çš„çº¿ç¨‹èŠ‚ç‚¹è¢«signal æˆ– signalAll åï¼Œå¯¹åº”çš„çº¿ç¨‹èŠ‚ç‚¹ä¼šè¢«è½¬åˆ°å¤–éƒ¨ç±»çš„åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œè¿™æ„å‘³ç€è¯¥èŠ‚ç‚¹æœ‰äº†ç«äº‰åŒæ­¥çŠ¶æ€çš„æœºä¼šï¼Œçº¿ç¨‹éœ€è¦è·å–åˆ°åŒæ­¥çŠ¶æ€æ‰èƒ½ç»§ç»­åç»­çš„é€»è¾‘ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œä¸€ä¸ªé”å¯¹è±¡å¯ä»¥åŒæ—¶åˆ›å»º N ä¸ª Condition å¯¹è±¡ï¼ˆå¯¹åº” N ä¸ªæ¡ä»¶é˜Ÿåˆ—ï¼‰ï¼Œè¿™è¡¨æ˜è·å–åˆ°åŒæ­¥çŠ¶æ€çš„çº¿ç¨‹å¯ä»¥æœ‰é€‰æ‹©åœ°åŠ å…¥æ¡ä»¶é˜Ÿåˆ—å¹¶åœ¨è¯¥é˜Ÿåˆ—ä¸­ç­‰å¾…ï¼Œå…¶å®ƒè·å–åˆ°åŒæ­¥çŠ¶æ€çš„çº¿ç¨‹å¯ä»¥æœ‰é€‰æ‹©åœ°å”¤é†’æŸä¸ªæ¡ä»¶é˜Ÿåˆ—ä¸­çš„ç­‰å¾…çš„çº¿ç¨‹ã€‚ä½†ä¸ç®¡æœ‰å¤šå°‘ä¸ªæ¡ä»¶é˜Ÿåˆ—ï¼Œç«äº‰åŒæ­¥çŠ¶æ€çš„çº¿ç¨‹èŠ‚ç‚¹éœ€è¦ç»Ÿä¸€è½¬åˆ°å¤–éƒ¨ç±»çš„åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œä¹Ÿå°±æ˜¯ Lock ç»´æŠ¤çš„åŒå‘é“¾è¡¨ï¼Œæ­¤åå°±æ˜¯ç«äº‰åŒæ­¥çŠ¶æ€çš„é€»è¾‘äº†ã€‚ ä¸‹å›¾ç®€å•æè¿°äº† Condition çš„å·¥ä½œåŸç†ï¼š ä»¥ä¸Šå°±æ˜¯ Condition å®ç°çš„ç­‰å¾…-é€šçŸ¥æœºåˆ¶ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œä¸Šè¿°æè¿°æ²¡æœ‰æ¶‰åŠè¿‡å¤šçš„ç»†èŠ‚ï¼Œå¦‚å¼‚å¸¸æµçš„å¤„ç†ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬é€šè¿‡å¯¹ä»£ç å±‚é¢çš„è§£ææ¥å…¨é¢äº†è§£ Condition çš„æœºåˆ¶ã€‚ æºç è§£æCondition Condition æ¥å£ä¸­å®šä¹‰çš„æ–¹æ³•å’Œ Object ä¸­çš„ç›‘è§†å™¨æ–¹æ³•ç±»ä¼¼ï¼ŒåŒºåˆ«åœ¨äºå‰è€…æ”¯æŒå“åº”ä¸­æ–­å’Œè¶…æ—¶ç­‰å¾…ã€‚ä¸‹é¢å¯¹è¯¥æ¥å£ä¸­å®šä¹‰çš„æ–¹æ³•è¿›è¡Œç®€å•è¯´æ˜ï¼š void await() throws InterruptedException æ–¹æ³• å“åº”ä¸­æ–­çš„ç­‰å¾…æ–¹æ³•ï¼Œçº¿ç¨‹è¿›å…¥æ¡ä»¶é˜Ÿåˆ—æŒ‚èµ·ï¼Œç›´åˆ°è¢«é€šçŸ¥æˆ–ä¸­æ–­ã€‚ void awaitUninterruptibly() æ–¹æ³• ä¸å“åº”ä¸­æ–­çš„ç­‰å¾…æ–¹æ³•ï¼Œä¸ä¼šæŠ›å‡ºä¸­æ–­å¼‚å¸¸ï¼Œä»…ä»…å¤ä½ä¸­æ–­æ ‡å¿—ï¼Œçº¿ç¨‹è¿›å…¥æ¡ä»¶é˜Ÿåˆ—æŒ‚èµ·ï¼Œç›´åˆ°è¢«é€šçŸ¥æˆ–ä¸­æ–­ã€‚ long awaitNanos(long nanosTimeout) throws InterruptedException æ–¹æ³• åœ¨ await() åŸºç¡€ä¸Šå¢åŠ äº†è¶…æ—¶åŠŸèƒ½ï¼Œçº¿ç¨‹è¿›å…¥æ¡ä»¶é˜Ÿåˆ—æŒ‚èµ·ç›´åˆ°è¢«é€šçŸ¥ã€ä¸­æ–­æˆ–è¶…æ—¶ï¼Œå¦‚æœåœ¨ nanosTimeout å†…è¿”å›ï¼Œé‚£ä¹ˆè¿”å›å€¼å°±æ˜¯ nanosTimeout - å®é™…è€—æ—¶ï¼Œå¦‚æœè¿”å›å€¼æ˜¯ 0 æˆ–è€…è´Ÿæ•°ï¼Œè¡¨ç¤ºè¶…æ—¶äº†ã€‚ boolean awaitUntil(Date deadline) throws InterruptedException æ–¹æ³• åœ¨ await() åŸºç¡€ä¸Šå¢åŠ äº†è¶…æ—¶åŠŸèƒ½ï¼Œçº¿ç¨‹è¿›å…¥æ¡ä»¶é˜Ÿåˆ—æŒ‚èµ·ç›´åˆ°è¢«é€šçŸ¥ã€ä¸­æ–­æˆ–è€…åˆ°æŸä¸ªæ—¶é—´ã€‚å¦‚æœæ²¡æœ‰åˆ°æŒ‡å®šæ—¶é—´å°±é€šçŸ¥ï¼Œè¿”å› trueï¼Œå¦åˆ™è¡¨ç¤ºè¶…æ—¶ã€‚ boolean await(long time, TimeUnit unit) throws InterruptedException æ–¹æ³• å’Œ awaitUntil(Date deadline) æ–¹æ³•å‡ ä¹ä¸€è‡´ï¼Œå‰è€…æ˜¯ç»å¯¹æ—¶é—´ï¼Œåè€…æ˜¯æ—¶é—´ç²’åº¦ã€‚ void signal() æ–¹æ³• å°†æ¡ä»¶é˜Ÿåˆ—ä¸­çš„å¤´èŠ‚ç‚¹è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œä»¥ç­‰å¾…ç«äº‰åŒæ­¥çŠ¶æ€ã€‚ void signalAll() æ–¹æ³• å°†æ¡ä»¶é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ä¾æ¬¡è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œä»¥ç­‰å¾…ç«äº‰åŒæ­¥çŠ¶æ€ã€‚æ­¤æ—¶æ¡ä»¶é˜Ÿåˆ—è¿›å…¥ä¸‹ä¸€ä¸ªå‘¨æœŸã€‚ åœ¨ JUC ä¸­ Condition ä¸»è¦åŸºäº ReentrantLock å’Œ ReentrantReadWriteLock å®ç°çš„ï¼Œåœ¨è¯­ä¹‰ä¸­å°±æ˜¯æˆ‘ä»¬è¯´çš„é”æ¦‚å¿µï¼Œè€Œé”åˆæ˜¯åŸºäº AQS å®ç°çš„ã€‚æ€»çš„æ¥è¯´ï¼ŒCondition ä¾èµ– Lockï¼ŒLock å®ç°æ˜¯åŸºäº AQS çš„ã€‚ä¸‹é¢ä»¥ ReentrantLock ä½œä¸º Condition çš„å®ç°è¿›è¡Œè¯´æ˜ã€‚ ConditionObjectConditionObjectå®ç°äº† Condition æ¥å£ï¼ŒåŒæ—¶ä½œä¸ºAbstractQueuedSynchronizerçš„å†…éƒ¨ç±»ï¼Œå› ä¸º Condition çš„æ“ä½œéœ€è¦è·å–åˆ°åŒæ­¥çŠ¶æ€ï¼Œå› æ­¤å…¶å®ç°ç±»ä½œä¸ºAbstractQueuedSynchronizerçš„å†…éƒ¨ç±»æ˜¯æ¯”è¾ƒåˆç†çš„ï¼Œè¿™æ„å‘³ç€ConditionObjectå¯ä»¥è®¿é—®å¤–éƒ¨èµ„æºã€‚ 12345678910111213141516171819+--- AbstractQueuedSynchronizer public class ConditionObject implements Condition, java.io.Serializable &#123; private static final long serialVersionUID = 1173984872572414699L; /** * æ¡ä»¶é˜Ÿåˆ— - å¤´èŠ‚ç‚¹ */ private transient Node firstWaiter; /** * æ¡ä»¶é˜Ÿåˆ— - å°¾èŠ‚ç‚¹ */ private transient Node lastWaiter; /** * Creates a new &#123;@code ConditionObject&#125; instance. */ public ConditionObject() &#123; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; æ¯ä¸ª ConditionObject å¯¹è±¡å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªåŸºäºå•å‘é“¾è¡¨çš„æ¡ä»¶é˜Ÿåˆ—ï¼Œè¯¥é˜Ÿåˆ—æ˜¯ Condition å®ç°ç­‰å¾…-é€šçŸ¥æœºåˆ¶çš„å…³é”®ã€‚æ—¢ç„¶æ˜¯é“¾è¡¨ï¼Œå…¶ä¸­çš„èŠ‚ç‚¹å®šä¹‰æ˜¯ä»€ä¹ˆå‘¢ï¼ŸConditionObject æ²¡æœ‰é‡æ–°å®šä¹‰é“¾è¡¨èŠ‚ç‚¹ï¼Œè€Œæ˜¯ç›´æ¥ä½¿ç”¨å¤–éƒ¨ç±» AbstractQueuedSynchronizer å®šä¹‰çš„ Node ï¼Œè¿™ä¹Ÿæ˜¯åˆç†çš„ã€‚ä¸‹é¢æˆ‘ä»¬ç®€å•çœ‹ä¸‹è¯¥ Node çš„å®šä¹‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647+--- AbstractQueuedSynchronizer static final class Node &#123; /** * å…±äº«ç±»å‹èŠ‚ç‚¹ï¼Œè¡¨æ˜èŠ‚ç‚¹åœ¨å…±äº«æ¨¡å¼ä¸‹ç­‰å¾… */ static final Node SHARED = new Node(); /** * ç‹¬å ç±»å‹èŠ‚ç‚¹ï¼Œè¡¨æ˜èŠ‚ç‚¹åœ¨ç‹¬å æ¨¡å¼ä¸‹ç­‰å¾… */ static final Node EXCLUSIVE = null; /** * ç­‰å¾…çŠ¶æ€ - å–æ¶ˆï¼ˆçº¿ç¨‹å·²ç»å–æ¶ˆï¼‰ */ static final int CANCELLED = 1; /** * ç­‰å¾…çŠ¶æ€ - é€šçŸ¥ï¼ˆåç»§çº¿ç¨‹éœ€è¦è¢«å”¤é†’ï¼‰ */ static final int SIGNAL = -1; /** * ç­‰å¾…çŠ¶æ€ - æ¡ä»¶ç­‰å¾…ï¼ˆçº¿ç¨‹åœ¨ Condition ä¸Šç­‰å¾…ï¼‰ */ static final int CONDITION = -2; /** * ç­‰å¾…çŠ¶æ€ - ä¼ æ’­ï¼ˆæ— æ¡ä»¶å‘åä¼ æ’­å”¤é†’åŠ¨ä½œï¼‰ */ static final int PROPAGATE = -3; /** * ç­‰å¾…çŠ¶æ€ï¼Œåˆå§‹å€¼ä¸º 0 */ volatile int waitStatus; /** * åŒæ­¥é˜Ÿåˆ—ä¸­ä½¿ç”¨ï¼Œå‰é©±èŠ‚ç‚¹ */ volatile Node prev; /** * åŒæ­¥é˜Ÿåˆ—ä¸­ä½¿ç”¨ï¼Œåç»§èŠ‚ç‚¹ */ volatile Node next; /** * èŠ‚ç‚¹ä¸­å°è£…çš„çº¿ç¨‹ */ volatile Thread thread; /** * æ¡ä»¶é˜Ÿåˆ—ä¸­ä½¿ç”¨ï¼Œåç½®èŠ‚ç‚¹ */ Node nextWaiter; &#125; æ¡ä»¶é˜Ÿåˆ—å’ŒåŒæ­¥é˜Ÿåˆ—å…±åŒä½¿ç”¨ä¸Šè¿°çš„ Node èŠ‚ç‚¹æ„å»ºé˜Ÿåˆ—ï¼ŒåŒºåˆ«åœ¨äºå‰è€…åº•å±‚æ•°æ®ç»“æ„æ˜¯åŒå‘é“¾è¡¨ï¼ŒèŠ‚ç‚¹çš„ç»´æŠ¤ä½¿ç”¨ prev å’Œ next å±æ€§ï¼Œåè€…åº•å±‚æ•°æ®ç»“æ„æ˜¯å•å‘é“¾è¡¨ï¼ŒèŠ‚ç‚¹ç»´æŠ¤ä½¿ç”¨ nextWaiter å±æ€§ï¼Œä¸¤è€…ä¸­çš„èŠ‚ç‚¹ç­‰å¾…çŠ¶æ€éƒ½æ˜¯ä½¿ç”¨ waitStatus å±æ€§ã€‚ ReentrantLock å¯¹è±¡å’Œ ReentrantReadWriteLock å¯¹è±¡å¯ä»¥åˆ›å»ºå¤šä¸ª ConditionObject å¯¹è±¡ï¼Œä»£ç å¦‚ä¸‹ï¼š 123final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; ä¸‹é¢å¯¹ ReentrantLock å’Œ ConditionObject çš„å…³è”å…³ç³»è¿›è¡Œè¯´æ˜ï¼š ConditionObject ç»´æŠ¤çš„æ¡ä»¶é˜Ÿåˆ—å’Œ ReentrantLock ç»´æŠ¤çš„åŒæ­¥é˜Ÿåˆ—çš„èŠ‚ç‚¹éƒ½æ˜¯ Node çš„å®ä¾‹ï¼Œæ¡ä»¶é˜Ÿåˆ—çš„çº¿ç¨‹èŠ‚ç‚¹éœ€è¦ç§»åŠ¨åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ä»¥å‚ä¸ç«äº‰åŒæ­¥çŠ¶æ€ã€‚ ReentrantLock å¯¹è±¡ä¸ ConditionObject å¯¹è±¡çš„æ¯”ä¾‹å…³ç³»ä¸ºï¼š 1 : N ï¼Œæ¯ä¸ª ConditionObject éƒ½èƒ½ç›´æ¥è®¿é—® ReentrantLock è¿™ä¸ªå¤–éƒ¨ç±»èµ„æºã€‚ ä¸€ä¸ªåŒæ­¥é˜Ÿåˆ—å¯¹åº” N ä¸ªæ¡ä»¶é˜Ÿåˆ—ï¼ŒåŒæ­¥é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹ï¼ˆè·å–åˆ°åŒæ­¥çŠ¶æ€ï¼‰å¯ä»¥é€‰æ‹©æ€§åœ°è¿›å…¥ä¸åŒçš„æ¡ä»¶é˜Ÿåˆ—è¿›è¡Œç­‰å¾…ï¼Œè€Œå¤šä¸ªæ¡ä»¶é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹èŠ‚ç‚¹è¦å‚ä¸ç«äº‰åŒæ­¥çŠ¶æ€å°±éœ€è¦è¿›å…¥åŒä¸€ä¸ªåŒæ­¥é˜Ÿåˆ—ã€‚ æ¥ä¸‹æ¥å¯¹ç­‰å¾…å’Œé€šçŸ¥çš„æ ¸å¿ƒä»£ç è¿›è¡Œåˆ†æï¼Œæ ¹æ®ä¸»è¦æµç¨‹åˆ†åˆ«è¯´æ˜ã€‚ ç­‰å¾…ConditionObject ä¸­å®ç°äº†å‡ ç§ä¸åŒåŠŸèƒ½çš„ç­‰å¾…æ–¹æ³•ï¼Œåœ¨ä»‹ç» Condition æ¥å£æ—¶å·²ç»è¯¦ç»†è¯´æ˜ï¼Œä¸‹é¢å…ˆå¯¹ await() çš„æ–¹æ³•å®ç°è¿›è¡Œåˆ†æã€‚ å½“è·å–åŒæ­¥çŠ¶æ€çš„çº¿ç¨‹è°ƒç”¨ await() æ–¹æ³•æ—¶ï¼Œç›¸å½“äºåŒæ­¥é˜Ÿåˆ—çš„å¤´èŠ‚ç‚¹ä¸­çš„çº¿ç¨‹ï¼ˆè·å–äº†åŒæ­¥çŠ¶æ€çš„èŠ‚ç‚¹ï¼‰è¿›å…¥åˆ° Condition çš„æ¡ä»¶é˜Ÿåˆ—ä¸­ï¼Œå®Œå…¨é‡Šæ”¾åŒæ­¥çŠ¶æ€ååŒæ­¥é˜Ÿåˆ—å°†ä¼šç§»é™¤è¯¥çº¿ç¨‹å¯¹åº”çš„èŠ‚ç‚¹ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œä¸‹å›¾ä¸­çš„ç¬¬ 2 æ­¥ä¸­é‡Šæ”¾åŒæ­¥çŠ¶æ€å¤±è´¥çš„æƒ…å†µæ˜¯é’ˆå¯¹æ²¡æœ‰è·å–åˆ°åŒæ­¥çŠ¶æ€å°±æ‰§è¡Œ await æ–¹æ³•çš„æƒ…å†µï¼Œè·å–åˆ°åŒæ­¥çŠ¶æ€çš„çº¿ç¨‹åœ¨é‡Šæ”¾çŠ¶æ€çš„æ—¶å€™ä¸€èˆ¬æ˜¯ä¸ä¼šå‡ºé‡Šæ”¾åŒæ­¥çŠ¶æ€å¤±è´¥çš„æƒ…å†µã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼ŒåŒæ­¥é˜Ÿåˆ—ä¸­å¤´èŠ‚ç‚¹çš„çº¿ç¨‹æ˜¯å…ˆé‡Šæ”¾åŒæ­¥çŠ¶æ€ç„¶åæ‰ä¼šå é¢†å¤´èŠ‚ç‚¹è¿›è€Œå»å”¤é†’åç»§ç­‰å¾…çš„çº¿ç¨‹ï¼Œä¹Ÿå°±æ˜¯åŒæ­¥é˜Ÿåˆ—ä¸­çš„å¤´èŠ‚ç‚¹å°±æ˜¯ä¾›æŒæœ‰åŒæ­¥çŠ¶æ€çš„çº¿ç¨‹å é¢†ï¼Œè¿›è€Œå”¤é†’åç»§ç­‰å¾…çº¿ç¨‹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253+--- ConditionObject public final void await() throws InterruptedException &#123; // å“åº”ä¸­æ–­ if (Thread.interrupted()) throw new InterruptedException(); //1. å°†å½“å‰çº¿ç¨‹å°è£…åˆ°èŠ‚ç‚¹ä¸­ï¼Œå¹¶å°†èŠ‚ç‚¹åŠ å…¥åˆ°æ¡ä»¶é˜Ÿåˆ—å°¾éƒ¨ Node node = addConditionWaiter(); //2. ä¿å­˜å¹¶å®Œå…¨é‡Šæ”¾åŒæ­¥çŠ¶æ€ï¼Œæ³¨æ„æ˜¯å®Œå…¨é‡Šæ”¾ï¼Œå› ä¸ºå…è®¸å¯é‡å…¥é”ã€‚å¦‚æœæ²¡æœ‰æŒé”ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œä¹Ÿå°±æ˜¯é‡Šæ”¾åŒæ­¥çŠ¶æ€å¤±è´¥ int savedState = fullyRelease(node); // è®°å½•ä¸­æ–­æ¨¡å¼ int interruptMode = 0; /** *3. åˆ¤æ–­ä¸Šè¿°åŠ å…¥åˆ°æ¡ä»¶é˜Ÿåˆ—çš„çº¿ç¨‹èŠ‚ç‚¹æ˜¯å¦è¢«ç§»åŠ¨åˆ°äº†åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œä¸åœ¨åˆ™æŒ‚èµ·çº¿ç¨‹ï¼ˆæ›¾ç»è·å–åˆ°é”çš„çº¿ç¨‹ï¼‰ã€‚ * * å¾ªç¯ç»“æŸçš„æ¡ä»¶ï¼š * 1. å…¶å®ƒçº¿ç¨‹è°ƒç”¨ signal/signalAll æ–¹æ³•ï¼Œå°†å½“å‰çº¿ç¨‹èŠ‚ç‚¹ç§»åŠ¨åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ï¼ŒèŠ‚ç‚¹å¯¹åº”çš„çº¿ç¨‹å°†ä¼šåœ¨ç«äº‰åŒæ­¥çŠ¶æ€çš„è¿‡ç¨‹è¢«å‰é©±èŠ‚ç‚¹å”¤é†’ã€‚ * 2. å…¶å®ƒçº¿ç¨‹ä¸­æ–­äº†å½“å‰çº¿ç¨‹ï¼Œå½“å‰çº¿ç¨‹ä¼šè‡ªè¡Œå°è¯•è¿›å…¥åŒæ­¥é˜Ÿåˆ—ä¸­ã€‚ */ while (!isOnSyncQueue(node)) &#123; // æŒ‚èµ·çº¿ç¨‹ï¼Œç›´åˆ°è¢«å”¤é†’æˆ–è¢«ä¸­æ–­ LockSupport.park(this); /** * æ£€æµ‹ä¸­æ–­æ¨¡å¼ï¼š * åœ¨çº¿ç¨‹ä» park ä¸­è¿”å›æ—¶ï¼Œéœ€è¦åˆ¤æ–­æ˜¯è¢«å”¤é†’è¿”å›è¿˜æ˜¯è¢«ä¸­æ–­è¿”å›ã€‚ * 1). å¦‚æœçº¿ç¨‹æ²¡æœ‰è¢«ä¸­æ–­ï¼Œåˆ™è¿”å› 0ï¼Œæ­¤æ—¶éœ€è¦é‡è¯•å¾ªç¯ç»§ç»­åˆ¤æ–­å½“å‰çº¿ç¨‹èŠ‚ç‚¹æ˜¯å¦åœ¨åŒæ­¥é˜Ÿåˆ—ä¸­ã€‚ * 2). å¦‚æœçº¿ç¨‹è¢«ä¸­æ–­ * - ä¸­æ–­å‘ç”Ÿåœ¨è¢«å”¤é†’ä¹‹å‰ï¼Œå½“å‰çº¿ç¨‹ï¼ˆçº¿ç¨‹èŠ‚ç‚¹ï¼‰ä¼šå°è¯•è‡ªè¡Œè¿›å…¥åŒæ­¥é˜Ÿåˆ—å¹¶è¿”å› THROW_IEï¼Œåç»­éœ€è¦æŠ›å‡ºä¸­æ–­å¼‚å¸¸ã€‚todo * - ä¸­æ–­å‘ç”Ÿåœ¨è¢«å”¤é†’ä¹‹åï¼Œå³å½“å‰çº¿ç¨‹ï¼ˆçº¿ç¨‹èŠ‚ç‚¹ï¼‰å°è¯•è‡ªè¡Œè¿›å…¥åŒæ­¥é˜Ÿåˆ—å¤±è´¥ï¼ˆè¯´æ˜å…¶å®ƒçº¿ç¨‹è°ƒç”¨è¿‡äº† signal/signalAll å”¤é†’çº¿ç¨‹å¹¶å°è¯•å°†çº¿ç¨‹èŠ‚ç‚¹è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ï¼‰ï¼Œ * è¿”å› REINTERRUPT ï¼Œåç»­éœ€è¦é‡æ–°ä¸­æ–­çº¿ç¨‹ï¼Œå‘åä¼ é€’ä¸­æ–­æ ‡å¿—ã€‚ */ if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; //4. é†’æ¥åï¼Œè¢«ç§»åŠ¨åˆ°åŒæ­¥é˜Ÿåˆ—çš„èŠ‚ç‚¹ node é‡æ–°å°è¯•è·å–åŒæ­¥çŠ¶æ€æˆåŠŸï¼Œä¸”è·å–åŒæ­¥çŠ¶æ€çš„è¿‡ç¨‹ä¸­å¦‚æœè¢«ä¸­æ–­ï¼Œæ¥ç€åˆ¤æ–­ä¸­æ–­æ¨¡å¼é THROW_IE çš„æƒ…å†µä¼šæ›´æ–°ä¸º REINTERRUPT if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; //5. æ¸…ç†å–æ¶ˆèŠ‚ç‚¹ã€‚æ­£å¸¸æƒ…å†µä¸‹ signal/signalAll å°†èŠ‚ç‚¹è½¬åˆ°åŒæ­¥é˜Ÿåˆ—çš„åŒæ—¶ä¼šå°†èŠ‚ç‚¹çš„ nextWaiter ç½®ç©ºï¼Œè¿™é‡Œä¸»è¦å¯¹è‡ªè¡Œè¿›å…¥åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹è¿›è¡Œå¤„ç†ã€‚ // 1ï¼‰ ä¸­æ–­æ¨¡å¼ä¸º THROW_IE çš„æƒ…å†µä¸‹ nextWaiter ä¸ä¼šè¢«ç½®ç©ºï¼Œä¸”ç­‰å¾…çŠ¶æ€ä¸º 0 ï¼Œè¿™ç§æƒ…å†µä¸‹èŠ‚ç‚¹åº”è¯¥ä»æ¡ä»¶é˜Ÿåˆ—ä¸­ç§»é™¤ã€‚ // 2ï¼‰ fullyRelease æ–¹æ³•å‡ºç°å¼‚å¸¸ï¼ŒnextWaiter ä¸ä¼šè¢«ç½®ç©ºï¼Œä¸”ç­‰å¾…çŠ¶æ€ä¸º CANCELLEDï¼Œæ¸…ç†ä»»åŠ¡ä¼šç”±åç»§çš„èŠ‚ç‚¹å®Œæˆã€‚ if (node.nextWaiter != null) // clean up if cancelled // æ¸…ç†æ¡ä»¶é˜Ÿåˆ—ä¸­å–æ¶ˆçš„èŠ‚ç‚¹ï¼ˆé‡ç»„é“¾è¡¨ï¼‰ unlinkCancelledWaiters(); //6. å¦‚æœçº¿ç¨‹å‘ç”Ÿè¿‡ä¸­æ–­åˆ™æ ¹æ® THROW_IE æˆ– REINTERRUPT åˆ†åˆ«æŠ›å‡ºå¼‚å¸¸æˆ–è€…é‡æ–°ä¸­æ–­ã€‚ todo æœ€ç»ˆéƒ½è¦æŠ›å‡ºå¼‚å¸¸è¿˜è·å–ä¸ªçƒçƒçš„é” if (interruptMode != 0) reportInterruptAfterWait(interruptMode); &#125; ä¸‹é¢å¯¹ä¸Šè¿°æ•´ä¸ªç­‰å¾…æµç¨‹è¿›è¡Œæ¦‚è¿°ï¼š å°†è·å–åˆ°åŒæ­¥çŠ¶æ€çš„çº¿ç¨‹å°è£…åˆ°èŠ‚ç‚¹ä¸­å¹¶åŠ å…¥åˆ°æ¡ä»¶é˜Ÿåˆ—ã€‚ å®Œå…¨é‡Šæ”¾åŒæ­¥çŠ¶æ€ï¼Œå¹¶è®°å½•è·å–åˆ°çš„åŒæ­¥çŠ¶æ€ï¼Œä¸ºåé¢é‡æ–°ç«äº‰åŒæ­¥çŠ¶æ€åšå‡†å¤‡ã€‚ åœ¨æ¡ä»¶é˜Ÿåˆ—ä¸­ç­‰å¾…è¢«å”¤é†’ï¼Œæˆ–è€…è¢«ä¸­æ–­ã€‚ å†æ¬¡ç«äº‰æŒ‚èµ·ç­‰å¾…å‰çš„åŒæ­¥çŠ¶æ€ã€‚ å¯¹ä¸­æ–­æƒ…å†µçš„å¤„ç†ï¼ŒæŠ›å‡ºå¼‚å¸¸æˆ–é‡æ–°ä¸­æ–­çº¿ç¨‹ä»¥å¤ä½ä¸­æ–­æ ‡å¿—ã€‚ ä»¥ä¸Šå¯¹æ•´ä¸ªç­‰å¾…æµç¨‹è¿›è¡Œäº†æ€»ä½“æè¿°ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“çº¿ç¨‹ä»await()æ–¹æ³•è¿”å›æ—¶ï¼Œå½“å‰çº¿ç¨‹ä¸€å®šè·å–äº†Conditionç›¸å…³è”çš„é”ã€‚ä¸‹é¢å¯¹å…¶ä¸­çš„åˆ†æ”¯æµè¿›è¡Œè¯´æ˜ã€‚ addConditionWaiterå°†å½“å‰çº¿ç¨‹å°è£…åˆ°èŠ‚ç‚¹ä¸­ï¼Œç„¶ååŠ å…¥åˆ°å½“å‰ Condition å¯¹è±¡ç»´æŠ¤çš„æ¡ä»¶é˜Ÿåˆ—çš„å°¾éƒ¨ã€‚ 1234567891011121314151617181920212223242526272829+--- ConditionObjectprivate Node addConditionWaiter() &#123; // æ¡ä»¶é˜Ÿåˆ—å°¾èŠ‚ç‚¹ Node t = lastWaiter; // é€‰å‡ºæ¡ä»¶é˜Ÿåˆ—ä¸­æœ‰æ•ˆå°¾èŠ‚ç‚¹ã€‚è¿™é‡Œä¸»è¦å¤„ç† fullyRelease æ–¹æ³•å‡ºç°å¼‚å¸¸çš„æƒ…å†µã€‚ if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; // å¦‚æœéœ€è¦ï¼Œæ¸…ç†æ¡ä»¶é˜Ÿåˆ—ä¸­å–æ¶ˆçš„èŠ‚ç‚¹ï¼ˆé‡ç»„é“¾è¡¨ï¼‰ unlinkCancelledWaiters(); // é‡è¯»å°¾èŠ‚ç‚¹ï¼Œå¯èƒ½ä¸º null t = lastWaiter; &#125; // åˆ›å»ºèŠ‚ç‚¹å°è£…å½“å‰çº¿ç¨‹ï¼ŒèŠ‚ç‚¹çŠ¶æ€ä¸º CONDITION Node node = new Node(Thread.currentThread(), Node.CONDITION); // åˆå§‹åŒ–æ¡ä»¶é˜Ÿåˆ—ï¼ŒfirstWaiter æ›´æ–°ä¸ºå½“å‰èŠ‚ç‚¹ if (t == null) firstWaiter = node; // å°†å½“å‰èŠ‚ç‚¹åŠ å…¥åˆ°æ¡ä»¶é˜Ÿåˆ—å°¾ else t.nextWaiter = node; // æ›´æ–°æ¡ä»¶é˜Ÿåˆ—å°¾æŒ‡é’ˆæŒ‡å‘ lastWaiter = node; // è¿”å›å½“å‰çº¿ç¨‹å…³è”çš„èŠ‚ç‚¹ return node;&#125; ç‰¹åˆ«è¯´æ˜ï¼š addConditionWaiter() æ–¹æ³•ä¸ä¸€å®šæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œæ²¡æœ‰è·å–åˆ°é”å°±è°ƒç”¨ await æ–¹æ³•å°±æ˜¯ä¸å®‰å…¨æ“ä½œã€‚è™½ç„¶æ²¡æœ‰è·å–åˆ°é”çš„çº¿ç¨‹æ‰§è¡Œ await æ–¹æ³•æœ€ç»ˆä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œé—ç•™åœ¨æ¡ä»¶é˜Ÿåˆ—çš„èŠ‚ç‚¹ä¹Ÿä¼šè¢«åç»§èŠ‚ç‚¹æ¸…ç†ï¼Œä½†æ˜¯å¦‚æœæŒé”å’Œä¸æŒé”çš„ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨ await æ–¹æ³•å°±å¯èƒ½ä¼šäº§ç”Ÿå¹¶å‘é—®é¢˜ï¼Œä½¿ ConditionObject ç»´æŠ¤çš„æ¡ä»¶é˜Ÿåˆ—ä¸­èŠ‚ç‚¹äº§ç”Ÿè¦†ç›–ï¼Œè¿™æ˜¯ä¸€ç§ç ´åè¡Œä¸ºï¼Œæœ€ç»ˆä¼šå¯¼è‡´æœ‰äº›æˆåŠŸè°ƒç”¨ await æ–¹æ³•çš„çº¿ç¨‹å¯èƒ½æ°¸è¿œæ²¡æœ‰åŠæ³•è¢«å”¤é†’(éæ­£å¸¸å”¤é†’é™¤å¤–ï¼Œå¦‚ä¸­æ–­)ï¼Œæ›´æ²¡æœ‰æœºä¼šå†æ¬¡è·å–é”ï¼Œå› ä¸ºæ¡ä»¶é˜Ÿåˆ—ä¸­å¹¶æ²¡æœ‰è®°å½•å®ƒä»¬ï¼Œè®°å½•çš„æ˜¯éæ³•è°ƒç”¨çš„çº¿ç¨‹èŠ‚ç‚¹ã€‚ ä¸Šè¿°è¿‡ç¨‹æ¶‰åŠåˆ°æ¸…ç†æ— æ•ˆèŠ‚ç‚¹çš„é€»è¾‘ï¼Œè¯¥é€»è¾‘ç”± unlinkCancelledWaiters() æ–¹æ³•å®Œæˆï¼Œä¸‹é¢æˆ‘ä»¬æ¥åˆ†æè¯¥æ–¹æ³•ã€‚ unlinkCancelledWaiters1234567891011121314151617181920212223242526272829303132333435363738394041424344454647+--- ConditionObject private void unlinkCancelledWaiters() &#123; // ä»é¦–èŠ‚ç‚¹å¼€å§‹è¿›è¡ŒèŠ‚ç‚¹æ£€æµ‹ Node t = firstWaiter; // è®°å½•ä¸Šä¸€ä¸ªéå–æ¶ˆçŠ¶æ€èŠ‚ç‚¹ï¼Œå‚ç…§èŠ‚ç‚¹æ˜¯å½“å‰éå†èŠ‚ç‚¹ Node trail = null; // éå†é“¾è¡¨ while (t != null) &#123; // ä¿å­˜å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåœ¨å½“å‰èŠ‚ç‚¹å¤„äºå–æ¶ˆçŠ¶æ€æ—¶è¿›è¡Œæ›¿æ¢ Node next = t.nextWaiter; // å¦‚æœèŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€ä¸æ˜¯ CONDITIONï¼Œè¡¨æ˜è¿™ä¸ªèŠ‚ç‚¹è¢«å–æ¶ˆäº†ã€‚ if (t.waitStatus != Node.CONDITION) &#123; // å–æ¶ˆçŠ¶æ€çš„èŠ‚ç‚¹è¦æ–­å¼€å’Œé“¾è¡¨çš„å…³è” t.nextWaiter = null; /** * é‡ç»„é“¾è¡¨ï¼Œä¿è¯é“¾æ¡ä¸ºç©ºæˆ–è€…æ‰€æœ‰èŠ‚ç‚¹éƒ½æ˜¯éå–æ¶ˆçŠ¶æ€ * * trail == nullï¼Œè¡¨æ˜ next ä¹‹å‰çš„èŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€å‡ä¸ºå–æ¶ˆçŠ¶æ€ï¼Œæ­¤æ—¶æ›´æ–° firstWaiter å¼•ç”¨æŒ‡å‘ * trail != nullï¼Œè¡¨æ˜ next ä¹‹å‰æœ‰èŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€ä¸º CONDITION ï¼Œæ­¤æ—¶åªéœ€ trail.nextWaiter æŒ‡å‘ next èŠ‚ç‚¹ * æ³¨æ„ï¼š * 1 firstWaiter ä¸€å®šæŒ‡å‘é“¾è¡¨ç¬¬ä¸€ä¸ªéå–æ¶ˆèŠ‚ç‚¹ï¼Œæˆ–è€…ä¸º null * 2 trail ç¬¬ä¸€æ¬¡èµ‹å€¼çš„è¯ä¸€å®šå’Œ firstWaiter ä¸€æ ·çš„å€¼ * 3 firstWaiter ä¸€æ—¦è¢«èµ‹äºˆé null çš„å€¼åå°±ä¸ä¼šå†å˜åŠ¨ï¼Œåç»­çš„èŠ‚ç‚¹è¿æ¥å°±çœ‹ trail çš„è¡¨æ¼”ï¼š * - å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯å–æ¶ˆèŠ‚ç‚¹ï¼Œå°± trail.nextWaiter æŒ‡å‘ next èŠ‚ç‚¹ * - å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯éå–æ¶ˆèŠ‚ç‚¹ï¼Œtrail è·Ÿç€èŠ‚ç‚¹èµ° */ if (trail == null) firstWaiter = next; else trail.nextWaiter = next; // å½“å‰èŠ‚ç‚¹æ²¡æœ‰åç»§åˆ™éå†ç»“æŸï¼Œæ­¤æ—¶å½“å‰èŠ‚ç‚¹æ˜¯æ— æ•ˆèŠ‚ç‚¹ï¼Œå› æ­¤å°† lastWaiter å›é€€å³æ›´æ–°ä¸ºä¸Šä¸€ä¸ªéå–æ¶ˆèŠ‚ç‚¹ if (next == null) lastWaiter = trail; // å½“å‰èŠ‚ç‚¹å¤„äºç­‰å¾…çŠ¶æ€ &#125; else trail = t; // ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ t = next; &#125; &#125; unlinkCancelledWaiters() æ–¹æ³•ç”¨äºæ¸…ç†å–æ¶ˆèŠ‚ç‚¹ï¼Œé‡æ–°æ„é€ é“¾è¡¨ï¼Œä¸»è¦å¤„ç†å› ä¸­æ–­è‡ªè¡ŒåŠ å…¥åŒæ­¥é˜Ÿåˆ—å’Œé‡Šæ”¾åŒæ­¥çŠ¶æ€å¼‚å¸¸çš„æƒ…å†µã€‚å–æ¶ˆèŠ‚ç‚¹çš„å®šä¹‰æ˜¯çº¿ç¨‹èŠ‚ç‚¹æŒ‚èµ·æ—¶è¢«ä¸­æ–­æˆ–é‡Šæ”¾åŒæ­¥çŠ¶æ€å¤±è´¥ã€‚ çº¿ç¨‹èŠ‚ç‚¹åŠ å…¥åˆ°æ¡ä»¶é˜Ÿåˆ—åå°±å¯ä»¥æ‰§è¡Œå®Œå…¨é‡Šæ”¾åŒæ­¥çŠ¶æ€æ“ä½œï¼Œä¸‹é¢æˆ‘ä»¬çœ‹å…·ä½“çš„é€»è¾‘ã€‚ fullyRelease1234567891011121314151617181920212223+--- AbstractQueuedSynchronizer final int fullyRelease(Node node) &#123; boolean failed = true; try &#123; // è·å–åŒæ­¥çŠ¶æ€ï¼ˆæ‹¿åˆ°åŒæ­¥çŠ¶æ€çš„çº¿ç¨‹ï¼‰ int savedState = getState(); // é‡Šæ”¾æŒ‡å®šæ•°é‡çš„åŒæ­¥çŠ¶æ€ // java.util.concurrent.locks.ReentrantLock.Sync.tryRelease ï¼Œæ²¡æœ‰æŒæœ‰é”ä¼šæŠ›å‡ºå¼‚å¸¸ if (release(savedState)) &#123; failed = false; // è¿”å›åŒæ­¥çŠ¶æ€ï¼Œé‡Šæ”¾ä¹‹å‰çš„å€¼ return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; // é‡Šæ”¾åŒæ­¥çŠ¶æ€å¤±è´¥ï¼Œéœ€è¦å°†èŠ‚ç‚¹çŠ¶æ€è®¾ç½®ä¸ºå–æ¶ˆçŠ¶æ€ï¼Œåç»­ä¼šè¢«æ¸…ç† if (failed) node.waitStatus = Node.CANCELLED; &#125; &#125; è¯¥æ–¹æ³•ç”¨äºå®Œå…¨é‡Šæ”¾åŒæ­¥çŠ¶æ€ï¼Œå±äº AbstractQueuedSynchronizer ä¸­å®šä¹‰çš„æ–¹æ³•ï¼Œä¸Šæ–‡ä¹Ÿæåˆ° ConditionObject æ˜¯ AbstractQueuedSynchronizer çš„å†…éƒ¨ç±»ï¼Œå› æ­¤å¯ä»¥å…±äº«å¤–éƒ¨èµ„æºã€‚æ³¨æ„ï¼Œè¯¥æ–¹æ³•æ˜¯å®Œå…¨é‡Šæ”¾åŒæ­¥çŠ¶æ€ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ä¸ºäº†é¿å…æ­»é”çš„äº§ç”Ÿï¼Œé”çš„å®ç°ä¸Šä¸€èˆ¬æ”¯æŒé‡å…¥åŠŸèƒ½ã€‚ éœ€è¦ç‰¹åˆ«è¯´æ˜çš„æ˜¯ï¼Œå¦‚æœçº¿ç¨‹æ²¡æœ‰è·å–åˆ°åŒæ­¥çŠ¶æ€å°±æ‰§è¡Œ await() æ–¹æ³•ï¼Œè¯¥çº¿ç¨‹å…³è”çš„èŠ‚ç‚¹èƒ½è¿›å…¥åˆ°æ¡ä»¶é˜Ÿåˆ—ä¸­ï¼Œä½†æ˜¯è¿›å…¥æ¡ä»¶é˜Ÿåˆ—åéœ€è¦è°ƒç”¨ fullyRelease æ–¹æ³•æ‰§è¡ŒåŒæ­¥çŠ¶æ€é‡Šæ”¾é€»è¾‘ï¼Œç”±äºæ²¡æœ‰è·å–åˆ°åŒæ­¥çŠ¶æ€åœ¨æ‰§è¡Œåˆ° ReentrantLock.tryRelease æ–¹æ³•æ—¶ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œè¿›è€Œ finally å—ä¸­å°†èŠ‚ç‚¹çŠ¶æ€è¿›è¡Œæ›´æ–° node.waitStatus = Node.CANCELLED ï¼Œè¿™ä¸ªå·²ç»å…¥é˜Ÿåˆ°æ¡ä»¶é˜Ÿåˆ—çš„èŠ‚ç‚¹ä¼šè¢«åç»­èŠ‚ç‚¹æ¸…ç†å‡ºå»ï¼Œä¹Ÿå³æ‰§è¡Œ unlinkCancelledWaiters æ–¹æ³•ã€‚ é‡Šæ”¾æŒæœ‰çš„åŒæ­¥çŠ¶æ€åä¼šè¿›å…¥è‡ªæ—‹ç­‰å¾…é€»è¾‘ï¼Œè¯¥è¿‡ç¨‹ä¼šå¯¹é€šçŸ¥å’Œä¸­æ–­è¿›è¡Œä¸åŒçš„å¤„ç†ã€‚ ç­‰å¾…è½¬å…¥åŒæ­¥é˜Ÿåˆ—12345678910111213141516171819+--- ConditionObject while (!isOnSyncQueue(node)) &#123; // æŒ‚èµ·çº¿ç¨‹ï¼Œç›´åˆ°è¢«å”¤é†’æˆ–è¢«ä¸­æ–­ LockSupport.park(this); /** * æ£€æµ‹ä¸­æ–­æ¨¡å¼ï¼š * åœ¨çº¿ç¨‹ä» park ä¸­è¿”å›æ—¶ï¼Œéœ€è¦åˆ¤æ–­æ˜¯è¢«å”¤é†’è¿”å›è¿˜æ˜¯è¢«ä¸­æ–­è¿”å›ã€‚ * 1. å¦‚æœçº¿ç¨‹æ²¡æœ‰è¢«ä¸­æ–­ï¼Œåˆ™è¿”å› 0ï¼Œæ­¤æ—¶éœ€è¦é‡è¯•å¾ªç¯ç»§ç»­åˆ¤æ–­å½“å‰çº¿ç¨‹èŠ‚ç‚¹æ˜¯å¦åœ¨åŒæ­¥é˜Ÿåˆ—ä¸­ã€‚ * 2. å¦‚æœçº¿ç¨‹è¢«ä¸­æ–­ * - ä¸­æ–­å‘ç”Ÿåœ¨è¢«å”¤é†’ä¹‹å‰ï¼Œå½“å‰çº¿ç¨‹ï¼ˆçº¿ç¨‹èŠ‚ç‚¹ï¼‰ä¼šå°è¯•è‡ªè¡Œè¿›å…¥åŒæ­¥é˜Ÿåˆ—å¹¶è¿”å› THROW_IEï¼Œåç»­éœ€è¦æŠ›å‡ºä¸­æ–­å¼‚å¸¸ã€‚ * - ä¸­æ–­å‘ç”Ÿåœ¨è¢«å”¤é†’ä¹‹åï¼Œå³å½“å‰çº¿ç¨‹ï¼ˆçº¿ç¨‹èŠ‚ç‚¹ï¼‰å°è¯•è‡ªè¡Œè¿›å…¥åŒæ­¥é˜Ÿåˆ—å¤±è´¥ï¼ˆè¯´æ˜å…¶å®ƒçº¿ç¨‹è°ƒç”¨è¿‡äº† signal/signalAll å”¤é†’çº¿ç¨‹å¹¶å°è¯•å°†çº¿ç¨‹èŠ‚ç‚¹è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ï¼‰ï¼Œ * è¿”å› REINTERRUPT ï¼Œåç»­éœ€è¦é‡æ–°ä¸­æ–­çº¿ç¨‹ï¼Œå‘åä¼ é€’ä¸­æ–­æ ‡å¿—ï¼Œç”±åç»­ä»£ç å»å¤„ç†ä¸­æ–­ã€‚ * */ if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; ä»¥ä¸Šè‡ªæ—‹ç­‰å¾…é€»è¾‘ä¸»è¦åŒ…æ‹¬ä¸¤éƒ¨åˆ†å·¥ä½œï¼Œæ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦åœ¨åŒæ­¥é˜Ÿåˆ—ä¸­å’Œå¤„ç†ä¸­æ–­ã€‚ä¸‹é¢æˆ‘ä»¬åˆ†åˆ«æ¥çœ‹è¿™ä¸¤ä¸ªé€»è¾‘ã€‚ isOnSyncQueueæ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å·²ç»è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940+--- AbstractQueuedSynchronizer final boolean isOnSyncQueue(Node node) &#123; /** * 1 åŒæ­¥é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹çŠ¶æ€å¯èƒ½ä¸º 0ã€SIGNAL = -1ã€PROPAGATE = -3ã€CANCELLED = 1ï¼Œä½†ä¸ä¼šæ˜¯ CONDITION = -2 * 2 node.prev ä»…ä¼šåœ¨èŠ‚ç‚¹è·å–åŒæ­¥çŠ¶æ€åï¼Œè°ƒç”¨ setHead æ–¹æ³•å°†è‡ªå·±è®¾ä¸ºå¤´ç»“ç‚¹æ—¶è¢«è®¾ç½®ä¸º nullï¼Œæ‰€ä»¥åªè¦èŠ‚ç‚¹åœ¨åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œnode.prev ä¸€å®šä¸ä¼šä¸º null */ if (node.waitStatus == Node.CONDITION || node.prev == null) return false; /** * 1 æ¡ä»¶é˜Ÿåˆ—ä¸­èŠ‚ç‚¹æ˜¯ä½¿ç”¨ nextWaiter æŒ‡å‘åç»§èŠ‚ç‚¹ï¼Œnext å‡ä¸º null ã€‚åŒæ­¥é˜Ÿåˆ—ä¸­èŠ‚ç‚¹æ˜¯ä½¿ç”¨ next æŒ‡å‘åç»§èŠ‚ç‚¹ã€‚ * 2 node.next != null ä»£è¡¨å½“å‰èŠ‚ç‚¹ node ä¸€å®šåœ¨åŒæ­¥é˜Ÿåˆ—ä¸­ã€‚ */ if (node.next != null) // If has successor, it must be on queue return true; /** * node.next == null ä¹Ÿä¸èƒ½è¯´æ˜èŠ‚ç‚¹ node ä¸€å®šä¸åœ¨åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œå› ä¸ºåŒæ­¥é˜Ÿåˆ—å…¥é˜Ÿæ–¹æ³•ä¸æ˜¯åŒæ­¥çš„è€Œæ˜¯è‡ªæ—‹æ–¹å¼ï¼Œ * æ˜¯å…ˆè®¾ç½® node.prevï¼Œåè®¾ç½® node.nextï¼ŒCAS å¤±è´¥æ—¶ node å¯èƒ½å·²ç»åœ¨åŒæ­¥é˜Ÿåˆ—ä¸Šäº†ï¼Œæ‰€ä»¥è¿™é‡Œè¿˜éœ€è¦è¿›ä¸€æ­¥æŸ¥æ‰¾ã€‚ */ return findNodeFromTail(node); &#125; /** * ä»åŒæ­¥é˜Ÿåˆ—å°¾éƒ¨å¼€å§‹æœç´¢ï¼ŒæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨ node èŠ‚ç‚¹ã€‚ * ä¸ºä»€ä¹ˆä¸ä»å¤´å¼€å§‹æœç´¢ï¼Ÿå› ä¸ºèŠ‚ç‚¹çš„ prev å¯èƒ½ä¼šä¸º null * * @return true if present */ private boolean findNodeFromTail(Node node) &#123; Node t = tail; for (; ; ) &#123; if (t == node) return true; if (t == null) return false; t = t.prev; &#125; &#125; checkInterruptWhileWaitingæ£€æŸ¥åœ¨çº¿ç¨‹æŒ‚èµ·æœŸé—´æ˜¯å¦å‘ç”Ÿä¸­æ–­ï¼Œè‹¥å‘ç”Ÿä¸­æ–­åˆ™éœ€è¦è¿›è¡Œç‰¹æ®Šå¤„ç†ï¼Œå³å°è¯•è‡ªè¡Œè¿›å…¥åŒæ­¥é˜Ÿåˆ—ä¸­ã€‚ 123456+--- ConditionObject private int checkInterruptWhileWaiting(Node node) &#123; return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0; &#125; æ–¹æ³•é€»è¾‘å¦‚ä¸‹ï¼š çº¿ç¨‹æœªè¢«ä¸­æ–­ï¼Œåˆ™è¿”å› 0 çº¿ç¨‹è¢«ä¸­æ–­ä¸”è‡ªè¡Œå…¥åŒæ­¥é˜Ÿåˆ—æˆåŠŸï¼Œåˆ™è¿”å› THROW_IEï¼Œè¿™ç§æƒ…å†µä¸‹åç»­éœ€è¦æŠ›å‡ºä¸­æ–­å¼‚å¸¸ çº¿ç¨‹è¢«ä¸­æ–­ä¸”æœªèƒ½è‡ªè¡Œå…¥åŒæ­¥é˜Ÿåˆ—ï¼ˆå…¶å®ƒçº¿ç¨‹å·²ç»æ‰§è¡Œ signal/signalAll æ–¹æ³•ï¼ŒèŠ‚ç‚¹çŠ¶æ€å·²è¢«æ›´æ”¹ï¼‰ï¼Œåˆ™è¿”å› REINTERRUPT ï¼Œè¿™ç§æƒ…å†µä¸‹åç»­éœ€è¦é‡æ–°ä¸­æ–­çº¿ç¨‹ä»¥æ¢å¤ä¸­æ–­æ ‡å¿— transferAfterCancelledWaitå–æ¶ˆç­‰å¾…ï¼ˆä¸­æ–­ï¼‰åçš„è½¬ç§»èŠ‚ç‚¹æ“ä½œï¼Œå³çº¿ç¨‹è¢«ä¸­æ–­ä¼˜å…ˆå°è¯•è‡ªè¡ŒåŠ å…¥åŒæ­¥é˜Ÿåˆ—ï¼Œå¦‚æœåœ¨ä¸­æ–­ä¹‹å‰å·²ç»æ‰§è¡Œè¿‡åŠ å…¥æ“ä½œå°±ç­‰å¾…åŠ å…¥åŒæ­¥é˜Ÿåˆ—å®Œæˆã€‚ æ³¨æ„ï¼š ç”±äºä¸­æ–­å°è¯•è‡ªè¡ŒåŠ å…¥åŒæ­¥é˜Ÿåˆ—çš„çº¿ç¨‹èŠ‚ç‚¹å¹¶æ²¡æœ‰ä¸æ¡ä»¶é˜Ÿåˆ—æ–­å¼€è¿æ¥ï¼Œè¯¥èŠ‚ç‚¹ä¼šåœ¨åç»­çš„é€»è¾‘ä¸­è¿›è¡Œæ¸…é™¤ã€‚ å³ä½¿å‘ç”Ÿäº†ä¸­æ–­ï¼ŒèŠ‚ç‚¹ä¾ç„¶ä¼šè½¬åˆ°åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ã€‚ 123456789101112131415161718192021+--- ConditionObject final boolean transferAfterCancelledWait(Node node) &#123; // ä¸­æ–­å¦‚æœå‘ç”Ÿåœ¨ èŠ‚ç‚¹è¢«è½¬åˆ°åŒæ­¥é˜Ÿåˆ—å‰ï¼Œåº”è¯¥å°è¯•è‡ªè¡Œå°†èŠ‚ç‚¹è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œå¹¶è¿”å› true if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123; // å°†èŠ‚ç‚¹è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ enq(node); return true; &#125; /** * 1. å¦‚æœä¸Šé¢çš„CASå¤±è´¥ï¼Œåˆ™è¡¨æ˜å·²ç»æœ‰çº¿ç¨‹è°ƒç”¨ signal/signalAll æ–¹æ³•æ›´æ–°è¿‡èŠ‚ç‚¹çŠ¶æ€ï¼ˆCONDITION -&gt; 0 ï¼‰ï¼Œå¹¶è°ƒç”¨ enq æ–¹æ³•å°è¯•å°†èŠ‚ç‚¹è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ã€‚ * 2. è¿™é‡Œä½¿ç”¨ while è¿›è¡Œåˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦å·²ç»åœ¨åŒæ­¥é˜Ÿåˆ—ä¸Šçš„åŸå› æ˜¯ï¼Œsignal/signalAll æ–¹æ³•å¯èƒ½ä»…è®¾ç½®äº†ç­‰å¾…çŠ¶æ€ï¼Œè¿˜æ²¡æœ‰å®Œæˆå°†çº¿ç¨‹èŠ‚ç‚¹è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œæ‰€ä»¥è¿™é‡Œç”¨è‡ªæ—‹çš„ * æ–¹å¼ç­‰å¾…çº¿ç¨‹èŠ‚ç‚¹åŠ å…¥åˆ°åŒæ­¥é˜Ÿåˆ—ï¼Œå¦åˆ™ä¼šå½±å“åç»­é‡æ–°è·å–åŒæ­¥çŠ¶æ€ï¼ˆè°ƒç”¨ acquireQueued() æ–¹æ³•ï¼Œè¯¥æ–¹æ³•éœ€è¦çº¿ç¨‹èŠ‚ç‚¹å…¥åŒæ­¥é˜Ÿåˆ—æ‰èƒ½è°ƒç”¨ï¼Œå¦åˆ™ä¼šæŠ›å‡ºnpå¼‚å¸¸ï¼‰ã€‚è¿™ç§æƒ…å†µè¡¨æ˜äº†ä¸­æ–­å‘ç”Ÿåœ¨èŠ‚ç‚¹è¢«è½¬ç§»åˆ°åŒæ­¥é˜Ÿåˆ—æœŸé—´ã€‚ */ while (!isOnSyncQueue(node)) // è®©å‡º CPU Thread.yield(); // ä¸­æ–­åœ¨èŠ‚ç‚¹è¢«è½¬åˆ°åŒæ­¥é˜Ÿåˆ—æœŸé—´æˆ–ä¹‹åå‘ç”Ÿï¼Œè¿”å› false return false; &#125; åˆ¤æ–­ä¸­æ–­å‘ç”Ÿçš„æ—¶æœºï¼š ä¸­æ–­åœ¨èŠ‚ç‚¹è¢«è½¬åˆ°åŒæ­¥é˜Ÿåˆ—å‰å‘ç”Ÿï¼Œæ­¤æ—¶è¿”å› true ä¸­æ–­åœ¨èŠ‚ç‚¹è¢«è½¬åˆ°åŒæ­¥é˜Ÿåˆ—è¿‡ç¨‹æˆ–ä¹‹åå‘ç”Ÿï¼Œæ­¤æ—¶è¿”å› false é€šçŸ¥åœ¨è§£æé€šçŸ¥æºç ä¹‹å‰æˆ‘ä»¬å…ˆå›åˆ°çº¿ç¨‹æŒ‚èµ·ç­‰å¾…æºç å¤„ï¼Œå¦‚ä¸‹ï¼š 123456789+--- ConditionObject while (!isOnSyncQueue(node)) &#123; // æŒ‚èµ·çº¿ç¨‹ï¼Œç›´åˆ°è¢«å”¤é†’æˆ–è¢«ä¸­æ–­ LockSupport.park(this); // æœ‰ä¸­æ–­æƒ…å†µï¼Œè¿›è¿›è¡Œå¤„ç† if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; çº¿ç¨‹é‡Šæ”¾åŒæ­¥çŠ¶æ€æˆåŠŸåä¼šæŒ‚èµ·ç­‰å¾…å…¶å®ƒçº¿ç¨‹å”¤é†’è‡ªå·±ï¼ˆåŒæ­¥é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹èŠ‚ç‚¹ï¼‰ï¼Œæˆ–è€…è¢«å…¶å®ƒçº¿ç¨‹ä¸­æ–­ã€‚å…³äºçº¿ç¨‹æŒ‚èµ·ç­‰å¾…æ—¶è¢«ä¸­æ–­çš„å¤„ç†é€»è¾‘å‰æ–‡å·²ç»è§£æï¼Œä¸»è¦æ˜¯ç¡®ä¿è¢«ä¸­æ–­çš„çº¿ç¨‹ä¹Ÿèƒ½åŠ å…¥åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ã€‚ä¸‹å›¾å¯¹é€šçŸ¥æµç¨‹è¿›è¡Œäº†ç®€å•åœ°æè¿°ã€‚ ä¸‹é¢å¯¹é€šçŸ¥æµç¨‹è¿›è¡Œè¯´æ˜ï¼š å°†æ¡ä»¶é˜Ÿåˆ—ä¸­å¤´èŠ‚ç‚¹è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ã€‚ æ ¹æ®æƒ…å†µå†³å®šæ˜¯å¦å”¤é†’å¯¹åº”çš„çº¿ç¨‹ï¼Œä¸å”¤é†’åˆ™åœ¨åŒæ­¥é˜Ÿåˆ—ä¸­ç­‰å¾…ï¼Œå”¤é†’åˆ™å‡†å¤‡ç«äº‰åŒæ­¥çŠ¶æ€ã€‚ ä¸‹é¢æˆ‘ä»¬è§£ææ­£å¸¸é€šçŸ¥é€»è¾‘ã€‚ é€šçŸ¥å•ä¸ªèŠ‚ç‚¹123456789101112131415161718192021222324252627282930+--- ConditionObject /** * å°†æ¡ä»¶é˜Ÿåˆ—ä¸­çš„å¤´èŠ‚ç‚¹è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ */ public final void signal() &#123; // æ£€æŸ¥çº¿ç¨‹æ˜¯å¦è·å–äº†ç‹¬å é”ï¼Œæœªè·å–ç‹¬å é”è°ƒç”¨ signal æ–¹æ³•æ˜¯ä¸åˆæ³•çš„ if (!isHeldExclusively()) throw new IllegalMonitorStateException(); // æ¡ä»¶é˜Ÿåˆ—çš„å¤´èŠ‚ç‚¹ Node first = firstWaiter; // å°†æ¡ä»¶é˜Ÿåˆ—çš„å¤´èŠ‚ç‚¹è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ if (first != null) doSignal(first); &#125; private void doSignal(Node first) &#123; do &#123; // å› ä¸ºæ¡ä»¶é˜Ÿåˆ—çš„ firstWaiter è¦å‡ºé˜Ÿè½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œå› æ­¤ä½¿ç”¨ firstWaiter åç»§èŠ‚ç‚¹å é¢† firstWaiterã€‚ if ((firstWaiter = first.nextWaiter) == null) // åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„è¯ï¼Œå°¾èŠ‚ç‚¹æŒ‡å‘è®¾ç½®ä¸º null lastWaiter = null; // æ–­å¼€ first ä¸æ¡ä»¶é˜Ÿåˆ—çš„è¿æ¥ first.nextWaiter = null; // è°ƒç”¨ transferForSignal æ–¹æ³•å°†èŠ‚ç‚¹ç§»åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œå¦‚æœè½¬åˆ°åŒæ­¥é˜Ÿåˆ—å¤±è´¥ï¼Œåˆ™å¯¹åé¢çš„èŠ‚ç‚¹è¿›è¡Œæ“ä½œï¼Œä¾æ¬¡ç±»æ¨ &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null); &#125; é€šçŸ¥æ‰€æœ‰èŠ‚ç‚¹1234567891011121314151617181920212223242526272829+--- ConditionObject public final void signalAll() &#123; // æ£€æŸ¥çº¿ç¨‹æ˜¯å¦è·å–äº†ç‹¬å é”ï¼Œæœªè·å–ç‹¬å é”è°ƒç”¨ signalAll æ–¹æ³•æ˜¯ä¸åˆæ³•çš„ if (!isHeldExclusively()) throw new IllegalMonitorStateException(); // æ¡ä»¶é˜Ÿåˆ—çš„å¤´èŠ‚ç‚¹ Node first = firstWaiter; if (first != null) doSignalAll(first); &#125; private void doSignalAll(Node first) &#123; // ç½®ç©ºæ¡ä»¶é˜Ÿåˆ—çš„å¤´ã€å°¾æŒ‡é’ˆï¼Œå› ä¸ºå½“å‰é˜Ÿåˆ—å…ƒç´ è¦å…¨éƒ¨å‡ºé˜Ÿï¼Œé¿å…å°†æ–°å…¥é˜Ÿçš„èŠ‚ç‚¹è¯¯å”¤é†’ lastWaiter = firstWaiter = null; // å°†æ¡ä»¶é˜Ÿåˆ—ä¸­æ‰€æœ‰çš„èŠ‚ç‚¹éƒ½è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ã€‚ do &#123; Node next = first.nextWaiter; // å°†èŠ‚ç‚¹ä»æ¡ä»¶é˜Ÿåˆ—ä¸­ç§»é™¤ first.nextWaiter = null; // å°†èŠ‚ç‚¹è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ transferForSignal(first); first = next; &#125; while (first != null); &#125; åŠ å…¥åŒæ­¥é˜Ÿåˆ—12345678910111213141516171819202122232425 final boolean transferForSignal(Node node) &#123; /** * å¦‚æœæ›´æ–°èŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€ç”± CONDITION åˆ° 0 å¤±è´¥ï¼Œåˆ™è¯´æ˜è¯¥èŠ‚ç‚¹å·²ç»è¢«å–æ¶ˆï¼ˆå¦‚è¢«ä¸­æ–­ï¼‰ï¼Œä¹Ÿå°±ä¸éœ€è¦å†è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­äº†ã€‚ * ç”±äºæ•´ä¸ª signal /signalAll éƒ½éœ€è¦æ‹¿åˆ°é”æ‰èƒ½æ‰§è¡Œï¼Œå› æ­¤è¿™é‡Œä¸å­˜åœ¨çº¿ç¨‹ç«äº‰çš„é—®é¢˜ã€‚ */ if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; // è°ƒç”¨ enq æ–¹æ³•å°† node åŠ å…¥åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­å°¾ï¼Œå¹¶è¿”å› node çš„å‰é©±èŠ‚ç‚¹ Node p = enq(node); // è·å–å‰é©±èŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€ int ws = p.waitStatus; /** * 1 å¦‚æœå‰é©±èŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€ ws &gt; 0ï¼Œè¯´æ˜å‰é©±èŠ‚ç‚¹å·²ç»è¢«å–æ¶ˆäº†ï¼Œæ­¤æ—¶åº”è¯¥å”¤é†’ node å¯¹åº”çš„çº¿ç¨‹å»å°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼Œå‡†ç¡®çš„åº”è¯¥æ˜¯å…ˆæ‰¾å¤§å“¥ï¼Œæ‰¾å¤§å“¥è¿‡ç¨‹ä¼šå‰”é™¤å®ƒçš„æ— æ•ˆå‰é©±èŠ‚ç‚¹ã€‚ * æ³¨æ„ï¼Œè¿™é‡Œåªæ˜¯å…¥é˜Ÿå¹¶æ²¡æœ‰æ‰§è¡Œå‰”é™¤å–æ¶ˆèŠ‚ç‚¹çš„é€»è¾‘ï¼Œè™½ç„¶AQSå”¤é†’æ“ä½œæ”¯æŒä»å°¾èŠ‚ç‚¹å‘å‰å¯»æ‰¾æœ€å‰çš„æœ‰æ•ˆèŠ‚ç‚¹å¹¶å”¤é†’ï¼Œä½†è¿˜æ˜¯åº”è¯¥ä¸»åŠ¨å”¤é†’ node å¯¹åº”çš„çº¿ç¨‹ï¼Œä»¥æ›´æ–°å¤§å“¥èŠ‚ç‚¹ã€‚ * 2 å¦‚æœå‰é©±èŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€ ws &lt;= 0 ï¼Œé€šè¿‡ CAS æ“ä½œå°† node çš„å‰é©±èŠ‚ç‚¹ p çš„ç­‰å¾…çŠ¶æ€è®¾ç½®ä¸º SIGNALï¼Œå½“èŠ‚ç‚¹ p é‡Šæ”¾åŒæ­¥çŠ¶æ€åä¼šå”¤é†’å®ƒçš„åç»§èŠ‚ç‚¹ nodeã€‚ * å¦‚æœ CAS è®¾ç½®å¤±è´¥ï¼ˆå¯èƒ½èŠ‚ç‚¹ p åœ¨æ­¤æœŸé—´è¢«å–æ¶ˆäº†ï¼‰ï¼Œåˆ™åº”è¯¥ç«‹å³å”¤é†’ node èŠ‚ç‚¹å¯¹åº”çš„çº¿ç¨‹ï¼ŒåŸå› å’Œ 1 ä¸€è‡´ã€‚ */ if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true;&#125; åŠ å…¥åŒæ­¥é˜Ÿåˆ—ä¸»è¦é€»è¾‘å¦‚ä¸‹ï¼š ç”±äºæ‰§è¡Œ signal/signalAll æ–¹æ³•éœ€è¦æŒæœ‰åŒæ­¥çŠ¶æ€ï¼Œå› æ­¤ transferForSignal æ–¹æ³•æ˜¯ä¸å­˜åœ¨å¹¶å‘é—®é¢˜çš„ã€‚ å¯¹æ¡ä»¶é˜Ÿåˆ—ä¸­çš„é CONDITION çŠ¶æ€çš„èŠ‚ç‚¹ä¸æ‰§è¡Œè½¬å…¥åŒæ­¥é˜Ÿåˆ—æ“ä½œã€‚ å°†ç¬¦åˆæ¡ä»¶çš„èŠ‚ç‚¹åŠ å…¥åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œå¹¶è¿”å›å‰é©±èŠ‚ç‚¹ã€‚ æ­£å¸¸æƒ…å†µä¸‹ä¸ä¼šæ‰§è¡Œ LockSupport.unpark(node.thread) å”¤é†’çº¿ç¨‹ï¼Œè€Œæ˜¯èŠ‚ç‚¹è¿›å…¥åŒæ­¥é˜Ÿåˆ—ç„¶åæ–¹æ³•è¿”å› trueï¼ŒtransferForSignal æ–¹æ³•ç»“æŸã€‚ åŒæ­¥é˜Ÿåˆ—ä¸­ node çš„å‰é©±èŠ‚ç‚¹å–æ¶ˆç­‰å¾…ï¼Œæˆ–è€… CAS ç­‰å¾…çŠ¶æ€å¤±è´¥ï¼Œéœ€è¦å”¤é†’çº¿ç¨‹ï¼Œè¿™ä¸ªå±äºå¼‚å¸¸æµã€‚ æ³¨æ„ï¼Œæ‰§è¡Œ signal æˆ– signalAll æ–¹æ³•ä»…ä»…è®©çº¿ç¨‹èŠ‚ç‚¹å…·å¤‡ç«äº‰åŒæ­¥çŠ¶æ€çš„æœºä¼šï¼Œç¡®åˆ‡åœ°è¯´æ˜¯å°†æ¡ä»¶é˜Ÿåˆ—çš„èŠ‚ç‚¹ç§»åŠ¨åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œä»…æ­¤è€Œå·²ã€‚è‡³äºèƒ½ä¸èƒ½è·å–åˆ°åŒæ­¥çŠ¶æ€éœ€è¦çœ‹å…·ä½“ç«äº‰ç»“æœï¼Œè¦çŸ¥é“ä¸ä»…æ¡ä»¶é˜Ÿåˆ—ä¸­çº¿ç¨‹èŠ‚ç‚¹é˜»å¡ç­‰å¾…ï¼ŒåŒæ­¥é˜Ÿåˆ—ä¸­å¯èƒ½ä¹Ÿæœ‰å¤§é‡çš„çº¿ç¨‹èŠ‚ç‚¹åœ¨ç­‰å¾…å”¤é†’ï¼Œå†µä¸”æ¡ä»¶é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹èŠ‚ç‚¹éœ€è¦ç§»åŠ¨åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­æ‰æœ‰èµ„æ ¼å‚ä¸åŒæ­¥çŠ¶æ€çš„ç«äº‰ã€‚ é€šè¿‡ä¸‹é¢çš„ä¼ªä»£ç å¯ä»¥æ¨æ¼”å‡ºå¤šç§å¯èƒ½æƒ…å†µï¼š 1234567891011121314151617181920212223// é»˜è®¤ä½¿ç”¨çš„æ˜¯éå…¬å¹³é”ï¼Œæ„å‘³ç€å³ä½¿åŒæ­¥é˜Ÿåˆ—ä¸­æœ‰ç­‰å¾…å”¤é†’çš„èŠ‚ç‚¹ï¼Œé”è¿˜æ˜¯æœ‰å¯èƒ½è¢«å…¶å®ƒçº¿ç¨‹è·å–ã€‚ReentrantLock lock = new ReentrantLock();Condition condition = lock.newCondition();public void await() throws InterruptedException &#123; lock.lock(); try &#123; // business condition.await(); &#125; finally &#123; lock.unlock(); &#125;&#125;public void signal() &#123; lock.lock(); try &#123; // business condition.signal(); &#125; finally &#123; lock.unlock(); &#125;&#125; ä»ç­‰å¾…ä¸­é†’æ¥çº¿ç¨‹èŠ‚ç‚¹ç§»åŠ¨åˆ°åŒæ­¥é˜Ÿåˆ—åè¢«å”¤é†’ï¼Œçº¿ç¨‹ä»ç­‰å¾…ä¸­é†’æ¥ï¼Œç»§ç»­ä» LockSupport.park(this) å‘åæ‰§è¡Œã€‚ 12345678+--- ConditionObject while (!isOnSyncQueue(node)) &#123; // æŒ‚èµ·çº¿ç¨‹ï¼Œç›´åˆ°è¢«å”¤é†’æˆ–è¢«ä¸­æ–­ LockSupport.park(this); // æ£€æµ‹ä¸­æ–­æ¨¡å¼ if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; æ£€æŸ¥ä¸­æ–­æ¨¡å¼çº¿ç¨‹ä»æŒ‚èµ·è¿”å›åä¼šæ£€æŸ¥ä¸­æ–­çŠ¶æ€ï¼Œæ£€æŸ¥ä¸­æ–­é€»è¾‘å‰æ–‡å·²ç»è¯´æ˜ï¼Œè¿™é‡Œä¸å†é‡å¤ä»‹ç»ã€‚ ä»¥ä¸‹æƒ…å†µä¼šä½¿ LockSupport.park(this) è¿”å›ï¼š çº¿ç¨‹èŠ‚ç‚¹è¢«åŒæ­¥é˜Ÿåˆ—ä¸­å…¶å®ƒèŠ‚ç‚¹å”¤é†’ï¼Œä¸ä»…ä»…æ˜¯å®ƒçš„å‰é©±èŠ‚ç‚¹ï¼Œè¿˜å¯èƒ½æ˜¯å¤´èŠ‚ç‚¹ï¼ˆå¤´èŠ‚ç‚¹çº¿ç¨‹è¿›è¡Œ signal æ—¶ï¼Œçº¿ç¨‹èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹å–æ¶ˆäº†æˆ–æ›´æ–°å‰é©±èŠ‚ç‚¹çŠ¶æ€å¤±è´¥ï¼‰ã€‚ çº¿ç¨‹åœ¨æŒ‚èµ·æ—¶è¢«ä¸­æ–­ã€‚ è™šå‡å”¤é†’ï¼Œå’Œ Object.wait() å­˜åœ¨åŒæ ·çš„é—®é¢˜ï¼Œä¸€èˆ¬ä½¿ç”¨è‡ªæ—‹é¿å…ã€‚ ç«äº‰åŒæ­¥çŠ¶æ€çº¿ç¨‹èŠ‚ç‚¹è½¬å…¥åŒæ­¥é˜Ÿåˆ—åï¼Œå°±å¯ä»¥å°è¯•ç«äº‰åŒæ­¥çŠ¶æ€äº†ï¼Œæ³¨æ„é¢„è·å–åŒæ­¥çŠ¶æ€æ˜¯ä¹‹å‰é‡Šæ”¾é”å‰çš„å€¼ï¼Œä»£ç å¦‚ä¸‹ï¼š 123//é†’æ¥åï¼Œè¢«ç§»åŠ¨åˆ°åŒæ­¥é˜Ÿåˆ—çš„èŠ‚ç‚¹ node é‡æ–°å°è¯•è·å–åŒæ­¥çŠ¶æ€æˆåŠŸï¼Œä¸”è·å–åŒæ­¥çŠ¶æ€çš„è¿‡ç¨‹ä¸­å¦‚æœè¢«ä¸­æ–­ï¼Œæ¥ç€åˆ¤æ–­ä¸­æ–­æ¨¡å¼é THROW_IE çš„æƒ…å†µä¼šæ›´æ–°ä¸º REINTERRUPTif (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; è¿™é‡Œå›åˆ°äº†ç«äº‰åŒæ­¥çŠ¶æ€çš„é€»è¾‘ï¼Œè·å–åˆ°åŒæ­¥çŠ¶æ€åˆ™ç»§ç»­å‘åæ‰§è¡Œï¼Œä¹Ÿæ„å‘³ç€å¯ä»¥ä» await æ–¹æ³•è¿”å›ï¼Œæ²¡èƒ½è·å–åˆ°åŒæ­¥çŠ¶æ€åˆ™ç»§ç»­åœ¨åŒæ­¥é˜Ÿåˆ—ä¸­ç­‰å¾…ã€‚ å¤„ç†ä¸­æ–­1234567private void reportInterruptAfterWait(int interruptMode)throws InterruptedException &#123; if (interruptMode == THROW_IE) throw new InterruptedException(); else if (interruptMode == REINTERRUPT) // ä¸­æ–­çº¿ç¨‹ï¼Œå¤ä½ä¸­æ–­æ ‡å¿— selfInterrupt(); &#125; await() æ–¹æ³•è¿”å›ä¹‹å‰ä¼šå¯¹ä¸­æ–­è¿›è¡Œå¤„ç†ï¼Œå› ä¸ºå®ƒæ”¯æŒå“åº”ä¸­æ–­ï¼Œå…³äºä¸­æ–­æ¨¡å¼å‰æ–‡å·²ç»è¯´æ˜ï¼Œä¼šå¯¹è¢«ä¸­æ–­çš„çº¿ç¨‹è¿›è¡Œç‰¹æ®Šå¤„ç†ï¼Œä¿è¯è¢«ä¸­æ–­çš„çº¿ç¨‹ä¹Ÿè¦è½¬åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ã€‚ è¶…æ—¶ç­‰å¾…è¿™é‡Œä»¥è¶…æ—¶æ—¶é—´ç²’åº¦çš„ç­‰å¾…æ–¹æ³•ä¸ºä¾‹ç®€å•ä»‹ç»è¶…æ—¶ç­‰å¾…ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344public final long awaitNanos(long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); // åŠ å…¥æ¡ä»¶é˜Ÿåˆ— Node node = addConditionWaiter(); // å®Œå…¨é‡Šæ”¾åŒæ­¥çŠ¶æ€ int savedState = fullyRelease(node); // è¿‡æœŸæ—¶é—´ final long deadline = System.nanoTime() + nanosTimeout; // ä¸­æ–­æ¨¡å¼ int interruptMode = 0; // è¶…æ—¶çš„è¯ï¼Œè‡ªè¡Œè½¬å…¥åˆ°åŒæ­¥é˜Ÿåˆ— while (!isOnSyncQueue(node)) &#123; // è¶…æ—¶æ—¶é—´åˆ°ï¼Œè·³å‡ºè‡ªæ—‹ç­‰å¾… if (nanosTimeout &lt;= 0L) &#123; transferAfterCancelledWait(node); break; &#125; // è‡ªæ—‹è¿˜æ˜¯æŒ‚èµ· if (nanosTimeout &gt;= spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); // æ£€æŸ¥ä¸­æ–­æ¨¡å¼ if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; // è®¡ç®—è¶…æ—¶æ—¶é—´ nanosTimeout = deadline - System.nanoTime(); &#125; // ç«äº‰åŒæ­¥çŠ¶æ€ if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return deadline - System.nanoTime();&#125; è¶…æ—¶ç­‰å¾…æ˜¯åœ¨ await() æ–¹æ³•çš„åŸºç¡€ä¸Šå¢åŠ äº†ç­‰å¾…çš„è¶…æ—¶æ—¶é—´ï¼Œå¦‚æœè¶…è¿‡è¶…æ—¶æ—¶é—´åˆ™ä¸å†ç­‰å¾…å…¶å®ƒçº¿ç¨‹å”¤é†’ï¼Œè‡ªè¡ŒåŠ å…¥åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­å¹¶é€€å‡ºè‡ªæ—‹ç­‰å¾…ï¼Œç„¶åå°è¯•ç«äº‰åŒæ­¥çŠ¶æ€ã€‚ å¿½ç•¥ä¸­æ–­1234567891011121314151617181920public final void awaitUninterruptibly() &#123; // åŠ å…¥æ¡ä»¶é˜Ÿåˆ— Node node = addConditionWaiter(); // å®Œå…¨é‡Šæ”¾åŒæ­¥çŠ¶æ€ int savedState = fullyRelease(node); // ä¸­æ–­æ¨¡å¼ boolean interrupted = false; // è‡ªæ—‹ç­‰å¾… while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if (Thread.interrupted()) interrupted = true; &#125; // ç«äº‰åŒæ­¥çŠ¶æ€ if (acquireQueued(node, savedState) || interrupted) // å‘ç”Ÿä¸­æ–­éœ€è¦å¤ä½ä¸­æ–­æ ‡å¿— selfInterrupt();&#125; è¯¥æ–¹æ³•å’Œ await() æ–¹æ³•æœ€å¤§çš„åŒºåˆ«æ˜¯å¯¹ä¸­æ–­ä¸åšç‰¹åˆ«å¤„ç†ï¼Œå¦‚æœæœ‰ä¸­æ–­å‘ç”Ÿå¤ä½ä¸­æ–­æ ‡å¿—å³å¯ï¼Œä¸ä¼šæŠ›å‡ºä¸­æ–­å¼‚å¸¸ã€‚ å…¶å®ƒå’Œå¯¹è±¡ç›‘è§†å™¨çš„è”ç³» Condition å®šä¹‰çš„æ–¹æ³•å’Œå¯¹è±¡ç›‘è§†å™¨æ–¹æ³•ç±»ä¼¼ã€‚ å¯¹è±¡ç›‘è§†å™¨æ–¹æ³•éœ€è¦å’Œ synchronized å…³é”®å­—ä¸€èµ·ä½¿ç”¨ï¼Œä¸”å¿…é¡»å…ˆæ‹¿åˆ°é”æ‰èƒ½æ‰§è¡Œç›‘è§†å™¨æ–¹æ³•ã€‚Condition å¯¹è±¡éœ€è¦å’Œ Lock å¯¹è±¡ç»‘å®šï¼ŒåŒæ ·éœ€è¦å…ˆè·å–åˆ°é”æ‰èƒ½æ‰§è¡Œ Condition çš„æ–¹æ³•ã€‚ å’Œå¯¹è±¡ç›‘è§†å™¨çš„åŒºåˆ« Condition æ¥å£ä¸­å®šä¹‰çš„æ–¹æ³•åŠŸèƒ½æ›´åŠ å®Œå–„ï¼Œå¦‚å¿½ç•¥ä¸­æ–­ã€ç­‰å¾…è¶…æ—¶ã€‚ Condition æ˜¯ä»£ç å±‚é¢ä¸Šçš„å®ç°ï¼Œå¯¹è±¡ç›‘è§†å™¨æ˜¯JVMæŒ‡ä»¤å±‚é¢ä¸Šçš„å®ç°ã€‚ Condition ä¸ Lock ç»“åˆæ‹¥æœ‰ä¸€ä¸ªåŒæ­¥é˜Ÿåˆ—å’Œå¤šä¸ªæ¡ä»¶é˜Ÿåˆ—ï¼Œè€Œå¯¹è±¡ç›‘è§†å™¨æ¨¡å‹ä¸Šæœ‰ä¸€ä¸ªåŒæ­¥é˜Ÿåˆ—å’Œä¸€ä¸ªæ¡ä»¶é˜Ÿåˆ—ã€‚ Condition æ”¯æŒå”¤é†’ç‰¹å®šçº¿ç¨‹ï¼Œå¯¹è±¡ç›‘è§†å™¨æ–¹æ³•å”¤é†’çº¿ç¨‹æ˜¯éšæœºçš„ã€‚","categories":[{"name":"JDK","slug":"JDK","permalink":"https://gentryhuang.com/categories/JDK/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://gentryhuang.com/tags/JUC/"},{"name":"AQS","slug":"AQS","permalink":"https://gentryhuang.com/tags/AQS/"}]},{"title":"Dubboæºç åˆ†æ - ä¼˜é›…åœæœº","slug":"rpc/ä¼˜é›…åœæœº","date":"2020-10-21T16:00:00.000Z","updated":"2021-04-06T08:35:47.211Z","comments":false,"path":"posts/ef4cfe7a/","link":"","permalink":"https://gentryhuang.com/posts/ef4cfe7a/","excerpt":"","text":"æ¦‚è¿°ä¼˜é›…åœæœºä»…å­˜åœ¨äºæœåŠ¡é‡å¯ã€ä¸‹çº¿è¿™æ ·çš„éƒ¨ç½²é˜¶æ®µï¼Œä¼˜é›…åœæœºæ˜¯ä¸€ä¸ªåº”ç”¨ç”Ÿå‘½å‘¨æœŸçš„ä¸€éƒ¨åˆ†ï¼Œå®ƒä¿éšœäº†åº”ç”¨çš„å¥å£®æ€§ã€‚dubboæ˜¯é€šè¿‡jdkçš„ShutdownHookæ¥å®Œæˆä¼˜é›…åœæœºçš„ï¼Œæ‰€ä»¥å¦‚æœç”¨æˆ·ä½¿ç”¨ kill -9 pid ç­‰å¼ºåˆ¶å…³é—­æŒ‡ä»¤ï¼Œæ˜¯ä¸ä¼šæ‰§è¡Œä¼˜é›…åœæœºçš„ï¼Œåªæœ‰é€šè¿‡ kill pid å³æ­£å¸¸é€€å‡ºè¿›ç¨‹ï¼Œæ‰ä¼šæ‰§è¡Œã€‚ åŸºæœ¬è¦æ±‚ ä¼˜é›…åœæœºçš„æœåŠ¡ç«¯æœ‰æ­£åœ¨å¤„ç†ä¸­çš„è¯·æ±‚ï¼Œä¸èƒ½è¢«åœæœºæŒ‡ä»¤ä¸­æ–­ï¼Œé™¤éè¶…æ—¶ ä¼˜é›…åœæœºçš„æ¶ˆè´¹ç«¯ä¸åº”è¯¥å†å‘èµ·æ–°çš„è¯·æ±‚ æ¶ˆè´¹ç«¯ä¸åº”è¯¥è¯·æ±‚å·²ç»ä¸‹çº¿çš„æœåŠ¡æä¾›è€… æ„ä¹‰åº”ç”¨çš„é‡æ–°å¯åŠ¨ã€åœæœºç­‰æ“ä½œï¼Œé¿å…äº†å¯¹ä¸šåŠ¡çš„è¿ç»­æ€§é€ æˆå½±å“ï¼Œå¦‚ï¼šé›†ç¾¤ä¸­çš„æŸä¸ªåº”ç”¨å­˜åœ¨é€»è¾‘ä¸Šçš„bugï¼Œéœ€è¦ä¿®æ”¹ç¨‹åºï¼Œè¿™æ—¶å€™å°±å¯ä»¥ä½¿ç”¨ä¼˜é›…åœæœºå¹³æ»‘ä¸‹çº¿ï¼Œä¸ä¼šé€ æˆè°ƒç”¨æ–¹å¼‚å¸¸é—®é¢˜ã€‚ åŸç† dubboä¸­å®ç°ä¼˜é›…åœæœºä¸»è¦åŒ…å«ä»¥ä¸‹æ­¥éª¤ æ”¶åˆ°kill 9 è¿›ç¨‹é€€å‡ºä¿¡å·æ—¶ï¼Œspringå®¹å™¨ä¼šè§¦å‘å®¹å™¨é”€æ¯äº‹ä»¶ (å…¶å®æ˜¯springæ³¨å†Œçš„jvmé’©å­ç¨‹åºæ‰§è¡Œçš„ï¼Œåé¢ä¼šçœ‹åˆ°) providerç«¯ä¼šå–æ¶ˆæ³¨å†ŒæœåŠ¡å…ƒæ•°æ®ä¿¡æ¯ consumerç«¯ä¼šæ”¶åˆ°æœ€æ–°åœ°å€åˆ—è¡¨ï¼ˆå‡†å¤‡åœæœºåœ°å€ä¸åœ¨è¯¥åœ°å€åˆ—è¡¨ä¸­ï¼‰ dubboåè®®ä¼šå‘é€readonlyäº‹ä»¶æŠ¥æ–‡é€šçŸ¥consumeræœåŠ¡ä¸å¯ç”¨ æœåŠ¡ç«¯ç­‰å¾…å·²ç»æ‰§è¡Œçš„ä»»åŠ¡ç»“æŸå¹¶ä¸å†å¤„ç†æ–°çš„è¯·æ±‚ è¯´æ˜ ä¸Šå›¾ä¸­çš„æµç¨‹æ˜¯ä½¿ç”¨springæ„å»ºçš„dubboåº”ç”¨ ä¸Šå›¾ä¸­çš„æµç¨‹æ²¡æœ‰ä½“ç°å‡ºä¼˜é›…åœæœºçš„æ¶ˆè´¹ç«¯è§’è‰²ï¼Œè¯¥è§’è‰²åšçš„å·¥ä½œç›¸å¯¹ç®€å•ï¼Œä¸»è¦æ˜¯ä¸å†å‘èµ·æ–°çš„è°ƒç”¨è¯·æ±‚å’Œç­‰å¾…å“åº”è¿”å›ï¼Œè¶…æ—¶æ‰ä¼šå¼ºåˆ¶å…³é—­ æ³¨å†Œä¸­å¿ƒå·²ç»é€šçŸ¥äº†æœ€æ–°æœåŠ¡åˆ—è¡¨ï¼Œå‘é€readonlyäº‹ä»¶ä¸»è¦è€ƒè™‘åˆ°æ³¨å†Œä¸­å¿ƒæ¨é€æœåŠ¡æœ‰ç½‘ç»œå»¶è¿Ÿä»¥åŠå®¢æˆ·ç«¯è®¡ç®—æœåŠ¡åˆ—è¡¨ä¹Ÿéœ€è¦æ—¶é—´ã€‚æ¶ˆè´¹ç«¯æ”¶åˆ°åä¼šè®¾ç½®å¯¹åº”çš„providerä¸ºä¸å¯ç”¨çŠ¶æ€ï¼Œä¸‹æ¬¡è´Ÿè½½å‡è¡¡å°±ä¸ä¼šè°ƒç”¨è¿™ä¸ªä¸‹çº¿çš„æœåŠ¡ æ–¹æ¡ˆdubboå¯¹ä¼˜é›…åœæœºçš„å®ç°åœ¨ä¸åŒçš„ç‰ˆæœ¬ä¸­æœ‰æ‰€å·®å¼‚ï¼Œä¸‹é¢ä»2.5.xã€2.6.xä»¥åŠ2.7.xè¿™ä¸‰ä¸ªç‰ˆæœ¬åˆ†åˆ«åˆ†æã€‚ 2.5.xçš„ä¼˜é›…åœæœºæ³¨å†Œshutdown hook 12345678910111213141516171819public abstract class AbstractConfig implements Serializable &#123; // çœç•¥å…¶å®ƒä»£ç  static &#123; Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() &#123; public void run() &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Run shutdown hook now.\"); &#125; /** * é”€æ¯èµ„æº * 1 æ³¨å†Œä¸­å¿ƒæ•°æ®é”€æ¯ï¼š åˆ é™¤æ³¨å†Œä¸­å¿ƒä¸­æœ¬èŠ‚ç‚¹å¯¹åº”çš„æä¾›è€…åœ°å€ä»¥åŠè®¢é˜…æ•°æ® * 2 åè®®æµç¨‹æ•°æ®é”€æ¯ï¼š å–æ¶ˆè¯¥åè®®æ‰€æœ‰å·²ç»æš´éœ²å’Œå¼•ç”¨çš„æœåŠ¡ï¼Œé‡Šæ”¾åè®®æ‰€å ç”¨çš„æ‰€æœ‰èµ„æºï¼Œæ¯”å¦‚è¿æ¥å’Œç«¯å£ */ ProtocolConfig.destroyAll(); &#125; &#125;, \"DubboShutdownHook\")); &#125; è¯´æ˜ ProtocolConfig.destroyAll()æ–¹æ³•æ˜¯ç”¨æ¥é‡Šæ”¾èµ„æºçš„ï¼Œç”±äºdubboæ”¯æŒå¤šæ³¨å†Œä¸­å¿ƒå’Œå¤šåè®®ï¼Œå› æ­¤å…·ä½“é”€æ¯å®ç°ç»†èŠ‚å–å†³äºå…·ä½“çš„æ³¨å†Œä¸­å¿ƒå’Œå…·ä½“çš„åè®®ï¼Œè¿™é‡Œä¸å†å±•å¼€è¯´æ˜ã€‚ 2.6.xçš„ä¼˜é›…åœæœº springä¹Ÿä¾èµ–shutdown hookå®Œæˆä¼˜é›…åœæœºï¼Œå…¶æ³¨å†Œjvmé’©å­çš„æ–¹æ³•å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425/** * Register a shutdown hook with the JVM runtime, closing this context * on JVM shutdown unless it has already been closed at that time. * &lt;p&gt;Delegates to &#123;@code doClose()&#125; for the actual closing procedure. * @see Runtime#addShutdownHook * @see #close() * @see #doClose() */@Overridepublic void registerShutdownHook() &#123; if (this.shutdownHook == null) &#123; // No shutdown hook registered yet. this.shutdownHook = new Thread() &#123; @Override public void run() &#123; synchronized (startupShutdownMonitor) &#123; doClose(); &#125; &#125; &#125;; // æ³¨å†Œjvmé’©å­ Runtime.getRuntime().addShutdownHook(this.shutdownHook); &#125;&#125; springçš„shutdownhookå…·ä½“ä»»åŠ¡å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Actually performs context closing: publishes a ContextClosedEvent and * destroys the singletons in the bean factory of this application context. * &lt;p&gt;Called by both &#123;@code close()&#125; and a JVM shutdown hook, if any. * @see org.springframework.context.event.ContextClosedEvent * @see #destroyBeans() * @see #close() * @see #registerShutdownHook() */protected void doClose() &#123; if (this.active.get() &amp;&amp; this.closed.compareAndSet(false, true)) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Closing \" + this); &#125; LiveBeansView.unregisterApplicationContext(this); try &#123; // Publish shutdown event // æ³¨æ„å®¹å™¨å…³ç³»äº‹ä»¶çš„å‘å¸ƒ publishEvent(new ContextClosedEvent(this)); &#125; catch (Throwable ex) &#123; logger.warn(\"Exception thrown from ApplicationListener handling ContextClosedEvent\", ex); &#125; // Stop all Lifecycle beans, to avoid delays during individual destruction. if (this.lifecycleProcessor != null) &#123; try &#123; this.lifecycleProcessor.onClose(); &#125; catch (Throwable ex) &#123; logger.warn(\"Exception thrown from LifecycleProcessor on context close\", ex); &#125; &#125; // Destroy all cached singletons in the context's BeanFactory. destroyBeans(); // Close the state of this context itself. closeBeanFactory(); // Let subclasses do some final clean-up if they wish... onClose(); this.active.set(false); &#125; &#125; dubbo2.6.xæ”¯æŒä½¿ç”¨springæ„å»ºdubboåº”ç”¨æ—¶ï¼Œèƒ½å¤Ÿå®‰å…¨ä½¿ç”¨ä¼˜é›…åœæœºã€‚ç”±äºdubboæ³¨å†Œäº†jvmåœæ­¢çš„é’©å­ï¼Œ springå¯èƒ½ ä¹Ÿæ³¨å†Œäº†jvmåœæœºçš„é’©å­ï¼Œè¿™ç§æƒ…å†µä¸‹ä¸¤ä¸ªå¹¶å‘æ‰§è¡Œçš„çº¿ç¨‹å¯èƒ½å¼•ç”¨å·²ç»é”€æ¯çš„èµ„æºï¼Œå¯¼è‡´ä¼˜é›…åœæœºå¤±æ•ˆã€‚æ¯”å¦‚ï¼Œdubboæ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡éœ€è¦å¼•ç”¨springä¸­çš„beanï¼Œä½†æ­¤æ—¶springé’©å­å·²ç»å…³é—­springä¸Šä¸‹æ–‡ï¼Œå¯¼è‡´è®¿é—®springèµ„æºéƒ½ä¼šæŠ¥é”™ã€‚å› æ­¤å¯¹äºè¿™ç§æƒ…å†µï¼Œdubboåœ¨2.6.3ä¸­æ–°å¢ShutdownHookListener ç±»ç”¨æ¥è§£å†³å¹¶å‘é—®é¢˜ï¼Œè¯¥ç±»å®ç°äº†ApplicationListeneræ¥å£ï¼Œå½“è¿›ç¨‹é€€å‡ºæ—¶jvmé’©å­ä¼šè¢«è§¦å‘ï¼Œæ­¤æ—¶springå’Œdubboæ³¨å†Œçš„jvmé’©å­éƒ½ä¼šè¢«å›è°ƒï¼Œspringæ³¨å†Œçš„jvmé’©å­ç¨‹åºä¸­springå‘å‡ºå®¹å™¨å…³é—­äº‹ä»¶ï¼ŒShutdownHookListeneræ¥æ”¶åˆ°å…³é—­äº‹ä»¶åæ‰§è¡Œdubboçš„jvmé’©å­ç¨‹åºè¿›è¡Œèµ„æºçš„é‡Šæ”¾ï¼Œè¿™æ ·å°±é¿å…ä½¿ç”¨æ— æ•ˆspring beançš„é—®é¢˜ï¼Œä»è€Œå®Œæˆä¼˜é›…åœæœºã€‚ ShutdownHookListener 1234567891011private static class ShutdownHookListener implements ApplicationListener &#123; @Override public void onApplicationEvent(ApplicationEvent event) &#123; if (event instanceof ContextClosedEvent) &#123; // ä½¿ç”¨springæ¡†æ¶æ—¶ä¹Ÿä¸åº”è¯¥åˆ é™¤dubbo shutdown hookï¼Œå› ä¸ºspringå¯èƒ½æ²¡æœ‰æ³¨å†ŒContextClosed äº‹ä»¶ DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook(); shutdownHook.destroyAll(); &#125; &#125;&#125; AbstractConfigä¸­ä¾ç„¶ä¿ç•™JVMåœæ­¢é’©å­ 12345678910111213141516171819202122232425public abstract class AbstractConfig implements Serializable &#123; // çœç•¥æ— å…³ä»£ç ... static &#123; legacyProperties.put(\"dubbo.protocol.name\", \"dubbo.service.protocol\"); legacyProperties.put(\"dubbo.protocol.host\", \"dubbo.service.server.host\"); legacyProperties.put(\"dubbo.protocol.port\", \"dubbo.service.server.port\"); legacyProperties.put(\"dubbo.protocol.threads\", \"dubbo.service.max.thread.pool.size\"); legacyProperties.put(\"dubbo.consumer.timeout\", \"dubbo.service.invoke.timeout\"); legacyProperties.put(\"dubbo.consumer.retries\", \"dubbo.service.max.retry.providers\"); legacyProperties.put(\"dubbo.consumer.check\", \"dubbo.service.allow.no.provider\"); legacyProperties.put(\"dubbo.service.url\", \"dubbo.service.address\"); // this is only for compatibility /** * Dubbo çš„ä¼˜é›…åœæœº ShutdownHook åœ¨ AstractConfig çš„é™æ€ä»£ç å—ä¸­ï¼Œè¿™ä¿è¯äº†ShutdownHookèƒ½å¤Ÿç»™è¢«åˆå§‹åŒ–ã€‚ * è¯´æ˜ï¼š * 1 Dubbo æ˜¯ é€šè¿‡ JDKçš„ShutdownHookæ¥å®Œæˆä¼˜é›…åœæœºçš„ * 2 ShutdownHookæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªçº¿ç¨‹ï¼Œä»»åŠ¡ä½“åœ¨å¯¹åº”çš„runæ–¹æ³•ä¸­ */ Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook()); &#125; &#125; DubboShutdownHook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class DubboShutdownHook extends Thread &#123; private static final Logger logger = LoggerFactory.getLogger(DubboShutdownHook.class); /** * ShutdownHook,ç±»å±æ€§ */ private static final DubboShutdownHook dubboShutdownHook = new DubboShutdownHook(\"DubboShutdownHook\"); public static DubboShutdownHook getDubboShutdownHook() &#123; return dubboShutdownHook; &#125; /** * Has it already been destroyed or not? * &lt;p&gt; * æ˜¯å¦å·²ç»è¢«é”€æ¯æ ‡è¯† */ private final AtomicBoolean destroyed; private DubboShutdownHook(String name) &#123; super(name); this.destroyed = new AtomicBoolean(false); &#125; /** * ShutdownHookçš„ä»»åŠ¡ä½“ */ @Override public void run() &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Run shutdown hook now.\"); &#125; destroyAll(); &#125; /** * Destroy all the resources, including registries and protocols. * &lt;p&gt; * é”€æ¯æ‰€æœ‰çš„èµ„æºï¼ŒåŒ…æ‹¬ Registryç›¸å…³ å’Œ Protocolç›¸å…³ */ public void destroyAll() &#123; //å¦‚æœå·²ç»é”€æ¯åˆ™å¿½ç•¥ if (!destroyed.compareAndSet(false, true)) &#123; return; &#125; // é”€æ¯æ‰€æœ‰çš„ Registry,å–æ¶ˆåº”ç”¨ç¨‹åºä¸­çš„æœåŠ¡æä¾›è€…å’Œæ¶ˆè´¹è€…çš„è®¢é˜…ä¸æ³¨å†Œ AbstractRegistryFactory.destroyAll(); /** * é”€æ¯æ‰€æœ‰çš„ Protocol * * è¯´æ˜ï¼š * è¿™é‡Œçš„Protocolæ¯”è¾ƒå¤šï¼Œå¤§ä½“ä¸Šå¯ä»¥åˆ†ä¸¤ç±»ï¼š * 1 å’ŒRegistryç›¸å…³çš„Protocolï¼ŒRegistryProtocolå…³æ³¨æœåŠ¡çš„æ³¨å†Œ * 2 å…·ä½“åè®®ï¼Œå¦‚ DubboProtocolã€httpProtocolç­‰,å…³æ³¨æœåŠ¡çš„æš´éœ²å’Œå¼•ç”¨ */ ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol.class); for (String protocolName : loader.getLoadedExtensions()) &#123; try &#123; Protocol protocol = loader.getLoadedExtension(protocolName); if (protocol != null) &#123; protocol.destroy(); &#125; &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125;&#125; DubboShutdownHookä¸protocolã€registryçš„å…³ç³»å›¾ å›¾è§£(ä»¥dubboåè®®å’Œzookeeperæ³¨å†Œä¸­å¿ƒä¸ºä¾‹) Registryç›¸å…³ AbstractRegistryFactory#destroyAllæ–¹æ³•ï¼Œéå†æ‰€æœ‰çš„Registryå¹¶è°ƒç”¨Registry#destroyæ–¹æ³•ã€‚ç„¶åæ¸…ç©ºRegistryç¼“å­˜é›†åˆã€‚ AbstractRegistry å®ç°äº†å…¬ç”¨çš„é”€æ¯é€»è¾‘ï¼šå–æ¶ˆæ³¨å†Œå’Œè®¢é˜…ã€‚æœåŠ¡æä¾›è€…å’Œæ¶ˆè´¹è€…éƒ½ä¼šæ‰§è¡Œæ³¨å†Œå’Œè®¢é˜…ï¼Œå› æ­¤éƒ½éœ€è¦è¿›è¡Œå–æ¶ˆã€‚ FailbackRegistryå®ç°é”€æ¯å…¬ç”¨çš„é‡è¯•ä»»åŠ¡ ZookeeperRegistryé”€æ¯å…¶å¯¹åº”çš„å®¢æˆ·ç«¯è¿æ¥ Protocolç›¸å…³ AbstractProtocol#destroyæ–¹æ³•ï¼Œé”€æ¯åè®®å¯¹åº”çš„æœåŠ¡æ¶ˆè´¹è€…æ‹¥æœ‰çš„Invokerï¼Œ é”€æ¯åè®®å¯¹åº”çš„æœåŠ¡æä¾›è€…çš„æ‰€æœ‰Exporterã€‚ DubboProtocolé”€æ¯æ‰€æœ‰é€šä¿¡ ExchangeClient å’Œ ExchangeServer å°ç»“ dubbo2.6.3åœ¨springç¯å¢ƒä¸­æ³¨å†Œä¸¤ä¸ªé’©å­çš„æƒ…å†µï¼ŒShutdownHookListenerè§£å†³äº†å¹¶å‘æ‰§è¡Œé—®é¢˜ ä½¿ç”¨ShutdownHookListenerä¹Ÿä¸èƒ½ç§»é™¤è°ƒdubboæ³¨å†Œçš„jvmé’©å­ï¼Œå› ä¸ºä¸èƒ½ä¿è¯åº”ç”¨ä¸­ä¸€å®šä¼šæ³¨å†Œspringçš„shutdown hook 2.7.xä¼˜é›…åœæœºä»dubboçš„2.6.3ç‰ˆæœ¬å¼€å§‹ï¼Œè§£å†³äº†ä½¿ç”¨springæ„å»ºçš„dubboå¯èƒ½å‘ç”Ÿä¼˜é›…åœæœºå¹¶å‘æ‰§è¡Œshutdown hookçš„é—®é¢˜ã€‚ä½†æ˜¯è¿˜æ˜¯å­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯å¦‚æœåœ¨springç¯å¢ƒä¸‹æ²¡æœ‰æ³¨å†Œspringçš„jvmé’©å­ï¼Œè™½ç„¶æ²¡æœ‰å¤§é—®é¢˜ï¼Œä½†æ˜¯è¿˜æ˜¯æœ‰ä¸å®Œæ•´çš„ã€‚dubbo2.7.xè¿›è¡Œæ˜¾ç¤ºåœ°æ³¨å†Œspringçš„jvmé’©å­ï¼Œå¹¶ä¸”ç§»é™¤dubboçš„jvmé’©å­ï¼Œè§£å†³äº†å½“å‰é—®é¢˜ã€‚ 12345678910111213141516171819202122232425262728293031public class SpringExtensionFactory implements ExtensionFactory &#123; // çœç•¥å…¶å®ƒä»£ç ... private static final Set&lt;ApplicationContext&gt; CONTEXTS = new ConcurrentHashSet&lt;ApplicationContext&gt;(); private static final ApplicationListener SHUTDOWN_HOOK_LISTENER = new ShutdownHookListener(); public static void addApplicationContext(ApplicationContext context) &#123; CONTEXTS.add(context); if (context instanceof ConfigurableApplicationContext) &#123; // æ˜¾ç¤ºæ³¨å†Œspringçš„jvmé’©å­ ((ConfigurableApplicationContext) context).registerShutdownHook(); // æ˜¾ç¤ºç§»é™¤dubboçš„jvmé’©å­ DubboShutdownHook.getDubboShutdownHook().unregister(); &#125; BeanFactoryUtils.addApplicationListener(context, SHUTDOWN_HOOK_LISTENER); &#125; private static class ShutdownHookListener implements ApplicationListener &#123; @Override public void onApplicationEvent(ApplicationEvent event) &#123; if (event instanceof ContextClosedEvent) &#123; DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook(); shutdownHook.doDestroy(); &#125; &#125; &#125;&#125; è¯´æ˜ dubbo2.7.xä¼˜é›…åœæœºçš„å®ç°ï¼Œè§£å†³äº†springç¯å¢ƒä¸‹ä¸¤ä¸ªé’©å­å¹¶å‘çš„é—®é¢˜ï¼Œå¹¶ä¸”æ˜¾ç¤ºæ³¨å†Œspringçš„jvmé’©å­ã€‚ æ€»ç»“ä¼˜é›…åœæœºå¹¶ä¸æ˜¯javaä¸­çš„æ¦‚å¿µï¼Œä¹Ÿä¸æ˜¯åªæœ‰dubboæ¡†æ¶è¿›è¡Œäº†æ‰©å±•å®ç°ï¼Œspringbootã€dockerç­‰éƒ½æœ‰æ¶‰åŠåˆ°ä¼˜é›…åœæœºã€‚dubboä¸­çš„ä¼˜é›…åœæœºæ˜¯ä¸æ–­ä¼˜åŒ–çš„ï¼Œ2.5.xä¸­çš„å­˜åœ¨ä¸€å®šçš„é—®é¢˜ï¼Œ2.6.xåœ¨ä¸€èˆ¬åœºæ™¯ä¸‹æ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼Œ2.7.xæ˜¯å¯¹ä¹‹å‰ç‰ˆæœ¬çš„å®Œå–„å’Œä¼˜åŒ–ã€‚å¦‚æœ ShutdownHook ä¸èƒ½ç”Ÿæ•ˆï¼Œå¯ä»¥åœ¨éœ€è¦çš„æ—¶æœºè‡ªè¡Œè°ƒç”¨DubboShutdownHook.destroyAll()ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Spring","slug":"Spring","permalink":"https://gentryhuang.com/tags/Spring/"}]},{"title":"Dubboæºç åˆ†æ - æœ¬åœ°æš´éœ²","slug":"rpc/æœ¬åœ°å¯¼å‡º","date":"2020-10-14T16:00:00.000Z","updated":"2021-04-06T08:35:09.855Z","comments":false,"path":"posts/751c0982/","link":"","permalink":"https://gentryhuang.com/posts/751c0982/","excerpt":"","text":"å‰è¨€æœ‰äº†å‰é¢ä¸€ç³»åˆ—æ–‡ç« é“ºå«ï¼Œå†æ¥çœ‹æœåŠ¡æš´éœ²ä¸æœåŠ¡å¼•ç”¨å°±ç®€å•å¾ˆå¤šäº†ã€‚æœ¬åœ°æš´éœ²éœ€è¦é…ç½®ã€SPIã€åŠ¨æ€ä»£ç†ã€åè®®ç­‰çŸ¥è¯†ï¼Œå…¶ä¸­åè®®éƒ¨åˆ†ä¼šåœ¨åé¢çš„æ–‡ç« ä¸­ç€é‡åˆ†æã€‚ é…ç½®æ‰¿è½½æ— è®ºæ˜¯æœåŠ¡æš´éœ²è¿˜æ˜¯æœåŠ¡å¼•ç”¨ï¼ŒDubbo æ¡†æ¶éƒ½ä¼šæ ¹æ®é…ç½®è¦†ç›–ç­–ç•¥å¯¹é…ç½®é¡¹è¿›è¡Œèšåˆå¤„ç†ï¼Œé…ç½®è¦†ç›–ç­–ç•¥å‚è§å®˜ç½‘ ã€‚Dubbo æ”¯æŒåŠ¨æ€æ·»åŠ é…ç½®é¡¹å³æœåŠ¡æ²»ç†ï¼Œå…¶ä¸­ä¸å…è®¸ Provider ç«¯é…ç½®é¡¹é€ä¼ åˆ°å®¢æˆ·ç«¯çš„éƒ½ä¼šè¿›è¡Œç‰¹æ®Šå¤„ç†. æœåŠ¡æš´éœ²é…ç½® ä»…æœ¬åœ°æš´éœ²1&lt;dubbo:service scope=\"local\" /&gt; ä»…è¿œç¨‹æš´éœ²1&lt;dubbo:service scope=\"remote\" /&gt; æœ¬æš´éœ²å’Œè¿œç¨‹æš´éœ²1åœ¨ä¸é…ç½® scope çš„æƒ…å†µä¸‹ï¼Œé»˜è®¤ä¸¤ç§æ–¹å¼éƒ½æš´éœ² ä¸æš´éœ²1&lt;dubbo:service scope=\"none\" /&gt; æœåŠ¡æš´éœ²æœºåˆ¶Dubbo æœåŠ¡æš´éœ²åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œå…ˆå°†æŒæœ‰çš„æœåŠ¡ä¿¡æ¯ï¼ˆæœåŠ¡å¯¹è±¡ï¼ŒæœåŠ¡æ¥å£ï¼ŒæœåŠ¡ URLä¿¡æ¯ï¼‰é€šè¿‡åŠ¨æ€ä»£ç†å·¥å‚è½¬æ¢æˆ Invoker ï¼Œå†æŠŠ Invoker é€šè¿‡å…·ä½“çš„åè®®è½¬æˆ Exporterï¼ˆæ³¨æ„ï¼Œè¿™é‡Œæ¶‰åŠåˆ°å¤šåè®®çš„çŸ¥è¯†åé¢æ–‡ç« ä¼šè¯¦ç»†åˆ†æï¼‰ ã€‚Dubbo æ¡†æ¶åœ¨è¿›è¡ŒæœåŠ¡æš´éœ²æ—¶ï¼Œæ— è®ºæ˜¯ API é…ç½®ã€XML é…ç½®è¿˜æ˜¯æ³¨è§£é…ç½®ï¼Œæœ€ç»ˆéƒ½ä¼šè½¬æˆ ServiceBeanï¼Œå®ƒç»§æ‰¿è‡ª ServiceConfig ï¼Œæ³¨æ„è¿™é‡Œæ˜¯æŒ‡ä½¿ç”¨ Spring ç¯å¢ƒæ—¶ï¼Œå¦‚æœä»…ä½¿ç”¨ Dubbo API é…ç½®çš„è¯ï¼Œä¼šè½¬æˆ ServiceConfig ã€‚å› ä¸º Spring æ˜¯ä¸»æµï¼Œä¸‹é¢æ²¡æœ‰ç‰¹åˆ«è¯´æ˜éƒ½æ˜¯åœ¨ Spring ç¯å¢ƒä¸‹ã€‚ æœåŠ¡æš´éœ²æ–¹å¼Dubbo æ”¯æŒä¸¤ç§æœåŠ¡æš´éœ²æ–¹å¼ï¼Œåˆ†ä¸ºå»¶è¿Ÿæš´éœ²å’Œç«‹å³æš´éœ²ã€‚å»¶è¿Ÿæš´éœ²çš„å…¥å£æ˜¯ ServiceBean çš„ afterPropertiesSet æ–¹æ³•ï¼Œç«‹å³æš´éœ²çš„å…¥å£æ˜¯ ServiceBean çš„ onApplicationEvent æ–¹æ³•ã€‚ Springæ”¯æŒçš„ Dubbo IOC1234567891011121314151617181920212223242526272829303132333435public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener&lt;ContextRefreshedEvent&gt;, BeanNameAware, ApplicationEventPublisherAware &#123; @Override public void setApplicationContext(ApplicationContext applicationContext) &#123; this.applicationContext = applicationContext; // ä¸ºSpringæ‹“å±•å·¥å‚æ³¨å…¥ä¸Šä¸‹æ–‡ ,ç”¨äºDubbo IOC SpringExtensionFactory.addApplicationContext(applicationContext); if (applicationContext != null) &#123; SPRING_CONTEXT = applicationContext; try &#123; Method method = applicationContext.getClass().getMethod(\"addApplicationListener\", new Class&lt;?&gt;[]&#123;ApplicationListener.class&#125;); // backward compatibility to spring 2.0.1 method.invoke(applicationContext, new Object[]&#123;this&#125;); // å½“å‰Springå®¹å™¨æ˜¯å¦æ”¯æŒä¸Šä¸‹æ–‡ç›‘å¬ supportedApplicationListener = true; &#125; catch (Throwable t) &#123; if (applicationContext instanceof AbstractApplicationContext) &#123; try &#123; Method method = AbstractApplicationContext.class.getDeclaredMethod(\"addListener\", new Class&lt;?&gt;[]&#123;ApplicationListener.class&#125;); // backward compatibility to spring 2.0.1 if (!method.isAccessible()) &#123; method.setAccessible(true); &#125; method.invoke(applicationContext, new Object[]&#123;this&#125;); supportedApplicationListener = true; &#125; catch (Throwable t2) &#123; &#125; &#125; &#125; &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; ServiceBean#setApplicationContext æ–¹æ³•ç”¨äºå°† Spring çš„ä¸Šä¸‹æ–‡è®¾ç½®è®¾ç½®åˆ° SpringExtensionFactory ä¸­ï¼Œè¿™æ · Dubbo IOC å°±å¯ä»¥ä½¿ç”¨ Spring ç®¡ç†çš„å¯¹è±¡äº†ã€‚ å»¶è¿Ÿæš´éœ²12345678910111213141516171819202122232425262728293031323334353637383940414243public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener&lt;ContextRefreshedEvent&gt;, BeanNameAware, ApplicationEventPublisherAware &#123; /** * æœåŠ¡æš´éœ²çš„å…¥å£ï¼Œéå»¶è¿Ÿæš´éœ² ã€‚æ”¶åˆ° Spring å®¹å™¨çš„åˆ·æ–°äº‹ä»¶æ‰§è¡Œ * @param event */ @Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; // æ˜¯å¦æœ‰å»¶è¿Ÿæš´éœ² &amp;&amp; æ˜¯å¦å·²æš´éœ² &amp;&amp; æ˜¯ä¸æ˜¯å·²è¢«å–æ¶ˆæš´éœ² if (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"The service ready on spring started. service: \" + getInterface()); &#125; export(); &#125; &#125; private boolean isDelay() &#123; // è·å– delay Integer delay = getDelay(); ProviderConfig provider = getProvider(); if (delay == null &amp;&amp; provider != null) &#123; // å¦‚æœå‰é¢è·å–çš„ delay ä¸ºç©ºï¼Œè¿™é‡Œç»§ç»­è·å– delay = provider.getDelay(); &#125; /** * 1 åˆ¤æ–­ delay æ˜¯å¦ä¸ºç©ºï¼Œæˆ–è€…ç­‰äº -1ï¼Œå½“ delay ä¸ºç©ºï¼Œæˆ–è€…ç­‰äº-1æ—¶ï¼Œè¯¥æ–¹æ³•è¿”å› trueï¼Œè€Œä¸æ˜¯ false * 2 supportedApplicationListener å˜é‡ç”¨äºè¡¨ç¤ºå½“å‰çš„ Spring å®¹å™¨æ˜¯å¦æ”¯æŒ ApplicationListenerï¼Œè¿™ä¸ªå€¼åˆå§‹ä¸º falseã€‚ * åœ¨ Spring å®¹å™¨å°†è‡ªå·±è®¾ç½®åˆ° ServiceBean ä¸­æ—¶ï¼ŒServiceBean çš„ setApplicationContext æ–¹æ³•ä¼šæ£€æµ‹ Spring å®¹å™¨æ˜¯å¦æ”¯æŒ ApplicationListener,è‹¥æ”¯æŒï¼Œåˆ™å°† supportedApplicationListener ç½®ä¸º true */ return supportedApplicationListener &amp;&amp; (delay == null || delay == -1); &#125; public Integer getDelay() &#123; // é…ç½®é¡¹ return delay; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; æ³¨æ„ï¼Œè¿™é‡Œçš„ isDelay æ–¹æ³•ï¼Œå½“æ–¹æ³•è¿”å› true æ—¶ï¼Œè¡¨ç¤ºæ— éœ€å»¶è¿Ÿå¯¼å‡ºã€‚è¿”å› false æ—¶ï¼Œè¡¨ç¤ºéœ€è¦å»¶è¿Ÿå¯¼å‡ºï¼Œä¸å­—é¢æ„æ€æ˜¯ç›¸åçš„ã€‚ ç«‹å³æš´éœ²123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener&lt;ContextRefreshedEvent&gt;, BeanNameAware, ApplicationEventPublisherAware &#123; /** * æœåŠ¡æš´éœ²çš„å…¥å£ï¼Œå»¶è¿Ÿæš´éœ² * @throws Exception */ @Override @SuppressWarnings(&#123;\"unchecked\", \"deprecation\"&#125;) public void afterPropertiesSet() throws Exception &#123; if (getProvider() == null) &#123; Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, false, false); if (providerConfigMap != null &amp;&amp; providerConfigMap.size() &gt; 0) &#123; Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false); if ((protocolConfigMap == null || protocolConfigMap.size() == 0) &amp;&amp; providerConfigMap.size() &gt; 1) &#123; // backward compatibility List&lt;ProviderConfig&gt; providerConfigs = new ArrayList&lt;ProviderConfig&gt;(); for (ProviderConfig config : providerConfigMap.values()) &#123; if (config.isDefault() != null &amp;&amp; config.isDefault().booleanValue()) &#123; providerConfigs.add(config); &#125; &#125; if (!providerConfigs.isEmpty()) &#123; setProviders(providerConfigs); &#125; &#125; else &#123; ProviderConfig providerConfig = null; for (ProviderConfig config : providerConfigMap.values()) &#123; if (config.isDefault() == null || config.isDefault().booleanValue()) &#123; if (providerConfig != null) &#123; throw new IllegalStateException(\"Duplicate provider configs: \" + providerConfig + \" and \" + config); &#125; providerConfig = config; &#125; &#125; if (providerConfig != null) &#123; setProvider(providerConfig); &#125; &#125; &#125; &#125; if (getApplication() == null &amp;&amp; (getProvider() == null || getProvider().getApplication() == null)) &#123; Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false); if (applicationConfigMap != null &amp;&amp; applicationConfigMap.size() &gt; 0) &#123; ApplicationConfig applicationConfig = null; for (ApplicationConfig config : applicationConfigMap.values()) &#123; if (config.isDefault() == null || config.isDefault().booleanValue()) &#123; if (applicationConfig != null) &#123; throw new IllegalStateException(\"Duplicate application configs: \" + applicationConfig + \" and \" + config); &#125; applicationConfig = config; &#125; &#125; if (applicationConfig != null) &#123; setApplication(applicationConfig); &#125; &#125; &#125; if (getModule() == null &amp;&amp; (getProvider() == null || getProvider().getModule() == null)) &#123; Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false); if (moduleConfigMap != null &amp;&amp; moduleConfigMap.size() &gt; 0) &#123; ModuleConfig moduleConfig = null; for (ModuleConfig config : moduleConfigMap.values()) &#123; if (config.isDefault() == null || config.isDefault().booleanValue()) &#123; if (moduleConfig != null) &#123; throw new IllegalStateException(\"Duplicate module configs: \" + moduleConfig + \" and \" + config); &#125; moduleConfig = config; &#125; &#125; if (moduleConfig != null) &#123; setModule(moduleConfig); &#125; &#125; &#125; if ((getRegistries() == null || getRegistries().isEmpty()) &amp;&amp; (getProvider() == null || getProvider().getRegistries() == null || getProvider().getRegistries().isEmpty()) &amp;&amp; (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().isEmpty())) &#123; Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false); if (registryConfigMap != null &amp;&amp; registryConfigMap.size() &gt; 0) &#123; List&lt;RegistryConfig&gt; registryConfigs = new ArrayList&lt;RegistryConfig&gt;(); for (RegistryConfig config : registryConfigMap.values()) &#123; if (config.isDefault() == null || config.isDefault().booleanValue()) &#123; registryConfigs.add(config); &#125; &#125; if (registryConfigs != null &amp;&amp; !registryConfigs.isEmpty()) &#123; super.setRegistries(registryConfigs); &#125; &#125; &#125; if (getMonitor() == null &amp;&amp; (getProvider() == null || getProvider().getMonitor() == null) &amp;&amp; (getApplication() == null || getApplication().getMonitor() == null)) &#123; Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false); if (monitorConfigMap != null &amp;&amp; monitorConfigMap.size() &gt; 0) &#123; MonitorConfig monitorConfig = null; for (MonitorConfig config : monitorConfigMap.values()) &#123; if (config.isDefault() == null || config.isDefault().booleanValue()) &#123; if (monitorConfig != null) &#123; throw new IllegalStateException(\"Duplicate monitor configs: \" + monitorConfig + \" and \" + config); &#125; monitorConfig = config; &#125; &#125; if (monitorConfig != null) &#123; setMonitor(monitorConfig); &#125; &#125; &#125; if ((getProtocols() == null || getProtocols().isEmpty()) &amp;&amp; (getProvider() == null || getProvider().getProtocols() == null || getProvider().getProtocols().isEmpty())) &#123; Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false); if (protocolConfigMap != null &amp;&amp; protocolConfigMap.size() &gt; 0) &#123; List&lt;ProtocolConfig&gt; protocolConfigs = new ArrayList&lt;ProtocolConfig&gt;(); for (ProtocolConfig config : protocolConfigMap.values()) &#123; if (config.isDefault() == null || config.isDefault().booleanValue()) &#123; protocolConfigs.add(config); &#125; &#125; if (protocolConfigs != null &amp;&amp; !protocolConfigs.isEmpty()) &#123; super.setProtocols(protocolConfigs); &#125; &#125; &#125; if (getPath() == null || getPath().length() == 0) &#123; if (beanName != null &amp;&amp; beanName.length() &gt; 0 &amp;&amp; getInterface() != null &amp;&amp; getInterface().length() &gt; 0 &amp;&amp; beanName.startsWith(getInterface())) &#123; setPath(beanName); &#125; &#125; // å»¶è¿Ÿæš´éœ² if (!isDelay()) &#123; export(); &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; ServiceBean#afterPropertiesSet çš„æ–¹æ³•ä¸ä»…æ”¯æŒå»¶è¿Ÿæš´éœ²ï¼Œè¿˜ä¼šåœ¨ Spring ç”Ÿå‘½å‘¨æœŸå†…æŠŠ Dubbo çš„æ ¸å¿ƒé…ç½®æ‰¿è½½å¯¹è±¡è®¾ç½®åˆ° ServiceBean ä¸­ï¼ˆæˆ–å…¶çˆ¶ç±»ä¸­ï¼‰ã€‚ServiceBean é…ç½®ç»§æ‰¿å…³ç³»å¦‚ä¸‹ï¼š 123456- AbstractConfig - AbstractMethodConfig - AbstractInterfaceConfig - AbstractServiceConfig - ServiceConfig - ServiceBean å…³äºé…ç½®åœ¨ä¹‹å‰çš„æ–‡ç« ä¸­åº”è¯¦ç»†ä»‹ç»ï¼Œå¯ä»¥å‚è€ƒ APIå’Œå±æ€§é…ç½® ã€‚ æœåŠ¡æš´éœ²è¿‡ç¨‹ ä¸Šå›¾æ˜¯æœåŠ¡æœ¬åœ°æš´éœ²çš„ä¸»è¦æµç¨‹ï¼Œé…ç½®æ£€æŸ¥å’Œåˆå§‹åŒ–å®Œæˆåï¼Œç”Ÿæˆ URLï¼Œç„¶åå°†æœåŠ¡å¯¼å‡ºåˆ° JVM ä¸­ã€‚é…ç½®åŠ è½½åŠé…ç½®æ‰¿è½½å¯¹è±¡çš„åˆå§‹å¯¹åº”çš„ä¸‰ç§æ–¹å¼åœ¨å‰é¢çš„æ–‡ç« ä¸­å·²ç»è¯¦ç»†åˆ†æè¿‡ï¼Œå¯ä»¥å‚è€ƒ APIå’Œå±æ€§é…ç½® ã€XMLé…ç½® ã€æ³¨è§£é…ç½® ã€‚ä¸‹é¢åˆ†æå…·ä½“æºç ã€‚ æºç åˆ†æä»¥å»¶è¿Ÿæš´éœ²çš„æ–¹å¼è¿›è¡Œåˆ†æï¼Œé»˜è®¤æƒ…å†µä¸‹å°±æ˜¯å»¶è¿Ÿæš´éœ²çš„æ–¹å¼ã€‚ServiceBean æ˜¯ Dubbo æ¡†æ¶ä¸ Spring æ¡†æ¶è¿›è¡Œæ•´åˆçš„å…³é”®ï¼Œå¯ä»¥çœ‹åšæ˜¯ä¸¤ä¸ªæ¡†æ¶ä¹‹é—´çš„æ¡¥æ¢ã€‚ReferenceBean å…·æœ‰åŒæ ·çš„ä½œç”¨ã€‚ 1234567891011121314151617181920public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener&lt;ContextRefreshedEvent&gt;, BeanNameAware, ApplicationEventPublisherAware &#123; @Override public void export() &#123; // è°ƒç”¨çˆ¶ç±» ServiceConfig çš„ export æ–¹æ³•è¿›è¡ŒæœåŠ¡æš´éœ² super.export(); // å‘å¸ƒæœåŠ¡æš´éœ²å®Œæˆçš„äº‹ä»¶ publishExportEvent(); &#125; private void publishExportEvent() &#123; ServiceBeanExportedEvent exportEvent = new ServiceBeanExportedEvent(this); applicationEventPublisher.publishEvent(exportEvent); &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; ServiceBean ä¸­çš„å±æ€§ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener&lt;ContextRefreshedEvent&gt;, BeanNameAware, ApplicationEventPublisherAware &#123; private static final long serialVersionUID = 213195494150089726L; /** * Spring ä¸Šä¸‹æ–‡ */ private static transient ApplicationContext SPRING_CONTEXT; /** * Dubbo æœåŠ¡æ³¨è§£ */ private final transient Service service; /** * Spring ä¸Šä¸‹æ–‡ */ private transient ApplicationContext applicationContext; /** * æœåŠ¡å */ private transient String beanName; /** * æ˜¯å¦æ”¯æŒ Spring ä¸Šä¸‹æ–‡ç›‘å¬å™¨ */ private transient boolean supportedApplicationListener; /** * Spring äº‹ä»¶å‘å¸ƒå¯¹è±¡ */ private ApplicationEventPublisher applicationEventPublisher; /** * æ— å‚æ„é€ æ–¹æ³• */ public ServiceBean() &#123; super(); this.service = null; &#125; public ServiceBean(Service service) &#123; super(service); this.service = service; &#125; public static ApplicationContext getSpringContext() &#123; return SPRING_CONTEXT; &#125; /** * æ³¨å…¥äº‹ä»¶å‘å¸ƒå¯¹è±¡ * * @param applicationEventPublisher * @since 2.6.5 */ @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; this.applicationEventPublisher = applicationEventPublisher; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; å‡†å¤‡å·¥ä½œåœ¨æœåŠ¡æš´éœ²ä¹‹å‰ï¼ŒDubbo éœ€è¦æ£€æŸ¥é…ç½®ï¼Œæˆ–è€…è¡¥å……ç¼ºçœé…ç½®ã€‚é…ç½®æ£€æŸ¥å®Œæ¯•åï¼Œä¼šæ ¹æ®é…ç½®ç»„è£… URL ã€‚åœ¨ Dubbo ä¸­ï¼ŒURL ååˆ†é‡è¦ï¼Œè¯¦ç»†å‚è§ URLç»Ÿä¸€æ¨¡å‹ ã€‚ æ£€æŸ¥é…ç½®æˆ‘ä»¬ç»§ç»­ä»å…¥å£çœ‹èµ·ï¼ŒServiceBean çš„çˆ¶ç±» ServiceConfig ç±»ï¼Œä¸‹é¢æˆ‘ä»¬å…ˆçœ‹ä¸‹è¿™ä¸ªç±»ä¸­çš„å±æ€§ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class ServiceConfig&lt;T&gt; extends AbstractServiceConfig &#123; private static final long serialVersionUID = 3033787999037024738L; /** * è‡ªé€‚åº” Protocol å®ç°å¯¹è±¡ */ private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension(); /** * è‡ªé€‚åº” ProxyFactory å®ç°å¯¹è±¡ */ private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension(); /** * éšæœºç«¯å£ */ private static final Map&lt;String, Integer&gt; RANDOM_PORT_MAP = new HashMap&lt;String, Integer&gt;(); /** * å»¶æ—¶æš´éœ²çº¿ç¨‹æ±  */ private static final ScheduledExecutorService delayExportExecutor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"DubboServiceDelayExporter\", true)); /** * æœåŠ¡URLé›†åˆ */ private final List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); /** * æœåŠ¡é…ç½®æš´éœ²çš„Exporter: * URL: Exporter ä¸ä¸€å®šæ˜¯ 1:1 çš„å…³ç³»ï¼Œéœ€è¦çœ‹scopeçš„å€¼ï¼š * 1 scope æœªè®¾ç½®æ—¶ï¼Œä¼šæš´éœ²Local + Remoteä¸¤ä¸ªï¼Œä¹Ÿå°±æ˜¯URL : Exporter = 1:2 * 2 scopeè®¾ç½®ä¸ºç©ºæ—¶ï¼Œä¸ä¼šæš´éœ²ï¼Œä¹Ÿå°±æ˜¯URL:Exporter = 1:0 * 3 scopeç”šè‡³ä¸ºlocal æˆ– Remote ä»»ä¸€ä¸ªæ—¶ï¼Œä¼šæš´éœ²å¯¹åº”çš„ï¼Œä¹Ÿå°±æ˜¯URL:Exporter = 1:1 */ private final List&lt;Exporter&lt;?&gt;&gt; exporters = new ArrayList&lt;Exporter&lt;?&gt;&gt;(); /** * æ¥å£å */ private String interfaceName; /** * éé…ç½®ï¼Œé€šè¿‡interfaceName é€šè¿‡åå°„è·å¾— */ private Class&lt;?&gt; interfaceClass; /** * æœåŠ¡æ¥å£çš„å®ç°å¯¹è±¡ */ private T ref; /** * æœåŠ¡å */ private String path; /** * æ–¹æ³•é…ç½®å¯¹è±¡é›†åˆ */ private List&lt;MethodConfig&gt; methods; /** * æä¾›è€…é…ç½®å¯¹è±¡ */ private ProviderConfig provider; /** * æ˜¯å¦å·²ç»æš´éœ² */ private transient volatile boolean exported; /** * æ˜¯å¦æœªæš´éœ² */ private transient volatile boolean unexported; /** * æ³›åŒ– */ private volatile String generic; public ServiceConfig() &#123; &#125; public ServiceConfig(Service service) &#123; appendAnnotation(Service.class, service); &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; ä¸‹é¢æˆ‘ä»¬ä» ServiceConfig#export æ–¹æ³•ç»§ç»­è¿›è¡Œåˆ†æï¼Œå¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930/** * æš´éœ²æœåŠ¡å…¥å£ï¼ŒåŠ jvmé” */ public synchronized void export() &#123; // å½“export æˆ–è€… delay æœªé…ç½®æ—¶ï¼Œä»ProviderConfigå¯¹è±¡è¯»å– if (provider != null) &#123; if (export == null) &#123; export = provider.getExport(); &#125; if (delay == null) &#123; delay = provider.getDelay(); &#125; &#125; // ä¸æš´éœ²æœåŠ¡(export = false),åˆ™ä¸è¿›è¡Œæš´éœ²æœåŠ¡é€»è¾‘ if (export != null &amp;&amp; !export) &#123; return; &#125; // å»¶è¿Ÿæš´éœ²çš„è¯ï¼Œå°±æ˜¯ä½¿ç”¨ä»»åŠ¡çº¿ç¨‹æ± ScheduledExecutorServiceå¤„ç† if (delay != null &amp;&amp; delay &gt; 0) &#123; delayExportExecutor.schedule(new Runnable() &#123; @Override public void run() &#123; doExport(); &#125; &#125;, delay, TimeUnit.MILLISECONDS); &#125; else &#123; doExport(); &#125; &#125; éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬åªæ˜¯æƒ³æœ¬åœ°å¯åŠ¨æœåŠ¡è¿›è¡Œä¸€äº›è°ƒè¯•å·¥ä½œï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¹¶ä¸å¸Œæœ›æŠŠæœ¬åœ°å¯åŠ¨çš„æœåŠ¡æš´éœ²å‡ºå»ï¼Œæ­¤æ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡é…ç½® export ç¦æ­¢æœåŠ¡æš´éœ²ï¼Œå¦‚ï¼š &lt;dubbo:provider export=â€falseâ€ /&gt; æˆ‘ä»¬ç»§ç»­è·Ÿè¿› doExport æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸»è¦è¿›è¡Œé…ç½®çš„å¤„ç†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/** * æœåŠ¡æš´éœ²ï¼Œjvmé” */ protected synchronized void doExport() &#123; // æ£€æŸ¥æ˜¯å¦å¯ä»¥æš´éœ²ï¼Œè‹¥å¯ä»¥ï¼Œæ ‡è®°å·²ç»æš´éœ²ç„¶åæ‰§è¡ŒæœåŠ¡æš´éœ²é€»è¾‘ if (unexported) &#123; throw new IllegalStateException(\"Already unexported!\"); &#125; // å¦‚æœå·²ç»æš´éœ²äº†ç›´æ¥è¿”å› if (exported) &#123; return; &#125; // æ ‡è®°å·²ç»æš´éœ²è¿‡äº† exported = true; // æ ¡éªŒinterfaceName æ˜¯å¦åˆæ³•ï¼Œå³æ¥å£åéç©º if (interfaceName == null || interfaceName.length() == 0) &#123; throw new IllegalStateException(\"&lt;dubbo:service interface=\\\"\\\" /&gt; interface not allow null!\"); &#125; // æ ¡éªŒprovideræ˜¯å¦ä¸ºç©º(ä¸ºç©ºåˆ™æ–°å»ºä¸€ä¸ª)å¹¶æ‹¼æ¥å±æ€§é…ç½®ï¼ˆç¯å¢ƒå˜é‡ + .propertiesæ–‡ä»¶ä¸­çš„ å±æ€§ï¼‰åˆ°ProviderConfigå¯¹è±¡ checkDefault(); // æ£€æµ‹applicationï¼Œmoduleç­‰æ ¸å¿ƒé…ç½®ç±»å¯¹è±¡æ˜¯å¦ä¸ºç©ºï¼Œè‹¥ä¸ºç©ºåˆ™å°è¯•ä»å…¶ä»–é…ç½®ç±»å¯¹è±¡ä¸­è·å–å¯¹åº”çš„å®ä¾‹ã€‚å³ï¼š ä»ProviderConfig å¯¹è±¡ä¸­ï¼Œè¯»å–application,module,registries,monitor,protocolsé…ç½®å¯¹è±¡ if (provider != null) &#123; if (application == null) &#123; application = provider.getApplication(); &#125; if (module == null) &#123; module = provider.getModule(); &#125; if (registries == null) &#123; registries = provider.getRegistries(); &#125; if (monitor == null) &#123; monitor = provider.getMonitor(); &#125; if (protocols == null) &#123; protocols = provider.getProtocols(); &#125; &#125; // ä»ModuleConfig å¯¹è±¡ä¸­ï¼Œè¯»å–registries,monitoré…ç½®å¯¹è±¡ if (module != null) &#123; if (registries == null) &#123; registries = module.getRegistries(); &#125; if (monitor == null) &#123; monitor = module.getMonitor(); &#125; &#125; // ä»ApplicationConfig å¯¹è±¡ä¸­ï¼Œè¯»å–registries,monitoré…ç½®å¯¹è±¡ if (application != null) &#123; if (registries == null) &#123; registries = application.getRegistries(); &#125; if (monitor == null) &#123; monitor = application.getMonitor(); &#125; &#125; // æ£€æµ‹refæ˜¯å¦æ³›åŒ–æ¥å£çš„å®ç° if (ref instanceof GenericService) &#123; // è®¾ç½® interfaceClass ä¸º GenericService.class interfaceClass = GenericService.class; if (StringUtils.isEmpty(generic)) &#123; // è®¾ç½® generic = \"true\" generic = Boolean.TRUE.toString(); &#125; // æ™®é€šæ¥å£çš„å®ç° &#125; else &#123; try &#123; // é€šè¿‡åå°„è·å–å¯¹åº”çš„æ¥å£çš„Class interfaceClass = Class.forName(interfaceName, true, Thread.currentThread() .getContextClassLoader()); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; // æ£€éªŒæ¥å£å’Œæ–¹æ³• ï¼ˆæ¥å£éç©ºï¼Œæ–¹æ³•éƒ½åœ¨æ¥å£ä¸­å®šä¹‰ï¼‰ checkInterfaceAndMethods(interfaceClass, methods); // æ ¡éªŒå¼•ç”¨refæ˜¯å¦å®ç°äº†å½“å‰æ¥å£ checkRef(); // æ ‡è®°ä¸ºéæ³›åŒ–å®ç° generic = Boolean.FALSE.toString(); &#125; /** å¤„ç†æœåŠ¡æ¥å£å®¢æˆ·ç«¯æœ¬åœ°ä»£ç†,å³æœ¬åœ°å­˜æ ¹ã€‚ç›®å‰å·²ç»åºŸå¼ƒï¼Œæ­¤å¤„ä¸»è¦ç”¨äºå…¼å®¹ï¼Œä½¿ç”¨stubå±æ€§. todo æœåŠ¡ç«¯æ²¡æœ‰æ„ä¹‰ &#123;@link StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125; */ if (local != null) &#123; // å¦‚æœlocalå±æ€§è®¾ç½®ä¸ºtureï¼Œè¡¨ç¤ºä½¿ç”¨ç¼ºçœä»£ç†ç±»åï¼Œå³ï¼šæ¥å£å + Local åç¼€ if (\"true\".equals(local)) &#123; local = interfaceName + \"Local\"; &#125; Class&lt;?&gt; localClass; try &#123; // è·å–æœ¬åœ°å­˜æ ¹ç±» localClass = ClassHelper.forNameWithThreadContextClassLoader(local); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; // æ£€æµ‹æœ¬åœ°å­˜æ ¹ç±»æ˜¯å¦å¯èµ‹å€¼ç»™æ¥å£ç±»ï¼Œè‹¥ä¸å¯èµ‹å€¼åˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œæé†’ä½¿ç”¨è€…æœ¬åœ°å­˜æ ¹ç±»ç±»å‹ä¸åˆæ³• if (!interfaceClass.isAssignableFrom(localClass)) &#123; throw new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceName); &#125; &#125; /** å¤„ç†æœåŠ¡æ¥å£å®¢æˆ·ç«¯æœ¬åœ°ä»£ç†(stub å±æ€§)ç›¸å…³ï¼Œå³æœ¬åœ°å­˜æ ¹ã€‚ç›®çš„ï¼šæƒ³åœ¨å®¢æˆ·ç«¯ã€æœåŠ¡æ¶ˆè´¹æ–¹ã€‘æ‰§è¡Œéœ€è¦çš„é€»è¾‘ï¼Œä¸å±€é™æœåŠ¡æä¾›çš„é€»è¾‘ã€‚æœ¬åœ°å­˜æ ¹ç±»ç¼–å†™æ–¹å¼æ˜¯å›ºå®šã€‚todo æœåŠ¡ç«¯æ²¡æœ‰æ„ä¹‰ &#123;@link StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125;*/ if (stub != null) &#123; // å¦‚æœstubå±æ€§è®¾ç½®ä¸ºtureï¼Œè¡¨ç¤ºä½¿ç”¨ç¼ºçœä»£ç†ç±»åï¼Œå³ï¼šæ¥å£å + Stub åç¼€ if (\"true\".equals(stub)) &#123; stub = interfaceName + \"Stub\"; &#125; Class&lt;?&gt; stubClass; try &#123; // è·å–æœ¬åœ°å­˜æ ¹ç±» stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; // åˆ¤æ–­interfaceClass æ˜¯å¦æ˜¯ stubClass çš„æ¥å£ï¼Œå³ æ£€æµ‹æœ¬åœ°å­˜æ ¹ç±»æ˜¯å¦å¯èµ‹å€¼ç»™æ¥å£ç±»ï¼Œè‹¥ä¸å¯èµ‹å€¼åˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œæé†’ä½¿ç”¨è€…æœ¬åœ°å­˜æ ¹ç±»ç±»å‹ä¸åˆæ³• if (!interfaceClass.isAssignableFrom(stubClass)) &#123; throw new IllegalStateException(\"The stub implementation class \" + stubClass.getName() + \" not implement interface \" + interfaceName); &#125; &#125; // æ ¡éªŒApplicationConfigé…ç½® checkApplication(); // æ ¡éªŒRegistryConfigé…ç½® checkRegistry(); // æ ¡éªŒProtocolConfigé…ç½®æ•°ç»„ checkProtocol(); // è¯»å–ç¯å¢ƒå˜é‡å’Œpropertiesé…ç½®åˆ°ServiceConfigå¯¹è±¡ï¼ˆè‡ªå·±ï¼‰ appendProperties(this); // æ ¡éªŒStubå’ŒMockç›¸å…³çš„é…ç½® checkStubAndMock(interfaceClass); // æœåŠ¡è·¯å¾„ï¼Œç¼ºçœæ˜¯æ¥å£å if (path == null || path.length() == 0) &#123; path = interfaceName; &#125; // æš´éœ²æœåŠ¡ doExportUrls(); /** * 1 ProviderModel è¡¨ç¤ºæœåŠ¡æä¾›è€…æ¨¡å‹ï¼Œæ­¤å¯¹è±¡ä¸­å­˜å‚¨äº†å’ŒæœåŠ¡æä¾›è€…ç›¸å…³çš„ä¿¡æ¯ï¼Œæ¯”å¦‚æœåŠ¡çš„é…ç½®ä¿¡æ¯ï¼ŒæœåŠ¡å®ä¾‹ç­‰ã€‚æ¯ä¸ªè¢«å¯¼å‡ºçš„æœåŠ¡å¯¹åº”ä¸€ä¸ª ProviderModel * 2 ApplicationModel æŒæœ‰æ‰€æœ‰çš„ ProviderModel */ ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref); ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel); &#125; ä»¥ä¸Šå°±æ˜¯é…ç½®æ£€æŸ¥çš„ç›¸å…³åˆ†æï¼Œä¸‹é¢å¯¹é…ç½®æ£€æŸ¥çš„ä¸»è¦é€»è¾‘è¿›è¡Œç®€å•çš„æ€»ç»“ï¼Œå¦‚ä¸‹ï¼š æ£€æµ‹ dubbo:service æ ‡ç­¾çš„ interface å±æ€§åˆæ³•æ€§ï¼Œä¸åˆæ³•åˆ™æŠ›å‡ºå¼‚å¸¸ æ£€æµ‹ ProviderConfigã€ApplicationConfig ç­‰æ ¸å¿ƒé…ç½®ç±»å¯¹è±¡æ˜¯å¦ä¸ºç©ºï¼Œè‹¥ä¸ºç©ºï¼Œåˆ™å°è¯•åˆ›å»ºæˆ–ä»å…¶ä»–é…ç½®ç±»å¯¹è±¡ä¸­è·å–ç›¸åº”çš„å®ä¾‹ã€‚ æ£€æµ‹å¹¶å¤„ç†æ³›åŒ–æœåŠ¡å’Œæ™®é€šæœåŠ¡ç±» æ£€æµ‹æœ¬åœ°å­˜æ ¹é…ç½®ï¼Œå¹¶è¿›è¡Œç›¸åº”çš„å¤„ç† å¯¹ ApplicationConfigã€RegistryConfig ç­‰é…ç½®ç±»è¿›è¡Œæ£€æµ‹ï¼Œå¹¶è¯»å–ç¯å¢ƒå˜é‡å’Œpropertiesé…ç½®åˆ°é…ç½®æ‰¿è½½å¯¹è±¡ä¸­ è®¾ç½®é…ç½®åˆ°é…ç½®æ‰¿è½½å¯¹è±¡åœ¨ä¹‹å‰çš„æ–‡ç« ä¸­è¯¦ç»†è¯´æ˜äº†ï¼Œå¯ä»¥å‚è§ APIå’Œå±æ€§é…ç½® ã€‚ å¤šåè®®å¤šæ³¨å†Œä¸­å¿ƒæš´éœ²Dubbo å…è®¸ä½¿ç”¨ä¸åŒçš„åè®®æš´éœ²æœåŠ¡ï¼Œä¹Ÿæ”¯æŒå‘å¤šä¸ªæ³¨å†Œä¸­å¿ƒæ³¨å†ŒæœåŠ¡ï¼ŒDubbo åœ¨ ServiceConifg#doExportUrls ä¸­å¯¹å¤šåè®®ï¼Œå¤šæ³¨å†Œä¸­å¿ƒè¿›è¡Œäº†æ”¯æŒï¼Œä»£ç å¦‚ä¸‹ï¼š 12345678private void doExportUrls() &#123; // åŠ è½½æ³¨å†Œä¸­å¿ƒURL æ•°ç»„ ã€åè®®å·²ç»å¤„ç†è¿‡ï¼Œä¸å†æ˜¯é…ç½®çš„æ³¨å†Œä¸­å¿ƒåè®® å¦‚ï¼šzookeeper ,è€Œæ˜¯ç»Ÿä¸€æ›¿æ¢æˆäº†registryã€‘ List&lt;URL&gt; registryURLs = loadRegistries(true); // éå†åè®®é›†åˆï¼Œæ”¯æŒå¤šåè®®æš´éœ²ã€‚ for (ProtocolConfig protocolConfig : protocols) &#123; doExportUrlsFor1Protocol(protocolConfig, registryURLs); &#125; &#125; ä¸Šé¢ä»£ç æ¯”è¾ƒç®€å•ï¼Œé¦–å…ˆæ˜¯é€šè¿‡ loadRegistries åŠ è½½æ³¨å†Œä¸­å¿ƒURLï¼Œç„¶åå†éå† ProtocolConfig é›†åˆä½¿ç”¨å…·ä½“çš„åè®®å¯¼å‡ºæ¯ä¸ªæœåŠ¡ã€‚å¹¶åœ¨å¯¼å‡ºæœåŠ¡çš„è¿‡ç¨‹ä¸­ï¼Œå°†æœåŠ¡æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒã€‚ä¸‹é¢ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹ loadRegistries æ–¹æ³•çš„é€»è¾‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217/** * åŠ è½½æ³¨å†Œä¸­å¿ƒURLæ•°ç»„ * * @param provider æ˜¯å¦æ˜¯æœåŠ¡æä¾›è€… * @return URLæ•°ç»„ */ protected List&lt;URL&gt; loadRegistries(boolean provider) &#123; // æ ¡éªŒRegistryConfig é…ç½®æ•°ç»„ï¼Œä¸å­˜åœ¨ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œå¹¶ä¸”è¯¥æ–¹æ³•ä¼šåˆå§‹åŒ–RegistryConfigçš„é…ç½®å±æ€§ã€è§APIä¸å±æ€§é…ç½®ã€‘ checkRegistry(); // åˆ›å»ºæ³¨å†Œä¸­å¿ƒURLæ•°ç»„ List&lt;URL&gt; registryList = new ArrayList&lt;URL&gt;(); if (registries != null &amp;&amp; !registries.isEmpty()) &#123; // éå†RegistryConfig æ•°ç»„ for (RegistryConfig config : registries) &#123; // è·å–æ³¨å†Œä¸­å¿ƒçš„åœ°å€ String address = config.getAddress(); // åœ°å€ä¸ºç©ºå°±ä½¿ç”¨ 0.0.0.0 ä»»æ„åœ°å€ if (address == null || address.length() == 0) &#123; address = Constants.ANYHOST_VALUE; &#125; // å¦‚æœé…ç½®äº†å¯åŠ¨å‚æ•°çš„æ³¨å†Œä¸­å¿ƒåœ°å€ï¼Œå®ƒçš„ä¼˜å…ˆçº§æœ€é«˜ï¼Œå°±è¿›è¡Œè¦†ç›– String sysaddress = System.getProperty(\"dubbo.registry.address\"); if (sysaddress != null &amp;&amp; sysaddress.length() &gt; 0) &#123; address = sysaddress; &#125; // é€‰æ‹©æœ‰æ•ˆçš„æ³¨å†Œä¸­å¿ƒåœ°å€ if (address.length() &gt; 0 &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123; // åˆ›å»ºå‚æ•°é›†åˆmap,ç”¨äº URLçš„æ„å»º Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // å°†åº”ç”¨é…ç½®å¯¹è±¡å’Œæ³¨å†Œä¸­å¿ƒé…ç½®å¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°å‚æ•°é›†åˆmapä¸­ appendParameters(map, application); /** * éœ€è¦æ³¨æ„çš„æ˜¯ï¼šRegistryConfig çš„ getAddressæ–¹æ³•ä¸Šä½¿ç”¨äº† @Parameter(excluded = true)æ³¨è§£ï¼Œå› æ­¤å®ƒçš„addresså±æ€§ä¸ä¼šåŠ å…¥åˆ°å‚æ•°é›†åˆmapä¸­ * @Parameter(excluded = true) * public String getAddress() &#123;return address;&#125; */ appendParameters(map, config); // æ·»åŠ  path,dubbo,timestamp,pid åˆ°å‚æ•°é›†åˆmapä¸­ map.put(\"path\", RegistryService.class.getName()); // è¿™é‡Œçš„pathè¦å’ŒæœåŠ¡æš´éœ²é€»è¾‘ä¸­çš„pathåŒºåˆ†ï¼Œæ³¨å†Œä¸­å¿ƒçš„URLä¸­çš„pathä¸ºRegistryServiceçš„å…¨è·¯å¾„å map.put(\"dubbo\", Version.getProtocolVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; // å‚æ•°é›†åˆmapä¸­ä¸å­˜åœ¨ protocol å‚æ•°ã€ä»¥ä¸Šé…ç½®å¯¹è±¡çš„å±æ€§ä¸­æ²¡æœ‰æœ‰æ•ˆçš„åè®®protocolå‚æ•°ã€‘ï¼Œå°±é»˜è®¤ ä½¿ç”¨ dubbo ä½œä¸º åè®®protocolçš„å€¼ if (!map.containsKey(\"protocol\")) &#123; // todo remoteæ‰©å±•å®ç°å·²ç»ä¸å­˜åœ¨äº†ï¼Œä¸éœ€è€ƒè™‘è¿™ç§æƒ…å†µ if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(\"remote\")) &#123; map.put(\"protocol\", \"remote\"); &#125; else &#123; map.put(\"protocol\", \"dubbo\"); &#125; &#125; // è§£æåœ°å€ï¼Œåˆ›å»º URLæ•°ç»„ï¼Œæ³¨æ„addresså¯èƒ½åŒ…å«å¤šä¸ªæ³¨å†Œä¸­å¿ƒip, ã€æ•°ç»„å¤§å°å¯èƒ½ä¸ºä¸€ã€‘ List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map); // å¾ªç¯ dubbo Register url for (URL url : urls) &#123; // è®¾ç½® registry=$&#123;protocol&#125;å‚æ•°,è®¾ç½®åˆ°æ³¨å†Œä¸­å¿ƒçš„ URLçš„å‚æ•°éƒ¨åˆ†çš„ä½ç½®ä¸Šï¼Œå¹¶ä¸”æ˜¯è¿½åŠ å¼çš„æ·»åŠ  url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol()); // é‡ç½® URLä¸­çš„ protocolå±æ€§ä¸º 'registry',å³å°†URLçš„åè®®å¤´è®¾ç½®ä¸º'registry' url = url.setProtocol(Constants.REGISTRY_PROTOCOL); /** * é€šè¿‡åˆ¤æ–­æ¡ä»¶ï¼Œå†³å®šæ˜¯å¦æ·»åŠ urlåˆ°registryListä¸­ï¼Œæ¡ä»¶å¦‚ä¸‹ï¼š * 1 å¦‚æœæ˜¯æœåŠ¡æä¾›è€…,æ˜¯å¦åªè®¢é˜…ä¸æ³¨å†Œï¼Œå¦‚æœæ˜¯å°±ä¸æ·»åŠ åˆ°æ³¨å†Œä¸­å¿ƒURLæ•°ç»„ä¸­ * 2 å¦‚æœæ˜¯æœåŠ¡æ¶ˆè´¹è€…ï¼Œæ˜¯å¦æ˜¯åªæ³¨å†Œä¸è®¢é˜…ï¼Œå¦‚æœæ˜¯å°±ä¸æ·»åŠ åˆ°æ³¨å†Œä¸­å¿ƒURLæ•°ç»„ä¸­ */ if ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, true))) &#123; registryList.add(url); &#125; &#125; &#125; &#125; &#125; return registryList; &#125; /** * è§£ææ³¨å†Œä¸­å¿ƒåœ°å€ï¼Œåˆ›å»º URLæ•°ç»„ * * @param address * @param defaults * @return */ public static List&lt;URL&gt; parseURLs(String address, Map&lt;String, String&gt; defaults) &#123; // åˆ¤æ–­æ³¨å†Œä¸­å¿ƒåœ°å€çš„æœ‰æ•ˆæ€§ if (address == null || address.length() == 0) &#123; return null; &#125; // æ³¨å†Œä¸­å¿ƒåœ°å€address å¯ä»¥ä½¿ç”¨\"|\"æˆ–\";\"ä½œä¸ºåˆ†å‰²ç¬¦ï¼Œè®¾ç½®å¤šä¸ªæ³¨å†Œä¸­å¿ƒåˆ†ç»„ã€‚æ³¨æ„ï¼šä¸€ä¸ªæ³¨å†Œä¸­å¿ƒé›†ç¾¤æ˜¯ä¸€ä¸ªåˆ†ç»„è€Œä¸æ˜¯å¤šä¸ªã€‚ String[] addresses = Constants.REGISTRY_SPLIT_PATTERN.split(address); if (addresses == null || addresses.length == 0) &#123; return null; //here won't be empty &#125; List&lt;URL&gt; registries = new ArrayList&lt;URL&gt;(); // éå†æ³¨å†Œä¸­å¿ƒåˆ†ç»„ for (String addr : addresses) &#123; registries.add(parseURL(addr, defaults)); &#125; return registries; &#125; /** * è§£æå•ä¸ª URLï¼Œå°†defaultså±æ€§é›†åˆ é‡Œçš„å‚æ•°åˆå¹¶åˆ° æ³¨å†Œä¸­å¿ƒåœ°å€addressä¸­ï¼Œåˆå¹¶é€»è¾‘ï¼š * ä½¿ç”¨ defaults é›†åˆå¯¹æ³¨å†Œä¸­å¿ƒurLçš„å±æ€§ è¿›è¡Œ 'æŸ¥æ¼è¡¥ç¼º', å³ å°†defaultsé›†åˆä¸­ä¸åœ¨ æ³¨å†Œä¸­å¿ƒurlä¸Šçš„å±æ€§ è®¾ç½®åˆ°urlä¸Šï¼Œå­˜åœ¨åˆ™å¿½ç•¥ * * @param address æ³¨å†Œä¸­å¿ƒåœ°å€ * @param defaults å‚æ•°é›†åˆ * @return Dubbo URL */ public static URL parseURL(String address, Map&lt;String, String&gt; defaults) &#123; if (address == null || address.length() == 0) &#123; return null; &#125; String url; if (address.indexOf(\"://\") &gt;= 0) &#123; url = address; &#125; else &#123; String[] addresses = Constants.COMMA_SPLIT_PATTERN.split(address); url = addresses[0]; if (addresses.length &gt; 1) &#123; StringBuilder backup = new StringBuilder(); for (int i = 1; i &lt; addresses.length; i++) &#123; if (i &gt; 1) &#123; backup.append(\",\"); &#125; backup.append(addresses[i]); &#125; url += \"?\" + Constants.BACKUP_KEY + \"=\" + backup.toString(); &#125; &#125; String defaultProtocol = defaults == null ? null : defaults.get(\"protocol\"); if (defaultProtocol == null || defaultProtocol.length() == 0) &#123; defaultProtocol = \"dubbo\"; &#125; String defaultUsername = defaults == null ? null : defaults.get(\"username\"); String defaultPassword = defaults == null ? null : defaults.get(\"password\"); int defaultPort = StringUtils.parseInteger(defaults == null ? null : defaults.get(\"port\")); String defaultPath = defaults == null ? null : defaults.get(\"path\"); Map&lt;String, String&gt; defaultParameters = defaults == null ? null : new HashMap&lt;String, String&gt;(defaults); if (defaultParameters != null) &#123; defaultParameters.remove(\"protocol\"); defaultParameters.remove(\"username\"); defaultParameters.remove(\"password\"); defaultParameters.remove(\"host\"); defaultParameters.remove(\"port\"); defaultParameters.remove(\"path\"); &#125; // åˆ†ç¦»urlä¸­çš„å„ä¸ªå‚æ•°ï¼Œç„¶åæ ¹æ®å„ä¸ªå‚æ•°æ„å»ºæ ‡å‡†çš„Dubbo URL -&gt; protocol://username:password@host:port/path?key=value&amp;key=value... URL u = URL.valueOf(url); boolean changed = false; String protocol = u.getProtocol(); String username = u.getUsername(); String password = u.getPassword(); String host = u.getHost(); int port = u.getPort(); String path = u.getPath(); Map&lt;String, String&gt; parameters = new HashMap&lt;String, String&gt;(u.getParameters()); if ((protocol == null || protocol.length() == 0) &amp;&amp; defaultProtocol != null &amp;&amp; defaultProtocol.length() &gt; 0) &#123; changed = true; protocol = defaultProtocol; &#125; if ((username == null || username.length() == 0) &amp;&amp; defaultUsername != null &amp;&amp; defaultUsername.length() &gt; 0) &#123; changed = true; username = defaultUsername; &#125; if ((password == null || password.length() == 0) &amp;&amp; defaultPassword != null &amp;&amp; defaultPassword.length() &gt; 0) &#123; changed = true; password = defaultPassword; &#125; if (port &lt;= 0) &#123; if (defaultPort &gt; 0) &#123; changed = true; port = defaultPort; &#125; else &#123; changed = true; port = 9090; &#125; &#125; if (path == null || path.length() == 0) &#123; if (defaultPath != null &amp;&amp; defaultPath.length() &gt; 0) &#123; changed = true; path = defaultPath; &#125; &#125; if (defaultParameters != null &amp;&amp; defaultParameters.size() &gt; 0) &#123; for (Map.Entry&lt;String, String&gt; entry : defaultParameters.entrySet()) &#123; String key = entry.getKey(); String defaultValue = entry.getValue(); if (defaultValue != null &amp;&amp; defaultValue.length() &gt; 0) &#123; String value = parameters.get(key); if (value == null || value.length() == 0) &#123; changed = true; parameters.put(key, defaultValue); &#125; &#125; &#125; &#125; // æ ¹æ®æ ‡å‡†æ„å»ºçš„Ddubbo URLä¸­çš„å‚æ•°çš„å€¼æ˜¯å¦æœ‰æ•ˆï¼Œä¼šé‡æ–°æ„å»ºDubbo URLï¼ŒåŒºåˆ«åœ¨äºä¹‹å‰æ— æ•ˆçš„å‚æ•°éƒ½æ˜¯ç”¨é»˜è®¤å€¼æ›¿æ¢ if (changed) &#123; u = new URL(protocol, username, password, host, port, path, parameters); &#125; return u; &#125; éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œæœ¬æ–‡ä¸»è¦åˆ†æ Dubbo çš„æœ¬åœ°æš´éœ²ï¼Œæœ¬åœ°æš´éœ²ä¸ä¼šå‘æ³¨å†Œä¸­å¿ƒæ³¨å†ŒæœåŠ¡ï¼Œå› ä¸ºä»…ç”¨äº JVM å†…éƒ¨è°ƒç”¨ï¼Œç›¸å…³ä¿¡æ¯æ”¾åœ¨å†…å­˜ä¸­ã€‚åœ¨ä¸‹ä¸€ç¯‡è¿œç¨‹æš´éœ²æ—¶ä¼šç”¨åˆ°ï¼Œè¿™é‡Œä¸ºäº†å®Œæ•´å°±æå‰åˆ†æäº†ã€‚ åŠ è½½æ³¨å†Œä¸­å¿ƒURLä»£ç è¿˜æ˜¯æŒºå¤æ‚çš„ï¼Œä¸»è¦é€»è¾‘å¦‚ä¸‹ï¼š æ£€æµ‹æ˜¯å¦å­˜åœ¨æ³¨å†Œä¸­å¿ƒé…ç½®ç±»ï¼Œä¸å­˜åœ¨åˆ™æŠ›å‡ºå¼‚å¸¸ã€‚å­˜åœ¨åˆ™åˆå§‹åŒ–RegistryConfigçš„é…ç½®å±æ€§ã€‚ ç»„è£…å‚æ•°é›†åˆï¼Œåº”ç”¨äºæ³¨å†Œä¸­å¿ƒURLçš„å±æ€§ â€˜æŸ¥æ¼è¡¥ç¼ºâ€™ã€‚ æ„å»ºæ³¨å†Œä¸­å¿ƒURLåˆ—è¡¨ æœ‰å…³æ³¨å†Œä¸­å¿ƒURLæ„å»ºè¿˜æœ‰ä¸€ä¸ªæ•°æ®æµå‘æ“ä½œï¼Œä¸Šé¢ä»£ç ä¸­ä¹Ÿæ³¨é‡Šäº†ï¼Œæ¯”è¾ƒç®€å•ï¼Œå› ä¸ºä¼šåœ¨è¿œç¨‹æš´éœ²æ—¶ç”¨åˆ°ï¼Œè¿™é‡Œç®€å•ä»‹ç»ä¸‹ï¼Œä»¥ Redis æ³¨å†Œä¸­å¿ƒä¸ºä¾‹è¿›è¡Œè¯´æ˜ï¼Œæ›´å¸¸ç”¨ Zookeeper ä½œä¸ºæ³¨å†Œä¸­å¿ƒã€‚ ç»„è£… URL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177/** * ä½¿ç”¨ä¸åŒçš„åè®®ï¼Œé€ä¸ªå‘æ³¨å†Œä¸­å¿ƒåˆ†ç»„æš´éœ²æœåŠ¡ã€‚è¯¥æ–¹æ³•ä¸­åŒ…å«äº†æœ¬åœ°å’Œè¿œç¨‹ä¸¤ç§æš´éœ²æ–¹å¼ * * @param protocolConfig åè®®é…ç½®å¯¹è±¡ * @param registryURLs å¤„ç†è¿‡çš„æ³¨å†Œä¸­å¿ƒåˆ†ç»„é›†åˆã€å·²ç»æ·»åŠ äº†ApplicationConfigå’ŒRegistryConfigçš„å‚æ•°ã€‘ */ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; // åè®®å String name = protocolConfig.getName(); // åè®®åä¸ºç©ºæ—¶ï¼Œç¼ºçœè®¾ç½®ä¸º dubbo if (name == null || name.length() == 0) &#123; name = \"dubbo\"; &#125; // åˆ›å»ºå‚æ•°é›†åˆmapï¼Œç”¨äºDubbo URL çš„æ„å»ºï¼ˆæœåŠ¡æä¾›è€…URLï¼‰ Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // å°†side,dubbo,timestamp,pidå‚æ•°ï¼Œæ·»åŠ åˆ°mapé›†åˆä¸­ map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE); map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; // é€šè¿‡åå°„å°†å„ç§é…ç½®å¯¹è±¡ä¸­çš„å±æ€§æ·»åŠ åˆ°mapé›†åˆä¸­ï¼Œmapç”¨äºURLçš„æ„å»ºã€æ³¨æ„å±æ€§è¦†ç›–é—®é¢˜ã€‘ appendParameters(map, application); appendParameters(map, module); appendParameters(map, provider, Constants.DEFAULT_KEY); appendParameters(map, protocolConfig); appendParameters(map, this); // å°†MethodConfig å¯¹è±¡æ•°ç»„æ·»åŠ åˆ° map é›†åˆä¸­ã€‚å°±æ˜¯å°†æ¯ä¸ªMethodConfigå’Œå…¶å¯¹åº”çš„ArgumentConfigå¯¹è±¡æ•°ç»„æ·»åŠ åˆ°mapä¸­ã€å¤„ç†æ–¹æ³•ç›¸å…³çš„å±æ€§åˆ°mapã€‘ if (methods != null &amp;&amp; !methods.isEmpty()) &#123; // methods ä¸º MethodConfig é›†åˆï¼ŒMethodConfig ä¸­å­˜å‚¨äº† &lt;dubbo:method&gt; æ ‡ç­¾çš„é…ç½®ä¿¡æ¯ for (MethodConfig method : methods) &#123; /** * å°†MethodConfigå¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°mapé›†åˆä¸­ï¼Œå…¶ä¸­å±æ€§é”® = æ–¹æ³•å.å±æ€§åã€‚å¦‚ï¼š * &lt;dubbo:method name=\"sleep\" retries=\"2\"&gt;&lt;/dubbo:method&gt;å¯¹åº”çš„MethodConfigï¼Œå±æ€§åˆ°mapçš„æ ¼å¼ï¼š&#123;\"sleep.retries\":2&#125; */ appendParameters(map, method, method.getName()); // å½“é…ç½®äº† MehodConfig.retry = false æ—¶ï¼Œå¼ºåˆ¶ç¦ç”¨é‡è¯• String retryKey = method.getName() + \".retry\"; if (map.containsKey(retryKey)) &#123; String retryValue = map.remove(retryKey); // æ£€æµ‹ MethodConfig retry æ˜¯å¦ä¸º falseï¼Œè‹¥æ˜¯ï¼Œåˆ™è®¾ç½®é‡è¯•æ¬¡æ•°ä¸º0 if (\"false\".equals(retryValue)) &#123; map.put(method.getName() + \".retries\", \"0\"); &#125; &#125; // å°†MethodConfigä¸‹çš„ArgumentConfig å¯¹è±¡æ•°ç»„å³&lt;dubbo:argument&gt; æ ‡ç­¾ä¸­çš„é…ç½®ä¿¡æ¯ï¼Œæ·»åŠ åˆ° map é›†åˆä¸­ List&lt;ArgumentConfig&gt; arguments = method.getArguments(); if (arguments != null &amp;&amp; !arguments.isEmpty()) &#123; for (ArgumentConfig argument : arguments) &#123; // æ£€æµ‹type å±æ€§æ˜¯å¦ä¸ºç©º if (argument.getType() != null &amp;&amp; argument.getType().length() &gt; 0) &#123; // é€šè¿‡åå°„å–å‡ºæ¥å£çš„æ–¹æ³•åˆ—è¡¨ Method[] methods = interfaceClass.getMethods(); // éå†æ¥å£ä¸­çš„æ–¹æ³•åˆ—è¡¨ if (methods != null &amp;&amp; methods.length &gt; 0) &#123; for (int i = 0; i &lt; methods.length; i++) &#123; String methodName = methods[i].getName(); // æ¯”å¯¹æ–¹æ³•åï¼ŒæŸ¥æ‰¾ç›®æ ‡æ–¹æ³• if (methodName.equals(method.getName())) &#123; // é€šè¿‡åå°„å–å‡ºç›®æ ‡æ–¹æ³•çš„å‚æ•°ç±»å‹åˆ—è¡¨ Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes(); // è‹¥æœé…ç½®indexé…ç½®é¡¹ï¼Œä¸”å€¼ä¸ä¸º-1 if (argument.getIndex() != -1) &#123; // ä»argtypesæ•°ç»„ä¸­è·å–ä¸‹æ ‡indexå¤„çš„å…ƒç´ argTypeï¼Œå¹¶æ£€æµ‹ArgumentConfigä¸­çš„typeå±æ€§ä¸argTypeåç§°æ˜¯å¦ä¸€è‡´ï¼Œä¸ä¸€è‡´åˆ™æŠ›å‡ºå¼‚å¸¸ if (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123; // å°†ArgumentConfigå¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°mapé›†åˆä¸­ï¼Œé”®å‰ç¼€=æ–¹æ³•å.indexï¼Œå¦‚ï¼šmap = &#123;\"sleep.2\":true&#125; appendParameters(map, argument, method.getName() + \".\" + argument.getIndex()); &#125; else &#123; throw new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType()); &#125; &#125; else &#123; // éå†å‚æ•°ç±»å‹æ•°ç»„argtypesï¼ŒæŸ¥æ‰¾argument.typeç±»å‹çš„å‚æ•° for (int j = 0; j &lt; argtypes.length; j++) &#123; Class&lt;?&gt; argclazz = argtypes[j]; // ä»å‚æ•°ç±»å‹åˆ—è¡¨ä¸­æŸ¥æ‰¾ç±»å‹åç§°ä¸ºargument.typeçš„å‚æ•° if (argclazz.getName().equals(argument.getType())) &#123; // å°†ArgumentConfigå¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°mapé›†åˆä¸­ appendParameters(map, argument, method.getName() + \".\" + j); if (argument.getIndex() != -1 &amp;&amp; argument.getIndex() != j) &#123; throw new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType()); &#125; &#125; &#125; &#125; &#125; &#125; &#125; // ç”¨æˆ·æœªé…ç½® type å±æ€§ï¼Œä½†é…ç½®äº†indexå±æ€§ï¼Œä¸”index != -1 &#125; else if (argument.getIndex() != -1) &#123; // æŒ‡å®šå•ä¸ªå‚æ•°çš„ä½ç½® // å°†ArgumentConfigå¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°mapé›†åˆä¸­ appendParameters(map, argument, method.getName() + \".\" + argument.getIndex()); &#125; else &#123; throw new IllegalArgumentException(\"argument config must set index or type attribute.eg: &lt;dubbo:argument index='0' .../&gt; or &lt;dubbo:argument type=xxx .../&gt;\"); &#125; &#125; &#125; &#125; // end of methods for &#125; //--- æ£€æµ‹ generic æ˜¯å¦ ä¸º true ,å¹¶æ ¹æ®æ£€æµ‹ç»“æœå‘mapä¸­æ·»åŠ ä¸åŒçš„ä¿¡æ¯ ---/ // å°† generic,methods,revision åŠ å…¥åˆ°æ•°ç»„ if (ProtocolUtils.isGeneric(generic)) &#123; map.put(Constants.GENERIC_KEY, generic); map.put(Constants.METHODS_KEY, Constants.ANY_VALUE); &#125; else &#123; // å…ˆä»MAINFEST.MF ä¸­è·å–ç‰ˆæœ¬å·ï¼Œè‹¥è·å–ä¸åˆ°ï¼Œå†ä»jaråŒ…å‘½åä¸­å¯èƒ½å¸¦çš„ç‰ˆæœ¬å·ä½œä¸ºç»“æœï¼Œå¦‚ 2.6.5.RELEASEã€‚è‹¥éƒ½ä¸å­˜åœ¨ï¼Œè¿”å›é»˜è®¤ç‰ˆæœ¬å·ã€æºç è¿è¡Œå¯èƒ½ä¼šæ²¡æœ‰ã€‘ String revision = Version.getVersion(interfaceClass, version); if (revision != null &amp;&amp; revision.length() &gt; 0) &#123; map.put(\"revision\", revision); // ä¿®è®¢å· &#125; // ä¸ºæ¥å£ç”ŸæˆåŒ…è£¹ç±» Wrapperï¼ŒWrapper ä¸­åŒ…å«äº†æ¥å£çš„è¯¦ç»†ä¿¡æ¯ï¼Œå¦‚æ¥å£æ–¹æ³•ï¼Œå­—æ®µä¿¡æ¯ç­‰ String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames(); // æ·»åŠ æ–¹æ³•ååˆ° map ä¸­ï¼Œå¦‚æœåŒ…å«å¤šä¸ªæ–¹æ³•åï¼Œåˆ™ç”¨é€—å·éš”å¼€ï¼Œæ¯”å¦‚ï¼šmethod=a,b if (methods.length == 0) &#123; logger.warn(\"NO method found in service interface \" + interfaceClass.getName()); // æ²¡æœ‰æ–¹æ³•åå°±æ·»åŠ  method=* map.put(Constants.METHODS_KEY, Constants.ANY_VALUE); &#125; else &#123; // å°†é€—å·ä½œä¸ºåˆ†éš”ç¬¦è¿æ¥æ–¹æ³•åï¼Œå¹¶å°†è¿æ¥åçš„å­—ç¬¦ä¸²æ”¾å…¥ map ä¸­ map.put(Constants.METHODS_KEY, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), \",\")); &#125; &#125; // token ã€ä½¿æš´éœ²å‡ºå»çš„æœåŠ¡æ›´å®‰å…¨ï¼Œä½¿ç”¨tokenåšå®‰å…¨æ ¡éªŒã€‘ if (!ConfigUtils.isEmpty(token)) &#123; if (ConfigUtils.isDefault(token)) &#123; map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString()); &#125; else &#123; map.put(Constants.TOKEN_KEY, token); &#125; &#125; // åè®®ä¸ºinjvmæ—¶ï¼Œä¸æ³¨å†Œï¼Œä¸é€šçŸ¥ if (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123; protocolConfig.setRegister(false); map.put(\"notify\", \"false\"); &#125; // è·å¾—åŸºç¡€è·¯å¾„ String contextPath = protocolConfig.getContextpath(); if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) &#123; contextPath = provider.getContextpath(); &#125; // ---------------------------- ä¸»æœºç»‘å®š -------------------------------------/ // è·å¾—æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒçš„æœåŠ¡æä¾›è€…hostï¼Œå¹¶ä¸ºmapè®¾ç½®bind.ip , anyhost ä¸¤ä¸ªkey String host = this.findConfigedHosts(protocolConfig, registryURLs, map); // è·å–ç«¯å£ï¼Œå¹¶ä¸ºmapè®¾ç½®bing.port key Integer port = this.findConfigedPorts(protocolConfig, name, map); /** * åˆ›å»ºDubbo URLå¯¹è±¡ ã€æ³¨æ„è¿™é‡Œçš„ path çš„å€¼ã€‘ * 1 name: åè®®å * 2 host: ä¸»æœºå * 3 port: ç«¯å£ * 4 path: ã€åŸºç¡€è·¯å¾„ã€‘/path * 5 parameters: å±æ€§é›†åˆmap */ URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? \"\" : contextPath + \"/\") + path, map); // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; ä¸Šé¢çš„ä»£ç æ¯”è¾ƒå¤æ‚ï¼Œä¸è¿‡æ€»ä½“ä¸Šæ˜¯å°†é…ç½®æ‰¿è½½å¯¹è±¡ä¸­çš„å±æ€§æ·»åŠ åˆ°å‚æ•°é›†åˆä¸­ç”¨äºæ„å»º Dubbo URL ã€‚å…¶ä¸­æ¶‰åŠåˆ°çš„å°†é…ç½®å¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°å‚æ•°é›†åˆçš„ appendParameters æ–¹æ³•å¯ä»¥å‚è§ APIå’Œå±æ€§é…ç½® ã€‚ æœåŠ¡æš´éœ²æœåŠ¡æš´éœ²çš„å‡†å¤‡å·¥ä½œå®Œæˆåï¼Œæ¥ä¸‹æ¥å°±å¯ä»¥æ‰§è¡ŒæœåŠ¡æš´éœ²å·¥ä½œäº†ã€‚æœåŠ¡æš´éœ²ï¼Œåˆ†ä¸ºæœ¬åœ°æš´éœ²å’Œè¿œç¨‹æš´éœ²ã€‚æˆ‘ä»¬å…ˆä¸ç ”ç©¶ç»†èŠ‚ï¼Œå…ˆä»å®è§‚å±‚é¢ä¸Šçœ‹ä¸€ä¸‹æœåŠ¡æš´éœ²é€»è¾‘ã€‚å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * ä½¿ç”¨ä¸åŒçš„åè®®ï¼Œé€ä¸ªå‘æ³¨å†Œä¸­å¿ƒåˆ†ç»„æš´éœ²æœåŠ¡ã€‚è¯¥æ–¹æ³•ä¸­åŒ…å«äº†æœ¬åœ°å’Œè¿œç¨‹ä¸¤ç§æš´éœ²æ–¹å¼ * * @param protocolConfig åè®®é…ç½®å¯¹è±¡ * @param registryURLs å¤„ç†è¿‡çš„æ³¨å†Œä¸­å¿ƒåˆ†ç»„é›†åˆã€å·²ç»æ·»åŠ äº†ApplicationConfigå’ŒRegistryConfigçš„å‚æ•°ã€‘ */ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; // å¦‚æœå­˜åœ¨å½“å‰åè®®å¯¹åº”çš„ ConfiguratorFactory æ‰©å±•å®ç°ï¼Œå°±åˆ›å»ºé…ç½®è§„åˆ™å™¨ Configuratorï¼Œå°†é…ç½®è§„åˆ™åº”ç”¨åˆ°url todo è¿™é‡Œåº”è¯¥ä¸ä¼šå­˜åœ¨æŠŠï¼Ÿ if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).hasExtension(url.getProtocol())) &#123; // åŠ è½½ConfiguratorFactory ï¼Œå¹¶ç”ŸæˆConfiguratorï¼Œå°†é…ç½®è§„åˆ™åº”ç”¨åˆ°urlä¸­ url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).getExtension(url.getProtocol()).getConfigurator(url).configure(url); &#125; // ä»URLä¸­è·å–æš´éœ²æ–¹å¼ String scope = url.getParameter(Constants.SCOPE_KEY); // å¦‚æœ scope = noneï¼Œåˆ™ä¸è¿›è¡Œæš´éœ²ï¼Œç›´æ¥ç»“æŸ if (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) &#123; // scope != remoteï¼Œæœ¬åœ°æš´éœ² if (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123; exportLocal(url); &#125; // scope != localï¼Œè¿œç¨‹æš´éœ²ï¼ŒåŒ…å«äº†æœåŠ¡æš´éœ²å’ŒæœåŠ¡æ³¨å†Œä¸¤ä¸ªè¿‡ç¨‹ if (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url); &#125; if (registryURLs != null &amp;&amp; !registryURLs.isEmpty()) &#123; // éå†æ³¨å†Œä¸­å¿ƒURLæ•°ç»„ for (URL registryURL : registryURLs) &#123; // dynamicå±æ€§ï¼šæœåŠ¡æ˜¯å¦åŠ¨æ€æ³¨å†Œï¼Œå¦‚æœè®¾ä¸ºfalse,æ³¨å†Œåå°†æ˜¾ç¤ºdisableçŠ¶æ€ï¼Œéœ€è¦äººå·¥å¯ç”¨ï¼Œå¹¶ä¸”æœåŠ¡æä¾›è€…åœæ­¢æ—¶ï¼Œä¹Ÿä¸ä¼šè‡ªåŠ¨ä¸‹çº¿ï¼Œéœ€è¦äººå·¥ç¦ç”¨ url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY)); // è·å–ç›‘æ§ä¸­å¿ƒURL URL monitorUrl = loadMonitor(registryURL); if (monitorUrl != null) &#123; // ç›‘æ§URLä¸èƒ½ç©ºï¼Œå°±å°†ç›‘æ§ä¸­å¿ƒçš„URLä½œä¸ºmonitorå‚æ•°æ·»åŠ åˆ°æœåŠ¡æä¾›è€…çš„URLä¸­ï¼Œå¹¶ä¸”éœ€è¦ç¼–ç ã€‚é€šè¿‡è¿™æ ·æ–¹å¼ï¼ŒæœåŠ¡æä¾›è€…çš„URLä¸­å°±åŒ…å«äº†ç›‘æ§ä¸­å¿ƒçš„é…ç½® url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString()); &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Register dubbo service \" + interfaceClass.getName() + \" url \" + url + \" to registry \" + registryURL); &#125; // è·å–é…ç½®çš„åŠ¨æ€ä»£ç†çš„ç”Ÿæˆæ–¹å¼ &lt;dubbo:service proxy=\"\"/&gt;,å¯é€‰jdk/javassist,é»˜è®¤ä½¿ç”¨javassist String proxy = url.getParameter(Constants.PROXY_KEY); if (StringUtils.isNotEmpty(proxy)) &#123; registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy); &#125; // ä½¿ç”¨ProxyFactory åˆ›å»º AbstractProxyInvoker å¯¹è±¡ Invoker&lt;?&gt; invoker = proxyFactory.getInvoker( ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()) ); // åˆ›å»º DelegateProviderMetaDataInvoker å¯¹è±¡ï¼Œåœ¨Invokerå¯¹è±¡åŸºç¡€ä¸Šï¼Œå¢åŠ äº†å½“å‰æœåŠ¡æä¾›è€…ServiceConfigå¯¹è±¡ï¼Œå³æŠŠInvokerå’ŒServiceConfigç»“åˆåœ¨äº†ä¸€èµ· DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this); // æš´éœ²æœåŠ¡ï¼Œç”ŸæˆExporter: Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker); // æ·»åŠ åˆ° Exporter é›†åˆ exporters.add(exporter); &#125; &#125; else &#123; // æ— æ•ˆæ³¨å†Œä¸­å¿ƒï¼Œä»…æš´éœ²æœåŠ¡ // ä½¿ç”¨ProxyFactory åˆ›å»º Invoker å¯¹è±¡ Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url); // åˆ›å»º DelegateProviderMetaDataInvoker å¯¹è±¡ DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this); // ä½¿ç”¨Protocol æš´éœ²Invoker å¯¹è±¡ Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker); // æ·»åŠ åˆ° Exporter é›†åˆ exporters.add(exporter); &#125; &#125; &#125; this.urls.add(url);&#125; ä»å®è§‚å±‚é¢ä¸Šçœ‹ï¼ŒæœåŠ¡æš´éœ²çš„æ–¹å¼å–å†³äº scope å‚æ•°ï¼Œè¯¥å‚æ•°å€¼åœ¨æ–‡ç« å‰é¢æœ‰å…·ä½“è¯´æ˜ã€‚ åˆ›å»º Invokerä¸ç®¡æ˜¯æœ¬åœ°æš´éœ²ï¼Œè¿˜æ˜¯è¿œç¨‹æš´éœ²ï¼Œè¿›è¡ŒæœåŠ¡æš´éœ²ä¹‹å‰ï¼Œéƒ½éœ€è¦å…ˆåˆ›å»º Invoker ï¼Œè¿™ä¸€ç‚¹éå¸¸é‡è¦ã€‚åœ¨ Dubbo ä¸­ï¼ŒInvoker æ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„æ¨¡å‹ï¼Œæ— è®ºæ˜¯åœ¨æœåŠ¡æä¾›ç«¯ï¼Œè¿˜æ˜¯æœåŠ¡æ¶ˆè´¹ç«¯å‡ä¼šå‡ºç° Invokerã€‚Dubbo å®˜æ–¹æ–‡æ¡£ä¸­å¯¹ Invoker è¿›è¡Œäº†è¯´æ˜ã€‚ Invoker æ˜¯å®ä½“åŸŸï¼Œå®ƒæ˜¯ Dubbo çš„æ ¸å¿ƒæ¨¡å‹ï¼Œå…¶å®ƒæ¨¡å‹éƒ½å‘å®ƒé æ‰°ï¼Œæˆ–è½¬æ¢æˆå®ƒï¼Œå®ƒä»£è¡¨ä¸€ä¸ªå¯æ‰§è¡Œä½“ï¼Œå¯å‘å®ƒå‘èµ· invoke è°ƒç”¨ï¼Œå®ƒæœ‰å¯èƒ½æ˜¯ä¸€ä¸ªæœ¬åœ°çš„å®ç°ï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ªè¿œç¨‹çš„å®ç°ï¼Œä¹Ÿå¯èƒ½ä¸€ä¸ªé›†ç¾¤å®ç°ã€‚ Invoker æ˜¯ç”± ProxyFactory åˆ›å»ºçš„ï¼ŒDubbo é»˜è®¤çš„ ProxyFactory å®ç°ç±»æ˜¯ JavassistProxyFactory ï¼Œåœ¨ JavassiståŠ¨æ€ä»£ç† ä¸­è¿›è¡Œäº†è¯¦ç»†çš„è¯´æ˜ã€‚ æœ¬åœ°æš´éœ²1234567891011121314151617181920212223242526272829303132/** * æœ¬åœ°æš´éœ² * * @param url */ @SuppressWarnings(&#123;\"unchecked\", \"rawtypes\"&#125;) private void exportLocal(URL url) &#123; /** * 1 è‹¥æœURlçš„åè®®å¤´æ˜¯injvmï¼Œè¯´æ˜å·²ç»æš´éœ²åˆ°æœ¬åœ°äº†ï¼Œæ— éœ€å†æ¬¡æš´éœ² * 2 éinjvmåè®®å°±åŸºäºåŸæœ‰çš„URLæ„å»ºåè®®ä¸ºinjvmï¼Œä¸»æœºåœ°å€ 127.0.0.1ï¼Œç«¯å£ä¸º0 çš„æ–°çš„ URL */ if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123; URL local = URL.valueOf(url.toFullString()) .setProtocol(Constants.LOCAL_PROTOCOL) .setHost(LOCALHOST) .setPort(0); // æ·»åŠ æœåŠ¡æ¥å£çš„å®ç°ç±»ã€ä»…ç”¨äºRestProtocolåè®®ã€‘åˆ°çº¿ç¨‹å˜é‡ä¸­ ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref)); // åˆ›å»º Invokerï¼Œè¿™é‡Œ proxyFactory ä¼šåœ¨è¿è¡Œæ—¶æ‰§è¡Œ JavassistProxyFactory çš„ getInvoker æ–¹æ³• ï¼ˆé»˜è®¤æƒ…å†µï¼Œä¹Ÿå¯é€šè¿‡å‚æ•°æŒ‡å®šï¼‰ Invoker invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, local); // è¿™é‡Œçš„ protocol ä¼šåœ¨è¿è¡Œæ—¶è°ƒç”¨ InjvmProtocol çš„ export æ–¹æ³• Exporter&lt;?&gt; exporter = protocol.export(invoker); // æ·»åŠ åˆ°Exporteré›†åˆä¸­ exporters.add(exporter); logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to local registry\"); &#125; &#125; æœ¬åœ°æš´éœ²çš„ä»£ç æ¯”è¾ƒç®€å•ï¼Œä¸‹é¢æ€»ç»“ä¸‹æµç¨‹ï¼š æ ¹æ® URL åè®®å¤´å†³å®šæ˜¯å¦æš´éœ²æœåŠ¡ï¼Œå¦‚æœéœ€è¦æš´éœ²å°±åˆ›å»º injvm åè®®çš„ URL ç„¶åé€šè¿‡ SPI æœºåˆ¶åˆ†åˆ«è·å–è¿è¡Œæ—¶çš„ proxyFactory å’Œ protocol æ‰©å±•å®ç°ï¼Œè¿™å°±æ˜¯ Dubbo SPI è‡ªé€‚åº”çš„å¥½å¤„ ä½¿ç”¨proxyFactoryåˆ›å»º Invoker(AbstractProxyInvoker) ä½¿ç”¨protocolè¿›è¡ŒæœåŠ¡æš´éœ² ä»¥ä¸Šæµç¨‹çš„å‰ 3 æ­¥å·²ç»åˆ†æè¿‡ï¼Œä¸‹é¢å¯¹ç¬¬ 4 æ­¥è¿›è¡Œåˆ†æã€‚ Protocolæœ¬åœ°æš´éœ²æ¶‰åŠçš„ Protocol ç±»å›¾å¦‚ä¸‹ï¼š ç”±ä¸Šå›¾çš„ UML ç±»å›¾å¯çŸ¥ï¼ŒProtocol æœ‰ä¸¤ä¸ª Wrapper ç±»ï¼Œç”± Dubbo SPI æœºåˆ¶æˆ‘ä»¬çŸ¥é“æ‰§è¡Œ Protocol#export æ–¹æ³•çš„é¡ºåºï¼š Protocol$Adaptive =&gt; ProtocolListenerWrapper ==&gt; ProtocolFilterWrapper =&gt; InjvmProtocol ä¸‹é¢å¯¹æ‰§è¡Œé“¾è¿›è¡Œåˆ†æï¼Œå…¶ä¸­ Protocol è‡ªé€‚åº”æ‰©å±•å¯¹è±¡åŸç†åœ¨ è‡ªé€‚åº”æ‰©å±• ä¸­å·²ç»è¯¦ç»†åˆ†æã€‚è¿™é‡Œè¯´æ˜ä¸‹ï¼Œä¸Šå›¾çš„ UML ç±»å›¾ä¸­å…¶å®ƒçš„å…ˆä¸åšåˆ†æï¼Œåªå…³æ³¨æœ¬åœ°æš´éœ²ç›¸å…³çš„ï¼Œ Dubbo ä¸­çš„å¤šåè®®éƒ¨åˆ†ä¼šå•ç‹¬ä½œä¸ºä¸€ä¸ªæ¨¡å—åˆ†æã€‚ ProtocolListenerWrapperå®ç° Protocol æ¥å£ï¼Œæ˜¯ Protocol çš„ Wrapper ç±»ï¼Œåœ¨æœåŠ¡æš´éœ²æ—¶ç”¨äºç»™ Exporter æ·»åŠ ç›‘å¬å™¨ï¼Œç›‘å¬ Exporter æš´éœ²å’Œå–æ¶ˆã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041public class ProtocolListenerWrapper implements Protocol &#123; private final Protocol protocol; public ProtocolListenerWrapper(Protocol protocol) &#123; if (protocol == null) &#123; throw new IllegalArgumentException(\"protocol == null\"); &#125; this.protocol = protocol; &#125; /** * * @param invoker Service invoker * @param &lt;T&gt; * @return * @throws RpcException */ @Override public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; // registryåè®®å¼€å¤´çš„æœåŠ¡æš´éœ²é€»è¾‘ï¼Œåˆ™è·³è¿‡ if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123; return protocol.export(invoker); &#125; // æœåŠ¡æš´éœ²ï¼Œåˆ›å»º Exporter Exporter&lt;T&gt; export = protocol.export(invoker); // è·å– ExporterListener List&lt;ExporterListener&gt; exporterListeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class) .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)); // ä½¿ç”¨ ListenerExporterWrapper åŒ…è£… Exporterï¼Œä¸º Exporteré‚¦å®šç›‘å¬å™¨ return new ListenerExporterWrapper&lt;T&gt;(export, exporterListeners); &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; ProtocolListenerWrapper åœ¨æœåŠ¡æš´éœ²æµç¨‹ä¸­çš„é€»è¾‘å¦‚ä¸‹ï¼š åˆ¤æ–­å½“å‰Invokerå¯¹åº”çš„URLåè®®æ˜¯å¦ä¸º registryï¼Œè¿œç¨‹æš´éœ²æ—¶éœ€è¦ç”¨åˆ°æ³¨å†Œä¸­å¿ƒï¼Œæ‰§è¡Œåˆ°è¿™é‡Œæ—¶åè®®ä¼šä¸º registryï¼Œè¿™ç§æƒ…å†µå°±æ— éœ€ç»‘å®šç›‘å¬å™¨ã€‚ ä½¿ç”¨å…·ä½“åè®®æš´éœ²æœåŠ¡ï¼Œåˆ›å»º Exporter è·å–ExporterListenerï¼Œç”¨æˆ·å¯ä»¥è‡ªè¡Œå®ç°ç›‘å¬å™¨ã€‚æ³¨æ„ï¼Œå®ç°çš„ç›‘å¬å™¨æ˜¯è‡ªåŠ¨æ¿€æ´»ç±»å‹ å°†è·å–çš„ç›‘å¬å™¨ç»‘å®šåˆ°æœåŠ¡æš´éœ²ç”Ÿæˆçš„Exporter ExporterExporter æ˜¯ Invoker æœåŠ¡åœ¨ Protocol ä¸Šçš„å¯¹è±¡ã€‚æ›´å¤šå¯ä»¥å‚è€ƒ Dubboé¡¹ç›®ç»“æ„æ€»è§ˆ ã€‚æœ¬åœ°æš´éœ²æ¶‰åŠåˆ°çš„ UML ç±»å›¾å¦‚ä¸‹ï¼š InjvmExporterå®ç° AbstractExporter æŠ½è±¡ç±»ï¼ŒInjvm Exporter å®ç°ç±»ï¼Œä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738class InjvmExporter&lt;T&gt; extends AbstractExporter&lt;T&gt; &#123; /** * æœåŠ¡é”® */ private final String key; /** * Exporter é›†åˆ * key : æœåŠ¡é”® * è¯¥å€¼å®é™…å°±æ˜¯ &#123;@link com.alibaba.dubbo.rpc.protocol.AbstractProtocol#exporterMap&#125; */ private final Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap; /** * æ„é€ æ–¹æ³•ï¼Œå‘èµ·æš´éœ² * * @param invoker invoker * @param key æœåŠ¡é”® * @param exporterMap AbstractExporterçš„ç¼“å­˜ */ InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123; super(invoker); this.key = key; this.exporterMap = exporterMap; // åŠ å…¥åˆ°Exporteré›†åˆ[ä¼šæŠŠè‡ªå·±åŠ å…¥åˆ°AbstractProtocolä¸­çš„Mapä¸­] exporterMap.put(key, this); &#125; /** * å–æ¶ˆæš´éœ² */ @Override public void unexport() &#123; super.unexport(); // ç§»é™¤ keyå¯¹åº”çš„Exporter exporterMap.remove(key); &#125;&#125; InjvmExporter ä¼šå°†è‡ªèº«çš„å¯¹è±¡æ”¾å…¥åˆ°å…¶çˆ¶ç±» AbstractExporter å’Œè‡ªèº«çš„ç¼“å­˜ä¸­ï¼Œè¿™ä¹Ÿæ˜¯æœ¬åœ°æš´éœ²çš„æœ¬è´¨ã€‚ ListenerExporterWrapperå®ç° Exporter æ¥å£ï¼Œå…·æœ‰ç›‘å¬å™¨åŠŸèƒ½çš„ Exporter çš„ Wrapper ç±»ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * ListenerExporter * &lt;p&gt; * å®ç° Exporteræ¥å£ï¼Œå…·æœ‰ç›‘å¬å™¨åŠŸèƒ½çš„ExporteråŒ…è£…å™¨ */public class ListenerExporterWrapper&lt;T&gt; implements Exporter&lt;T&gt; &#123; private static final Logger logger = LoggerFactory.getLogger(ListenerExporterWrapper.class); /** * çœŸå®çš„Exporter å¯¹è±¡ */ private final Exporter&lt;T&gt; exporter; /** * Exporter ç›‘å¬å™¨æ•°ç»„ */ private final List&lt;ExporterListener&gt; listeners; public ListenerExporterWrapper(Exporter&lt;T&gt; exporter, List&lt;ExporterListener&gt; listeners) &#123; if (exporter == null) &#123; throw new IllegalArgumentException(\"exporter == null\"); &#125; this.exporter = exporter; this.listeners = listeners; // æ‰§è¡Œç›‘å¬å™¨ if (listeners != null &amp;&amp; !listeners.isEmpty()) &#123; RuntimeException exception = null; for (ExporterListener listener : listeners) &#123; if (listener != null) &#123; try &#123; // äº‹ä»¶è§¦å‘ã€æœåŠ¡å¯¼å‡ºåã€‘å›è°ƒï¼Œå¯ä»¥è¿›è¡Œè‡ªå®šä¹‰å®ç°ExporterListenerï¼Œé‡æ–°è¯¥æ–¹æ³• listener.exported(this); &#125; catch (RuntimeException t) &#123; logger.error(t.getMessage(), t); exception = t; &#125; &#125; &#125; if (exception != null) &#123; throw exception; &#125; &#125; &#125; @Override public Invoker&lt;T&gt; getInvoker() &#123; return exporter.getInvoker(); &#125; /** * å–æ¶ˆæœåŠ¡æš´éœ² */ @Override public void unexport() &#123; try &#123; exporter.unexport(); &#125; finally &#123; // æ‰§è¡Œç›‘å¬å™¨ if (listeners != null &amp;&amp; !listeners.isEmpty()) &#123; RuntimeException exception = null; for (ExporterListener listener : listeners) &#123; if (listener != null) &#123; try &#123; listener.unexported(this); &#125; catch (RuntimeException t) &#123; logger.error(t.getMessage(), t); exception = t; &#125; &#125; &#125; if (exception != null) &#123; throw exception; &#125; &#125; &#125; &#125;&#125; ListenerExporterWrapperæ˜¯ä¸€ä¸ª Wrapper ç±»ï¼Œæ˜¯ç”¨æ¥ç»™ Exporter ç»‘å®š ExporterListener ç›‘å¬å™¨çš„ã€‚ ExporterListener1234567891011121314151617181920212223242526@SPIpublic interface ExporterListener &#123; /** * The exporter exported. * * å½“æœåŠ¡æš´éœ²å®Œæˆ * * @param exporter * @throws RpcException * @see com.alibaba.dubbo.rpc.Protocol#export(Invoker) */ void exported(Exporter&lt;?&gt; exporter) throws RpcException; /** * The exporter unexported. * * å½“æœåŠ¡å–æ¶ˆå®Œæˆ * * @param exporter * @throws RpcException * @see com.alibaba.dubbo.rpc.Exporter#unexport() */ void unexported(Exporter&lt;?&gt; exporter);&#125; Exporter çš„ç›‘å¬å™¨ï¼Œæ˜¯ä¸€ä¸ªæ‰©å±•ç‚¹ã€‚ç”¨æˆ·å¯ä»¥è‡ªå®šä¹‰å®ç°ï¼Œç”¨æ¥ç›‘å¬æœåŠ¡æš´éœ²ã€‚ ProtocolFilterWrapperå®ç° Protocol æ¥å£ï¼Œæ˜¯ Protocol çš„ Wrapper ç±»ï¼Œç”¨äºç»™ Invoker å¢åŠ è¿‡æ»¤é“¾ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class ProtocolFilterWrapper implements Protocol &#123; private final Protocol protocol; public ProtocolFilterWrapper(Protocol protocol) &#123; if (protocol == null) &#123; throw new IllegalArgumentException(\"protocol == null\"); &#125; this.protocol = protocol; &#125; /** * åˆ›å»ºå¸¦Filteré“¾çš„Invoker å¯¹è±¡ * * @param invoker Invokerå¯¹è±¡ * @param key URLä¸­å‚æ•°å ã€å¦‚ï¼šç”¨äºè·å¾—ServiceConfigæˆ–ReferenceConfigé…ç½®çš„è‡ªå®šä¹‰è¿‡æ»¤å™¨ã€‘ * @param group åˆ†ç»„ ã€æš´éœ²æœåŠ¡æ—¶ï¼šgroup=provider; å¼•ç”¨æœåŠ¡æ—¶ï¼šgroup=consumerã€‘ * @param &lt;T&gt; * @return åœ¨æ‰§è¡Œçš„æ—¶å€™æ‰§è¡ŒFilter */ private static &lt;T&gt; Invoker&lt;T&gt; buildInvokerChain(final Invoker&lt;T&gt; invoker, String key, String group) &#123; Invoker&lt;T&gt; last = invoker; // è·å–æ‰€æœ‰çš„è¿‡æ»¤å™¨ï¼ŒåŒ…æ‹¬ç±»ä¸Šå¸¦æœ‰@Activeæ³¨è§£çš„å’Œåœ¨XMLä¸­é…ç½®çš„ List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group); // å€’åºå¾ªç¯ Filterï¼Œé€’å½’åŒ…è£…Invokerï¼Œå°±æ˜¯ä¸€ä¸ªé“¾è¡¨ç»“æ„ï¼š Xx1Filter-&gt;Xx2Filter-&gt;Xx3Filter-&gt;...-&gt;Invoker if (!filters.isEmpty()) &#123; for (int i = filters.size() - 1; i &gt;= 0; i--) &#123; final Filter filter = filters.get(i); final Invoker&lt;T&gt; next = last; // åˆ›å»ºæ–°çš„Invoker å¯¹è±¡ï¼Œ ç”¨äºåŒ…è£… next last = new Invoker&lt;T&gt;() &#123; @Override public Class&lt;T&gt; getInterface() &#123; return invoker.getInterface(); &#125; @Override public URL getUrl() &#123; return invoker.getUrl(); &#125; @Override public boolean isAvailable() &#123; return invoker.isAvailable(); &#125; /** * è°ƒç”¨Invokerçš„invokeæ–¹æ³•çš„æ—¶å€™ä¼šæ‰§è¡Œ * 1 è°ƒç”¨Filter#invoke(invoker,invocation)æ–¹æ³•ï¼Œä¸æ–­æ‰§è¡Œè¿‡æ»¤å™¨é€»è¾‘ * 2 åœ¨Filterä¸­ä¼šè°ƒç”¨Invoker#invoker(invocation)æ–¹æ³•ï¼Œæœ€åä¼šæ‰§è¡Œåˆ°Invokerã€å¦‚ï¼šInjvmInvoker,DubboInvokerç­‰ã€‘çš„invokeæ–¹æ³• * * @param invocation * @return * @throws RpcException */ @Override public Result invoke(Invocation invocation) throws RpcException &#123; return filter.invoke(next, invocation); &#125; @Override public void destroy() &#123; invoker.destroy(); &#125; @Override public String toString() &#123; return invoker.toString(); &#125; &#125;; &#125; &#125; return last; &#125; @Override public int getDefaultPort() &#123; return protocol.getDefaultPort(); &#125; @Override public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; // å¦‚æœ Invokerçš„URLä¸­ protocol=registry,è¯´æ˜æ˜¯æ³¨å†Œä¸­å¿ƒçš„åè®®ï¼Œè¿™ç§æƒ…å†µæ— éœ€åˆ›å»ºFilterè¿‡æ»¤å™¨ã€‚ if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123; return protocol.export(invoker); &#125; // å»ºç«‹å¸¦æœ‰Filter è¿‡æ»¤é“¾çš„ Invokerï¼Œå†æš´éœ²æœåŠ¡ return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER)); &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; ProtocolFilterWrapper åœ¨æœåŠ¡æš´éœ²æ—¶å°±åšäº†ä¸€ä»¶äº‹ï¼Œä¸º Invoker å¢åŠ è¿‡æ»¤é“¾ã€‚å…¶ä¸­keyå’Œgroupå‚æ•°æ˜¯ç”¨æ¥è·å–è‡ªå®šä¹‰è¿‡æ»¤å™¨çš„ï¼Œå…·ä½“è§„åˆ™å‚è§ Dubbo SPI ã€‚è¿‡æ»¤å™¨é“¾å¦‚ä¸‹ï¼ŒåŒ…å« Dubbo è‡ªå¸¦è¿‡æ»¤å™¨å’Œç”¨æˆ·è‡ªå®šä¹‰è¿‡æ»¤å™¨ã€‚ EchoFilter - å›å£°æ¢æµ‹è¿‡æ»¤å™¨ClassLoaderFilter - ç±»åŠ è½½å™¨åˆ‡æ¢è¿‡æ»¤å™¨GenericFilter - æœåŠ¡æä¾›è€…çš„æ³›åŒ–è°ƒç”¨è¿‡æ»¤å™¨ContextFilter - æœåŠ¡æä¾›è€…çš„ä¸Šä¸‹æ–‡è¿‡æ»¤å™¨TraceFilter - è¿½è¸ªè¿‡æ»¤å™¨TimeoutFilter - æœåŠ¡æä¾›è€…çš„è¶…æ—¶è¿‡æ»¤å™¨MonitorFilter - ç›‘æ§è¿‡æ»¤å™¨ExceptionFilter - åŠ å·¥å¼‚å¸¸è¿‡æ»¤å™¨XxxFilter - è‡ªå®šä¹‰è¿‡æ»¤å™¨ æ„å»º Invoker çš„è¿‡å™¨æ»¤é“¾è¿‡ç¨‹å¦‚ä¸‹ï¼š éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿”å›çš„ Invoker æ˜¯ä¸€ä¸ªåŒ¿åå†…éƒ¨ç±»å¯¹è±¡ï¼Œè¯¥å¯¹è±¡çš„ invoke æ–¹æ³•æ²¡æœ‰å…¶å®ƒé€»è¾‘ï¼Œä»…ç”¨æ¥æ‰§è¡Œ Filter.invoke æ–¹æ³•ã€‚å½“å‘è¯¥ Invoker å‘èµ·è°ƒç”¨æ—¶ï¼Œä¼šå…ˆæ‰§è¡Œè¿‡æ»¤å™¨é“¾ï¼Œåªæœ‰å½“è¿‡æ»¤å™¨é“¾æ‰§è¡Œå®Œæ¯•åï¼Œæ‰ä¼šæ‰§è¡ŒçœŸæ­£çš„ Invoker çš„é€»è¾‘ã€‚ InjvmProtocolå®ç° AbstractProtocol æŠ½è±¡ç±»ï¼ŒInjvm åè®®å®ç°ç±»ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * InjvmProtocol */public class InjvmProtocol extends AbstractProtocol implements Protocol &#123; /** * åè®®å */ public static final String NAME = Constants.LOCAL_PROTOCOL; /** * ç«¯å£ */ public static final int DEFAULT_PORT = 0; /** * å•ä¾‹ï¼šåœ¨Dubbo SPIä¸­ï¼Œè¢«åˆå§‹åŒ–æœ‰ä¸”ä»…æœ‰ä¸€æ¬¡ */ private static InjvmProtocol INSTANCE; public InjvmProtocol() &#123; INSTANCE = this; &#125; /** * è·å¾—å•ä¾‹å­ * * @return */ public static InjvmProtocol getInjvmProtocol() &#123; if (INSTANCE == null) &#123; ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(InjvmProtocol.NAME); &#125; return INSTANCE; &#125; @Override public int getDefaultPort() &#123; return DEFAULT_PORT; &#125; /** * è¿›è¡ŒæœåŠ¡æš´éœ²ï¼Œåˆ›å»ºInjvmExporter[å¹¶æŠŠè‡ªå·±-&gt;Exporterå­˜å…¥åˆ°çˆ¶ç±»çš„ &#123;@link #exporterMap&#125; å±æ€§ä¸­ï¼Œkey:å½“å‰æœåŠ¡é”®ï¼Œvalue:Exporter] * * @param invoker Service invoker * @param &lt;T&gt; * @return * @throws RpcException */ @Override public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; // åˆ›å»ºExporterï¼Œå¹¶ä¸”æŠŠè‡ªå·±æ·»åŠ åˆ° exporterMap ä¸­ï¼ŒexporterMap æ˜¯çˆ¶ç±»å±æ€§ return new InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap); &#125; injvm åè®®æš´éœ²æœåŠ¡æ¯”è¾ƒç®€å•ï¼Œç›´æ¥åˆ›å»º InjvmExporter å¯¹è±¡ï¼Œç„¶åæ”¾å…¥å†…å­˜ä¸­å³å¯ï¼Œæ²¡æœ‰å…¶å®ƒé€»è¾‘ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« è¯¦ç»†åˆ†æäº† Dubbo æœ¬åœ°æœåŠ¡å¯¼å‡ºè¿‡ç¨‹ï¼ŒåŒ…æ‹¬é…ç½®æ£€æµ‹ï¼ŒURL ç»„è£…ï¼ŒInvoker åˆ›å»ºè¿‡ç¨‹ç­‰ï¼Œä¸‹ä¸€ç¯‡æ–‡ç« å°†åˆ†æè¿œç¨‹æš´éœ²ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - é¢†åŸŸæ¨¡å‹æ‰©å±•","slug":"rpc/Invokeræ‰©å±•","date":"2020-10-11T16:00:00.000Z","updated":"2021-04-06T08:28:59.091Z","comments":false,"path":"posts/946483bd/","link":"","permalink":"https://gentryhuang.com/posts/946483bd/","excerpt":"","text":"æ¦‚è¿°å¸¸è§çš„é¢†åŸŸæ¨¡å‹åœ¨ä¹‹å‰çš„æ–‡ç« ä¸­æœ‰æ‰€ä»‹ç»ï¼Œå¦‚ï¼šAbstractExpoterã€AbstractInvokerã€DubboExpoterã€DubboInvokerã€InjvmExpoterã€InjvmInvoker ç­‰ï¼Œå…³äºé›†ç¾¤å®¹é”™ä¸­æ¶‰åŠçš„é¢†åŸŸæ¨¡å‹å°†åœ¨ä»‹ç»é›†ç¾¤å®¹é”™ç¯‡ç« è¿›è¡Œä»‹ç»ã€‚æœ¬ç¯‡æ–‡ç« å°†å¯¹é¢†åŸŸæ¨¡å‹ç›¸å…³çš„æ‰©å±•è¿›è¡Œä»‹ç»ï¼Œæ¶‰åŠçš„ç±»å›¾å¦‚ä¸‹ï¼š ä¸Šå›¾æè¿°çš„æ˜¯ æœåŠ¡æš´éœ²çš„ç›‘å¬ã€æœåŠ¡å¼•ç”¨çš„ç›‘å¬ ä»¥åŠ è¿‡æ»¤å™¨é“¾çš„æ„å»º å…³ç³»ã€‚ ProtocolListenerWrapperProtocolListenerWrapper æœ¬èº«æ˜¯ Protocol æ‰©å±•ç‚¹çš„ Wrapperç±»ï¼Œ åœ¨æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨æ—¶ä»¥ Dubbo AOP çš„èƒ½åŠ›åˆ†åˆ«å°†å…·æœ‰ç›‘å¬åŠŸèƒ½çš„ ExporterListener å’Œ InvokerListener ç»‘å®šåˆ°æµç¨‹ä¸­ï¼Œä¾¿äºç”¨æˆ·åœ¨ Dubbo æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨åæ·»åŠ è‡ªå®šä¹‰çš„ä¸šåŠ¡é€»è¾‘ã€‚ Dubbo SPI12# com.alibaba.dubbo.rpc.Protocollistener&#x3D;com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper ä½œä¸º Protocol æ‰©å±•ç‚¹çš„ Wrapper å®ç°ã€‚ æ„é€ æ–¹æ³•12345678910111213141516public class ProtocolListenerWrapper implements Protocol &#123; // æ‰©å±•ç‚¹ private final Protocol protocol; // Wrapper çš„æ ¼å¼ public ProtocolListenerWrapper(Protocol protocol) &#123; if (protocol == null) &#123; throw new IllegalArgumentException(\"protocol == null\"); &#125; this.protocol = protocol; &#125; @Override public int getDefaultPort() &#123; return protocol.getDefaultPort(); &#125;&#125; æœåŠ¡æš´éœ²12345678910111213141516171819+--- ProtocolListenerWrapper @Override public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; // 1 registryåè®®å¼€å¤´çš„æœåŠ¡æš´éœ²é€»è¾‘ç›´æ¥è¿”å› // å› ä¸º RegistryProtocol å¹¶é Dubbo ä¸­çš„å…·ä½“åè®®ï¼Œå®ƒçš„é€»è¾‘æ˜¯åœ¨æ‰§è¡Œå…·ä½“åè®®ä¹‹å‰å¤„ç†å‰ç½®å·¥ä½œ if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123; return protocol.export(invoker); &#125; // 2 æš´éœ²æœåŠ¡ Exporter&lt;T&gt; export = protocol.export(invoker); // 3 è·å¾—ExporterListenerçš„æ¿€æ´»æ‰©å±•å®ç°ã€‚å¯ä»¥è‡ªå®šä¹‰ ExporterListener å®ç°ï¼Œå¹¶é…ç½® @Activateæ³¨è§£æˆ–è€…xmlä¸­listenerå±æ€§ List&lt;ExporterListener&gt; exporterListeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class) .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)); // 4 åˆ›å»ºå¸¦ ExporterListenerçš„ListenerExporterWrapperï¼Œç”¨æ¥ç›‘æ§æœåŠ¡æš´éœ²å®Œæ¯•åçš„å›è°ƒæ“ä½œã€‚ return new ListenerExporterWrapper&lt;T&gt;(export, exporterListeners); &#125; ProtocolListenerWrapper.export ç”¨äºå…·ä½“åè®®æš´éœ²æœåŠ¡åå¢åŠ ç›‘å¬å™¨ï¼Œç”¨äºç›‘å¬æœåŠ¡æš´éœ²å®Œæˆå’ŒæœåŠ¡å–æ¶ˆæš´éœ²äº‹ä»¶ã€‚ä½¿ç”¨ ListenerExporterWrapper å¯¹ ExporterListener è¿›è¡Œå°è£…ã€‚ ExporterListener1234567891011121314151617181920@SPIpublic interface ExporterListener &#123; /** * ç›‘å¬æœåŠ¡æš´éœ²äº‹ä»¶ * * @param exporter * @throws RpcException * @see com.alibaba.dubbo.rpc.Protocol#export(Invoker) */ void exported(Exporter&lt;?&gt; exporter) throws RpcException; /** * ç›‘å¬å–æ¶ˆæš´éœ²äº‹ä»¶ * * @param exporter * @throws RpcException * @see com.alibaba.dubbo.rpc.Exporter#unexport() */ void unexported(Exporter&lt;?&gt; exporter);&#125; ExporterListener æ˜¯ Dubbo çš„ä¸€ä¸ªæ‰©å±•ç‚¹ï¼Œå…¶æ‰©å±•å®ç°ç±»å¯ä»¥é€šè¿‡å®ç° exported() æ–¹æ³•å’Œ unexported() æ–¹æ³•ç›‘å¬æœåŠ¡æš´éœ²äº‹ä»¶ä»¥åŠå–æ¶ˆæš´éœ²äº‹ä»¶ã€‚ExporterListenerAdapter æ˜¯è¯¥æ‰©å±•ç‚¹çš„é€‚é…å™¨æŠ½è±¡ç±»ï¼Œä½¿ç”¨æ–¹åœ¨ä½¿ç”¨è¯¥æ‰©å±•ç‚¹è¿›è¡ŒåŠŸèƒ½å®šåˆ¶æ—¶å¯ä»¥ç›´æ¥é€šè¿‡ç»§æ‰¿è¯¥æŠ½è±¡å®ç°ç±»å³å¯ã€‚ ListenerExporterWrapperåœ¨ ProtocolListenerWrapper çš„ export() æ–¹æ³•ä¸­ä¼šåœ¨åŸæœ‰çš„ Exporter ä¹‹ä¸Šç”¨ ListenerExporterWrapper è¿›è¡Œä¸€å±‚å°è£…ï¼ŒListenerExporterWrapper çš„æ„é€ æ–¹æ³•ä¸­ä¼šå¾ªç¯è°ƒç”¨å…¨éƒ¨ ExporterListener.exported() æ–¹æ³•ï¼Œé€šçŸ¥å…¶æœåŠ¡æš´éœ²çš„äº‹ä»¶ï¼Œæ ¸å¿ƒé€»è¾‘å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314151617181920212223242526272829303132+--- ListenerExporterWrapper /** * æ„é€ æ–¹æ³• * @param exporter æš´éœ²çš„ Expoter * @param listeners è‡ªå®šä¹‰çš„ ExporterListener */ public ListenerExporterWrapper(Exporter&lt;T&gt; exporter, List&lt;ExporterListener&gt; listeners) &#123; if (exporter == null) &#123; throw new IllegalArgumentException(\"exporter == null\"); &#125; this.exporter = exporter; this.listeners = listeners; // åœ¨æœåŠ¡æš´éœ²è¿‡ç¨‹ä¸­è§¦å‘å…¨éƒ¨ExpoterListenerç›‘å¬å™¨ if (listeners != null &amp;&amp; !listeners.isEmpty()) &#123; RuntimeException exception = null; for (ExporterListener listener : listeners) &#123; if (listener != null) &#123; try &#123; // äº‹ä»¶è§¦å‘ã€æœåŠ¡æš´éœ²åã€‘å›è°ƒ listener.exported(this); &#125; catch (RuntimeException t) &#123; logger.error(t.getMessage(), t); exception = t; &#125; &#125; &#125; if (exception != null) &#123; throw exception; &#125; &#125; &#125; ListenerExporterWrapper.unexported() æ–¹æ³•çš„é€»è¾‘ä¸ä¸Šè¿° exported() æ–¹æ³•çš„å®ç°åŸºæœ¬ç±»ä¼¼ï¼Œä»£ç å®ç°å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728+--- ListenerExporterWrapper /** * å–æ¶ˆæœåŠ¡æš´éœ² */ @Override public void unexport() &#123; try &#123; exporter.unexport(); &#125; finally &#123; // æ‰§è¡Œç›‘å¬å™¨ if (listeners != null &amp;&amp; !listeners.isEmpty()) &#123; RuntimeException exception = null; for (ExporterListener listener : listeners) &#123; if (listener != null) &#123; try &#123; listener.unexported(this); &#125; catch (RuntimeException t) &#123; logger.error(t.getMessage(), t); exception = t; &#125; &#125; &#125; if (exception != null) &#123; throw exception; &#125; &#125; &#125; &#125; åœ¨æœåŠ¡æš´éœ²æ—¶è¿”å›çš„å°±æ˜¯ ListenerExporterWrapper å¯¹è±¡ï¼Œæ‰§è¡Œå–æ¶ˆæœåŠ¡æš´éœ²åˆ™ä¼šè°ƒç”¨ä¸Šè¿° unexport() æ–¹æ³•ã€‚ UMLå…³ç³»å›¾ æœåŠ¡å¼•ç”¨1234567891011121314151617+--- ProtocolListenerWrapper @Override public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123; // 1 å¦‚æœæ˜¯æ³¨å†Œä¸­å¿ƒåè®®ï¼Œç›´æ¥è¿›å…¥ ProtocolFilterWrapper#referæ–¹æ³• if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123; return protocol.refer(type, url); &#125; // 2 å¼•ç”¨æœåŠ¡ Invoker&lt;T&gt; invoker = protocol.refer(type, url); // 3 è·å¾— InvokerListener çš„æ¿€æ´»æ‰©å±•å®ç°ï¼Œå¯ä»¥è‡ªå®šä¹‰ InvokerListener å®ç°ï¼Œå¹¶é…ç½® @Activateæ³¨è§£æˆ–è€…xmlä¸­listenerå±æ€§ List&lt;InvokerListener&gt; listeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(InvokerListener.class) .getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)); // 4 åˆ›å»ºå¸¦ InvokerListenerçš„ ListenerInvokerWrapperå¯¹è±¡ï¼Œç”¨æ¥ç›‘æ§æœåŠ¡å¼•ç”¨åçš„å›è°ƒæ“ä½œ return new ListenerInvokerWrapper&lt;T&gt;(invoker, listeners); &#125; ProtocolListenerWrapper.refer ç”¨äºå…·ä½“åè®®å¼•ç”¨æœåŠ¡åå¢åŠ ç›‘å¬å™¨ï¼Œç”¨äºç›‘å¬æœåŠ¡å¼•ç”¨å®Œæˆå’ŒæœåŠ¡é”€æ¯äº‹ä»¶ã€‚ä½¿ç”¨ ListenerInvokerWrapper å¯¹ InvokerListener è¿›è¡Œå°è£…ã€‚ InvokerListener1234567891011121314151617181920@SPIpublic interface InvokerListener &#123; /** * ç›‘å¬æœåŠ¡å¼•ç”¨äº‹ä»¶ * * @param invoker * @throws RpcException * @see com.alibaba.dubbo.rpc.Protocol#refer(Class, com.alibaba.dubbo.common.URL) */ void referred(Invoker&lt;?&gt; invoker) throws RpcException; /** * ç›‘å¬é”€æ¯å¼•ç”¨äº‹ä»¶ * * @param invoker * @see com.alibaba.dubbo.rpc.Invoker#destroy() */ void destroyed(Invoker&lt;?&gt; invoker);&#125; åŒæ ·åœ°ï¼ŒInvokerListener æ˜¯ Dubbo çš„ä¸€ä¸ªæ‰©å±•ç‚¹ï¼Œèµ·æ‰©å±•å®ç°ç±»å¯ä»¥é€šè¿‡å®ç° referred() æ–¹æ³•å’Œ destroyed() æ–¹æ³•ç›‘å¬æœåŠ¡å¼•ç”¨å’Œé”€æ¯å¼•ç”¨äº‹ä»¶ã€‚InvokerListenerAdapter æ˜¯è¯¥æ‰©å±•ç‚¹çš„é€‚é…å™¨æŠ½è±¡ç±»ï¼Œä½¿ç”¨æ–¹åœ¨ä½¿ç”¨è¯¥æ‰©å±•ç‚¹è¿›è¡ŒåŠŸèƒ½å®šåˆ¶æ—¶å¯ä»¥ç›´æ¥é€šè¿‡ç»§æ‰¿è¯¥æŠ½è±¡å®ç°ç±»å³å¯ã€‚ ListenerInvokerWrapperåœ¨ ProtocolListenerWrapper çš„ refer() æ–¹æ³•ä¸­ä¼šåœ¨åŸæœ‰çš„ Invoker ä¹‹ä¸Šç”¨ ListenerInvokerWrapper è¿›è¡Œä¸€å±‚å°è£…ï¼Œåœ¨æ„é€ æ–¹æ³•å†…éƒ¨ä¼šéå†æ•´ä¸ª InvokerListener åˆ—è¡¨ï¼Œå¹¶è°ƒç”¨æ¯ä¸ª InvokerListener.referred() æ–¹æ³•ï¼Œé€šçŸ¥å®ƒä»¬ Invoker è¢«å¼•ç”¨çš„äº‹ä»¶ã€‚ 123456789101112131415161718192021222324+--- ListenerInvokerWrapper public ListenerInvokerWrapper(Invoker&lt;T&gt; invoker, List&lt;InvokerListener&gt; listeners) &#123; if (invoker == null) &#123; throw new IllegalArgumentException(\"invoker == null\"); &#125; // è¢«ä¿®é¥°çš„ Invoker å¯¹è±¡ this.invoker = invoker; // ç›‘å¬å™¨é›†åˆ this.listeners = listeners; // æ‰§è¡Œç›‘å¬å™¨ if (listeners != null &amp;&amp; !listeners.isEmpty()) &#123; for (InvokerListener listener : listeners) &#123; // åœ¨æœåŠ¡å¼•ç”¨è¿‡ç¨‹ä¸­è§¦å‘å…¨éƒ¨InvokerListenerç›‘å¬å™¨ if (listener != null) &#123; try &#123; // å½“æœåŠ¡å¼•ç”¨å®Œæˆæ—¶ä¼šè¢«è°ƒç”¨ listener.referred(invoker); &#125; catch (Throwable t) &#123; logger.error(t.getMessage(), t); &#125; &#125; &#125; &#125; &#125; ListenerInvokerWrapper.destroy æ–¹æ³•çš„é€»è¾‘ä¸ä¸Šè¿°æ–¹æ³•åŸºæœ¬ç±»ä¼¼ï¼Œä»£ç å®ç°å¦‚ä¸‹ï¼š 123456789101112131415161718192021+--- ListenerInvokerWrapper @Override public void destroy() &#123; try &#123; // é”€æ¯å¼•ç”¨ invoker.destroy(); &#125; finally &#123; // æ‰§è¡Œç›‘å¬å™¨ if (listeners != null &amp;&amp; !listeners.isEmpty()) &#123; for (InvokerListener listener : listeners) &#123; if (listener != null) &#123; try &#123; listener.destroyed(invoker); &#125; catch (Throwable t) &#123; logger.error(t.getMessage(), t); &#125; &#125; &#125; &#125; &#125; &#125; æœåŠ¡å¼•ç”¨è¿”å›çš„å°±æ˜¯ ListenerInvokerWrapper å¯¹è±¡ï¼Œå½“è¿›è¡Œå¼•ç”¨é”€æ¯æ—¶ä¼šè°ƒç”¨ä¸Šè¿°æ–¹æ³•ã€‚ UMLå…³ç³»å›¾ ProtocolFilterWrapperProtocolFilterWrapper åŒæ ·ä¹Ÿæ˜¯ Protocol æ‰©å±•ç‚¹çš„ Wrapperç±»ï¼Œ åœ¨æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨æ—¶ä»¥ Dubbo AOP çš„èƒ½åŠ›åˆ†åˆ«æ„å»ºè¿‡æ»¤å™¨é“¾ã€‚ Dubbo SPI12# com.alibaba.dubbo.rpc.Protocolfilter&#x3D;com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper ä½œä¸º Protocol æ‰©å±•ç‚¹çš„ Wrapper å®ç°ã€‚ æ„é€ æ–¹æ³•123456789101112131415public class ProtocolFilterWrapper implements Protocol &#123; // æ‰©å±•ç‚¹ private final Protocol protocol; // Wrapper çš„æ ¼å¼ public ProtocolFilterWrapper(Protocol protocol) &#123; if (protocol == null) &#123; throw new IllegalArgumentException(\"protocol == null\"); &#125; this.protocol = protocol; &#125; @Override public int getDefaultPort() &#123; return protocol.getDefaultPort(); &#125;&#125; æœåŠ¡æš´éœ²1234567891011+--- ProtocolFilterWrapper @Override public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; // 1 å¦‚æœæ˜¯æ³¨å†Œä¸­å¿ƒåè®®ï¼Œæ— éœ€åˆ›å»ºFilterè¿‡æ»¤å™¨ã€‚ if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123; return protocol.export(invoker); &#125; // 2 å»ºç«‹å¸¦æœ‰Filter è¿‡æ»¤é“¾çš„ Invokerï¼Œæš´éœ²æœåŠ¡ã€‚ // Constants.PROVIDER æ ‡è¯†è‡ªå·±æ˜¯æœåŠ¡æä¾›è€…ç±»å‹çš„è°ƒç”¨é“¾ return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER)); &#125; ProtocolFilterWrapper.export æ–¹æ³•ä¼šåœ¨ Invoker çš„åŸºç¡€ä¸Šåˆ›å»ºå¸¦æœ‰ Filter è¿‡æ»¤å™¨çš„ Invoker ï¼Œç„¶åå°†å¤„ç†åçš„ Invoker æš´éœ²å‡ºå»ã€‚ æœåŠ¡å¼•ç”¨1234567891011121314+--- ProtocolFilterWrapper @Override public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123; // 1 å¦‚æœæ˜¯æ³¨å†Œä¸­å¿ƒåè®®ï¼Œæ— éœ€åˆ›å»ºFilterè¿‡æ»¤å™¨ã€‚ if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123; return protocol.refer(type, url); &#125; /** * 1 å¼•ç”¨æœåŠ¡ï¼Œè¿”å› Invoker å¯¹è±¡ * 2 å¼•ç”¨æœåŠ¡å®Œæˆåï¼Œè°ƒç”¨ buildInvokerChain(invoker,key,group)æ–¹æ³•ï¼Œåˆ›å»ºå¸¦æœ‰Filterè¿‡æ»¤å™¨çš„Invokerå¯¹è±¡ã€‚å’ŒæœåŠ¡æš´éœ²åŒºåˆ«åœ¨groupçš„å€¼ä¸Šï¼Œ * Constants.CONSUMER æ ‡è¯†è‡ªå·±æ˜¯æ¶ˆè´¹ç±»å‹çš„è°ƒç”¨é“¾ */ return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER); &#125; ProtocolFilterWrapper.refer æ–¹æ³•ä¼šå°†å¼•ç”¨çš„ Invoker å¯¹è±¡åŒ…è£…æˆå¸¦æœ‰ Filter è¿‡æ»¤å™¨çš„ Invoker ã€‚ å…³äºè¿‡æ»¤å™¨é“¾å¯ä»¥å‚è€ƒï¼šè¿‡æ»¤å™¨é“¾ å°ç»“æœ¬ç¯‡æ–‡ç« ä»‹ç»äº†æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨çš„äº‹ä»¶ç›‘å¬ï¼Œè§¦å‘æ—¶æœºæ˜¯åœ¨æœåŠ¡æš´éœ²å®Œæˆã€æœåŠ¡å¼•ç”¨å®Œæˆï¼Œè§¦å‘æ–¹å¼æ˜¯åˆ©ç”¨ Protocol æ‰©å±•ç‚¹çš„ Wrapper åŠŸèƒ½ï¼Œåœ¨æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨çš„æ–¹æ³•æ‰§è¡Œæ—¶æ‰§è¡Œè‡ªå®šä¹‰çš„ç›‘å¬å™¨ ExporterListener å’Œ InvokerListener çš„æ‰©å±•å®ç°ï¼Œä»¥å®ŒæˆæŒ‡å®šåŠŸèƒ½ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"é›†ç¾¤å®¹é”™ - Cluster","slug":"rpc/é›†ç¾¤å®¹é”™ä¹‹Cluster","date":"2020-10-02T16:00:00.000Z","updated":"2021-04-06T15:40:57.574Z","comments":false,"path":"posts/7f19ea26/","link":"","permalink":"https://gentryhuang.com/posts/7f19ea26/","excerpt":"","text":"å‰è¨€å‰é¢çš„å‡ ç¯‡æ–‡ç« åˆ†åˆ«å¯¹æœåŠ¡ç›®å½• Directoryã€è·¯ç”± Routerã€è´Ÿè½½å‡è¡¡ LoadBalance ä»¥åŠåŠ¨æ€é…ç½®è¿›è¡Œäº†ä»‹ç»ï¼Œæœ¬ç¯‡æ–‡ç« å°†å¯¹ Dubbo çš„é›†ç¾¤å®¹é”™è¿›è¡Œåˆ†æï¼Œé›†ç¾¤å®¹é”™æ˜¯åŸºäºå‰é¢å‡ éƒ¨åˆ†å†…å®¹å®ç°çš„ã€‚ æ¦‚è¿°ä¸ºäº†é¿å…å•ç‚¹æ•…éšœï¼Œç°åœ¨çš„åº”ç”¨é€šå¸¸è‡³å°‘ä¼šéƒ¨ç½²åœ¨ä¸¤å°æœåŠ¡å™¨ä¸Šï¼Œå¯¹ä¸€äº›è´Ÿè½½æ¯”è¾ƒé«˜çš„æœåŠ¡ï¼Œä¼šéƒ¨ç½²æ›´å¤šçš„æœåŠ¡å™¨ã€‚è¿™æ ·ï¼Œåœ¨åŒä¸€ç¯å¢ƒä¸‹çš„æœåŠ¡æä¾›è€…å°±ä¼šæœ‰å¤šå°ï¼Œå¯¹äºæœåŠ¡æ¶ˆè´¹è€…æ¥è¯´ï¼Œéœ€è¦é€‰æ‹©ä¸€ä¸ªæœåŠ¡æä¾›è€…è¿›è¡Œè°ƒç”¨ï¼Œå¦‚æœè°ƒç”¨å¤±è´¥è¿˜éœ€è¦è¿›è¡Œå¤±è´¥å¤„ç†ï¼Œå¦‚é‡è¯•ã€æŠ›å‡ºå¼‚å¸¸æˆ–è€…è®°å½•å¼‚å¸¸æ—¥å¿—ç­‰ã€‚ä¸ºäº†å¤„ç†è¿™äº›é—®é¢˜ï¼ŒDubbo å®šä¹‰äº†é›†ç¾¤æ¥å£ Cluster ä»¥åŠ Cluster Invoker ã€‚Cluster ç”¨é€”æ˜¯å°†å¤šä¸ªæœåŠ¡æä¾›è€…åˆå¹¶ä¸ºä¸€ä¸ª Cluster Invokerï¼Œå¹¶å°†è¿™ä¸ª Invoker æš´éœ²ç»™æœåŠ¡æ¶ˆè´¹è€…ã€‚è¿™æ ·ä¸€æ¥ï¼ŒæœåŠ¡æ¶ˆè´¹è€…åªéœ€é€šè¿‡è¿™ä¸ª Invoker è¿›è¡Œè¿œç¨‹è°ƒç”¨å³å¯ï¼Œè‡³äºå…·ä½“è°ƒç”¨å“ªä¸ªæœåŠ¡æä¾›è€…ï¼Œä»¥åŠè°ƒç”¨å¤±è´¥åå¦‚ä½•å¤„ç†ç­‰é—®é¢˜ï¼Œç°åœ¨éƒ½äº¤ç»™é›†ç¾¤æ¨¡å—å»å¤„ç†ã€‚é›†ç¾¤æ¨¡å—æ˜¯æœåŠ¡æä¾›è€…å’ŒæœåŠ¡æ¶ˆè´¹è€…çš„ä¸­é—´å±‚ï¼Œä¸ºæœåŠ¡æ¶ˆè´¹è€…å±è”½äº†æœåŠ¡æä¾›è€…çš„æƒ…å†µï¼Œè¿™æ ·æœåŠ¡æ¶ˆè´¹è€…å°±å¯ä»¥ä¸“å¿ƒå¤„ç†è¿œç¨‹è°ƒç”¨ç›¸å…³äº‹å®œã€‚æ¯”å¦‚å‘è¯·æ±‚ï¼Œæ¥å—æœåŠ¡æä¾›è€…è¿”å›çš„æ•°æ®ç­‰ã€‚è¿™å°±æ˜¯é›†ç¾¤çš„ä½œç”¨ã€‚ Dubbo é»˜è®¤å†…ç½®äº†è‹¥å¹²å®¹é”™ç­–ç•¥ï¼Œæ¯ç§å®¹é”™ç­–ç•¥éƒ½æœ‰ç‹¬ç‰¹çš„åº”ç”¨åœºæ™¯ï¼Œä½¿ç”¨æ–¹å¯ä»¥é€šè¿‡é…ç½®ä¸åŒçš„å®¹é”™ç­–ç•¥ï¼Œå¦‚æœè¿™äº›å†…ç½®å®¹é”™ç­–ç•¥ä¸èƒ½æ»¡è¶³éœ€æ±‚ï¼Œè¿˜å¯ä»¥è‡ªå®šä¹‰å®¹é”™ç­–ç•¥ã€‚ é›†ç¾¤å®¹é”™åœ¨åˆ†æé›†ç¾¤å®¹é”™ç›¸å…³ä»£ç ä¹‹å‰ï¼Œå…ˆå¯¹æ¶‰åŠçš„ç»„ä»¶è¿›è¡Œä»‹ç»ï¼Œä¸»è¦åŒ…æ‹¬äº† Clusterã€Cluster Invokerã€Directoryã€Router å’Œ LoadBalance ã€‚ é›†ç¾¤å·¥ä½œè¿‡ç¨‹å¯åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼Œå…·ä½“å¦‚ä¸‹ï¼š åˆ›å»º Cluster Invoker å®ä¾‹ åœ¨æœåŠ¡æ¶ˆè´¹è€…åˆå§‹åŒ–æœŸé—´ï¼Œé›†ç¾¤ Cluster å®ç°ç±»ä¸ºæœåŠ¡æ¶ˆè´¹è€…åˆ›å»º Cluster Invoker å®ä¾‹ï¼ŒåŠä¸Šå›¾ä¸­çš„ merge æ“ä½œã€‚ ä½¿ç”¨ Cluster Invoker å®ä¾‹ åœ¨æœåŠ¡æ¶ˆè´¹è€…å‘èµ·è¿œç¨‹è°ƒç”¨è¯·æ±‚æ—¶ï¼ŒCluster Invoker ä¼šä¾èµ– Directoryã€Routerã€LoadBalance ç­‰ç»„ä»¶å¾—åˆ°æœ€ç»ˆè¦è°ƒç”¨çš„ Invoker å¯¹è±¡ã€‚ å…¶ä¸­ä½¿ç”¨ Cluster Invoker è·å–ç›®æ ‡ Invoker çš„å…·ä½“æµç¨‹å¦‚ä¸‹ï¼š é€šè¿‡æœåŠ¡ç›®å½• Directory è·å–æ¶ˆè´¹ç«¯ Invoker åˆ—è¡¨ï¼ˆæä¾›è€…å¯¹åº”çš„ Invoker åˆ—è¡¨ï¼‰ï¼Œå…¶ä¸­çš„ RegistryDirectory ä¼šæ„ŸçŸ¥æ³¨å†Œä¸­å¿ƒçš„åŠ¨æ€å˜åŒ–ï¼Œå®æ—¶è·å–æä¾›è€…å¯¹åº”çš„ Invoker å¯¹è±¡ã€‚ ä½¿ç”¨ Router å¯¹æœåŠ¡ç›®å½•ä¸­çš„æä¾›è€…å¯¹åº”çš„ Invoker åˆ—è¡¨è¿›è¡Œè·¯ç”±ï¼Œè¿‡æ»¤æ‰ä¸ç¬¦åˆè·¯ç”±è§„åˆ™çš„ Invoker å¯¹è±¡ã€‚ ä½¿ç”¨ LoadBalance ä»è·¯ç”±åçš„ Invoker åˆ—è¡¨ä¸­é€‰æ‹©ä¸€ä¸ª Invokerã€‚ ClusterInvoker ä¼šå°†è¯·æ±‚ä¿¡æ¯ä¼ ç»™è´Ÿè½½å‡è¡¡é€‰å‡ºçš„ Invoker å®ä¾‹ï¼Œè¿›è¡ŒçœŸæ­£çš„è¿œç¨‹è°ƒç”¨ã€‚ ä»¥ä¸Šå°±æ˜¯é›†ç¾¤å·¥ä½œçš„æ­£å¸¸æµç¨‹ï¼Œæ²¡æœ‰æ¶‰åŠåˆ°å®¹é”™å¤„ç†ï¼Œå®¹é”™å¤„ç†é€»è¾‘æ˜¯åœ¨ Cluster Invoker ä¸­å°è£…çš„ã€‚Dubbo ä¸»è¦æä¾›äº†ä»¥ä¸‹çš„å®¹é”™æ–¹å¼ï¼š Failover Cluster - å¤±è´¥è‡ªåŠ¨åˆ‡æ¢ å¤±è´¥è‡ªåŠ¨åˆ‡æ¢ï¼Œæ˜¯ Dubbo é»˜è®¤çš„å®¹é”™æœºåˆ¶ã€‚åœ¨è¯·æ±‚ä¸€ä¸ªæä¾›è€…èŠ‚ç‚¹å¤±è´¥æ—¶ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°å…¶ä»–æä¾›è€…èŠ‚ç‚¹ï¼Œé»˜è®¤æ‰§è¡Œ 3 æ¬¡ï¼Œä¹Ÿå°±æ˜¯é‡è¯• 2 æ¬¡ï¼Œé€‚åˆå¹‚ç­‰æ“ä½œã€‚ Failfast Cluster - å¿«é€Ÿå¤±è´¥ å¿«é€Ÿå¤±è´¥ã€‚è¯·æ±‚å¤±è´¥åè¿”å›å¼‚å¸¸ï¼Œä¸è¿›è¡Œä»»åŠ¡é‡è¯•ã€‚ Failsafe Cluster - å¤±è´¥å®‰å…¨ å¤±è´¥å®‰å…¨ã€‚è¯·æ±‚å¤±è´¥åå¿½ç•¥å¼‚å¸¸ï¼Œä¸è¿›è¡Œä»»ä½•é‡è¯•ã€‚ Failback Cluster - å¤±è´¥è‡ªåŠ¨æ¢å¤ å¤±è´¥è‡ªåŠ¨æ¢å¤ã€‚å¤±è´¥åè®°å½•åˆ°é˜Ÿåˆ—ï¼Œä¼šå®šæ—¶é‡è¯•ã€‚ Forking Cluster - å¹¶è¡Œè°ƒç”¨å¤šä¸ªæä¾›è€… å¹¶è¡Œè°ƒç”¨å¤šä¸ªæä¾›è€…ï¼Œåªè¦æœ‰ä¸€ä¸ªæˆåŠŸå°±è¿”å›ã€‚ Broadcast Cluster - å¹¿æ’­å¤šä¸ªæä¾›è€… å¹¿æ’­å¤šä¸ªæä¾›è€…ï¼Œåªè¦æœ‰ä¸€ä¸ªå¤±è´¥å°±å¤±è´¥ã€‚ Availabel Cluster - è°ƒç”¨é¦–ä¸ªå¯ç”¨çš„æä¾›è€… éå†æ‰€æœ‰çš„ Provider èŠ‚ç‚¹ï¼Œæ‰¾åˆ°æ¯ä¸€ä¸ªå¯ç”¨çš„èŠ‚ç‚¹ï¼Œå°±ç›´æ¥è°ƒç”¨ã€‚å¦‚æœæ²¡æœ‰å¯ç”¨çš„ Provider èŠ‚ç‚¹ï¼Œåˆ™ç›´æ¥æŠ›å‡ºå¼‚å¸¸ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"é›†ç¾¤å®¹é”™ - LoadBalance","slug":"rpc/é›†ç¾¤å®¹é”™ä¹‹è´Ÿè½½å‡è¡¡","date":"2020-09-30T23:00:00.000Z","updated":"2021-04-06T08:33:39.593Z","comments":false,"path":"posts/9966fbd5/","link":"","permalink":"https://gentryhuang.com/posts/9966fbd5/","excerpt":"","text":"æ¦‚è¿°Dubbo ä¸­çš„è´Ÿè½½å‡è¡¡ LoadBalance çš„èŒè´£æ˜¯å°†ç½‘ç»œè¯·æ±‚æˆ–è€…å…¶å®ƒå½¢å¼çš„è´Ÿè½½ &quot;å‡æ‘Š&quot; åˆ°ä¸åŒçš„æœåŠ¡èŠ‚ç‚¹ä¸Šï¼Œä»è€Œé¿å…æœåŠ¡é›†ç¾¤ä¸­éƒ¨åˆ†èŠ‚ç‚¹å‹åŠ›è¿‡å¤§ï¼Œè€Œå¦ä¸€éƒ¨åˆ†èŠ‚ç‚¹æ¯”è¾ƒç©ºé—²çš„æƒ…å†µã€‚é€šè¿‡åˆç†çš„è´Ÿè½½å‡è¡¡ï¼Œå¯ä»¥è®©æ¯ä¸ªæœåŠ¡èŠ‚ç‚¹è·å–åˆ°é€‚åˆè‡ªå·±å¤„ç†èƒ½åŠ›çš„è´Ÿè½½ï¼Œå®ç°å¤„ç†èƒ½åŠ›å’Œæµé‡çš„åˆç†åˆ†é…ã€‚å¸¸ç”¨çš„è´Ÿè½½å‡è¡¡å¯åˆ†ä¸ºè½¯ä»¶è´Ÿè½½å‡è¡¡å’Œç¡¬ä»¶è´Ÿè½½å‡è¡¡ï¼Œåœ¨æ—¥å¸¸å¼€å‘ä¸­ä¸€èˆ¬å¾ˆéš¾æ¥è§¦åˆ°ç¡¬ä»¶è´Ÿè½½å‡è¡¡ï¼Œä¸»è¦æœ‰ F5ã€NetScaler ç­‰ï¼›è½¯ä»¶è´Ÿè½½å‡è¡¡è¿˜æ˜¯å¾ˆå¸¸è§çš„ï¼Œæ¯”å¦‚ Nginx ã€‚å¸¸è§çš„ RPC æ¡†æ¶éƒ½æœ‰è´Ÿè½½å‡è¡¡çš„æ¦‚å¿µå’Œç›¸åº”çš„å®ç°ï¼ŒDubbo ä¹Ÿä¸ä¾‹å¤–ã€‚Dubbo éœ€è¦å¯¹æœåŠ¡æ¶ˆè´¹è€…çš„è°ƒç”¨è¯·æ±‚è¿›è¡Œåˆ†é…ï¼Œé¿å…å°‘æ•°æä¾›è€…èŠ‚ç‚¹è´Ÿè½½è¿‡å¤§ï¼Œè€Œå…¶å®ƒæä¾›è€…èŠ‚ç‚¹å¤„äºç©ºé—²çŠ¶æ€ã€‚æœåŠ¡æä¾›è€…è´Ÿè½½è¿‡å¤§ï¼Œä¼šå¯¼è‡´éƒ¨åˆ†è¯·æ±‚è¶…æ—¶ã€ç”šè‡³ä¸¢å¤±ç­‰ä¸€ç³»åˆ—é—®é¢˜ï¼Œé€ æˆçº¿ä¸Šæ•…éšœã€‚å› æ­¤å°†è´Ÿè½½å‡è¡¡åˆ°æ¯ä¸ªæœåŠ¡æä¾›è€…æ˜¯éå¸¸æœ‰å¿…è¦çš„ã€‚ è´Ÿè½½å‡è¡¡ç­–ç•¥åœ¨é›†ç¾¤è´Ÿè½½å‡è¡¡æ—¶ï¼ŒDubbo æä¾›äº† 5 ç§å‡è¡¡ç­–ç•¥ï¼Œç¼ºçœä¸º random éšæœºè°ƒç”¨ã€‚ åŸºäºåŠ æƒéšæœºç®—æ³•çš„ RandomLoadBalance åŸºäºåŠ æƒè½®è¯¢ç®—æ³•çš„ RoundRobinLoadBalance åŸºäºæœ€å°‘æ´»è·ƒè°ƒç”¨æ•°ç®—æ³•çš„ LeastActiveLoadBalance åŸºäºä¸€è‡´æ€§ Hash çš„ ConsistentHashLoadBalance åŸºäºæœ€çŸ­å“åº”æ—¶é—´çš„ ShortestResponseLoadBalance ç»§æ‰¿å…³ç³»å›¾å¦‚ä¸‹ï¼š å…¶ä¸­åŸºäºæœ€çŸ­å“åº”æ—¶é—´çš„ ShortestResponseLoadBalance è´Ÿè½½å‡è¡¡ç­–ç•¥æ˜¯ Dubbo 2.7.x æ–°å¢çš„ï¼Œå’ŒåŸºäºæœ€å°‘æ´»è·ƒè°ƒç”¨æ•°ç®—æ³•ç±»ä¼¼ã€‚ é…ç½® æœåŠ¡ç«¯æœåŠ¡çº§åˆ«1&lt;dubbo:service interface=\"...\" loadbalance=\"roundrobin\" /&gt; å®¢æˆ·ç«¯æœåŠ¡çº§åˆ«1&lt;dubbo:reference interface=\"...\" loadbalance=\"roundrobin\" /&gt; æœåŠ¡ç«¯æ–¹æ³•çº§åˆ«123&lt;dubbo:service interface=\"...\"&gt; &lt;dubbo:method name=\"...\" loadbalance=\"roundrobin\"/&gt;&lt;/dubbo:service&gt; å®¢æˆ·ç«¯æ–¹æ³•çº§åˆ«123&lt;dubbo:reference interface=\"...\"&gt; &lt;dubbo:method name=\"...\" loadbalance=\"roundrobin\"/&gt;&lt;/dubbo:reference&gt; æºç åˆ†æLoadBalance123456789101112131415@SPI(RandomLoadBalance.NAME)public interface LoadBalance &#123; /** * æ ¹æ®ä¼ å…¥çš„ URL å’Œ Invocation ï¼Œä»¥åŠè´Ÿè½½å‡è¡¡ç®—æ³•ä» Invoker é›†åˆä¸­é€‰æ‹©ä¸€ä¸ª Invoker * * @param invokers invokers. * @param url refer url * @param invocation invocation. * @return selected invoker. */ @Adaptive(\"loadbalance\") &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;&#125; LoadBalance æ˜¯ä¸€ä¸ªæ‰©å±•æ¥å£ï¼Œé»˜è®¤æ‰©å±•å®ç°æ˜¯ RandomLoadBalance ï¼ŒDubbo æ ¹æ® @Adaptive(&quot;loadbalance&quot;) æ³¨è§£ç”Ÿæˆçš„é€‚é…å™¨ä¼šæŒ‰ç…§ URL ä¸­çš„ loadbalance å‚æ•°å€¼é€‰æ‹©æ‰©å±•å®ç°ç±»ã€‚ AbstractLoadBalanceé€‰æ‹© Invoker123456789101112131415161718192021+--- AbstractLoadBalance /** * @param invokers invokers. * @param url refer url * @param invocation invocation. * @param &lt;T&gt; * @return */ @Override public &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123; // 1 Invokeré›†åˆä¸ºç©ºï¼Œç›´æ¥è¿”å›null if (CollectionUtils.isEmpty(invokers)) &#123; return null; &#125; // 2 Invokeré›†åˆåªåŒ…å«ä¸€ä¸ªInvokerï¼Œåˆ™ç›´æ¥è¿”å›è¯¥Invokerå¯¹è±¡ if (invokers.size() == 1) &#123; return invokers.get(0); &#125; // 3 Invokeré›†åˆåŒ…å«å¤šä¸ªInvokerå¯¹è±¡æ—¶ï¼Œäº¤ç»™doSelect()æ–¹æ³•å¤„ç†ï¼Œè¿™æ˜¯ä¸ªæŠ½è±¡æ–¹æ³•ï¼Œç•™ç»™å­ç±»å…·ä½“å®ç° return doSelect(invokers, url, invocation); &#125; AbstractLoadBalance æŠ½è±¡ç±»å¹¶æ²¡æœ‰çœŸæ­£å®ç° select() æ–¹æ³•ï¼Œä»…æ˜¯å¯¹ Invoker é›†åˆä¸ºç©ºæˆ–æ˜¯åªåŒ…å«ä¸€ä¸ª Invoker å¯¹è±¡çš„æƒ…å†µè¿›è¡Œäº†å¤„ç†ï¼Œå…¶å®ƒæƒ…å†µçš„é€‰æ‹©é€»è¾‘äº¤ç»™å­ç±»å®ç°ã€‚ æœåŠ¡æä¾›è€…æƒé‡è®¡ç®—1234567891011121314151617181920212223242526272829303132333435+--- AbstractLoadBalance int getWeight(Invoker&lt;?&gt; invoker, Invocation invocation) &#123; int weight; URL url = invoker.getUrl(); // 1 å¤šæ³¨å†Œä¸­å¿ƒåœºæ™¯ï¼Œå¤šæ³¨å†Œä¸­å¿ƒè´Ÿè½½å‡è¡¡ã€‚ if (REGISTRY_SERVICE_REFERENCE_PATH.equals(url.getServiceInterface())) &#123; // 1.1 å¦‚æœæ˜¯RegistryServiceæ¥å£çš„è¯ï¼Œç›´æ¥æ ¹æ®é…ç½®é¡¹ registry.weight è·å–æƒé‡å³å¯ï¼Œé»˜è®¤æ˜¯ 100 weight = url.getParameter(REGISTRY_KEY + \".\" + WEIGHT_KEY, DEFAULT_WEIGHT); // 2 éå¤šæ³¨å†Œä¸­å¿ƒåœºæ™¯ &#125; else &#123; // 2.1 ä» url ä¸­è·å– weight é…ç½®å€¼ï¼Œé»˜è®¤ä¸º 100 weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT); if (weight &gt; 0) &#123; // 2.2 è·å–æœåŠ¡æä¾›è€…çš„å¯åŠ¨æ—¶é—´æˆ³ long timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, 0L); if (timestamp &gt; 0L) &#123; // 2.3 è®¡ç®—Providerè¿è¡Œæ—¶é•¿ long uptime = System.currentTimeMillis() - timestamp; if (uptime &lt; 0) &#123; return 1; &#125; // 2.4 ä» url ä¸­è·å– Provider é¢„çƒ­æ—¶é—´é…ç½®å€¼ï¼Œé»˜è®¤ä¸º10åˆ†é’Ÿ int warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP); // 2.5 å¦‚æœProviderè¿è¡Œæ—¶é—´å°äºé¢„çƒ­æ—¶é—´ï¼Œåˆ™è¯¥ProviderèŠ‚ç‚¹å¯èƒ½è¿˜åœ¨é¢„çƒ­é˜¶æ®µï¼Œéœ€è¦é™ä½å…¶æƒé‡ if (uptime &gt; 0 &amp;&amp; uptime &lt; warmup) &#123; weight = calculateWarmupWeight((int) uptime, warmup, weight); &#125; &#125; &#125; &#125; // 3 é˜²å¾¡æ€§ç¼–ç¨‹ï¼Œæƒé‡ä¸èƒ½ä¸ºè´Ÿæ•° return Math.max(weight, 0); &#125; åœ¨è·å–æœåŠ¡æä¾›è€…æƒé‡æ—¶ï¼Œéœ€è¦è€ƒè™‘å½“å‰æœåŠ¡æä¾›è€…æ˜¯å¦è¿˜åœ¨é¢„çƒ­é˜¶æ®µï¼ˆè¿è¡Œæ—¶é—´å°äºé¢„çƒ­æ—¶é—´ï¼‰ï¼Œå¦‚æœè¿˜åœ¨é¢„çƒ­é˜¶æ®µéœ€è¦å¯¹å…¶è¿›è¡Œé™æƒå¤„ç†ï¼Œç›®çš„æ˜¯é¿å…æœåŠ¡æä¾›è€…ä¸€å¯åŠ¨å°±æœ‰å¤§é‡è¯·æ±‚æ¶Œæ¥ï¼Œå¤„äºé«˜è´Ÿè½½çŠ¶æ€ã€‚æœåŠ¡é¢„çƒ­æ˜¯ä¸€ä¸ªä¼˜åŒ–æ‰‹æ®µï¼Œä¸€èˆ¬åœ¨æœåŠ¡å¯åŠ¨åï¼Œè®©å…¶åœ¨å°æµé‡çŠ¶æ€ä¸‹è¿è¡Œä¸€æ®µæ—¶é—´ï¼Œç„¶åå†é€æ­¥æ”¾å¤§æµé‡ã€‚ æƒé‡è®¡ç®—æ˜¯åœ¨ calculateWarmupWeight æ–¹æ³•ä¸­ã€‚ 12345678910111213141516+--- AbstractLoadBalance /** * å¯¹è¿˜åœ¨é¢„çƒ­çŠ¶æ€çš„ Provider èŠ‚ç‚¹è¿›è¡Œé™æƒï¼Œé¿å… Provider ä¸€å¯åŠ¨å°±æœ‰å¤§é‡è¯·æ±‚æ¶Œè¿›æ¥ã€‚ * * @param uptime the uptime in milliseconds æœåŠ¡è¿è¡Œæ—¶é—´ * @param warmup the warmup time in milliseconds é¢„çƒ­æ—¶é—´ * @param weight the weight of an invoker é…ç½®çš„æœåŠ¡æƒé‡ * @return weight which takes warmup into account è®¡ç®—çš„æœåŠ¡æƒé‡ */ static int calculateWarmupWeight(int uptime, int warmup, int weight) &#123; // è®¡ç®—æƒé‡ï¼Œç®€åŒ–ä¸ºï¼š (uptime/warmup) * weightã€‚ // éšç€æœåŠ¡è¿è¡Œæ—¶é—´ uptime å¢å¤§ï¼Œæƒé‡è®¡ç®—å€¼ ww ä¼šæ…¢æ…¢æ¥è¿‘é…ç½®å€¼ weight int ww = (int) (uptime / ((float) warmup / weight)); // æƒé‡èŒƒå›´ä¸º [0,weight] ä¹‹é—´ return ww &lt; 1 ? 1 : (Math.min(ww, weight)); &#125; calculateWarmupWeight() æ–¹æ³•ç”¨äºè®¡ç®—è¿˜å¤„äºé¢„çƒ­çŠ¶æ€çš„ Provider èŠ‚ç‚¹çš„æƒé‡ï¼Œéšç€æœåŠ¡è¿è¡Œæ—¶é—´å¢å¤§ï¼Œæƒé‡è®¡ç®—å€¼ä¼šæ…¢æ…¢æ¥è¿‘é…ç½®çš„æƒé‡å€¼ã€‚ è´Ÿè½½å‡è¡¡çš„æŠ½è±¡å®ç°ä¸»è¦æ˜¯å¯¹æ¶ˆè´¹ç«¯ Invoker é›†åˆä¸ºç©ºæˆ–ä»…æœ‰ä¸€ä¸ªçš„æƒ…å†µä¸‹ç›´æ¥å¤„ç†ï¼Œæ— éœ€å­ç±»è¿›è¡Œé€‰æ‹©ã€‚æ­¤å¤–è¿˜å¯¹æ¶ˆè´¹ç«¯ Invoker æƒé‡çš„è·å–åšäº†ç»Ÿä¸€å®ç°ã€‚äº†è§£äº†è´Ÿè½½å‡è¡¡æŠ½è±¡å®ç°åï¼Œä¸‹é¢æˆ‘ä»¬å¯¹è´Ÿè½½å‡è¡¡çš„å…·ä½“å®ç°è¿›è¡Œåˆ†æã€‚ RandomLoadBalanceRandomLoadBalance æ˜¯åŠ æƒéšæœºç®—æ³•çš„å…·ä½“å®ç°ï¼Œå®ƒæ˜¯ä¸€ä¸ªç®€å•ã€é«˜æ•ˆçš„è´Ÿè½½å‡è¡¡å®ç°ï¼Œä¹Ÿæ˜¯ Dubbo é»˜è®¤ä½¿ç”¨çš„è´Ÿè½½å‡è¡¡ç­–ç•¥ã€‚å…¶æ ¸å¿ƒå°±æ˜¯åŠ æƒéšæœºç®—æ³•ï¼Œä¸‹é¢æˆ‘ä»¬ç®€å•å¯¹è¯¥ç®—æ³•è¿›è¡Œè¯´æ˜ã€‚ å‡è®¾æœ‰ 3 ä¸ªæœåŠ¡èŠ‚ç‚¹ï¼Œåˆ†åˆ«ä¸ºèŠ‚ç‚¹ Aã€èŠ‚ç‚¹ Bã€èŠ‚ç‚¹ Cï¼Œå®ƒä»¬å¯¹åº”çš„æƒé‡ä¾æ¬¡ä¸º 5ã€2ã€3ï¼Œæƒé‡æ€»å’Œä¸º 10ã€‚ç°åœ¨æŠŠè¿™äº›æƒé‡å€¼æ”¾åˆ°ä¸€ç»´åæ ‡ä¸Šï¼Œ[0,5)åŒºé—´å±äºèŠ‚ç‚¹Aï¼Œ[5,7)åŒºé—´å±äºèŠ‚ç‚¹Bï¼Œ[7,10)åŒºé—´å±äºèŠ‚ç‚¹Cï¼Œå…·ä½“åˆ†å¸ƒå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ¥ä¸‹æ¥é€šè¿‡éšæœºæ•°ç”Ÿæˆå™¨åœ¨ [0,10) è¿™ä¸ªèŒƒå›´å†…ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼Œç„¶åè®¡ç®—è¿™ä¸ªéšæœºæ•°ä¼šè½åˆ°å“ªä¸ªåŒºé—´ä¸Šã€‚æ¯”å¦‚ï¼Œéšæœºç”Ÿæˆæ•°å­— 3 ï¼Œå°±ä¼šè½åˆ° Provider A å¯¹åº”çš„åŒºé—´ä¸Šï¼Œæ­¤æ—¶ RandomLoadBalance å°±ä¼šè¿”å› Provider A è¿™ä¸ªèŠ‚ç‚¹ã€‚æƒé‡è¶Šå¤§çš„èŠ‚ç‚¹ï¼Œåœ¨åæ ‡è½´ä¸Šå¯¹åº”çš„åŒºé—´èŒƒå›´å°±è¶Šå¤§ï¼Œå› æ­¤éšæœºæ•°ç”Ÿæˆå™¨ç”Ÿæˆçš„æ•°å­—å°±ä¼šæœ‰æ›´å¤§çš„æ¦‚ç‡è½åˆ°æ­¤åŒºé—´å†…ã€‚åªè¦éšæœºæ•°ç”Ÿæˆå™¨äº§ç”Ÿçš„éšæœºæ•°åˆ†å¸ƒæ€§å¾ˆå¥½ï¼Œåœ¨ç»è¿‡å¤šæ¬¡é€‰æ‹©åï¼Œæ¯ä¸ªæœåŠ¡èŠ‚ç‚¹è¢«é€‰ä¸­çš„æ¬¡æ•°æ¯”ä¾‹æ¥è¿‘å…¶æƒé‡æ¯”ä¾‹ã€‚æ¯”å¦‚ï¼Œç»è¿‡ä¸€ä¸‡æ¬¡é€‰æ‹©åï¼ŒæœåŠ¡å™¨ A è¢«é€‰ä¸­çš„æ¬¡æ•°å¤§çº¦ä¸º 5000 æ¬¡ï¼ŒæœåŠ¡å™¨ B è¢«é€‰ä¸­çš„æ¬¡æ•°çº¦ä¸º 3000 æ¬¡ï¼ŒæœåŠ¡å™¨ C è¢«é€‰ä¸­çš„æ¬¡æ•°çº¦ä¸º 2000 æ¬¡ã€‚ äº†è§£äº†åŠ æƒéšæœºç®—æ³•åï¼Œæˆ‘ä»¬å¼€å§‹å¯¹ RandomLoadBalance æºç è¿›è¡Œåˆ†æã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class RandomLoadBalance extends AbstractLoadBalance &#123; /** * æ‰©å±•ç‚¹åç§° */ public static final String NAME = \"random\"; /** * Select one invoker between a list using a random criteria * * @param invokers List of possible invokers * @param url URL * @param invocation Invocation * @param &lt;T&gt; * @return The selected invoker */ @Override protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123; int length = invokers.size(); // æ¯ä¸ª Invoker æƒé‡æ˜¯å¦ç›¸åŒçš„æ ‡å¿— boolean sameWeight = true; // è®¡ç®—æ¯ä¸ª Invoker å¯¹è±¡å¯¹åº”çš„æƒé‡ï¼Œå¹¶å¡«å……åˆ° weights æ•°ç»„ä¸­ int[] weights = new int[length]; // è®¡ç®—ç¬¬ä¸€ä¸ª Invoker æƒé‡ int firstWeight = getWeight(invokers.get(0), invocation); weights[0] = firstWeight; // è®°å½•æƒé‡æ€»å’Œ int totalWeight = firstWeight; for (int i = 1; i &lt; length; i++) &#123; // è®¡ç®—ç¬¬ i ä¸ª Invoker çš„æƒé‡ int weight = getWeight(invokers.get(i), invocation); weights[i] = weight; // ç´¯åŠ æ€»æƒé‡ totalWeight += weight; // æ£€æµ‹æ˜¯å¦æœ‰ä¸åŒæƒé‡çš„ Invoker if (sameWeight &amp;&amp; weight != firstWeight) &#123; sameWeight = false; &#125; &#125; // æ€»æƒé‡ &gt; 0 &amp;&amp; å¹¶éæ‰€æœ‰ Invoker æƒé‡éƒ½ç›¸åŒ // è®¡ç®—éšæœºæ•°è½åœ¨å“ªä¸ªåŒºé—´ if (totalWeight &gt; 0 &amp;&amp; !sameWeight) &#123; // éšæœºè·å–ä¸€ä¸ª [0,totalWeight) åŒºé—´å†…çš„éšæœºæ•° int offset = ThreadLocalRandom.current().nextInt(totalWeight); // å¾ªç¯è®©éšæœºæ•°æ•°å‡å»Invokerçš„æƒé‡å€¼ï¼Œå½“éšæœºæ•°å°äº0æ—¶ï¼Œè¿”å›ç›¸åº”çš„Invoker for (int i = 0; i &lt; length; i++) &#123; offset -= weights[i]; if (offset &lt; 0) &#123; return invokers.get(i); &#125; &#125; &#125; // å¦‚æœæ‰€æœ‰çš„ Invoker æƒé‡ç›¸åŒ æˆ– æƒé‡æ€»æƒé‡ä¸º 0ï¼Œåˆ™å‡ç­‰éšæœº return invokers.get(ThreadLocalRandom.current().nextInt(length)); &#125;&#125; RandomLoadBalance ä¸­ doSelect() æ–¹æ³•çš„å®ç°ï¼Œä¸»è¦æœ‰ä»¥ä¸‹ 3 ä¸ªå…³é”®ç‚¹ï¼š é€šè¿‡ AbstractLoadBalance.getWeight æ–¹æ³•è®¡ç®—æ¯ä¸ª Invoker çš„æƒé‡å€¼ æ±‡æ€» Invoker çš„æ€»æƒé‡å€¼ å½“æ¯ä¸ª Invoker æƒé‡ä¸åŒæ—¶ï¼Œä½¿ç”¨åŠ æƒéšæœºç®—æ³•é€‰å‡ºå¯¹åº”çš„ Invoker å¯¹è±¡ã€‚ å½“æ‰€æœ‰ Invoker æƒé‡ç›¸åŒæ—¶ï¼Œéšæœºè¿”å›ä¸€ä¸ª Invoker å³å¯ã€‚ æ€»ä½“ä¸ŠåŠ æƒéšæœºè´Ÿè½½å‡è¡¡ç­–ç•¥è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼ŒåŒæ—¶å®ƒä¹Ÿæ˜¯å…¶å®ƒè´Ÿè½½å‡è¡¡ç®—æ³•çš„åŸºç¡€ï¼Œå¦‚æœ€å°æ´»è·ƒè°ƒç”¨æ•°è´Ÿè½½å‡è¡¡å’Œæœ€çŸ­å“åº”æ—¶é—´è´Ÿè½½å‡è¡¡åœ¨å…·æœ‰å¤šä¸ªç›¸åŒæ¡ä»¶çš„ Invoker æ—¶ï¼Œæœ€åä¼šé€šè¿‡è¯¥ç®—æ³•è¿›ä¸€æ­¥é€‰æ‹©ç›®æ ‡ Invoker ã€‚ RoundRobinLoadBalanceRoundRobinLoadBalance æ˜¯åŠ æƒè½®è¯¢ç®—æ³•çš„å…·ä½“å®ç°ã€‚è½®è¯¢æŒ‡çš„æ˜¯å°†è¯·æ±‚è½®æµåˆ†é…ç»™æ¯ä¸ªæœåŠ¡èŠ‚ç‚¹ï¼Œä¾‹å¦‚ï¼Œæœ‰ Aã€Bã€C ä¸‰ä¸ªæœåŠ¡èŠ‚ç‚¹ï¼ŒæŒ‰ç…§æ™®é€šè½®è¯¢çš„æ–¹å¼ï¼Œä¼šå°†ç¬¬ä¸€ä¸ªè¯·æ±‚åˆ†é…ç»™ A èŠ‚ç‚¹ï¼Œå°†ç¬¬äºŒä¸ªè¯·æ±‚åˆ†é…ç»™ B èŠ‚ç‚¹ï¼Œç¬¬ä¸‰ä¸ªè¯·æ±‚åˆ†é…ç»™ C èŠ‚ç‚¹ï¼Œç¬¬å››ä¸ªè¯·æ±‚åˆ†é…ç»™ A èŠ‚ç‚¹â€¦â€¦å¦‚æ­¤å¾ªç¯å¾€å¤ã€‚è½®è¯¢æ˜¯ä¸€ç§æ— çŠ¶æ€è´Ÿè½½å‡è¡¡ç®—æ³•ï¼Œå®ç°ç®€å•ï¼Œé€‚ç”¨äºæ¯å°æœåŠ¡å™¨æ€§èƒ½ç›¸è¿‘çš„åœºæ™¯ã€‚ä½†ç°å®æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¹¶ä¸èƒ½ä¿è¯æ¯å°æœåŠ¡å™¨æ€§èƒ½å‡ç›¸è¿‘ã€‚å¦‚æœæˆ‘ä»¬å°†ç­‰é‡çš„è¯·æ±‚åˆ†é…ç»™æ€§èƒ½è¾ƒå·®çš„æœåŠ¡å™¨ï¼Œè¿™æ˜¾ç„¶æ˜¯ä¸åˆç†çš„ã€‚å› æ­¤ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬éœ€è¦å¯¹è½®è¯¢è¿‡ç¨‹è¿›è¡ŒåŠ æƒï¼Œä»¥è°ƒæ§æ¯å°æœåŠ¡å™¨çš„è´Ÿè½½ã€‚ç»è¿‡åŠ æƒåï¼Œæ¯å°æœåŠ¡å™¨èƒ½å¤Ÿå¾—åˆ°çš„è¯·æ±‚æ•°æ¯”ä¾‹ï¼Œæ¥è¿‘æˆ–ç­‰äºä»–ä»¬çš„æƒé‡æ¯”ã€‚æ¯”å¦‚æœåŠ¡èŠ‚ç‚¹ Aã€Bã€C æƒé‡æ¯”ä¸º 5:2:1ã€‚é‚£ä¹ˆåœ¨8æ¬¡è¯·æ±‚ä¸­ï¼ŒæœåŠ¡å™¨ A å°†æ”¶åˆ°å…¶ä¸­çš„5æ¬¡è¯·æ±‚ï¼ŒæœåŠ¡å™¨ B ä¼šæ”¶åˆ°å…¶ä¸­çš„2æ¬¡è¯·æ±‚ï¼ŒæœåŠ¡å™¨ C åˆ™æ”¶åˆ°å…¶ä¸­çš„1æ¬¡è¯·æ±‚ã€‚ RoundRobinLoadBalance å‚è€ƒè‡ª Nginx çš„å¹³æ»‘åŠ æƒè½®è¯¢è´Ÿè½½å‡è¡¡ã€‚æ¯ä¸ªæœåŠ¡èŠ‚ç‚¹æœ‰ä¸¤ä¸ªæƒé‡ï¼Œåˆ†åˆ«ä¸º weight å’Œ current ï¼Œå…¶ä¸­ weight æ˜¯é€šè¿‡çˆ¶ç±»çš„ getWeight æ–¹æ³•è®¡ç®—å‡ºæ¥çš„å€¼ï¼Œè™½ç„¶åœ¨é¢„çƒ­è¿‡ç¨‹æ˜¯å˜åŒ–çš„ï¼Œä½†è¿™é‡Œå¯ä»¥è®¤ä¸ºæ˜¯å›ºå®šçš„ï¼›current æ˜¯åŠ¨æ€çš„ï¼Œåˆå§‹å€¼ä¸º 0 ï¼Œæ¯æ¬¡æœ‰æ–°çš„è¯·æ±‚è¿›æ¥æ—¶ï¼Œéå† Invoker åˆ—è¡¨ï¼Œå¹¶ç”¨å¯¹åº”çš„ current åŠ ä¸Š weight ã€‚éå†å®Œæˆåï¼Œæ‰¾åˆ°å…·æœ‰æœ€å¤§ current çš„ Invoker å’Œå¯¹åº”çš„ WeightedRoundRobin ã€‚åœ¨è¿”å›é€‰ä¸­çš„ Invoker ä¹‹å‰ï¼Œå°†å…¶å¯¹åº”çš„ WeightedRoundRobin ä¸­çš„å½“å‰æƒé‡å€¼ current å‡å»æœ¬æ¬¡è¯·æ±‚ç´¯åŠ çš„æ€»æƒé‡å€¼ï¼Œä»è€Œå®ç°å¹³æ»‘è´Ÿè½½å‡è¡¡ã€‚ åŠ æƒè½®è¯¢ç®—æ³•ä¸‹é¢ä¸¾ä¾‹å¯¹ RoundRobinLoadBalance çš„æ‰§è¡Œæµç¨‹è¿›è¡Œè¯´æ˜ã€‚å‡è®¾æœ‰ 3 ä¸ªæœåŠ¡èŠ‚ç‚¹ï¼Œåˆ†åˆ«ä¸ºèŠ‚ç‚¹ Aã€èŠ‚ç‚¹ Bã€èŠ‚ç‚¹ Cï¼Œå¯¹åº”çš„æƒé‡ä¾æ¬¡ä¸ºï¼š5ã€1ã€1 ï¼Œé€‰æ‹©è¿‡ç¨‹å¦‚ä¸‹ï¼š è¯·æ±‚ç¼–å· å½“å‰æƒé‡(current)æ•°ç»„ é€‰æ‹©ç»“æœ å‡å»æƒé‡æ€»å’Œåçš„å½“å‰æƒé‡(current)æ•°ç»„ 1 [5, 1, 1] A [-2, 1, 1] 2 [3, 2, 2] A [-4, 2, 2] 3 [1, 3, 3] B [1, -4, 3] 4 [6, -3, 4] A [-1, -3, 4] 5 [4, -2, 5] C [4, -2, -2] 6 [9, -1, -1] A [2, -1, -1] 7 [7, 0, 0] A [0, 0, 0] ä¸‹é¢å¯¹ä»¥ä¸Šæ¯æ¬¡è¯·æ±‚æ•°æ®å˜æ›´è¿›è¡Œè¯´æ˜ï¼Œè¯¥è¿‡ç¨‹å°±æ˜¯åŠ æƒè½®è¯¢ç®—æ³•çš„å®ç°ï¼š å¤„ç†ç¬¬ä¸€ä¸ªè¯·æ±‚ï¼Œæ¯ä¸ª Invoker ç›¸å…³çš„ currentWeigh ä¸é…ç½®çš„ weight ç›¸åŠ ï¼Œå³ä» [0, 0, 0] å˜ä¸º [5, 1, 1]ã€‚æ¥ä¸‹æ¥ï¼Œä»ä¸­é€‰æ‹©æƒé‡æœ€å¤§çš„ Invoker ä½œä¸ºç»“æœï¼Œå³èŠ‚ç‚¹ Aã€‚æœ€åï¼Œå°†èŠ‚ç‚¹ A çš„ currentWeight å€¼å‡å» totalWeight å€¼ï¼Œæœ€ç»ˆå¾—åˆ° currentWeight æ•°ç»„ä¸º [-2, 1, 1]ã€‚ å¤„ç†ç¬¬äºŒä¸ªè¯·æ±‚ï¼Œæ¯ä¸ª Invoker ç›¸å…³çš„ currentWeigh ä¸é…ç½®çš„ weight ç›¸åŠ ï¼Œå³ä» [-2, 1, 1] å˜ä¸º [3, 2, 2]ã€‚æ¥ä¸‹æ¥ï¼Œä»ä¸­é€‰æ‹©æƒé‡æœ€å¤§çš„ Invoker ä½œä¸ºç»“æœï¼Œå³èŠ‚ç‚¹ Aã€‚æœ€åï¼Œå°†èŠ‚ç‚¹ A çš„ currentWeight å€¼å‡å» totalWeight å€¼ï¼Œæœ€ç»ˆå¾—åˆ° currentWeight æ•°ç»„ä¸º [-4, 2, 2]ã€‚ å¤„ç†ç¬¬ä¸‰ä¸ªè¯·æ±‚ï¼Œæ¯ä¸ª Invoker ç›¸å…³çš„ currentWeigh ä¸é…ç½®çš„ weight ç›¸åŠ ï¼Œå³ä» [-4, 2, 2] å˜ä¸º [1, 3, 3]ã€‚æ¥ä¸‹æ¥ï¼Œä»ä¸­é€‰æ‹©æƒé‡æœ€å¤§çš„ Invoker ä½œä¸ºç»“æœï¼Œå³èŠ‚ç‚¹ Bã€‚æœ€åï¼Œå°†èŠ‚ç‚¹ B çš„ currentWeight å€¼å‡å» totalWeight å€¼ï¼Œæœ€ç»ˆå¾—åˆ° currentWeight æ•°ç»„ä¸º [1, -4, 3]ã€‚ å¤„ç†ç¬¬å››ä¸ªè¯·æ±‚ï¼Œæ¯ä¸ª Invoker ç›¸å…³çš„ currentWeigh ä¸é…ç½®çš„ weight ç›¸åŠ ï¼Œå³ä» [1, -4, 3] å˜ä¸º [6, -3, 4]ã€‚æ¥ä¸‹æ¥ï¼Œä»ä¸­é€‰æ‹©æƒé‡æœ€å¤§çš„ Invoker ä½œä¸ºç»“æœï¼Œå³èŠ‚ç‚¹ Aã€‚æœ€åï¼Œå°†èŠ‚ç‚¹ A çš„ currentWeight å€¼å‡å» totalWeight å€¼ï¼Œæœ€ç»ˆå¾—åˆ° currentWeight æ•°ç»„ä¸º [-1, -3, 4]ã€‚ å¤„ç†ç¬¬äº”ä¸ªè¯·æ±‚ï¼Œæ¯ä¸ª Invoker ç›¸å…³çš„ currentWeigh ä¸é…ç½®çš„ weight ç›¸åŠ ï¼Œå³ä» [-1, -3, 4] å˜ä¸º [4, -2, 5]ã€‚æ¥ä¸‹æ¥ï¼Œä»ä¸­é€‰æ‹©æƒé‡æœ€å¤§çš„ Invoker ä½œä¸ºç»“æœï¼Œå³èŠ‚ç‚¹ Cã€‚æœ€åï¼Œå°†èŠ‚ç‚¹ C çš„ currentWeight å€¼å‡å» totalWeight å€¼ï¼Œæœ€ç»ˆå¾—åˆ° currentWeight æ•°ç»„ä¸º [4, -2, -2]ã€‚ å¤„ç†ç¬¬å…­ä¸ªè¯·æ±‚ï¼Œæ¯ä¸ª Invoker ç›¸å…³çš„ currentWeigh ä¸é…ç½®çš„ weight ç›¸åŠ ï¼Œå³ä» [4, -2, -2] å˜ä¸º [9, -1, -1]ã€‚æ¥ä¸‹æ¥ï¼Œä»ä¸­é€‰æ‹©æƒé‡æœ€å¤§çš„ Invoker ä½œä¸ºç»“æœï¼Œå³èŠ‚ç‚¹ Aã€‚æœ€åï¼Œå°†èŠ‚ç‚¹ A çš„ currentWeight å€¼å‡å» totalWeight å€¼ï¼Œæœ€ç»ˆå¾—åˆ° currentWeight æ•°ç»„ä¸º [2, -1, -1]ã€‚ å¤„ç†ç¬¬ä¸ƒä¸ªè¯·æ±‚ï¼Œæ¯ä¸ª Invoker ç›¸å…³çš„ currentWeigh ä¸é…ç½®çš„ weight ç›¸åŠ ï¼Œå³ä» [2, -1, -1] å˜ä¸º [7, 0, 0]ã€‚æ¥ä¸‹æ¥ï¼Œä»ä¸­é€‰æ‹©æƒé‡æœ€å¤§çš„ Invoker ä½œä¸ºç»“æœï¼Œå³èŠ‚ç‚¹ Aã€‚æœ€åï¼Œå°†èŠ‚ç‚¹ A çš„ currentWeight å€¼å‡å» totalWeight å€¼ï¼Œæœ€ç»ˆå¾—åˆ° currentWeight æ•°ç»„ä¸º [0, 0, 0]ã€‚ ä»¥ä¸Šå°±æ˜¯ä¸€ä¸ªè½®è¯¢çš„å‘¨æœŸã€‚äº†è§£äº†åŠ æƒè½®è¯¢çš„è®¡ç®—è¿‡ç¨‹åï¼Œä¸‹é¢æˆ‘ä»¬å°±å¯¹ RoundRobinLoadBalance æºç å®ç°è¿›è¡Œåˆ†æã€‚ å±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263+--- RoundRobinLoadBalancepublic class RoundRobinLoadBalance extends AbstractLoadBalance &#123; /** * æ‰©å±•ç‚¹åç§° */ public static final String NAME = \"roundrobin\"; /** * é•¿æ—¶é—´æœªæ›´æ–°çš„é˜ˆå€¼ 60 s */ private static final int RECYCLE_PERIOD = 60000; /** * æ¯ä¸ª Invoker å¯¹åº”çš„å¯¹è±¡ï¼ŒåŠ æƒè½®æµè°ƒåº¦å™¨ */ protected static class WeightedRoundRobin &#123; /** * æœåŠ¡æä¾›è€…é…ç½®æƒé‡ï¼Œåœ¨è´Ÿè½½å‡è¡¡è¿‡ç¨‹ä¸ä¼šå˜åŒ–(å¿½ç•¥å¯åŠ¨é¢„çƒ­) */ private int weight; /** * æœåŠ¡æä¾›è€…å½“å‰æƒé‡ï¼Œåœ¨è´Ÿè½½å‡è¡¡è¿‡ç¨‹ä¼šåŠ¨æ€è°ƒæ•´ï¼Œåˆå§‹å€¼ä¸º 0 */ private AtomicLong current = new AtomicLong(0); /** * æœ€åæ›´æ–°æ—¶é—´ */ private long lastUpdate; public int getWeight() &#123; return weight; &#125; public void setWeight(int weight) &#123; this.weight = weight; current.set(0); &#125; // Invokerå½“å‰æƒé‡ + é…ç½®çš„æƒé‡ public long increaseCurrent() &#123; return current.addAndGet(weight); &#125; // Invokerå½“å‰æƒé‡ - æ€»æƒé‡ public void sel(int total) &#123; current.addAndGet(-1 * total); &#125; public long getLastUpdate() &#123; return lastUpdate; &#125; public void setLastUpdate(long lastUpdate) &#123; this.lastUpdate = lastUpdate; &#125; &#125; /** * æœåŠ¡æ–¹æ³•ä¸ WeightedRoundRobin çš„æ˜ å°„å…³ç³» * key1: æœåŠ¡é”® + æ–¹æ³•å -&gt; å®Œæ•´æ–¹æ³•å * key2: URLä¸² * value: WeightedRoundRobin */ private ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap = new ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();&#125; RoundRobinLoadBalance ä¸­æœ‰ 3 ä¸ªæ ¸å¿ƒå±æ€§ï¼Œä¸‹é¢æˆ‘ä»¬å¯¹å…¶è¿›è¡Œä»‹ç»ã€‚ RECYCLE_PERIOD ç”¨äºç›‘æ§ Invoker å¯¹åº”çš„ WeightedRoundRobin çš„æ›´æ–°é¢‘ç‡ã€‚ç”±äº Invoker å¯¹åº”çš„æœåŠ¡å¯èƒ½ä¼šå®•æœºï¼Œå¦‚æœå®•æœºå°±å¿…é¡»å°†å…¶å¯¹åº”çš„ WeightedRoundRobin ç¼“å­˜æ¸…é™¤ï¼ŒRECYCLE_PERIOD å±æ€§å°±æ˜¯ç”¨æ¥ç›‘æ§é•¿æ—¶é—´æœªæ›´æ–°çš„ WeightedRoundRobinã€‚ WeightedRoundRobin ä½œä¸º RoundRobinLoadBalance çš„å†…éƒ¨ç±»ï¼Œåœ¨ RoundRobinLoadBalance ä¸­ä¼šä¸ºæ¯ä¸ª Invoker å¯¹è±¡éƒ½åˆ›å»ºä¸€ä¸ªå¯¹åº”çš„ WeightedRoundRobin å¯¹è±¡ï¼Œç”¨æ¥è®°å½•é…ç½®çš„æƒé‡ï¼ˆweightå­—æ®µï¼‰ä»¥åŠéšæ¯æ¬¡è´Ÿè½½å‡è¡¡ç®—æ³•æ‰§è¡Œå˜åŒ–çš„å½“å‰æƒé‡ï¼ˆcurrentå­—æ®µï¼‰ã€‚ methodWeightMap12345678910111213# key1: å®Œæ•´æ–¹æ³•å# key2: URLä¸²# value: WeightedRoundRobin &#123; \"...UserService.query\":&#123; \"url1\": WeightedRoundRobin@123, \"url2\": WeightedRoundRobin@456 &#125;, \"...UserService.update\":&#123; \"url1\": WeightedRoundRobin@111, \"url2\": WeightedRoundRobin@222 &#125; &#125; ä¼šåŸºäºæ¯ä¸ªæ–¹æ³•åˆ›å»ºä¸€ä¸ª WeightedRoundRobin æ˜ å°„å…³ç³»ã€‚ é€‰æ‹©ç›®æ ‡ Invoker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172+--- RoundRobinLoadBalance @Override protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123; // 1 è·å–è¯·æ±‚çš„å®Œæ•´æ–¹æ³•å String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName(); // 2 è·å–æ•´ä¸ªInvokeråˆ—è¡¨å¯¹åº”çš„ WeightedRoundRobin æ˜ å°„è¡¨ï¼Œå¦‚æœä¸ºç©ºï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„WeightedRoundRobinæ˜ å°„è¡¨ ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.computeIfAbsent(key, k -&gt; new ConcurrentHashMap&lt;&gt;()); // æ€»æƒé‡ int totalWeight = 0; // è®°å½• Invoker åˆ—è¡¨ä¸­æœ€å¤§æƒé‡ long maxCurrent = Long.MIN_VALUE; // è·å–å½“å‰æ—¶é—´æˆ³ long now = System.currentTimeMillis(); // é€‰ä¸­çš„ Invoker Invoker&lt;T&gt; selectedInvoker = null; // é€‰ä¸­çš„ Invoker å¯¹åº”çš„ WeightedRoundRobin WeightedRoundRobin selectedWRR = null; // 3 éå† Invoker åˆ—è¡¨ï¼Œé€‰å‡ºå…·æœ‰æœ€å¤§ current çš„ Invoker for (Invoker&lt;T&gt; invoker : invokers) &#123; // è·å– Invoker å¯¹åº”çš„URLä¸² String identifyString = invoker.getUrl().toIdentityString(); // è·å–å½“å‰ Invoker æƒé‡ int weight = getWeight(invoker, invocation); // æ£€æµ‹å½“å‰ Invoker æ˜¯å¦æœ‰ç›¸åº”çš„ WeightedRoundRobin ï¼Œæ²¡æœ‰åˆ™åˆ›å»º WeightedRoundRobin weightedRoundRobin = map.computeIfAbsent(identifyString, k -&gt; &#123; WeightedRoundRobin wrr = new WeightedRoundRobin(); // è®¾ç½®æƒé‡å’Œåˆå§‹åŒ–å½“å‰æƒé‡å€¼ä¸º0 wrr.setWeight(weight); return wrr; &#125;); // æ£€æµ‹ Invoker æƒé‡æ˜¯å¦å‘ç”Ÿäº†å˜åŒ–ï¼Œè‹¥å˜åŒ–äº†åˆ™æ›´æ–°ç›¸åº” WeightedRoundRobin ä¸­çš„ weight å€¼ if (weight != weightedRoundRobin.getWeight()) &#123; //weight changed weightedRoundRobin.setWeight(weight); &#125; // 3.1 è®© current åŠ ä¸Šé…ç½®çš„ weight ğŸŒŸ long cur = weightedRoundRobin.increaseCurrent(); // 3.2 æ›´æ–° lastUpdate å­—æ®µ weightedRoundRobin.setLastUpdate(now); // 3.3 å¯»æ‰¾å…·æœ‰æœ€å¤§ current çš„ Invokerï¼Œä»¥åŠInvokerå¯¹åº”çš„ WeightedRoundRobin ï¼Œæš‚å­˜èµ·æ¥ç•™ä½œåç”¨ if (cur &gt; maxCurrent) &#123; maxCurrent = cur; selectedInvoker = invoker; selectedWRR = weightedRoundRobin; &#125; // 3.4 è®¡ç®—æƒé‡æ€»å’Œ totalWeight += weight; &#125; // 4 Invoker é›†åˆæ•°ä¸ç­‰äºç¼“å­˜æ•°ï¼Œè¯´æ˜å­˜åœ¨ Invoker æŒ‚äº†çš„å¯èƒ½ï¼Œæ­¤æ—¶åº”è¯¥æ¸…é™¤æ— æ•ˆç¼“å­˜ if (invokers.size() != map.size()) &#123; // æ¸…é™¤æ‰é•¿æ—¶é—´æœªè¢«æ›´æ–°çš„èŠ‚ç‚¹ map.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD); &#125; // 5 æ›´æ–°é€‰ä¸­çš„ Invoker å¯¹åº”çš„ WeightedRoundRobin ä¸­ç»´æŠ¤çš„ current çš„å€¼ï¼Œç„¶åè¿”å›é€‰ä¸­çš„ Invoker ğŸŒŸ if (selectedInvoker != null) &#123; // ç”¨ current å‡å» totalWeight selectedWRR.sel(totalWeight); // è¿”å›é€‰ä¸­çš„Invokerå¯¹è±¡ return selectedInvoker; &#125; // should not happen here return invokers.get(0); &#125; RoundRobinLoadBalance ä¸­çš„ doSelect å°±æ˜¯å¯¹ä¸Šé¢åŠ æƒè½®è¯¢è®¡ç®—è¿‡ç¨‹çš„å®ç°ï¼Œç†è§£äº†åŠ æƒè½®è¯¢ç®—æ³•å°±ç†è§£äº† RoundRobinLoadBalance è´Ÿè½½å‡è¡¡ç­–ç•¥ã€‚ LeastActiveLoadBalanceLeastActiveLoadBalance ä½¿ç”¨çš„æ˜¯ æœ€å°æ´»è·ƒæ•°è´Ÿè½½å‡è¡¡ç®—æ³•ã€‚æ´»è·ƒè°ƒç”¨æ•°è¶Šå°ï¼Œè¡¨æ˜è¯¥æœåŠ¡æä¾›è€…æ•ˆç‡è¶Šé«˜ï¼Œå•ä½æ—¶é—´å†…å¯å¤„ç†æ›´å¤šçš„è¯·æ±‚ï¼Œæ­¤æ—¶åº”ä¼˜å…ˆå°†è¯·æ±‚åˆ†é…ç»™è¯¥æœåŠ¡æä¾›è€…ã€‚åœ¨å…·ä½“å®ç°ä¸­ï¼Œæ¯ä¸ªæœåŠ¡æä¾›è€…éƒ½å¯¹åº”ä¸€ä¸ªæ´»è·ƒæ•° active ï¼Œåˆå§‹æƒ…å†µä¸‹æ‰€æœ‰æœåŠ¡æä¾›è€…æ´»è·ƒæ•°å‡ä¸º 0 ï¼Œæ¯æ”¶åˆ°ä¸€ä¸ªè¯·æ±‚ï¼Œæ´»è·ƒæ•°åŠ  1 ï¼Œå®Œæˆè¯·æ±‚ååˆ™å°†æ´»è·ƒæ•°å‡ 1 ã€‚åœ¨æœåŠ¡è¿è¡Œä¸€æ®µæ—¶é—´åï¼Œæ€§èƒ½å¥½çš„æœåŠ¡æä¾›è€…å¤„ç†è¯·æ±‚çš„é€Ÿåº¦æ›´å¿«ï¼Œå› æ­¤æ´»è·ƒæ•°ä¸‹é™çš„ä¹Ÿè¶Šå¿«ï¼Œæ­¤æ—¶è¿™æ ·çš„æœåŠ¡æä¾›è€…èƒ½å¤Ÿä¼˜å…ˆè·å–åˆ°æ–°çš„æœåŠ¡è¯·æ±‚ã€‚ä»¥ä¸Šå°±æ˜¯æœ€å°æ´»è·ƒæ•°è´Ÿè½½å‡è¡¡ç®—æ³•çš„åŸºæœ¬æ€æƒ³ã€‚ é™¤äº†æœ€å°æ´»è·ƒæ•°ï¼ŒLeastActiveLoadBalance åœ¨å®ç°ä¸Šè¿˜å¼•å…¥äº†æƒé‡ï¼Œæ‰€ä»¥å‡†ç¡®åœ°è¯´è¯¥è´Ÿè½½å‡è¡¡ç­–ç•¥æ˜¯åŸºäºåŠ æƒæœ€å°æ´»è·ƒæ•°ç®—æ³•å®ç°çš„ã€‚LeastActiveLoadBalance éœ€è¦é…åˆ ActiveLimitFilterä½¿ç”¨ï¼ŒActiveLimitFilter æ˜¯ Dubbo åœ¨æ¶ˆè´¹ç«¯çš„é™æµå®ç°ï¼Œä¼šè®°å½•æ¶ˆè´¹è€…å¯¹ä¸€ä¸ªæœåŠ¡ç«¯æ–¹æ³•çš„å¹¶å‘è°ƒç”¨é‡ï¼Œåœ¨è¿›è¡Œè´Ÿè½½å‡è¡¡æ—¶ï¼Œåªä¼šä»æ´»è·ƒè°ƒç”¨æ•°æœ€å°çš„ Invoker é›†åˆä¸­æŒ‘é€‰ Invoker ï¼Œå½“æœ‰å¤šä¸ªæœ€å°æ´»è·ƒè°ƒç”¨æ•°çš„Invokeræ—¶ï¼Œä¼šåœ¨æœ€å°æ´»è·ƒè°ƒç”¨æ•°åŸºç¡€å¢åŠ åŠ æƒéšæœºç­–ç•¥ã€‚ä¸‹é¢æˆ‘ä»¬å¯¹æºç è¿›è¡Œåˆ†æã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class LeastActiveLoadBalance extends AbstractLoadBalance &#123; /** * æ‰©å±•ç‚¹å */ public static final String NAME = \"leastactive\"; @Override protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123; // ---------------------- 1 ğŸŒŸ å…³é”®å±æ€§ ------------------------------/ // Invoker æ•°é‡ int length = invokers.size(); // è®°å½•æœ€å°çš„æ´»è·ƒè°ƒç”¨æ•° int leastActive = -1; // è®°å½•å…·æœ‰ç›¸åŒæœ€å°æ´»è·ƒè°ƒç”¨æ•°ï¼ˆleastActive çš„å€¼ï¼‰çš„ Invoker æ•°é‡ int leastCount = 0; // è®°å½•å…·æœ‰ç›¸åŒæœ€å°æ´»è·ƒè°ƒç”¨æ•°ï¼ˆleastActive çš„å€¼ï¼‰çš„ Invoker åœ¨ Invoker åˆ—è¡¨ä¸­çš„ä¸‹æ ‡ä½ç½®ã€‚ // leastIndexes æ•°ç»„ä¸­å¦‚æœæœ‰å¤šä¸ªå€¼ï¼Œåˆ™è¯´æ˜æœ‰ä¸¤ä¸ªåŠä»¥ä¸Šçš„ Invoker å…·æœ‰ç›¸åŒçš„æœ€å°æ´»è·ƒæ•°ï¼ˆleastActive çš„å€¼ï¼‰ int[] leastIndexes = new int[length]; // è®°å½•æ¯ä¸ª Invoker çš„æƒé‡å€¼ int[] weights = new int[length]; // è®°å½•æœ€å°æ´»è·ƒè°ƒç”¨æ•°æ‰€æœ‰ Invoker çš„æƒé‡å€¼ä¹‹å’Œ int totalWeight = 0; // è®°å½•æœ€å°æ´»è·ƒè¯·æ±‚æ•° Invoker é›†åˆä¸­ç¬¬ä¸€ä¸ª Invoker çš„æƒé‡å€¼ int firstWeight = 0; // æ ‡è®°æ˜¯å¦å…·æœ‰ç›¸åŒæƒé‡çš„æœ€å°æ´»è·ƒæ•° Invoker boolean sameWeight = true; // ---------------------- 2 ğŸŒŸ æ“ä½œå…³é”®å±æ€§ ------------------------------/ // éå†æ‰€æœ‰Invokerï¼Œé€‰å‡ºæœ€å°æ´»è·ƒè°ƒç”¨æ•°çš„Invokeré›†åˆ for (int i = 0; i &lt; length; i++) &#123; Invoker&lt;T&gt; invoker = invokers.get(i); // è·å–è¯¥ Invoker çš„æ´»è·ƒè°ƒç”¨æ•° ï¼ˆä½¿ç”¨åˆ°äº†æ¶ˆè´¹æ–¹é™æµç­–ç•¥ï¼šActiveLimitFilterï¼‰ int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // è®°å½•è¯¥ Invoker çš„æƒé‡ int afterWarmup = getWeight(invoker, invocation); weights[i] = afterWarmup; // æ¯”è¾ƒæ´»è·ƒè°ƒç”¨æ•°ï¼Œå‘ç°æ›´å°çš„æ´»è·ƒè°ƒç”¨æ•°åˆ™æ›´æ–°ç›¸å…³å±æ€§ã€‚è¿™æ ·æƒ…å†µåªæœ‰ä¸€ä¸ª Invoker // è¿™ä¸ªæ˜¯å¿…é¡»è¦çš„ï¼Œå› ä¸ºè¦çš„å°±æ˜¯æœ€å°æ´»è·ƒè°ƒç”¨æ•°ï¼Œå…·æœ‰ç›¸åŒçš„æœ€å°æ´»è·ƒè°ƒç”¨æ•°åªæ˜¯ä¸€ç§å¤æ‚æƒ…å†µï¼Œéœ€è¦æ ¹æ®æƒé‡å†å¤„ç† if (leastActive == -1 || active &lt; leastActive) &#123; // é‡æ–°è®°å½•æœ€å°çš„æ´»è·ƒè°ƒç”¨æ•° leastActive = active; // é‡æ–°è®°å½•æœ€å°æ´»è·ƒè°ƒç”¨æ•°çš„ Invoker ä¸ªæ•° leastCount = 1; // é‡æ–°è®°å½•æœ€å°æ´»è·ƒè°ƒç”¨æ•°çš„ Invoker åœ¨ Invoker åˆ—è¡¨ä¸­çš„ä¸‹æ ‡ leastIndexes[0] = i; // é‡ç½®æ€»æƒé‡ totalWeight = afterWarmup; // è®°å½•ç¬¬ä¸€ä¸ªæœ€å°æ´»è·ƒè°ƒç”¨æ•° Invoker çš„æƒé‡ firstWeight = afterWarmup; // Each invoke has the same weight (only one invoker here) // é‡ç½®æƒé‡ç›¸åŒæ ‡è¯† sameWeight = true; // å¦‚æœå½“å‰ Invoker çš„æ´»è·ƒè°ƒç”¨æ•°ç­‰äºæœ€å°æ´»è·ƒè°ƒç”¨æ•°ï¼Œè¿™æ ·æƒ…å†µä¸‹å·²ç»å­˜åœ¨æœ€å°æ´»è·ƒè°ƒç”¨æ•°çš„ Invoker &#125; else if (active == leastActive) &#123; // è®°å½•å½“å‰ Invoker åœ¨ Invoker åˆ—è¡¨ä¸­çš„ä¸‹æ ‡ leastIndexes[leastCount++] = i; // ç´¯åŠ æ€»æƒé‡ï¼Œé’ˆå¯¹çš„æ˜¯å…·æœ‰ç›¸åŒçš„æœ€å°æ´»è·ƒæ•° totalWeight += afterWarmup; // åˆ¤æ–­æ˜¯å¦å­˜åœ¨ç›¸åŒæƒé‡çš„æœ€å°æ´»è·ƒè°ƒç”¨æ•°çš„ Invoker // å³æ£€æµ‹å½“å‰ Invoker çš„æƒé‡ä¸firstWeightæ˜¯å¦ç›¸ç­‰ï¼Œä¸ç›¸ç­‰åˆ™å°† sameWeight è®¾ç½®ä¸º false if (sameWeight &amp;&amp; afterWarmup != firstWeight) &#123; sameWeight = false; &#125; &#125; &#125; // ---------------------- 3 ğŸŒŸ é€‰æ‹© Invoker ------------------------------/ // 3.1 å¦‚æœåªæœ‰ä¸€ä¸ªæœ€å°æ´»è·ƒè°ƒç”¨æ•°çš„ Invoker ï¼Œç›´æ¥å–å‡ºå³å¯ if (leastCount == 1) &#123; // ä» Invoker åˆ—è¡¨ä¸­å–å‡ºæœ€å°æ´»è·ƒæ•°çš„ Invoker return invokers.get(leastIndexes[0]); &#125; // 3.2 å­˜åœ¨å¤šä¸ªå…·æœ‰æœ€å°æ´»è·ƒæ•°çš„ Invoker ï¼Œä½†å®ƒä»¬çš„æƒé‡ä¸ç›¸åŒä¸”æ€»æƒé‡ &gt; 0 ï¼Œåˆ™ä½¿ç”¨åŠ æƒéšæœºç®—æ³•ã€‚ if (!sameWeight &amp;&amp; totalWeight &gt; 0) &#123; // If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on // totalWeight. int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight); // Return a invoker based on the random value. for (int i = 0; i &lt; leastCount; i++) &#123; int leastIndex = leastIndexes[i]; offsetWeight -= weights[leastIndex]; if (offsetWeight &lt; 0) &#123; return invokers.get(leastIndex); &#125; &#125; &#125; // 3.3 å­˜åœ¨å¤šä¸ª Invoker å…·æœ‰ç›¸åŒçš„æœ€å°æ´»è·ƒæ•°ï¼Œä½†å®ƒä»¬çš„æƒé‡ç›¸ç­‰æˆ–æ€»æƒé‡ä¸º0ï¼Œåˆ™ä½¿ç”¨éšæœºå‡ç­‰ return invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]); &#125;&#125; LeastActiveLoadBalance æ ¸å¿ƒæ€æƒ³æ˜¯é€‰æ‹©æœ€å°æ´»è·ƒè°ƒç”¨æ•°çš„æœåŠ¡æä¾›è€…ï¼Œå¦‚æœæœ€å°æ´»è·ƒè°ƒç”¨æ•°çš„æœåŠ¡æä¾›è€…æœ‰å¤šä¸ªï¼Œåˆ™ä½¿ç”¨åŠ æƒéšæœºç®—æ³•è¿›è¡Œé€‰æ‹©ã€‚æ ¸å¿ƒæ€æƒ³ç†è§£èµ·æ¥å¾ˆå®¹æ˜“ï¼Œä½†æ˜¯å®ç°ä¸Šæ˜¾å¾—æœ‰ç‚¹å¤æ‚ï¼Œä½“ç°åœ¨å®šä¹‰äº†å¾ˆå¤šçš„å±æ€§ä¸Šï¼Œä¸‹é¢å¯¹æ•´ä¸ªé€»è¾‘è¿›è¡Œç®€å•æ¢³ç†ã€‚ éå† Invoker åˆ—è¡¨ï¼Œå¯»æ‰¾æ´»è·ƒè°ƒç”¨æ•°æœ€å°çš„ Invokerï¼Œ å¦‚æœå­˜åœ¨å¤šä¸ª Invoker å…·æœ‰ç›¸åŒçš„æœ€å°æ´»è·ƒè°ƒç”¨æ•°ï¼Œæ­¤æ—¶éœ€è¦è®°å½•ä¸‹è¿™äº› Invoker åœ¨ Invoker é›†åˆä¸­çš„ä¸‹æ ‡ï¼Œå¹¶ç´¯åŠ å®ƒä»¬çš„æƒé‡ï¼Œä¸”æ¯”è¾ƒå®ƒä»¬çš„æƒé‡å€¼æ˜¯å¦ç›¸ç­‰ã€‚ å¦‚æœåªæœ‰ä¸€ä¸ª Invoker å…·æœ‰æœ€å°æ´»è·ƒæ•°ï¼Œæ­¤æ—¶ç›´æ¥è¿”å›è¯¥ Invoker å³å¯ã€‚ å¦‚æœå­˜åœ¨å¤šä¸ª Invoker å…·æœ‰æœ€å°æ´»è·ƒæ•°ï¼Œä¸”å®ƒä»¬çš„æƒé‡ä¸ç›¸ç­‰ï¼Œæ­¤æ—¶å¤„ç†æ–¹å¼å’ŒåŠ æƒéšæœº RandomLoadBalance ä¸€è‡´ã€‚ å¦‚æœå­˜åœ¨å¤šä¸ª Invoker å…·æœ‰æœ€å°æ´»è·ƒæ•°ï¼Œä½†å®ƒä»¬çš„æƒé‡éƒ½ç›¸ç­‰ï¼Œæ­¤æ—¶éšæœºè¿”å›ä¸€ä¸ªå³å¯ã€‚ ConsistentHashLoadBalanceConsistentHashLoadBalance è´Ÿè½½å‡è¡¡ç­–ç•¥ä½¿ç”¨çš„æ˜¯ ä¸€è‡´æ€§ Hash æ¥å®ç°çš„ã€‚åœ¨åˆ†æå…·ä½“æºç ä¹‹å‰ï¼Œæˆ‘ä»¬ç°å¯¹ç›¸å…³æ¦‚å¿µè¿›è¡Œä»‹ç»ã€‚ ä¸€è‡´æ€§ Hash ç®—æ³•æå‡ºä¹‹åˆæ˜¯ç”¨äºå¤§è§„æ¨¡ç¼“å­˜ç³»ç»Ÿçš„è´Ÿè½½å‡è¡¡ï¼Œå®ƒçš„å·¥ä½œè¿‡ç¨‹æ˜¯è¿™æ ·çš„ï¼Œé¦–å…ˆæ ¹æ®ç¼“å­˜èŠ‚ç‚¹åœ°å€æˆ–å…¶å®ƒä¿¡æ¯ä¸ºç¼“å­˜èŠ‚ç‚¹ç”Ÿæˆä¸€ä¸ª hash å€¼ï¼Œå¹¶å°†è¿™ä¸ª hash å€¼æŠ•å°„åˆ° [0, 2^32 - 1] çš„åœ†ç¯ä¸Šï¼ˆHashç¯ï¼‰ï¼Œä¹Ÿå°±æ˜¯å¯¹ 2^32 å–æ¨¡ ã€‚å½“æœ‰è¯»å†™è¯·æ±‚æ—¶ï¼Œåˆ™ä¸ºç¼“å­˜é¡¹ key ç”Ÿæˆä¸€ä¸ª hash å€¼ï¼Œç„¶ååˆ° Hash ç¯ä¸ŠæŸ¥æ‰¾ç¬¬ä¸€ä¸ªå¤§äºæˆ–ç­‰äºè¯¥ hash å€¼çš„ç¼“å­˜èŠ‚ç‚¹ï¼Œæœ€åå°±å¯ä»¥åœ¨æ‰¾åˆ°çš„ç¼“å­˜èŠ‚ç‚¹ä¸Šè¿›è¡Œè¯»å†™æ“ä½œäº†ã€‚å¦‚æœå½“å‰ç¼“å­˜èŠ‚ç‚¹æŒ‚äº†ï¼Œåˆ™åœ¨ä¸‹ä¸€æ¬¡è¯»å†™è¯·æ±‚æ—¶æŸ¥æ‰¾å…¶å®ƒå¤§äºæˆ–ç­‰äºæœ¬æ¬¡è¯·æ±‚çš„ hash å€¼çš„ç¼“å­˜èŠ‚ç‚¹å³å¯ã€‚å¤§è‡´çš„ Hash ç¯å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæ¯ä¸ªç¼“å­˜èŠ‚ç‚¹åœ¨åœ†ç¯ä¸Šæ˜ å°„ä¸€ä¸ªä½ç½®ã€‚å¦‚æœç¼“å­˜é¡¹ key çš„ hash å°äºæˆ–ç­‰äºç¼“å­˜èŠ‚ç‚¹å¯¹åº”çš„ hash å€¼ï¼Œåˆ™åˆ°è¯¥ç¼“å­˜èŠ‚ç‚¹ä¸­è¿›è¡Œè¯»å†™æ“ä½œã€‚å¦‚ä¸‹é¢ç»¿è‰²ç‚¹å¯¹åº”çš„ç¼“å­˜é¡¹å°†ä¼šè¢«å­˜å‚¨åˆ° cahce-2 èŠ‚ç‚¹ä¸­ã€‚ç”±äº cache-3 æŒ‚äº†ï¼ŒåŸæœ¬åº”è¯¥å­˜åˆ°è¯¥èŠ‚ç‚¹ä¸­çš„ç¼“å­˜é¡¹æœ€ç»ˆä¼šå­˜å‚¨åˆ° cache-4 èŠ‚ç‚¹ä¸Šã€‚ ä¸€è‡´æ€§ Hash åœ¨ Dubbo ä¸­çš„åº”ç”¨å°±æ˜¯å°†ç¼“å­˜èŠ‚ç‚¹æ›¿æ¢æˆ Dubbo çš„æœåŠ¡æä¾›è€…èŠ‚ç‚¹ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œä¸€è‡´æ€§ Hash ç®—æ³•ä¼šå°† Dubbo çš„æœåŠ¡æä¾›è€…èŠ‚ç‚¹å‡åŒ€åœ°åˆ†å¸ƒåˆ° Hash ç¯ä¸Šï¼Œè¯·æ±‚ä¹Ÿå¯ä»¥å‡åŒ€åœ°åˆ†å‘ç»™ Dubbo çš„æœåŠ¡æä¾›è€…èŠ‚ç‚¹ã€‚ä½†åœ¨å®é™…æƒ…å†µä¸­ï¼Œæä¾›è€…èŠ‚ç‚¹åœ°å€å–æ¨¡åçš„å€¼å¯èƒ½åœ¨ Hash ç¯ä¸Šåˆ†å¸ƒä¸å‡åŒ€ï¼Œå¦‚ä¸‹å›¾ï¼š ç”±äº Invoker-1 å’Œ Invoker-2 åœ¨åœ†ç¯ä¸Šåˆ†å¸ƒä¸å‡åŒ€ï¼Œå¯¼è‡´ç³»ç»Ÿä¸­å¤§éƒ¨åˆ†è¯·æ±‚éƒ½ä¼šè½åˆ° Invoker-1 ä¸Šï¼Œåªæœ‰å°‘éƒ¨åˆ†è¯·æ±‚ä¼šè½åˆ° Invoker-2 ä¸Šï¼Œè¿™å°±å‡ºç°äº†æ•°æ®å€¾æ–œçš„é—®é¢˜ã€‚æ‰€è°“æ•°æ®å€¾æ–œæ˜¯æŒ‡ç”±äºèŠ‚ç‚¹ä¸å¤Ÿåˆ†æ•£ï¼Œå¯¼è‡´å¤§é‡è¯·æ±‚è½åˆ°äº†åŒä¸€ä¸ªèŠ‚ç‚¹ä¸Šï¼Œè€Œå…¶ä»–èŠ‚ç‚¹åªä¼šæ¥æ”¶åˆ°å°‘é‡è¯·æ±‚çš„æƒ…å†µã€‚ä¸ºäº†è§£å†³ä¸€è‡´æ€§ Hash ç®—æ³•ä¸­å‡ºç°çš„æ•°æ®å€¾æ–œé—®é¢˜ï¼Œå¼•å…¥äº†è™šæ‹ŸèŠ‚ç‚¹çš„æ¦‚å¿µã€‚è§£å†³æ€è·¯æ˜¯ï¼šæ—¢ç„¶ Dubbo æœåŠ¡æä¾›è€…èŠ‚ç‚¹åœ¨ Hash ç¯ä¸Šåˆ†å¸ƒä¸å‡åŒ€ï¼Œé‚£ä¹ˆå¯ä»¥è™šæ‹Ÿå‡º N ç»„ Invoker-1ï¼ŒInvoker-2ï¼Œâ€¦ï¼ŒInvoker-N çš„æä¾›è€…èŠ‚ç‚¹ï¼Œè®©å¤šç»„æä¾›è€…èŠ‚ç‚¹ç›¸å¯¹å‡åŒ€åˆ†å¸ƒåœ¨ Hash ç¯ä¸Šã€‚å¦‚ä¸‹å›¾ï¼š ä¸Šå›¾ä¸­ç›¸åŒé¢œè‰²çš„èŠ‚ç‚¹å±äºåŒä¸€ä¸ªæœåŠ¡æä¾›è€…ï¼Œå¦‚ Invoker1-1ã€Invoker1-2ã€â€¦.ã€Invoker1-160 è¡¨ç¤ºçš„éƒ½æ˜¯ Invoker1 è¿™ä¸ªæœåŠ¡èŠ‚ç‚¹ï¼Œè¿™æ ·åšçš„ç›®çš„æ˜¯é€šè¿‡å¼•å…¥è™šæ‹ŸèŠ‚ç‚¹ï¼Œè®© Invoker åœ¨åœ†ç¯ä¸Šåˆ†æ•£å¼€æ¥ï¼Œé¿å…æ•°æ®å€¾æ–œé—®é¢˜ã€‚ä¸Šå›¾ä¸­æœ‰ä¸‰ä¸ªç»„ã€‚ å±æ€§123456789101112131415161718192021222324public class ConsistentHashLoadBalance extends AbstractLoadBalance &#123; /** * æ‰©å±•å */ public static final String NAME = \"consistenthash\"; /** * è™šæ‹ŸèŠ‚ç‚¹æ•°é…ç½®é¡¹ï¼Œé»˜è®¤å€¼ä¸º 160 * æ ¼å¼ï¼š&lt;dubbo:parameter key=\"hash.nodes\" value=\"320\" /&gt; */ public static final String HASH_NODES = \"hash.nodes\"; /** * å‚ä¸Hashè®¡ç®—çš„å‚æ•°ç´¢å¼•ï¼Œé»˜è®¤åªå¯¹ç¬¬ä¸€ä¸ªå‚æ•°Hash * æ ¼å¼ï¼š&lt;dubbo:parameter key=\"hash.arguments\" value=\"0,1\" /&gt; */ public static final String HASH_ARGUMENTS = \"hash.arguments\"; /** * key: ServiceKey.methodName -&gt; å®Œæ•´æ–¹æ³•å * value: ConsistentHashSelector */ private final ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = new ConcurrentHashMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt;();&#125; HASH_NODES å’Œ HASH_ARGUMENTS å±æ€§åˆ†åˆ«æ˜¯æ¯ä¸ªæœåŠ¡èŠ‚ç‚¹å¯¹åº”çš„è™šæ‹ŸèŠ‚ç‚¹æ•°å’Œå‚ä¸Hashè®¡ç®—çš„è¯·æ±‚å‚æ•°çš„ç´¢å¼•ï¼Œselectors å±æ€§ç”¨äºå­˜å‚¨ è¯·æ±‚è°ƒç”¨&quot;å®Œæ•´æ–¹æ³•å&quot;åˆ°ä¸€è‡´æ€§Hashé€‰æ‹©å™¨ çš„æ˜ å°„å…³ç³»ã€‚ é€‰æ‹© Invoker1234567891011121314151617181920212223+--- ConsistentHashLoadBalance @Override protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123; // 1 è·å–è°ƒç”¨çš„æ–¹æ³•åç§° String methodName = RpcUtils.getMethodName(invocation); // 2 å°† ServiceKey å’Œ æ–¹æ³•å æ‹¼æ¥èµ·æ¥æ„æˆä¸€ä¸ª keyï¼Œå³å®Œæ•´æ–¹æ³•å String key = invokers.get(0).getUrl().getServiceKey() + \".\" + methodName; // 3 è·å– Invoker åˆ—è¡¨çš„ hashcodeï¼ˆä¸ºäº†åœ¨ Invokers åˆ—è¡¨å‘ç”Ÿå˜åŒ–æ—¶é‡æ–°ç”Ÿæˆ ConsistentHashSelector å¯¹è±¡ï¼‰ int invokersHashCode = invokers.hashCode(); ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key); // 4 å¦‚æœ invokers æ˜¯ä¸€ä¸ªæ–°çš„ List å¯¹è±¡ï¼Œè¯´æ˜æœåŠ¡æä¾›è€…æ•°é‡å‘ç”Ÿäº†å˜åŒ–ï¼Œå¯èƒ½æ–°å¢ä¹Ÿå¯èƒ½å‡å°‘äº† // æ­¤æ—¶ selector.identityHashCode != invokersHashCode æˆç«‹ if (selector == null || selector.identityHashCode != invokersHashCode) &#123; // åˆ›å»º ConsistentHashSelector å¯¹è±¡ selectors.put(key, new ConsistentHashSelector&lt;T&gt;(invokers, methodName, invokersHashCode)); selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key); &#125; // 5 é€šè¿‡ ConsistentHashSelector å¯¹è±¡é€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ return selector.select(invocation); &#125; ConsistentHashLoadBalance çš„ doSelect æ–¹æ³•å¹¶æ²¡æœ‰çœŸæ­£é€‰æ‹©ç›®æ ‡ Invoker å¯¹è±¡ï¼Œè€Œæ˜¯åšäº†ä¸€äº›å‰ç½®å·¥ä½œï¼Œä¸»è¦æ˜¯æ£€æµ‹ Invoker åˆ—è¡¨æ˜¯å¦å˜æ›´äº†ï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦åˆ›å»ºè¯·æ±‚æ–¹æ³•å¯¹åº”çš„ä¸€è‡´æ€§ Hash é€‰æ‹©å™¨å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯æ˜¯å¦éœ€è¦é‡æ–°æ„å»º Hash ç¯ã€‚è¿™ä¸ªå‡†å¤‡å·¥ä½œå®Œæˆåï¼ŒHash ç¯ä¹Ÿå°±æ„å»ºå®Œæ¯•äº†ï¼Œæ¥ä¸‹æ¥å°†é€‰æ‹© Invoker çš„é€»è¾‘äº¤ç»™ä¸€è‡´æ€§é€‰æ‹©æ€§å™¨ ConsistentHashSelector å¯¹è±¡ã€‚ä¸‹é¢æˆ‘ä»¬å°±æ¥åˆ†æä¸€è‡´æ€§ Hash é€‰æ‹©å™¨ã€‚ ConsistentHashSelectorConsistentHashLoadBalance å®ç°è´Ÿè½½å‡è¡¡éƒ½æ˜¯å§”æ‰˜ç»™ä¸€è‡´æ€§ Hash é€‰æ‹©å™¨ ConsistentHashSelector å®Œæˆçš„ï¼Œä¸‹é¢æˆ‘ä»¬å¯¹è¯¥å†…éƒ¨ç±»è¿›è¡Œä»‹ç»ã€‚ æ ¸å¿ƒå±æ€§12345678910111213141516171819202122+--- ConsistentHashLoadBalance private static final class ConsistentHashSelector&lt;T&gt; &#123; /** * ä½¿ç”¨ TreeMap å­˜å‚¨ Invoker è™šæ‹ŸèŠ‚ç‚¹ï¼ŒTreeMap æ˜¯æŒ‰ç…§Keyæ’åºçš„ * key: Hash å€¼ */ private final TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers; /** * Invoker è™šæ‹ŸèŠ‚ç‚¹ä¸ªæ•° */ private final int replicaNumber; /** * Invoker é›†åˆçš„ HashCode å€¼ */ private final int identityHashCode; /** * éœ€è¦å‚ä¸ Hash è®¡ç®—çš„å‚æ•°ç´¢å¼•ã€‚ * å¦‚ï¼šargumentIndex = [0,1,2] æ—¶ï¼Œè¡¨ç¤ºè°ƒç”¨çš„ç›®æ ‡æ–¹æ³•çš„å‰ä¸‰ä¸ªå‚æ•°è¦å‚ä¸ Hash è®¡ç®—ã€‚ */ private final int[] argumentIndex; &#125; ä¸‹é¢å¯¹æ ¸å¿ƒå±æ€§è¿›è¡Œä»‹ç»ï¼š éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œé’ˆå¯¹æ¯ä¸€ä¸ªè¯·æ±‚çš„æœåŠ¡æ–¹æ³•éƒ½ä¼šåˆ›å»ºä¸€ä¸ª ConsistentHashLoadBalance ã€‚ virtualInvokers ç”¨äºç¼“å­˜ Invoker çš„è™šæ‹ŸèŠ‚ç‚¹ï¼Œå³å¤šä¸ª hash å€¼æ˜ å°„åˆ°åŒä¸€ä¸ª Invoker ã€‚ replicaNumber ç”¨äºè®°å½•æ¯ä¸ª Invoker è™šæ‹ŸèŠ‚ç‚¹çš„ä¸ªæ•°ã€‚ identityHashCode ç”¨äºè®°å½•è¯·æ±‚æ¶‰åŠçš„ Invoker é›†åˆçš„ HashCode å€¼ã€‚ argumentIndex ç”¨äºå­˜å‚¨å‚ä¸ Hash è®¡ç®—çš„å‚æ•°ç´¢å¼•ï¼Œç”¨äºè¯·æ±‚è´Ÿè½½å‡è¡¡æ—¶å¯¹è¯·æ±‚å‚æ•°è¿›è¡ŒåŒ¹é…ï¼Œç¡®å®šå“ªäº›å‚æ•°å‚ä¸ Hash è®¡ç®—ã€‚ æ„é€ æ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * * @param invokers æ¶ˆè´¹ç«¯ Invoker åˆ—è¡¨ * @param methodName æ–¹æ³•å * @param identityHashCode Invoker åˆ—è¡¨çš„ hashCode çš„å€¼ */ ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) &#123; // 1 åˆå§‹åŒ– virtualInvokers å­—æ®µï¼Œç”¨äºç¼“å­˜ Invoker çš„è™šæ‹ŸèŠ‚ç‚¹ this.virtualInvokers = new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;(); // 2 è®°å½• Invoker é›†åˆçš„ hashCodeï¼Œç”¨è¯¥ hashCode å€¼å¯ä»¥åˆ¤æ–­ Provider åˆ—è¡¨æ˜¯å¦å‘ç”Ÿäº†å˜åŒ– this.identityHashCode = identityHashCode; // 3 è·å–æ¶ˆè´¹ç«¯ Invoker çš„ URL URL url = invokers.get(0).getUrl(); // 4 ä»é…ç½®ä¸­è·å–è™šæ‹ŸèŠ‚ç‚¹æ•°ï¼ˆhash.nodes å‚æ•°ï¼‰ä»¥åŠå‚ä¸ hash è®¡ç®—çš„å‚æ•°ä¸‹æ ‡ï¼ˆhash.arguments å‚æ•°ï¼‰ this.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, 160); // 5 å¯¹å‚ä¸ hash è®¡ç®—çš„å‚æ•°ä¸‹æ ‡è¿›è¡Œè§£æï¼Œç„¶åå­˜æ”¾åˆ° argumentIndex æ•°ç»„ä¸­ String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, \"0\")); argumentIndex = new int[index.length]; for (int i = 0; i &lt; index.length; i++) &#123; argumentIndex[i] = Integer.parseInt(index[i]); &#125; // 6 æ„å»º Invoker è™šæ‹ŸèŠ‚ç‚¹ï¼Œé»˜è®¤ replicaNumber=160ï¼Œç›¸å½“äºåœ¨ Hash ç¯ä¸Šæ”¾ 160 ä¸ªæ§½ä½ã€‚å¤–å±‚è½®è¯¢ 40 æ¬¡ï¼Œå†…å±‚è½®è¯¢ 4 æ¬¡ï¼Œå…± 40 * 4 = 160æ¬¡ï¼Œä¹Ÿå°±æ˜¯åŒä¸€ä¸ªèŠ‚ç‚¹è™šæ‹Ÿå‡º 160 ä¸ªæ§½ä½ for (Invoker&lt;T&gt; invoker : invokers) &#123; // 6.1 è·å–æœåŠ¡åœ°å€ host:port String address = invoker.getUrl().getAddress(); for (int i = 0; i &lt; replicaNumber / 4; i++) &#123; // 6.2 å¯¹ address + i è¿›è¡Œmd5è¿ç®—ï¼Œå¾—åˆ°ä¸€ä¸ªé•¿åº¦ä¸º16çš„å­—èŠ‚æ•°ç»„ // åŸºäºæœåŠ¡åœ°å€è¿›è¡Œ md5 è®¡ç®— byte[] digest = md5(address + i); // 6.3 å¯¹ digest éƒ¨åˆ†å­—èŠ‚è¿›è¡Œ 4 æ¬¡ Hash è¿ç®—ï¼Œå¾—åˆ° 4 ä¸ªä¸åŒçš„ long å‹æ­£æ•´æ•° for (int h = 0; h &lt; 4; h++) &#123; // h = 0 æ—¶ï¼Œå– digest ä¸­ä¸‹æ ‡ä¸º 0 ~ 3 çš„4ä¸ªå­—èŠ‚è¿›è¡Œä½è¿ç®— // h = 1 æ—¶ï¼Œå– digest ä¸­ä¸‹æ ‡ä¸º 4 ~ 7 çš„4ä¸ªå­—èŠ‚è¿›è¡Œä½è¿ç®— // h = 2, h = 3 æ—¶è¿‡ç¨‹åŒä¸Š long m = hash(digest, h); // 6.3 å°† hash åˆ° Invoker çš„æ˜ å°„å…³ç³»å­˜å‚¨åˆ° virtualInvokers ä¸­ // virtualInvokers éœ€è¦æä¾›é«˜æ•ˆã€æœ‰åºçš„æŸ¥è¯¢æ“¦æ“ä½œï¼Œå› æ­¤é€‰ç”¨ TreeMap ä½œä¸ºå­˜å‚¨ç»“æ„ virtualInvokers.put(m, invoker); &#125; &#125; &#125; &#125; ConsistentHashSelector çš„æ„é€ æ–¹æ³•æ ¸å¿ƒç‚¹æ˜¯ åˆ›å»ºè™šæ‹ŸèŠ‚ç‚¹ï¼ˆæ„å»º Hash ç¯ï¼‰ å’Œ æ”¶é›†å‚ä¸ä¸€è‡´æ€§Hashè®¡ç®—çš„å‚æ•°ä¸‹æ ‡ï¼ˆé»˜è®¤æƒ…å†µä¸‹åªä½¿ç”¨ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œä¹Ÿå°±æ˜¯ä¸‹æ ‡ä¸º 0ï¼‰ ã€‚éœ€è¦ç‰¹åˆ«è¯´æ˜çš„æ˜¯ï¼ŒConsistentHashLoadBalance çš„è´Ÿè½½å‡è¡¡é€»è¾‘åªå—å‚æ•°å€¼å½±å“ï¼Œå…·æœ‰ç›¸åŒå‚æ•°å€¼çš„è¯·æ±‚å°†ä¼šè¢«åˆ†é…ç»™åŒä¸€ä¸ªæœåŠ¡æä¾›è€…ï¼ŒConsistentHashLoadBalance ä¸å…³å¿ƒæƒé‡ï¼Œå› æ­¤ä½¿ç”¨æ—¶éœ€è¦æ³¨æ„ä¸€ä¸‹ã€‚ä¸‹é¢æˆ‘ä»¬å°±æ¥å¯¹å…¶é€‰æ‹© Invoker çš„ select æ–¹æ³•è¿›è¡Œåˆ†æï¼Œä»è¯¥æ–¹æ³•å°±å¯ä»¥çœ‹å‡ºä¸ºä»€ä¹ˆè¯´è¯¥è´Ÿè½½å‡è¡¡ç­–ç•¥åªå—å‚æ•°å€¼å½±å“ã€‚ é€‰æ‹©æœåŠ¡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051+--- ConsistentHashSelector /** * é€‰æ‹©åˆé€‚çš„ Invoker å¯¹è±¡ * * @param invocation * @return */ public Invoker&lt;T&gt; select(Invocation invocation) &#123; // 1 å°†å‚ä¸ä¸€è‡´æ€§ Hash çš„å‚æ•°æ‹¼æ¥åˆ°ä¸€èµ· String key = toKey(invocation.getArguments()); // 2 å¯¹ key è¿›è¡Œ md5 è¿ç®— byte[] digest = md5(key); // 3 å– digest æ•°ç»„çš„å‰å››ä¸ªå­—èŠ‚è¿›è¡Œ hash è¿ç®—ï¼Œå†å°† hash å€¼ä¼ ç»™ selectForKey æ–¹æ³•ï¼Œå¯»æ‰¾åˆé€‚çš„ Invoker return selectForKey(hash(digest, 0)); &#125; /** * å°†å‚ä¸ Hash è®¡ç®—çš„å‚æ•°ç´¢å¼•å¯¹åº”çš„å‚æ•°å€¼è¿›è¡Œæ‹¼æ¥ã€‚é»˜è®¤å¯¹ç¬¬ä¸€ä¸ªå‚æ•°è¿›è¡Œ Hash è¿ç®—ã€‚ * * @param args * @return */ private String toKey(Object[] args) &#123; StringBuilder buf = new StringBuilder(); // å¯¹å‚ä¸ Hash è®¡ç®—çš„å‚æ•°å€¼è¿›è¡Œæ‹¼æ¥ for (int i : argumentIndex) &#123; if (i &gt;= 0 &amp;&amp; i &lt; args.length) &#123; buf.append(args[i]); &#125; &#125; return buf.toString(); &#125; /** * é€‰æ‹© Invoker * * @param hash è°ƒç”¨æ–¹æ³•å‚æ•°å¤„ç†åçš„ Hash å€¼ * @return */ private Invoker&lt;T&gt; selectForKey(long hash) &#123; // 1 åˆ° TreeMap ä¸­æŸ¥æ‰¾ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å€¼å¤§äºæˆ–ç­‰äºå½“å‰ hash çš„ Invoker Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.ceilingEntry(hash); // 2 å¦‚æœä¼ å…¥çš„ hash å¤§äº Invoker åœ¨ Hash ç¯ä¸Šæœ€å¤§çš„ä½ç½®ï¼Œæ­¤æ—¶ entry = nullï¼Œæ­¤æ—¶éœ€è¦å›åˆ° Hash ç¯çš„å¼€å¤´è¿”å›ç¬¬ä¸€ä¸ª Invoker å¯¹è±¡ if (entry == null) &#123; entry = virtualInvokers.firstEntry(); &#125; // 3 å–å‡ºç›®æ ‡ Invoker return entry.getValue(); &#125; ä¸€è‡´æ€§ Hash é€‰æ‹©å™¨ ConsistentHashSelector é€‰æ‹©çš„è¿‡ç¨‹ç›¸å¯¹æ¯”è¾ƒç®€å•ã€‚å…ˆæ˜¯å¯¹å‚æ•°è¿›è¡Œ md5 ä»¥åŠ hash è¿ç®—ï¼Œå¾—åˆ°ä¸€ä¸ª Hash å€¼ï¼Œç„¶åå†æ‹¿è¿™ä¸ª Hash å€¼åˆ° TreeMap ä¸­æŸ¥æ‰¾ç›®æ ‡ Invoker å³å¯ã€‚ ShortestResponseLoadBalanceShortestResponseLoadBalance ä½¿ç”¨çš„æ˜¯ æœ€çŸ­å“åº”æ—¶é—´çš„è´Ÿè½½å‡è¡¡ç®—æ³•ï¼Œå’Œæœ€å°æ´»è·ƒæ•°è´Ÿè½½å‡è¡¡ç®—æ³•ç±»ä¼¼ï¼Œå”¯ä¸€çš„å·®åˆ«åœ¨äºæœ€çŸ­å“åº”æ—¶é—´æ˜¯åŸºäºè°ƒç”¨æˆåŠŸçš„è¯·æ±‚æ¥è®¡ç®—å®ç°çš„ï¼Œè€Œæœ€å°æ´»è·ƒæ•°æ˜¯ç›´æ¥åŸºäºå½“å‰æ­£åœ¨å¤„ç†çš„è¯·æ±‚æ•°å®ç°çš„ï¼Œå…¶å®ƒçš„ä¸¤è€…å®Œå…¨ä¸€è‡´ã€‚æœ€çŸ­å“åº”æ—¶é—´è¶Šå°ï¼Œè¡¨æ˜è¯¥æœåŠ¡æä¾›è€…æ•ˆç‡è¶Šé«˜ï¼Œæ­¤æ—¶å¯ä»¥å°†è¯·æ±‚ä¼˜å…ˆåˆ†é…ç»™è¯¥æœåŠ¡ã€‚åœ¨å…·ä½“å®ç°ä¸­ï¼Œä¼šè®°å½•æ¯ä¸ªæœåŠ¡æä¾›è€…æˆåŠŸå¤„ç†è¯·æ±‚çš„ä¸ªæ•°ä»¥åŠå¯¹åº”çš„å¤„ç†æ€»æ—¶é—´ï¼Œè¿™æ ·å¯ä»¥å¾—åˆ°ä¸€ä¸ª æˆåŠŸè°ƒç”¨çš„å¹³å‡æ—¶é—´ ï¼Œæœ€åç»“åˆè¯¥æœåŠ¡æä¾›è€…çš„æœ€å°æ´»è·ƒæ•°ï¼Œè®¡ç®—å‡ºæœ€çŸ­å“åº”æ—¶é—´ã€‚ä¹Ÿå°±æ˜¯ä»å¤šä¸ªæä¾›è€…èŠ‚ç‚¹ä¸­é€‰å‡ºè°ƒç”¨æˆåŠŸä¸”å“åº”æ—¶é—´æœ€çŸ­çš„æœåŠ¡æä¾›è€…èŠ‚ç‚¹ã€‚æ»¡è¶³è¯¥æ¡ä»¶çš„æœåŠ¡èŠ‚ç‚¹å¯èƒ½æœ‰å¤šä¸ªï¼Œè¿™ç§æƒ…å†µå†ä½¿ç”¨åŠ æƒéšæœºç®—æ³•è¿›è¡Œä¸€æ¬¡é€‰æ‹©å°±å¯ä»¥å¾—åˆ°æœ€ç»ˆç›®æ ‡èŠ‚ç‚¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public class ShortestResponseLoadBalance extends AbstractLoadBalance &#123; /** * æ‰©å±•å */ public static final String NAME = \"shortestresponse\"; @Override protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123; // -------------------------- 1 ğŸª å…³é”®å±æ€§ ------------------------/ // è®°å½• Invoker é›†åˆæ•°é‡ int length = invokers.size(); // è®°å½•æ‰€æœ‰ Invoker é›†åˆä¸­æœ€çŸ­å“åº”æ—¶é—´ long shortestResponse = Long.MAX_VALUE; // è®°å½•å…·æœ‰ç›¸åŒæœ€çŸ­å“åº”æ—¶é—´ï¼ˆshortestResponse çš„å€¼ï¼‰çš„ Invoker æ•°é‡ int shortestCount = 0; // å­˜æ”¾å…·æœ‰ç›¸åŒæœ€çŸ­å“åº”æ—¶é—´ï¼ˆshortestResponse çš„å€¼ï¼‰çš„ Invoker åœ¨ Invoker åˆ—è¡¨ä¸­çš„ä¸‹æ ‡ // shortestIndexes æ•°ç»„ä¸­å¦‚æœæœ‰å¤šä¸ªå€¼ï¼Œåˆ™è¯´æ˜æœ‰ä¸¤ä¸ªåŠä»¥ä¸Šçš„ Invoker å…·æœ‰ç›¸åŒçš„æœ€çŸ­å“åº”æ—¶é—´ int[] shortestIndexes = new int[length]; // å­˜æ”¾æ¯ä¸ª Invoker æƒé‡ï¼Œä¸»è¦ç”¨äºå½“æœ€çŸ­å“åº”æ—¶é—´çš„ Invoker æ•°é‡æœ‰å¤šä¸ªçš„æƒ…å†µ int[] weights = new int[length]; // è®°å½•å…·æœ‰ç›¸åŒæœ€çŸ­å“åº”æ—¶é—´ Invoker çš„æ€»æƒé‡ int totalWeight = 0; // è®°å½•ç¬¬ä¸€ä¸ª Invoker å¯¹è±¡çš„æƒé‡ int firstWeight = 0; // æ ‡è®°æ˜¯å¦å…·æœ‰ç›¸åŒæƒé‡çš„æœ€çŸ­å“åº”æ—¶é—´çš„ Invoker boolean sameWeight = true; // --------------------------- 2 ğŸª æ“ä½œå…³é”®å±æ€§ -----------------------/ // éå†æ‰€æœ‰ Invoker ï¼Œé€‰å‡ºæœ€çŸ­å“åº”æ—¶é—´çš„ Invoker é›†åˆ for (int i = 0; i &lt; length; i++) &#123; Invoker&lt;T&gt; invoker = invokers.get(i); // ä½¿ç”¨åˆ°äº†æ¶ˆè´¹æ–¹é™æµç­–ç•¥ï¼šActiveLimitFilter RpcStatus rpcStatus = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()); // è·å–è°ƒç”¨æˆåŠŸçš„å¹³å‡æ—¶é—´ï¼Œè®¡ç®—æ–¹å¼ï¼šè°ƒç”¨æˆåŠŸçš„è¯·æ±‚æ•°æ€»æ•°å¯¹åº”çš„æ€»è€—æ—¶ / è°ƒç”¨æˆåŠŸçš„è¯·æ±‚æ•°æ€»æ•° = æˆåŠŸè°ƒç”¨çš„å¹³å‡æ—¶é—´ long succeededAverageElapsed = rpcStatus.getSucceededAverageElapsed(); // è·å–è¯¥æä¾›è€…çš„æ´»è·ƒè¯·æ±‚æ•°ï¼Œä¹Ÿå°±æ˜¯å½“å‰æ­£åœ¨å¤„ç†ä¸­çš„è¯·æ±‚æ•° int active = rpcStatus.getActive(); // è®¡ç®—ä¸€ä¸ªå¤„ç†æ–°è¯·æ±‚çš„é¢„ä¼°å€¼ï¼Œä¹Ÿå°±æ˜¯å¦‚æœå½“å‰è¯·æ±‚å‘ç»™è¯¥æä¾›è€…ï¼Œå¤§æ¦‚è€—æ—¶å¤šä¹…å¤„ç†å®Œæˆ long estimateResponse = succeededAverageElapsed * active; // è·å–è¯¥ Invoker çš„æƒé‡ int afterWarmup = getWeight(invoker, invocation); weights[i] = afterWarmup; // å’Œ LeastActiveLoadBalance ç±»ä¼¼ // æ¯”è¾ƒæœ€çŸ­æ—¶é—´ï¼Œå‘ç°æ›´å°å€¼åˆ™æ›´æ–°ç›¸å…³å±æ€§ï¼Œè¿™ç§æƒ…å†µåªæœ‰ä¸€ä¸ª Invoker if (estimateResponse &lt; shortestResponse) &#123; // é‡æ–°è®°å½•æœ€çŸ­å“åº”æ—¶é—´ shortestResponse = estimateResponse; // é‡æ–°è®°å½•æœ€çŸ­å“åº”æ—¶é—´çš„ Invoker æ•°é‡ shortestCount = 1; // é‡æ–°è®°å½•æœ€çŸ­å“åº”æ—¶é—´çš„ Invoker åœ¨ Invoker åˆ—è¡¨ä¸­çš„ä¸‹æ ‡ shortestIndexes[0] = i; // é‡ç½®æ€»æƒé‡ totalWeight = afterWarmup; // è®°å½•ç¬¬ä¸€ä¸ªæœ€çŸ­å“åº”æ—¶é—´çš„ Invoker çš„æƒé‡ firstWeight = afterWarmup; // é‡ç½®æƒé‡ç›¸åŒæ ‡è¯† sameWeight = true; // å‡ºç°å¤šä¸ªè€—æ—¶æœ€çŸ­çš„Invokerå¯¹è±¡ &#125; else if (estimateResponse == shortestResponse) &#123; // è®°å½•å½“å‰ Invoker åœ¨ Invoker åˆ—è¡¨ä¸­çš„ä¸‹æ ‡ shortestIndexes[shortestCount++] = i; // ç´¯åŠ æ€»æƒé‡ï¼Œé’ˆå¯¹çš„æ˜¯å…·æœ‰ç›¸åŒçš„æœ€çŸ­å“åº”æ—¶é—´ totalWeight += afterWarmup; // åˆ¤æ–­æ˜¯å¦å­˜åœ¨ç›¸åŒæƒé‡çš„æœ€çŸ­å“åº”æ—¶é—´çš„ Invoker if (sameWeight &amp;&amp; i &gt; 0 &amp;&amp; afterWarmup != firstWeight) &#123; sameWeight = false; &#125; &#125; &#125; //------------------------------ 3 ğŸª é€‰æ‹© Invoker ----------------------/ // ä»…æœ‰ä¸€ä¸ªæœ€çŸ­å“åº”æ—¶é—´çš„ Invoker if (shortestCount == 1) &#123; return invokers.get(shortestIndexes[0]); &#125; // å¦‚æœè€—æ—¶æœ€çŸ­çš„æ‰€æœ‰Invokerå¯¹è±¡çš„æƒé‡ä¸ç›¸åŒï¼Œåˆ™é€šè¿‡åŠ æƒéšæœºè´Ÿè½½å‡è¡¡çš„æ–¹å¼é€‰æ‹©ä¸€ä¸ªInvokerè¿”å› if (!sameWeight &amp;&amp; totalWeight &gt; 0) &#123; int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight); for (int i = 0; i &lt; shortestCount; i++) &#123; int shortestIndex = shortestIndexes[i]; offsetWeight -= weights[shortestIndex]; if (offsetWeight &lt; 0) &#123; return invokers.get(shortestIndex); &#125; &#125; &#125; // å¦‚æœè€—æ—¶æœ€çŸ­çš„æ‰€æœ‰ Invoker å¯¹è±¡çš„æƒé‡ç›¸åŒï¼Œåˆ™éšæœºè¿”å›ä¸€ä¸ª return invokers.get(shortestIndexes[ThreadLocalRandom.current().nextInt(shortestCount)]); &#125;&#125; ShortestResponseLoadBalance æ ¸å¿ƒæ€æƒ³æ˜¯é€‰æ‹©æœ€çŸ­å“åº”æ—¶é—´çš„æœåŠ¡æä¾›è€…ï¼Œå¦‚æœæœ€çŸ­å“åº”æ—¶é—´çš„æä¾›è€…æœ‰å¤šä¸ªï¼Œåˆ™ä½¿ç”¨åŠ æƒéšæœºç®—æ³•ç»§ç»­é€‰æ‹©å³å¯ã€‚ç”±äºå’Œæœ€å°æ´»è·ƒæ•°è´Ÿè½½å‡è¡¡ç­–ç•¥åŸºæœ¬ä¸€è‡´ï¼Œè¿™é‡Œå°±ä¸å†å…·ä½“æè¿°ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« å¯¹ Dubbo çš„äº”ç§è´Ÿè½½å‡è¡¡å®ç°è¿›è¡Œäº†è¯¦ç»†åˆ†æï¼Œç†è§£è´Ÿè½½å‡è¡¡ä»£ç é€»è¾‘çš„å…³é”®æ˜¯ç†è§£å¯¹åº”çš„ç®—æ³•æœ¬èº«ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"é›†ç¾¤å®¹é”™ - Router","slug":"rpc/é›†ç¾¤å®¹é”™ä¹‹Router","date":"2020-09-26T23:00:00.000Z","updated":"2021-04-06T08:32:41.637Z","comments":false,"path":"posts/26e2f6a4/","link":"","permalink":"https://gentryhuang.com/posts/26e2f6a4/","excerpt":"","text":"æ¦‚è¿°Dubbo ä¸­çš„è·¯ç”± Router çš„ä¸»è¦åŠŸèƒ½å°±æ˜¯æ ¹æ®ç”¨æˆ·é…ç½®çš„è·¯ç”±è§„åˆ™ä»¥åŠè¯·æ±‚æºå¸¦ä¿¡æ¯ï¼Œè¿‡æ»¤å‡ºç¬¦åˆæ¡ä»¶çš„ Invoker é›†åˆï¼Œä¾›åç»­è´Ÿè½½å‡è¡¡é€»è¾‘ä½¿ç”¨ã€‚ç›¸å…³ç±»å›¾å›¾å¦‚ä¸‹ï¼š RouterFactory &amp; RouterRouterFactory123456789101112@SPIpublic interface RouterFactory &#123; /** * * åˆ›å»º Router. * * @param url * @return router */ @Adaptive(\"protocol\") Router getRouter(URL url);&#125; RouterFactory æ˜¯ Dubbo çš„æ‰©å±•ç‚¹ï¼Œæ²¡æœ‰é»˜è®¤æ‰©å±•å®ç°ï¼Œç”¨äºåˆ›å»º Routerã€‚å…¶ä¸­ getRouter æ–¹æ³•åŠ¨æ€ç”Ÿæˆçš„é€‚é…å™¨ä¼šæ ¹æ® protocol å‚æ•°é€‰æ‹©æ‰©å±•å®ç°ã€‚ Router123456789101112131415161718192021222324public interface Router extends Comparable&lt;Router&gt; &#123; /** * è·å–è·¯ç”±è§„åˆ™URL * * get the router url. * * @return url */ URL getUrl(); /** * è·¯ç”±ï¼Œç­›é€‰åŒ¹é…çš„Invoker é›†åˆ * * route. * * @param invokers Invoker é›†åˆ * @param url refer url * @param invocation * @return routed invokers è·¯ç”±åçš„Invoker é›†åˆ * @throws RpcException */ &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;&#125; Router å†³å®šäº†ä¸€æ¬¡ Dubbo è°ƒç”¨çš„ç›®æ ‡æœåŠ¡ï¼Œè¯¥æ¥å£çš„æ¯ä¸ªå®ç°ç±»éƒ½ä»£è¡¨ä¸€ä¸ªè·¯ç”±è§„åˆ™ã€‚å½“æ¶ˆè´¹æ–¹è°ƒç”¨æœåŠ¡æä¾›æ–¹æ—¶ï¼ŒDubbo æ ¹æ®è·¯ç”±è§„åˆ™ä»æœåŠ¡ç›®å½•ä¸­ç­›é€‰å‡ºç¬¦åˆæ¡ä»¶çš„æœåŠ¡åˆ—è¡¨ï¼Œä¹‹åé€šè¿‡è´Ÿè½½å‡è¡¡ç®—æ³•å†æ¬¡è¿›è¡Œç­›é€‰ã€‚ ConditionRouterFactory &amp; ConditionRouterConditionRouterFactory123456789101112public class ConditionRouterFactory implements RouterFactory &#123; /** * æ‹“å±•å */ public static final String NAME = \"condition\"; @Override public Router getRouter(URL url) &#123; // åˆ›å»º ConditionRouter å¯¹è±¡ return new ConditionRouter(url); &#125;&#125; ConditionRouterFactory å®ç°ï¼Œå…¶æ‰©å±•åä¸º condition ï¼Œåœ¨å…¶ getRouter æ–¹æ³•ä¸­ä¼šåˆ›å»º ConditionRouter å¯¹è±¡ã€‚ ConditionRouterConditionRouter æ˜¯åŸºäºæ¡ä»¶è¡¨è¾¾å¼çš„è·¯ç”±å®ç°ç±»ï¼Œå†åˆ†ææ¡ä»¶è·¯ç”±ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆå¯¹æ¡ä»¶è¡¨è¾¾å¼ç›¸å…³å†…å®¹è¿›è¡Œè¯´æ˜ï¼Œæ¡ä»¶è·¯ç”±å°±æ˜¯æ ¹æ®è¿™äº›è§„åˆ™å®ç°çš„ã€‚ ä¸‹é¢å°±æ˜¯ä¸€æ¡åŸºäºæ¡ä»¶è¡¨è¾¾å¼çš„è·¯ç”±è§„åˆ™ï¼š 1host &#x3D; 10.20.153.10 &#x3D;&gt; host &#x3D; 10.20.153.11 è§„åˆ™ =&gt; ä¹‹å‰çš„ä¸ºæ¶ˆè´¹è€…åŒ¹é…æ¡ä»¶ï¼Œè¯¥æ¡ä»¶ä¸­çš„æ‰€æœ‰å‚æ•°ä¼šä¸æ¶ˆè´¹è€…çš„ URL è¿›è¡Œå¯¹æ¯”ï¼Œå½“æ¶ˆè´¹è€…æ»¡è¶³åŒ¹é…æ¡ä»¶æ—¶ï¼Œä¼šå¯¹è¯¥æ¶ˆè´¹è€…æ‰§è¡Œåé¢çš„è¿‡æ»¤è§„åˆ™ï¼Œå¦åˆ™ç›´æ¥è¿”å›æ¶ˆè´¹ç«¯Invokeråˆ—è¡¨ï¼Œæ— éœ€ç»§ç»­æä¾›è€…è¿‡æ»¤æ¡ä»¶çš„åŒ¹é…ã€‚ =&gt; ä¹‹åçš„ä¸ºæä¾›è€…åœ°å€åˆ—è¡¨çš„è¿‡æ»¤æ¡ä»¶ï¼Œè¯¥æ¡ä»¶ä¸­çš„æ‰€æœ‰å‚æ•°ä¼šä¸æä¾›è€…çš„ URL è¿›è¡Œå¯¹æ¯”ï¼Œæ¶ˆè´¹è€…æœ€ç»ˆåªèƒ½æ‹¿åˆ°è¿‡æ»¤åçš„åœ°å€åˆ—è¡¨ å¦‚æœåŒ¹é…æ¡ä»¶ä¸ºç©ºï¼Œè¡¨ç¤º =&gt; ä¹‹åçš„è¿‡æ»¤æ¡ä»¶å¯¹æ‰€æœ‰æ¶ˆè´¹æ–¹ç”Ÿæ•ˆï¼Œå¦‚ï¼š =&gt; host!=10.20.153.11ï¼Œå«ä¹‰æ˜¯æ‰€æœ‰çš„æ¶ˆè´¹æ–¹éƒ½ä¸èƒ½è¯·æ±‚ 10.20.153.11 è¿™ä¸ªæä¾›è€…èŠ‚ç‚¹ã€‚ å¦‚æœæä¾›è€…è¿‡æ»¤æ¡ä»¶ä¸ºç©ºï¼Œè¡¨ç¤ºç¦æ­¢è®¿é—®æ‰€æä¾›è€…ï¼Œå¦‚ï¼šhost = 10.20.153.10 =&gt;ï¼Œå«ä¹‰æ˜¯ 10.20.153.10 è¿™ä¸ªæ¶ˆè´¹æ–¹ä¸èƒ½è®¿é—®ä»»ä½•æä¾›è€…ã€‚ è¡¨è¾¾å¼å‚æ•°æ”¯æŒ æœåŠ¡è°ƒç”¨ä¿¡æ¯ï¼Œå¦‚ï¼šmethodã€argument ç­‰ URL æœ¬èº«çš„å­—æ®µï¼Œå¦‚ï¼šprotocolã€hostã€port ç­‰ URL ä¸Šçš„æ‰€æœ‰å‚æ•°ï¼Œå¦‚ï¼šapplicationã€organization ç­‰ æ¡ä»¶æ”¯æŒ ç­‰å· = è¡¨ç¤ºåŒ¹é…ï¼Œå¦‚ï¼šhost = 10.20.153.10 ä¸ç­‰å· != è¡¨ç¤ºä¸åŒ¹é…ï¼Œå¦‚ï¼šhost != 10.20.153.10 å€¼æ”¯æŒ ä»¥é€—å· , åˆ†éš”å¤šä¸ªå€¼ï¼Œå¦‚ï¼šhost != 10.20.153.10,10.20.153.11 ä»¥æ˜Ÿå· * ç»“å°¾ï¼Œè¡¨ç¤ºé€šé…ï¼Œå¦‚ï¼šhost != 10.20.* ä»¥ç¾å…ƒç¬¦ $ å¼€å¤´ï¼Œè¡¨ç¤ºå¼•ç”¨æ¶ˆè´¹è€…å‚æ•°ï¼Œå¦‚ï¼šhost = $host å±æ€§123456789101112131415161718192021222324252627282930313233343536373839public class ConditionRouter implements Router, Comparable&lt;Router&gt; &#123; private static final Logger logger = LoggerFactory.getLogger(ConditionRouter.class); /** * åˆ†ç»„æ­£åˆ™åŒ¹é…ï¼Œç”¨äºåˆ‡åˆ†è·¯ç”±è§„åˆ™çš„æ­£åˆ™è¡¨è¾¾å¼ * è¯´æ˜ï¼š * ç¬¬ä¸€ä¸ªåŒ¹é…ç»„-åˆ†å‰²ç¬¦ï¼š ç”¨äºåŒ¹é… \"&amp;\", \"!=\", \"=\" å’Œ \",\" ç­‰ç¬¦å·ï¼Œä½œä¸ºåŒ¹é…è§„åˆ™çš„åˆ†éš”ç¬¦ã€‚å…è®¸åŒ¹é…ä¸åˆ°ï¼Œä½¿ç”¨äº† * é€šé…ç¬¦ * ç¬¬äºŒä¸ªåŒ¹é…ç»„-å†…å®¹ï¼š è¿™é‡Œç”¨äºåŒ¹é… è‹±æ–‡å­—æ¯ï¼Œæ•°å­—ç­‰å­—ç¬¦ï¼Œã€ä¸åŒ¹é… &amp;!=,ã€‘ä½œä¸ºåŒ¹é…è§„åˆ™çš„åŒ¹é…å†…å®¹ã€‚ å¯èƒ½å‡ºç°ï¼Œè¿™é‡ŒåŒ¹é…åˆ°äº†ï¼Œä½†æ˜¯ç¬¬ä¸€åŒ¹é…ç»„æ²¡æœ‰åŒ¹é…åˆ°ã€‚ */ private static Pattern ROUTE_PATTERN = Pattern.compile(\"([&amp;!=,]*)\\\\s*([^&amp;!=,\\\\s]+)\"); /** * è·¯ç”±è§„åˆ™ URL * å¦‚ï¼š URL.valueOf(\"route://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule=\" + URL.encode(\"host = 10.20.153.10 =&gt; host = 10.20.153.11\")) */ private final URL url; /** * è·¯ç”±è§„åˆ™ä¼˜å…ˆçº§ï¼Œç”¨äºæ’åºï¼Œä¼˜å…ˆçº§è¶Šå¤§è¶Šé å‰ã€‚ä¼˜å…ˆçº§è¶Šå¤§è¶Šé å‰æ‰§è¡Œã€‚é»˜è®¤ä¸º0 */ private final int priority; /** * å½“è·¯ç”±ç»“æœä¸ºç©ºæ—¶æ˜¯å¦å¼ºåˆ¶æ‰§è¡Œï¼Œå¦‚æœä¸å¼ºåˆ¶æ‰§è¡Œï¼Œè·¯ç”±åŒ¹é…ç»“æœä¸ºç©ºçš„è·¯ç”±è§„è®¤ä¸ºæ˜¯å¤±æ•ˆçš„ã€‚å¦‚æœå¼ºåˆ¶æ‰§è¡Œï¼Œåˆ™ç›´æ¥è¿”å›ç©ºçš„è·¯ç”±ç»“æœã€‚é»˜è®¤ä¸ºfalse */ private final boolean force; /** * æ¶ˆè´¹è€…åŒ¹é…çš„æ¡ä»¶é›†åˆï¼Œé€šè¿‡è§£ææ¡ä»¶è¡¨è¾¾å¼è§„åˆ™ '=&gt;' ä¹‹å‰çš„éƒ¨åˆ†å¾—åˆ° * key: åŒ¹é…é¡¹ * value: åŒ¹é…é¡¹å¯¹åº”çš„åŒ¹é…å¯¹ ã€åŒ…å«åŒ¹é…é¡¹å¯¹åº”çš„ åŒ¹é…å€¼é›†åˆ/ä¸åŒ¹é…å€¼é›†åˆ ã€‘ * æ•ˆæœï¼šæ‰€æœ‰å‚æ•°å’Œæ¶ˆè´¹è€…çš„ URL è¿›è¡Œå¯¹æ¯”ï¼Œå½“æ¶ˆè´¹è€…æ»¡è¶³åŒ¹é…æ¡ä»¶æ—¶ï¼Œå¯¹è¯¥æ¶ˆè´¹è€…æ‰§è¡Œåé¢çš„è¿‡æ»¤è§„åˆ™ã€‚ */ private final Map&lt;String, MatchPair&gt; whenCondition; /** * æä¾›è€…åŒ¹é…çš„æ¡ä»¶é›†åˆï¼Œé€šè¿‡è§£ææ¡ä»¶è¡¨è¾¾å¼è§„åˆ™ '=&gt;' ä¹‹åçš„éƒ¨åˆ†å¾—åˆ° * key: åŒ¹é…é¡¹ * value: åŒ¹é…é¡¹å¯¹åº”çš„åŒ¹é…å¯¹ ã€åŒ…å«åŒ¹é…é¡¹å¯¹åº”çš„ åŒ¹é…å€¼é›†åˆ/ä¸åŒ¹é…å€¼é›†åˆ ã€‘ * æ•ˆæœï¼šæ‰€æœ‰å‚æ•°å’Œæä¾›è€…çš„ URLï¼ˆåˆå¹¶å¤„ç†åçš„ï¼‰è¿›è¡Œå¯¹æ¯”ï¼Œæ¶ˆè´¹è€…æœ€ç»ˆåªæ‹¿åˆ°è¿‡æ»¤åçš„åœ°å€åˆ—è¡¨ã€‚ */ private final Map&lt;String, MatchPair&gt; thenCondition;&#125; æ„é€ æ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546+--- ConditionRouter /** * å°†æ¡ä»¶è·¯ç”±è§„åˆ™è§£ææˆé¢„å®šæ ¼å¼ * * @param url æ¡ä»¶è§„åˆ™ URL */ public ConditionRouter(URL url) &#123; this.url = url; // 1 è·å– priority å’Œ force é…ç½® this.priority = url.getParameter(Constants.PRIORITY_KEY, 0); this.force = url.getParameter(Constants.FORCE_KEY, false); try &#123; // 2 è·å–è·¯ç”±è§„åˆ™URLä¸­è·¯ç”±è§„åˆ™ rule å‚æ•°çš„å€¼ String rule = url.getParameterAndDecoded(Constants.RULE_KEY); if (rule == null || rule.trim().length() == 0) &#123; throw new IllegalArgumentException(\"Illegal route rule!\"); &#125; // 3 å‰”é™¤æ‰è·¯ç”±è§„åˆ™ä¸­çš„consumer.æˆ–è€…provider. ï¼Œå¦‚ consumer.host != 192.168.0.1 &amp; method = * =&gt; provider.host != 10.75.25.66 // å‰”é™¤è°ƒå‰ç¼€æ‰æ˜¯çœŸæ­£çš„è§„åˆ™ rule = rule.replace(\"consumer.\", \"\").replace(\"provider.\", \"\"); // 4 æ ¹æ® \"=&gt;\" æ‹†åˆ†è·¯ç”±è§„åˆ™ int i = rule.indexOf(\"=&gt;\"); // 5 åˆ†åˆ«è·å–æ¶ˆè´¹è€…åŒ¹é…è§„åˆ™çš„ä¸² å’Œ æœåŠ¡æä¾›è€…è¿‡æ»¤è§„åˆ™çš„ä¸² String whenRule = i &lt; 0 ? null : rule.substring(0, i).trim(); String thenRule = i &lt; 0 ? rule.trim() : rule.substring(i + 2).trim(); // 6 å°†è·¯ç”±è§„åˆ™ä¸²è§£æä¸ºkey-valueå½¢å¼ ,keyä¸ºè·¯ç”±è§„åˆ™åŒ¹é…é¡¹ï¼Œvalueä¸ºåŒ¹é…å¯¹ï¼ˆåŒ…å«äº†åŒ¹é…é¡¹å¯¹åº”çš„ åŒ¹é…å€¼é›†åˆå’Œä¸åŒ¹é…å€¼é›†åˆï¼‰ // 6.1 è§£ææ¶ˆè´¹æ–¹åŒ¹é…è§„åˆ™ Map&lt;String, MatchPair&gt; when = StringUtils.isBlank(whenRule) || \"true\".equals(whenRule) ? new HashMap&lt;String, MatchPair&gt;() : parseRule(whenRule); // 6.2 è§£ææä¾›è€…è¿‡æ»¤è§„åˆ™ Map&lt;String, MatchPair&gt; then = StringUtils.isBlank(thenRule) || \"false\".equals(thenRule) ? null : parseRule(thenRule); // 6.3 èµ‹å€¼ æ¶ˆè´¹æ–¹åŒ¹é…æ¡ä»¶é›†åˆã€æä¾›è€…è¿‡æ»¤æ¡ä»¶é›†åˆ this.whenCondition = when; this.thenCondition = then; &#125; catch (ParseException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; åœ¨ ConditionRouter çš„æ„é€ æ–¹æ³•ä¸­ï¼Œä¼šæ ¹æ® URL ä¸­æºå¸¦çš„ç›¸åº”å‚æ•°åˆå§‹åŒ– priorityã€force ç­‰å±æ€§ã€‚ç„¶åä»æ¡ä»¶è·¯ç”± URL çš„ rule å‚æ•°ä¸­è·å–è·¯ç”±è§„åˆ™å¹¶è¿›è¡Œè§£æï¼Œæœ€åå¾—åˆ°åŒ¹é…é¡¹é›†åˆï¼Œå½“éœ€è¦è¿›è¡ŒåŒ¹é…æ—¶ï¼Œæ ¹æ®å·²ç»è§£æå¥½çš„è§„åˆ™å¯¹æ¶ˆè´¹æ–¹ URL æˆ–æä¾›è€… URL è¿›è¡ŒåŒ¹é…å³å¯ã€‚ åŒ¹é…é¡¹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869+--- ConditionRouterprivate static final class MatchPair &#123; /** * åŒ¹é…å€¼é›†åˆï¼Œå¾…åŒ¹é…é¡¹å­˜åœ¨äºé›†åˆï¼Œåˆ™è¯´æ˜åŒ¹é…æˆåŠŸ */ final Set&lt;String&gt; matches = new HashSet&lt;String&gt;(); /** * ä¸åŒ¹é…å€¼é›†åˆï¼Œå¾…åŒ¹é…é¡¹å­˜åœ¨äºé›†åˆï¼Œåˆ™è¯´æ˜åŒ¹é…å¤±è´¥ */ final Set&lt;String&gt; mismatches = new HashSet&lt;String&gt;(); /** * åˆ¤æ–­ value æ˜¯å¦åŒ¹é… matches + mismatches * * @param value * @param param * @return */ private boolean isMatch(String value, URL param) &#123; // 1 åªåŒ¹é… matchesï¼Œæ²¡æœ‰åŒ¹é…ä¸Šåˆ™è¯´æ˜å¤±è´¥äº†ï¼Œè¿”å›false if (!matches.isEmpty() &amp;&amp; mismatches.isEmpty()) &#123; for (String match : matches) &#123; // åªè¦å…¥å‚è¢« matches é›†åˆä¸­çš„ä»»æ„ä¸€ä¸ªå…ƒç´ åŒ¹é…åˆ°ï¼Œå°±åŒ¹é…æˆåŠŸï¼Œè¿”å›true if (UrlUtils.isMatchGlobPattern(match, value, param)) &#123; return true; &#125; &#125; // å¦‚æœæ‰€æœ‰åŒ¹é…å€¼éƒ½æ— æ³•åŒ¹é…åˆ° valueï¼Œåˆ™åŒ¹é…å¤±è´¥,è¿”å›false return false; &#125; // 2 åªåŒ¹é… mismatchesï¼Œæ²¡æœ‰åŒ¹é…ä¸Šï¼Œåˆ™è¯´æ˜æˆåŠŸäº†ï¼Œè¿”å›true if (!mismatches.isEmpty() &amp;&amp; matches.isEmpty()) &#123; for (String mismatch : mismatches) &#123; // åªè¦å…¥å‚è¢« mismatches é›†åˆä¸­çš„ä»»æ„ä¸€ä¸ªå…ƒç´ åŒ¹é…åˆ°ï¼Œå°±åŒ¹é…å¤±è´¥ï¼Œè¿”å›false if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) &#123; return false; &#125; &#125; // mismatches é›†åˆä¸­æ‰€æœ‰å…ƒç´ éƒ½æ— æ³•åŒ¹é…åˆ°å…¥å‚ï¼Œåˆ™åŒ¹é…æˆåŠŸï¼Œè¿”å› true return true; &#125; // 3 åŒ¹é… mismatches + matchesï¼Œä¼˜å…ˆå»åŒ¹é… mismatches if (!matches.isEmpty() &amp;&amp; !mismatches.isEmpty()) &#123; // åªè¦ mismatches é›†åˆä¸­ä»»æ„ä¸€ä¸ªå…ƒç´ ä¸å…¥å‚åŒ¹é…æˆåŠŸï¼Œåˆ™åŒ¹é…å¤±è´¥ï¼Œå°±ç«‹å³è¿”å› false for (String mismatch : mismatches) &#123; if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) &#123; return false; &#125; &#125; // åªè¦ matches é›†åˆä¸­ä»»æ„ä¸€ä¸ªå…ƒç´ ä¸å…¥å‚åŒ¹é…æˆåŠŸï¼Œåˆ™åŒ¹é…æˆåŠŸï¼Œå°±ç«‹å³è¿”å› true for (String match : matches) &#123; if (UrlUtils.isMatchGlobPattern(match, value, param)) &#123; return true; &#125; &#125; return false; &#125; // 4 matches å’Œ mismatches å‡ä¸ºç©ºï¼Œæ­¤æ—¶è¿”å› false return false; &#125; &#125; MatchPair è¡¨ç¤ºä¸€ä¸ªåŒ¹é…é¡¹ï¼Œå…¶ä¸­åŒ…å«ä¸¤ä¸ª Set é›†åˆï¼ŒåŒ¹é…å€¼é›†åˆå’Œä¸åŒ¹é…å€¼é›†åˆã€‚å…·ä½“åŒ¹é…é€»è¾‘å¦‚ä¸‹ï¼š å½“ mismatches é›†åˆä¸ºç©ºæ—¶ï¼Œä¼šéå† matches é›†åˆä¸­çš„åŒ¹é…æ¡ä»¶ï¼ŒåŒ¹é…ä¸Šä»»æ„ä¸€æ¡å³å¯è¿”å› trueã€‚ å½“ matches é›†åˆä¸ºç©ºæ—¶ï¼Œä¼šéå† mismatches é›†åˆä¸­çš„åŒ¹é…æ¡ä»¶ï¼ŒåŒ¹é…ä¸Šä»»æ„ä¸€æ¡å³è¿”å› falseã€‚ å½“ matches é›†åˆå’Œ mismatches é›†åˆåŒæ—¶ä¸ä¸ºç©ºæ—¶ï¼Œä¼šä¼˜å…ˆåŒ¹é… mismatches é›†åˆä¸­çš„æ¡ä»¶ï¼ŒåŒ¹é…ä¸Šä»»æ„ä¸€æ¡è§„åˆ™å³è¿”å› falseã€‚è‹¥ mismatches ä¸­çš„æ¡ä»¶å…¨éƒ¨åŒ¹é…å¤±è´¥ï¼Œæ‰ä¼šå¼€å§‹åŒ¹é… matches é›†åˆï¼ŒåŒ¹é…ä¸Šä»»æ„ä¸€æ¡å³è¿”å› trueã€‚ å½“ matches é›†åˆå’Œ mismatches é›†åˆåŒæ—¶ä¸ºç©ºæ—¶ï¼Œåˆ™è¿”å› false å…¶ä¸­å…·ä½“çš„åŒ¹é…é€»è¾‘éƒ½æ˜¯åœ¨ UrlUtils.isMatchGlobPattern æ–¹æ³•ä¸­å®ç°çš„ï¼Œä¸»è¦åˆ¤æ–­é€»è¾‘å¦‚ä¸‹ï¼š å¦‚æœåŒ¹é…æ¡ä»¶ä»¥ $ ç¬¦å·å¼€å¤´ï¼Œè¡¨ç¤ºä» URL ä¸­è·å–ç›¸åº”çš„å‚æ•°å€¼è¿›è¡ŒåŒ¹é…ã€‚ å¯¹ * é€šé…ç¬¦ç‰¹åˆ«å¤„ç†ï¼Œä¼šå¤„ç†é€šé…ç¬¦åœ¨åŒ¹é…æ¡ä»¶å¼€å¤´ã€ä¸­é—´ä»¥åŠæœ«å°¾ä¸‰ç§æƒ…å†µã€‚ éé€šé…ç¬¦ç›´æ¥ç­‰å€¼åŒ¹é… ä¸‹é¢ç®€å•ç²˜è´´ä¸‹ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566+--- UrlUtils /** * åˆ¤æ–­ value æ˜¯å¦åŒ¹é… matches/mismatches * æ³¨æ„ï¼šparamå‚æ•°æ˜¯ä¸ºäº†æ”¯æŒä»URLä¸­è¯»å–å‚æ•° * * @param pattern åŒ¹é…è§„åˆ™ * @param value å¾…å’ŒåŒ¹é…å€¼è¿›è¡ŒåŒ¹é…çš„å€¼ * @param param æ¶ˆæ¯è€…URL * @return æ˜¯å¦åŒ¹é… */ public static boolean isMatchGlobPattern(String pattern, String value, URL param) &#123; // ä»¥ç¾å…ƒç¬¦ `$` å¼€å¤´ï¼Œè¡¨ç¤ºå¼•ç”¨æ¶ˆè´¹è€…å‚æ•°ï¼ˆä»URLä¸­è·å–ç›¸åº”çš„å‚æ•°å€¼ï¼‰ï¼Œparamå‚æ•°ä¸ºæ¶ˆè´¹è€…URL if (param != null &amp;&amp; pattern.startsWith(\"$\")) &#123; pattern = param.getRawParameter(pattern.substring(1)); &#125; // è¿›è¡ŒåŒ¹é… return isMatchGlobPattern(pattern, value); &#125; public static boolean isMatchGlobPattern(String pattern, String value) &#123; // å…¨åŒ¹é…ï¼Œé€šé…ç¬¦æ”¯æŒ if (\"*\".equals(pattern)) &#123; return true; &#125; // åŒ¹é…è§„åˆ™å’Œå¾…åŒ¹é…å€¼å…¨éƒ¨ä¸ºç©ºï¼Œè®¤ä¸ºä¸¤è€…ç›¸ç­‰ï¼Œå³åŒ¹é… if ((pattern == null || pattern.length() == 0) &amp;&amp; (value == null || value.length() == 0)) &#123; return true; &#125; // åŒ¹é…è§„åˆ™å’Œå¾…åŒ¹é…å€¼æœ‰ä¸€ä¸ªä¸ºç©ºï¼Œä¸åŒ¹é… if ((pattern == null || pattern.length() == 0) || (value == null || value.length() == 0)) &#123; return false; &#125; // ç¡®å®š åŒ¹é…è§„åˆ™ä¸­é€šé…ç¬¦ * çš„ä½ç½® int i = pattern.lastIndexOf('*'); // åŒ¹é…è§„åˆ™ä¸­ä¸åŒ…å«é€šé…ç¬¦ï¼Œæ­¤æ—¶ç›´æ¥æ¯”è¾ƒåŒ¹é…å€¼å’Œå¾…åŒ¹é…å€¼ æ˜¯å¦ç›¸ç­‰å³å¯ï¼Œå¹¶è¿”å›æ¯”è¾ƒç»“æœ if (i == -1) &#123; return value.equals(pattern); &#125; // é€šé…ç¬¦ \"*\" åœ¨åŒ¹é…è§„åˆ™å°¾éƒ¨ï¼Œæ¯”å¦‚ 192.168.25.* else if (i == pattern.length() - 1) &#123; // åˆ¤æ–­å¾…åŒ¹é…å€¼æ˜¯å¦ç¬¦åˆå«æœ‰é€šé…ç¬¦çš„åŒ¹é…è§„åˆ™ return value.startsWith(pattern.substring(0, i)); &#125; // é€šé…ç¬¦ \"*\" åœ¨åŒ¹é…è§„åˆ™å¤´éƒ¨ï¼Œå¦‚ï¼š*ã€‚168.25.100 else if (i == 0) &#123; // åˆ¤æ–­å¾…åŒ¹é…å€¼æ˜¯å¦ç¬¦åˆå«æœ‰é€šé…ç¬¦çš„åŒ¹é…è§„åˆ™ return value.endsWith(pattern.substring(i + 1)); &#125; // é€šé…ç¬¦ \"*\" åœ¨åŒ¹é…è§„åˆ™ä¸­é—´ä½ç½® else &#123; // ä»¥é€šé…ç¬¦ * åˆ†éš”ï¼Œè·å–å‰åç¼€ String prefix = pattern.substring(0, i); String suffix = pattern.substring(i + 1); // åˆ¤æ–­åŒ¹é…å€¼æ˜¯å¦ä»¥ å‰ç¼€å¼€å¤´ä¸”ä»¥åç¼€ç»“å°¾ return value.startsWith(prefix) &amp;&amp; value.endsWith(suffix); &#125; &#125; è§£æè·¯ç”±è§„åˆ™123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112+--- ConditionRouter private static Map&lt;String, MatchPair&gt; parseRule(String rule) throws ParseException &#123; // 1 å®šä¹‰æ¡ä»¶æ˜ å°„é›†åˆï¼Œkeyï¼šåŒ¹é…é¡¹ value: åŒ¹é…å¯¹MatchPair ã€‚ Map&lt;String, MatchPair&gt; condition = new HashMap&lt;String, MatchPair&gt;(); if (StringUtils.isBlank(rule)) &#123; return condition; &#125; // 2 å­˜å‚¨åŒ¹é…å¯¹ï¼Œå³åŒ¹é…å’Œä¸åŒ¹é…æ¡ä»¶ MatchPair pair = null; // 3 åŒ¹é…å¯¹ä¸­çš„ åŒ¹é…å€¼é›†åˆ/ä¸åŒ¹é…å€¼é›†åˆçš„ä¸´æ—¶å˜é‡ Set&lt;String&gt; values = null; // 4 æŒ‰ç…§ åˆ†ç»„æ­£åˆ™åŒ¹é… é…æ•´è·¯ç”±ä¸ªæ¡ä»¶è¡¨è¾¾å¼ final Matcher matcher = ROUTE_PATTERN.matcher(rule); /** * 5 é€šè¿‡ ROUTE_PATTERN æ­£åˆ™åŒ¹é… rule ï¼Œéå†åŒ¹é…ç»“æœï¼Œ * è¯´æ˜ï¼š * 1 find()æ–¹æ³•æ˜¯éƒ¨åˆ†åŒ¹é…ï¼Œæ˜¯æŸ¥æ‰¾è¾“å…¥ä¸²ä¸­ä¸æ¨¡å¼åŒ¹é…çš„å­ä¸²ï¼Œå¦‚æœè¯¥åŒ¹é…çš„ä¸²æœ‰ç»„è¿˜å¯ä»¥ä½¿ç”¨group()å‡½æ•°ã€‚å½“ä¸”ä»…å½“è¾“å…¥åºåˆ—çš„å­åºåˆ—ï¼ŒåŒ¹é…è§„åˆ™æ‰ä¼šè¿”å›trueï¼Œå¯èƒ½å¯ä»¥åŒ¹é…å¤šä¸ªå­ä¸² * 2 matcher.group() è¿”å›åŒ¹é…åˆ°çš„å­å­—ç¬¦ä¸² * ä¾‹å­ï¼šhost = 2.2.2.2 &amp; host != 1.1.1.1 &amp; method = hello * åŒ¹é…ç»“æœï¼š * ç¬¬ä¸€ä¸ªå­åºåˆ—ï¼š host åˆ†ç»„ä¸€ï¼š\"\" åˆ†ç»„äºŒï¼šhost * ç¬¬äºŒä¸ªå­åºåˆ—ï¼š= 2.2.2.2 åˆ†ç»„ä¸€ï¼š= åˆ†ç»„äºŒï¼š2.2.2.2 * ç¬¬ä¸‰ä¸ªå­åºåˆ—ï¼š&amp; host åˆ†ç»„ä¸€ï¼š&amp; åˆ†ç»„äºŒï¼šhost * ... */ while (matcher.find()) &#123; // 5.1 è·å–åŒ¹é…ç»„ä¸€çš„åŒ¹é…ç»“æœï¼Œå³åˆ†éš”ç¬¦ String separator = matcher.group(1); // 5.2 è·å–åŒ¹é…ç»„äºŒçš„åŒ¹é…ç»“æœï¼Œå³åŒ¹é…è§„åˆ™é¡¹ String content = matcher.group(2); // 6 åŒ¹é…ç»„ä¸€çš„åŒ¹é…ç»“æœä¸ºç©ºï¼Œåˆ™è¯´æ˜ content ä¸ºå‚æ•°åç§° if (separator == null || separator.length() == 0) &#123; // åˆ›å»º MatchPair å¯¹è±¡ pair = new MatchPair(); // å­˜å‚¨ &lt;åŒ¹é…é¡¹, MatchPair&gt; é”®å€¼å¯¹ï¼Œæ¯”å¦‚ &lt;host, MatchPair&gt; condition.put(content, pair); &#125; // 7 å¦‚æœåŒ¹é…ç»„ä¸€çš„åŒ¹é…ç»“æœæ˜¯ '&amp;'ï¼Œè¯´æ˜æ˜¯å¤šä¸ªè¡¨è¾¾å¼ else if (\"&amp;\".equals(separator)) &#123; // å…ˆå°è¯•ä» condition ä¸­è·å–contentå¯¹åº”çš„MatchPairï¼Œä¸å­˜åœ¨åˆ™æ–°å»ºå¹¶æ”¾å…¥conditionä¸­ if (condition.get(content) == null) &#123; pair = new MatchPair(); condition.put(content, pair); &#125; else &#123; pair = condition.get(content); &#125; &#125; // 8 å¦‚æœåˆ†éš”ç¬¦ä¸º '='ï¼Œè¡¨ç¤ºKVçš„åˆ†ç•Œçº¿ï¼Œå€¼æ˜¯åŒ¹é…å€¼ else if (\"=\".equals(separator)) &#123; if (pair == null) &#123; throw new ParseException(\"Illegal route rule \\\"\" + rule + \"\\\", The error char '\" + separator + \"' at index \" + matcher.start() + \" before \\\"\" + content + \"\\\".\", matcher.start()); &#125; // åŒ¹é…å¯¹ä¸­çš„åŒ¹é…å€¼é›†åˆï¼Œå…ˆå–å†æ”¾ values = pair.matches; // å°† content å­˜å…¥åˆ° MatchPair çš„ matches é›†åˆä¸­ values.add(content); &#125; // 9 å¦‚æœåˆ†éš”ç¬¦ä¸º '!='ï¼Œè¡¨ç¤ºKVçš„åˆ†ç•Œçº¿ï¼Œå€¼å°±æ˜¯ä¸åŒ¹é…å€¼ else if (\"!=\".equals(separator)) &#123; if (pair == null) &#123; throw new ParseException(\"Illegal route rule \\\"\" + rule + \"\\\", The error char '\" + separator + \"' at index \" + matcher.start() + \" before \\\"\" + content + \"\\\".\", matcher.start()); &#125; // åŒ¹é…å¯¹ä¸­çš„ä¸åŒ¹é…å€¼é›†åˆï¼Œå…ˆå–å†æ”¾ values = pair.mismatches; // å°† content å­˜å…¥åˆ° MatchPair çš„ mismatches é›†åˆä¸­ values.add(content); &#125; // 10 åˆ†éš”ç¬¦ä¸º , è¡¨ç¤ºæŸä¸ªåŒ¹é…é¡¹æœ‰å¤šä¸ªå€¼ï¼Œå®ƒä»¬ä»¥ ','åˆ†éš” else if (\",\".equals(separator)) &#123; if (values == null || values.isEmpty()) &#123; throw new ParseException(\"Illegal route rule \\\"\" + rule + \"\\\", The error char '\" + separator + \"' at index \" + matcher.start() + \" before \\\"\" + content + \"\\\".\", matcher.start()); &#125; // å°† content å­˜å…¥åˆ°ä¸Šä¸€æ­¥è·å–åˆ°çš„ values ä¸­ï¼Œå¯èƒ½æ˜¯ matchesï¼Œä¹Ÿå¯èƒ½æ˜¯ mismatches values.add(content); // 11 æš‚ä¸æ”¯æŒçš„åˆ†å‰²ç¬¦ &#125; else &#123; throw new ParseException(\"Illegal route rule \\\"\" + rule + \"\\\", The error char '\" + separator + \"' at index \" + matcher.start() + \" before \\\"\" + content + \"\\\".\", matcher.start()); &#125; &#125; return condition; &#125; è§£æè·¯ç”±è§„åˆ™ä¸»è¦æ˜¯æ ¹æ®æ­£åˆ™è¡¨è¾¾å¼ä¸­çš„ä¸¤ä¸ªåŒ¹é…ç»„ï¼Œç¬¬ä¸€ä¸ªç»„ç”¨æ¥åŒ¹é…åˆ†å‰²ç¬¦ï¼Œç›®å‰æ”¯æŒ &amp;ã€!=ã€= ä»¥åŠ , ç¬¦å·ï¼›ç¬¬äºŒä¸ªç»„ç”¨æ¥åŒ¹é…æ¡ä»¶å†…å®¹ï¼›å…¶ä¸­ä¸¤ä¸ªåŒ¹é…ç»„ä¸­é—´å…è®¸æœ‰å¤šä¸ªç©ºç™½ã€‚ åœ¨è§£ææ—¶ï¼Œè§„åˆ™å¦‚ä¸‹ï¼š ç¬¬ä¸€ä¸ªåŒ¹é…ç»„åŒ¹é…ä¸ºç©ºæˆ–è€…åŒ¹é…åˆ° &amp; ç¬¦å·æ—¶ï¼Œè¯´æ˜ç¬¬äºŒä¸ªåŒ¹é…é¡¹åŒ¹é…åˆ°çš„æ˜¯ä¸€ä¸ªæ¡ä»¶é¡¹ï¼Œåº”è¯¥ä¸ºå…¶åˆ›å»ºä¸€ä¸ªåŒ¹é…é¡¹ MatchPair å¯¹è±¡ï¼Œç”¨äºä¸‹ä¸€ä¸ªåŒ¹é…æŸ¥æ‰¾å­˜æ”¾åŒ¹é…å€¼æˆ–ä¸åŒ¹é…å€¼ã€‚ ç¬¬ä¸€ä¸ªåŒ¹é…ç»„åŒ¹é…ä¸º =ã€!= ä»¥åŠ , æ—¶ï¼Œè¯´æ˜æœ¬æ¬¡æŸ¥æ‰¾åˆ°åŒ¹é…çš„å†…å®¹äº†ï¼Œæ ¹æ®ç­‰å€¼æˆ–ä¸ç­‰å€¼åˆ¤æ–­ï¼Œå°†è¯¥å†…å®¹è®°å½•åˆ°ä¸Šä¸€è½®çš„ MatchPair ä¸­çš„ç­‰å€¼æˆ–ä¸ç­‰å€¼çš„é›†åˆä¸­ã€‚ ä»¥ä¸Šå°±æ˜¯è·¯ç”±è§„åˆ™çš„è§£æé€»è¾‘ï¼Œä¸‹é¢ä½¿ç”¨ä¸€ä¸ªç¤ºä¾‹å¯¹è§£æé€»è¾‘è¿›è¡Œè¯´æ˜ã€‚ ç¤ºä¾‹1host &#x3D; 2.2.2.2,1.1.1.1 &amp; method !&#x3D;get &#x3D;&gt; host &#x3D; 3.3.3.3 æ­£åˆ™è§£æç»“æœ - whenCondition123456 ç¬¬ä¸€ä¸ªåŒ¹é…ç»„ï¼ˆåˆ†å‰²ç¬¦ï¼‰ ç¬¬äºŒåŒ¹é…ç»„ï¼ˆæ¡ä»¶ï¼‰ç¬¬ä¸€è½®ï¼š &quot;&quot; hostç¬¬äºŒè½®ï¼š &#x3D; 2.2.2.2ç¬¬ä¸‰è½®ï¼š , 1.1.1.1ç¬¬å››è½®ï¼š &amp; methodç¬¬äº”è½®ï¼š !&#x3D; get æ­£åˆ™è§£æç»“æœ - thenCondition123 ç¬¬ä¸€ä¸ªåŒ¹é…ç»„ï¼ˆåˆ†å‰²ç¬¦ï¼‰ ç¬¬äºŒåŒ¹é…ç»„ï¼ˆæ¡ä»¶ï¼‰ç¬¬ä¸€è½®ï¼š &quot;&quot; hostç¬¬äºŒè½®ï¼š &#x3D; 3.3.3.3 è§£æåçš„ conditon å†…å®¹å¦‚ä¸‹ï¼š whenConditon12345678910&#123; \"host\":&#123; \"matches\":[\"2.2.2.2\",\"1.1.1.1\"], \"mismatches\":[] &#125;, \"method\":&#123; \"matches\":[], \"mismatches\":[\"get\"] &#125;&#125; thenCondition123456&#123; \"host\":&#123; \"matches\":[\"3.3.3.3\"], \"mismatches\":[] &#125;&#125; æœåŠ¡è·¯ç”±1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768+--- ConditionRouter /** * è·¯ç”± * è¯´æ˜ï¼šè¯¥æ–¹æ³•ä¼ å…¥çš„urlå‚æ•°ç›®å‰éƒ½æ˜¯æ¶ˆè´¹è€…URL: * &#123;@link AbstractDirectory#list(com.alibaba.dubbo.rpc.Invocation)&#125; * &#123;@link com.alibaba.dubbo.registry.integration.RegistryDirectory#route(java.util.List, java.lang.String)&#125; * * @param invokers Invoker é›†åˆ * @param url è°ƒç”¨è€…ä¼ å…¥ï¼Œç›®å‰éƒ½æ˜¯æ¶ˆè´¹è€…URL * @param invocation è°ƒç”¨ä¿¡æ¯ * @param &lt;T&gt; * @return * @throws RpcException */ @Override public &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException &#123; // åˆ¤ç©º if (invokers == null || invokers.isEmpty()) &#123; return invokers; &#125; try &#123; /** * 1 ä¼˜å…ˆæ‰§è¡Œæ¶ˆè´¹è€…åŒ¹é…æ¡ä»¶ï¼Œå¦‚æœåŒ¹é…å¤±è´¥ï¼Œè¯´æ˜å½“å‰æ¶ˆè´¹è€…URLä¸ç¬¦åˆæ¶ˆè´¹è€…åŒ¹é…è§„åˆ™ï¼Œç›´æ¥è¿”å›invokeré›†åˆå³å¯ï¼Œæ— éœ€ç»§ç»­åé¢çš„é€»è¾‘ã€‚ * è¯´æ˜ï¼š * æ¶ˆè´¹è€… ipï¼š192.168.25.100 * è·¯ç”±è§„åˆ™ï¼šhost = 10.20.125.10 =&gt; host = 10.2.12.10 : ipä¸º10.20.125.10çš„æ¶ˆè´¹è€…è°ƒç”¨ipä¸º10.2.12.10çš„æœåŠ¡æä¾›è€… * ç»“æœï¼šå½“å‰æ¶ˆè´¹è€…ipä¸º192.168.25.100ï¼Œè¿™æ¡è·¯ç”±è§„åˆ™ä¸é€‚ç”¨äºå½“å‰çš„æ¶ˆè´¹è€…ï¼Œç›´æ¥è¿”å› * */ if (!matchWhen(url, invocation)) &#123; return invokers; &#125; // è·¯ç”±è¿‡æ»¤åçš„Invokerç»“æœé›† List&lt;Invoker&lt;T&gt;&gt; result = new ArrayList&lt;Invoker&lt;T&gt;&gt;(); // 2 æä¾›è€…è¿‡æ»¤æ¡ä»¶æœªé…ç½®çš„è¯ç›´æ¥è¿”å›ç©ºé›†åˆï¼Œè¡¨ç¤ºæ— æä¾›è€…å¯ç”¨ if (thenCondition == null) &#123; logger.warn(\"The current consumer in the service blacklist. consumer: \" + NetUtils.getLocalHost() + \", service: \" + url.getServiceKey()); return result; &#125; // 3 éå†Invokeré›†åˆï¼Œé€ä¸ªåˆ¤æ–­ Invoker æ˜¯å¦ç¬¦åˆæä¾›è€…è¿‡æ»¤æ¡ä»¶ for (Invoker&lt;T&gt; invoker : invokers) &#123; if (matchThen(invoker.getUrl(), url)) &#123; result.add(invoker); &#125; &#125; // 4 å¦‚æœ result éç©ºï¼Œåˆ™ç›´æ¥è¿”å›è¿‡æ»¤åçš„Invoker é›†åˆ if (!result.isEmpty()) &#123; return result; // 5 å¦‚æœè¿‡æ»¤åçš„Invokeré›†åˆä¸ºç©ºï¼Œæ ¹æ® force å†³å®šè¿”å›ç©ºé›†åˆè¿˜æ˜¯è¿”å›å…¨éƒ¨ Invoker // å¦‚æœ force = trueï¼Œè¡¨ç¤ºå¼ºåˆ¶è¿”å›ç©ºåˆ—è¡¨ï¼Œå¦åˆ™è·¯ç”±ç»“æœä¸ºç©ºçš„è·¯ç”±è§„åˆ™å°†å¤±æ•ˆ &#125; else if (force) &#123; logger.warn(\"The route result is empty and force execute. consumer: \" + NetUtils.getLocalHost() + \", service: \" + url.getServiceKey() + \", router: \" + url.getParameterAndDecoded(Constants.RULE_KEY)); return result; &#125; &#125; catch (Throwable t) &#123; logger.error(\"Failed to execute condition router rule: \" + getUrl() + \", invokers: \" + invokers + \", cause: \" + t.getMessage(), t); &#125; // 6 èµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜è¿‡æ»¤åçš„Invokeré›†åˆä¸ºç©ºï¼Œå¹¶ä¸”éå¼ºåˆ¶æ‰§è¡Œï¼Œåˆ™åŸæ ·è¿”å›invoker é›†åˆï¼Œå³è¡¨ç¤ºè¯¥æ¡è·¯ç”±è§„åˆ™å¤±æ•ˆï¼Œå¿½å¾‹è·¯ç”±è§„åˆ™ return invokers; &#125; æœåŠ¡è·¯ç”±é¦–å…ˆåˆ¤æ–­æ­¤æ¬¡å‘èµ·è°ƒç”¨çš„æ¶ˆè´¹æ–¹æ˜¯å¦ç¬¦åˆæ¶ˆè´¹ç«¯åŒ¹é…æ¡ä»¶ï¼Œè‹¥ä¸ç¬¦åˆè¯´æ˜å½“å‰è·¯ç”±è§„åˆ™ä¸é€‚ç”¨å½“å‰çš„æ¶ˆè´¹è€…ï¼Œç›´æ¥è¿”å›æ•´ä¸ª Invoker åˆ—è¡¨å³å¯ã€‚è‹¥ç¬¦åˆï¼Œåˆ™ç»§ç»­é€šè¿‡æä¾›è€…åŒ¹é…æ¡ä»¶å¯¹ Invoker é›†åˆè¿›è¡Œè¿‡æ»¤ã€‚å…¶ä¸­é€šè¿‡è°ƒç”¨ matchWhen å¯¹æ¶ˆè´¹æ–¹è¿›è¡ŒåŒ¹é…ï¼ŒåŒ¹é…æˆåŠŸå†ä½¿ç”¨ matchThen å¯¹æä¾›è€…è¿›è¡Œè¿‡æ»¤ã€‚ä¸‹é¢æ¥çœ‹ä¸€ä¸‹è¿™ä¸¤ä¸ªæ–¹æ³•çš„é€»è¾‘ï¼š 1234567891011121314151617181920212223242526272829+--- ConditionRouter /** * å¯¹æœåŠ¡æ¶ˆè´¹æ–¹è¿›è¡ŒåŒ¹é…ï¼Œå¦‚æœåŒ¹é…å¤±è´¥ï¼Œç›´æ¥è¿”å›Invoker åˆ—è¡¨ã€‚å¦‚æœåŒ¹é…æˆåŠŸï¼Œæ‰ä¼šå¯¹æœåŠ¡æä¾›è€…è¿›è¡ŒåŒ¹é…ã€‚ * * @param url æ¶ˆè´¹è€… URL * @param invocation è°ƒç”¨ä¿¡æ¯ * @return */ boolean matchWhen(URL url, Invocation invocation) &#123; /** * æœåŠ¡æ¶ˆè´¹è€…åŒ¹é…æ¡ä»¶ä¸º null æˆ– ç©ºï¼Œè¡¨ç¤ºå¯¹æ‰€æœ‰æ¶ˆè´¹æ–¹ç”Ÿæ•ˆï¼Œè¿”å›trueï¼Œå¦‚ï¼š * =&gt; host != 10.2.12.10 ï¼Œè¡¨ç¤ºæ‰€æœ‰çš„æ¶ˆè´¹è€…éƒ½ä¸èƒ½è°ƒç”¨ IP ä¸º 10.2.12.10 */ return whenCondition == null || whenCondition.isEmpty() || matchCondition(whenCondition, url, null, invocation); &#125; /** * å¯¹æœåŠ¡æä¾›è€…è¿›è¡ŒåŒ¹é… * * @param url æä¾›è€…URLåˆå¹¶åçš„ URL * @param param æ¶ˆè´¹è€… URL * @return */ private boolean matchThen(URL url, URL param) &#123; // æœåŠ¡æä¾›è€…æ¡ä»¶ä¸º null æˆ– ç©ºï¼Œè¡¨ç¤ºç¦ç”¨æœåŠ¡ return !(thenCondition == null || thenCondition.isEmpty()) &amp;&amp; matchCondition(thenCondition, url, param, null); &#125; è¿™ä¸¤ä¸ªæ–¹æ³•å‡æ˜¯é€šè¿‡è°ƒç”¨ matchCondition æ–¹æ³•æ‰§è¡ŒåŒ¹é…é€»è¾‘çš„ï¼ŒåŒºåˆ«åœ¨å®ƒä»¬å„è‡ªä¼ å‚ä¸åŒã€‚å…·ä½“ä¼ å‚ä»£ç ä¸­å·²ç»è¯¦ç»†æ ‡æ³¨ï¼Œä¸‹é¢æˆ‘ä»¬å°±çœ‹å…·ä½“çš„åŒ¹é…é€»è¾‘ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970+--- ConditionRouter/** * åŒ¹é…æ¡ä»¶ * * @param condition æ¶ˆè´¹è€…åŒ¹é…çš„æ¡ä»¶é›†åˆ/æä¾›è€…åŒ¹é…çš„æ¡ä»¶é›†åˆ * @param url æ¶ˆè´¹è€…URL/æä¾›è€…URLåˆå¹¶åçš„URL * @param param æ¶ˆè´¹è€…URLï¼Œåœ¨urlå‚æ•°ä¸ºæä¾›è€…URLåˆå¹¶åçš„URLæ—¶æ‰æœ‰å€¼ã€‚è¯¥å€¼ä»…ç”¨äºåŒ¹é…è§„åˆ™å¼•ç”¨æ¶ˆè´¹è€…URLçš„å‚æ•°çš„åœºæ™¯ã€‚ * @param invocation è°ƒç”¨ä¿¡æ¯ * @return */ private boolean matchCondition(Map&lt;String, MatchPair&gt; condition, URL url, URL param, Invocation invocation) &#123; // 1 å°†æœåŠ¡æä¾›è€…æˆ–æ¶ˆè´¹è€… url è½¬æˆ Map Map&lt;String, String&gt; sample = url.toMap(); // æ ‡è®°æ˜¯å¦åŒ¹é… boolean result = false; // 2 éå†åŒ¹é…æ¡ä»¶é›†åˆ for (Map.Entry&lt;String, MatchPair&gt; matchPair : condition.entrySet()) &#123; //--------------------------- è·å–åŒ¹é…é¡¹ï¼Œç¡®å®šåŒ¹é…å€¼ --------------------------/ // 2.1 è·å¾—åŒ¹é…é¡¹åç§°ï¼Œå¦‚ host,method String key = matchPair.getKey(); // 2.2 åŒ¹é…é¡¹çš„å€¼ String sampleValue; // 2.3 å¦‚æœ Invocation ä¸ä¸ºnullï¼Œä¸”åŒ¹é…é¡¹åç§°ä¸º method æˆ– methodsï¼Œè¡¨ç¤ºè¿›è¡Œæ–¹æ³•åŒ¹é… if (invocation != null &amp;&amp; (Constants.METHOD_KEY.equals(key) || Constants.METHODS_KEY.equals(key))) &#123; // ä»Invocationä¸­è·å–è°ƒç”¨æ–¹æ³•å sampleValue = invocation.getMethodName(); &#125; else &#123; // 2.4 ä»æœåŠ¡æä¾›è€…æˆ–è€…æ¶ˆè´¹è€… URL ä¸­è·å–åŒ¹é…é¡¹çš„å€¼ï¼Œå¦‚ hostã€application sampleValue = sample.get(key); // 2.5 åŒ¹é…é¡¹å¯¹åº”çš„å€¼ä¸å­˜åœ¨ï¼Œåˆ™å°è¯•è·å– default.key çš„å€¼ if (sampleValue == null) &#123; sampleValue = sample.get(Constants.DEFAULT_KEY_PREFIX + key); &#125; &#125; //--------------------------- æ¡ä»¶åŒ¹é… ------------------------------------------/ // 3 åŒ¹é…é¡¹çš„å€¼ä¸ä¸ºç©º if (sampleValue != null) &#123; // è°ƒç”¨åŒ¹é…é¡¹å…³è”çš„ MatchPair çš„ isMatch æ–¹æ³•è¿›è¡ŒåŒ¹é…ï¼Œåªè¦æœ‰ä¸€ä¸ªåŒ¹é…è§„åˆ™åŒ¹é…å¤±è´¥ï¼Œå°±å¤±è´¥ if (!matchPair.getValue().isMatch(sampleValue, param)) &#123; return false; &#125; else &#123; result = true; &#125; // 4 åŒ¹é…é¡¹çš„å€¼ä¸ºç©ºï¼Œè¯´æ˜æœåŠ¡æä¾›è€…æˆ–æ¶ˆè´¹è€…URLä¸­ä¸åŒ…å«è¯¥é…ç½®é¡¹çš„å€¼ &#125; else &#123; // åŒ¹é…é¡¹ä¸­çš„åŒ¹é…æ¡ä»¶ `matches` ä¸ä¸ºç©ºï¼Œè¡¨ç¤ºåŒ¹é…å¤±è´¥ï¼Œè¿”å›false // å¦‚æˆ‘ä»¬è®¾ç½®äº†è¿™æ ·ä¸€æ¡è§„åˆ™ï¼šip = 10.2.12.10 ï¼Œå‡è®¾ URL ä¸­ä¸åŒ…å« ip å‚æ•°ï¼Œæ­¤æ—¶ ip åŒ¹é…é¡¹çš„å€¼ä¸º nullï¼Œ // ä½†è·¯ç”±è§„åˆ™é™åˆ¶äº† ip = 10.2.12.10ï¼ŒURLä¸­å´æ²¡æœ‰è¯¥é…ç½®é¡¹ï¼Œè¿™æ˜¯ä¸ç¬¦åˆè§„åˆ™çš„ï¼Œå› æ­¤è¿”å› false if (!matchPair.getValue().matches.isEmpty()) &#123; return false; &#125; else &#123; result = true; &#125; &#125; &#125; return result; &#125; matchCondition æ–¹æ³•æ ¸å¿ƒé€»è¾‘æ˜¯ä½¿ç”¨æ¶ˆè´¹è€…åŒ¹é…æ¡ä»¶é›†åˆæˆ–æä¾›è€…åŒ¹é…æ¡ä»¶é›†åˆï¼Œå»åŒ¹é… æ¶ˆè´¹æ–¹URL æˆ– æä¾›æ–¹URLï¼ˆåˆå¹¶åçš„ç»“æœï¼‰ï¼ŒåŒ¹é…é¡¹çš„åŒ¹é…å·¥ä½œæ˜¯äº¤ç»™ MatchPair.isMatch æ–¹æ³•å®Œæˆçš„ã€‚ å…¶ä¸­ URL è½¬æˆ Map å‚æ•°é€»è¾‘å¦‚ä¸‹ï¼š 1234567891011121314151617+--- URL public Map&lt;String, String&gt; toMap() &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(parameters); if (protocol != null) map.put(\"protocol\", protocol); if (username != null) map.put(\"username\", username); if (password != null) map.put(\"password\", password); if (host != null) map.put(\"host\", host); if (port &gt; 0) map.put(\"port\", String.valueOf(port)); if (path != null) map.put(\"path\", path); return map; &#125; å¯ä»¥çœ‹åˆ°ï¼ŒtoMap æ–¹æ³•å°† URL ä¸­çš„ä¸»å¹²å’Œå‚æ•°éƒ¨åˆ†éƒ½è½¬æˆäº†å¯¹åº”çš„ K-V å½¢å¼ï¼Œç”¨äºå’ŒåŒ¹é…æ¡ä»¶é›†åˆæ¯”å¯¹ã€‚ æ€»ç»“æ•´ä½“æ¥çœ‹æ¡ä»¶è·¯ç”±è¿˜æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œä¸‹é¢å¯¹å…¶ä¸»è¦æµç¨‹è¿›è¡Œç®€å•æ¢³ç†ã€‚ æ¡ä»¶è·¯ç”± ConditionRouter åœ¨åˆå§‹åŒ–æ—¶ä¼šå¯¹ä¼ å…¥çš„æ¡ä»¶è·¯ç”±è§„åˆ™è¿›è¡Œè§£æã€ç¼“å­˜ï¼Œé’ˆå¯¹æ¶ˆè´¹æ–¹å’Œæä¾›æ–¹å„æœ‰ä¸€ä¸ªæ¡ä»¶é›†åˆï¼Œæ ¼å¼ä¸º &lt;åŒ¹é…é¡¹,MatchPair&lt;åŒ¹é…é¡¹å¯¹åº”çš„åŒ¹é…å€¼é›†åˆï¼ŒåŒ¹é…é¡¹å¯¹åº”çš„ä¸åŒ¹é…å€¼é›†åˆ&gt;&gt; ã€‚ è¿›è¡ŒæœåŠ¡è·¯ç”±çš„æ—¶å€™ï¼Œé¦–å…ˆä½¿ç”¨æ¶ˆè´¹æ–¹æ¡ä»¶é›†åˆå¯¹ä¼ å…¥çš„æ¶ˆè´¹è€…URLè¿›è¡ŒåŒ¹é…ï¼ŒåŒ¹é…å¤±è´¥åˆ™è¯´æ˜å½“å‰æ¶ˆè´¹è€…URLä¸ç¬¦åˆæ¶ˆè´¹è€…åŒ¹é…æ¡ä»¶ï¼Œç›´æ¥è¿”å›ä¼ å…¥çš„ Invoker é›†åˆå³å¯ã€‚å¦‚æœåŒ¹é…æˆåŠŸï¼Œåˆ™ä½¿ç”¨æä¾›æ–¹æ¡ä»¶é›†åˆå¯¹ä¼ å…¥çš„ Invoker é›†åˆé€ä¸€åŒ¹é…ï¼Œå³ä½¿ç”¨æä¾›æ–¹æ¡ä»¶é›†åˆå¯¹Invokerçš„URLè¿›è¡ŒåŒ¹é…ï¼Œæœ€ç»ˆç­›é€‰å‡ºç¬¦åˆæ¡ä»¶çš„ Invoker åˆ—è¡¨ã€‚å¦‚æœå¯¹ä¼ å…¥Invoker åˆ—è¡¨è¿‡æ»¤åç»“æœä¸ºç©ºï¼Œåˆ™éœ€è¦æ ¹æ® force å†³å®šè¿”å›ç©ºé›†åˆè¿˜æ˜¯è¿”å›å…¨éƒ¨ Invoker ï¼Œå¦‚æœ force = true è¡¨ç¤ºå¼ºåˆ¶è¿”å›ç©ºåˆ—è¡¨ï¼Œå¦åˆ™è·¯ç”±ç»“æœä¸ºç©ºçš„è·¯ç”±è®¤ä¸ºæ˜¯å¤±æ•ˆçš„ã€‚å¦‚æœæœ€ç»ˆè¿‡æ»¤åçš„ç»“æœéç©ºï¼Œåˆ™ç›´æ¥è¿”å›è¿‡æ»¤åçš„ Invoker åˆ—è¡¨ã€‚ ç¬¬ 2 æ­¥çš„åŒ¹é…é€»è¾‘æœ€ç»ˆæ˜¯äº¤ç»™ MatchPair.isMatch æ–¹æ³•å¤„ç†çš„ï¼Œæœ¬è´¨ä¸Šæ˜¯ä½¿ç”¨åŒ¹é…é›†åˆåŒ¹é…URLä¸­å¯¹åº”çš„å‚æ•°å€¼ã€‚ ScriptRouterFactory &amp; ScriptRouterScriptRouterFactory123456789101112public class ScriptRouterFactory implements RouterFactory &#123; /** * æ‰©å±•å */ public static final String NAME = \"script\"; @Override public Router getRouter(URL url) &#123; // åˆ›å»º ScriptRouter å¯¹è±¡ return new ScriptRouter(url); &#125;&#125; ScriptRouterFactory çš„æ‰©å±•åä¸º script ï¼Œå…¶ getRouter æ–¹æ³•ä¸­ä¼šåˆ›å»ºä¸€ä¸ª ScriptRouter å¯¹è±¡ã€‚ ScriptRouterScriptRouter æ”¯æŒ JDK è„šæœ¬å¼•æ“çš„æ‰€æœ‰è„šæœ¬ï¼Œå¦‚ï¼šjavaScriptã€JRubyã€Groovy ç­‰ï¼Œé€šè¿‡ type=javascript å‚æ•°è®¾ç½®è„šæœ¬ç±»å‹ï¼Œç¼ºçœä¸º javaScript ã€‚ è„šæœ¬1&quot;script:&#x2F;&#x2F;0.0.0.0&#x2F;com.foo.BarService?category&#x3D;routers&amp;dynamic&#x3D;false&amp;rule&#x3D;&quot; + URL.encode(&quot;ï¼ˆfunction route(invokers) &#123; ... &#125; (invokers)ï¼‰&quot;) åŸºäºè„šæœ¬å¼•æ“çš„è·¯ç”±è§„åˆ™ï¼Œä¸‹é¢å®šä¹‰ä¸€ä¸ª route() å‡½æ•°è¿›è¡Œ ip è¿‡æ»¤ã€‚ 12345678910ï¼ˆfunction route(invokers) &#123; var result = new java.util.ArrayList(invokers.size()); for (i = 0; i &lt; invokers.size(); i ++) &#123; // åˆ¤æ–­ Invoker çš„ host æ˜¯å¦ç¬¦åˆæ¡ä»¶ if (\"10.20.153.10\".equals(invokers.get(i).getUrl().getHost())) &#123; result.add(invokers.get(i)); &#125; &#125; return result;&#125; (invokers)ï¼‰; // è¡¨ç¤ºç«‹å³æ‰§è¡Œæ–¹æ³• å¯ä»¥å°†ä¸Šé¢çš„è„šæœ¬è¿›è¡Œç¼–ç å¹¶ä½œä¸ºè·¯ç”±è§„åˆ™å‚æ•° rule çš„å€¼æ·»åŠ åˆ° URL ä¸­ï¼Œè¯¥ URL ä¼ å…¥ ScriptRouter çš„æ„é€ å‡½æ•°æ—¶å³å¯è¢«è§£æã€‚ å±æ€§1234567891011121314151617181920212223242526272829public class ScriptRouter implements Router &#123; private static final Logger logger = LoggerFactory.getLogger(ScriptRouter.class); /** * è„šæœ¬ç±»å‹ ä¸è„šæœ¬å¼•æ“çš„æ˜ å°„ç¼“å­˜ * keyï¼šè„šæœ¬è¯­è¨€çš„åç§° * value: è„šæœ¬å¼•æ“ */ private static final Map&lt;String, ScriptEngine&gt; engines = new ConcurrentHashMap&lt;String, ScriptEngine&gt;(); /** * è„šæœ¬è·¯ç”±è§„åˆ™ */ private final ScriptEngine engine; /** * è·¯ç”±è§„åˆ™ä¼˜å…ˆçº§ï¼Œç”¨äºæ’åºï¼Œè¯¥å­—æ®µå€¼è¶Šå¤§ï¼Œä¼˜å…ˆçº§è¶Šé«˜ï¼Œé»˜è®¤å€¼ä¸º 0ã€‚ */ private final int priority; /** * å½“å‰ ScriptRouter ä½¿ç”¨çš„å…·ä½“è„šæœ¬å†…å®¹ */ private final String rule; /** * è·¯ç”±è§„åˆ™ URLï¼Œå¯ä»¥ä» rule å‚æ•°ä¸­è·å–å…·ä½“çš„è·¯ç”±è§„åˆ™ */ private final URL url;&#125; æ„é€ æ–¹æ³•12345678910111213141516171819202122232425262728+--- ScriptRouter public ScriptRouter(URL url) &#123; this.url = url; // è·å–è„šæœ¬ç±»å‹å’Œè·¯ç”±ä¼˜å…ˆçº§ String type = url.getParameter(Constants.TYPE_KEY); this.priority = url.getParameter(Constants.PRIORITY_KEY, 0); // è·å–è„šæœ¬å†…å®¹ String rule = url.getParameterAndDecoded(Constants.RULE_KEY); if (type == null || type.length() == 0) &#123; type = Constants.DEFAULT_SCRIPT_TYPE_KEY; &#125; if (rule == null || rule.length() == 0) &#123; throw new IllegalStateException(new IllegalStateException(\"route rule can not be empty. rule:\" + rule)); &#125; // æ ¹æ®è„šæœ¬ç±»å‹è·å–å¯¹åº”çš„è„šæœ¬å¼•æ“ ScriptEngine engine = engines.get(type); if (engine == null) &#123; engine = new ScriptEngineManager().getEngineByName(type); if (engine == null) &#123; throw new IllegalStateException(new IllegalStateException(\"Unsupported route rule type: \" + type + \", rule: \" + rule)); &#125; engines.put(type, engine); &#125; this.engine = engine; this.rule = rule; &#125; ScriptRouter æ„é€ æ–¹æ³•ä¼šè·å–ä¼ å…¥URLä¸­çš„è„šæœ¬å†…å®¹ï¼Œä»¥åŠè·å–è„šæœ¬ç±»å‹ï¼Œå¹¶æ ¹æ®è„šæœ¬ç±»å‹åˆ›å»ºè„šæœ¬å¼•æ“ï¼Œè„šæœ¬å¼•æ“ä¸»è¦ç”¨äºç¼–è¯‘å’Œæ‰§è¡Œè„šæœ¬ã€‚ æœåŠ¡è·¯ç”±123456789101112131415161718192021222324252627282930313233343536373839404142+--- ScriptRouter @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException &#123; try &#123; List&lt;Invoker&lt;T&gt;&gt; invokersCopy = new ArrayList&lt;Invoker&lt;T&gt;&gt;(invokers); Compilable compilable = (Compilable) engine; // åˆ›å»º Bindings å¯¹è±¡ä½œä¸º Bindings bindings = engine.createBindings(); // ä¸å‰é¢çš„ javascriptçš„ç¤ºä¾‹è„šæœ¬ç»“åˆï¼Œè¿™é‡Œåœ¨ Bindings ä¸­ä¸ºè„šæœ¬ä¸­çš„route()å‡½æ•°æä¾›äº† invokersã€Invocationã€context ä¸‰ä¸ªå‚æ•° bindings.put(\"invokers\", invokersCopy); bindings.put(\"invocation\", invocation); bindings.put(\"context\", RpcContext.getContext()); // ä½¿ç”¨è„šæœ¬å¼•æ“ç¼–è¯‘è„šæœ¬ CompiledScript function = compilable.compile(rule); // æ‰§è¡Œè„šæœ¬ Object obj = function.eval(bindings); // æ ¹æ®ç»“æœç±»å‹ï¼Œè½¬æ¢æˆ (List&lt;Invoker&lt;T&gt;&gt; ç±»å‹è¿”å› if (obj instanceof Invoker[]) &#123; invokersCopy = Arrays.asList((Invoker&lt;T&gt;[]) obj); &#125; else if (obj instanceof Object[]) &#123; invokersCopy = new ArrayList&lt;Invoker&lt;T&gt;&gt;(); for (Object inv : (Object[]) obj) &#123; invokersCopy.add((Invoker&lt;T&gt;) inv); &#125; &#125; else &#123; invokersCopy = (List&lt;Invoker&lt;T&gt;&gt;) obj; &#125; return invokersCopy; &#125; catch (ScriptException e) &#123; //fail then ignore rule .invokers. logger.error(\"route error , rule has been ignored. rule: \" + rule + \", method:\" + invocation.getMethodName() + \", url: \" + RpcContext.getContext().getUrl(), e); return invokers; &#125; &#125; ScriptRouter æœåŠ¡è·¯ç”±ç›¸å¯¹æ¯”è¾ƒç®€å•ï¼Œä¸»è¦ä¾é  JDK çš„è„šæœ¬å¼•æ“å¯¹è±¡ï¼Œå¯¹è„šæœ¬ç¼–è¯‘ã€æ‰§è¡Œï¼Œæœ€ç»ˆè·å–è·¯ç”±åçš„ Invoker é›†åˆã€‚ FileRouterFactoryFileRouterFactory æ˜¯ ScriptRouterFactory çš„è£…é¥°å™¨ï¼ŒåŸºäºæ–‡ä»¶è¯»å–è·¯ç”±è§„åˆ™ã€‚åœ¨ ScriptRouterFactory åŸºç¡€ä¸Šå¢åŠ äº†è¯»å–æ–‡ä»¶çš„èƒ½åŠ›ï¼Œä½¿ç”¨æ–¹å¯ä»¥å°† ScriptRouter ä½¿ç”¨çš„è·¯ç”±è§„åˆ™ä¿å­˜åˆ°æ–‡ä»¶ä¸­ï¼Œç„¶ååœ¨ URL ä¸­æŒ‡å®šæ–‡ä»¶è·¯å¾„ï¼ŒFileRouterFactory ä»ä¸­è§£æåˆ°è¯¥è„šæœ¬æ–‡ä»¶çš„è·¯å¾„å¹¶è¿›è¡Œè¯»å–ï¼Œç„¶åè°ƒç”¨ ScriptRouterFactory å»åˆ›å»ºç›¸åº”çš„ ScriptRouter å¯¹è±¡ã€‚ å±æ€§12345678910111213141516public class FileRouterFactory implements RouterFactory &#123; /** * æ‹“å±•å */ public static final String NAME = \"file\"; /** * RouterFactory$Adaptive å¯¹è±¡, Dubbo IOCæ³¨å…¥ */ private RouterFactory routerFactory; public void setRouterFactory(RouterFactory routerFactory) &#123; this.routerFactory = routerFactory; &#125;&#125; è·å–è·¯ç”±12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849+--- FileRouterFactory @Override public Router getRouter(URL url) &#123; try &#123; // router é…ç½®é¡¹ï¼Œé»˜è®¤ä¸º script // å°† file åè®®çš„ URL è½¬æ¢æˆ script åè®®çš„ URL // file:///d:/path/to/route.js?router=script ==&gt; script:///d:/path/to/route.js?type=js&amp;rule=&lt;file-content&gt; // 1 è·å– router é…ç½®é¡¹ï¼Œé»˜è®¤ä¸º script // Replace original protocol (maybe 'file') with 'script' String protocol = url.getParameter(Constants.ROUTER_KEY, ScriptRouterFactory.NAME); // ä½¿ç”¨æ–‡ä»¶åç¼€ä½œä¸ºç±»å‹ï¼Œå¦‚ï¼šjsã€groovy String type = null; // 2 è·å–path String path = url.getPath(); // 3 è·å–è„šæœ¬æ–‡ä»¶çš„è¯­è¨€ç±»å‹ if (path != null) &#123; int i = path.lastIndexOf('.'); if (i &gt; 0) &#123; type = path.substring(i + 1); &#125; &#125; // 4 ä»æ–‡ä»¶ä¸­è¯»å–è·¯ç”±è§„åˆ™ï¼Œä½œä¸º ScriptRouter çš„è·¯ç”±è§„åˆ™ String rule = IOUtils.read(new FileReader(new File(url.getAbsolutePath()))); // 5 åˆ›å»ºscriptåè®®çš„URL boolean runtime = url.getParameter(Constants.RUNTIME_KEY, false); // 5.1 protocol å†³å®šä½¿ç”¨å“ªç§è·¯ç”±ï¼Œé»˜è®¤ä¸ºscript URL script = url.setProtocol(protocol) // 5.2 typeï¼Œå¦‚ï¼šjs .addParameter(Constants.TYPE_KEY, type) // 5.3 runtime .addParameter(Constants.RUNTIME_KEY, runtime) // 5.4 è·¯ç”±è§„åˆ™ rule .addParameterAndEncoded(Constants.RULE_KEY, rule); // è·å–scriptå¯¹åº”çš„Routerå®ç° return routerFactory.getRouter(script); &#125; catch (IOException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; æ€»ç»“FileRouterFactory æ ¸å¿ƒæœ‰ä¸¤ç‚¹ï¼šå…¶ä¸€ï¼Œå°†è·¯ç”±è§„åˆ™ä»è„šæœ¬æ–‡ä»¶è¯»å–åˆ°å†…å­˜ï¼Œå°†ä½œä¸ºè„šæœ¬è·¯ç”±çš„è§„åˆ™ï¼›å…¶äºŒï¼Œå®Œæˆ fileåè®® çš„ URL åˆ° scriptåè®® çš„ URL çš„è½¬æ¢ï¼Œå³åŸºäº fileåè®® çš„URL æ„å»ºä¸€ä¸ª scriptåè®® çš„ URL ã€‚æœ‰äº†ä»¥ä¸Šä¸¤ç‚¹ï¼Œå°±å¯ä»¥å®ç°åŸºäº ScriptRouterFactory åŸºç¡€å¢åŠ è¯»å–æ–‡ä»¶å†…å®¹çš„èƒ½åŠ›ã€‚ TagRouterFactory &amp; TagRouteræ ‡ç­¾è·¯ç”±æ˜¯ Dubbo 2.7.x æ”¯æŒçš„è·¯ç”±è§„åˆ™ã€‚ TagRouterFactory12345678910111213@Activate(order = 100)public class TagRouterFactory extends CacheableRouterFactory &#123; /** * æ‰©å±•å */ public static final String NAME = \"tag\"; @Override protected Router createRouter(URL url) &#123; // åˆ›å»º TagRouter return new TagRouter(url); &#125;&#125; TagRouterç®€ä»‹æ ‡ç­¾è·¯ç”±é€šè¿‡å°†æŸä¸€ä¸ªæˆ–å¤šä¸ªæœåŠ¡çš„æä¾›è€…åˆ’åˆ†åˆ°åŒä¸€ä¸ªåˆ†ç»„ï¼Œçº¦æŸæµé‡åªåœ¨æŒ‡å®šåˆ†ç»„ä¸­æµè½¬ï¼Œä»è€Œå®ç°æµé‡éš”ç¦»çš„ç›®çš„ï¼Œå¯ä»¥ä½œä¸ºç°åº¦å‘å¸ƒç­‰åœºæ™¯çš„åŸºç¡€ã€‚ Provideræ ‡ç­¾ä¸»è¦æ˜¯æŒ‡å¯¹ Provider ç«¯åº”ç”¨å®ä¾‹çš„åˆ†ç»„ï¼Œç›®å‰æœ‰ä¸¤ç§æ–¹å¼å¯ä»¥å®Œæˆå®ä¾‹åˆ†ç»„ï¼Œåˆ†åˆ«æ˜¯ åŠ¨æ€è§„åˆ™æ‰“æ ‡ å’Œ é™æ€è§„åˆ™æ‰“æ ‡ ï¼Œå…¶ä¸­åŠ¨æ€è§„åˆ™ç›¸è¾ƒäºé™æ€è§„åˆ™ä¼˜å…ˆçº§æ›´é«˜ï¼Œå½“ä¸¤ç§è§„åˆ™åŒæ—¶å­˜åœ¨ä¸”å‡ºç°å†²çªæ—¶ï¼Œä»¥åŠ¨æ€è§„åˆ™ä¸ºå‡†ã€‚ åŠ¨æ€æ‰“æ ‡å¯éšæ—¶åœ¨ æœåŠ¡æ²»ç†å¹³å° åŠ¨æ€ä¸‹å‘æ ‡ç­¾ 1234567891011121314# governance-tagrouter-provideråº”ç”¨å¢åŠ äº†ä¸¤ä¸ªæ ‡ç­¾åˆ†ç»„tag1å’Œtag2# tag1åŒ…å«ä¸€ä¸ªå®ä¾‹ 127.0.0.1:20880# tag2åŒ…å«ä¸€ä¸ªå®ä¾‹ 127.0.0.1:20881--- force: false runtime: true enabled: true key: governance-tagrouter-provider tags: - name: tag1 addresses: [\"127.0.0.1:20880\"] - name: tag2 addresses: [\"127.0.0.1:20881\"] ... åŠ¨æ€æ‰“æ ‡è§„åˆ™è¯¦è§£ï¼š key æ˜ç¡®è§„åˆ™ä½“ä½œç”¨åˆ°å“ªä¸ªåº”ç”¨ã€‚å¿…å¡«ã€‚ enabled=true å½“å‰è·¯ç”±è§„åˆ™æ˜¯å¦ç”Ÿæ•ˆï¼Œå¯ä¸å¡«ï¼Œç¼ºçœç”Ÿæ•ˆã€‚ force=false å½“è·¯ç”±ç»“æœä¸ºç©ºæ—¶ï¼Œæ˜¯å¦å¼ºåˆ¶æ‰§è¡Œï¼Œå¦‚æœä¸å¼ºåˆ¶æ‰§è¡Œï¼Œè·¯ç”±ç»“æœä¸ºç©ºçš„è·¯ç”±è§„åˆ™å°†è‡ªåŠ¨å¤±æ•ˆï¼Œå¯ä¸å¡«ï¼Œç¼ºçœä¸º falseã€‚ runtime=false æ˜¯å¦åœ¨æ¯æ¬¡è°ƒç”¨æ—¶æ‰§è¡Œè·¯ç”±è§„åˆ™ï¼Œå¦åˆ™åªåœ¨æä¾›è€…åœ°å€åˆ—è¡¨å˜æ›´æ—¶é¢„å…ˆæ‰§è¡Œå¹¶ç¼“å­˜ç»“æœï¼Œè°ƒç”¨æ—¶ç›´æ¥ä»ç¼“å­˜ä¸­è·å–è·¯ç”±ç»“æœã€‚å¦‚æœç”¨äº†å‚æ•°è·¯ç”±ï¼Œå¿…é¡»è®¾ä¸º trueï¼Œéœ€è¦æ³¨æ„è®¾ç½®ä¼šå½±å“è°ƒç”¨çš„æ€§èƒ½ï¼Œå¯ä¸å¡«ï¼Œç¼ºçœä¸º falseã€‚ priority=1 è·¯ç”±è§„åˆ™çš„ä¼˜å…ˆçº§ï¼Œç”¨äºæ’åºï¼Œä¼˜å…ˆçº§è¶Šå¤§è¶Šé å‰æ‰§è¡Œï¼Œå¯ä¸å¡«ï¼Œç¼ºçœä¸º 0ã€‚ tags å®šä¹‰å…·ä½“çš„æ ‡ç­¾åˆ†ç»„å†…å®¹ï¼Œå¯å®šä¹‰ä»»æ„nï¼ˆn&gt;=1ï¼‰ä¸ªæ ‡ç­¾å¹¶ä¸ºæ¯ä¸ªæ ‡ç­¾æŒ‡å®šå®ä¾‹åˆ—è¡¨ã€‚å¿…å¡«ã€‚ nameï¼Œ æ ‡ç­¾åç§° addressesï¼Œå½“å‰æ ‡ç­¾åŒ…å«çš„å®ä¾‹åˆ—è¡¨ï¼ˆæ ‡ç­¾å¯¹åº”çš„æœåŠ¡èŠ‚ç‚¹åœ°å€åˆ—è¡¨ï¼‰ é™æ€æ‰“æ ‡1234&lt;!-- å…¨å±€æœåŠ¡çº§åˆ« --&gt;&lt;dubbo:provider tag=\"tag1\"/&gt;&lt;!--æœåŠ¡æ¥å£çº§åˆ«--&gt;&lt;dubbo:service tag=\"tag1\"/&gt; ConsumerConsumer ç«¯å¯ä»¥åœ¨ RpcContext çš„ attachment ä¸­æ·»åŠ  request.tag é™„åŠ å±æ€§ã€‚ 1234// ç¡¬ç¼–ç RpcContext.getContext().setAttachment(Constants.REQUEST_TAG_KEY,\"tag1\");// é…ç½®&lt;dubbo:reference tag=\"tag1\"/&gt; è¯·æ±‚æ ‡ç­¾çš„ä½œç”¨åŸŸä¸ºæ¯ä¸€æ¬¡ Invocationï¼Œä½¿ç”¨ attachment æ¥ä¼ é€’è¯·æ±‚æ ‡ç­¾ï¼Œæ³¨æ„ä¿å­˜åœ¨ attachment ä¸­çš„å€¼å°†ä¼šåœ¨ä¸€æ¬¡å®Œæ•´çš„è¿œç¨‹è°ƒç”¨ä¸­æŒç»­ä¼ é€’ï¼Œå¾—ç›Šäºè¿™æ ·çš„ç‰¹æ€§ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨èµ·å§‹è°ƒç”¨æ—¶è¿›è¡Œè®¾ç½®ï¼Œå°±å¯ä»¥è¾¾åˆ°æ ‡ç­¾çš„æŒç»­ä¼ é€’ã€‚ æ ‡ç­¾è·¯ç”±è§„åˆ™ å½“è®¾ç½® request.tag=tag1 æ—¶ä¼˜å…ˆé€‰æ‹©æ ‡è®°äº† tag=tag1 çš„ Providerã€‚è‹¥ Provider é›†ç¾¤ä¸­ä¸å­˜åœ¨ä¸è¯·æ±‚ Tag å¯¹åº”çš„ Provider èŠ‚ç‚¹ï¼Œåˆ™é»˜è®¤å°†é™çº§è¯·æ±‚ Tag ä¸ºç©ºçš„ Provider èŠ‚ç‚¹ï¼›å¦‚æœå¸Œæœ›åœ¨æ‰¾ä¸åˆ°åŒ¹é… Tag çš„ Provider èŠ‚ç‚¹æ—¶æŠ›å‡ºå¼‚å¸¸ï¼Œéœ€è¦è®¾ç½® request.tag.force=true ã€‚ å½“ request.tag æœªè®¾ç½®æ—¶ï¼Œåªä¼šåŒ¹é… Tag ä¸ºç©ºçš„ Provider èŠ‚ç‚¹ï¼Œå³ä½¿é›†ç¾¤ä¸­å­˜åœ¨å¯ç”¨çš„æœåŠ¡ï¼Œè‹¥ Tag ä¸åŒ¹é…ä¹Ÿæ— æ³•è°ƒç”¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼šæºå¸¦ Tag çš„è¯·æ±‚å¯ä»¥é™çº§è®¿é—®åˆ°æ—  Tag çš„ Providerï¼Œä½†ä¸æºå¸¦ Tag çš„è¯·æ±‚æ°¸è¿œæ— æ³•è®¿é—®åˆ°å¸¦æœ‰ Tag çš„ Providerã€‚ Tag ä½¿ç”¨åŸºäº Tag çš„æµ‹è¯•ç¯å¢ƒéš”ç¦»æ–¹æ¡ˆ åœ¨å¼€å‘æµ‹è¯•ä¸­ï¼Œå¦‚æœé’ˆå¯¹æ¯ä¸ªéœ€æ±‚åˆ†åˆ«ç‹¬ç«‹å‡ºä¸€å¥—æµ‹è¯•ç¯å¢ƒçš„è¯ï¼Œä¼šå ç”¨å¤§é‡æœºå™¨å¹¶ä¸”ç»´æŠ¤æˆæœ¬ä¹Ÿéƒ½æ¯”è¾ƒé«˜ã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡æ ‡ç­¾è·¯ç”±å®ç°ç¯å¢ƒéš”ç¦»ï¼Œå¯¹ Provider è¿›è¡Œæ‰“æ ‡ï¼Œæ¶ˆè´¹æ–¹é…ç½®ç›®æ ‡æœåŠ¡çš„æ ‡ç­¾å³å¯ã€‚ å±æ€§1234567891011121314151617181920212223public class TagRouter extends AbstractRouter implements ConfigurationListener &#123; private static final Logger logger = LoggerFactory.getLogger(TagRouter.class); public static final String NAME = \"TAG_ROUTER\"; /** * ä¼˜å…ˆçº§ */ private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100; private static final String RULE_SUFFIX = \".tag-router\"; private String application; /** * æ ‡ç­¾è·¯ç”±è§„åˆ™ */ private TagRouterRule tagRouterRule; public TagRouter(URL url) &#123; super(url); // è®¾ç½®ä¼˜å…ˆçº§ this.priority = TAG_ROUTER_DEFAULT_PRIORITY; &#125;&#125; åœ¨ TagRouter ä¸­æŒæœ‰ TagRouterRule å¯¹è±¡å¼•ç”¨ï¼Œå®ƒè¡¨ç¤ºä¸€ä¸ªæ ‡ç­¾è·¯ç”±è§„åˆ™ï¼Œè¯¥å¯¹è±¡ä¸»è¦ç”¨äºåŠ¨æ€æ‰“æ ‡çš„æ–¹å¼ï¼Œä¸‹é¢æˆ‘ä»¬å¯¹å…¶è¿›è¡Œç®€å•ä»‹ç»ã€‚ TagRouterRule123456789101112131415161718192021222324252627282930313233343536public class TagRouterRule extends AbstractRouterRule &#123; /** * Tag é›†åˆ */ private List&lt;Tag&gt; tags; /** * address åˆ° tag åç§°çš„æ˜ å°„ */ private Map&lt;String, List&lt;String&gt;&gt; addressToTagnames = new HashMap&lt;&gt;(); /** * tag åç§°åˆ° address çš„æ˜ å°„ */ private Map&lt;String, List&lt;String&gt;&gt; tagnameToAddresses = new HashMap&lt;&gt;(); /** * æ ¹æ® Tag é›†åˆåˆå§‹åŒ– addressToTagnames å’Œ tagnameToAddresses */ public void init() &#123; if (!isValid()) &#123; return; &#125; tags.stream().filter(tag -&gt; CollectionUtils.isNotEmpty(tag.getAddresses())).forEach(tag -&gt; &#123; // tag åç§° åˆ° address çš„æ˜ å°„ tagnameToAddresses.put(tag.getName(), tag.getAddresses()); // address åˆ° tag åç§°çš„æ˜ å°„ tag.getAddresses().forEach(addr -&gt; &#123; List&lt;String&gt; tagNames = addressToTagnames.computeIfAbsent(addr, k -&gt; new ArrayList&lt;&gt;()); tagNames.add(tag.getName()); &#125;); &#125;); &#125; // çœç•¥è·å– Tag é›†åˆä¸­åœ°å€ã€æ ‡ç­¾åä¿¡æ¯ç­‰æ–¹æ³•&#125; TagRouterRule ä¸»è¦ä¸ºåŠ¨æ€æ‰“æ ‡æœåŠ¡ï¼Œç»§æ‰¿äº† AbstractRouterRule , å…¶ä¸­å®šä¹‰äº†è·¯ç”±è§„åˆ™çš„å…¬ç”¨å±æ€§ã€‚ AbstractRouterRule1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class AbstractRouterRule &#123; /** * è·¯ç”±è§„åˆ™è§£æå‰çš„åŸå§‹å­—ç¬¦ä¸²é…ç½® */ private String rawRule; /** * è¡¨ç¤ºæ˜¯å¦åœ¨æ¯æ¬¡è°ƒç”¨æ—¶æ‰§è¡Œè¯¥è·¯ç”±è§„åˆ™ã€‚ * å¦‚æœè®¾ç½®ä¸º falseï¼Œåˆ™ä¼šåœ¨ Provider åˆ—è¡¨å˜æ›´æ—¶é¢„å…ˆæ‰§è¡Œå¹¶ç¼“å­˜ç»“æœï¼Œè°ƒç”¨æ—¶ç›´æ¥ä»ç¼“å­˜ä¸­è·å–è·¯ç”±ç»“æœã€‚ */ private boolean runtime = true; /** * å½“è·¯ç”±ç»“æœä¸ºç©ºæ—¶ï¼Œæ˜¯å¦å¼ºåˆ¶æ‰§è¡Œï¼Œå¦‚æœä¸å¼ºåˆ¶æ‰§è¡Œï¼Œè·¯ç”±ç»“æœä¸ºç©ºçš„è·¯ç”±è§„åˆ™å°†è‡ªåŠ¨å¤±æ•ˆã€‚è¯¥å­—æ®µé»˜è®¤å€¼ä¸º falseã€‚ */ private boolean force = false; /** * æ ‡è¯†è§£æç”Ÿæˆå½“å‰ RouterRule å¯¹è±¡çš„é…ç½®æ˜¯å¦åˆæ³•ã€‚ */ private boolean valid = true; /** * æ ‡è¯†å½“å‰è·¯ç”±è§„åˆ™æ˜¯å¦ç”Ÿæ•ˆã€‚ */ private boolean enabled = true; /** * ç”¨äºè¡¨ç¤ºå½“å‰ RouterRule çš„ä¼˜å…ˆçº§ã€‚ */ private int priority; /** * è¡¨ç¤ºè¯¥è·¯ç”±è§„åˆ™æ˜¯å¦ä¸ºæŒä¹…æ•°æ®ï¼Œå½“æ³¨å†Œæ–¹é€€å‡ºæ—¶ï¼Œè·¯ç”±è§„åˆ™æ˜¯å¦ä¾ç„¶å­˜åœ¨ã€‚ */ private boolean dynamic = false; /** * èŒƒå›´ï¼šapplication/service */ private String scope; /** * æ˜ç¡®è§„åˆ™ä½“ä½œç”¨åœ¨å“ªä¸ªæœåŠ¡æˆ–åº”ç”¨ * 1 scope ä¸º service: ç”± [&#123;group&#125;:]&#123;service&#125;[:&#123;version&#125;] æ„æˆ * 2 scope ä¸º application: application */ private String key;&#125; æ­¤å¤–ï¼ŒTagRouterRule ä¸­ç»´æŠ¤äº†ä¸€ä¸ª Tag é›†åˆï¼Œå› ä¸ºä¸€ä¸ªæ ‡ç­¾è·¯ç”±è§„åˆ™æ”¯æŒå¤šä¸ª Tagï¼Œè€Œæ¯ä¸ª Tag å¯¹è±¡ä¸­ç»´æŠ¤äº†ä¸€ä¸ª Tag åç§°ï¼Œä»¥åŠè¯¥ Tag ç»‘å®šçš„æœåŠ¡èŠ‚ç‚¹ç½‘ç»œåœ°å€é›†åˆã€‚ Tag12345678910public class Tag &#123; /** * Tag åç§° */ private String name; /** * Tag ç»‘å®šçš„ç½‘ç»œåœ°å€é›†åˆ */ private List&lt;String&gt; addresses;&#125; æ ‡ç­¾è·¯ç”±è§„åˆ™å¦‚ä¸‹ï¼š è§£ææ ‡ç­¾è·¯ç”±è§„åˆ™TagRouter å®ç°äº† ConfigurationListener æ¥å£ï¼Œç”¨äºç›‘å¬é…ç½®çš„å˜åŒ–ï¼Œç”¨äºæ›´æ–°åŠ¨æ€æ‰“æ ‡ä¿¡æ¯ï¼Œå…¶ä¸­å°±åŒ…æ‹¬ TagRouterRule é…ç½®çš„å˜æ›´ã€‚ 12345678910111213141516171819202122232425262728+--- TagRouter /** * ç›‘å¬é…ç½®çš„å˜åŒ– * * @param event config change event */ @Override public synchronized void process(ConfigChangedEvent event) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Notification of tag rule, change type is: \" + event.getChangeType() + \", raw rule is:\\n \" + event.getContent()); &#125; try &#123; // 1 DELETED äº‹ä»¶ä¼šç›´æ¥æ¸…ç©º tagRouterRule if (event.getChangeType().equals(ConfigChangeType.DELETED)) &#123; this.tagRouterRule = null; // 2 å…¶å®ƒäº‹ä»¶ä¼šè§£ææœ€æ–°çš„è·¯ç”±è§„åˆ™ï¼Œå¹¶è®°å½•åˆ° tagRouterRule å­—æ®µä¸­ &#125; else &#123; // é€šè¿‡ TagRuleParser è§£æé…ç½® this.tagRouterRule = TagRuleParser.parse(event.getContent()); &#125; &#125; catch (Exception e) &#123; logger.error(\"Failed to parse the raw tag router rule and it will not take effect, please check if the \" + \"rule matches with the template, the raw rule is:\\n \", e); &#125; &#125; TagRuleParser ç”¨äºè§£æ yaml æ ¼å¼çš„ TagRouterRule é…ç½®ï¼Œå°†è§„åˆ™é…ç½®ä¿¡æ¯è¯»å…¥åˆ° TagRouterRule ä¸­ã€‚ æœåŠ¡è·¯ç”±è·¯ç”±çš„æœ€ç»ˆç›®çš„æ˜¯è¦è¿‡æ»¤ç¬¦åˆæ¡ä»¶çš„ Invoker å¯¹è±¡ï¼Œä¸‹é¢æˆ‘ä»¬å°±æ¥çœ‹ TagRouter æ˜¯å¦‚ä½•ä½¿ç”¨ TagRouterRule è·¯ç”±é€»è¾‘è¿›è¡Œ Invoker è¿‡æ»¤çš„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889+--- TagRouter /*** * æœåŠ¡è·¯ç”± * @param invokers invoker list * @param url refer url * @param invocation invocation * @param &lt;T&gt; * @return * @throws RpcException */ @Override public &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException &#123; // 1 å¦‚æœ invokers ä¸ºç©ºï¼Œç›´æ¥è¿”å›ç©ºé›†åˆ if (CollectionUtils.isEmpty(invokers)) &#123; return invokers; &#125; // 2 ä¼˜å…ˆä½¿ç”¨åŠ¨æ€è§„åˆ™ // æ£€æŸ¥åŠ¨æ€è§„åˆ™ tagRouterRule æ˜¯å¦å¯ç”¨ï¼Œå¦‚æœä¸å¯ç”¨ï¼Œåˆ™è°ƒç”¨ filterUsingStaticTag æ–¹æ³•ä½¿ç”¨é™æ€è§„åˆ™è¿›è¡Œè¿‡æ»¤ final TagRouterRule tagRouterRuleCopy = tagRouterRule; if (tagRouterRuleCopy == null || !tagRouterRuleCopy.isValid() || !tagRouterRuleCopy.isEnabled()) &#123; return filterUsingStaticTag(invokers, url, invocation); &#125; // ä½¿ç”¨åŠ¨æ€è§„åˆ™ List&lt;Invoker&lt;T&gt;&gt; result = invokers; // 3 è·å–æ­¤æ¬¡è¯·æ±‚çš„ tag ä¿¡æ¯ï¼Œå°è¯•ä» Invocation ä»¥åŠ URL ä¸­è·å– String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) : invocation.getAttachment(TAG_KEY); // 4 æ­¤æ¬¡è¯·æ±‚æŒ‡å®šäº† tag (ä¼˜å…ˆé€‰æ‹©tagå¯¹åº”çš„Providerï¼Œå¦‚æœæ²¡æœ‰Provideråˆ™é™çº§å¤„ç†ï¼Œé€‰æ‹© tag ä¸ºç©ºçš„ Provider) if (StringUtils.isNotEmpty(tag)) &#123; // 4.1 ä»åŠ¨æ€è§„åˆ™ä¸­è·å–è¯·æ±‚ tag å¯¹åº”çš„ address é›†åˆ List&lt;String&gt; addresses = tagRouterRuleCopy.getTagnameToAddresses().get(tag); if (CollectionUtils.isNotEmpty(addresses)) &#123; // 4.1.2 æ ¹æ®è¯·æ±‚ tag å¯¹åº”çš„ address é›†åˆå»åŒ¹é…ç¬¦åˆæ¡ä»¶çš„ Invoker result = filterInvoker(invokers, invoker -&gt; addressMatches(invoker.getUrl(), addresses)); // å¦‚æœå­˜åœ¨ç¬¦åˆæ¡ä»¶çš„Invokerï¼Œåˆ™ç›´æ¥å°†è¿‡æ»¤å¾—åˆ°çš„Invokeré›†åˆè¿”å›ã€‚å¦åˆ™ï¼Œæ ¹æ®forceé…ç½®å†³å®šæ˜¯å¦è¿”å›ç©ºInvokeré›†åˆ if (CollectionUtils.isNotEmpty(result) || tagRouterRuleCopy.isForce()) &#123; return result; &#125; // 4.2 å¦‚æœè¯·æ±‚ tag æ²¡æœ‰å¯¹åº” address &#125; else &#123; // 4.2.1 å°†è¯·æ±‚æºå¸¦çš„ tag ä¸ Provider URL ä¸­çš„ tag å‚æ•°å€¼è¿›è¡Œæ¯”è¾ƒï¼ŒåŒ¹é…å‡ºç¬¦åˆæ¡ä»¶çš„ Invoker é›†åˆã€‚ result = filterInvoker(invokers, invoker -&gt; tag.equals(invoker.getUrl().getParameter(TAG_KEY))); &#125; // 4.3 å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„Invoker æˆ–æ˜¯ force=trueï¼Œåˆ™ç›´æ¥è¿”å›è¿‡æ»¤åçš„ç»“æœ if (CollectionUtils.isNotEmpty(result) || isForceUseTag(invocation)) &#123; return result; &#125; // 4.4 å¦‚æœ Invoker è¿‡æ»¤åçš„ç»“æœä¸ºç©ºï¼Œä¸” force é…ç½®ä¸º falseï¼Œåˆ™è¿”å›æ‰€æœ‰ä¸åŒ…å«ä»»ä½• tag çš„ Provider åˆ—è¡¨ã€‚(é™çº§) // FAILOVER: return all Providers without any tags. else &#123; List&lt;Invoker&lt;T&gt;&gt; tmp = filterInvoker(invokers, invoker -&gt; addressNotMatches(invoker.getUrl(), tagRouterRuleCopy.getAddresses())); return filterInvoker(tmp, invoker -&gt; StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY))); &#125; // 5 å¦‚æœæ­¤æ¬¡è¯·æ±‚æœªæºå¸¦ tag ä¿¡æ¯ï¼ˆåªåŒ¹é…tagä¸ºç©ºçš„Provierï¼‰ &#125; else &#123; // List&lt;String&gt; addresses = tagRouterRule.filter(providerApp); // return all addresses in dynamic tag group. // 5.1 è·å– TagRouterRule è§„åˆ™ä¸­å…¨éƒ¨ tag å…³è”çš„ address é›†åˆ List&lt;String&gt; addresses = tagRouterRuleCopy.getAddresses(); // 5.2 å¦‚æœ address é›†åˆä¸ä¸ºç©ºï¼Œåˆ™è¿‡æ»¤å‡ºä¸åœ¨ address é›†åˆä¸­çš„ Invoker å¹¶æ·»åŠ åˆ°ç»“æœé›†åˆä¸­ã€‚ if (CollectionUtils.isNotEmpty(addresses)) &#123; result = filterInvoker(invokers, invoker -&gt; addressNotMatches(invoker.getUrl(), addresses)); // 1. all addresses are in dynamic tag group, return empty list. if (CollectionUtils.isEmpty(result)) &#123; return result; &#125; // 2. if there are some addresses that are not in any dynamic tag group, continue to filter using the // static tag group. &#125; // 5.3 å°† Provider URL ä¸­çš„ tag å€¼ä¸ TagRouterRule ä¸­çš„ tag åç§°è¿›è¡Œæ¯”è¾ƒï¼Œè¿‡æ»¤å‡ºä¸åŒ¹é…çš„ tagï¼Œå¾—åˆ°æœ€ç»ˆçš„ Invoker é›†åˆã€‚ return filterInvoker(result, invoker -&gt; &#123; String localTag = invoker.getUrl().getParameter(TAG_KEY); return StringUtils.isEmpty(localTag) || !tagRouterRuleCopy.getTagNames().contains(localTag); &#125;); &#125; &#125; è¿›è¡Œæ ‡ç­¾è·¯ç”±æ—¶ï¼Œå¦‚æœåŠ¨æ€è§„åˆ™ä¸ºç©ºæˆ–ä¸å¯ç”¨ï¼Œåˆ™ä½¿ç”¨é™æ€è§„åˆ™ã€‚ä½¿ç”¨é™æ€è§„åˆ™è·¯ç”±è§„åˆ™å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627+--- TagRouter private &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; filterUsingStaticTag(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123; List&lt;Invoker&lt;T&gt;&gt; result = invokers; // 1 è·å–è¯·æ±‚æºå¸¦çš„ tag // Dynamic param String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) : invocation.getAttachment(TAG_KEY); // 2 è¯·æ±‚æºå¸¦äº† tag // Tag request if (!StringUtils.isEmpty(tag)) &#123; // 2.1 æ¯”è¾ƒè¯·æ±‚æºå¸¦çš„ tag å€¼ä¸ Provider URL ä¸­çš„ tag å‚æ•°å€¼ result = filterInvoker(invokers, invoker -&gt; tag.equals(invoker.getUrl().getParameter(TAG_KEY))); // 2.2 é›†ç¾¤ä¸­ä¸å­˜åœ¨ä¸è¯·æ±‚tagå¯¹åº”çš„æœåŠ¡ï¼Œé»˜è®¤é™çº§è¯·æ±‚ tag ä¸ºç©ºçš„ Providerã€‚ if (CollectionUtils.isEmpty(result) &amp;&amp; !isForceUseTag(invocation)) &#123; result = filterInvoker(invokers, invoker -&gt; StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY))); &#125; // 3 è¯·æ±‚æ²¡æœ‰æºå¸¦ tagï¼Œåªä¼šåŒ¹é… tag ä¸ºç©ºçš„ Provider ã€‚ &#125; else &#123; result = filterInvoker(invokers, invoker -&gt; StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY))); &#125; return result; &#125; ä»ä»£ç å±‚é¢ä¸ŠéªŒè¯äº†å‰æ–‡æåˆ°çš„æ ‡ç­¾è·¯ç”±è§„åˆ™ï¼Œä¸‹é¢å¯¹æœåŠ¡è·¯ç”±è¿›è¡Œæ¦‚è¿°ï¼š è¯·æ±‚æŒ‡å®šäº†tagä¿¡æ¯ ä¼˜å…ˆé€‰æ‹©tagå¯¹åº”çš„Provider é™çº§è¯·æ±‚tagä¸ºç©ºçš„provider è¯·æ±‚æœªæŒ‡å®štagä¿¡æ¯ åªéœ€åŒ¹é…tagä¸ºç©ºçš„Provider æ€»ç»“æ ‡ç­¾è·¯ç”±æ˜¯é€šè¿‡åŠ¨æ€æˆ–é™æ€æ‰“æ ‡çš„æ–¹å¼ä¸ºæœåŠ¡æä¾›è€…è®¾ç½® Tagã€‚å…¶ä¸­åŠ¨æ€æ‰“æ ‡æ–¹å¼çš„è§„åˆ™å­˜å‚¨åˆ° TagRouterRule å¯¹è±¡ä¸­ï¼Œæ˜¯é€šè¿‡ &lt;tagåç§°ï¼ŒProviderèŠ‚ç‚¹åœ°å€é›†åˆ&gt; æ˜ å°„å…³ç³»ä½“ç°è¿‡æ»¤è§„åˆ™çš„ã€‚é™æ€æ‰“æ ‡æ–¹å¼çš„è§„åˆ™æ˜¯ä½œä¸ºé…ç½®ä¿¡æ¯å­˜å‚¨åˆ°æä¾›è€…URLä¸­çš„ï¼Œæ˜¯é€šè¿‡ tag å‚æ•°ä½“ç°è¿‡æ»¤è§„åˆ™çš„ã€‚å½“æ¶ˆè´¹è¯·æ±‚è¿›æ¥ï¼Œä¼šé€šè¿‡ TagRouterRule å’Œ tag å‚æ•°è¿›è¡Œ Invoker åˆ—è¡¨çš„è¿‡æ»¤ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« ä¸­å¯¹ æ¡ä»¶è·¯ç”±ã€è„šæœ¬è·¯ç”±ã€æ–‡ä»¶è·¯ç”± è¿›è¡Œäº†ä»‹ç»ï¼Œæœ€åå¯¹ Dubbo 2.7.x ä¸­æ–°æ”¯æŒçš„ æ ‡ç­¾è·¯ç”± è¿›è¡Œäº†ä»‹ç»ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"é›†ç¾¤å®¹é”™ - åŠ¨æ€é…ç½®","slug":"rpc/é›†ç¾¤å®¹é”™ä¹‹DubboåŠ¨æ€é…ç½®","date":"2020-09-22T23:00:00.000Z","updated":"2021-04-06T08:32:25.772Z","comments":false,"path":"posts/a965bdb8/","link":"","permalink":"https://gentryhuang.com/posts/a965bdb8/","excerpt":"","text":"æ¦‚è¿°åœ¨ä»‹ç»åŠ¨æ€æœåŠ¡ç›®å½• RegistryDirectory ç›¸å…³å†…å®¹æ—¶ï¼Œæåˆ°äº† RegistryDirectory ä¼šç›‘å¬æ³¨å†Œä¸­å¿ƒçš„ providersã€routers å’Œ configurators ä¸‰ä¸ªç›®å½•ï¼Œå½“é…ç½®å˜æ›´æ—¶ä¼šåšå‡ºç›¸åº”çš„å¤„ç†ã€‚æ­¤å¤–åœ¨æœåŠ¡æš´éœ²è¿‡ç¨‹ä¸­ï¼ŒæœåŠ¡æä¾›è€…ä¼šå‘æ³¨å†Œä¸­å¿ƒæ³¨å†Œç›‘å¬å™¨ï¼Œç›‘å¬ configurators ç›®å½•ä¸‹æ•°æ®çš„å˜æ›´ã€‚æœ¬ç¯‡æ–‡ç« å¯¹ Dubbo åŠ¨æ€é…ç½®è¿›è¡Œåˆ†æï¼Œå¹¶å¯¹ Configurator çš„é›†æˆè¿›è¡Œä»‹ç»ã€‚Configurator ç›¸å…³ç±»å›¾å¦‚ä¸‹ï¼š è¦†ç›–è§„åˆ™æ˜¯ Dubbo è®¾è®¡çš„åœ¨æ— éœ€é‡å¯åº”ç”¨çš„æƒ…å†µä¸‹ï¼ŒåŠ¨æ€è°ƒæ•´ RPC è°ƒç”¨è¡Œä¸ºçš„ä¸€ç§èƒ½åŠ›ã€‚ä» 2.7.0 ç‰ˆæœ¬å¼€å§‹ï¼Œæ”¯æŒä»æœåŠ¡å’Œåº”ç”¨ä¸¤ä¸ªç²’åº¦æ¥è°ƒæ•´åŠ¨æ€é…ç½®ã€‚ åŸºç¡€åè®®åœ¨åˆ†ææºç ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆäº†è§£ä¸‹åŠ¨æ€é…ç½®çš„ä¸¤ç§åè®®ã€‚ä¸‹é¢ä»¥ override åè®®ä¸ºä¾‹ï¼š override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;enabled=true&amp;application=foo&amp;timeout=1000 ä¸‹é¢å¯¹ä¸Šè¿° URL è¿›è¡Œè§£æï¼š override:// è¡¨ç¤ºæ•°æ®é‡‡ç”¨è¦†ç›–æ–¹å¼ï¼ŒDubbo æ”¯æŒ override å’Œ absent ä¸¤ç§åè®®ï¼Œå¯æ‰©å±•ï¼Œå¿…å¡«ã€‚ 0.0.0.0 è¡¨ç¤ºå¯¹æ‰€æœ‰ IP åœ°å€ç”Ÿæ•ˆï¼Œå¦‚æœåªæƒ³è¦†ç›–æŸä¸ª IP çš„æ•°æ®ï¼Œè¯·å¡«å…¥å…·ä½“ IPï¼Œå¿…å¡«ã€‚ com.foo.BarService è¡¨ç¤ºåªå¯¹æŒ‡å®šçš„æœåŠ¡ç”Ÿæ•ˆï¼Œå¿…å¡«ã€‚ category=configurators è¡¨ç¤ºè¯¥ URL ä¸ºåŠ¨æ€é…ç½®ç±»å‹ï¼Œå¿…å¡«ã€‚ dynamic=false è¡¨ç¤ºè¯¥ URL ä¸ºæŒä¹…æ•°æ®ï¼Œå³ä½¿æ³¨å†Œè¯¥ URL çš„èŠ‚ç‚¹é€€å‡ºï¼Œè¯¥ URL ä¾æ—§ä¼šä¿å­˜åœ¨æ³¨å†Œä¸­å¿ƒï¼Œå¿…å¡«ã€‚ enabled=true è¡¨ç¤ºè¯¥ URL çš„è¦†ç›–è§„åˆ™ç”Ÿæ•ˆï¼Œå¯ä¸å¡«ï¼Œç¼ºçœç”Ÿæ•ˆã€‚ application=foo è¡¨ç¤ºåªå¯¹æŒ‡å®šåº”ç”¨ç”Ÿæ•ˆï¼Œå¯ä¸å¡«ï¼Œè¡¨ç¤ºå¯¹æ‰€æœ‰åº”ç”¨ç”Ÿæ•ˆã€‚ timeout=1000 è¡¨ç¤ºå°†æ»¡è¶³ä»¥ä¸Šæ¡ä»¶çš„ URL ä¸­çš„ timeout å‚æ•°çš„å€¼è¦†ç›–ä¸º 1000 ã€‚å¦‚æœæƒ³è¦†ç›–å…¶ä»–é…ç½®ï¼Œå¯ä»¥ç›´æ¥ä»¥å‚æ•°çš„å½¢å¼æ·»åŠ åˆ° override URL ä¹‹ä¸Šã€‚ ä½¿ç”¨ç¤ºä¾‹ï¼š ç¦ç”¨æŸä¸ªæä¾›è€…ï¼ˆé€šå¸¸ç”¨äºä¸´æ—¶å‰”é™¤æŸä¸ª Provider èŠ‚ç‚¹ï¼‰ override://10.20.153.10/com.foo.BarService?category=configurators&amp;dynamic=false&amp;disbaled=true è°ƒæ•´æŸä¸ªæä¾›è€…çš„æƒé‡ï¼ˆé€šå¸¸ç”¨äºå®¹é‡è¯„ä¼°ï¼Œç¼ºçœæƒé‡ä¸º 100ï¼‰ override://10.20.153.10/com.foo.BarService?category=configurators&amp;dynamic=false&amp;weight=200 è°ƒæ•´è´Ÿè½½å‡è¡¡ç­–ç•¥ï¼ˆç¼ºçœè´Ÿè½½å‡è¡¡ç­–ç•¥ä¸º randomï¼‰ override://10.20.153.10/com.foo.BarService?category=configurators&amp;dynamic=false&amp;loadbalance=leastactive æœåŠ¡é™çº§ï¼ˆé€šå¸¸ç”¨äºä¸´æ—¶å±è”½æŸä¸ªå‡ºé”™çš„éå…³é”®æœåŠ¡ï¼‰ override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null æºç åˆ†æConfiguratorFactory123456789101112@SPIpublic interface ConfiguratorFactory &#123; /** * åˆ›å»º Configurator é…ç½®è§„åˆ™å¯¹è±¡ * * @param url - configurator url. * @return configurator instance. */ @Adaptive(\"protocol\") Configurator getConfigurator(URL url);&#125; ConfiguratorFactory æ˜¯ Dubbo çš„ä¸€ä¸ªæ‰©å±•ç‚¹ï¼Œæ²¡æœ‰é»˜è®¤çš„æ‰©å±•å®ç°ã€‚ä½œä¸º Configurator å·¥å‚æ¥å£ï¼Œå…¶ä¸­çš„ @Adaptive(&quot;protocol&quot;) æ³¨è§£ä¼šåŸºäº Dubbo è‡ªé€‚åº”æ‰©å±•æœºåˆ¶è·å– ConfiguratorFactory å…·ä½“å®ç°ï¼Œå³æ ¹æ®é…ç½®è§„åˆ™ URL çš„ protocol å±æ€§è·å– Configurator å®ç°ã€‚ç›®å‰é…ç½® URL çš„åè®®æ”¯æŒ override å’Œ absent ä¸¤ç§ï¼Œå¯¹åº”çš„å®ç°åˆ†åˆ«ä¸º OverrideConfiguratorFactory å’Œ AbsentConfiguratorFactory ã€‚ OverrideConfiguratorFactory1234567public class OverrideConfiguratorFactory implements ConfiguratorFactory &#123; @Override public Configurator getConfigurator(URL url) &#123; // åˆ›å»º OverrideConfigurator å¯¹è±¡ return new OverrideConfigurator(url); &#125;&#125; AbsentConfiguratorFactory12345678public class AbsentConfiguratorFactory implements ConfiguratorFactory &#123; @Override public Configurator getConfigurator(URL url) &#123; // åˆ›å»º AbsentConfigurator return new AbsentConfigurator(url); &#125;&#125; Configurator123456789101112131415161718public interface Configurator extends Comparable&lt;Configurator&gt; &#123; /** * è·å¾—é…ç½®URLï¼Œé‡Œé¢å¸¦æœ‰é…ç½®è§„åˆ™ * * @return configurator url. */ URL getUrl(); /** * å°† Configurator åº”ç”¨åˆ° URL * * @param url - old rovider url. * @return new provider url. */ URL configure(URL url);&#125; Configurator æ¥å£æŠ½è±¡äº†ä¸€æ¡é…ç½®ä¿¡æ¯ï¼Œå³ä¸€ä¸ª Configurator å¯¹è±¡å¯¹åº”ä¸€æ¡é…ç½®è§„åˆ™ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¯¥æ¥å£å®ç°äº† Comparable æ¥å£ï¼Œå› ä¸º Configurator æœ‰ä¼˜å…ˆçº§çš„è¦æ±‚ã€‚ AbstractConfiguratorAbstractConfigurator ä½œä¸º Configurator æŠ½è±¡å®ç°ç±»ï¼Œå®ç°äº†å…¬ç”¨çš„é…ç½®è§„åˆ™çš„åŒ¹é…ã€æ’åºé€»è¾‘ï¼Œå°†é…ç½®è§„åˆ™åº”ç”¨åˆ°ç›®æ ‡ URL ä¸Šçš„å·¥ä½œäº¤ç»™äº†å…·ä½“å­ç±»å®Œæˆã€‚ è·å–é…ç½®è§„åˆ™1234567891011121314151617181920212223public abstract class AbstractConfigurator implements Configurator &#123; /** * é…ç½®è§„åˆ™url */ private final URL configuratorUrl; public AbstractConfigurator(URL url) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"configurator url == null\"); &#125; this.configuratorUrl = url; &#125; /** * è·å¾—é…ç½®è§„åˆ™URL * * @return */ @Override public URL getUrl() &#123; return configuratorUrl; &#125;&#125; åº”ç”¨é…ç½®å‡†å¤‡å·¥ä½œ123456789101112131415161718192021222324252627282930313233343536373839+--- AbstractConfigurator /** * è®¾ç½®é…ç½®è§„åˆ™åˆ°æŒ‡å®šURlä¸­ * * @param url å¾…åº”ç”¨é…ç½®è§„åˆ™çš„URL * @return */ @Override public URL configure(URL url) &#123; // 1 å‚æ•°æ£€æŸ¥ï¼Œé…ç½®è§„åˆ™ä¸­å¿…é¡»è¦æœ‰ ip if (configuratorUrl == null || configuratorUrl.getHost() == null || url == null || url.getHost() == null) &#123; return url; &#125; // 2 é…ç½®è§„åˆ™Urlæœ‰ç«¯å£ï¼Œåˆ™è¯´æ˜è¿™ä¸ªé…ç½®è§„åˆ™Urlæ˜¯æ“ä½œæŸä¸ªæœåŠ¡æä¾›è€…çš„ï¼Œå¯ä»¥é€šè¿‡é…ç½®Urlçš„ç‰¹æ€§å‚æ•°æ¥æ§åˆ¶æœåŠ¡æä¾›è€…ã€‚é…ç½®æˆåŠŸåï¼Œæ—¢å¯ä»¥åœ¨æœåŠ¡æä¾›è€…ç«¯ç”Ÿæ•ˆä¹Ÿå¯ä»¥åœ¨æœåŠ¡æ¶ˆè´¹ç«¯ç”Ÿæ•ˆã€‚ if (configuratorUrl.getPort() != 0) &#123; // é…ç½®è§„åˆ™Urlæœ‰ç«¯å£ï¼Œä¸”å’Œå¾…å¤„ç†çš„urlçš„ç«¯å£ä¸€è‡´ if (url.getPort() == configuratorUrl.getPort()) &#123; // å› ä¸ºæ“ä½œçš„æ˜¯æœåŠ¡æä¾›è€…ï¼Œæ‰€ä»¥è¿™é‡Œä½¿ç”¨çš„æ˜¯urlçš„host return configureIfMatch(url.getHost(), url); &#125; // 3 é…ç½®è§„åˆ™Urlæ²¡æœ‰ç«¯å£ &#125; else &#123; // 3.1 å¦‚æœ url æ˜¯æ¶ˆè´¹ç«¯åœ°å€ï¼Œç›®çš„æ˜¯æ§åˆ¶ä¸€ä¸ªç‰¹å®šçš„æ¶ˆè´¹è€…å®ä¾‹ï¼Œåªåœ¨æ¶ˆè´¹ç«¯ç”Ÿæ•ˆï¼ŒæœåŠ¡ç«¯æ”¶åˆ°åå¿½ç•¥ if (url.getParameter(Constants.SIDE_KEY, Constants.PROVIDER).equals(Constants.CONSUMER)) &#123; // NetUtils.getLocalHost() æ˜¯æ¶ˆè´¹ç«¯æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒçš„åœ°å€ return configureIfMatch(NetUtils.getLocalHost(), url); // 3.2 å¦‚æœ url æ˜¯æœåŠ¡ç«¯åœ°å€ï¼Œæ„å›¾åŒ¹é…å…¨éƒ¨æœåŠ¡æä¾›è€…ã€‚ã€æ³¨æ„ï¼šè¿™ç§æƒ…å†µæš‚ä¸æ”¯æŒæŒ‡å®šæœºå™¨æœåŠ¡æä¾›è€…ã€‘ &#125; else if (url.getParameter(Constants.SIDE_KEY, Constants.CONSUMER).equals(Constants.PROVIDER)) &#123; // å¯¹æ‰€æœ‰æœåŠ¡ç«¯ç”Ÿæ•ˆï¼Œå› æ­¤åœ°å€å¿…é¡»æ˜¯0.0.0.0ï¼Œå¦åˆ™å®ƒå°†ä¸ä¼šæ‰§è¡Œåˆ°æ­¤ifåˆ†æ”¯ return configureIfMatch(Constants.ANYHOST_VALUE, url); &#125; &#125; return url; &#125; configure æ–¹æ³•ä¸»è¦çš„é€»è¾‘å¦‚ä¸‹ï¼š å¯¹é…ç½®è§„åˆ™å’Œä¼ å…¥çš„URLè¿›è¡Œæ ¡éªŒï¼Œip éƒ½ä¸èƒ½ä¸ºç©ºã€‚é…ç½®è§„åˆ™å†³å®šæ˜¯å¦åº”ç”¨åˆ°ç›®æ ‡URLä¸­ï¼Œè¦çœ‹é…ç½®è§„åˆ™çš„ ip æ˜¯å¦åŒ¹é…ç›®æ ‡URLä¸­çš„ ip å€¼ã€‚æ³¨æ„ï¼Œé…ç½®è§„åˆ™URLä¸­çš„ ip å€¼å¦‚æœä¸º 0.0.0.0 è¡¨ç¤ºåŒ¹é…æ‰€æœ‰ ip ã€‚ å¯¹é…ç½®è§„åˆ™è¿›è¡Œåˆ¤æ–­ï¼Œæœ‰ä»¥ä¸‹ä¸‰ç§æƒ…å†µï¼š é…ç½®è§„åˆ™URLä¸­æœ‰ port ï¼Œä¸”å’Œå¾…å¤„ç†çš„URLçš„ port ä¸€è‡´ã€‚ç›®çš„æ˜¯åŒ¹é…æŒ‡å®šçš„ä¸€ä¸ªæœåŠ¡æä¾›è€… ï¼Œå› æ­¤ ip ä½¿ç”¨æä¾›è€…URLä¸­çš„ host å±æ€§å€¼ã€‚ é…ç½®è§„åˆ™URLä¸­æ²¡æœ‰ portï¼Œä¼ å…¥çš„URLæ˜¯æ¶ˆè´¹ç«¯URLã€‚ç›®çš„æ˜¯åŒ¹é…æŒ‡å®šçš„ä¸€ä¸ªæ¶ˆè´¹è€…ï¼Œå› æ­¤ ip ä½¿ç”¨ NetUtils.getLocalHost() çš„å€¼ã€‚ é…ç½®è§„åˆ™URLä¸­æ²¡æœ‰ portï¼Œä¼ å…¥çš„URLæ˜¯æœåŠ¡ç«¯URLã€‚ç›®çš„æ˜¯åŒ¹é…å…¨éƒ¨æä¾›è€…ï¼Œå› æ­¤ ip ä½¿ç”¨ 0.0.0.0 ã€‚ ç¡®å®šå¥½æ˜¯å¯¹æä¾›è€…è¿˜æ˜¯æ¶ˆè´¹è€…ååº”ç”¨é…ç½®åï¼Œæ¥ä¸‹æ¥å°±æ˜¯å¯¹ä¸èƒ½åŠ¨æ€ä¿®æ”¹å±æ€§çš„æ’é™¤å·¥ä½œäº†ï¼Œä¸»è¦é€»è¾‘åœ¨ configureIfMatch æ–¹æ³•ä¸­ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556+--- AbstractConfigurator private URL configureIfMatch(String host, URL url) &#123; // 1 åŒ¹é… host // å¦‚æœé…ç½® url çš„ host ä¸º 0.0.0.0ï¼Œæˆ–è€…é…ç½® url çš„ host ç­‰äºä¼ å…¥çš„ hostï¼Œåˆ™ç»§ç»­åŒ¹é…åº”ç”¨ã€‚å¦åˆ™ç›´æ¥è¿”å›url if (Constants.ANYHOST_VALUE.equals(configuratorUrl.getHost()) || host.equals(configuratorUrl.getHost())) &#123; // 2 è·å¾—é…ç½®urlä¸­çš„ applicationï¼Œå³åº”ç”¨å String configApplication = configuratorUrl.getParameter(Constants.APPLICATION_KEY, configuratorUrl.getUsername()); // 3 è·å¾—ä¼ å…¥ url çš„applicationï¼Œå³åº”ç”¨å String currentApplication = url.getParameter(Constants.APPLICATION_KEY, url.getUsername()); //4 åŒ¹é…åº”ç”¨ï¼Œ å¦‚æœé…ç½®urlçš„åº”ç”¨åä¸ºnullï¼Œæˆ–è€…ä¸º \"*\"ï¼Œæˆ–è€…å’Œurlçš„åº”ç”¨åç›¸åŒï¼Œåˆ™æ‰§è¡Œé…ç½®è§„åˆ™é€»è¾‘ã€‚ if (configApplication == null || Constants.ANY_VALUE.equals(configApplication) || configApplication.equals(currentApplication)) &#123; // 5 æ’é™¤ä¸èƒ½åŠ¨æ€ä¿®æ”¹çš„å±æ€§ï¼Œé™¤äº†å››ä¸ªå†…ç½®çš„ï¼Œè¿˜å¯ä»¥åŒ…æ‹¬ å¸¦æœ‰\"ï½\"å¼€å¤´çš„keyã€\"application\" ã€ \"side\" Set&lt;String&gt; conditionKeys = new HashSet&lt;String&gt;(); // category conditionKeys.add(Constants.CATEGORY_KEY); // check conditionKeys.add(Constants.CHECK_KEY); // dynamic conditionKeys.add(Constants.DYNAMIC_KEY); // enabled conditionKeys.add(Constants.ENABLED_KEY); /** * éå†é…ç½®urlçš„ parameter å‚æ•°é›†åˆ * 1 æŠŠç¬¦åˆè¦æ±‚çš„æ¡ä»¶åŠ å…¥åˆ° conditionKeys ä¸­ï¼Œå³ï¼šå¸¦æœ‰\"ï½\"å¼€å¤´çš„keyã€\"application\" ã€ \"side\" * 2 åˆ¤æ–­ä¼ å…¥çš„urlæ˜¯å¦åŒ¹é…é…ç½®è§„åˆ™Urlçš„æ¡ä»¶ï¼Œæ³¨æ„æ˜¯parameteréƒ¨åˆ†æ¯”è¾ƒï¼Œå¹¶ä¸”ä¸æ˜¯æ•´ä¸ªparameteré›†åˆçš„æ¯”è¾ƒï¼Œåªæ˜¯ \"ï½\"å¼€å¤´çš„key æˆ– \"application\" æˆ– \"side\" è¿™ä¸ªä¸‰ä¸ªkey/valuçš„æ¯”è¾ƒ */ for (Map.Entry&lt;String, String&gt; entry : configuratorUrl.getParameters().entrySet()) &#123; // å‚æ•°key String key = entry.getKey(); // å‚æ•°keyå¯¹åº”çš„value String value = entry.getValue(); // å¦‚æœ é…ç½®urlçš„parameterå‚æ•°çš„keyæ˜¯ï¼š \"ï½\" æˆ– \"application\" æˆ– \"side\"ï¼Œé‚£ä¹ˆä¹ŸåŠ å…¥åˆ°é…ç½®Urlçš„æ¡ä»¶é›†åˆä¸­ï¼Œéœ€è¦å‰”é™¤ï¼Œä¸èƒ½å‚ä¸åº”ç”¨åˆ°ç›®æ ‡URL if (key.startsWith(\"~\") || Constants.APPLICATION_KEY.equals(key) || Constants.SIDE_KEY.equals(key)) &#123; // æŠŠkeyåŠ å…¥åˆ°æ¡ä»¶é›†åˆä¸­ï¼Œç”¨äºå‰”é™¤ conditionKeys.add(key); // å¦‚æœç›®æ ‡URLä¸­ä¸å­˜åœ¨é…ç½®URLä¸­çš„å‰”é™¤å‚æ•°å€¼ï¼ˆä»¥ ï½ å¼€å¤´çš„å‚æ•°ï¼‰ï¼Œåˆ™è¯´æ˜urlä¸åŒ¹é…é…ç½®è§„åˆ™ï¼Œç›´æ¥è¿”å›url if (value != null &amp;&amp; !Constants.ANY_VALUE.equals(value) &amp;&amp; !value.equals(url.getParameter(key.startsWith(\"~\") ? key.substring(1) : key))) &#123; return url; &#125; &#125; &#125; // ä»é…ç½®Urlä¸­æ’é™¤ä¸èƒ½åŠ¨æ€ä¿®æ”¹çš„å±æ€§ï¼Œç„¶åæŠŠå‰©ä½™çš„å±æ€§é…ç½®åˆ°URLä¸­ return doConfigure(url, configuratorUrl.removeParameters(conditionKeys)); &#125; &#125; return url; &#125; configureIfMatch æ–¹æ³•ä¸»è¦åšäº†ä¸‰ä»¶äº‹ï¼š é€šè¿‡ ip åˆ¤æ–­é…ç½®URLæ˜¯å¦èƒ½å¤Ÿåº”ç”¨åˆ°ç›®æ ‡URLä¸Šï¼Œé…ç½®URLä¸­çš„ipæ”¯æŒ 0.0.0.0 è¡¨ç¤ºåŒ¹é…æ‰€æœ‰ipã€‚ é€šè¿‡ application åº”ç”¨ååˆ¤æ–­é…ç½®URLæ˜¯å¦èƒ½å¤Ÿåº”ç”¨åˆ°ç›®æ ‡URLä¸Šï¼Œé…ç½®URLä¸­çš„ application å…è®¸ä¸ºç©ºæˆ– * ï¼Œè¡¨ç¤ºåŒ¹é…æ‰€æœ‰åº”ç”¨ã€‚ å‰”é™¤é…ç½®URLä¸­ä¸èƒ½åŠ¨æ€ä¿®æ”¹çš„å±æ€§ã€‚ åº”ç”¨é…ç½®123456789+--- AbstractConfigurator /** * å°†é…ç½®è§„åˆ™é…ç½®åˆ°urlä¸­ * * @param currentUrl ç›®æ ‡url * @param configUrl é…ç½®url * @return */ protected abstract URL doConfigure(URL currentUrl, URL configUrl); åº”ç”¨é…ç½®è§„åˆ™æ˜¯ä¸€ä¸ªæŠ½è±¡æ–¹æ³•ï¼Œå…·ä½“å®ç°äº¤ç»™å…·ä½“å­ç±»å®ç°ã€‚ é…ç½®æ’åº12345678910111213141516171819+--- AbstractConfigurator @Override public int compareTo(Configurator o) &#123; if (o == null) &#123; return -1; &#125; // 1 æ ¹æ® ip å‡åº int ipCompare = getUrl().getHost().compareTo(o.getUrl().getHost()); // 2 å¦‚æœ ip ç›¸åŒï¼Œåˆ™æŒ‰ç…§ priority é™åº if (ipCompare == 0) &#123; int i = getUrl().getParameter(Constants.PRIORITY_KEY, 0), j = o.getUrl().getParameter(Constants.PRIORITY_KEY, 0); return i &lt; j ? -1 : (i == j ? 0 : 1); &#125; else &#123; return ipCompare; &#125; &#125; Configurator æ’åºé¦–å…ˆæŒ‰ç…§ ip è¿›è¡Œæ’åºï¼Œæ‰€æœ‰ ip çš„ä¼˜å…ˆçº§éƒ½é«˜äº 0.0.0.0ï¼Œå½“ ip ç›¸åŒæ—¶ï¼Œä¼šæŒ‰ç…§ priority å‚æ•°å€¼è¿›è¡Œæ’åºã€‚ OverrideConfigurator1234567891011121314151617public class OverrideConfigurator extends AbstractConfigurator &#123; /** * æ„é€ æ–¹æ³•ä¼šè°ƒç”¨çˆ¶ç±»çš„æ„é€ æ–¹æ³• * * @param url */ public OverrideConfigurator(URL url) &#123; super(url); &#125; @Override public URL doConfigure(URL currentUrl, URL configUrl) &#123; // è¦†ç›–æ·»åŠ ï¼Œå³ç›´æ¥ç”¨é…ç½®URLä¸­å‰©ä½™çš„å…¨éƒ¨å‚æ•°ï¼Œè¦†ç›–åŸå§‹ URL ä¸­ç›¸åº”å‚æ•° return currentUrl.addParameters(configUrl.getParameters()); &#125;&#125; OverrideConfigurator æ˜¯ä¸€ç§ç›´æ¥è¦†ç›–ç­–ç•¥ï¼Œå³ç›´æ¥ä½¿ç”¨é…ç½®URLä¸­å‰©ä½™çš„å…¨éƒ¨å‚æ•°ï¼ˆåœ¨çˆ¶ç±»ä¸­å·²ç»å‰”é™¤äº†ä¸èƒ½åŠ¨æ€ä¿®æ”¹çš„å‚æ•°ï¼‰ï¼Œè¦†ç›–åŸå§‹ URL ä¸­ç›¸åº”å‚æ•°ã€‚ AbsentConfigurator1234567891011121314151617public class AbsentConfigurator extends AbstractConfigurator &#123; /** * æ„é€ æ–¹æ³•ä¼šè°ƒç”¨çˆ¶ç±»çš„æ„é€ æ–¹æ³• * * @param url */ public AbsentConfigurator(URL url) &#123; super(url); &#125; @Override public URL doConfigure(URL currentUrl, URL configUrl) &#123; // å°è¯•ç”¨é…ç½® URL ä¸­çš„å‚æ•°æ·»åŠ åˆ°åŸå§‹ URL ä¸­ï¼Œå¦‚æœåŸå§‹ URL ä¸­å·²ç»æœ‰äº†è¯¥å‚æ•°æ˜¯ä¸ä¼šè¢«è¦†ç›–çš„ return currentUrl.addParametersIfAbsent(configUrl.getParameters()); &#125;&#125; AbsentConfigurator æ˜¯ä¸€ç§é€‰æ‹©æ€§è¦†ç›–ç­–ç•¥ï¼Œå½“ç›®æ ‡URLä¸­ä¸å­˜å‚æ•°æ—¶æ‰ä¼šä½¿ç”¨é…ç½®ä¸­çš„å‚æ•°ã€‚ Configurator é›†æˆDubbo æ¡†æ¶ä¸­é›†æˆ Configurator å¦‚ä¸‹ï¼š å°ç»“æœ¬ç¯‡æ–‡ç« ä»‹ç»äº† Dubbo ä¸­é…ç½®ç›¸å…³å®ç°ã€‚é¦–å…ˆå¯¹é…ç½®åè®® override å’Œ absent URL è¿›è¡Œäº†ä»‹ç»ï¼Œç„¶ååˆ†æäº† Configurator è¦†ç›–ç›®æ ‡ URL çš„å®ç°ï¼Œæœ€ååˆ—å‡ºäº† Dubbo ä¸­å¯¹ Configuratgor çš„é›†æˆä»£ç ç‰‡æ®µã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"é›†ç¾¤å®¹é”™ - Directory","slug":"rpc/é›†ç¾¤å®¹é”™ä¹‹Directory","date":"2020-09-18T03:00:00.000Z","updated":"2021-04-06T08:31:55.022Z","comments":false,"path":"posts/e43ac0a6/","link":"","permalink":"https://gentryhuang.com/posts/e43ac0a6/","excerpt":"","text":"æ¦‚è¿°æœ¬ç¯‡æ–‡ç« å¯¹ Dubbo é›†ç¾¤æ¨¡å—ä¸­çš„ Directory æœåŠ¡ç›®å½•è¿›è¡Œä»‹ç»ã€‚æœåŠ¡ç›®å½• RegistryDirectory ä¸­å­˜å‚¨äº†ä¸€äº›å’ŒæœåŠ¡æä¾›è€…æœ‰å…³çš„ä¿¡æ¯ï¼ˆé™„åŠ æœåŠ¡æ²»ç†å‚æ•°ï¼‰ï¼Œé€šè¿‡æœåŠ¡ç›®å½•æ¶ˆè´¹è€…å¯è·å–åˆ°æœåŠ¡æä¾›è€…çš„ä¿¡æ¯ï¼Œæ¯”å¦‚ ipã€ç«¯å£ã€æœåŠ¡åè®®ç­‰ã€‚æœåŠ¡ç›®å½•æœ¬è´¨ä¸Šæ˜¯å¯¹æ³¨å†Œä¸­å¿ƒä¸ŠæœåŠ¡é…ç½®ä¿¡æ¯çš„æ•´åˆç»“æœï¼Œæœ€ç»ˆä¼šç»“åˆé…ç½®ä¿¡æ¯ä»¥åŠæ¶ˆè´¹ç«¯ä¿¡æ¯ç»„è£…æ¶ˆè´¹ç«¯çš„ Invoker ã€‚æœåŠ¡ç›®å½•å¯ä»¥çœ‹åšæ˜¯ Invoker çš„é›†åˆï¼Œä¸”è¿™ä¸ªé›†åˆä¸­çš„å…ƒç´ ä¼šéšæ³¨å†Œä¸­å¿ƒçš„å˜åŒ–è€Œè¿›è¡ŒåŠ¨æ€è°ƒæ•´ã€‚ ç»§æ‰¿ä½“ç³»æœåŠ¡ç›®å½• Directory ç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æœåŠ¡ç›®å½•å†…ç½®å®ç°åˆ†åˆ«ä¸º StaticDirectory å’Œ RegistryDirectory ï¼Œå‰è€…ç”¨äºå°†ä¼ å…¥çš„ Invoker é›†åˆå°è£…æˆé™æ€çš„ Directory å¯¹è±¡ï¼Œåè€…æ˜¯åŸºäºæ³¨å†Œä¸­å¿ƒçš„åŠ¨æ€ Directory å¯¹è±¡ã€‚ä¸‹é¢æˆ‘ä»¬ä»æºç å±‚é¢ä¸Šåˆ†ææœåŠ¡ç›®å½•çš„å®ç°ã€‚ æºç åˆ†æDirectory1234567891011121314151617public interface Directory&lt;T&gt; extends Node &#123; /** * è·å¾—æœåŠ¡æ¥å£ç±»å‹ï¼Œå¦‚ï¼šcom.alibaba.dubbo.demo.DemoService * * @return service type. */ Class&lt;T&gt; getInterface(); /** * æ ¹æ®ä¼ å…¥çš„ Invocation è¯·æ±‚è¿”å›ç¬¦åˆæ¡ä»¶çš„ Invoker é›†åˆ * * @return invokers */ List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException;&#125; Directory æ¥å£è¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªæœåŠ¡ç›®å½•ï¼Œç”±å¤šä¸ª Invoker æ„æˆï¼Œåç»­çš„ è·¯ç”±å¤„ç†ã€è´Ÿè½½å‡è¡¡ã€é›†ç¾¤å®¹é”™ç­‰éƒ½æ˜¯åŸºäº Directory å®ç°çš„ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸€ä¸ªæœåŠ¡ç›®å½• Directory ä»…å¯¹åº”ä¸€ä¸ªæœåŠ¡ç±»å‹ï¼Œç®¡ç†çš„æ˜¯è¯¥ç±»å‹çš„å¤šä¸ªæœåŠ¡ã€‚ è¯¥æ¥å£åŒ…å«äº†ä¸€ä¸ªé‡è¦çš„æ–¹æ³•å®šä¹‰ï¼Œå³ list(Invocation)ï¼Œç”¨äºåˆ—ä¸¾ Invokerã€‚ä¸‹é¢æˆ‘ä»¬å¯¹å®ƒçš„æŠ½è±¡å®ç°è¿›è¡Œè¯´æ˜ã€‚ AbstractDirectoryAbstractDirectory æ˜¯ Directory æ¥å£çš„æŠ½è±¡å®ç°ï¼Œå…¶ä¸­é™¤äº†ç»´æŠ¤æ¶ˆè´¹ç«¯çš„ URL ä¿¡æ¯ï¼Œè¿˜ç»´æŠ¤äº†è·¯ç”±ä¿¡æ¯ã€‚æ­¤å¤–ï¼Œå°è£…äº†è·å– Invoker åˆ—è¡¨çš„æµç¨‹ï¼Œå…·ä½“çš„é€»è¾‘ç”±å­ç±»å®ç°ã€‚ä¸‹é¢æˆ‘ä»¬å…ˆæ¥çœ‹è¯¥æŠ½è±¡å®ç°æºç ã€‚ å±æ€§1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public abstract class AbstractDirectory&lt;T&gt; implements Directory&lt;T&gt; &#123; private static final Logger logger = LoggerFactory.getLogger(AbstractDirectory.class); /** * æ³¨å†Œä¸­å¿ƒURL */ private final URL url; /** * æ˜¯å¦å·²ç»é”€æ¯ */ private volatile boolean destroyed = false; /** * æ¶ˆè´¹è€… URL * æ³¨æ„ï¼šå¦‚æœæ²¡æœ‰æ˜¾ç¤ºè°ƒç”¨æ„é€ æ–¹æ³•ï¼Œé‚£ä¹ˆè¯¥å±æ€§çš„å€¼ä¸º urlçš„å€¼ */ private volatile URL consumerUrl; /** * è·¯ç”±æ•°ç»„ */ private volatile List&lt;Router&gt; routers; public AbstractDirectory(URL url) &#123; this(url, null); &#125; public AbstractDirectory(URL url, List&lt;Router&gt; routers) &#123; this(url, url, routers); &#125; public AbstractDirectory(URL url, URL consumerUrl, List&lt;Router&gt; routers) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; // è®¾ç½®url this.url = url; // è®¾ç½®consumerUrl this.consumerUrl = consumerUrl; // è®¾ç½®è·¯ç”±æ•°ç»„ setRouters(routers); &#125;&#125; æ„é€ æ–¹æ³•ä¸­ä¼šç»´æŠ¤ä¼ å…¥çš„ æ³¨å†Œä¸­å¿ƒ URLã€æ¶ˆè´¹ç«¯ URL ä»¥åŠ è®¾ç½®è·¯ç”±åˆ—è¡¨ã€‚åœ¨å¤„ç†è·¯ç”±æ—¶ï¼Œé™¤äº†ä¿å­˜ä¼ å…¥çš„è·¯ç”±å¤–ï¼Œå¦‚æœé…ç½®äº†è·¯ç”±ä¹Ÿä¼šå°†å…¶åŠ å…¥åˆ°è·¯ç”±é›†åˆä¸­ï¼Œä¸‹é¢æˆ‘ä»¬çœ‹ä¸‹å…¶å®ç°ã€‚ 123456789101112131415161718192021222324+--- AbstractDirectory protected void setRouters(List&lt;Router&gt; routers) &#123; // 1 ä¿å­˜ä¼ å…¥çš„è·¯ç”±é›†åˆ routers = routers == null ? new ArrayList&lt;Router&gt;() : new ArrayList&lt;Router&gt;(routers); // 2 ä»URLä¸­å–å‡ºé…ç½®çš„è·¯ç”± String routerkey = url.getParameter(Constants.ROUTER_KEY); // 3 å¦‚æœé…ç½®äº†è·¯ç”±ï¼Œåˆ™è·å–å¯¹åº”çš„è·¯ç”±å®ç°ï¼Œå¹¶åŠ å…¥åˆ° routersé›†åˆ ä¸­ if (routerkey != null &amp;&amp; routerkey.length() &gt; 0) &#123; RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey); routers.add(routerFactory.getRouter(url)); &#125; // 4 ç»Ÿä¸€æ·»åŠ  MockInvokersSelector è·¯ç”± routers.add(new MockInvokersSelector()); // 5 æ’åº Collections.sort(routers); // 6 æ”¾å…¥ç¼“å­˜ this.routers = routers; &#125; åˆ›å»ºæœåŠ¡ç›®å½•æ—¶ï¼Œä¼šåŒæ—¶ç»´æŠ¤è·¯ç”±ï¼Œç»´æŠ¤çš„è·¯ç”±ç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼Œå¤–éƒ¨ä¼ å…¥çš„Router + é…ç½®çš„Router + MockInvokersSelector ã€‚å…³äºè·¯ç”±çš„ä»‹ç»ä¼šåœ¨åé¢çš„æ–‡ç« ä¸­å•ç‹¬è¯´æ˜ï¼Œè¿™é‡Œä¸å†å±•å¼€ã€‚ æ‹‰å– Invoker é›†åˆ123456789101112131415161718192021222324252627282930313233343536+--- AbstractDirectory @Override public List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException &#123; // 1 æœåŠ¡ç›®å½•é”€æ¯äº†å°±ç›´æ¥æŠ›å‡ºå¼‚å¸¸ if (destroyed) &#123; throw new RpcException(\"Directory already destroyed .url: \" + getUrl()); &#125; // 2 è°ƒç”¨ doList æ–¹æ³•è·å– Invokers é›†åˆï¼Œå…·ä½“å®ç°äº¤ç»™å­ç±» List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation); // 3 ä½¿ç”¨è·¯ç”± List&lt;Router&gt; localRouters = this.routers; // ä½¿ç”¨è·¯ç”±è§„åˆ™ç­›é€‰Invokeré›†åˆ if (localRouters != null &amp;&amp; !localRouters.isEmpty()) &#123; for (Router router : localRouters) &#123; try &#123; /** * æ ¹æ®è·¯ç”±çš„URLå€¼ä»¥åŠ runtime å‚æ•°ï¼Œå†³å®šæ˜¯å¦è¿›è¡Œè·¯ç”± * æ³¨æ„ï¼š * Routerçš„runtimeå‚æ•°å†³å®šæ˜¯å¦æ¯æ¬¡è°ƒç”¨æœåŠ¡æ—¶éƒ½æ‰§è¡Œè·¯ç”±è§„åˆ™ã€‚å¦‚æœ runtimeé…ç½®ä¸ºtrueï¼Œæ¯æ¬¡è°ƒç”¨æœåŠ¡å‰éƒ½éœ€è¦è¿›è¡ŒæœåŠ¡è·¯ç”±ï¼Œè¿™ä¸ªä¼šå¯¹æ€§èƒ½ä¼šé€ æˆå½±å“ã€‚ */ if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) &#123; // ä½¿ç”¨è·¯ç”±ç­›é€‰ Invoker invokers = router.route(invokers, getConsumerUrl(), invocation); &#125; &#125; catch (Throwable t) &#123; logger.error(\"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(), t); &#125; &#125; &#125; // 4 è¿”å›è·¯ç”±åçš„ç»“æœ return invokers; &#125; AbstractDirectory æ‹‰å– Invoker åˆ—è¡¨çš„ä¸»è¦é€»è¾‘å¦‚ä¸‹ï¼š è°ƒç”¨å­ç±»å®ç°çš„ doList æ–¹æ³•è·å– Invoker åˆ—è¡¨ã€‚ ä½¿ç”¨è·¯ç”±ï¼Œæ ¹æ® Router çš„ getUrl è¿”å›å€¼æ˜¯å¦ä¸ºç©ºï¼Œä»¥åŠ runtime å‚æ•°å†³å®šæ˜¯å¦è¿›è¡Œè·¯ç”±è¿‡æ»¤ã€‚ éœ€è¦è¯´æ˜çš„æ˜¯ï¼ŒRouter çš„ runtime å‚æ•°å†³å®šäº†æ˜¯å¦æ¯æ¬¡è°ƒç”¨æœåŠ¡æ—¶éƒ½è¦æ‰§è¡Œè·¯ç”±è§„åˆ™ã€‚å¦‚æœ runtime ä¸º trueï¼Œé‚£ä¹ˆæ¯æ¬¡è°ƒç”¨æœåŠ¡å‰ï¼Œéƒ½éœ€è¦è¿›è¡ŒæœåŠ¡è·¯ç”±ï¼Œè¿™ä¸ªä¼šå¯¹æ€§èƒ½é€ æˆå½±å“ã€‚ StaticDirectoryStaticDirectory å®ç°ä¸­ç»´æŠ¤çš„ Invoker é›†åˆæ˜¯é™æ€çš„ï¼Œåœ¨ StaticDirectory å¯¹è±¡åˆ›å»ºå®Œæ¯•åï¼Œæ˜¯ä¸ä¼šå‘ç”Ÿæ”¹å˜çš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class StaticDirectory&lt;T&gt; extends AbstractDirectory&lt;T&gt; &#123; /** * Invoker é›†åˆï¼Œè¿™ä¸ªé›†åˆä¸­çš„å…ƒç´ æ˜¯ä¸å˜çš„ */ private final List&lt;Invoker&lt;T&gt;&gt; invokers; public StaticDirectory(List&lt;Invoker&lt;T&gt;&gt; invokers) &#123; this(null, invokers, null); &#125; public StaticDirectory(List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Router&gt; routers) &#123; this(null, invokers, routers); &#125; public StaticDirectory(URL url, List&lt;Invoker&lt;T&gt;&gt; invokers) &#123; this(url, invokers, null); &#125; public StaticDirectory(URL url, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Router&gt; routers) &#123; // ç¡®å®šurlæœ‰æ•ˆæ€§ super(url == null &amp;&amp; invokers != null &amp;&amp; !invokers.isEmpty() ? invokers.get(0).getUrl() : url, routers); if (invokers == null || invokers.isEmpty()) &#123; throw new IllegalArgumentException(\"invokers == null\"); &#125; this.invokers = invokers; &#125; /** * è·å–æ¥å£ * * @return Invokerå¯¹åº”çš„æ¥å£ */ @Override public Class&lt;T&gt; getInterface() &#123; return invokers.get(0).getInterface(); &#125; /** * æ£€æµ‹æœåŠ¡ç›®å½•æ˜¯å¦å¯ç”¨ * * @return */ @Override public boolean isAvailable() &#123; // è‹¥å·²ç»é”€æ¯ï¼Œåˆ™ä¸å¯ç”¨ if (isDestroyed()) &#123; return false; &#125; // ä»»æ„ä¸€ä¸ªInvoker å¯ç”¨ï¼Œå½“å‰æœåŠ¡ç›®å½•å°±å¯ç”¨ for (Invoker&lt;T&gt; invoker : invokers) &#123; if (invoker.isAvailable()) &#123; return true; &#125; &#125; return false; &#125; @Override public void destroy() &#123; // å·²é”€æ¯ï¼Œåˆ™è·³è¿‡ if (isDestroyed()) &#123; return; &#125; // é”€æ¯ super.destroy(); // é”€æ¯æ¯ä¸ª Invoker for (Invoker&lt;T&gt; invoker : invokers) &#123; invoker.destroy(); &#125; // æ¸…ç©ºInvoker é›†åˆ invokers.clear(); &#125; /** * ç›´æ¥è¿”å›ç”±æ„é€ æ–¹æ³•ä¼ å…¥è¿›æ¥çš„Invoker é›†åˆ * * @param invocation * @return * @throws RpcException */ @Override protected List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) throws RpcException &#123; return invokers; &#125;&#125; RegistryDirectoryRegistryDirectory æ˜¯ä¸€ä¸ªåŠ¨æ€çš„ Directory å®ç°ï¼Œå®ç°äº† NotifyListener æ¥å£ï¼Œè®¢é˜…æ³¨å†Œä¸­å¿ƒçš„æ•°æ®ï¼Œå®ç°ç›‘å¬åŠŸèƒ½ã€‚å½“æ³¨å†Œä¸­å¿ƒçš„æœåŠ¡é…ç½®å‘ç”Ÿå˜æ›´æ—¶ï¼Œä¼šè§¦å‘å›è°ƒ NotifyListener.notify æ–¹æ³•ï¼ŒRegistryDirectory æ”¶åˆ°å˜æ›´é€šçŸ¥åä¼šæ ¹æ®æ³¨å†Œä¸­å¿ƒæ¨é€çš„é€šçŸ¥ï¼Œé‡æ–°å¼•ç”¨æœåŠ¡ï¼Œå³ åˆ·æ–° Invoker åˆ—è¡¨ã€‚è¯¥å®ç°ç±»ä¸ºäº†è®©æœ¬åœ°æœåŠ¡ç›®å½•å’Œæ³¨å†Œä¸­å¿ƒçš„æœåŠ¡ä¿¡æ¯ä¿æŒä¸€è‡´åšäº†å¾ˆå¤šçš„å·¥ä½œï¼Œä¸‹æ–‡æˆ‘ä»¬ä¸€ä¸€åˆ†æã€‚ å±æ€§1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class RegistryDirectory&lt;T&gt; extends AbstractDirectory&lt;T&gt; implements NotifyListener &#123; private static final Logger logger = LoggerFactory.getLogger(RegistryDirectory.class); /** * é›†ç¾¤æ‰©å±•å®ç° Cluster$Adaptive å¯¹è±¡ - å¯¹åŒç»„ Invoker è¿›è¡Œåˆå¹¶ */ private static final Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension(); /** * è·¯ç”±å·¥å‚æ‰©å±•å®ç° RouterFactory$Adaptiveå¯¹è±¡ - åˆ›å»ºè·¯ç”± */ private static final RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getAdaptiveExtension(); /** * é…ç½®è§„åˆ™å·¥å‚å®ç° ConfiguratorFactory$Adaptive å¯¹è±¡ - åˆ›å»ºé…ç½®å¯¹è±¡ */ private static final ConfiguratorFactory configuratorFactory = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).getAdaptiveExtension(); /** * æ³¨å†Œä¸­å¿ƒURLçš„æœåŠ¡é”®ï¼Œ å¦‚ï¼šcom.alibaba.dubbo.registry.RegistryService */ private final String serviceKey; /** * æœåŠ¡æ¥å£ç±»å‹ï¼Œå¦‚ï¼šcom.alibaba.dubbo.demo.DemoService * æ¯ä¸€ä¸ªæœåŠ¡å¼•ç”¨éƒ½å¯¹åº”ä¸€ä¸ªæœåŠ¡ç›®å½• */ private final Class&lt;T&gt; serviceType; /** * æœåŠ¡æ¶ˆè´¹è€… URL çš„é…ç½®é¡¹ Mapã€‚å³ Consumer URL ä¸­ refer å‚æ•°è§£æåå¾—åˆ°çš„å…¨éƒ¨ KV */ private final Map&lt;String, String&gt; queryMap; /** * åªä¿ç•™ Consumer å±æ€§çš„ URLï¼Œä¹Ÿå°±æ˜¯ç”± queryMap é›†åˆé‡æ–°ç”Ÿæˆçš„ URLï¼ŒURL ä¸»ä½“ä»ç„¶æ˜¯æ³¨å†Œä¸­å¿ƒçš„ URLä¿¡æ¯ã€‚ */ private final URL directoryUrl; /** * å¼•ç”¨çš„æœåŠ¡æ¥å£æ–¹æ³•æ•°ç»„ */ private final String[] serviceMethods; /** * æ˜¯å¦å¼•ç”¨å¤šä¸ªæœåŠ¡åˆ†ç»„ - æœåŠ¡åˆ†ç»„æ¦‚å¿µ */ private final boolean multiGroup; /** * æ³¨å†Œä¸­å¿ƒçš„Protocol å¯¹è±¡ */ private Protocol protocol; /** * æ³¨å†Œä¸­å¿ƒ */ private Registry registry; /** * æ˜¯å¦ç¦æ­¢è®¿é—®ï¼š * 1 å½“æ²¡æœ‰æœåŠ¡æä¾›è€… * 2 å½“æœåŠ¡æä¾›è€…è¢«ç¦ç”¨ */ private volatile boolean forbidden = false; /** * ç»“åˆé…ç½®è§„åˆ™ï¼Œé‡å†™åŸå§‹ç›®å½•URLå¾—åˆ°çš„ */ private volatile URL overrideDirectoryUrl; /** * é…ç½®è§„åˆ™æ•°ç»„ * override rules * Priority: override&gt;-D&gt;consumer&gt;provider * Rule one: for a certain provider &lt;ip:port,timeout=100&gt; * Rule two: for all providers &lt;* ,timeout=5000&gt; */ private volatile List&lt;Configurator&gt; configurators; /** * &lt;æœåŠ¡æä¾›è€…URLåˆå¹¶å¤„ç†åçš„URLä¸²,æœåŠ¡å¼•ç”¨åˆ›å»ºçš„Invoker&gt; * Map&lt;url, Invoker&gt; cache service url to invoker mapping. */ private volatile Map&lt;String, Invoker&lt;T&gt;&gt; urlInvokerMap; /** * æ–¹æ³•åä¸å¼•ç”¨Invokeré›†åˆçš„æ˜ å°„ * Map&lt;methodName, Invoker&gt; cache service method to invokers mapping. */ private volatile Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; methodInvokerMap; /** * å½“å‰ç¼“å­˜çš„æ‰€æœ‰ Provider çš„ URL * Set&lt;invokerUrls&gt; cache invokeUrls to invokers mapping. */ private volatile Set&lt;URL&gt; cachedInvokerUrls;&#125; æ„é€ æ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839+--- RegistryDirectory /** * æ„é€ æ–¹æ³•ï¼Œæ ¹æ®æ³¨å†Œä¸­å¿ƒURLåˆå§‹åŒ–ç›¸å…³å±æ€§ * * @param serviceType æœåŠ¡æ¥å£ç±»å‹ * @param url æ³¨å†Œä¸­å¿ƒ URL */ public RegistryDirectory(Class&lt;T&gt; serviceType, URL url) &#123; // è°ƒç”¨çˆ¶ç±»æ„é€ æ–¹æ³• super(url); // å¦‚æœæœåŠ¡ç±»å‹ä¸ºç©ºï¼ŒæŠ›å‡ºå¼‚å¸¸ if (serviceType == null) &#123; throw new IllegalArgumentException(\"service type is null.\"); &#125; // Urlå¯¹åº”çš„æœåŠ¡é”®ä¸ºç©ºï¼ŒæŠ›å‡ºå¼‚å¸¸ if (url.getServiceKey() == null || url.getServiceKey().length() == 0) &#123; throw new IllegalArgumentException(\"registry serviceKey is null.\"); &#125; // è®¾ç½®æœåŠ¡ç±»å‹ å’Œ æ³¨å†Œä¸­å¿ƒURLçš„æœåŠ¡é”® this.serviceType = serviceType; this.serviceKey = url.getServiceKey(); // è®¾ç½®æœåŠ¡æ¶ˆè´¹è€… URL çš„é…ç½®é¡¹ Mapï¼Œå³è§£æ refer å‚æ•°å€¼ï¼Œå¾—åˆ° Consumer çš„é…ç½®å‚æ•° parameters çš„å€¼ this.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY)); // æ„é€ çš„æ—¶å€™ï¼Œthis.overrideDirectoryUrl == this.directoryUrl // å°† queryMap ä¸­çš„ KV ä½œä¸ºå‚æ•°ï¼Œé‡æ–°æ„é€  URLï¼ŒURLä¸»ä½“ä¸å˜ this.overrideDirectoryUrl = this.directoryUrl = url.setPath(url.getServiceInterface()).clearParameters().addParameters(queryMap).removeParameter(Constants.MONITOR_KEY); // ä»æ¶ˆè´¹è€…é…ç½®é¡¹ä¸­è·å–åˆ†ç»„å‚æ•° String group = directoryUrl.getParameter(Constants.GROUP_KEY, \"\"); // è®¾ç½®å¤šåˆ†ç»„æ ‡è¯† this.multiGroup = group != null &amp;&amp; (\"*\".equals(group) || group.contains(\",\")); // ä»æ¶ˆè´¹è€…é…ç½®é¡¹ä¸­è·å–æœåŠ¡æ–¹æ³•ä¸² String methods = queryMap.get(Constants.METHODS_KEY); // è®¾ç½®å¼•ç”¨æœåŠ¡æ¥å£ä¸­çš„æ–¹æ³•æ•°ç»„ this.serviceMethods = methods == null ? null : Constants.COMMA_SPLIT_PATTERN.split(methods); &#125; RegistryDirectory ä¸­çš„éƒ¨åˆ†å±æ€§ä¼šæ ¹æ®æ³¨å†Œä¸­å¿ƒURLåˆå§‹åŒ–ã€‚ä¸‹é¢å¯¹è¾ƒä¸ºé‡è¦çš„å±æ€§è¿›è¡Œè¯´æ˜ï¼š this.queryMap:1Consumer ç«¯çš„ URL çš„å‚æ•°é…ç½®é¡¹ parameters çš„å€¼ this.directoryUrl:1ä¼ å…¥çš„æ³¨å†Œä¸­å¿ƒ URL çš„ä¸»å¹²éƒ¨åˆ† + Consumer ç«¯çš„ URL çš„ parametersï¼ˆthis.queryMapï¼‰ this.overrideDirectoryUrl1åˆå§‹å€¼ä¸º this.directoryUrlï¼Œåœ¨æ¥æ”¶æ³¨å†Œä¸­å¿ƒç›®å½•ï¼ˆæŸä¸ªæœåŠ¡æ¥å£ä¸‹çš„ç›®å½•ï¼Œå…¶ä¸­ä¸€æœåŠ¡æ¥å£å¯¹åº”ä¸€ä¸ªæœåŠ¡ç›®å½•ï¼‰å˜æ›´é€šçŸ¥æ—¶ä¼šå…ˆç»“åˆé…ç½®è§„åˆ™ Configurator é‡å†™ this.directoryUrlã€‚ InvokerDelegateInvokerDelegate æ˜¯ RegistryDirectory çš„å†…éƒ¨ç±»ï¼Œç»§æ‰¿äº† InvokerWrapper è¿™ä¸ª Invoker çš„åŒ…è£…ç±»ã€‚è¿™ä¸ªä»£ç†ç±»ä¸»è¦ç”¨äºå­˜å‚¨æ³¨å†Œä¸­å¿ƒä¸‹å‘çš„æœåŠ¡æä¾›è€…çš„URLä»¥åŠæœåŠ¡å¼•ç”¨åˆ›å»ºçš„ Invoker ã€‚ 123456789101112131415161718192021+--- RegistryDirectory private static class InvokerDelegate&lt;T&gt; extends InvokerWrapper&lt;T&gt; &#123; /** * æœåŠ¡æä¾›è€…URLï¼Œæ³¨æ„ï¼šè¿™æ˜¯æœªç»è¿‡é…ç½®åˆå¹¶çš„URL */ private URL providerUrl; /** * @param invoker Protocol.refer å¼•ç”¨çš„ Invoker * @param url åˆå¹¶åçš„ URL * @param providerUrl æœåŠ¡æä¾›è€…URL */ public InvokerDelegate(Invoker&lt;T&gt; invoker, URL url, URL providerUrl) &#123; super(invoker, url); this.providerUrl = providerUrl; &#125; public URL getProviderUrl() &#123; return providerUrl; &#125; &#125; æ‹‰å– Invokeræ‹‰å– Invoker é€»è¾‘å°è£…åœ¨ doList æ–¹æ³•ä¸­ï¼Œæ˜¯çˆ¶ç±» AbstractDirectory çš„æ¨¡ç‰ˆæ–¹æ³•ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950+--- RegistryDirectory @Override public List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) &#123; // 1 æ£€æµ‹forbiddenå­—æ®µï¼Œå½“è¯¥å­—æ®µåœ¨ refreshInvoker() è¿‡ç¨‹ä¸­è®¾ç½®ä¸ºtrueæ—¶ï¼Œè¡¨ç¤ºæ—  Provider å¯ç”¨ï¼Œç›´æ¥æŠ›å‡ºå¼‚å¸¸ if (forbidden) &#123; // 1. No service provider 2. Service providers are disabled throw new RpcException(RpcException.FORBIDDEN_EXCEPTION, \"No provider available from registry \" + getUrl().getAddress() + \" for service \" + getConsumerUrl().getServiceKey() + \" on consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please check status of providers(disabled, not registered or in blacklist).\"); &#125; List&lt;Invoker&lt;T&gt;&gt; invokers = null; // 2 è·å–Invokeræœ¬åœ°ç¼“å­˜ ï¼ˆæœåŠ¡å¼•ç”¨çš„è¿‡ç¨‹ methodInvokerMap ä¸­çš„å€¼å·²ç»æœ‰äº†ï¼Œå¹¶ä¸”è¯¥å€¼ä¼šéšç€è®¢é˜…çš„æœåŠ¡è€Œå˜åŒ–ï¼‰ Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap = this.methodInvokerMap; // 3 ä» Invoker æœ¬åœ°ç¼“å­˜ä¿¡æ¯ä¸­é€‰å‡ºç›®æ ‡ Invoker é›†åˆ if (localMethodInvokerMap != null &amp;&amp; localMethodInvokerMap.size() &gt; 0) &#123; // è·å¾—è°ƒç”¨çš„æ–¹æ³•åå’Œæ–¹æ³•å‚æ•°åˆ—è¡¨ String methodName = RpcUtils.getMethodName(invocation); Object[] args = RpcUtils.getArguments(invocation); if (args != null &amp;&amp; args.length &gt; 0 &amp;&amp; args[0] != null &amp;&amp; (args[0] instanceof String || args[0].getClass().isEnum())) &#123; // 3.1 æ ¹æ®ç¬¬ä¸€ä¸ªå‚æ•°å’Œæœ¬èº«çš„æ–¹æ³•åæ‹¼æ¥ç¡®å®šæœ€åçš„æ–¹æ³•åï¼Œç„¶åè·å¾—Invokeré›†åˆã€‚ invokers = localMethodInvokerMap.get(methodName + args[0]); // The routing can be enumerated according to the first parameter &#125; if (invokers == null) &#123; // 3.2 æ ¹æ®æ–¹æ³•åè·å¾— Invoker é›†åˆï¼Œä¸€èˆ¬ä¼šæˆåŠŸ invokers = localMethodInvokerMap.get(methodName); &#125; if (invokers == null) &#123; // 3.3 é€šè¿‡é€šé…ç¬¦ * è·å– Invoker é›†åˆï¼Œå¦‚ å›å£°æ¢æµ‹æ–¹æ³• invokers = localMethodInvokerMap.get(Constants.ANY_VALUE); &#125; if (invokers == null) &#123; //4 ä½¿ç”¨ methodInvokerMap ç¬¬ä¸€ä¸ªInvokerã€‚é˜²å¾¡æ€§ç¼–ç¨‹ã€‚ Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator = localMethodInvokerMap.values().iterator(); if (iterator.hasNext()) &#123; invokers = iterator.next(); &#125; &#125; &#125; // 4 è¿”å›ç›®æ ‡Invokeré›†åˆ return invokers == null ? new ArrayList&lt;Invoker&lt;T&gt;&gt;(0) : invokers; &#125; ä»¥ä¸Šæ–¹æ³•ç”¨äºä» RegistryDirectory çš„ Invoker ç¼“å­˜ä¸­è·å–æœ¬æ¬¡è°ƒç”¨çš„æ¶ˆè´¹ç«¯ Invoker åˆ—è¡¨ã€‚å…¶ä¸­è·å–çš„æ–¹å¼æœ‰ä»¥ä¸‹ 4 ç§ï¼š æ ¹æ®è°ƒç”¨çš„æ–¹æ³•å + å‚æ•°å€¼ç¡®å®šæœ€ç»ˆçš„è°ƒç”¨æ–¹æ³•åã€‚ä½¿ç”¨ä¾‹å­å¦‚ä¸‹ï¼š12345678910// æ¥å£å®šä¹‰public interface DemoService &#123; void hello(String name); void hello01(String name);&#125;// æ¶ˆè´¹æ–¹è°ƒç”¨DemoService demoService = (DemoService) context.getBean(\"demoService\");// æœ€ç»ˆè°ƒç”¨åˆ°çš„æ˜¯ DemoService ä¸­çš„ hello01 æ–¹æ³•demoService.hello(\"01\"); æ ¹æ®è°ƒç”¨æ–¹æ³•åè·å– Invoker é›†åˆã€‚ ä½¿ç”¨å…¨é‡ Invoker é›†åˆã€‚ åŸºäºé˜²å¾¡æ€§ç¼–ç¨‹ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ª Invoker é›†åˆã€‚ ä»¥ä¸Šæ–¹æ³•å¯ä»¥çœ‹ä½œæ˜¯å¯¹ RegistryDirectory ä¸­ Invoker ç¼“å­˜çš„è¯»æ“ä½œï¼Œå†™æ“ä½œæ˜¯åœ¨æ”¶åˆ°é€šçŸ¥çš„æ—¶å€™å®Œæˆçš„ï¼Œåç»­ä¼šè¯¦ç»†åˆ†æã€‚ è®¢é˜…1234567+--- RegistryDirectory public void subscribe(URL url) &#123; // è®¾ç½®æœåŠ¡æ¶ˆè´¹è€…URL setConsumerUrl(url); // å‘æ³¨å†Œä¸­å¿ƒå‘èµ·è®¢é˜… registry.subscribe(url, this); &#125; è¯¥æ–¹æ³•ä¼šåœ¨æ¶ˆè´¹ç«¯è¿›è¡Œè®¢é˜…æ—¶è¢«è°ƒç”¨ï¼Œé€šè¿‡è°ƒç”¨ Registry çš„ subscribe æ–¹æ³•å®Œæˆè®¢é˜…ï¼ŒåŒæ—¶è¿˜ä¼šå°†å½“å‰ RegistryDirectory ä»¥ NotifyListener ç›‘å¬å™¨å½¢å¼æ·»åŠ åˆ° Registry ä¸Šã€‚ æ¶ˆè´¹ç«¯è®¢é˜…è§¦å‘æ—¶æœºæ˜¯åœ¨æœåŠ¡å¼•ç”¨è¿‡ç¨‹ï¼Œå…·ä½“æºç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546+--- RegistryProtocol /** * æ‰§è¡ŒæœåŠ¡å¼•ç”¨ï¼Œè¿”å›Invokerå¯¹è±¡ * * @param cluster Cluster å¯¹è±¡ * @param registry æ³¨å†Œä¸­å¿ƒå¯¹è±¡ * @param type æœåŠ¡æ¥å£ç±»å‹ * @param url æ³¨å†Œä¸­å¿ƒURL * @param &lt;T&gt; æ³›å‹ * @return Invoker å¯¹è±¡ */ private &lt;T&gt; Invoker&lt;T&gt; doRefer(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url) &#123; // 1 åˆ›å»ºRegistryDirectoryå¯¹è±¡ã€æœåŠ¡ç›®å½•ã€‘ï¼Œå¹¶è®¾ç½®æ³¨å†Œä¸­å¿ƒåˆ°å®ƒçš„å±æ€§ï¼Œè¯¥å¯¹è±¡åŒ…å«äº†æ³¨å†Œä¸­å¿ƒçš„æ‰€æœ‰æœåŠ¡æä¾›è€… List&lt;Invoker&gt; RegistryDirectory&lt;T&gt; directory = new RegistryDirectory&lt;T&gt;(type, url); // 1.1 è®¾ç½®æ³¨å†Œä¸­å¿ƒå’Œåè®® directory.setRegistry(registry); directory.setProtocol(protocol); // 2 è·å¾—æœåŠ¡å¼•ç”¨é…ç½®é›†åˆparametersã€‚æ³¨æ„ï¼šurlä¼ å…¥RegistryDirectoryåï¼Œç»è¿‡å¤„ç†å¹¶é‡æ–°åˆ›å»ºï¼Œæ‰€ä»¥ url != directory.urlï¼Œ Map&lt;String, String&gt; parameters = new HashMap&lt;String, String&gt;(directory.getUrl().getParameters()); // 3 ç”Ÿæˆæ¶ˆè´¹è€…URL URL subscribeUrl = new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters); // 4 æ³¨å†ŒæœåŠ¡æ¶ˆè´¹è€…ï¼Œåœ¨consumersç›®å½•ä¸‹ if (!Constants.ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) &#123; registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY, Constants.CHECK_KEY, String.valueOf(false))); &#125; // 5 å‘æ³¨å†Œä¸­å¿ƒè®¢é˜… æœåŠ¡æä¾›è€… + è·¯ç”±è§„åˆ™ + é…ç½®è§„åˆ™ èŠ‚ç‚¹ä¸‹çš„æ•°æ® directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY + \",\" + Constants.CONFIGURATORS_CATEGORY + \",\" + Constants.ROUTERS_CATEGORY)); // 6 åŸºäº RegistryDirectory åˆ›å»º Invoker å¯¹è±¡ Invoker invoker = cluster.join(directory); // å‘æœ¬åœ°æ³¨å†Œè¡¨ï¼Œæ³¨å†Œæ¶ˆè´¹è€… ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory); return invoker; &#125; æ¶ˆè´¹ç«¯åœ¨æœåŠ¡å¼•ç”¨è¿‡ç¨‹ä¼šè¿›è¡ŒæœåŠ¡è®¢é˜…ï¼Œå½“ç›‘å¬çš„èŠ‚ç‚¹å‘ç”Ÿå˜æ›´æ—¶ï¼Œæ³¨å†Œä¸­å¿ƒä¼šå°†èŠ‚ç‚¹ä¸‹çš„æ•°æ®ä»¥ å…¨é‡ å½¢å¼é€šçŸ¥ç»™è®¢é˜…æ–¹ï¼Œä¹Ÿå°±æ˜¯å¯¹åº”çš„ NotifyListener ä»¬ã€‚å…³äºè®¢é˜…é€šçŸ¥å¯ä»¥å‚è€ƒ è®¢é˜…é€šçŸ¥ ã€‚ä¸‹é¢ç²˜è´´æ³¨å†Œä¸­å¿ƒæ¨¡å—é€šçŸ¥é€»è¾‘ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public abstract class AbstractRegistry implements Registry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /* * è®¢é˜…URLæ˜ å°„çš„èŠ‚ç‚¹å¯¹åº”çš„å­èŠ‚ç‚¹å‘ç”Ÿå˜åŒ–æ—¶ï¼Œé€šçŸ¥ç›‘å¬å™¨ * @param url è®¢é˜…URL * @param listener è®¢é˜…ULRå¯¹åº”çš„ç›‘å¬å™¨ * @param urls è®¢é˜…URLæ˜ å°„çš„è·¯å¾„ä¸‹çš„å­è·¯å¾„é›†åˆï¼ˆå…¨é‡æ•°æ®ï¼‰ */ protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"notify url == null\"); &#125; if (listener == null) &#123; throw new IllegalArgumentException(\"notify listener == null\"); &#125; if ((urls == null || urls.isEmpty()) &amp;&amp; !Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; logger.warn(\"Ignore empty notify urls for subscribe url \" + url); return; &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Notify urls for subscribe url \" + url + \", urls: \" + urls); &#125; // 1 å°† `urls` æŒ‰ç…§ URLä¸­çš„ 'category` å‚æ•°è¿›è¡Œåˆ†ç±»ï¼Œæ·»åŠ åˆ°Mapé›†åˆresultä¸­ Map&lt;String, List&lt;URL&gt;&gt; result = new HashMap&lt;String, List&lt;URL&gt;&gt;(); // éå† for (URL u : urls) &#123; // å­è·¯å¾„URLæ˜¯å¦åŒ¹é…è®¢é˜…URL if (UrlUtils.isMatch(url, u)) &#123; // è·å–åˆ†ç±»ï¼Œé»˜è®¤ä¸º providers String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY); // åŠ å…¥åˆ°ç»“æœé›† List&lt;URL&gt; categoryList = result.get(category); if (categoryList == null) &#123; categoryList = new ArrayList&lt;URL&gt;(); result.put(category, categoryList); &#125; categoryList.add(u); &#125; &#125; if (result.size() == 0) &#123; return; &#125; // è·å¾—è®¢é˜…URLå¯¹åº”çš„ç¼“å­˜`notified`,å³é€šçŸ¥çš„ URL å˜åŒ–ç»“æœï¼ˆå…¨é‡æ•°æ®ï¼‰ï¼Œä¼šæŠŠresultä¸­çš„å€¼æ”¾å…¥åˆ° categoryNotifiedä¸­ Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url); if (categoryNotified == null) &#123; notified.putIfAbsent(url, new ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;()); categoryNotified = notified.get(url); &#125; // å¤„ç†é€šçŸ¥çš„ URL å˜åŒ–ç»“æœï¼ˆå…¨é‡æ•°æ®ï¼‰ï¼Œå³æŒ‰ç…§åˆ†ç±»ï¼Œå¾ªç¯å¤„ç†é€šçŸ¥çš„URLå˜åŒ–ç»“æœï¼ˆå…¨é‡æ•°æ®ï¼‰ for (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123; // è·å¾—åˆ†ç±»å String category = entry.getKey(); // è·å¾—åˆ†ç±»åå¯¹åº”çš„é€šçŸ¥ULRåˆ—è¡¨ List&lt;URL&gt; categoryList = entry.getValue(); // 1 å°†result è¦†ç›–åˆ° `notified`ç¼“å­˜ã€æ›´æ–°notifiedé›†åˆä¸­çš„é€šçŸ¥ULRåˆ—è¡¨ã€‘ï¼Œéœ€è¦æ³¨æ„ï¼šå½“æŸä¸ªåˆ†ç±»çš„æ•°æ®ä¸ºç©ºæ—¶ï¼Œä¼šä¾ç„¶æœ‰URLï¼Œå¦‚ empty://...` ï¼Œé€šè¿‡è¿™ç§æ–¹å¼ç»Ÿä¸€å¤„ç†æ‰€æœ‰è®¢é˜…URLå¯¹åº”çš„æ•°æ®ä¸ºç©ºçš„æƒ…å†µã€‚ categoryNotified.put(category, categoryList); // 2 ä¿å­˜è®¢é˜…urlå¯¹åº”çš„è¢«é€šçŸ¥çš„URLåˆ° propertieså’Œæ–‡ä»¶ ä¸­ // åœ¨å¾ªç¯ä¸­çš„ä¿å­˜çš„åŸå› æ˜¯ï¼Œè®¢é˜…urlå¯¹åº”çš„é€šçŸ¥urlå¯èƒ½æ˜¯å˜åŠ¨çš„ï¼Œä¸Šä¸€æ­¥çš„æ“ä½œä¼šæ›´æ–°notifiedé›†åˆï¼Œä¸ºäº†è®© propertieså’Œæ–‡ä»¶ä¸­çš„ è®¢é˜…-é€šçŸ¥å…³ç³»æ­£ç¡®å°±éœ€è¦ä¸æ–­æ›´æ–°ã€‚ saveProperties(url); // 3 è°ƒç”¨ä¼ å…¥çš„listenerçš„notify()æ–¹æ³• listener.notify(categoryList); &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; å› ä¸º RegistryDirectory ä½œä¸ºä¸€ä¸ª NotifyListener å‘æ³¨å†Œä¸­å¿ƒ Registry å‘èµ·äº†è®¢é˜…ï¼Œå› æ­¤ä¼šæ”¶åˆ°é€šçŸ¥ã€‚ç”±é€šçŸ¥ä»£ç é€»è¾‘å¯çŸ¥ï¼Œæ˜¯æŒ‰ç…§åˆ†ç±»å¾ªç¯é€šçŸ¥çš„ï¼Œä¹Ÿå°±è¯´å¯èƒ½è®¢é˜…çš„åˆ†ç±»æœ‰å¤šä¸ªï¼Œä½†æ˜¯æ¯æ¬¡é€šçŸ¥åªæœ‰ä¸€ç±» URL ã€‚ é€šçŸ¥RegistryDirectory æ˜¯ä¸€ä¸ªåŠ¨æ€æœåŠ¡ç›®å½•ï¼Œå®ƒéœ€è¦ç›‘å¬æ³¨å†Œä¸­å¿ƒä¸Šçš„ç›¸å…³æ•°æ®å˜æ›´è¿›è€ŒåŠ¨æ€è°ƒæ•´ï¼Œå› æ­¤å®ç°äº† NotifyListener æ¥å£ï¼Œé€šè¿‡è¯¥æ¥å£è·å–æ³¨å†Œä¸­å¿ƒå˜æ›´é€šçŸ¥ã€‚ä¸‹é¢æˆ‘ä»¬æ¥çœ‹å…·ä½“å®ç°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960+--- RegistryDirectory @Override public synchronized void notify(List&lt;URL&gt; urls) &#123; // 1 æ ¹æ®URLçš„åˆ†ç±»ï¼Œåˆ†æˆä¸‰ä¸ªç±»åˆ«ï¼š1 æœåŠ¡æä¾›è€…URL 2 è·¯ç”±URL 3 é…ç½®URL List&lt;URL&gt; invokerUrls = new ArrayList&lt;URL&gt;(); List&lt;URL&gt; routerUrls = new ArrayList&lt;URL&gt;(); List&lt;URL&gt; configuratorUrls = new ArrayList&lt;URL&gt;(); // 2 éå† urlsï¼Œè¿›è¡Œåˆ†ç±» for (URL url : urls) &#123; // 2.1 è·å–åè®® String protocol = url.getProtocol(); // 2.2 è·å– category å‚æ•°çš„å€¼ï¼Œé»˜è®¤æ˜¯ providers String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY); // 2.3 æ ¹æ® category å‚æ•°å°† url åˆ†åˆ«æ”¾åˆ°ä¸åŒçš„åˆ—è¡¨ä¸­ // 2.3.1 ç¬¦åˆè·¯ç”±è§„åˆ™ if (Constants.ROUTERS_CATEGORY.equals(category) || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123; routerUrls.add(url); // 2.3.2 ç¬¦åˆé…ç½®è§„åˆ™ &#125; else if (Constants.CONFIGURATORS_CATEGORY.equals(category) || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123; configuratorUrls.add(url); // 2.3.3 ç¬¦åˆæœåŠ¡æä¾›è€… &#125; else if (Constants.PROVIDERS_CATEGORY.equals(category)) &#123; invokerUrls.add(url); &#125; else &#123; logger.warn(\"Unsupported category \" + category + \" in notified url: \" + url + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost()); &#125; &#125; // 3 configurators ä¸‹çš„æ•°æ®å˜æ›´ï¼Œåˆ™å°†é…ç½®è§„åˆ™URLé›†åˆè½¬æ¢æˆå¯¹åº”çš„ Configurator é›†åˆ if (configuratorUrls != null &amp;&amp; !configuratorUrls.isEmpty()) &#123; this.configurators = toConfigurators(configuratorUrls); &#125; // 4 routers ä¸‹çš„æ•°æ®å˜æ›´ï¼Œåˆ™å°†è·¯ç”±URLé›†åˆè½¬æ¢æˆå¯¹åº”çš„Routeré›†åˆ if (routerUrls != null &amp;&amp; !routerUrls.isEmpty()) &#123; List&lt;Router&gt; routers = toRouters(routerUrls); // å¦‚æœå¤„ç†å¾—åˆ°çš„Routeréç©ºï¼Œè°ƒç”¨çˆ¶ç±»çš„#setRoutersæ–¹æ³•ï¼Œè®¾ç½®è·¯ç”±è§„åˆ™ã€‚ if (routers != null) &#123; setRouters(routers); &#125; &#125; // 5 åˆå¹¶é…ç½®è§„åˆ™åˆ° directoryUrl, å½¢æˆ overrideDirectoryUrl å˜é‡ List&lt;Configurator&gt; localConfigurators = this.configurators; this.overrideDirectoryUrl = directoryUrl; if (localConfigurators != null &amp;&amp; !localConfigurators.isEmpty()) &#123; for (Configurator configurator : localConfigurators) &#123; // ä½¿ç”¨é…ç½®è§„åˆ™å™¨ å°† é…ç½®è§„åˆ™åº”ç”¨åˆ° overrideDirectoryUrl this.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl); &#125; &#125; // 6 åˆ·æ–°Invokeråˆ—è¡¨ refreshInvoker(invokerUrls); &#125; é€šè¿‡å‰é¢çš„ä»‹ç»æˆ‘ä»¬çŸ¥é“ï¼Œåœ¨æœåŠ¡å¼•ç”¨çš„è¿‡ç¨‹ä¸­ä¼šåˆ›å»º RegistryDirectory å¯¹è±¡ï¼Œä¸€æ–¹é¢åšä¸º NotifyListener ç›‘å¬æ³¨å†Œä¸­å¿ƒçš„ providersã€configurators å’Œ routers ä¸‰ä¸ªç›®å½•ï¼Œæ‰€ä»¥åœ¨è¿™ä¸‰ä¸ªç›®å½•ä¸‹å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œå°±ä¼šè§¦å‘ RegistryDirectory çš„ notify æ–¹æ³•ã€‚å¦ä¸€æ–¹é¢ä½œä¸ºæ¶ˆè´¹ç«¯çš„ Invoker æºä¾›é›†ç¾¤ç­–ç•¥ä½¿ç”¨ã€‚åœ¨è¯¥æ–¹æ³•ä¸­ï¼Œé¦–å…ˆä¼šæŒ‰ç…§ category å‚æ•° å¯¹å˜æ›´çš„ URL è¿›è¡Œåˆ†ç±»ï¼Œå¹¶åˆ†åˆ«å¯¹ä¸åŒç±»å‹çš„ URL è¿›è¡Œå¤„ç†ï¼š å°† router ç±»å‹çš„ URL è½¬åŒ–ä¸º Router ï¼Œå¹¶ä¿å­˜åˆ°æœåŠ¡ç›®å½•ä¸­ã€‚ å°† configurators ç±»å‹çš„ URL è½¬åŒ–ä¸º Configurator ï¼Œå¹¶ä¿å­˜åˆ°æœåŠ¡ç›®å½•ä¸­ã€‚ å°† provider ç±»å‹çš„ URL è½¬åŒ–ä¸º Invoker ï¼Œå¹¶ä¿å­˜åˆ°æœåŠ¡ç›®å½•ä¸­ï¼Œè¯¥è¿‡ç¨‹æ˜¯æœ€æ ¸å¿ƒçš„é€»è¾‘ã€‚ RegistryDirectory ä¸­æœ‰å¾ˆå¤šæ ¸å¿ƒå±æ€§ï¼Œå®ƒä»¬çš„æ›´æ–°ä¸»è¦åœ¨æ³¨å†Œä¸­å¿ƒé€šçŸ¥çš„è¿‡ç¨‹ï¼ŒDubbo ä½¿ç”¨äº† synchronized é”æ¥å¤„ç†çº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚ å…¶ä¸­åœ¨å°† configurators ç±»å‹ URL è½¬ä¸º Configurator åï¼Œè¿˜ä¼šå°†é…ç½®è§„åˆ™åº”ç”¨åœ¨ overrideDirectoryUrl ã€‚ä¸‹é¢æˆ‘ä»¬å¯¹ä»¥ä¸Š 3 ä¸ªå…³é”®æµç¨‹è¿›è¡Œåˆ†æã€‚ è½¬æ¢ Configurator123456789101112131415161718192021222324252627282930313233343536+--- RegistryDirectorypublic static List&lt;Configurator&gt; toConfigurators(List&lt;URL&gt; urls) &#123; // 1 é…ç½®è§„åˆ™URLé›†åˆä¸ºç©ºï¼Œè¡¨ç¤ºä¸ä½¿ç”¨é…ç½®è§„åˆ™ if (urls == null || urls.isEmpty()) &#123; return Collections.emptyList(); &#125; // 2 éå†é…ç½®è§„åˆ™ URL ï¼Œåˆ›å»ºConfigurator é…ç½®è§„åˆ™ List&lt;Configurator&gt; configurators = new ArrayList&lt;Configurator&gt;(urls.size()); for (URL url : urls) &#123; // 2.1 å¦‚æœåè®®ä¸º empty:// ï¼Œä¼šæ¸…ç©ºæ‰€æœ‰é…ç½®è§„åˆ™ï¼Œè¿”å›ç©ºé›†åˆ if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) &#123; configurators.clear(); break; &#125; // 2.2 è·å–é…ç½®è§„åˆ™URLçš„key-valueå‚æ•°é›†åˆ Map&lt;String, String&gt; override = new HashMap&lt;String, String&gt;(url.getParameters()); // 2.3 override ä¸Šçš„ anyhost å¯èƒ½æ˜¯è‡ªåŠ¨æ·»åŠ çš„ï¼Œä¸ºäº†é˜²æ­¢å½±å“ä¸‹é¢çš„åˆ¤æ–­ï¼Œéœ€è¦å…ˆåˆ é™¤æ‰ override.remove(Constants.ANYHOST_KEY); // 2.4 å¦‚æœé…ç½®Urlå‚æ•°éƒ¨åˆ†ä¸ºç©ºï¼Œä¼šæ¸…ç©ºæ‰€æœ‰é…ç½®è§„åˆ™ if (override.size() == 0) &#123; configurators.clear(); continue; &#125; // 2.5 ç”±å·¥å‚åˆ›å»ºConfigurator å¯¹è±¡ï¼Œå¹¶æ·»åŠ åˆ° configurators é›†åˆä¸­ configurators.add(configuratorFactory.getConfigurator(url)); &#125; // å¯¹å¤šä¸ªé…ç½®è§„åˆ™å¯¹è±¡æ’åº Collections.sort(configurators); return configurators; &#125; ä»¥ä¸Šæ–¹æ³•ç”¨äºå°†é…ç½®è§„åˆ™ URL è½¬æ¢æˆå¯¹åº”çš„é…ç½®è§„åˆ™ Configurator å¯¹è±¡ï¼Œç”¨äºå®ç°æœåŠ¡æ²»ç†åŠŸèƒ½ã€‚é…ç½®è§„åˆ™ URL å¯èƒ½å€¼å¦‚ä¸‹ï¼š override://0.0.0.0/â€¦( or override://ip:portâ€¦?anyhost=true)&amp;para1=value1â€¦ means global rules (all of the providers take effect) ## è¡¨ç¤ºå…¨å±€è§„åˆ™ï¼ˆå¯¹æ‰€æœ‰çš„æä¾›è€…å…¨éƒ¨ç”Ÿæ•ˆï¼‰ override://ip:portâ€¦?anyhost=false Special rules (only for a certain provider) ## ç‰¹æ®Šè§„åˆ™ï¼ˆåªé’ˆå¯¹æŸä¸ªæä¾›è€…ç”Ÿæ•ˆï¼‰ override:// rule is not supportedâ€¦ ,needs to be calculated by registry itself. ## ä¸æ”¯æŒoverride:// è§„åˆ™ï¼Œéœ€è¦æ³¨å†Œä¸­å¿ƒè‡ªè¡Œè®¡ç®— override://0.0.0.0/ without parameters means clearing the override ## ä¸å¸¦å‚æ•°,è¡¨ç¤ºæ¸…é™¤override è½¬æ¢ Router12345678910111213141516171819202122232425262728293031323334353637+--- RegistryDirectory private List&lt;Router&gt; toRouters(List&lt;URL&gt; urls) &#123; List&lt;Router&gt; routers = new ArrayList&lt;Router&gt;(); // 1 è·¯ç”±è§„åˆ™ URLé›†åˆåˆ¤ç©º if (urls == null || urls.isEmpty()) &#123; return routers; &#125; // 2 éå†è·¯ç”±è§„åˆ™ URL if (urls != null &amp;&amp; !urls.isEmpty()) &#123; for (URL url : urls) &#123; // 2.1 å¦‚æœæ˜¯ empty:// ï¼Œåˆ™å¿½ç•¥ã€‚ // ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå½“æ‰€æœ‰è·¯ç”±è§„åˆ™è¢«åˆ é™¤æ—¶ï¼Œæœ‰ä¸”ä»…æœ‰ä¸€æ¡åè®®ä¸º empty:// çš„è·¯ç”±è§„åˆ™ URL if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) &#123; continue; &#125; // 2.2 è·å–é…ç½®çš„ router é…ç½®é¡¹ï¼Œå¦‚æœæœ‰è®¾ç½®åˆ™ä½¿ç”¨è®¾ç½®çš„é…ç½®é¡¹ String routerType = url.getParameter(Constants.ROUTER_KEY); if (routerType != null &amp;&amp; routerType.length() &gt; 0) &#123; url = url.setProtocol(routerType); &#125; try &#123; // 2.3 é€šè¿‡è·¯ç”±å·¥å‚åˆ›å»º Router Router router = routerFactory.getRouter(url); if (!routers.contains(router)) &#123; routers.add(router); &#125; &#125; catch (Throwable t) &#123; logger.error(\"convert router url to router error, url: \" + url, t); &#125; &#125; &#125; return routers; &#125; ä»¥ä¸Šæ–¹æ³•ç”¨äºå°†è·¯ç”±è§„åˆ™ URL è½¬æ¢æˆå¯¹åº”è·¯ç”±è§„åˆ™ Router å¯¹è±¡ï¼Œç”¨äºè¿‡æ»¤æœåŠ¡ç›®å½•ä¸­çš„æœåŠ¡é›†åˆã€‚ åˆ·æ–° Invoker åˆ—è¡¨åˆ·æ–° Invoker åˆ—è¡¨æ˜¯ä¸ºäº†ä¿è¯æœåŠ¡ç›®å½•éšæ³¨å†Œä¸­å¿ƒå˜åŒ–è€Œå˜åŒ–ï¼Œä½¿æ¶ˆè´¹ç«¯çš„ Invoker æ˜¯æœ€æ–°çš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970+--- RegistryDirectory// invokerUrls æ˜¯ .../providers è·¯å¾„ä¸‹çš„å­è·¯å¾„åˆ—è¡¨ï¼Œå…¨é‡æ•°æ®private void refreshInvoker(List&lt;URL&gt; invokerUrls) &#123; // 1 æ‰€æœ‰æœåŠ¡ä¸å¯ç”¨ // å½“ invokerUrls é›†åˆå¤§å°ä¸º1ï¼Œå¹¶ä¸”åè®®æ˜¯ empty://ï¼Œè¯´æ˜æ‰€æœ‰çš„æœåŠ¡éƒ½å·²ç»ä¸‹çº¿äº†ï¼Œå³ç¦ç”¨æ‰€æœ‰æœåŠ¡ã€‚Zookeeper å†Œä¸­å¿ƒå¯å‚è§ &#123;@link ZookeeperRegistry#toUrlsWithEmpty&#125; if (invokerUrls != null &amp;&amp; invokerUrls.size() == 1 &amp;&amp; invokerUrls.get(0) != null &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) &#123; // 1.1 è®¾ç½®ç¦æ­¢è®¿é—®ï¼Œåç»­è¯·æ±‚å°†ç›´æ¥æŠ›å‡ºå¼‚å¸¸ this.forbidden = true; // 1.2 ç½®ç©º æ–¹æ³•åä¸Invokeré›†åˆæ˜ å°„ methodInvokerMap this.methodInvokerMap = null; // 1.3 æ¸…ç©º Invoker ç¼“å­˜ï¼Œé”€æ¯æ‰€æœ‰çš„ Invoker destroyAllInvokers(); // 2 å­˜åœ¨å¯ç”¨æœåŠ¡ &#125; else &#123; // 2.1 è®¾ç½®å…è®¸è®¿é—® this.forbidden = false; // 2.2 ä¿å­˜æ—§çš„ urlInvokerMapï¼Œä¸ºåç»­é€»è¾‘æ˜¯å¦å­˜åœ¨æ— æ•ˆçš„ invoker ä½œä¸ºåˆ¤æ–­ä¾æ®ã€‚ Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = this.urlInvokerMap; // 2.3 ä¼ å…¥çš„ invokerUrls ä¸ºç©ºè¯´æ˜ æ³¨å†Œä¸­å¿ƒä¸­çš„ providers ç›®å½•æœªå‘ç”Ÿå˜åŒ–ï¼Œ // æ˜¯è·¯ç”±è§„åˆ™æˆ–è€…é…ç½®è§„åˆ™å‘ç”Ÿæ”¹å˜ã€‚é‚£ä¹ˆç›´æ¥ä½¿ç”¨ç¼“å­˜çš„æœåŠ¡æä¾›è€… Invoker çš„URLé›†åˆ if (invokerUrls.isEmpty() &amp;&amp; this.cachedInvokerUrls != null) &#123; invokerUrls.addAll(this.cachedInvokerUrls); // 2.4 ä¼ å…¥çš„ invokerUrls éç©ºï¼Œè¯´æ˜æ³¨å†Œä¸­å¿ƒä¸­çš„ providers ç›®å½•å‘ç”Ÿäº†æ”¹å˜ï¼Œå³æœåŠ¡æä¾›è€…å‘ç”Ÿäº†æ”¹å˜ï¼ˆç¬¬ä¸€æ¬¡å…¨é‡æ‹‰å–æ•°æ®ä¹Ÿæ˜¯ä¸€ç§æ”¹å˜ï¼Œä»æ— åˆ°æœ‰ï¼‰ // åˆ™ä½¿ç”¨ä¼ å…¥çš„ invokerUrls æ›´æ–° cachedInvokerUrls &#125; else &#123; this.cachedInvokerUrls = new HashSet&lt;URL&gt;(); //ç¼“å­˜invokerUrlsåˆ—è¡¨ï¼Œä¾¿äºäº¤å‰å¯¹æ¯” this.cachedInvokerUrls.addAll(invokerUrls); &#125; // 2.4 invokerUrls ä¸ºç©ºåˆ™ç›´æ¥å¿½ç•¥ï¼ˆä¾‹å¦‚ï¼šåˆå§‹æ˜¯æŒ‰ç…§ configurators =&gt; routers =&gt; providers ï¼Œé‚£ä¹ˆå‰ä¸¤ä¸ªä¼šå‡ºç°ä¸ºç©ºçš„æƒ…å†µï¼‰ if (invokerUrls.isEmpty()) &#123; return; &#125; // 2.5 å°†å˜æ›´çš„URLåˆ—è¡¨è½¬æˆ URLä¸² åˆ° Invoker çš„æ˜ å°„ (æœ€æ ¸å¿ƒçš„æ–¹æ³•) Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map // 2.6 å°†ä¸Šä¸€æ­¥å¾—åˆ°çš„ newUrlInvokerMap è½¬æ¢æˆ æ–¹æ³•ååˆ°Invokeråˆ—è¡¨çš„æ˜ å°„ Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); // Change method name to map Invoker Map // 2.7 å¦‚æœè½¬æ¢é”™è¯¯ï¼Œåˆ™å¿½ç•¥æœ¬æ¬¡è½¬æ¢ if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) &#123; logger.error(new IllegalStateException(\"urls to invokers error .invokerUrls.size :\" + invokerUrls.size() + \", invoker.size :0. urls :\" + invokerUrls.toString())); return; &#125; // 2.8 å¦‚æœå¼•ç”¨å¤šä¸ªæœåŠ¡åˆ†ç»„ï¼Œé‚£ä¹ˆå°±æŒ‰ç…§ method + group ç»´åº¦åˆå¹¶Invoker this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap; // 2.9 ä¿å­˜ URLä¸² åˆ° Invoker çš„æ˜ å°„ this.urlInvokerMap = newUrlInvokerMap; try &#123; // 2.10 æ¯”è¾ƒæ–°æ—§ä¸¤ç»„ Invoker é›†åˆï¼Œé”€æ¯å·²ç»ä¸‹çº¿çš„ Invoker é›†åˆï¼Œé¿å…æœåŠ¡æ¶ˆè´¹æ–¹è°ƒç”¨å·²ç»ä¸‹çº¿çš„æœåŠ¡ destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker &#125; catch (Exception e) &#123; logger.warn(\"destroyUnusedInvokers error. \", e); &#125; &#125; &#125; æœåŠ¡ç›®å½•è½¬æ¢æœåŠ¡æä¾›è€…URL -&gt; Invoker çš„è§„åˆ™å¦‚ä¸‹ï¼š å¦‚æœ URL å·²ç»è½¬æ¢ä¸º Invokerï¼Œåˆ™ä¸å†é‡æ–°å¼•ç”¨ï¼Œç›´æ¥ä»ç¼“å­˜ä¸­è·å–ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœ URL ä¸­ä»»ä½•ä¸€ä¸ªå‚æ•°å˜æ›´éƒ½ä¼šé‡æ–°å¼•ç”¨ã€‚ å¦‚æœä¼ å…¥çš„æœåŠ¡æä¾›è€…URLåˆ—è¡¨å¤§å°ä¸º 1 ä¸”åè®®æ˜¯ empty://ï¼Œè¯´æ˜æ‰€æœ‰çš„æœåŠ¡éƒ½å·²ç»ä¸‹çº¿ï¼Œè¦ç¦ç”¨æ‰€æœ‰æœåŠ¡ã€‚ å¦‚å¤šä¼ å…¥çš„æœåŠ¡æä¾›è€…URLåˆ—è¡¨ä¸ºç©ºï¼Œåˆ™è¡¨ç¤ºåªæ˜¯ä¸‹å‘é…ç½®è§„åˆ™å’Œè·¯ç”±è§„åˆ™ã€‚ æ³¨æ„ï¼Œä¸Šé¢è§„åˆ™ä¸­æåˆ°çš„ URL å¹¶éæ˜¯æœåŠ¡æä¾›è€…URLï¼Œè€Œæ˜¯åˆå¹¶åçš„æœåŠ¡æä¾›è€…URLï¼Œå…³äºåˆå¹¶è§„åˆ™ä¸‹æ–‡ä¼šè¯¦ç»†è¯´æ˜ã€‚ åˆ·æ–° Invoker åˆ—è¡¨çš„é€»è¾‘å¦‚ä¸‹ï¼š æ ¹æ®å…¥å‚ invokerUrls çš„æ•°é‡å’Œåè®®åˆ¤æ–­æ˜¯å¦ç¦ç”¨æ‰€æœ‰æœåŠ¡ï¼Œå¦‚æœç¦ç”¨åˆ™å°†ç¦ç”¨æ ‡å¿— forbidden è®¾ç½®ä¸º true ï¼Œå¹¶é”€æ¯å¼•ç”¨æ‰€æœ‰çš„ Invoker ã€‚ éç¦ç”¨ï¼Œåˆ™å°† invokerUrls ä¸­çš„ URL è¿›è¡Œåˆå¹¶æ“ä½œï¼Œç„¶åè½¬æ¢æˆ Invokerï¼ˆå¼•ç”¨ Invokerï¼‰ï¼Œå¾—åˆ°æ–°çš„ &lt;urlä¸²,Invoker&gt; çš„æ˜ å°„å…³ç³»ã€‚ å°†ç¬¬ 2 æ­¥ä¸­å¾—åˆ°çš„ &lt;urlä¸²,Invoker&gt; è¿›ä¸€æ­¥è½¬æˆ &lt;methodName,Invokeråˆ—è¡¨&gt; ã€‚ å¦‚æœæ¶ˆè´¹æ–¹å¼•ç”¨å¤šä¸ªæœåŠ¡åˆ†ç»„ï¼Œåˆ™æ ¹æ® method + group è¿›è¡Œå¤šç»„åˆå¹¶æ“ä½œï¼ŒåŒæ ·å¾—åˆ° &lt;methodName,Invokeråˆ—è¡¨&gt; æ•°æ®ï¼ŒdoList æ–¹æ³•ä¸­è¯»å–çš„å°±æ˜¯è¯¥æ•°æ®ï¼Œè€Œè¿™é‡Œæ˜¯å†™æ“ä½œã€‚ æ–°çš„æ¶ˆè´¹ç«¯ Invoker åˆ—è¡¨ç”Ÿæˆåï¼Œæ ¹æ®ç¬¬ 2 æ­¥å¾—åˆ°çš„ &lt;urlä¸²,Invoker&gt; ï¼ŒåŒæ—§çš„ &lt;urlä¸²,Invoker&gt; å¯¹æ¯”ï¼Œé”€æ¯æ— ç”¨çš„ Invokerï¼Œé¿å…æœåŠ¡æ¶ˆè´¹è€…è°ƒç”¨å·²ç»ä¸‹çº¿çš„æœåŠ¡ã€‚ åˆ·æ–° Invoker é€»è¾‘ä¸­ä¼šå˜æ›´ä¸¤ä¸ªæ ¸å¿ƒçš„å±æ€§ï¼šurlInvokerMap å’Œ methodInvokerMap ï¼Œå‰è€…ä»¥URLç»´åº¦åè€…ä»¥æ–¹æ³•åç»´åº¦ï¼Œå‰è€…ç”¨äºåˆ¤æ–­æ˜¯å¦éœ€è¦é‡æ–°å¼•ç”¨æœåŠ¡ï¼Œåè€…ç”¨äºå­˜å‚¨å¼•ç”¨çš„Invokeré›†åˆä¾› doList æ–¹æ³•æ‹‰å–ã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬å¯¹ä¸Šé¢æ¶‰åŠåˆ°çš„æ ¸å¿ƒæ­¥éª¤è¿›è¡Œåˆ†æã€‚ è½¬æ¢ Invoker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104+--- RegistryDirectory private Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123; // &lt;URLä¸²,Invoker&gt; Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = new HashMap&lt;String, Invoker&lt;T&gt;&gt;(); // è‹¥ä¸ºç©ºç›´æ¥è¿”å› if (urls == null || urls.isEmpty()) &#123; return newUrlInvokerMap; &#125; // 1 è®°å½•å·²åˆå§‹åŒ–çš„æœåŠ¡æä¾›è€…URLä¸²ï¼Œå³å·²ç»å¤„ç†è¿‡çš„æœåŠ¡æä¾›è€…URL Set&lt;String&gt; keys = new HashSet&lt;String&gt;(); // 2 è·å–æ¶ˆè´¹è€…é…ç½®çš„åè®® (ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸åœ¨æ¶ˆè´¹ç«¯ &lt;dubbo:reference protocol=\"\"/&gt; é…ç½®æœåŠ¡åè®®) String queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY); // 3 å¾ªç¯éå†å˜æ›´çš„æä¾›è€…URLé›†åˆ for (URL providerUrl : urls) &#123; // 4 å¯¹æ¶ˆè´¹ç«¯é…ç½®åè®®çš„å¤„ç†é€»è¾‘ // 4.1 å¦‚æœæ¶ˆè´¹ç«¯é…ç½®äº†åè®®ï¼Œåˆ™åªé€‰æ‹©å’Œæ¶ˆè´¹ç«¯åŒ¹é…çš„åè®® if (queryProtocols != null &amp;&amp; queryProtocols.length() &gt; 0) &#123; boolean accept = false; // å¯èƒ½é…ç½®äº†å¤šåè®® String[] acceptProtocols = queryProtocols.split(\",\"); // 4.2 æ ¹æ®æ¶ˆè´¹æ–¹protocolè¿‡æ»¤ä¸åŒ¹é…åè®®ï¼Œå› ä¸ºDubboå…è®¸åœ¨æ¶ˆè´¹æ–¹é…ç½®åªæ¶ˆè´¹æŒ‡å®šåè®®çš„æœåŠ¡ for (String acceptProtocol : acceptProtocols) &#123; if (providerUrl.getProtocol().equals(acceptProtocol)) &#123; accept = true; break; &#125; &#125; // 4.3 å¦‚æœå½“å‰URLä¸æ”¯æŒConsumerç«¯çš„åè®®ï¼Œä¹Ÿå°±æ— æ³•æ‰§è¡Œåç»­è½¬æ¢æˆInvokerçš„é€»è¾‘ if (!accept) &#123; continue; &#125; &#125; // 5 è·³è¿‡ empty:// åè®®çš„ URL if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123; continue; &#125; // 6 å¦‚æœæ¶ˆè´¹ç«¯ä¸æ”¯æŒå˜æ›´çš„æœåŠ¡ç«¯çš„åè®®ï¼Œåˆ™å¿½ç•¥ if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123; logger.error(new IllegalStateException(\"Unsupported protocol \" + providerUrl.getProtocol() + \" in notified url: \" + providerUrl + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost() + \", supported protocol: \" + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions())); continue; &#125; // 7 åˆå¹¶URLæ•°æ®ï¼Œå³å°†é…ç½®è§„åˆ™ï¼Œæ¶ˆè´¹ç«¯é…ç½®å‚æ•°åˆå¹¶åˆ°æœåŠ¡æä¾›è€…URlä¸­ // æ³¨æ„æœåŠ¡æä¾›è€…URLçš„ä¸»ä½“ä¿¡æ¯ä¸å˜ï¼Œåˆå¹¶çš„åªæ˜¯å‚æ•°éƒ¨åˆ† URL url = mergeUrl(providerUrl); // 8 URLå­—ç¬¦ä¸²ï¼Œè¯¥å­—ç¬¦ä¸²æ˜¯æœåŠ¡æä¾›è€…URLåˆå¹¶å¤„ç†åçš„ï¼Œä½œä¸ºæ˜¯å¦éœ€è¦é‡æ–°å¼•ç”¨çš„æ ‡å¿— String key = url.toFullString(); // 9 è·³è¿‡é‡å¤çš„ URLï¼Œé˜²æ­¢é‡å¤å¼•ç”¨ if (keys.contains(key)) &#123; continue; &#125; // åŠ å…¥åˆ° keys é›†åˆä¸­ï¼Œä¸ºäº†é˜²æ­¢é‡å¤ keys.add(key); // 10 åˆ¤æ–­ key æ˜¯å¦å·²ç»å¼•ç”¨è¿‡ï¼Œå¼•ç”¨è¿‡åˆ™æ— éœ€é‡æ–°å¼•ç”¨ï¼Œç›´æ¥ä½¿ç”¨å¯¹åº”çš„ç¼“å­˜å³å¯ // å¦‚æœæ²¡æœ‰å¼•ç”¨è¿‡ï¼Œåˆ™é€šè¿‡ Protocol.refer æ–¹æ³•å¼•ç”¨æœåŠ¡ï¼Œåˆ›å»º Invoker Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = this.urlInvokerMap; Invoker&lt;T&gt; invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key); // æ²¡æœ‰å¼•ç”¨è¿‡ if (invoker == null) &#123; try &#123; // é€šè¿‡è·å–é…ç½®é¡¹ enable å’Œ disable çš„å€¼åˆ¤æ–­æœåŠ¡æ˜¯å¦å¼€å¯ boolean enabled = true; if (url.hasParameter(Constants.DISABLED_KEY)) &#123; enabled = !url.getParameter(Constants.DISABLED_KEY, false); &#125; else &#123; enabled = url.getParameter(Constants.ENABLED_KEY, true); &#125; // å¦‚æœå¼€å¯ï¼Œåˆ™åˆ›å»º Invoker å¯¹è±¡ if (enabled) &#123; // é€šè¿‡ Protocol.refer æ–¹æ³•åˆ›å»ºå¯¹åº”çš„ Invoker å¯¹è±¡ï¼Œå¹¶ä½¿ç”¨ InvokerDelegate è£…é¥°å¼•ç”¨çš„ Invoker invoker = new InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl); &#125; &#125; catch (Throwable t) &#123; logger.error(\"Failed to refer invoker for interface:\" + serviceType + \",url:(\" + url + \")\" + t.getMessage(), t); &#125; // å°†keyå’ŒInvokerå¯¹è±¡ä¹‹é—´çš„æ˜ å°„å…³ç³»è®°å½•åˆ°newUrlInvokerMapä¸­ if (invoker != null) &#123; newUrlInvokerMap.put(key, invoker); &#125; // ç¼“å­˜å‘½ä¸­ï¼Œç›´æ¥ä½¿ç”¨ç¼“å­˜çš„ Invoker &#125; else &#123; newUrlInvokerMap.put(key, invoker); &#125; &#125; // 11 æ¸…ç©ºkeysæ ‡è®°é›†åˆ keys.clear(); // 12 è¿”å›æ–°çš„æ¶ˆè´¹ç«¯ Invoker return newUrlInvokerMap; &#125; è½¬æ¢ Invoker æ–¹æ³•ç”¨äºå°†æœåŠ¡æä¾›è€…URLæœ€ç»ˆè½¬ä¸ºInvokerï¼Œå³ä½¿ç”¨protocol.referæ–¹æ³•è¿›è¡ŒæœåŠ¡å¼•ç”¨ï¼Œä¹Ÿå°±æ˜¯ä¸€æ¡æœåŠ¡æä¾›è€…URLå¯¹åº”ä¸€ä¸ªæ¶ˆè´¹ç«¯Invokerã€‚ä¸»è¦æ ¸å¿ƒé€»è¾‘å¦‚ä¸‹ï¼š å¯¹æœåŠ¡æä¾›è€… URL è¿›è¡Œæ£€æµ‹ï¼Œè‹¥æœåŠ¡æ¶ˆè´¹ç«¯çš„é…ç½®ä¸æ”¯æŒæœåŠ¡ç«¯çš„åè®®ï¼Œæˆ–æœåŠ¡ç«¯ URL åè®®å¤´ä¸º empty æ—¶ï¼Œåˆ™å¿½ç•¥æœåŠ¡æä¾›æ–¹ URLã€‚ åˆå¹¶ URL ï¼Œå³å°†é…ç½®è§„åˆ™å’Œæ¶ˆè´¹ç«¯é…ç½®å‚æ•°åˆå¹¶åˆ°æœåŠ¡æä¾›è€…URLä¸­ã€‚ æ ¹æ®åˆå¹¶åçš„ URL è®¿é—®ç¼“å­˜ï¼Œå°è¯•è·å–ä¸ URL å¯¹åº”çš„ Invokerã€‚ç¼“å­˜æœªå‘½ä¸­ï¼Œåˆ™é€šè¿‡ Protocol.refer è¿›è¡ŒæœåŠ¡å¼•ç”¨ï¼Œå¹¶å°†åˆ›å»ºçš„ Invoker è¿›è¡Œç¼“å­˜ã€‚ toInvokers() æ–¹æ³•çš„æ ¸å¿ƒé€»è¾‘å°±æ˜¯è°ƒç”¨ Protocol.refer() æ–¹æ³•åˆ›å»º Invoker å¯¹è±¡ï¼Œå…¶ä»–çš„é€»è¾‘éƒ½æ˜¯åœ¨åˆ¤æ–­æ˜¯å¦è°ƒç”¨è¯¥æ–¹æ³•ä»¥åŠè°ƒç”¨è¯¥æ–¹æ³•å‰çš„å‡†å¤‡å·¥ä½œã€‚ä¸‹é¢æˆ‘ä»¬å¯¹ URL å‚æ•°åˆå¹¶é€»è¾‘ç®€å•ä»‹ç»ã€‚ 123456789101112131415161718192021222324252627282930+--- RegistryDirectory private URL mergeUrl(URL providerUrl) &#123; // 1 å°†æ¶ˆè´¹ç«¯URLå‚æ•°é…ç½®é¡¹åˆå¹¶åˆ°æœåŠ¡æä¾›è€…çš„URLä¸­ // 1.1 ç§»é™¤ Provider URL ä¸­åªåœ¨ Provider ç«¯ç”Ÿæ•ˆçš„å±æ€§ï¼Œå¦‚ï¼šthreadnameã€threadpoolã€corethreadsã€threadsã€queuesã€aliveã€transporter // 1.2 ç”¨ Consumer ç«¯çš„å‚æ•°é…ç½®ï¼ˆparametersï¼‰è¦†ç›– Provider URL çš„ç›¸åº”é…ç½®ï¼Œä½†ï¼šversionã€groupã€methodsã€timestampç­‰å‚æ•°ä»¥Providerç«¯çš„é…ç½®ä¼˜å…ˆï¼Œå› ä¸ºå®ƒä»¬æ˜¯è¿œç¨‹é…ç½®çš„å‚æ•°ã€‚ // 1.3 åˆå¹¶ Provider ç«¯å’Œ Consumer ç«¯é…ç½®çš„ Filter ä»¥åŠ Listener providerUrl = ClusterUtils.mergeUrl(providerUrl, queryMap); // 2 åˆå¹¶é…ç½®è§„åˆ™URLåˆ° providerUrlä¸­ï¼Œé…ç½®è§„åˆ™URLå¯ä»¥æ˜¯ï¼š // 2.1 ç¬¬ä¸€ç±»æ˜¯æ³¨å†Œä¸­å¿ƒ Configurators ç›®å½•ä¸‹çš„çš„URLï¼ˆoverride åè®®ï¼‰ // 2.2 ç¬¬äºŒç±»æ˜¯æœåŠ¡æ²»ç†æ§åˆ¶å°åŠ¨æ€æ·»åŠ é…ç½® List&lt;Configurator&gt; localConfigurators = this.configurators; // local reference if (localConfigurators != null &amp;&amp; !localConfigurators.isEmpty()) &#123; for (Configurator configurator : localConfigurators) &#123; // ä½¿ç”¨é…ç½®è§„åˆ™å™¨ å°† é…ç½®è§„åˆ™åº”ç”¨åˆ° providerUrl providerUrl = configurator.configure(providerUrl); &#125; &#125; // 3 å¢åŠ check=falseï¼Œå³åªæœ‰åœ¨è°ƒç”¨æ—¶ï¼Œæ‰æ£€æŸ¥Provideræ˜¯å¦å¯ç”¨ providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(false)); // 4 æ›´æ–° overrideDirectoryUrl this.overrideDirectoryUrl = this.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters()); // Merge the provider side parameters // å¿½ç•¥ å¯¹ 1.0 ç‰ˆæœ¬çš„å…¼å®¹ // 5 è¿”å›å¤„ç†åçš„æ–°çš„æœåŠ¡æä¾›è€… URL return providerUrl; &#125; åˆå¹¶ URL çš„é€»è¾‘å¦‚ä¸‹ï¼š å°†æ¶ˆè´¹ç«¯URLå‚æ•°é…ç½®é¡¹åˆå¹¶åˆ°æœåŠ¡æä¾›è€…URLä¸­ï¼Œä½† groupã€versionã€methods ç­‰å‚æ•°ä»¥æœåŠ¡ç«¯çš„é…ç½®ä¼˜å…ˆï¼Œå› ä¸ºå®ƒä»¬æ˜¯è¿œç¨‹æœåŠ¡é…ç½®å‚æ•°ã€‚ filter å’Œ listener å‚æ•°ä½¿ç”¨ä¸¤ç«¯çš„é…ç½®é¡¹ã€‚ å°†æ³¨å†Œä¸­å¿ƒä¸­ configurators ç›®å½•ä¸‹çš„ URLï¼Œä»¥åŠæœåŠ¡æ²»ç†æ§åˆ¶å°åŠ¨æ€æ·»åŠ çš„é…ç½®ä¸ Provider URL è¿›è¡Œåˆå¹¶ï¼Œå³è¦†ç›– Provider URL åŸæœ‰çš„ä¸€äº›ä¿¡æ¯ã€‚ å¢åŠ check=falseï¼Œå³åªæœ‰åœ¨è°ƒç”¨æ—¶ï¼Œæ‰æ£€æŸ¥Provideræ˜¯å¦å¯ç”¨ã€‚ æ›´æ–° overrideDirectoryUrl çš„å€¼ï¼šæ³¨å†Œä¸­å¿ƒURL + æ¶ˆè´¹ç«¯URLå‚æ•°é…ç½®é¡¹ -&gt; æ³¨å†Œä¸­å¿ƒURL + æ¶ˆè´¹ç«¯URLå‚æ•°é…ç½®é¡¹ + æœåŠ¡ç«¯URLåˆå¹¶åçš„URLå‚æ•°é…ç½®é¡¹ã€‚ éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œåˆå¹¶ URL å‚æ•°çš„ä¼˜å…ˆçº§ï¼šé…ç½®è§„åˆ™ -&gt; ç³»ç»Ÿå‚æ•° -&gt; æ¶ˆè´¹ç«¯é…ç½® -&gt; æœåŠ¡ç«¯é…ç½® toInvokers æ–¹æ³•è¿”å›çš„æ˜¯ &lt;urlä¸²,Invoker&gt; æ˜ å°„å…³ç³»ï¼Œæ¥ä¸‹æ¥è¿˜ä¼šå¯¹è¯¥ç»“æœè¿›ä¸€æ­¥å¤„ç†ï¼Œå¾—åˆ°æ–¹æ³•ååˆ° Invoker åˆ—è¡¨çš„æ˜ å°„å…³ç³»ã€‚ æ–¹æ³•å-&gt;Invokeråˆ—è¡¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687+--- RegistryDirectory private Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; toMethodInvokers(Map&lt;String, Invoker&lt;T&gt;&gt; invokersMap) &#123; // æ–¹æ³•ååˆ°Invokeré›†åˆæ˜ å°„ Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = new HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;(); // è®°å½•æœåŠ¡æä¾›è€…Invokeré›†åˆ List&lt;Invoker&lt;T&gt;&gt; invokersList = new ArrayList&lt;Invoker&lt;T&gt;&gt;(); // æŒ‰ç…§æœåŠ¡æä¾›è€…URLå£°æ˜çš„ method åˆ†ç±»ï¼Œå…¼å®¹æ³¨å†Œä¸­å¿ƒæ‰§è¡Œè·¯ç”±è¿‡æ»¤æ‰çš„ methods if (invokersMap != null &amp;&amp; invokersMap.size() &gt; 0) &#123; // å¾ªç¯æ¯ä¸ªæœåŠ¡æä¾›è€…Invoker for (Invoker&lt;T&gt; invoker : invokersMap.values()) &#123; // 1 æœåŠ¡æä¾›è€…URLå£°æ˜çš„ methods String parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY); // 2 éå†æ–¹æ³•é›†åˆ if (parameter != null &amp;&amp; parameter.length() &gt; 0) &#123; // åˆ‡å‰² methods å‚æ•°å€¼ï¼Œå¤„ç†æˆæ–¹æ³•åæ•°ç»„ String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter); if (methods != null &amp;&amp; methods.length &gt; 0) &#123; // 3 å¾ªç¯æ¯ä¸ªæ–¹æ³•ï¼ŒæŒ‰ç…§æ–¹æ³•åçš„ç»´åº¦æ”¶é›†å¼•ç”¨çš„ Invoker for (String method : methods) &#123; // å½“æœåŠ¡æä¾›è€…çš„æ–¹æ³•ä¸º * æ—¶ï¼Œä»£è¡¨æ³›åŒ–è°ƒç”¨ï¼Œä¸å¤„ç†ã€‚ if (method != null &amp;&amp; method.length() &gt; 0 &amp;&amp; !Constants.ANY_VALUE.equals(method)) &#123; List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method); if (methodInvokers == null) &#123; methodInvokers = new ArrayList&lt;Invoker&lt;T&gt;&gt;(); newMethodInvokerMap.put(method, methodInvokers); &#125; // æ ¹æ®æ–¹æ³•åè·å–Invokeré›†åˆ methodInvokers.add(invoker); &#125; &#125; &#125; &#125; // 4 æ”¶é›†å¼•ç”¨çš„ Invoker invokersList.add(invoker); &#125; &#125; // 5 è¿›è¡ŒæœåŠ¡çº§åˆ«è·¯ç”±ï¼Œå³å¯¹å¼•ç”¨çš„æœåŠ¡è¿›è¡Œè·¯ç”± List&lt;Invoker&lt;T&gt;&gt; newInvokersList = route(invokersList, null); // 6 å­˜å‚¨ &lt;*, newInvokersList&gt; æ˜ å°„å…³ç³» newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList); // 7 å¯¹å¼•ç”¨çš„æœåŠ¡æ¥å£ä¸­çš„æ–¹æ³•è¿›è¡Œæ–¹æ³•çº§åˆ«è·¯ç”± if (serviceMethods != null &amp;&amp; serviceMethods.length &gt; 0) &#123; // éå†æœåŠ¡æ–¹æ³•æ•°ç»„åŸºäºæ¯ä¸ªæ–¹æ³•è·¯ç”±ï¼ŒåŒ¹é…æ–¹æ³•å¯¹åº”çš„Invokeré›†åˆ for (String method : serviceMethods) &#123; List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method); if (methodInvokers == null || methodInvokers.isEmpty()) &#123; methodInvokers = newInvokersList; &#125; // è¿›è¡Œæ–¹æ³•çº§åˆ«è·¯ç”± newMethodInvokerMap.put(method, route(methodInvokers, method)); &#125; &#125; // 8 æ’åºï¼Œè½¬æˆä¸å¯å˜é›†åˆ for (String method : new HashSet&lt;String&gt;(newMethodInvokerMap.keySet())) &#123; List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method); Collections.sort(methodInvokers, InvokerComparator.getComparator()); newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers)); &#125; return Collections.unmodifiableMap(newMethodInvokerMap); &#125;---+ private List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, String method) &#123; // åˆ›å»ºInvocation å¯¹è±¡ Invocation invocation = new RpcInvocation(method, new Class&lt;?&gt;[0], new Object[0]); // è·å¾— Router æ•°ç»„ List&lt;Router&gt; routers = getRouters(); // æ ¹æ®è·¯ç”±è§„åˆ™ï¼Œç­›é€‰Invoker é›†åˆ if (routers != null) &#123; for (Router router : routers) &#123; if (router.getUrl() != null) &#123; invokers = router.route(invokers, getConsumerUrl(), invocation); &#125; &#125; &#125; return invokers; &#125; å°†å¼•ç”¨çš„ Invoker åˆ—è¡¨è¿›è¡Œæ˜ å°„ï¼Œå¾—åˆ°æ–¹æ³•ååˆ° Invoker çš„æ˜ å°„ã€‚ä¸»è¦è¿‡ç¨‹å¦‚ä¸‹ï¼š å¯¹ä¼ å…¥çš„å¼•ç”¨ Invoker è¿›è¡Œéå†ï¼Œè·å–å…¶ä¸­çš„ methods å‚æ•°ï¼Œå¹¶åˆ‡åˆ†æˆæ•°ç»„ã€‚ç„¶åä»¥æ–¹æ³•åä¸ºé”®ï¼ŒInvoker åˆ—è¡¨ä¸ºå€¼è¿›è¡Œç¼“å­˜ã€‚ å…ˆååŸºäºæœåŠ¡çº§åˆ«å’Œæ–¹æ³•çº§åˆ«å¯¹ Invoker åˆ—è¡¨è¿›è¡Œè·¯ç”±æ“ä½œï¼Œç­›é€‰ç›®æ ‡ Invoker ã€‚ å¯¹è·¯ç”±åçš„ Invoker åˆ—è¡¨è¿›è¡Œæ’åºï¼Œå¹¶è½¬æˆä¸å¯å˜åˆ—è¡¨ã€‚ å¤šåˆ†ç»„èšåˆ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849+--- RegistryDirectoryprivate Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; toMergeMethodInvokerMap(Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; methodMap) &#123; Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; result = new HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;(); // å¾ªç¯mapé›†åˆï¼Œæ ¹æ® method + group èšåˆ Invoker é›†åˆ for (Map.Entry&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; entry : methodMap.entrySet()) &#123; // 1 è·å–æ–¹æ³•å String method = entry.getKey(); // 2 è·å–æ–¹æ³•åå¯¹åº”çš„invokeråˆ—è¡¨ List&lt;Invoker&lt;T&gt;&gt; invokers = entry.getValue(); // 3 æŒ‰ç…§ group èšåˆ Invoker é›†åˆçš„ç»“æœï¼Œkeyï¼šgroup valueï¼šInvokeré›†åˆ Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; groupMap = new HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;(); // 4 éå†Invokeré›†åˆ ã€‚æ³¨æ„ï¼šä¸€ä¸ªæ–¹æ³•å¯¹åº”çš„ Invoker åˆ—è¡¨å¯èƒ½å±äºå¤šä¸ªç»„ for (Invoker&lt;T&gt; invoker : invokers) &#123; // 4.1 è·å–åˆ†ç»„å String group = invoker.getUrl().getParameter(Constants.GROUP_KEY, \"\"); // 4.2 ä»¥åˆ†ç»„åèšåˆInvokeré›†åˆ List&lt;Invoker&lt;T&gt;&gt; groupInvokers = groupMap.get(group); if (groupInvokers == null) &#123; groupInvokers = new ArrayList&lt;Invoker&lt;T&gt;&gt;(); groupMap.put(group, groupInvokers); &#125; groupInvokers.add(invoker); &#125; // 5 å¦‚æœåªæœ‰ä¸€ä¸ªgroupï¼Œåˆ™ç›´æ¥ä½¿ç”¨è¯¥groupåˆ†ç»„å¯¹åº”çš„Invokeré›†åˆä½œä¸ºç»“æœ if (groupMap.size() == 1) &#123; result.put(method, groupMap.values().iterator().next()); // 6 æœ‰å¤šä¸ªåˆ†ç»„çš„è¯ï¼Œå°†æ¯ä¸ªgroupå¯¹åº”çš„Invokeré›†åˆç»è¿‡Clusteråˆå¹¶æˆä¸€ä¸ªInvoker &#125; else if (groupMap.size() &gt; 1) &#123; List&lt;Invoker&lt;T&gt;&gt; groupInvokers = new ArrayList&lt;Invoker&lt;T&gt;&gt;(); for (List&lt;Invoker&lt;T&gt;&gt; groupList : groupMap.values()) &#123; // è¿™é‡Œä½¿ç”¨åˆ°StaticDirectoryä»¥åŠClusteråˆå¹¶æ¯ä¸ªgroupä¸­çš„Invoker groupInvokers.add(cluster.join(new StaticDirectory&lt;T&gt;(groupList))); &#125; result.put(method, groupInvokers); // æ²¡æœ‰çš„è¯ï¼Œå°±ä½¿ç”¨åŸæ¥çš„æ•°æ® &#125; else &#123; result.put(method, invokers); &#125; &#125; return result; &#125; å¤šåˆ†ç»„èšåˆæ–¹æ³•ç”¨äºåœ¨ &lt;methodName,Invokeråˆ—è¡¨&gt; åŸºç¡€ä¸­ï¼Œå¯¹åŒä¸€ä¸ªæ–¹æ³•å¯¹åº”çš„ Invoker åˆ—è¡¨è¿›è¡Œ group ç»´åº¦çš„åˆ†ç±»ï¼ŒåŒä¸€ä¸ª group ç»´åº¦çš„ Invoker åˆ—è¡¨é€šè¿‡ Cluster åˆå¹¶æˆä¸€ä¸ª Invoker ã€‚ é”€æ¯æ— ç”¨ Invoker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051+--- RegistryDirectory private void destroyUnusedInvokers(Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap, Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap) &#123; // 1 å®‰å…¨å¤„ç† if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) &#123; // é”€æ¯æ‰€æœ‰æœåŠ¡æä¾›è€…Invoker destroyAllInvokers(); return; &#125; // 2 æ¯”è¾ƒæ–°è€é›†åˆï¼Œç¡®å®šéœ€è¦é”€æ¯å“ªäº›Invokerã€‚ // åŸåˆ™æ˜¯ï¼šä»¥æ–°çš„ä¸ºåŸºå‡†ï¼Œå¦‚æœæ–°çš„ä¸­ä¸åŒ…å«è€çš„ï¼Œè¯´æ˜è€çš„åº”è¯¥è¢«é”€æ¯ List&lt;String&gt; deleted = null; if (oldUrlInvokerMap != null) &#123; // è·å–æ–°ç”Ÿæˆçš„ Invoker é›†åˆ Collection&lt;Invoker&lt;T&gt;&gt; newInvokers = newUrlInvokerMap.values(); // éå†è€çš„ &lt;urlä¸², Invoker&gt; æ˜ å°„è¡¨ for (Map.Entry&lt;String, Invoker&lt;T&gt;&gt; entry : oldUrlInvokerMap.entrySet()) &#123; // å¦‚æœæ–°çš„é›†åˆä¸­ä¸åŒ…å«è€çš„Invokerï¼Œåˆ™è¡¨ç¤ºå¯ä»¥æŠŠå½“å‰è€çš„Invokeråˆ é™¤ if (!newInvokers.contains(entry.getValue())) &#123; if (deleted == null) &#123; deleted = new ArrayList&lt;String&gt;(); &#125; // è‹¥ä¸åŒ…å«ï¼Œåˆ™å°†è€çš„ Invoker å¯¹åº”çš„ url å­˜å…¥ deleted åˆ—è¡¨ä¸­ deleted.add(entry.getKey()); &#125; &#125; &#125; // 3 æœ‰éœ€è¦é”€æ¯çš„Invokerå°±è¿›è¡Œé”€æ¯ if (deleted != null) &#123; // éå† deleted é›†åˆï¼Œå¹¶åˆ°è€çš„ &lt;url, Invoker&gt; æ˜ å°„å…³ç³»è¡¨æŸ¥å‡º Invokerå¹¶é”€æ¯ for (String url : deleted) &#123; if (url != null) &#123; // ä»è€çš„Invokeré›†åˆä¸­ç§»é™¤è¦é”€æ¯çš„Invoker Invoker&lt;T&gt; invoker = oldUrlInvokerMap.remove(url); if (invoker != null) &#123; try &#123; // é”€æ¯Invoker invoker.destroy(); if (logger.isDebugEnabled()) &#123; logger.debug(\"destroy invoker[\" + invoker.getUrl() + \"] success. \"); &#125; &#125; catch (Exception e) &#123; logger.warn(\"destroy invoker[\" + invoker.getUrl() + \"] faild. \" + e.getMessage(), e); &#125; &#125; &#125; &#125; &#125; &#125; é”€æ¯æ— ç”¨ Invoker å…³é”®çœ‹æ—§çš„ Invoker æ˜¯å¦åœ¨æ–°çš„ Invoker é›†åˆä¸­ï¼Œä¸åœ¨åˆ™è¯´æ˜éœ€è¦é”€æ¯ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« å¯¹ Dubbo çš„æœåŠ¡ç›®å½•è¿›è¡Œäº†åˆ†æï¼Œç›¸æ¯”é™æ€æœåŠ¡ç›®å½• StaticDirectory ï¼ŒåŠ¨æ€çš„æœåŠ¡ç›®å½• RegistryDirectory è¦å¤æ‚å¾—å¤šã€‚ä¸ºäº†è®©æœ¬åœ°æœåŠ¡ç›®å½•å’Œæ³¨å†Œä¸­å¿ƒä¿æŒä¸€è‡´ï¼Œéœ€è¦åšå¾ˆå¤šå·¥ä½œã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - é›†ç¾¤æ¨¡å—æ€»è§ˆ","slug":"rpc/é›†ç¾¤æ¨¡å—æ€»è§ˆ","date":"2020-09-11T16:00:00.000Z","updated":"2021-04-06T08:31:35.563Z","comments":false,"path":"posts/7aca9035/","link":"","permalink":"https://gentryhuang.com/posts/7aca9035/","excerpt":"","text":"æ¦‚è¿°ä¸ºäº†ä¿è¯æœåŠ¡çš„å¯é æ€§ã€ååé‡ä»¥åŠå®¹é”™èƒ½åŠ›ï¼Œé€šå¸¸ä¼šåœ¨å¤šä¸ªæœåŠ¡å™¨ä¸Šè¿è¡Œç›¸åŒçš„åº”ç”¨ç¨‹åºï¼Œç„¶åä»¥é›†ç¾¤çš„å½¢å¼å¯¹å¤–æä¾›æœåŠ¡ã€‚æ ¹æ®åº”ç”¨åœºæ™¯ä¸åŒï¼Œæ¯ä¸ªé›†ç¾¤ä¸­çš„æœåŠ¡å®ä¾‹ä¸ªæ•°ä¹Ÿä¸å°½ç›¸åŒã€‚Dubbo ä¸­çš„ Cluster æ˜¯å¤–å›´æ¦‚å¿µï¼Œç”¨äºå°†å¤šä¸ª Invoker ä¼ªè£…æˆä¸€ä¸ª Invokerï¼Œè¿™æ ·è°ƒç”¨æ–¹åªéœ€å…³æ³¨ Protocol å±‚ Invoker å³å¯ï¼ŒåŠ ä¸Š Cluster æˆ–è€…å»æ‰ Cluster å¯¹å…¶å®ƒå±‚éƒ½ä¸ä¼šé€ æˆå½±å“ï¼Œå› ä¸ºåªæœ‰ä¸€ä¸ªæä¾›è€…æ—¶ï¼Œæ˜¯ä¸éœ€è¦ Cluster çš„ã€‚ Cluster å±‚ åœ¨ Dubbo æ¶æ„ä¸­çš„ä½ç½®å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š Cluster æ¶æ„Dubbo çš„é›†ç¾¤æ¨¡å—ä¸»è¦åŠŸèƒ½æ˜¯å°†å¤šä¸ªæœåŠ¡æä¾›è€…ä¼ªè£…æˆä¸€ä¸ªæä¾›è€…ä¾›æ¶ˆè´¹æ–¹è°ƒç”¨ï¼Œæ ¸å¿ƒç»„ä»¶å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä»ä¸Šå›¾å¯ä»¥çœ‹å‡ºï¼ŒDubbo é›†ç¾¤æ¨¡å—æ¶‰åŠä»¥ä¸‹ 4 ä¸ªæ ¸å¿ƒç»„ä»¶ï¼š Directory - æœåŠ¡ç›®å½• ä»£è¡¨å¤šä¸ª Invokerï¼Œå¯ä»¥æŠŠå®ƒçœ‹æˆ List&lt;Invoker&gt; ï¼Œä½†ä¸ List ä¸åŒçš„æ˜¯ï¼Œå®ƒçš„å€¼å¯èƒ½æ˜¯åŠ¨æ€å˜åŒ–çš„ï¼Œæ¯”å¦‚æ³¨å†Œä¸­å¿ƒæ¨é€å˜æ›´ã€‚å®ƒæ˜¯åç»­è·¯ç”±è§„åˆ™ã€è´Ÿè½½å‡è¡¡ç­–ç•¥ä»¥åŠé›†ç¾¤å®¹é”™çš„åŸºç¡€ã€‚ Cluster - é›†ç¾¤ å°† Directory ä¸­çš„å¤šä¸ª Invoker ä¼ªè£…æˆä¸€ä¸ª Invoker ï¼Œå¯¹ä¸Šå±‚é€æ˜ã€‚ä¼ªè£…è¿‡ç¨‹åŒ…å«äº†å®¹é”™é€»è¾‘ï¼Œç”¨äºåœ¨æŸäº› Provider èŠ‚ç‚¹å‘ç”Ÿæ•…éšœæ—¶è®© Consumer çš„è°ƒç”¨è¯·æ±‚èƒ½å¤Ÿå‘é€åˆ°æ­£å¸¸çš„ Provider èŠ‚ç‚¹ï¼Œä»è€Œä¿è¯æ•´ä¸ªç³»ç»Ÿçš„å¯ç”¨æ€§ã€‚ Router - è·¯ç”± è´Ÿè´£ä» Directory ä¸­æŒ‰è·¯ç”±è§„åˆ™é€‰å‡ºå­é›†ï¼Œæ¯”å¦‚åº”ç”¨åœ¨ è¯»å†™åˆ†ç¦»ã€åº”ç”¨éš”ç¦» ã€ç°åº¦å‘å¸ƒ ç­‰ã€‚ LoadBalance - è´Ÿè½½å‡è¡¡ è´Ÿè´£ä» Router ä¸­é€‰å‡ºå…·ä½“çš„ä¸€ä¸ª Invokerã€‚é€‰çš„è¿‡ç¨‹åŒ…å«äº†è´Ÿè½½å‡è¡¡ç®—æ³•ã€‚ Cluster å±‚çš„æ ¸å¿ƒæµç¨‹ï¼š å½“è°ƒç”¨è¿›å…¥ Cluster æ¨¡å—æ—¶ï¼ŒCluster ä¼šä» Directory ä¸­è·å–å½“å‰ Invoker é›†åˆï¼›ç„¶åæŒ‰ç…§ Router è¿›è¡Œè·¯ç”±ï¼Œä» Directory ä¸­ç­›é€‰å‡ºç¬¦åˆæ¡ä»¶çš„ Invoker å­é›†ï¼›æ¥ç€æŒ‰ç…§ LoadBalance è¿›è¡Œè´Ÿè½½å‡è¡¡ï¼Œä» Router å­é›†ä¸­é€‰å‡ºä¸€ä¸ªæœ€ç»ˆè¦è°ƒç”¨çš„ Invoker å¯¹è±¡ã€‚ Cluster æ¨¡å—äº†è§£äº† Dubbo çš„ Cluster æ¶æ„ï¼Œä¸‹é¢æˆ‘ä»¬å¯¹ Dubbo é›†ç¾¤æ¨¡å—çš„å®ç°ç®€å•è¯´æ˜ä¸‹ã€‚ Dubbo çš„ Cluster æ¨¡å—ä»£ç å®ç°å¦‚ä¸Šå›¾æ‰€ç¤ºã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« ç›¸å¯¹æ¯”è¾ƒè½»æ¾ï¼Œç®€å•ä»‹ç»äº† Cluster å±‚åœ¨ Dubbo æ¶æ„ä¸­æ‰€å¤„çš„ä½ç½®å’Œå…¶æ¶æ„çš„ç»„æˆã€‚åœ¨åé¢å‡ ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬ä¼šåˆ†åˆ«ä»‹ç»è¿™äº›ç»„ä»¶ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - HTTPåè®®","slug":"rpc/HTTPåè®®","date":"2020-09-05T16:00:00.000Z","updated":"2021-03-15T03:08:20.553Z","comments":false,"path":"posts/c5a37c18/","link":"","permalink":"https://gentryhuang.com/posts/c5a37c18/","excerpt":"","text":"å‰è¨€RPC å®ç° è¿œç¨‹è¿‡ç¨‹è°ƒç”¨éœ€è¦è§£å†³ä»¥ä¸‹é—®é¢˜ï¼š å¯»å€ï¼šå®¢æˆ·ç«¯è°ƒç”¨çš„æ—¶å€™éœ€è¦å‘Šè¯‰æœåŠ¡ç«¯è°ƒç”¨çš„æ˜¯å“ªä¸ªæœåŠ¡ã€å“ªä¸ªæ–¹æ³•ã€å“ªäº›å‚æ•°ä»¥åŠé™„åŠ å±æ€§ã€‚ åºåˆ—åŒ–/ååºåˆ—åŒ–ï¼šç”±äºå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ä¸æ˜¯åŒä¸€ä¸ªè¿›ç¨‹ä¸èƒ½é€šè¿‡å†…å­˜æ¥ä¼ é€’å‚æ•°ï¼Œéœ€è¦ç½‘ç»œä¼ è¾“ï¼Œå› æ­¤å®¢æˆ·ç«¯éœ€è¦å°†å‚æ•°åºåˆ—åŒ–æˆå­—èŠ‚æµç„¶åç»ç½‘ç»œä¼ é€’ç»™æœåŠ¡ç«¯ï¼ŒæœåŠ¡ç«¯æ”¶åˆ°å­—èŠ‚æµåååºåˆ—åŒ–ä¸ºè‡ªå·±èƒ½è¯»å–çš„æ ¼å¼ã€‚åºåˆ—åŒ–/ååºåˆ—åŒ–å¯ä»¥ä½¿ç”¨ Hessianã€Dubboã€Protobufã€JSON ç­‰ã€‚ ç½‘ç»œä¼ è¾“ï¼šå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯éœ€è¦é€šè¿‡ç½‘ç»œè¿æ¥æ¥ä¼ è¾“æ•°æ®ï¼Œç½‘ç»œä¼ è¾“å¯ä»¥ä½¿ç”¨ Socketã€TCPã€UDPã€HTTPã€HTTP2 ç­‰ã€‚ HTTP HTTP è¯·æ±‚è°ƒç”¨æœ¬èº«ä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯ RPC çš„ä¸€ç§å…·ä½“å½¢å¼ï¼ŒHTTP è¯·æ±‚ä¹Ÿæ˜¯ä»å®¢æˆ·ç«¯å‘å‡ºè¯·æ±‚åˆ°æœåŠ¡ç«¯ï¼ŒæœåŠ¡ç«¯æ‰§è¡Œå…·ä½“é€»è¾‘ï¼Œç„¶åè¿”å›ç»“æœç»™å®¢æˆ·ç«¯ã€‚HTTP è¯·æ±‚éå¸¸å¸¸è§ï¼Œä¸€èˆ¬å¼€æ”¾æœåŠ¡ç»™ä»»æ„çš„ä¸€æ–¹è°ƒç”¨ï¼Œä½¿ç”¨ HTTP APIçš„å½¢å¼æ˜¯éå¸¸åˆé€‚çš„ã€‚å¯¹äºå†…éƒ¨é€šä¿¡ä¸ºäº†çµæ´»ã€é«˜æ•ˆï¼Œå¯ä»¥æ ¹æ®å®é™…éœ€è¦è‡ªå®šåˆ¶ä¸€å¥— RPC æ¡†æ¶ï¼Œåå¤„å°±æ˜¯æ²¡æœ‰é‚£ä¹ˆé€šç”¨ã€‚ JSON-RPC JSON-RPC æ˜¯åŸºäº JSON çš„è·¨è¯­è¨€è¿œç¨‹è°ƒç”¨ï¼ˆRPCï¼‰åè®®ï¼Œå…¶ ä¼ è¾“çš„å†…å®¹ä»¥JSONæ–¹å¼ï¼ˆæ³¨æ„ï¼Œä¼ è¾“æ ¼å¼æ˜¯äºŒè¿›åˆ¶å½¢å¼ï¼‰ï¼Œç›¸æ¯” XML-RPCã€WebService ç­‰åŸºäºæ–‡æœ¬çš„åè®®ä¼ è¾“æ•°æ®æ ¼å¼å°ã€‚ç›¸å¯¹ Dubboã€Hessian ç­‰äºŒè¿›åˆ¶åè®®ï¼ŒJSON-RPC æ›´ä¾¿äºè°ƒè¯•ã€å®ç°å’Œæ‰©å±•ã€‚ç›®å‰ä¸»æµè¯­è¨€å‡ ä¹éƒ½åŸºäº JSON-RPC å®ç°äº†æ¡†æ¶ï¼ŒJava ä¸­è¾ƒå¥½çš„ JSON-RPC å®ç°æ¡†æ¶æœ‰ jsonrpc4jã€jpoxy ä»¥åŠ json-rpc ï¼Œå…¶ä¸­ jsonrpc4j æ—¢å¯å•ç‹¬ä½¿ç”¨ï¼Œåˆå¯ä¸ Spring æ— ç¼æ•´åˆã€‚ äºŒè¿›åˆ¶åè®®å’Œæ–‡æœ¬åè®® äºŒè¿›åˆ¶åè®®éœ€è¦é€šä¿¡åŒæ–¹çº¦å®šåè®®çš„ç»“æ„ï¼ˆå¦‚ Dubbo åè®®çš„ç»“æ„ï¼‰ï¼Œå‘é€æ–¹åœ¨å‘é€æ•°æ®å‰æŒ‰ç…§åè®®çš„ç»“æ„ç»„è£…æ•°æ®ç„¶ååºåˆ—åŒ–æˆå­—èŠ‚æµä¼ é€ç»™å¯¹ç«¯ï¼Œæ¥æ”¶æ–¹æ”¶åˆ°å­—èŠ‚æµåæŒ‰ç…§åè®®çš„ç»“æ„è¿›è¡Œè§£æå°±å¯ä»¥äº†ã€‚æ–‡æœ¬åè®®ï¼ˆå¦‚ JSON-RPCåè®®ï¼‰ä¸éœ€è¦é€šä¿¡åŒæ–¹çº¦å®šåè®®ç»“æ„ï¼Œå‘é€æ–¹åªéœ€å°†å…·ä½“çš„æ–‡æœ¬æ•°æ®ï¼ˆå¦‚ JSONæ•°æ®ï¼‰åºåˆ—åŒ–æˆå­—èŠ‚æµå‘é€åˆ°å¯¹ç«¯å³å¯ï¼Œæ¥æ”¶æ–¹æ”¶åˆ°å­—èŠ‚æµåæŒ‰ç…§åŒæ ·çš„æ–‡æœ¬æ ¼å¼ï¼ˆå¦‚ JSONï¼‰è§£æå°±å¯ä»¥äº†ã€‚ äºŒè¿›åˆ¶åè®®çš„ä¼˜ç‚¹åœ¨äºï¼Œè¿›è¡Œæ•°æ®è½¬åŒ–æ—¶ä¸éœ€è¦åŒ…å«å®šä¹‰æ•°æ®çš„ç»“æ„ä¿¡æ¯ï¼Œç›¸æ¯”æ–‡æœ¬åè®®è¦å°ï¼›æ–‡æœ¬åè®®çš„ä¼˜ç‚¹åœ¨äºä¸éœ€è¦å®šä¹‰æ•°æ®çš„ä¼ è¾“æ ¼å¼ï¼Œè¾ƒä¸ºæ–¹ä¾¿ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œæ— è®ºæ˜¯äºŒè¿›åˆ¶åè®®è¿˜æ˜¯æ–‡æœ¬åè®®ï¼Œéƒ½æ˜¯ä»¥äºŒè¿›åˆ¶æ•°æ®å½¢å¼è¿›è¡Œç½‘ç»œä¼ è¾“çš„ï¼ŒåŒºåˆ«åœ¨äºäºŒè¿›åˆ¶åè®®éœ€è¦å®šåˆ¶ç»“æ„ï¼Œè€Œæ–‡æœ¬åè®®ä¸éœ€è¦ã€‚ åè®®å’Œåºåˆ—åŒ– åè®®å’Œåºåˆ—åŒ–æ˜¯ä¸åŒçš„ä¸œè¥¿ï¼Œå®ƒä»¬ä¹‹é—´å±äºç»„åˆå…³ç³»ï¼Œåè®®éœ€è¦ç”¨åˆ°åºåˆ—åŒ–æŠ€æœ¯ï¼Œè€Œåºåˆ—åŒ–æŠ€æœ¯å¯ä»¥æœåŠ¡äºä¸åŒçš„åè®®ã€‚ è·¨è¯­è¨€ è·¨è¯­è¨€è°ƒç”¨ä¸€ä¸ªé‡è¦çš„æ€è·¯å°±æ˜¯è¦æœ‰ä¸€ä¸ªé€šç”¨çš„åè®®ï¼Œæˆ–è€…ä½¿ç”¨ä¸€å®šçš„ç­–ç•¥å®Œæˆåè®®é€‚é…ï¼Œå¯¹äºå‰è€…è€Œè¨€ HTTP åè®®å°±æ˜¯å¾ˆå¥½çš„é€‰æ‹©ï¼Œå¦‚å¼‚æ„è¯­è¨€å¯¹ SpringCloud çš„è°ƒç”¨åªéœ€æä¾› HTTP å®¢æˆ·ç«¯ä¾¿å¯ä»¥å®ç°è·¨è¯­è¨€è°ƒç”¨ã€‚ è·¨è¯­è¨€éš¾ç‚¹åœ¨äº å¼‚æ„è¯­è¨€å¦‚ä½•è¡¨ç¤ºç›®æ ‡æœåŠ¡æ‰€éœ€çš„æ•°æ®ç±»å‹ å’Œ åºåˆ—åŒ–æ–¹æ¡ˆå¦‚ä½•åšåˆ°è·¨è¯­è¨€ï¼Œå¦‚ nodejs å¯¹ dubbo åè®®ä¸‹çš„ Java æœåŠ¡çš„è°ƒç”¨æ˜¯åˆ©ç”¨ dubbo2.js ç»„ä»¶æ¥å®ç°çš„ï¼Œä½¿ç”¨ js-to-javaç±»åº“ä½¿å¾— node.jså…·å¤‡ Java å¯¹è±¡çš„è¡¨è¾¾èƒ½åŠ›ï¼Œä½¿ç”¨ hessian.js æä¾›äº†åºåˆ—åŒ–èƒ½åŠ›ï¼Œè¿™æ ·ä¸€æ¥ nodejs å°±èƒ½é€šè¿‡è‡ªå·±çš„ socket å‘é€ä¸€å¥— dubbo åè®®çš„æŠ¥æ–‡ï¼Œæœ€ç»ˆå®ç°æœåŠ¡è°ƒç”¨ã€‚ æ¦‚è¿°Dubbo ä¸­æ”¯æŒçš„ HTTP åè®®å¹¶éæ˜¯é€šç”¨çš„ HTTPåè®®ï¼Œè€Œæ˜¯å°† HTTPåè®® ä¸ Spring ç»“åˆä½¿ç”¨ï¼ŒåŸºäº HTTP è¡¨å•çš„è¿œç¨‹è°ƒç”¨åè®®ï¼Œé‡‡ç”¨ Spring çš„ HttpInvoker å®ç°ï¼Œä½†åœ¨ Dubbo çš„ 2.7.x ç‰ˆæœ¬ä¸­æ‘’å¼ƒäº† HttpInvoker å®ç°æ–¹å¼ï¼Œä»£æ›¿çš„æ˜¯å°† HTTPåè®® ä¸ JSON-RPC ç»“åˆä½¿ç”¨ï¼Œå®ç°è·¨è¯­è¨€è°ƒç”¨çš„æ•ˆæœã€‚ Dubbo 2.6.x å®ç°Dubbo 2.6.x ç‰ˆæœ¬ä¸­çš„ HTTP åè®®æ˜¯åŸºäº HTTP è¡¨å•çš„è¿œç¨‹è°ƒç”¨åè®®ï¼Œé‡‡ç”¨ Spring çš„ HttpInvoker å®ç°ã€‚ ç‰¹ç‚¹ è¿æ¥ä¸ªæ•°ï¼šå¤šè¿æ¥è¿æ¥æ–¹å¼ï¼šçŸ­è¿æ¥ä¼ è¾“åè®®ï¼šHTTPä¼ è¾“æ–¹å¼ï¼šåŒæ­¥ä¼ è¾“åºåˆ—åŒ–ï¼šè¡¨å•åºåˆ—åŒ–ï¼ˆé»˜è®¤ä½¿ç”¨çš„æ˜¯ java åºåˆ—åŒ–çš„æ–¹å¼ï¼‰é€‚ç”¨èŒƒå›´ï¼šä¼ å…¥ä¼ å‡ºå‚æ•°æ•°æ®åŒ…å¤§å°æ··åˆï¼Œæä¾›è€…æ¯”æ¶ˆè´¹è€…ä¸ªæ•°å¤šï¼Œå¯ç”¨æµè§ˆå™¨æŸ¥çœ‹ï¼Œå¯ç”¨è¡¨å•æˆ–URLä¼ å…¥å‚æ•°ï¼Œæš‚ä¸æ”¯æŒä¼ æ–‡ä»¶ã€‚é€‚ç”¨åœºæ™¯ï¼šéœ€åŒæ—¶ç»™åº”ç”¨ç¨‹åºå’Œæµè§ˆå™¨ JS ä½¿ç”¨çš„æœåŠ¡ã€‚ é…ç½® 12&lt;!-- ä½¿ç”¨çš„åº”ç”¨æœåŠ¡å™¨é»˜è®¤æ˜¯ jetty --&gt;&lt;dubbo:protocol name=\"http\" port=\"8080\" server=\"jetty\"/&gt; å½“æœåŠ¡æ¶ˆè´¹è€…å‘æœåŠ¡æä¾›è€…å‘èµ·è°ƒç”¨æ—¶ï¼Œåº•å±‚ä¾¿ä¼šä½¿ç”¨æ ‡å‡†çš„ HTTP åè®®è¿›è¡Œé€šä¿¡ã€‚åœ¨åˆ†æ Dubbo 2.6.x ç‰ˆæœ¬ä¸­çš„ â€œHTTPåè®®â€ ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆäº†è§£ä¸‹ Spring çš„ HttpInvoker å®ç°ã€‚ HttpInvoker åŸç”Ÿå®ç°æœåŠ¡æä¾›è€…1234567@Servicepublic class InvokerServiceImpl implements IInvokerService &#123; @Override public String sayHello(String msg) &#123; return \"hello \" + msg; &#125;&#125; æš´éœ²æœåŠ¡1234567891011121314@Configurationpublic class HttpInvokerConfig &#123; /** * @param iInvokerService * @return */ @Bean(\"/invokerService\") public HttpInvokerServiceExporter httpInvokerServiceExporter(IInvokerService iInvokerService) &#123; HttpInvokerServiceExporter httpInvokerServiceExporter = new HttpInvokerServiceExporter(); httpInvokerServiceExporter.setService(iInvokerService); httpInvokerServiceExporter.setServiceInterface(IInvokerService.class); return httpInvokerServiceExporter; &#125;&#125; æš´éœ²æœåŠ¡é€»è¾‘å¦‚ä¸‹ï¼š 1 å¯¹å¤–æä¾›çš„æœåŠ¡ï¼Œè®¿é—®è·¯å¾„æ ¼å¼: http://ip:port/ä¸Šä¸‹æ–‡/invokerService 2 HttpInvokerServiceExporter æ˜¯ Spring å°è£…çš„ä¸€ä¸ªæœåŠ¡æš´éœ²å™¨ï¼Œå®ƒä¼šä»¥ serviceInterface ä¸ºå…¬å…±æ¥å£ï¼Œä»¥ service ä¸ºå®ç°ç±»å‘å¤–æä¾›æœåŠ¡ã€‚ Springå°è£…äº†è¿œç¨‹è°ƒç”¨çš„é€»è¾‘ï¼Œç½‘ç»œä¼ è¾“ä½¿ç”¨çš„æ˜¯ HTTPï¼Œå½“æœ‰è¯·æ±‚è¿‡æ¥ï¼Œå½“å‰æœåŠ¡ä¼šè¿›è¡Œå¤„ç†å¹¶å°†å¤„ç†åçš„ç»“æœä¼ è¾“åˆ°å¯¹ç«¯ã€‚ 3 @Bean(â€œ/invokerServiceâ€) ä¸ä»…ä»…æŒ‡å®šäº† IOC å®¹å™¨ä¸­ bean çš„åå­—ï¼Œè¿˜å……å½“äº†è·¯å¾„æ˜ å°„çš„åŠŸèƒ½ï¼Œå¦‚æœæœ¬åœ°æœåŠ¡å™¨æš´éœ²åœ¨ 8080 ç«¯å£ï¼Œåˆ™ç¤ºä¾‹æœåŠ¡çš„è®¿é—®è·¯å¾„ä¸º http://localhost:8080/ä¸Šä¸‹æ–‡/invokerService æœåŠ¡æ¶ˆè´¹è€…123ConfigurableApplicationContext applicationContext = SpringApplication.run(Application.class, args);IInvokerService iInvokerService = applicationContext.getBean(IInvokerService.class);System.out.println(iInvokerService.sayHello(\"shunhua!\")); æœåŠ¡å¼•ç”¨123456789101112131415161718@Configurationpublic class ClientConfig &#123; /** * è®¿é—®æœåŠ¡è·¯å¾„ */ private String serviceUrl = \"http://localhost:8080/ä¸Šä¸‹æ–‡/invokerService\"; /** * * @return */ @Bean public HttpInvokerProxyFactoryBean httpInvokerProxyFactoryBean() &#123; HttpInvokerProxyFactoryBean httpInvokerProxyFactoryBean = new HttpInvokerProxyFactoryBean(); httpInvokerProxyFactoryBean.setServiceUrl(serviceUrl); httpInvokerProxyFactoryBean.setServiceInterface(IInvokerService.class); return httpInvokerProxyFactoryBean; &#125;&#125; æœåŠ¡å¼•ç”¨é€»è¾‘å¦‚ä¸‹ï¼š 1 HttpInvokerProxyFactoryBean æ˜¯ Spring å°è£…çš„ä¸€ä¸ªæœåŠ¡å¼•ç”¨å™¨ï¼ŒserviceInterface æŒ‡å®šäº†ç”Ÿæˆä»£ç†çš„æ¥å£ï¼ŒserviceUrl æŒ‡å®šäº†æœåŠ¡æ‰€åœ¨çš„åœ°å€ï¼Œä¸ä¹‹å‰é…ç½®çš„æœåŠ¡æš´éœ²è€…çš„è·¯å¾„éœ€è¦å¯¹åº”ã€‚ 2 HttpInvokerProxyFactoryBean æ³¨å†Œåˆ° Spring å®¹å™¨ä¸­æ—¶ï¼Œä¼šåŒæ—¶ç”Ÿæˆä¸€ä¸ªæŒ‡å®šæ¥å£çš„ä»£ç†ç±»ï¼Œç”± Spring å°è£…è¿œç¨‹è°ƒç”¨çš„é€»è¾‘ï¼Œä½¿ç”¨ HTTP ä¼ è¾“æ•°æ®ï¼Œé»˜è®¤ä½¿ç”¨java åºåˆ—åŒ–çš„æ–¹å¼ã€‚ æºç å®ç°Dubbo çš„ HTTP åè®®å®ç°ä»£ç ç»“æ„å¦‚ä¸‹ï¼š å¯¹æ¯” Dubbo åè®®å¯ä»¥çœ‹å‡ºï¼ŒHTTP åè®®å®ç°çš„éå¸¸ç®€å•ï¼Œä¸»è¦åŸå› å¦‚ä¸‹ï¼š ä½¿ç”¨ HTTP é€šä¿¡ï¼Œä¸éœ€è¦è‡ªå®šä¹‰ç¼–è§£ç å™¨ã€‚ ä½¿ç”¨çš„åºåˆ—åŒ–æ˜¯ JDK åŸç”Ÿçš„ å€ŸåŠ©äº† Spring æä¾›çš„æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨æœºåˆ¶ HttpProtocolå±æ€§123456789101112131415161718192021222324252627282930313233343536373839public class HttpProtocol extends AbstractProxyProtocol &#123; /** * é»˜è®¤æœåŠ¡å™¨ç«¯å£ */ public static final int DEFAULT_PORT = 80; /** * Http æœåŠ¡å™¨é›†åˆ * key: ip:port * value: HttpæœåŠ¡å™¨ */ private final Map&lt;String, HttpServer&gt; serverMap = new ConcurrentHashMap&lt;String, HttpServer&gt;(); /** * Spring çš„ HttpInvokerServiceExporter é›†åˆ * key: path æœåŠ¡å * value: springçš„HttpInvokerServiceExporter * è¯·æ±‚å¤„ç†è¿‡ç¨‹è¯´æ˜ï¼š * HttpServer -&gt; DispatcherServlet -&gt; InternalHandler -&gt; HttpInvokerServiceExporter */ private final Map&lt;String, HttpInvokerServiceExporter&gt; skeletonMap = new ConcurrentHashMap&lt;String, HttpInvokerServiceExporter&gt;(); /** * HttpBinder$Adaptive å¯¹è±¡,é€šè¿‡ &#123;@link #setHttpBinder(HttpBinder)&#125;æ–¹æ³•ï¼ŒDubbo SPI IOCæ³¨å…¥ */ private HttpBinder httpBinder; public HttpProtocol() &#123; super(RemoteAccessException.class); &#125; public void setHttpBinder(HttpBinder httpBinder) &#123; this.httpBinder = httpBinder; &#125; @Override public int getDefaultPort() &#123; return DEFAULT_PORT; &#125; æœåŠ¡æš´éœ²123456789101112131415161718192021222324252627282930313233343536373839+--- HttpProtocol @Override protected &lt;T&gt; Runnable doExport(final T impl, Class&lt;T&gt; type, URL url) throws RpcException &#123; // 1 è·å–æœåŠ¡å™¨åœ°å€ ip:port String addr = getAddr(url); // 2 æ ¹æ®åœ°å€ä»ç¼“å­˜ä¸­è·å¾— HttpServer å¯¹è±¡ï¼Œè‹¥ä¸å­˜åœ¨ï¼Œè¿›è¡Œåˆ›å»º HttpServer server = serverMap.get(addr); if (server == null) &#123; /** * 1 é€šè¿‡SPIæœºåˆ¶è·å–å…·ä½“çš„ HttpBinderçš„æ‹“å±•å®ç° * 2 å…·ä½“çš„HttpBinderå®ç°è°ƒç”¨bindæ–¹æ³•ï¼š * 1ï¼‰å¯åŠ¨æœåŠ¡ * 2ï¼‰ä¸ºæœåŠ¡è®¾ç½®è¯·æ±‚å¤„ç†å™¨(InternalHandlerå¯¹è±¡) */ server = httpBinder.bind(url, new InternalHandler()); // å°†åˆ›å»ºå¥½çš„æœåŠ¡åŠ å…¥ç¼“å­˜ serverMap.put(addr, server); &#125; // 3 è·å– url çš„ pathï¼Œä»¥æ­¤ä¸º keyç¼“å­˜ HttpInvokerServiceExporter final String path = url.getAbsolutePath(); skeletonMap.put(path, createExporter(impl, type)); // 4 æ”¯æŒæ³›åŒ–ï¼Œåªéœ€å°†æœåŠ¡å®ç°çš„æ¥å£æ›¿æ¢æˆæ³›åŒ–æ¥å£ GenericService å³å¯ final String genericPath = path + \"/\" + Constants.GENERIC_KEY; skeletonMap.put(genericPath, createExporter(impl, GenericService.class)); // 5 è¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable return new Runnable() &#123; /** * åœ¨å›è°ƒæ—¶ä¼šç§»é™¤å¯¹åº”çš„ç¼“å­˜ HttpInvokerServiceExporter */ @Override public void run() &#123; skeletonMap.remove(path); skeletonMap.remove(genericPath); &#125; &#125;; &#125; HttpProtocol çš„ doExport() æ–¹æ³•æ˜¯å¯¹å…¶çˆ¶ç±» AbstractProxyProtocol æœåŠ¡æš´éœ²æ¨¡ç‰ˆæ–¹æ³•çš„å®ç°ï¼Œè¯¥æ–¹æ³•çš„é€»è¾‘ä¸»è¦è¿‡ç¨‹å¦‚ä¸‹ï¼š åŸºäºæœåŠ¡åœ°å€ç»´åº¦æŸ¥è¯¢ç¼“å­˜çš„ HTTPæœåŠ¡å™¨ HttpServerã€‚ ä½¿ç”¨ HTTP ç»‘å®šå™¨åˆ›å»ºå¹¶å¯åŠ¨ HTTPæœåŠ¡å™¨ï¼Œè¯¥æœåŠ¡å™¨ç”¨äºæ¥æ”¶è¯·æ±‚ã€‚ åˆ›å»º HttpInvokerServiceExporter æœåŠ¡æš´éœ²å™¨ï¼Œå‘å¤–æä¾›æœåŠ¡ï¼Œç”¨äºå¤„ç† HTTP æœåŠ¡å™¨æ¥æ”¶çš„è¯·æ±‚ã€‚å…¶ä¸­æ”¯æŒæ³›åŒ–å®ç°ï¼Œå³ä½¿ç”¨æœåŠ¡æš´éœ²å™¨æš´éœ²ä¸€ä¸ªæ³›åŒ–æœåŠ¡å³å¯ã€‚ è¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable ã€‚ ä¸ºäº†é€‚é…å„ç§ HTTP æœåŠ¡å™¨ï¼Œå¦‚ Tomcatã€Jettyï¼Œä»¥åŠéœ€è¦å¤–éƒ¨ Servlet å®¹å™¨çš„ Servlet ï¼ŒDubbo åœ¨ Transporter å±‚æä¾›äº†ä¸€ç³»åˆ—æ¥å£ï¼Œä»£ç ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä»ä»£ç ç»“æ„ç»“åˆ Servlet çŸ¥è¯†ç‚¹æˆ‘ä»¬ä¸éš¾çœ‹å‡ºï¼ŒDubbo ä½¿ç”¨äº†å››ä¸ªä¸åŒçš„ç»„ä»¶å°† Servlet ä¸²è”èµ·æ¥ã€‚ä¸‹é¢æˆ‘ä»¬åˆ†åˆ«æ¥çœ‹è¿™ä¸‰ä¸ªç»„ä»¶ç±»ã€‚ HTTP ç»‘å®šå™¨12345678910111213@SPI(\"jetty\")public interface HttpBinder &#123; /** * åŸºäºDubbo SPI æœºåˆ¶ï¼ŒåŠ è½½å¯¹åº”çš„Server å®ç°ã€‚ * * bind the server. * * @param url server url. * @return server. */ @Adaptive(&#123;Constants.SERVER_KEY&#125;) HttpServer bind(URL url, HttpHandler handler);&#125; HttpBinder ç”¨äºåˆ›å»ºå¹¶å¯åŠ¨ HTTP æœåŠ¡å™¨ï¼Œé»˜è®¤æ‰©å±•å®ç°ä¸º JettyHttpServer ã€‚ Jetty ç»‘å®šå™¨ 1234567public class JettyHttpBinder implements HttpBinder &#123; @Override public HttpServer bind(URL url, HttpHandler handler) &#123; // ç”¨äºåˆ›å»ºå¹¶å¯åŠ¨ Jetty æœåŠ¡å™¨ã€‚ return new JettyHttpServer(url, handler); &#125;&#125; Tomcat ç»‘å®šå™¨ 1234567public class TomcatHttpBinder implements HttpBinder &#123; @Override public HttpServer bind(URL url, HttpHandler handler) &#123; // ç”¨äºåˆ›å»ºå¹¶å¯åŠ¨ Tomcat æœåŠ¡å™¨ã€‚ return new TomcatHttpServer(url, handler); &#125;&#125; Servlet ç»‘å®šå™¨ 123456789public class ServletHttpBinder implements HttpBinder &#123; @Override @Adaptive() public HttpServer bind(URL url, HttpHandler handler) &#123; // è¿™ç§æ–¹å¼å¹¶ä¸ç›´æ¥åˆ›å»ºæœåŠ¡å™¨ï¼Œè€Œæ˜¯å°†è¯·æ±‚å¤„ç†å™¨ä¿å­˜èµ·æ¥ï¼Œç”¨äºå¤„ç†å¤–éƒ¨ Servlet å®¹å™¨è½¬å‘çš„è¯·æ±‚ã€‚ // ä¹Ÿå°±æ˜¯è¯´ï¼Œéœ€è¦å¤–éƒ¨é…ç½® Servlet ï¼Œè¯¥å¤–éƒ¨ Servlet æ¥æ”¶çš„è¯·æ±‚äº¤ç”± handler æ¥å¤„ç† return new ServletHttpServer(url, handler); &#125;&#125; HTTP æœåŠ¡å™¨HttpServer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface HttpServer extends Resetable &#123; /** * get http handler. è·å–å¤„ç†å™¨ * * @return http handler. */ HttpHandler getHttpHandler(); /** * get url. * * @return url */ URL getUrl(); /** * get local address. * * @return local address. */ InetSocketAddress getLocalAddress(); /** * close the channel. */ void close(); /** * Graceful close the channel. */ void close(int timeout); /** * is bound. * * @return bound */ boolean isBound(); /** * is closed. * * @return closed */ boolean isClosed();&#125; HttpServer ç»§æ‰¿äº† Resetable æ¥å£ï¼Œå®šä¹‰äº† HTTP æœåŠ¡å™¨æ¥å£ã€‚åœ¨ dubbo-rpc æ¨¡å—ä¸­ï¼Œhttp://ã€rest://ã€hessian://ã€webservice:// åè®®å®ç°ç­‰ï¼Œéƒ½æ˜¯åŸºäº HTTP æœåŠ¡å™¨å®ç°è¯·æ±‚å¤„ç†çš„ã€‚ AbstractHttpServer123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class AbstractHttpServer implements HttpServer &#123; /** * URL å¯¹è±¡ */ private final URL url; /** * å¤„ç†å™¨ */ private final HttpHandler handler; /** * æ˜¯å¦å…³é—­æ ‡è®° */ private volatile boolean closed; public AbstractHttpServer(URL url, HttpHandler handler) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; if (handler == null) &#123; throw new IllegalArgumentException(\"handler == null\"); &#125; this.url = url; this.handler = handler; &#125; @Override public void close() &#123; closed = true; &#125; // ä¸æ”¯æŒè¶…æ—¶å…³é—­ @Override public void close(int timeout) &#123; close(); &#125; @Override public boolean isClosed() &#123; return closed; &#125; // çœç•¥å…¶å®ƒä»£ç ...&#125; HTTP æœåŠ¡å™¨æŠ½è±¡ç±»ä»…æ˜¯å¯¹å¤„ç†å™¨å’ŒURLçš„ç®€å•å°è£…ï¼Œå¤–åŠ æ ‡è®°æœåŠ¡å™¨å…³é—­æ ‡å¿—ã€‚ä¸‹é¢æˆ‘ä»¬å…·ä½“åˆ†æ Dubbo å¦‚ä½•å®ç°å†…ç½®çš„ Servlet å®¹å™¨çš„ã€‚è€ƒè™‘åˆ° JettyHttpServer å®ç°é€»è¾‘ å’Œ TomcatHttpServer å®ç°é€»è¾‘ç±»ä¼¼ï¼Œè¿™é‡Œæˆ‘ä»¬åªå¯¹ Tomcat æœåŠ¡å™¨å®ç°è¿›è¡Œåˆ†æã€‚ TomcatHttpServer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class TomcatHttpServer extends AbstractHttpServer &#123; private static final Logger logger = LoggerFactory.getLogger(TomcatHttpServer.class); /** * å†…åµŒTomcat */ private final Tomcat tomcat; /** * URL å¯¹è±¡ */ private final URL url; public TomcatHttpServer(URL url, final HttpHandler handler) &#123; super(url, handler); this.url = url; // 1 æ³¨å†Œè¯·æ±‚å¤„ç†å™¨HttpHandler åˆ° DispatcherServletçš„ å¤„ç†å™¨é›†åˆä¸­ DispatcherServlet.addHttpHandler(url.getPort(), handler); // 2 åˆ›å»ºå†…åµŒTomcat String baseDir = new File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath(); tomcat = new Tomcat(); tomcat.setBaseDir(baseDir); // è®¾ç½®ç«¯å£ tomcat.setPort(url.getPort()); // è®¾ç½®æœ€å¤§çº¿ç¨‹æ•° tomcat.getConnector().setProperty(\"maxThreads\", String.valueOf(url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS)));// tomcat.getConnector().setProperty(// \"minSpareThreads\", String.valueOf(url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS))); // è®¾ç½®æœ€å¤§è¿æ¥æ±  tomcat.getConnector().setProperty(\"maxConnections\", String.valueOf(url.getParameter(Constants.ACCEPTS_KEY, -1))); // ç¼–ç ä¸ºUTF-8 tomcat.getConnector().setProperty(\"URIEncoding\", \"UTF-8\"); // è¿æ¥è¶…æ—¶ 60 ç§’ tomcat.getConnector().setProperty(\"connectionTimeout\", \"60000\"); tomcat.getConnector().setProperty(\"maxKeepAliveRequests\", \"-1\"); tomcat.getConnector().setProtocol(\"org.apache.coyote.http11.Http11NioProtocol\"); // 3 åˆ›å»ºå¹¶æ·»åŠ DispatcherServlet åˆ° Tomcat ä¸­ï¼Œä½œä¸º Tomcat çš„å¤„ç†å™¨åˆ†å‘å™¨ Context context = tomcat.addContext(\"/\", baseDir); Tomcat.addServlet(context, \"dispatcher\", new DispatcherServlet()); context.addServletMapping(\"/*\", \"dispatcher\"); // 4 æ·»åŠ ServletContext ä¸Šä¸‹æ–‡å¯¹è±¡ åˆ° ServletManager ä¸­ ServletManager.getInstance().addServletContext(url.getPort(), context.getServletContext()); try &#123; // 5 å¯åŠ¨tomcat tomcat.start(); &#125; catch (LifecycleException e) &#123; throw new IllegalStateException(\"Failed to start tomcat server at \" + url.getAddress(), e); &#125; &#125;&#125; TomcatHttpServer çš„æ„é€ æ–¹æ³•ä¸­ä¼šåˆ›å»ºä¸€ä¸ªå†…ç½®çš„ Tomcat æœåŠ¡å™¨ï¼Œç„¶åè®¾ç½® å¯åŠ¨ç«¯å£ã€æœ€å¤§çº¿ç¨‹ä»¥åŠè°ƒåº¦å™¨ ç­‰å‚æ•°ï¼Œå…¶ä¸­ è°ƒåº¦å™¨ æ˜¯ç”¨æ¥å¤„ç† å†…ç½®Tomcat æ¥æ”¶çš„è¯·æ±‚çš„ï¼Œè¯¥è°ƒåº¦å™¨æ˜¯ Dubbo æ¡†æ¶é€šè¿‡ç»§æ‰¿ HttpServer å®ç°çš„ï¼Œä½œç”¨å’Œ Spring çš„ DispatcherServlet ç±»ä¼¼ï¼Œç”¨æ¥æ´¾å‘è¯·æ±‚ï¼Œæˆ‘ä»¬ä¼šåœ¨ä¸‹æ–‡ä¸­è¯¦ç»†è¯´æ˜ã€‚ æœåŠ¡å…³é—­å¦‚ä¸‹ï¼š 1234567891011121314+--- TomcatHttpServer @Override public void close() &#123; // æ ‡è®°å…³é—­ super.close(); // ç§»é™¤ ServletContext å¯¹è±¡ ServletManager.getInstance().removeServletContext(url.getPort()); // å…³é—­tomcat try &#123; tomcat.stop(); &#125; catch (Exception e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; ServletHttpServer1234567public class ServletHttpServer extends AbstractHttpServer &#123; public ServletHttpServer(URL url, HttpHandler handler) &#123; super(url, handler); // æ³¨å†ŒHttpHandler åˆ° DispatcherServlet ä¸­ DispatcherServlet.addHttpHandler(url.getParameter(Constants.BIND_PORT_KEY, 8080), handler); &#125;&#125; ServletHttpServer æ˜¯åŸºäº Servlet çš„æœåŠ¡å™¨å®ç°ç±»ï¼Œè¯¥æ–¹å¼éœ€è¦é…ç½® DispatcherServlet(Dubbo å®ç°çš„ HttpServlet) åˆ° web.xml ä¸­ï¼Œé€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œè®©å¤–éƒ¨çš„Servletå®¹å™¨å¯ä»¥è¿›è¡Œè½¬å‘è¯·æ±‚ã€‚ HTTP è°ƒåº¦å™¨DispatcherServlet ç»§æ‰¿äº† javax.servlet.http.HttpServlet ï¼Œæ˜¯ Dubbo å®ç°çš„æœåŠ¡å™¨è¯·æ±‚è°ƒåº¦ Servletã€‚ç”¨äºè°ƒåº¦è¯·æ±‚ï¼Œå°†è¯·æ±‚äº¤ç»™å¯¹åº”çš„å¤„ç†å™¨æ‰§è¡Œã€‚æ— è®ºæ˜¯å†…ç½®çš„ Jetty å®ç°ï¼Œè¿˜æ˜¯ Tomcat å®ç°ï¼Œæˆ–è€…æ˜¯ä½œä¸ºå¤–éƒ¨çš„ Servlet , DispatcherServlet ä½œç”¨éƒ½æ˜¯ä¸€è‡´çš„ï¼Œç”¨äºè°ƒåº¦è¯·æ±‚ã€‚ å±æ€§12345678910111213141516171819202122232425262728293031323334353637383940public class DispatcherServlet extends HttpServlet &#123; private static final long serialVersionUID = 5766349180380479888L; /** * å¤„ç†å™¨ç¼“å­˜é›†åˆ */ private static final Map&lt;Integer, HttpHandler&gt; handlers = new ConcurrentHashMap&lt;Integer, HttpHandler&gt;(); /** * å•ä¾‹ - é¥¿æ±‰æ¨¡å¼ */ private static DispatcherServlet INSTANCE; public DispatcherServlet() &#123; DispatcherServlet.INSTANCE = this; &#125; /** * æ·»åŠ å¤„ç†å™¨ * * @param port æœåŠ¡å™¨ç«¯å£ * @param processor å¤„ç†å™¨ */ public static void addHttpHandler(int port, HttpHandler processor) &#123; handlers.put(port, processor); &#125; public static DispatcherServlet getInstance() &#123; return INSTANCE; &#125; /** * ç§»é™¤å¤„ç†å™¨ * * @param port æœåŠ¡å™¨ç«¯å£ */ public static void removeHttpHandler(int port) &#123; handlers.remove(port); &#125;&#125; è°ƒåº¦è¯·æ±‚12345678910111213+--- DispatcherServlet @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1 ä»HANDLERSé›†åˆä¸­æŸ¥è¯¢ç«¯å£å¯¹åº”çš„HttpHandlerå¯¹è±¡ HttpHandler handler = handlers.get(request.getLocalPort()); // 2 æ²¡æœ‰å¤„ç†å™¨å°±æŠ¥é”™ if (handler == null) &#123; response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Service not found.\"); &#125; else &#123; // 3 å°†è¯·æ±‚å§”æ‰˜ç»™å¯¹åº”çš„HttpHandlerå¯¹è±¡å¤„ç† handler.handle(request, response); &#125; &#125; DispatcherServlet å°†æ¥æ”¶åˆ°çš„è¯·æ±‚äº¤ç»™è¯·æ±‚ HTTP å¤„ç†å™¨å¤„ç†ã€‚ HTTP å¤„ç†å™¨1234567891011public interface HttpHandler &#123; /** * å¤„ç†è¯·æ±‚ * * @param request request. è¯·æ±‚ * @param response response. å“åº” * @throws IOException * @throws ServletException */ void handle(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;&#125; åŸºäº HTTP æœåŠ¡çš„ Protocol éƒ½æœ‰å„è‡ªçš„å®ç°ï¼Œä¸‹é¢æˆ‘ä»¬åˆ†æ HttpProtocol ä¸­çš„å®ç°ã€‚ 1234567891011121314151617181920212223242526272829303132333435+--- HttpProtocol private class InternalHandler implements HttpHandler &#123; /** * å¤„ç†è¯·æ±‚ * * @param request request è¯·æ±‚ * @param response response å“åº” * @throws IOException * @throws ServletException */ @Override public void handle(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; // 1 è·å–è¯·æ±‚çš„uri String uri = request.getRequestURI(); // 2 ä»ç¼“å­˜ä¸­å–å‡ºuriå¯¹åº”çš„ HttpInvokerServiceExporter å¯¹è±¡ HttpInvokerServiceExporter skeleton = skeletonMap.get(uri); // 3 å¿…é¡»æ˜¯postè¯·æ±‚ï¼ˆ Dubbo 2.6.x çš„ http åè®®æ˜¯åŸºäºHTTPè¡¨å•çš„è¿œç¨‹è°ƒç”¨åè®®) if (!request.getMethod().equalsIgnoreCase(\"POST\")) &#123; // ä¸æ˜¯postè¯·æ±‚å°±ç›´æ¥è¿”å›500 response.setStatus(500); &#125; else &#123; // 4 è®¾ç½®è¿œç¨‹è°ƒç”¨åœ°å€ RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort()); try &#123; // 5 å¤„ç†è¯·æ±‚ï¼Œç»“æœå†™åˆ°responseä¸­ // å“åº”æ•°æ®ç±»å‹ä½¿ç”¨çš„ä¹Ÿæ˜¯ application/x-java-serialized-object skeleton.handleRequest(request, response); &#125; catch (Throwable e) &#123; throw new ServletException(e); &#125; &#125; &#125; &#125; HttpProtocol ä¸­ HTTP å¤„ç†å™¨æ˜¯ä¸€ä¸ªå†…éƒ¨å®ç°ç±»ï¼Œç”¨äºå¤„ç† HTTP è°ƒåº¦å™¨è½¬å‘è¿‡æ¥çš„è¯·æ±‚ï¼Œæœ€ç»ˆåˆä¼šå°†è¯·æ±‚äº¤ç»™ HttpInvokerServiceExporter æš´éœ²çš„æœåŠ¡å¤„ç†ã€‚å…¶ä¸­è¯·æ±‚çš„ uri ä½œä¸ºæ˜ å°„ HttpInvokerServiceExporter æš´éœ²çš„æœåŠ¡çš„é”®ï¼Œåœ¨æœåŠ¡å¼•ç”¨æ–¹æ³• doRefer ä¸­ä¼šè®¾ç½®å¥½è¿™ä¸ªè¯·æ±‚è·¯å¾„ã€‚ æä¾›æœåŠ¡ä½¿ç”¨ HttpInvokerServiceExporter å‘å¤–æä¾›æœåŠ¡ã€‚ 123456789101112131415private &lt;T&gt; HttpInvokerServiceExporter createExporter(T impl, Class&lt;?&gt; type) &#123; // 1 åˆ›å»º HttpInvokerServiceExporterï¼Œä»¥ serviceInterface ä¸ºå…¬å…±æ¥å£ï¼Œä»¥ service ä¸ºå®ç°ç±»å‘å¤–æä¾›æœåŠ¡ã€‚ final HttpInvokerServiceExporter httpServiceExporter = new HttpInvokerServiceExporter(); // 2 è®¾ç½®æ¥å£ httpServiceExporter.setServiceInterface(type); // 3 è®¾ç½®å®ç° httpServiceExporter.setService(impl); try &#123; // 4 æ ¹æ®æ¥å£å’Œå®ç°ï¼Œåˆ›å»ºä»£ç†å¯¹è±¡ï¼ˆSpringå®ç°çš„ï¼‰ï¼Œæ˜¯ HttpInvokerServiceExporter ä¸­çš„ä¸€ä¸ªå±æ€§ã€‚ httpServiceExporter.afterPropertiesSet(); &#125; catch (Exception e) &#123; throw new RpcException(e.getMessage(), e); &#125; return httpServiceExporter;&#125; éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒHttpInvokerServiceExporter é»˜è®¤ä½¿ç”¨çš„åºåˆ—åŒ–ä¸º application/x-java-serialized-objectï¼Œå³ Java åºåˆ—æ–¹å¼ã€‚ç†è®ºä¸Šå¯ä»¥é€šè¿‡ HttpInvokerServiceExporter.setContentType() æ–¹æ³•æŒ‡å®šåºåˆ—åŒ–æ–¹å¼ã€‚ æœåŠ¡å¼•ç”¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566+--- HttpProtocol @Override @SuppressWarnings(\"unchecked\") protected &lt;T&gt; T doRefer(final Class&lt;T&gt; serviceType, final URL url) throws RpcException &#123; // 1 åˆ¤æ–­æ˜¯å¦æ˜¯æ³›åŒ–è°ƒç”¨ final String generic = url.getParameter(Constants.GENERIC_KEY); final boolean isGeneric = ProtocolUtils.isGeneric(generic) || serviceType.equals(GenericService.class); // 2 åˆ›å»º HttpInvokerProxyFactoryBean å¯¹è±¡ // Spring å°è£…çš„ä¸€ä¸ªæœåŠ¡å¼•ç”¨å™¨ï¼ŒserviceInterface æŒ‡å®šäº†ç”Ÿæˆä»£ç†çš„æ¥å£ï¼ŒserviceUrl æŒ‡å®šäº†æœåŠ¡æ‰€åœ¨çš„åœ°å€ï¼ˆä¸æœåŠ¡æš´éœ²è€…çš„è·¯å¾„éœ€è¦å¯¹åº”ï¼‰ final HttpInvokerProxyFactoryBean httpProxyFactoryBean = new HttpInvokerProxyFactoryBean(); // 3 è®¾ç½®è¿œç¨‹è°ƒç”¨ä¿¡æ¯ï¼Œå…¶ä¸­åŒ…æ‹¬å¯¹é™„åŠ å±æ€§å’Œæ³›åŒ–è°ƒç”¨çš„å¤„ç† httpProxyFactoryBean.setRemoteInvocationFactory(new RemoteInvocationFactory() &#123; @Override public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) &#123; RemoteInvocation invocation = new HttpRemoteInvocation(methodInvocation); if (isGeneric) &#123; invocation.addAttribute(Constants.GENERIC_KEY, generic); &#125; return invocation; &#125; &#125;); // 4 è®¾ç½®ç›®æ ‡æœåŠ¡çš„è°ƒç”¨åœ°å€ ï¼Œå¦‚ï¼šhttp://10.1.31.48:8080/com.alibaba.dubbo.demo.DemoService String key = url.toIdentityString(); // 4.1 è°ƒç”¨æ³›åŒ–æœåŠ¡ å¦‚ï¼šhttp://10.1.31.48:8080/com.alibaba.dubbo.demo.DemoService/generic if (isGeneric) &#123; key = key + \"/\" + Constants.GENERIC_KEY; &#125; // 4.2 è®¾ç½®è®¿é—®æœåŠ¡è·¯å¾„ï¼Œæ ¼å¼ï¼šip:port/path httpProxyFactoryBean.setServiceUrl(key); // 4.3 è®¾ç½®ç”Ÿæˆä»£ç†çš„æ¥å£ httpProxyFactoryBean.setServiceInterface(serviceType); // 5 åˆå§‹åŒ–å®¢æˆ·ç«¯ç±»å‹ client å‚æ•° String client = url.getParameter(Constants.CLIENT_KEY); // æ ¹æ®å®¢æˆ·ç«¯ç±»å‹ä¸åŒï¼Œåˆ›å»ºä¸åŒçš„ æ‰§è¡Œå™¨ï¼Œé»˜è®¤åˆ›å»º SimpleHttpInvokerRequestExecutor å¯¹è±¡ï¼Œå³ä½¿ç”¨çš„æ˜¯ JDK çš„ HTTP åŠŸèƒ½ã€‚ // ä»¥ä¸‹ä¸¤ç§æ–¹å¼ Content-Type çš„å€¼ä¸º application/x-java-serialized-objectï¼Œå³ä½¿ç”¨çš„åºåˆ—åŒ–æ–¹å¼ä¸º java åºåˆ—åŒ– if (client == null || client.length() == 0 || \"simple\".equals(client)) &#123; // ä½¿ç”¨çš„HttpClient æ˜¯ JDK HttpClent SimpleHttpInvokerRequestExecutor httpInvokerRequestExecutor = new SimpleHttpInvokerRequestExecutor() &#123; @Override protected void prepareConnection(HttpURLConnection con, int contentLength) throws IOException &#123; super.prepareConnection(con, contentLength); con.setReadTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT)); con.setConnectTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT)); &#125; &#125;; httpProxyFactoryBean.setHttpInvokerRequestExecutor(httpInvokerRequestExecutor); &#125; else if (\"commons\".equals(client)) &#123; // ä½¿ç”¨çš„HttpClient æ˜¯ Apache HttpClient HttpComponentsHttpInvokerRequestExecutor httpInvokerRequestExecutor = new HttpComponentsHttpInvokerRequestExecutor(); httpInvokerRequestExecutor.setReadTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT)); httpInvokerRequestExecutor.setConnectTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT)); httpProxyFactoryBean.setHttpInvokerRequestExecutor(httpInvokerRequestExecutor); &#125; else &#123; throw new IllegalStateException(\"Unsupported http protocol client \" + client + \", only supported: simple, commons\"); &#125; // 6 è¿”å›æŒ‡å®šæ¥å£çš„ä»£ç†å¯¹è±¡ httpProxyFactoryBean.afterPropertiesSet(); return (T) httpProxyFactoryBean.getObject(); &#125; æœåŠ¡å¼•ç”¨çš„å…³é”®æœ‰ä¸¤ç‚¹ï¼šå…¶ä¸€ï¼Œç¡®å®šå¥½ç›®æ ‡æœåŠ¡è®¿é—®è·¯å¾„ï¼Œè®¿é—®è·¯å¾„çš„ uri éƒ¨åˆ†ä½¿ç”¨ Dubbo URL ä¸­çš„ pathå‚æ•°ã€‚å…¶äºŒï¼Œè®¾ç½® ç›®æ ‡æœåŠ¡çš„æ¥å£ï¼Œæ³¨æ„æ³›åŒ–è°ƒç”¨çš„å®ç°æ–¹å¼ã€‚ å…³ç³»ç±»å›¾ HTTP æŠ¥æ–‡ä¿¡æ¯ä¸Šå›¾ä¸­çš„å®¢æˆ·ç«¯ä¹‹æ‰€ä»¥æ˜¯ Apache-HttpClientï¼Œæ˜¯é…ç½®äº† client=commonsã€‚é»˜è®¤é‡‡ç”¨ Java çš„å®¢æˆ·ç«¯ï¼Œå¦‚ï¼š User-Agent: Java/1.8.0_211ã€‚ åŸºäº HTTP è¡¨å•çš„è¿œç¨‹è°ƒç”¨åè®®ï¼Œé‡‡ç”¨ Spring çš„ HttpInvoker å®ç°çš„ HTTPåè®®ï¼Œæ€»ä½“æ¥çœ‹æ¯”è¾ƒé¸¡è‚‹ã€‚ä¸€æ–¹é¢ç½‘ç»œä¼ è¾“ä½¿ç”¨çš„æ˜¯ HTTP æ–¹å¼ï¼Œå…¶æœ¬èº«å…·æœ‰é€šç”¨æ€§ï¼Œä½†é‡‡ç”¨çš„åºåˆ—åŒ–æ–¹å¼å´æ˜¯ Java çš„åºåˆ—åŒ–ï¼Œè¿™ä½¿å¾—å…¶åœ¨ä¸€å®šç¨‹åº¦ä¸Šä¸§å¤±äº†è·¨è¯­è¨€çš„ä¼˜åŠ¿ã€‚ Dubbo 2.7.x å®ç°Dubbo 2.7.x ä¸­ä½¿ç”¨ HTTPåè®® + JSON-RPC çš„æ–¹å¼æ¥å®ç°è·¨è¯­è¨€è°ƒç”¨ï¼Œå…¶ä¸­ HTTP åè®®å’Œ JSON éƒ½æ˜¯å¤©ç„¶è·¨è¯­è¨€çš„æ ‡å‡†ï¼Œå‡ ä¹å„ç§è¯­è¨€ä¸­éƒ½æœ‰æˆç†Ÿçš„ç±»åº“ã€‚è¯¥ç‰ˆæœ¬ä¸­æ”¯æŒçš„ HTTP åè®®å®é™…ä¸Šä½¿ç”¨çš„æ˜¯ JSON-RPC åè®®ï¼Œå…·ä½“æ˜¯ä½¿ç”¨ jsonrpc4j åº“æ¥å®ç° JSON-RPC åè®®çš„ã€‚ JSON-RPC åŸç”Ÿä½¿ç”¨æè¿°JSON-RPC åè®®éå¸¸ç®€å•ï¼Œå‘èµ·è¿œç¨‹è°ƒç”¨æ—¶å‘æœåŠ¡ç«¯ä¼ è¾“æ•°æ®æ ¼å¼å¦‚ä¸‹ï¼š 12345678&#123; \"id\": 1, \"jsonrpc\" : 2.0, \"method\": \"sayHello\", \"params\": [ \"Hello JSON-RPC\" ] &#125; å‚æ•°è¯´æ˜ï¼š idï¼šè°ƒç”¨æ ‡è¯†ç¬¦ï¼Œç”¨äºæ ‡ç¤ºä¸€æ¬¡è¿œç¨‹è°ƒç”¨è¿‡ç¨‹ã€‚ jsonrpc: å®šä¹‰ JSON-RPC ç‰ˆæœ¬ method: è°ƒç”¨çš„æ–¹æ³•å params: æ–¹æ³•ä¼ å…¥å‚æ•°ï¼Œéœ€è¦æ˜¯æ•°ç»„æ ¼å¼ï¼Œè‹¥æ— å‚æ•°åˆ™ä¼ å…¥ [] ã€‚ æœåŠ¡å™¨æ”¶åˆ°è°ƒç”¨è¯·æ±‚åä¼šæŸ¥æ‰¾åˆ°ç›¸åº”çš„æ–¹æ³•å¹¶è¿›è¡Œè°ƒç”¨ï¼Œç„¶åå°†æ–¹æ³•çš„è¿”å›å€¼æ•´ç†æˆå¦‚ä¸‹æ ¼å¼ï¼Œè¿”å›ç»™å®¢æˆ·ç«¯ï¼š 123456&#123; \"id\": 1, \"jsonrpc\" : 2.0, \"result\": \"Hello JSON-RPC\", \"error\": null&#125; å‚æ•°è¯´æ˜ï¼š id: è°ƒç”¨æ ‡è¯†ç¬¦ï¼Œä¸è°ƒç”¨æ–¹ä¼ å…¥çš„æ ‡è¯†ç¬¦ä¸€è‡´ã€‚ jsonrpc: å®šä¹‰ JSON-RPC ç‰ˆæœ¬ result: æ–¹æ³•è¿”å›å€¼ï¼Œè‹¥æ— è¿”å›å€¼ï¼Œåˆ™è¿”å›nullã€‚è‹¥è°ƒç”¨é”™è¯¯ï¼Œè¿”å›nullã€‚ error: è°ƒç”¨å‘ç”Ÿå¼‚å¸¸æ—¶é”™è¯¯ä¿¡æ¯ï¼Œæ— é”™è¯¯è¿”å›nullã€‚ jsonrpc4j ä½¿ç”¨ç¤ºä¾‹æœåŠ¡æš´éœ²123456789101112131415161718192021@Controllerpublic class RpcController &#123; /** * è¿™é‡Œä½¿ç”¨ SpringMvc æ¥æ”¶è¯·æ±‚ï¼Œç„¶åå°†è¯·æ±‚äº¤ç»™ JsonRpcServer * * @param request * @param response * @throws IOException */ @RequestMapping(\"/json_rpc\") public void handle(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; /** * 1 å°†æœåŠ¡ IJsonRpcService ä¸ JSON-RPC å…³è”èµ·æ¥ï¼ŒHTTP è¯·æ±‚å§”æ‰˜ç»™ JsonPpcServer è¿›è¡Œå¤„ç† * 2 JsonRpcServer ä¼šæŒ‰ç…§ json-rpc è¯·æ±‚è°ƒç”¨ JsonRpcServiceImpl ä¸­çš„æ–¹æ³•ã€‚å…¶ä¸­ IJsonRrcService æ²¡æœ‰ç”¨åˆ°ã€‚ */ JsonRpcServer rpcServer = new JsonRpcServer(new JsonRpcServiceImpl(), IJsonRrcService.class); rpcServer.handle(request, response); &#125;&#125; è¯¥æ¡ˆä¾‹å€ŸåŠ© Servlet å®¹å™¨æ¥æ”¶è¯·æ±‚ï¼Œç„¶åå°†è¯·æ±‚å§”æ‰˜ç»™ JsonRpcServer å¤„ç†ã€‚ ä¸‹é¢æˆ‘ä»¬ç®€å•å¯¹ jsonrpc4j è¿›è¡Œåˆ†æï¼Œè¿™æ ·å¯ä»¥æ›´ç›´è§‚åœ°æ„Ÿå— JSON-RPC åè®®å®ç°ã€‚ æºç åˆ†æåˆ›å»º JsonRpcServer123456789101112131415161718192021222324+--- JsonRpcServer // çœç•¥å±æ€§ /** * @param handler æœåŠ¡å®ç° * @param remoteInterface æœåŠ¡æ¥å£ï¼Œæ²¡æœ‰ç”¨åˆ° */ public JsonRpcServer(Object handler, Class&lt;?&gt; remoteInterface) &#123; // åˆ›å»º jackson åŸŸå¯¹è±¡ this(new ObjectMapper(), handler, (Class) null); &#125; public JsonRpcServer(ObjectMapper mapper, Object handler, Class&lt;?&gt; remoteInterface) &#123; this.backwardsComaptible = true; this.rethrowExceptions = false; this.allowExtraParams = false; this.allowLessParams = false; this.errorResolver = null; this.exceptionLogLevel = Level.WARNING; this.mapper = mapper; // mapper this.handler = handler; // æœåŠ¡å¯¹è±¡ this.remoteInterface = remoteInterface; // null &#125; å¤„ç†è¯·æ±‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137+--- JsonRpcServer public void handle(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; if (LOGGER.isLoggable(Level.FINE)) &#123; LOGGER.log(Level.FINE, \"Handing HttpServletRequest \" + request.getMethod()); &#125; // 1 å“åº”æ•°æ®ç±»å‹ response.setContentType(\"application/json-rpc\"); InputStream input = null; // è·å–è¾“å‡ºæµ OutputStream output = response.getOutputStream(); // 2 åˆ¤æ–­è¯·æ±‚ç±»å‹ if (request.getMethod().equals(\"POST\")) &#123; // 2.1 å¦‚æœæ˜¯ POST è¯·æ±‚ï¼Œé‚£ä¹ˆè¯·æ±‚å†…å®¹åœ¨è¯·æ±‚ä½“ä¸­ input = request.getInputStream(); &#125; else &#123; if (!request.getMethod().equals(\"GET\")) &#123; throw new IOException(\"Invalid request method, only POST and GET is supported\"); &#125; // 2.2 å¦‚æœæ˜¯ GET è¯·æ±‚ï¼Œåˆ™éœ€è¦æŠŠå…³é”®çš„è¯·æ±‚å‚æ•°æå–å‡ºæ¥ï¼Œå¹¶å°è£…æˆ InputStream å¯¹è±¡ input = createInputStream(request.getParameter(\"method\"), request.getParameter(\"id\"), request.getParameter(\"params\")); &#125; // 3 å¤„ç†è¯·æ±‚ this.handle((InputStream) input, (OutputStream) output); &#125; public void handle(InputStream ips, OutputStream ops) throws IOException &#123; JsonNode jsonNode = null; try &#123; // å°†è¯·æ±‚çš„å­—èŠ‚æ•°æ®ååºåˆ—åŒ–æˆå¯¹è±¡ jsonNode = this.mapper.readTree(new NoCloseInputStream(ips)); &#125; catch (JsonParseException var5) &#123; this.writeAndFlushValue(ops, this.createErrorResponse(\"jsonrpc\", \"null\", -32700, \"Parse error\", (Object) null)); return; &#125; // è¿›ä¸€æ­¥å¤„ç†è¯·æ±‚ this.handleNode(jsonNode, ops); &#125; /** * @param node è¯·æ±‚å­—èŠ‚æµååºåˆ—åŒ–çš„å¯¹è±¡ * @param ops å“åº”è¾“å‡ºæµ * @throws IOException */ public void handleNode(JsonNode node, OutputStream ops) throws IOException &#123; // æ ¹æ®ä¸åŒçš„è¯·æ±‚å‚æ•°ç±»å‹ï¼Œè¿›è¡Œä¸åŒçš„å¤„ç† if (node.isObject()) &#123; // æœ€ç»ˆæœ‰æ•ˆçš„è¯·æ±‚ä¼šèµ°è¿™ä¸ªåˆ†æ”¯ this.handleObject((ObjectNode) ObjectNode.class.cast(node), ops); &#125; else if (node.isArray()) &#123; this.handleArray((ArrayNode) ArrayNode.class.cast(node), ops); &#125; else &#123; this.writeAndFlushValue(ops, this.createErrorResponse(\"2.0\", \"null\", -32600, \"Invalid Request\", (Object) null)); &#125; &#125; // node è¯·æ±‚ä¿¡æ¯ ï¼š &#123;\"id\":\"7325124684462669617\",\"jsonrpc\":\"2.0\",\"method\":\"getUser\",\"params\":[1]&#125; public void handleObject(ObjectNode node, OutputStream ops) throws IOException &#123; if (LOGGER.isLoggable(Level.FINE)) &#123; LOGGER.log(Level.FINE, \"Request: \" + node.toString()); &#125; if ((this.backwardsComaptible || node.has(\"jsonrpc\")) &amp;&amp; node.has(\"method\")) &#123; // 1 è·å–è¯·æ±‚ä¿¡æ¯ JsonNode jsonPrcNode = node.get(\"jsonrpc\"); // json-rpc åè®®ç‰ˆæœ¬ JsonNode methodNode = node.get(\"method\"); // è°ƒç”¨ä¿¡æ¯ - æ–¹æ³• JsonNode idNode = node.get(\"id\"); // è°ƒç”¨ä¿¡æ¯ - è°ƒç”¨å”¯ä¸€id JsonNode paramsNode = node.get(\"params\"); // è°ƒç”¨ä¿¡æ¯ - å‚æ•° String jsonRpc = jsonPrcNode != null &amp;&amp; !jsonPrcNode.isNull() ? jsonPrcNode.asText() : \"2.0\"; // ç‰ˆæœ¬ String methodName = this.getMethodName(methodNode); // æ–¹æ³•å String serviceName = this.getServiceName(methodNode); // æœåŠ¡å ï¼Œç›®å‰ç‰ˆæœ¬è¿”å› null Object id = this.parseId(idNode); // è°ƒç”¨id Set&lt;Method&gt; methods = new HashSet(); // 2 åå°„è·å–æ–¹æ³•å¯¹è±¡ï¼Œå³æ ¹æ®æœåŠ¡å¯¹è±¡å’Œæ–¹æ³•åï¼Œåå°„è·å–æ–¹æ³•å¯¹è±¡ã€‚ // getHandlerInterfaces æ–¹æ³•çš„ serviceName æ²¡æœ‰ç”¨åˆ°ï¼Œç›´æ¥æ˜¯ä½¿ç”¨ this.handler è·å– Class ä¿¡æ¯ï¼Œå³æœåŠ¡å¯¹è±¡çš„Class methods.addAll(ReflectionUtil.findMethods(this.getHandlerInterfaces(serviceName), methodName)); if (methods.isEmpty()) &#123; this.writeAndFlushValue(ops, this.createErrorResponse(jsonRpc, id, -32601, \"Method not found\", (Object) null)); &#125; else &#123; // è·å–æ–¹æ³•å¯¹è±¡å’Œæ–¹æ³•çš„å‚æ•°å€¼ JsonRpcServer.MethodAndArgs methodArgs = this.findBestMethodByParamsNode(methods, paramsNode); if (methodArgs == null) &#123; this.writeAndFlushValue(ops, this.createErrorResponse(jsonRpc, id, -32602, \"Invalid method parameters\", (Object) null)); &#125; else &#123; JsonNode result = null; Throwable thrown = null; try &#123; // 3 åå°„è°ƒç”¨æœåŠ¡æ–¹æ³• // this.getHandler(serviceName) ç›´æ¥è¿”å› this.handlerï¼Œå³æœåŠ¡å¯¹è±¡ result = this.invoke(this.getHandler(serviceName), methodArgs.method, methodArgs.arguments); &#125; catch (Throwable var17) &#123; thrown = var17; &#125; if (id != null) &#123; JsonError error = null; Throwable e; if (thrown != null) &#123; e = thrown; if (InvocationTargetException.class.isInstance(thrown)) &#123; e = ((InvocationTargetException) InvocationTargetException.class.cast(thrown)).getTargetException(); &#125; if (this.errorResolver != null) &#123; error = this.errorResolver.resolveError(e, methodArgs.method, methodArgs.arguments); &#125; else &#123; error = DEFAULT_ERRROR_RESOLVER.resolveError(e, methodArgs.method, methodArgs.arguments); &#125; if (error == null) &#123; error = new JsonError(0, e.getMessage(), e.getClass().getName()); &#125; &#125; e = null; ObjectNode response; if (error != null) &#123; // 4 å°è£…é”™è¯¯å“åº” response = this.createErrorResponse(jsonRpc, id, error.getCode(), error.getMessage(), error.getData()); &#125; else &#123; // 4 å°è£…å“åº”å¯¹è±¡ response = this.createSuccessResponse(jsonRpc, id, result); &#125; // 5 å°†ç»“æœé€šè¿‡ ops å“åº”ç»™å®¢æˆ·ç«¯ this.writeAndFlushValue(ops, response); &#125; if (thrown != null) &#123; if (LOGGER.isLoggable(this.exceptionLogLevel)) &#123; LOGGER.log(this.exceptionLogLevel, \"Error in JSON-RPC Service\", thrown); &#125; if (this.rethrowExceptions) &#123; throw new RuntimeException(thrown); &#125; &#125; &#125; &#125; &#125; else &#123; this.writeAndFlushValue(ops, this.createErrorResponse(\"2.0\", \"null\", -32600, \"Invalid Request\", (Object) null)); &#125; &#125; æœåŠ¡å¼•ç”¨12345678910111213public class Client &#123; public static void main(String[] args) throws Throwable &#123; // 1 åˆ›å»º JsonRpcHttpClient JsonRpcHttpClient client = new JsonRpcHttpClient(new URL(\"http://127.0.0.1:8080/json_rpc\")); // 2 é€šè¿‡ JsonRpcHttpClient.invoke æ–¹æ³•è¿›è¡Œè°ƒç”¨ // 2.1 æŒ‡å®šè°ƒç”¨æ–¹æ³• // 2.2 æŒ‡å®šæ–¹æ³•å‚æ•°ï¼Œè¦æ±‚æ•°ç»„ // 2.3 é€‰å¡«ï¼Œè¿™é‡Œæ˜¯è¿”å›å€¼ç±»å‹ Integer[] params = new Integer[]&#123;1&#125;; User getUser = client.invoke(\"getUser\", params, User.class); System.out.println(getUser); &#125;&#125; åˆ›å»º JsonRpcHttpClient å¯¹è±¡ï¼Œå¹¶é€šè¿‡ JsonRpcHttpClient è¯·æ±‚æœåŠ¡ç«¯ã€‚ æºç åˆ†æåˆ›å»º JsonRpcHttpClient1234567891011121314151617+--- JsonRpcHttpClient public JsonRpcHttpClient(URL serviceUrl) &#123; // åˆ›å»º jackson é˜ˆå¯¹è±¡ this(new ObjectMapper(), serviceUrl, new HashMap()); &#125; public JsonRpcHttpClient(ObjectMapper mapper, URL serviceUrl, Map&lt;String, String&gt; headers) &#123; super(mapper); // JackJson å¯¹è±¡ this.connectionProxy = Proxy.NO_PROXY; this.connectionTimeoutMillis = 60000; this.readTimeoutMillis = 120000; this.sslContext = null; this.hostNameVerifier = null; this.headers = new HashMap(); this.serviceUrl = serviceUrl; // æœåŠ¡URL this.headers.putAll(headers); &#125; è°ƒç”¨æœåŠ¡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687+--- JsonRpcHttpClient/** * @param methodName æ–¹æ³•å * @param argument å‚æ•° ï¼Œæ•°ç»„å½¢å¼ * @param clazz è¿”å›å€¼ç±»å‹ * @param &lt;T&gt; * @return * @throws Throwable */ public &lt;T&gt; T invoke(String methodName, Object argument, Class&lt;T&gt; clazz) throws Throwable &#123; return this.invoke(methodName, argument, (Type) Type.class.cast(clazz)); &#125; public Object invoke(String methodName, Object argument, Type returnType, Map&lt;String, String&gt; extraHeaders) throws Throwable &#123; // 1 æ‰“å¼€è¿æ¥ï¼Œè¿æ¥æœåŠ¡ ï¼ˆJDK çš„ HTTP åŠŸèƒ½ï¼‰ HttpURLConnection con = this.prepareConnection(extraHeaders); con.connect(); // 2 è·å–è¿æ¥çš„è¾“å‡ºæµå¯¹è±¡ OutputStream ops = con.getOutputStream(); try &#123; // 3 è°ƒç”¨ JsonRpcClient ä¸­ invoke æ–¹æ³•ã€‚è¯¥æ–¹æ³•æ¶‰åŠåˆ°è¯·æ±‚æ•°æ®çš„å°è£…ã€åºåˆ—åŒ– super.invoke(methodName, argument, ops); &#125; finally &#123; ops.close(); &#125; // 4 è·å–è¿æ¥çš„è¾“å…¥æµ InputStream ips = con.getInputStream(); Object var8; try &#123; // 5 ååºåˆ—åŒ– var8 = super.readResponse(returnType, ips); &#125; finally &#123; ips.close(); &#125; return var8; &#125; /** * åˆå§‹åŒ– HTTP è¿æ¥ * * @param extraHeaders * @return * @throws IOException */ protected HttpURLConnection prepareConnection(Map&lt;String, String&gt; extraHeaders) throws IOException &#123; // æ‰“å¼€ Httpè¿æ¥ // this.serviceUrl æœåŠ¡URL HttpURLConnection con = (HttpURLConnection) this.serviceUrl.openConnection(this.connectionProxy); con.setConnectTimeout(this.connectionTimeoutMillis); con.setReadTimeout(this.readTimeoutMillis); con.setAllowUserInteraction(false); con.setDefaultUseCaches(false); con.setDoInput(true); con.setDoOutput(true); con.setUseCaches(false); con.setInstanceFollowRedirects(true); // è®¾ç½®è¯·æ±‚æ–¹å¼ä¸º POST con.setRequestMethod(\"POST\"); if (HttpsURLConnection.class.isInstance(con)) &#123; HttpsURLConnection https = (HttpsURLConnection) HttpsURLConnection.class.cast(con); if (this.hostNameVerifier != null) &#123; https.setHostnameVerifier(this.hostNameVerifier); &#125; if (this.sslContext != null) &#123; https.setSSLSocketFactory(this.sslContext.getSocketFactory()); &#125; &#125; Iterator i$ = this.headers.entrySet().iterator(); Entry entry; while (i$.hasNext()) &#123; entry = (Entry) i$.next(); con.setRequestProperty((String) entry.getKey(), (String) entry.getValue()); &#125; i$ = extraHeaders.entrySet().iterator(); while (i$.hasNext()) &#123; entry = (Entry) i$.next(); con.setRequestProperty((String) entry.getKey(), (String) entry.getValue()); &#125; // è®¾ç½®è¯·æ±‚æ•°æ®ç±»å‹å›ºå®šä¸º application/json-rpc con.setRequestProperty(\"Content-Type\", \"application/json-rpc\"); return con; &#125; JsonRpcHttpClient.invoke() æ–¹æ³•æµç¨‹ä¸»è¦å®Œæˆ JDK HTTPè¿æ¥çš„åˆ›å»ºï¼Œ å“åº”æ•°æ®çš„è¯»å–ï¼Œä»¥åŠååºåˆ—åŒ–æ•°æ®ã€‚è¯·æ±‚çš„æ•°æ®çš„å°è£…å’Œå‘é€æ˜¯åˆå…¶çˆ¶ç±» JsonRpcClient å®Œæˆã€‚ å‘èµ·è°ƒç”¨12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697+--- JsonRpcClient /** * æ‰§è¡Œè°ƒç”¨ * * @param methodName æ–¹æ³•åï¼Œå¦‚ï¼šgetUser * @param argument æ–¹æ³•å‚æ•°å€¼ * @param ops è¿æ¥çš„è¾“å‡ºæµå¯¹è±¡ * @throws IOException */ public void invoke(String methodName, Object argument, OutputStream ops) throws IOException &#123; // è¿™é‡Œä¼šç”Ÿæˆä¸€ä¸ªè°ƒç”¨id this.invoke(methodName, argument, ops, this.random.nextLong() + \"\"); &#125; /** * @param methodName * @param argument * @param ops * @param id å½“å‰è°ƒç”¨çš„å”¯ä¸€æ ‡è¯†åˆ« * @throws IOException */ public void invoke(String methodName, Object argument, OutputStream ops, String id) throws IOException &#123; this.writeRequest(methodName, argument, ops, id); ops.flush(); &#125; // å‘é€è¯·æ±‚ public void writeRequest(String methodName, Object argument, OutputStream ops, String id) throws IOException &#123; // å†…éƒ¨å‘é€è¯·æ±‚ this.internalWriteRequest(methodName, argument, ops, id); &#125; private void internalWriteRequest(String methodName, Object arguments, OutputStream ops, String id) throws IOException &#123; // 1 æ„é€ è¯·æ±‚å¯¹è±¡ ObjectNode request = this.mapper.createObjectNode(); // 1.1 id if (id != null) &#123; request.put(\"id\", id); &#125; // 1.2 jsonrpc request.put(\"jsonrpc\", \"2.0\"); // 1.3 method request.put(\"method\", methodName); // 1.4 params ArrayNode paramsNode; // 1.4.1 æ•°ç»„ if (arguments != null &amp;&amp; arguments.getClass().isArray()) &#123; Object[] args = (Object[]) Object[].class.cast(arguments); if (args.length &gt; 0) &#123; paramsNode = new ArrayNode(this.mapper.getNodeFactory()); Object[] arr$ = args; int len$ = args.length; for (int i$ = 0; i$ &lt; len$; ++i$) &#123; Object arg = arr$[i$]; JsonNode argNode = this.mapper.valueToTree(arg); paramsNode.add(argNode); &#125; request.put(\"params\", paramsNode); &#125; // 1.4.2 é›†åˆ &#125; else if (arguments != null &amp;&amp; Collection.class.isInstance(arguments)) &#123; Collection&lt;?&gt; args = (Collection) Collection.class.cast(arguments); if (!args.isEmpty()) &#123; paramsNode = new ArrayNode(this.mapper.getNodeFactory()); Iterator i$ = args.iterator(); while (i$.hasNext()) &#123; Object arg = i$.next(); JsonNode argNode = this.mapper.valueToTree(arg); paramsNode.add(argNode); &#125; request.put(\"params\", paramsNode); &#125; // 1.4.3 Map &#125; else if (arguments != null &amp;&amp; Map.class.isInstance(arguments)) &#123; if (!((Map) Map.class.cast(arguments)).isEmpty()) &#123; request.put(\"params\", this.mapper.valueToTree(arguments)); &#125; &#125; else if (arguments != null) &#123; request.put(\"params\", this.mapper.valueToTree(arguments)); &#125; if (this.requestListener != null) &#123; this.requestListener.onBeforeRequestSent(this, request); &#125; if (LOGGER.isLoggable(Level.FINE)) &#123; LOGGER.log(Level.FINE, \"JSON-PRC Request: \" + request.toString()); &#125; // 2 ä½¿ç”¨è¿æ¥çš„è¾“å‡ºæµå°†è¯·æ±‚æ•°æ®å†™å‡ºå»ï¼ˆå‘é€åˆ°å¯¹ç«¯ï¼‰ this.writeAndFlushValue(ops, request); &#125; private void writeAndFlushValue(OutputStream ops, Object value) throws IOException &#123; // å°†è¯·æ±‚å¯¹è±¡åºåˆ—åŒ–ï¼Œç„¶åå†™å‡ºå» this.mapper.writeValue(new NoCloseOutputStream(ops), value); ops.flush(); &#125; æºç å®ç° HTTP åè®®å®ç°ç›¸å…³çš„ä»£ç ç»“æ„å¦‚ä¸Šå›¾æ‰€ç¤ºã€‚ HttpProtocolå±æ€§123456789101112131415161718192021222324252627public class HttpProtocol extends AbstractProxyProtocol &#123; // è·¨åŸŸæ”¯æŒ public static final String ACCESS_CONTROL_ALLOW_ORIGIN_HEADER = \"Access-Control-Allow-Origin\"; public static final String ACCESS_CONTROL_ALLOW_METHODS_HEADER = \"Access-Control-Allow-Methods\"; public static final String ACCESS_CONTROL_ALLOW_HEADERS_HEADER = \"Access-Control-Allow-Headers\"; /** * æœåŠ¡è·¯å¾„ï¼ˆpathï¼‰åˆ° JsonRpcServer çš„æ˜ å°„ * è¯·æ±‚å¤„ç†è¿‡ç¨‹è¯´æ˜ï¼šHttpServer -&gt; DispatcherServlet -&gt; InternalHandler -&gt; JsonRpcServer */ private final Map&lt;String, JsonRpcServer&gt; skeletonMap = new ConcurrentHashMap&lt;&gt;(); // HTTPç»‘å®šå™¨ private HttpBinder httpBinder; public HttpProtocol() &#123; super(HttpException.class, JsonRpcClientException.class); &#125; // HttpBinder$Adaptive å¯¹è±¡,é€šè¿‡ &#123;@link #setHttpBinder(HttpBinder)&#125;æ–¹æ³•ï¼ŒDubbo SPI IOCæ³¨å…¥ public void setHttpBinder(HttpBinder httpBinder) &#123; this.httpBinder = httpBinder; &#125; @Override public int getDefaultPort() &#123; return 80; &#125;&#125; æœåŠ¡æš´éœ²12345678910111213141516171819202122232425262728293031323334+--- HttpProtocol @Override protected &lt;T&gt; Runnable doExport(final T impl, Class&lt;T&gt; type, URL url) throws RpcException &#123; // 1 è·å–æœåŠ¡å™¨åœ°å€ ip:port String addr = getAddr(url); // 2 æ ¹æ®åœ°å€ä»ç¼“å­˜ä¸­è·å¾— HTTP æœåŠ¡ï¼Œè‹¥ä¸å­˜åœ¨ï¼Œè¿›è¡Œåˆ›å»º ProtocolServer protocolServer = serverMap.get(addr); if (protocolServer == null) &#123; /** * 1 é€šè¿‡SPIæœºåˆ¶è·å–å…·ä½“çš„ HttpBinderçš„æ‹“å±•å®ç° * 2 å…·ä½“çš„HttpBinderå®ç°è°ƒç”¨bindæ–¹æ³•ï¼š * 1ï¼‰å¯åŠ¨æœåŠ¡ * 2ï¼‰ä¸ºæœåŠ¡è®¾ç½®è¯·æ±‚å¤„ç†å™¨(InternalHandlerå¯¹è±¡)ï¼Œæ”¯æŒè®¾ç½®è·¨åŸŸå‚æ•° * 3 ç¼“å­˜ HTTP æœåŠ¡ */ RemotingServer remotingServer = httpBinder.bind(url, new InternalHandler(url.getParameter(\"cors\", false))); serverMap.put(addr, new ProxyProtocolServer(remotingServer)); &#125; // 3 è·å– url çš„ path ï¼Œä»¥æ­¤ä¸º key ç¼“å­˜ JsonRpcServerã€‚å¦‚ï¼š/org.apache.dubbo.demo.GreetingService final String path = url.getAbsolutePath(); // 4 æ”¯æŒæ³›åŒ–ï¼Œå¦‚ï¼š/org.apache.dubbo.demo.GreetingService/generic final String genericPath = path + \"/\" + GENERIC_KEY; // 5 åˆ›å»º JsonRpcServerï¼Œæš´éœ²æœåŠ¡ JsonRpcServer skeleton = new JsonRpcServer(impl, type); JsonRpcServer genericServer = new JsonRpcServer(impl, GenericService.class); // 6 åˆ†åˆ«ç¼“å­˜æœåŠ¡å’Œæ³›åŒ–æœåŠ¡çš„ JsonRpcServer skeletonMap.put(path, skeleton); skeletonMap.put(genericPath, genericServer); return () -&gt; &#123; skeletonMap.remove(path); skeletonMap.remove(genericPath); &#125;; &#125; HTTP å¤„ç†å™¨1234567891011121314151617181920212223242526272829303132333435363738394041424344+--- HttpProtocolprivate class InternalHandler implements HttpHandler &#123; /** * æ˜¯å¦è·¨åŸŸæ”¯æŒ */ private boolean cors; public InternalHandler(boolean cors) &#123; this.cors = cors; &#125; @Override public void handle(HttpServletRequest request, HttpServletResponse response) throws ServletException &#123; // 1 è·å–è¯·æ±‚çš„uri String uri = request.getRequestURI(); // 2 ä»ç¼“å­˜ä¸­å–å‡ºè¯·æ±‚uri å¯¹åº”çš„ JsonRpcServer JsonRpcServer skeleton = skeletonMap.get(uri); // 3 å¤„ç†è·¨åŸŸ if (cors) &#123; response.setHeader(ACCESS_CONTROL_ALLOW_ORIGIN_HEADER, \"*\"); response.setHeader(ACCESS_CONTROL_ALLOW_METHODS_HEADER, \"POST\"); response.setHeader(ACCESS_CONTROL_ALLOW_HEADERS_HEADER, \"*\"); &#125; // 4 å“åº”è·¨åŸŸæ¢æµ‹è¯·æ±‚ if (request.getMethod().equalsIgnoreCase(\"OPTIONS\")) &#123; response.setStatus(200); // 5 å¿…é¡»æ˜¯ POST è¯·æ±‚ &#125; else if (request.getMethod().equalsIgnoreCase(\"POST\")) &#123; // è®¾ç½®è¿œç¨‹è°ƒç”¨åœ°å€ RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort()); try &#123; // å¤„ç†è¯·æ±‚ skeleton.handle(request.getInputStream(), response.getOutputStream()); &#125; catch (Throwable e) &#123; throw new ServletException(e); &#125; // è¯·æ±‚æ–¹æ³•ä¸åŒ¹é…ç›´æ¥æŠ›å‡º 500 &#125; else &#123; response.setStatus(500); &#125; &#125; &#125; æœåŠ¡å¼•ç”¨1234567891011121314151617181920212223242526272829303132333435363738+--- HttpProtocol @Override protected &lt;T&gt; T doRefer(final Class&lt;T&gt; serviceType, URL url) throws RpcException &#123; // 1 åˆ¤æ–­æ˜¯å¦æ˜¯æ³›åŒ–è°ƒç”¨ final String generic = url.getParameter(GENERIC_KEY); final boolean isGeneric = ProtocolUtils.isGeneric(generic) || serviceType.equals(GenericService.class); // 2 å·¥å‚å¯¹è±¡ JsonProxyFactoryBean jsonProxyFactoryBean = new JsonProxyFactoryBean(); JsonRpcProxyFactoryBean jsonRpcProxyFactoryBean = new JsonRpcProxyFactoryBean(jsonProxyFactoryBean); // 3 é™„åŠ å±æ€§å’Œæ³›åŒ–è°ƒç”¨æ”¯æŒ jsonRpcProxyFactoryBean.setRemoteInvocationFactory((methodInvocation) -&gt; &#123; RemoteInvocation invocation = new JsonRemoteInvocation(methodInvocation); // æ³›åŒ–è°ƒç”¨ if (isGeneric) &#123; invocation.addAttribute(GENERIC_KEY, generic); &#125; return invocation; &#125;); // 4 æœåŠ¡è®¿é—®è·¯å¾„ï¼Œå¦‚ http://10.1.31.48:80/org.apache.dubbo.demo.DemoService String key = url.setProtocol(\"http\").toIdentityString(); // 5 æ³›åŒ–è°ƒç”¨æœåŠ¡è®¿é—®è·¯å¾„ï¼Œå¦‚: http://10.1.31.48:80/org.apache.dubbo.demo.DemoService/generic if (isGeneric) &#123; key = key + \"/\" + GENERIC_KEY; &#125; // 6.1 è®¾ç½®æœåŠ¡è®¿é—®è·¯å¾„ï¼Œè®¾ç½®åˆ° jsonProxyFactoryBean ä¸­ jsonRpcProxyFactoryBean.setServiceUrl(key); // 6.2 è®¾ç½®æœåŠ¡æ¥å£ï¼Œè®¾ç½®åˆ° jsonProxyFactoryBean ä¸­ jsonRpcProxyFactoryBean.setServiceInterface(serviceType); // 6.3 æ‰§è¡ŒSpringçš„InitializingBeanæ–¹æ³•ï¼Œ åˆ›å»º JsonRpcHttpClient &amp; æ¥å£ä»£ç†å¯¹è±¡ jsonProxyFactoryBean.afterPropertiesSet(); // 7 è¿”å›æ¥å£çš„ä»£ç†å¯¹è±¡ï¼Œæ‹¦æˆªåŠŸèƒ½æ˜¯ MethodInterceptorï¼ŒåŸºäºaopallianceæä¾›AOPçš„æ‹¦æˆªå¤„ç†æœºåˆ¶ã€‚ // åœ¨æ‰§è¡Œæ¥å£çš„ç›®æ ‡æ–¹æ³•æ—¶ï¼Œä¼šè¿›è¡Œæ‹¦æˆªï¼Œæ‰§è¡Œ com.googlecode.jsonrpc4j.spring.JsonProxyFactoryBean.invoke æ–¹æ³•ï¼Œè¿›è€Œä½¿ç”¨ JsonRpcHttpClient è¿›è¡Œè¿œç¨‹è°ƒç”¨ return (T) jsonProxyFactoryBean.getObject(); &#125; åˆ›å»º JsonRpcHttpClient &amp; æ¥å£ä»£ç†å¯¹è±¡12345678910111213141516171819202122232425262728293031323334353637383940+--- public class JsonProxyFactoryBean extends UrlBasedRemoteAccessor implements MethodInterceptor, InitializingBean, FactoryBean&lt;Object&gt;, ApplicationContextAware @Override @SuppressWarnings(\"unchecked\") public void afterPropertiesSet() &#123; super.afterPropertiesSet(); // 1 åˆ›å»ºæ¥å£ä»£ç†å¯¹è±¡ï¼Œæ‹¦æˆªå¢å¼ºä½¿ç”¨ MethodInterceptor proxyObject = ProxyFactory.getProxy(getServiceInterface(), this); // find the ObjectMapper if (objectMapper == null &amp;&amp; applicationContext != null &amp;&amp; applicationContext.containsBean(\"objectMapper\")) &#123; objectMapper = (ObjectMapper) applicationContext.getBean(\"objectMapper\"); &#125; if (objectMapper == null &amp;&amp; applicationContext != null) &#123; try &#123; objectMapper = (ObjectMapper)BeanFactoryUtils .beanOfTypeIncludingAncestors(applicationContext, ObjectMapper.class); &#125; catch (Exception e) &#123; /* no-op */ &#125; &#125; if (objectMapper==null) &#123; objectMapper = new ObjectMapper(); &#125; // 2 åˆ›å»º JsonRpcHttpClient try &#123; jsonRpcHttpClient = new JsonRpcHttpClient(objectMapper, new URL(getServiceUrl()), extraHttpHeaders); jsonRpcHttpClient.setRequestListener(requestListener); jsonRpcHttpClient.setSslContext(sslContext); jsonRpcHttpClient.setHostNameVerifier(hostNameVerifier); &#125; catch (MalformedURLException mue) &#123; throw new RuntimeException(mue); &#125; &#125; æ‹¦æˆªå¢å¼º123456789101112131415161718192021222324252627282930313233+--- public class JsonProxyFactoryBean extends UrlBasedRemoteAccessor implements MethodInterceptor, InitializingBean, FactoryBean&lt;Object&gt;, ApplicationContextAware /** * &#123;@inheritDoc&#125; */ public Object invoke(MethodInvocation invocation) throws Throwable &#123; // 1 handle toString() Method method = invocation.getMethod(); if (method.getDeclaringClass() == Object.class &amp;&amp; method.getName().equals(\"toString\")) &#123; return proxyObject.getClass().getName() + \"@\" + System.identityHashCode(proxyObject); &#125; // 2 get return type Type retType = (invocation.getMethod().getGenericReturnType() != null) ? invocation.getMethod().getGenericReturnType() : invocation.getMethod().getReturnType(); // 3 get arguments Object arguments = ReflectionUtil.parseArguments( invocation.getMethod(), invocation.getArguments(), useNamedParams); // 4 invoke it return jsonRpcHttpClient.invoke( invocation.getMethod().getName(), arguments, retType, extraHttpHeaders); &#125; ä»¥åˆ‡é¢çš„æ–¹å¼å¯¹ç›®æ ‡æ–¹æ³•è¿›è¡Œæ‹¦æˆªï¼Œè¿›è€Œä½¿ç”¨ JsonRpcHttpClient è°ƒç”¨è¿œç¨‹æœåŠ¡æ–¹æ³•ã€‚ é”€æ¯12345678910111213141516171819+--- HttpProtocol @Override public void destroy() &#123; super.destroy(); // å…³é—­æœåŠ¡ for (String key : new ArrayList&lt;&gt;(serverMap.keySet())) &#123; ProtocolServer server = serverMap.remove(key); if (server != null) &#123; try &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Close jsonrpc server \" + server.getUrl()); &#125; server.close(); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125; &#125; å…¶å®ƒHTTP ç»‘å®šå™¨ã€HTTP è°ƒåº¦å™¨ã€HTTP æœåŠ¡å™¨ å’Œ Dubbo 2.6.x ä¸­çš„ä¸€è‡´ã€‚ HTTP æŠ¥æ–‡ä¿¡æ¯ ä» Dubbo 2.7.x ä¸­çš„ HTTP æŠ¥æ–‡ä½“çš„ç»„ç»‡å’Œåºåˆ—åŒ–æ–¹å¼å¯ä»¥çœ‹å‡ºï¼Œç›¸æ¯” Spring çš„ HttpInvoker ï¼Œä½¿ç”¨ JSON-RPC åè®®æ›´åŠ é€‚åˆè·¨è¯­è¨€è°ƒç”¨ï¼Œæ›´é€‚åˆæˆ´ä¸Š http åè®®çš„å¸½å­ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« ä»‹ç»äº† Dubbo ä¸åŒç‰ˆæœ¬ä¸­ HTTPåè®®çš„å®ç°ï¼Œä»åè®®åæ¥çœ‹è¿™æ˜¯æ”¯æŒé€šç”¨è°ƒç”¨çš„åè®®ï¼Œä½†æ˜¯çœŸæ­£åœ°å®ç°å¹¶éå¦‚æ­¤ã€‚åŸºäº HTTTP è¡¨å•çš„è¿œç¨‹è°ƒç”¨åè®®é‡‡ç”¨äº† Spring çš„ HttpInvoker å®ç°ï¼Œåºåˆ—åŒ–ä½¿ç”¨ Java è¯­è¨€çš„åºåˆ—åŒ–æŠ€æœ¯ï¼Œè¿œç¨‹è°ƒç”¨é€»è¾‘ç”± Spring å°è£…ï¼Œè¿™æ˜¾ç„¶å¤±å»äº†è·¨è¯­è¨€çš„èƒ½åŠ›ã€‚ä¸ºäº†å®ç°è·¨è¯­è¨€è°ƒç”¨ï¼ŒDubbo è½¬è€Œä½¿ç”¨ HTTPåè®® + JSON-RPC çš„æ–¹æ¡ˆï¼Œè¿™ä¾èµ– HTTP åè®® å’Œ JSON éƒ½æ˜¯è·¨è¯­è¨€çš„æ ‡å‡†ï¼Œå‡ ä¹åœ¨å„ç§è¯­è¨€ä¸­éƒ½æœ‰æˆç†Ÿçš„ç±»åº“ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Protocol","slug":"Protocol","permalink":"https://gentryhuang.com/tags/Protocol/"}]},{"title":"Dubboæºç åˆ†æ - Dubboåè®®","slug":"rpc/Dubboåè®®","date":"2020-08-29T16:00:00.000Z","updated":"2021-03-11T14:49:25.093Z","comments":false,"path":"posts/a064181a/","link":"","permalink":"https://gentryhuang.com/posts/a064181a/","excerpt":"","text":"å‰è¨€åœ¨ å¤šåè®®æ¦‚è§ˆ ä¸­ï¼Œæˆ‘ä»¬å¯¹ Dubbo çš„åè®®çš„ä¸¤å¤§åˆ†æ”¯ä»æŠ½è±¡å±‚é¢è¿›è¡Œäº†ä»‹ç»ï¼Œæœ¬ç¯‡æ–‡ç« å°†å¯¹ Dubbo åè®®è¿›è¡Œè¯¦ç»†åˆ†æã€‚ æ¦‚è¿°Dubbo æ¡†æ¶ç¼ºçœåè®®å°±æ˜¯ Dubbo åè®®ï¼Œè¯¥åè®®é‡‡ç”¨å•ä¸€é•¿è¿æ¥å’Œ NIO å¼‚æ­¥é€šè®¯ï¼Œé€‚åˆäºå°æ•°æ®é‡å¤§å¹¶å‘çš„æœåŠ¡è°ƒç”¨ï¼Œä»¥åŠæœåŠ¡æ¶ˆè´¹è€…æœºå™¨æ•°è¿œå¤§äºæœåŠ¡æä¾›è€…æœºå™¨æ•°çš„æƒ…å†µã€‚Dubbo åè®®è°ƒç”¨ç®€åŒ–å›¾å¦‚ä¸‹ï¼š Transporter: mina, netty, grizzy Serialization: dubbo, hessian2, java, json Dispatcher: all, direct, message, execution, connection ThreadPool: fixed, cached,limited,eager ç‰¹æ€§ è¿æ¥ä¸ªæ•°ï¼šå•ä¸€è¿æ¥è¿æ¥æ–¹å¼ï¼šé•¿è¿æ¥ä¼ è¾“åè®®ï¼šTCPä¼ è¾“æ–¹å¼ï¼šNIO å¼‚æ­¥ä¼ è¾“åºåˆ—åŒ–ï¼šé»˜è®¤é‡‡ç”¨ Hessian äºŒè¿›åˆ¶åºåˆ—åŒ–é€‚ç”¨èŒƒå›´ï¼šä¼ å…¥ä¼ å‡ºå‚æ•°æ•°æ®åŒ…è¾ƒå°ï¼ˆå»ºè®®å°äº100Kï¼‰ï¼Œæ¶ˆè´¹è€…æ¯”æä¾›è€…ä¸ªæ•°å¤šï¼Œå•ä¸€æ¶ˆè´¹è€…æ— æ³•å‹æ»¡æä¾›è€…ï¼Œå°½é‡ä¸è¦ç”¨ dubbo åè®®ä¼ è¾“å¤§æ–‡ä»¶æˆ–è¶…å¤§å­—ç¬¦ä¸²ã€‚ é—®é¢˜ ä¸ºä»€ä¹ˆè¦æ¶ˆè´¹è€…æ¯”æä¾›è€…ä¸ªæ•°å¤šï¼Ÿ å› ä¸º Dubbo åè®®é‡‡ç”¨å•ä¸€é•¿è¿æ¥ï¼Œæ¯æ¡è¿æ¥æ•°æ®å‹ç½‘å¡çš„å­—èŠ‚æ•°æ®é‡æ˜¯ä¸€å®šçš„ï¼Œç†è®ºä¸Šä¸€ä¸ªæœåŠ¡æä¾›è€…éœ€è¦å¤šä¸ªæœåŠ¡æ¶ˆè´¹è€…æ‰èƒ½å‹æ»¡ç½‘å¡ã€‚ ä¸ºä»€ä¹ˆä¸èƒ½ä¼ å¤§åŒ…ï¼Ÿ å› ä¸º Dubbo åè®®é‡‡ç”¨å•ä¸€é•¿è¿æ¥ï¼Œå¦‚æœæ¯æ¬¡è¯·æ±‚çš„æ•°æ®åŒ…å¤ªå¤§ï¼Œå•ä¸ªæœåŠ¡æä¾›è€…çš„ TPS ä¼šé™ä½ï¼Œå› ä¸ºç½‘ç»œå¸¦å®½æ˜¯ä¸€å®šçš„ã€‚æ­¤å¤–ï¼Œå•ä¸ªæ¶ˆè´¹è€…è°ƒç”¨å•ä¸ªæœåŠ¡æä¾›è€…çš„ TPS ä¹Ÿä¼šéšç€è¯·æ±‚åŒ…å˜å¤§è€Œé™ä½ã€‚ ä¸ºä»€ä¹ˆé‡‡ç”¨å¼‚æ­¥å•ä¸€é•¿è¿æ¥ï¼Ÿ é€šè¿‡å•ä¸€è¿æ¥ä¿è¯å•ä¸€æ¶ˆè´¹è€…ä¸ä¼šå‹å®æä¾›è€…ï¼›é•¿è¿æ¥å‡å°‘è¿æ¥æ¡æ‰‹éªŒè¯ç­‰ï¼›ä½¿ç”¨å¼‚æ­¥ IO å¤ç”¨çº¿ç¨‹æ± ï¼Œé˜²æ­¢ C10K é—®é¢˜ã€‚ Dubbo åè®® QAä¸ä½¿ç”¨ HTTP çš„åŸå› : åœ¨è®¾è®¡ RPC çš„æ—¶å€™ï¼Œä¸ºäº†é«˜æ€§èƒ½å’Œååé‡ï¼ŒåŸºäº TCP æ€§èƒ½æ›´å¿«ã€‚ ä¸€èˆ¬ RPC ä¸ºäº†ååé‡ï¼Œä¼šå¼‚æ­¥å‘é€è¯·æ±‚ï¼Œç­‰å¾…å“åº”ï¼Œæ‰€ä»¥éœ€è¦çŸ¥é“å“ªä¸ªåº”ç­”å¯¹åº”å“ªä¸ªè¯·æ±‚ï¼Œè€Œ HTTP å±äºæ— çŠ¶æ€åè®®ï¼Œæ— æ³•å®ç°è¯·æ±‚è·Ÿå“åº”å…³è”ã€‚ ç‰ˆæœ¬ä¸æ˜¯å¾ˆä½çš„ HTTP éƒ½æ”¯æŒ Keep-Alive é“¾æ¥ï¼Œå¯ä»¥é¿å…äº†é“¾æ¥é‡å¤åˆ›å»ºå¼€é”€ï¼Œä¹Ÿèƒ½æ”¯æŒé•¿è¿æ¥ï¼Œä½†æ˜¯ç›®å‰åº”ç”¨ HTTP æ›´å¤šæ˜¯ä½¿ç”¨çŸ­è¿æ¥ã€‚ Dubbo åè®®ç°å­˜é—®é¢˜: Dubbo åè®®æ˜¯ç›´æ¥å®šä¹‰åœ¨ TCP ä¼ è¾“å±‚åè®®ä¹‹ä¸Šï¼Œç”±äº TCP é«˜å¯é å…¨åŒå·¥çš„ç‰¹ç‚¹ï¼Œä¸º Dubbo åè®®çš„å®šä¹‰æä¾›äº†æœ€å¤§çš„çµæ´»æ€§ï¼Œä½†åŒæ—¶ä¹Ÿæ­£æ˜¯å› ä¸ºè¿™æ ·çš„çµæ´»æ€§ï¼ŒRPC åè®®æ™®ééƒ½æ˜¯å®šåˆ¶åŒ–çš„ç§æœ‰åè®®ï¼ŒDubbo åŒæ ·ä¹Ÿé¢ä¸´è¿™ä¸ªé—®é¢˜ã€‚ ç›¸æ¯”äºç›´æ¥æ„å»ºä¸ TPC ä¼ è¾“å±‚çš„ç§æœ‰ RPC åè®®ï¼Œæ„å»ºäº HTTP ä¹‹ä¸Šçš„è¿œç¨‹è°ƒç”¨è§£å†³æ–¹æ¡ˆä¼šæœ‰æ›´å¥½çš„é€šç”¨æ€§ï¼Œå¦‚ WebServices æˆ– REST æ¶æ„ï¼Œä½¿ç”¨ HTTP + JSON å¯ä»¥è¯´æ˜¯ä¸€ä¸ªäº‹å®æ ‡å‡†çš„è§£å†³æ–¹æ¡ˆã€‚ä¹‹æ‰€ä»¥é€‰æ‹©æ„å»ºåœ¨ HTTP ä¹‹ä¸Šï¼Œæœ‰ä¸¤å¤§çš„ä¼˜åŠ¿ï¼š HTTP çš„è¯­ä¹‰å’Œå¯æ‰©å±•æ€§èƒ½å¾ˆå¥½çš„æ»¡è¶³ RPC è°ƒç”¨éœ€æ±‚ã€‚ - æ‰©å±•æ€§ é€šç”¨æ€§ï¼ŒHTTP åè®®å‡ ä¹è¢«ç½‘ç»œä¸Šçš„æ‰€æœ‰è®¾å¤‡æ‰€æ”¯æŒï¼Œå…·æœ‰å¾ˆå¥½çš„åè®®ç©¿é€æ€§ã€‚- é€šç”¨æ€§ ä¼˜åŒ–ç‚¹ï¼š Dubbo åè®®ä½“ Body ä¸­æœ‰ä¸€ä¸ªå¯æ‰©å±•çš„ attachments éƒ¨åˆ†ï¼Œè¿™ç»™ RPC æ–¹æ³•ä¹‹å¤–é¢å¤–ä¼ é€’é™„åŠ å±æ€§æä¾›äº†å¯èƒ½ï¼Œæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è®¾è®¡ã€‚ä½†æ˜¯ç±»ä¼¼çš„ Header éƒ¨åˆ†ï¼Œå´ç¼ºå°‘ç±»ä¼¼çš„å¯æ‰©å±• attachmentsï¼Œè¿™ç‚¹å¯å‚è€ƒ HTTP å®šä¹‰çš„ Ascii Header è®¾è®¡ï¼Œå°† Body Attachments å’Œ Header Attachments åšèŒè´£åˆ’åˆ†ã€‚ Body åè®®ä½“ä¸­çš„ä¸€äº› RPC è¯·æ±‚å®šä½ç¬¦å¦‚ Service Nameã€Method Nameã€Version ç­‰ï¼Œå¯ä»¥æåˆ° Header ä¸­ï¼Œå’Œå…·ä½“çš„åºåˆ—åŒ–åè®®è§£è€¦ï¼Œä»¥æ›´å¥½çš„è¢«ç½‘ç»œåŸºç¡€è®¾æ–½è¯†åˆ«æˆ–ç”¨äºæµé‡ç®¡æ§ã€‚ æ‰©å±•æ€§ä¸å¤Ÿå¥½ï¼Œæ¬ ç¼ºåè®®å‡çº§æ–¹é¢çš„è®¾è®¡ï¼Œå¦‚ Header å¤´ä¸­æ²¡æœ‰é¢„ç•™çš„çŠ¶æ€æ ‡è¯†ä½ï¼Œæˆ–è€…åƒ HTTP æœ‰ä¸“ä¸ºåè®®å‡çº§æˆ–åå•†è®¾è®¡çš„ç‰¹æ®Š packetã€‚åè®®å¤´è¦æ”¯æŒå¯æ‰©å±•ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªæ‰©å±•å­—æ®µç”¨äºå­˜æ”¾æ‰©å±•ä¿¡æ¯ï¼Œæ‰©å±•åçš„åè®®å¤´çš„é•¿åº¦å°±ä¸èƒ½å›ºå®šäº†ï¼Œå¯ä»¥åœ¨åè®®å¤´ä¸­åŠ å…¥ä¸€ä¸ªæ ‡è¯†å¤´é•¿åº¦çš„å­—æ®µã€‚ Dubbo åè®®è®¾è®¡ä¸Šæ²¡æœ‰è¶³å¤Ÿçš„å‰ç»æ€§ï¼Œä½†å‘¨è¾¹ä¹Ÿæœ‰ä¸å°‘é…ä»¶ç»„ä»¶ï¼Œå¦‚ dubbo2.jsã€dubbo-goã€dubbo-cpp ç­‰ï¼Œåœ¨ä¸€å®šç¨‹åº¦ä¸Šè§£å†³äº†å¤šè¯­è¨€é—®é¢˜ã€‚å…³äº Dubbo åè®®å…·ä½“å¯ä»¥å‚è€ƒ ç¼–è§£ç å™¨ ä¸­çš„ä»‹ç»ã€‚ DubboProtocolå±æ€§1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class DubboProtocol extends AbstractProtocol &#123; /** * åè®®å */ public static final String NAME = \"dubbo\"; /** * åè®®é»˜è®¤ç«¯å£ */ public static final int DEFAULT_PORT = 20880; /** * å‚æ•°å›è°ƒç”¨ç›¸å…³å­—æ®µ */ private static final String IS_CALLBACK_SERVICE_INVOKE = \"_isCallBackServiceInvoke\"; /** * DubboProtocol */ private static DubboProtocol INSTANCE; /** * é€šä¿¡æœåŠ¡é›†åˆ * key: æœåŠ¡å™¨åœ°å€ã€‚æ ¼å¼ï¼šhost:port * value: ExchangeServer ä¿¡æ¯äº¤æ¢æœåŠ¡æ¥å£ */ private final Map&lt;String, ExchangeServer&gt; serverMap = new ConcurrentHashMap&lt;String, ExchangeServer&gt;(); /** * é€šä¿¡è¿æ¥é›†åˆ * key: æœåŠ¡å™¨åœ°å€ æ ¼å¼ï¼šhost:port * value: å®¢æˆ·ç«¯ */ private final Map&lt;String, ReferenceCountExchangeClient&gt; referenceClientMap = new ConcurrentHashMap&lt;String, ReferenceCountExchangeClient&gt;(); /** * é€šä¿¡è¿æ¥é›†åˆ - å»¶è¿Ÿè¿æ¥çš„åˆ›å»º * key: æœåŠ¡å™¨åœ°å€ æ ¼å¼:host:port * value: å®¢æˆ·ç«¯ */ private final ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap = new ConcurrentHashMap&lt;String, LazyConnectExchangeClient&gt;(); /** * ç”¨äºjvm é”é›†åˆ */ private final ConcurrentMap&lt;String, Object&gt; locks = new ConcurrentHashMap&lt;String, Object&gt;(); /** * å·²åˆå§‹åŒ–çš„ SerializationOptimizer å®ç°ç±»åçš„é›†åˆ * ç”¨äºåºåˆ—åŒ–ä¼˜åŒ– */ private final Set&lt;String&gt; optimizers = new ConcurrentHashSet&lt;String&gt;(); //consumer side export a stub service for dispatching event å’Œæœ¬åœ°å­˜æ ¹ç›¸å…³ private final ConcurrentMap&lt;String, String&gt; stubServiceMethodsMap = new ConcurrentHashMap&lt;String, String&gt;(); public DubboProtocol() &#123; INSTANCE = this; &#125; public static DubboProtocol getDubboProtocol() &#123; if (INSTANCE == null) &#123; // dubbo SPI è·å– DubboProtocl ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(DubboProtocol.NAME); &#125; return INSTANCE; &#125;&#125; DubboProtocolä¸­çš„å±æ€§åŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªæ–¹é¢çš„ä¿¡æ¯ï¼š Dubbo åè®®çš„é»˜è®¤ç«¯å£ã€Protocol æ‰©å±•å®ç° Dubbo åè®®ä¸‹çš„æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ç¼“å­˜ åºåˆ—åŒ–ä¼˜åŒ–å™¨å®ç° æœåŠ¡æš´éœ²1234567891011121314151617181920212223242526272829303132333435+--- DubboProtocol @Override public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; // 1 è·å–URL URL url = invoker.getUrl(); //2 æœåŠ¡æš´éœ² //2.1 è·å–æœåŠ¡é”®,å¦‚ï¼šdemoGroup/com.alibaba.dubbo.demo.DemoService:1.0.0:20880 String key = serviceKey(url); //2.2 å°†ä¸Šå±‚ä¼ å…¥çš„ Invoker å¯¹è±¡å°è£…æˆ DubboExporter å¯¹è±¡ DubboExporter&lt;T&gt; exporter = new DubboExporter&lt;T&gt;(invoker, key, exporterMap); //2.3 ç¼“å­˜ DubboExporter åˆ°çˆ¶ç±»AbstractProtocol Mapç¼“å­˜ä¸­,ç›¸åŒåˆ™è¦†ç›– exporterMap.put(key, exporter); //export an stub service for dispatching event å’Œæœ¬åœ°å­˜æ ¹æœ‰å…³ Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT); // å‚æ•°å›è°ƒç›¸å…³ Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false); if (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123; String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY); if (stubServiceMethods == null || stubServiceMethods.length() == 0) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(new IllegalStateException(\"consumer [\" + url.getParameter(Constants.INTERFACE_KEY) + \"], has set stubproxy support event ,but no stub methods founded.\")); &#125; &#125; else &#123; stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods); &#125; &#125; // 3 å¯åŠ¨æœåŠ¡å™¨ openServer(url); // 4 ä¼˜åŒ–åºåˆ—åŒ– optimizeSerialization(url); // 5 å°† Invoker ä»¥ Exporter å½¢å¼æš´éœ²å‡ºå» return exporter; &#125; DubboProtcol ç›´æ¥å®ç°äº† Protocol çš„æœåŠ¡æš´éœ²æ¥å£ï¼Œå› ä¸º AbstractProtocol å¹¶æ²¡æœ‰å¯¹æœåŠ¡æš´éœ²æ¥å£è¿›è¡Œå®ç°ã€‚Dubbo åè®®ä¸‹çš„æœåŠ¡æš´éœ²æ ¸å¿ƒå°±ä¸¤ç‚¹ï¼Œå°†å…·æœ‰æœåŠ¡èƒ½åŠ›çš„ Invoker å°è£…æˆ DubboExporterï¼Œæ¥ç€å¯åŠ¨ NIOæœåŠ¡å™¨ ç”¨äºæ¥æ”¶è¯·æ±‚ã€‚ ä¸‹é¢åˆ†åˆ«å¯¹å¯åŠ¨æœåŠ¡å’Œä¼˜åŒ–åºåˆ—åŒ–éƒ¨åˆ†è¯¦ç»†åˆ†æã€‚ å¯åŠ¨NIOæœåŠ¡1234567891011121314151617181920212223+--- DubboProtocol private void openServer(URL url) &#123; // è·å– host:portï¼Œå¹¶å°†å…¶ä½œä¸ºæœåŠ¡å™¨å®ä¾‹ç¼“å­˜ keyï¼Œç”¨äºæ ‡è¯†å½“å‰çš„æœåŠ¡èµ·å®ä¾‹ String key = url.getAddress(); // å‚æ•°é…ç½®é¡¹ isserverï¼Œåªæœ‰Serverç«¯æ‰èƒ½å¯åŠ¨Serverå¯¹è±¡ boolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true); // åªæœ‰Serverç«¯æ‰èƒ½å¯åŠ¨Serverå¯¹è±¡ if (isServer) &#123; // ä»serverMapç¼“å­˜ä¸­è·å–æœåŠ¡å™¨ ExchangeServer server = serverMap.get(key); // æ—  Serverç›‘å¬è¯¥åœ°å€ if (server == null) &#123; // ä¸å­˜åœ¨åˆ™åˆ›å»º Server serverMap.put(key, createServer(url)); &#125; else &#123; // å¦‚æœå·²æœ‰ Server å®ä¾‹ï¼Œåˆ™å°è¯•æ ¹æ®URLä¿¡æ¯é‡ç½® Server // com.alibaba.dubbo.remoting.transport.AbstractServer.reset server.reset(url); &#125; &#125; &#125; åˆ›å»ºå¹¶å¯åŠ¨æœåŠ¡æ˜¯ä»¥ Dubbo çš„ä¸»æœºç»‘å®šç»“æœ host:port è¿›è¡Œçš„ï¼Œå¹¶ä¸”åŒä¸€å°æœåŠ¡å™¨åŒä¸€ä¸ªç«¯å£ä¸Šä»…å…è®¸å¯åŠ¨ä¸€ä¸ªæœåŠ¡å™¨å®ä¾‹ï¼Œè‹¥æŸä¸ªç«¯å£ä¸Šå·²æœ‰æœåŠ¡å™¨å®ä¾‹ï¼Œæ­¤æ—¶resetæ–¹æ³•å°±ä¼šè°ƒç”¨ï¼Œé‡ç½®æœåŠ¡å™¨çš„ä¸€äº›é…ç½®ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839+--- DubboProtocol private ExchangeServer createServer(URL url) &#123; // 1 é»˜è®¤å¼€å¯ åœ¨ Server å…³é—­çš„æ—¶å€™ï¼Œåªèƒ½å‘é€ ReadOnly è¯·æ±‚ url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString()); // 2 é»˜è®¤å¼€å¯ å¿ƒè·³ ã€heartbeatå‚æ•°ä¼šåœ¨HeaderExchangeServerå¯åŠ¨å¿ƒè·³è®¡æ—¶å™¨ä½¿ç”¨ã€‘,é»˜è®¤å€¼ä¸º 60000ï¼Œè¡¨ç¤ºé»˜è®¤çš„å¿ƒè·³æ—¶é—´é—´éš”ä¸º 60 ç§’ url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT)); // 3 æ£€æµ‹SERVER_KEYå‚æ•°æŒ‡å®šçš„Transporteræ‰©å±•å®ç°æ˜¯å¦åˆæ³•, å³Dubbo SPIæ‰©å±•æ˜¯å¦å­˜åœ¨ï¼Œé»˜è®¤æ˜¯Netty String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER); if (str != null &amp;&amp; str.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123; throw new RpcException(\"Unsupported server type: \" + str + \", url: \" + url); &#125; // 4 è®¾ç½®ç¼–ç è§£ç å™¨å‚æ•° ï¼Œé»˜è®¤ä¸º DubboCountCodec url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME); // 5 åˆ›å»ºã€å¯åŠ¨æœåŠ¡å™¨ ExchangeServer server; try &#123; // 5.1 é€šè¿‡Exchangersé—¨é¢ç±»ï¼Œåˆ›å»ºExchangeServerå¯¹è±¡ã€‚ // éœ€è¦ä¼ å…¥ ExchangeHandler å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ç”¨äºå¤„ç†é€šé“ç›¸å…³äº‹ä»¶ server = Exchangers.bind(url, requestHandler); &#125; catch (RemotingException e) &#123; throw new RpcException(\"Fail to start server(url: \" + url + \") \" + e.getMessage(), e); &#125; // 6 æ ¡éªŒClient çš„ Dubbo SPIæ‹“å±•æ˜¯å¦å­˜åœ¨ã€‚å¯æŒ‡å®šnetty,mina str = url.getParameter(Constants.CLIENT_KEY); if (str != null &amp;&amp; str.length() &gt; 0) &#123; // è·å–æ‰€æœ‰çš„Transporter å®ç°ç±»åç§°é›†åˆï¼Œæ¯”å¦‚ netty,mina Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(); // æ£€æµ‹å½“å‰Dubbo æ‰€æ”¯æŒçš„Transporterå®ç°ç±»åç§°åˆ—è¡¨ä¸­æ˜¯å¦åŒ…å«clientæ‰€è¡¨ç¤ºçš„ Transporter ï¼Œè‹¥ä¸åŒ…å«åˆ™æŠ›å‡ºå¼‚å¸¸ if (!supportedTypes.contains(str)) &#123; throw new RpcException(\"Unsupported client type: \" + str); &#125; &#125; return server; &#125; DubboProtol åœ¨åˆ›å»ºå¹¶å¯åŠ¨ NIOæœåŠ¡å™¨ ä¹‹å‰ï¼Œä¼šä¸º URL æ·»åŠ åŠŸèƒ½å‚æ•°ï¼š 1 channel.readonly.sent: å¼€å¯ åœ¨ Server å…³é—­çš„æ—¶å€™åªèƒ½å‘é€ ReadOnly è¯·æ±‚2 heartbeat: å¼€å¯å¿ƒè·³ï¼Œé»˜è®¤å€¼ä¸º 60000 ï¼Œè¡¨ç¤ºé»˜è®¤çš„å¿ƒè·³æ—¶é—´é—´éš”ä¸º 60 s3 codec: è®¾ç½®ç¼–è§£ç å™¨ï¼Œé»˜è®¤ä¸º DubboCountCodec åŠŸèƒ½å‚æ•°è®¾ç½®å®Œæ¯•åï¼Œé€šè¿‡ä¿¡æ¯äº¤æ¢å±‚çš„ Exchangers é—¨é¢ç±»åˆ›å»º ExchangeServer å¯¹è±¡ï¼Œå¹¶ä¼ å…¥é€šé“å¤„ç†å™¨ ExchangeHandler å¯¹è±¡ã€‚å…³äºä¿¡æ¯äº¤æ¢å±‚çš„ä»‹ç»å¯ä»¥å‚è€ƒ ä¿¡æ¯äº¤æ¢å±‚ ä¸€æ–‡ã€‚ä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹ DubboProtocol çš„é€šé“å¤„ç†å™¨å®ç°ã€‚ é€šé“å¤„ç†å™¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149+--- DubboProtocol private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() &#123; /** * å¤„ç†æœåŠ¡æ¶ˆè´¹è€…çš„ åŒæ­¥è°ƒç”¨å’Œå¼‚æ­¥è°ƒç”¨çš„è¯·æ±‚ * * @param channel * @param message * @return * @throws RemotingException */ @Override public Object reply(ExchangeChannel channel, Object message) throws RemotingException &#123; // åˆ¤æ–­æ¶ˆæ¯ç±»å‹ã€‚å…¶å®ï¼Œç»è¿‡å‰é¢çš„ Hander å¤„ç†åè¿™é‡Œæ”¶åˆ°çš„ Message å¿…é¡»æ˜¯ Invocation ç±»å‹çš„å¯¹è±¡ if (message instanceof Invocation) &#123; Invocation inv = (Invocation) message; /** * è·å–æ­¤æ¬¡è°ƒç”¨çš„Invokerï¼š * 1 å…ˆè·å– Exporter ï¼ˆåœ¨æœåŠ¡æš´éœ²æ—¶å°±å·²ç»åˆå§‹åŒ–å¥½äº†ï¼‰ * 2 ä» exporter ä¸­è·å– Invoker */ Invoker&lt;?&gt; invoker = getInvoker(channel, inv); /** * å¦‚æœæ˜¯å‚æ•°å›è°ƒï¼š * 1 éœ€è¦å¤„ç†é«˜ç‰ˆæœ¬è°ƒç”¨ä½ç‰ˆæœ¬çš„é—®é¢˜ * 2 æ ¡éªŒæœåŠ¡æ¶ˆè´¹è€…å®é™…å­˜åœ¨å¯¹åº”çš„å›è°ƒæ–¹æ³•ï¼Œé€šè¿‡æ–¹æ³•ååˆ¤æ–­ */ if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123; String methodsStr = invoker.getUrl().getParameters().get(\"methods\"); boolean hasMethod = false; if (methodsStr == null || methodsStr.indexOf(\",\") == -1) &#123; hasMethod = inv.getMethodName().equals(methodsStr); &#125; else &#123; String[] methods = methodsStr.split(\",\"); for (String method : methods) &#123; if (inv.getMethodName().equals(method)) &#123; hasMethod = true; break; &#125; &#125; &#125; if (!hasMethod) &#123; logger.warn(new IllegalStateException(\"The methodName \" + inv.getMethodName() + \" not found in callback service interface ,invoke will be ignored.\" + \" please update the api interface. url is:\" + invoker.getUrl()) + \" ,invocation is :\" + inv); return null; &#125; &#125; // è®¾ç½®è°ƒç”¨æ–¹çš„åœ°å€ï¼Œå³å°†æ¶ˆè´¹æ–¹åœ°å€è®°å½•åˆ° RpcContext ä¸­ RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress()); /** * æ‰§è¡Œè°ƒç”¨ * 1 æ‰§è¡Œ Filteré“¾ ï¼šEchoFilter-&gt;ClassLoaderFilter-&gt;GenericFilter-&gt;ContextFilter-&gt;TraceFilter-&gt;TimeoutFilter-&gt;MonitorFilter-&gt;ExceptionFilter -&gt; Invokeré€»è¾‘ * 2 ç„¶åæ‰§è¡ŒçœŸæ­£çš„Invokerçš„è°ƒç”¨é€»è¾‘ï¼šAbstractProxyInvoker.invoke -&gt; JavassistProxyFactory$AbstractProxyInvoker.doInvoke -&gt; Wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments) -&gt; ref.xxxYYYæ–¹æ³• */ return invoker.invoke(inv); &#125; throw new RemotingException(channel, \"Unsupported request: \" + (message == null ? null : (message.getClass().getName() + \": \" + message)) + \", channel: consumer: \" + channel.getRemoteAddress() + \" --&gt; provider: \" + channel.getLocalAddress()); &#125; /** *å¤„ç†è¯»å–åˆ°çš„æ•°æ® * * @param channel * @param message * @throws RemotingException */ @Override public void received(Channel channel, Object message) throws RemotingException &#123; // åˆ¤æ–­æ¶ˆæ¯ç±»å‹æ˜¯ä¸æ˜¯ Invocation if (message instanceof Invocation) &#123; reply((ExchangeChannel) channel, message); &#125; else &#123; super.received(channel, message); &#125; &#125; //---------------- ä»¥ä¸‹æ˜¯å¯¹è®¾ç½®çš„ onconnect å’Œ ondisconnect æ–¹æ³•çš„å¤„ç† -----------------/ /** * åœ¨æœåŠ¡æä¾›è€…ä¸Šå¯ä»¥é…ç½® onconnect é…ç½®é¡¹æŒ‡å®šè¿æ¥ä¸ŠæœåŠ¡æ—¶ä¼šè°ƒç”¨çš„æ–¹æ³• - ä¸æ˜¯å¾ˆé‡è¦ * @param channel * @throws RemotingException */ @Override public void connected(Channel channel) throws RemotingException &#123; invoke(channel, Constants.ON_CONNECT_KEY); &#125; /** * åœ¨æœåŠ¡æä¾›è€…ä¸Šå¯ä»¥é…ç½® 'ondisconnect' é…ç½®é¡¹æŒ‡å®šæ–¹æ³•ï¼Œåœ¨æœåŠ¡æä¾›è€…è¿æ¥æ–­å¼€æ—¶ä¼šè°ƒç”¨è¯¥æ–¹æ³• - ä¸æ˜¯å¾ˆé‡è¦ * * @param channel * @throws RemotingException */ @Override public void disconnected(Channel channel) throws RemotingException &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"disconnected from \" + channel.getRemoteAddress() + \",url:\" + channel.getUrl()); &#125; invoke(channel, Constants.ON_DISCONNECT_KEY); &#125; /** * è¿›è¡Œè°ƒç”¨ï¼Œæ‰§è¡Œå¯¹åº”çš„æ–¹æ³• * * @param channel é€šé“ * @param methodKey æ–¹æ³•å */ private void invoke(Channel channel, String methodKey) &#123; // åˆ›å»ºè°ƒç”¨ä¿¡æ¯ Invocation å¯¹è±¡ Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey); // å¦‚æœ invocation ä¸ä¸ºç©ºï¼Œæ‰§è¡Œreceivedæ–¹æ³• if (invocation != null) &#123; try &#123; received(channel, invocation); &#125; catch (Throwable t) &#123; logger.warn(\"Failed to invoke event method \" + invocation.getMethodName() + \"(), cause: \" + t.getMessage(), t); &#125; &#125; &#125; /** * åˆ›å»º Invocation * @param channel * @param url * @param methodKey * @return */ private Invocation createInvocation(Channel channel, URL url, String methodKey) &#123; String method = url.getParameter(methodKey); if (method == null || method.length() == 0) &#123; return null; &#125; RpcInvocation invocation = new RpcInvocation(method, new Class&lt;?&gt;[0], new Object[0]); invocation.setAttachment(Constants.PATH_KEY, url.getPath()); invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY)); invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY)); invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY)); if (url.getParameter(Constants.STUB_EVENT_KEY, false)) &#123; invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString()); &#125; return invocation; &#125; &#125;; DubboProtocol ä¸­å®ç°äº†ä¿¡æ¯äº¤æ¢å±‚ä¸­çš„ ExchangeHandlerAdapter é€šé“å¤„ç†å™¨é€»è¾‘ï¼ŒæœåŠ¡æ¶ˆè´¹è€…çš„è¿œç¨‹è°ƒç”¨æ˜¯é€šè¿‡ #reply æ–¹æ³•å¤„ç†çš„ï¼Œè¯¥æ–¹æ³•çš„æ ¸å¿ƒé€»è¾‘å¦‚ä¸‹ï¼š æ ¹æ®è¿æ¥ä¿¡æ¯å’Œè°ƒç”¨ä¿¡æ¯ç»„è£…æœåŠ¡å¥ï¼Œå¹¶æ ¹æ®æœåŠ¡å¥è·å–å…·æœ‰æœåŠ¡èƒ½åŠ›çš„ Invoker å¯¹è±¡ã€‚ å¦‚æœè®¾ç½®äº†å‚æ•°å›è°ƒç”¨ï¼Œåˆ™å¯¹å‚æ•°å›è°ƒé€»è¾‘è¿›è¡Œå¤„ç†ã€‚å…³äºå‚æ•°å›è°ƒå†…å®¹ä¼šåœ¨ Dubbo é«˜çº§ç‰¹æ€§ä¸­ä»‹ç»ã€‚ å°†è°ƒç”¨æ–¹çš„åœ°å€å³æ¶ˆè´¹ç«¯åœ°å€è®°å½•åˆ°ä¸Šä¸‹æ–‡ä¸­ã€‚ æ‰§è¡Œ Invoker.invoke ã€‚ ä¸‹é¢æˆ‘ä»¬ç»§ç»­åˆ†æè·å– Invoker å¯¹è±¡çš„æ–¹æ³•ã€‚ æœåŠ¡ç«¯ä¾§ Invoker1234567891011121314151617181920212223242526272829303132333435363738+--- DubboProtocol Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) throws RemotingException &#123; boolean isCallBackServiceInvoke = false; boolean isStubServiceInvoke = false; // è·å–ç«¯å£ int port = channel.getLocalAddress().getPort(); // ä»è°ƒç”¨ä¿¡æ¯ä¸­å›½è·å– path String path = inv.getAttachments().get(Constants.PATH_KEY); // å¯¹å®¢æˆ·ç«¯ Callback çš„å¤„ç† isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getAttachments().get(Constants.STUB_EVENT_KEY)); if (isStubServiceInvoke) &#123; // ä»Channelä¸­è·å– ç«¯å£ port port = channel.getRemoteAddress().getPort(); &#125; // å‚æ•°å›è°ƒå¤„ç†ï¼Œè·å¾—çœŸæ­£çš„æœåŠ¡å `path` isCallBackServiceInvoke = isClientSide(channel) &amp;&amp; !isStubServiceInvoke; if (isCallBackServiceInvoke) &#123; path = inv.getAttachments().get(Constants.PATH_KEY) + \".\" + inv.getAttachments().get(Constants.CALLBACK_SERVICE_KEY); inv.getAttachments().put(IS_CALLBACK_SERVICE_INVOKE, Boolean.TRUE.toString()); &#125; // è·å¾—æœåŠ¡é”®ï¼Œæ ¼å¼ï¼š group/path:version:port // æ ¹æ® Invocation æºå¸¦çš„ä¿¡æ¯ï¼šattachments ä¸­çš„pathã€groupã€versionä»¥åŠä»channelä¸­è·å–çš„port è®¡ç®—æœåŠ¡å¥ String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY)); // æ ¹æ®æœåŠ¡å¥æŸ¥æ‰¾ç¼“å­˜çš„ DubboExporter DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey); // æ²¡æœ‰å¯¹åº”çš„ Exporterï¼Œç›´æ¥æŠ›å‡ºå¼‚å¸¸ if (exporter == null) &#123; throw new RemotingException(channel, \"Not found exported service: \" + serviceKey + \" in \" + exporterMap.keySet() + \", may be version or group mismatch \" + \", channel: consumer: \" + channel.getRemoteAddress() + \" --&gt; provider: \" + channel.getLocalAddress() + \", message:\" + inv); &#125; // å–å‡ºExporterä¸­çš„Invoker å¯¹è±¡ return exporter.getInvoker(); &#125; è·å–æœåŠ¡ç«¯ä¾§ Invoker å°±æ˜¯æ ¹æ® æœåŠ¡é”® ä»ç¼“å­˜ä¸­å–å‡ºæœåŠ¡æš´éœ²æ—¶å­˜å‚¨åœ¨å†…å­˜ä¸­çš„ Expoter å¯¹è±¡ï¼Œè¿›è€Œä»è¯¥ Expoter ä¸­å–å‡ºå¯¹åº”çš„ Invoker å¯¹è±¡ã€‚æ³¨æ„ï¼ŒæœåŠ¡é”®çš„ groupã€pathã€verison éƒ½æ˜¯ä»è°ƒç”¨ä¿¡æ¯ä¸­è·å–çš„ï¼Œå› ä¸ºè°ƒç”¨æ–¹æ›´æ¸…æ¥šç›®æ ‡æœåŠ¡ï¼Œè€Œ port éƒ¨åˆ†åˆ™æ˜¯é€šè¿‡é€šé“è·å–çš„ï¼Œè°ƒç”¨æ–¹æ— éœ€å…³å¿ƒç«¯å£ï¼Œæä¾›æ–¹è‡ªå·±æ›´åŠ æ¸…æ¥šã€‚ ä¼˜åŒ–åºåˆ—åŒ–1234567891011121314151617181920212223242526272829303132333435363738394041424344private void optimizeSerialization(URL url) throws RpcException &#123; // è·å¾— optimizer åºåˆ—åŒ–ä¼˜åŒ–å™¨ é…ç½®é¡¹ String className = url.getParameter(Constants.OPTIMIZER_KEY, \"\"); // å¦‚æœç³»ç»Ÿä¸­æ²¡æœ‰æŒ‡å®šåºåˆ—åŒ–ä¼˜åŒ–å™¨å°±ç›´æ¥è¿”å› if (StringUtils.isEmpty(className) || optimizers.contains(className)) &#123; return; &#125; logger.info(\"Optimizing the serialization process for Kryo, FST, etc...\"); try &#123; // æ ¹æ® åºåˆ—åŒ–ä¼˜åŒ–å™¨å åŠ è½½ SerializationOptimizer å®ç°ç±» Class clazz = Thread.currentThread().getContextClassLoader().loadClass(className); // æ˜¯å¦æ˜¯ SerializationOptimizer.classï¼Œæˆ–è€… æ˜¯SerializationOptimizer çš„å­ç±» if (!SerializationOptimizer.class.isAssignableFrom(clazz)) &#123; throw new RpcException(\"The serialization optimizer \" + className + \" isn't an instance of \" + SerializationOptimizer.class.getName()); &#125; // åˆ›å»º SerializationOptimizer å¯¹è±¡ SerializationOptimizer optimizer = (SerializationOptimizer) clazz.newInstance(); // æ²¡æœ‰è¦ä¼˜åŒ–çš„ç±»ç›´æ¥è¿”å› if (optimizer.getSerializableClasses() == null) &#123; return; &#125; // å°†è¦ä¼˜åŒ–çš„ç±»æ³¨å†Œåˆ° SerializableClassRegistry ä¸­ // åœ¨ä½¿ç”¨ Kryo,FST ç­‰åºåˆ—åŒ–ç®—æ³•æ—¶ï¼Œä¼šè¯»å–è¯¥é›†åˆä¸­çš„ç±»ï¼Œå®Œæˆæ³¨å†Œ. for (Class c : optimizer.getSerializableClasses()) &#123; SerializableClassRegistry.registerClass(c); &#125; // å°† åºåˆ—åŒ–ä¼˜åŒ–å™¨å®ç°ç±»å åŠ å…¥åˆ°ç¼“å­˜ä¸­ optimizers.add(className); &#125; catch (ClassNotFoundException e) &#123; throw new RpcException(\"Cannot find the serialization optimizer class: \" + className, e); &#125; catch (InstantiationException e) &#123; throw new RpcException(\"Cannot instantiate the serialization optimizer class: \" + className, e); &#125; catch (IllegalAccessException e) &#123; throw new RpcException(\"Cannot instantiate the serialization optimizer class: \" + className, e); &#125; &#125; æœåŠ¡æš´éœ²æ—¶ä¼šè¿›è¡Œåºåˆ—åŒ–ä¼˜åŒ–ï¼Œé€šè¿‡è‡ªå®šä¹‰ SerializationOptimizer å¯¹è±¡å°†éœ€è¦ä¼˜åŒ–çš„ç±»å…¨éƒ¨åŠ å…¥åˆ°è¯¥å¯¹è±¡ä¸­å³å¯ã€‚å…³äºåºåˆ—åŒ–çš„ä»‹ç»å¯ä»¥å‚è€ƒ åºåˆ—åŒ–ä¼˜åŒ–å™¨ ä¸€æ–‡ã€‚ æœåŠ¡æš´éœ²æµç¨‹å›¾ Dubbo æ¡†æ¶é‡‡ç”¨ Dubbo åè®®è¿›è¡ŒæœåŠ¡å‘å¸ƒçš„æµç¨‹å¦‚ä¸Šå›¾æ‰€ç¤ºã€‚ä» Protocol åè®®å±‚ çš„ openServer æ–¹æ³•ä¼šä¸€è·¯è°ƒç”¨åˆ° Exchange ä¿¡æ¯äº¤æ¢å±‚ã€Transport ç½‘ç»œä¼ è¾“å±‚ï¼Œæœ€ç»ˆåˆ›å»ºå¹¶å¯åŠ¨ Netty æœåŠ¡ æ¥æ¥æ”¶å®¢æˆ·ç«¯çš„è¯·æ±‚ã€‚ é¢†åŸŸæ¨¡å‹DubboExpoter æ˜¯å¯¹æœåŠ¡ç«¯ä¾§çš„ Invoker çš„å°è£…ï¼ŒæœåŠ¡ç«¯ä¾§çš„ Invoker å†…éƒ¨å°è£…äº†å…·ä½“æœåŠ¡å®ç°ï¼Œå…·å¤‡æœåŠ¡èƒ½åŠ›ã€‚DubboExpoter ç»§æ‰¿äº† AbstractExpoter æŠ½è±¡ç±»ï¼Œå…·ä½“å®ç°å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637public class DubboExporter&lt;T&gt; extends AbstractExporter&lt;T&gt; &#123; /** * æœåŠ¡é”® */ private final String key; /** * Exporter é›†åˆ * key : æœåŠ¡é”® * value: DubboProtocol å‘å¸ƒçš„æœåŠ¡ */ private final Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap; /** * å°è£… Invoker * * @param invoker Invoker * @param key æœåŠ¡é”® * @param exporterMap AbstractProtocol.exporterMapå±æ€§ */ public DubboExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123; super(invoker); this.key = key; this.exporterMap = exporterMap; &#125; /** * å–æ¶ˆæš´éœ² */ @Override public void unexport() &#123; // å–æ¶ˆæš´éœ² super.unexport(); //æ¸…ç†è¯¥ DubboExporter å®ä¾‹åœ¨ exporterMap ä¸­ç›¸åº”çš„å…ƒç´  exporterMap.remove(key); &#125;&#125; æœåŠ¡å¼•ç”¨1234567891011121314+--- DubboProtocol @Override public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123; // 1 åˆå§‹åŒ–åºåˆ—åŒ–ä¼˜åŒ–å™¨ optimizeSerialization(url); // 2 åˆ›å»º DubboInvoker å¯¹è±¡ DubboInvoker&lt;T&gt; invoker = new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers); // 3 æ·»åŠ åˆ° invokers ç¼“å­˜ä¸­ invokers.add(invoker); return invoker; &#125; DubboProtocol ç›´æ¥å®ç°äº† Protocol çš„æœåŠ¡å¼•ç”¨æ¥å£ã€‚Dubbo åè®®ä¸‹çš„æœåŠ¡å¼•ç”¨æ ¸å¿ƒå°±ä¸€ä¸ªï¼Œåˆ›å»º DubboInvoker å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ä¼šå¯¹ Client è¿›è¡Œå°è£…ï¼Œç”¨äºå‘é€è¯·æ±‚å’Œæ¥æ”¶å“åº”ã€‚åˆå§‹åŒ–åºåŒ–ä¼˜åŒ–å™¨åŒæœåŠ¡æš´éœ²ä¸­çš„ä¸€è‡´ã€‚ è¿æ¥NIOæœåŠ¡å™¨getClients æ–¹æ³•åˆ›å»ºäº†åº•å±‚å‘é€è¯·æ±‚å’Œæ¥æ”¶å“åº”çš„ Client é›†åˆï¼Œå³åˆ›å»ºå®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯çš„é•¿è¿æ¥ã€‚å…¶æ ¸å¿ƒå®ç°åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯é’ˆå¯¹å…±äº«è¿æ¥çš„å¤„ç†ï¼Œå¦ä¸€ä¸ªæ˜¯é’ˆå¯¹ç‹¬äº«è¿æ¥çš„å¤„ç†ã€‚å®ç°é€»è¾‘å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930+--- DubboProtocolprivate ExchangeClient[] getClients(URL url) &#123; // æ˜¯å¦ä½¿ç”¨å…±äº«è¿æ¥ boolean service_share_connect = false; // è·å– connections é…ç½®é¡¹ï¼Œè¯¥å€¼å†³å®šäº†åç»­å»ºç«‹è¿æ¥çš„æ•°é‡ã€‚ä¸é…ç½®çš„æƒ…å†µä¸‹é»˜è®¤ä¸º0ï¼Œå¹¶ä½¿ç”¨å…±äº«è¿æ¥çš„æ–¹å¼ï¼Œå»ºç«‹ä¸€æ¡å…±äº«è¿æ¥ã€‚ int connections = url.getParameter(Constants.CONNECTIONS_KEY, 0); // å¦‚æœæ²¡æœ‰è¿æ¥æ•°çš„ç›¸å…³é…ç½®ï¼Œé»˜è®¤ä½¿ç”¨å…±äº«è¿æ¥çš„æ–¹å¼ï¼Œä¸”è¿æ¥æ•°ä¸º 1 // Dubbo åœ¨ 2.7 ç‰ˆæœ¬ä¸­æ”¯æŒå…±äº«è¿æ¥æ•°çš„é…ç½® SHARE_CONNECTIONS_KEY if (connections == 0) &#123; service_share_connect = true; connections = 1; &#125; // åˆ›å»ºè¿æ¥æœåŠ¡æä¾›è€…çš„ ExchangeClient å¯¹è±¡æ•°ç»„ ExchangeClient[] clients = new ExchangeClient[connections]; for (int i = 0; i &lt; clients.length; i++) &#123; // 1 å…±äº«è¿æ¥ if (service_share_connect) &#123; clients[i] = getSharedClient(url); // 2 å–ç‹¬äº«è¿æ¥ï¼Œconnections çš„å€¼ä¸ºå¤šå°‘å°±ä¼šåˆ›å»ºå‡ ä¸ªç‹¬äº«è¿æ¥ï¼Œåœ¨è°ƒç”¨æ—¶ä¼šè½®æµä½¿ç”¨ã€‚ // æ³¨æ„å’Œ Dubbo è´Ÿè½½å‡è¡¡çš„åŒºåˆ«ã€‚ &#125; else &#123; clients[i] = initClient(url); &#125; &#125; return clients; &#125; ExchangeClient å®é™…ä¸Šå¹¶ä¸å…·æœ‰é€šä¿¡èƒ½åŠ›ï¼Œé€šä¿¡èƒ½åŠ›ä¾èµ–å…¶å°è£…çš„æ›´åº•å±‚å®¢æˆ·ç«¯å®ä¾‹ï¼Œå¦‚ NettyClientã€MinaClient ç­‰ã€‚ å½“ä½¿ç”¨ç‹¬äº«è¿æ¥æ—¶ï¼Œé’ˆå¯¹æ¯ä¸ªæœåŠ¡ï¼ˆå¯¹åº”ä¸€ä¸ªServiceï¼‰åˆ›å»ºå›ºå®šæ•°é‡çš„ Client ï¼Œæ¯ä¸ª Client ç»´æŠ¤ä¸€ä¸ªåº•å±‚è¿æ¥ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œconnections é…ç½®é¡¹è®¾ç½®äº† 2 ï¼Œä¹Ÿå°±æ˜¯é’ˆå¯¹æ¯ä¸ª Service éƒ½å¯åŠ¨äº†ä¸¤ä¸ªç‹¬äº«è¿æ¥ã€‚ å½“ä½¿ç”¨å…±äº«è¿æ¥æ—¶ï¼Œä¼šæ ¹æ®èŠ‚ç‚¹åœ°å€ï¼ˆhost:portï¼‰ï¼Œä¸€ä¸ªåœ°å€åªåˆ›å»ºå›ºå®šæ•°é‡çš„å…±äº«è¿æ¥ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œshareconnections é…ç½®é¡¹è®¾ç½®äº† 2ï¼Œä¹Ÿå°±æ˜¯é’ˆå¯¹æ¯ä¸ªæœåŠ¡èŠ‚ç‚¹éƒ½ä¼šåˆ›å»ºä¸¤ä¸ªå…±äº«è¿æ¥ï¼Œè¿™ä¸¤ä¸ªå…±äº«è¿æ¥è¢«èŠ‚ç‚¹ä¸­çš„æ‰€æœ‰æœåŠ¡ä½¿ç”¨ï¼Œå¦‚ Consumer è°ƒç”¨ Provider1 æä¾›è€…ä¸­çš„å¤šä¸ªæœåŠ¡æ—¶ï¼Œæ˜¯ä½¿ç”¨å›ºå®šæ•°é‡çš„å…±äº«é•¿è¿æ¥è¿›è¡Œæ•°æ®ä¼ è¾“ï¼Œè¿™æ ·å°±å¯ä»¥è¾¾åˆ°å‡å°‘æœåŠ¡ç«¯è¿æ¥çš„ç›®çš„ã€‚ å…±äº«è¿æ¥123456789101112131415161718192021222324252627282930313233343536373839404142434445+--- DubboProtocol private ExchangeClient getSharedClient(URL url) &#123; // 1 è·å–ä»æ³¨å†Œä¸­å¿ƒæ‹‰å–çš„æœåŠ¡æä¾›è€…çš„åœ°å€ï¼ˆip:portï¼‰ï¼Œè¿æ¥æœåŠ¡è‡ªç„¶éœ€è¦çŸ¥é“æœåŠ¡åœ°å€ String key = url.getAddress(); // 2 ä» referenceClientMap ä¸­è·å–ä¸è¯¥åœ°å€è¿æ¥çš„å¸¦æœ‰å¼•ç”¨è®°æ•°åŠŸèƒ½çš„ExchangeClient ReferenceCountExchangeClient client = referenceClientMap.get(key); if (client != null) &#123; if (!client.isClosed()) &#123; /** è‹¥æœªå…³é—­ï¼Œå¢åŠ æŒ‡å‘è¯¥Client çš„æ•°é‡ &#123;@link #refenceCount&#125; */ client.incrementAndGetCount(); return client; // è‹¥å·²å…³é—­ï¼Œç§»é™¤ &#125; else &#123; referenceClientMap.remove(key); &#125; &#125; // æ–°å¢é”å¯¹è±¡ locks.putIfAbsent(key, new Object()); // é’ˆå¯¹æŒ‡å®šåœ°å€çš„å®¢æˆ·ç«¯åˆ›å»ºè¿›è¡ŒåŠ é”ï¼Œè¿™é‡Œä½¿ç”¨åˆ†åŒºåŠ é”å¯ä»¥æé«˜å¹¶å‘åº¦ synchronized (locks.get(key)) &#123; // double check if (referenceClientMap.containsKey(key)) &#123; return referenceClientMap.get(key); &#125; // 3 åˆå§‹åŒ– ExchangeClient å®¢æˆ·ç«¯ ExchangeClient exchangeClient = initClient(url); // 4 ä½¿ç”¨è£…é¥°è€…æ¨¡å¼å°†initClientè¿”å›çš„HeaderExchangeClientå®ä¾‹æˆ–LazyConnectExchangeClientå®ä¾‹å°è£…ä¸ºReferenceCountExchangeClientå¯¹è±¡ // æ³¨æ„ï¼Œåœ¨ä½¿ç”¨å…±äº«è¿æ¥æ—¶éœ€è¦æ³¨æ„ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœä¸¤ä¸ªä»¥ä¸Šçš„Invoker å…±äº«è¿™ä¸ªè¿æ¥çš„è¯ï¼Œé‚£ä¹ˆå¿…é¡»æ‰€æœ‰çš„Invoker éƒ½å…³é—­æ‰èƒ½å…³é—­è¿æ¥ã€‚ client = new ReferenceCountExchangeClient(exchangeClient, ghostClientMap); // 5 æ·»åŠ åˆ°ç¼“å­˜é›†åˆ referenceClientMap.put(key, client); // 6 æ–°å»ºäº†ExchangeClientï¼Œä¸éœ€è¦è¿›è¡Œå…œåº•ï¼Œç§»é™¤å…œåº•é›†åˆ ghostClientMap ä¸­çš„å…ƒç´  ghostClientMap.remove(key); //å°†ä½œä¸ºé”æ ‡è¯†çš„å…ƒç´ ä»é›†åˆä¸­ç§»é™¤ locks.remove(key); return client; &#125; &#125; å…±äº«è¿æ¥çš„åˆ›å»ºæ˜¯åœ¨ç‹¬äº«è¿æ¥åˆ›å»ºçš„åŸºç¡€ä¸Šè¿›è¡Œçš„ï¼Œå…±äº«è¿æ¥çš„ç¼“å­˜åŸºäºå¯¹ç«¯åœ°å€ï¼ˆip:portï¼‰ï¼ŒåŒæ—¶å…±äº«è¿æ¥çš„å®ç°æ˜¯ ReferenceCountExchangeClientï¼Œå®ƒæ˜¯ ExchangeClient çš„ä¸€ä¸ªè£…é¥°å™¨ï¼Œåœ¨åŸå§‹çš„ ExchangeClient å¯¹è±¡åŸºç¡€ä¸Šæ·»åŠ äº†å¼•ç”¨è®¡æ•°çš„åŠŸèƒ½ã€‚ å®¢æˆ·ç«¯å…±äº«è¿æ¥ä½¿ç”¨çš„å®¢æˆ·ç«¯å®ç°æ˜¯ ReferenceCountExchangeClient ï¼Œå®ƒæ˜¯å¯¹ä¿¡æ¯äº¤æ¢å±‚çš„ ExchangeClient æ¥å£çš„ç›´æ¥å®ç°ï¼Œæ˜¯ ExchangeClient çš„è£…é¥°å™¨ï¼Œåœ¨åŸå§‹çš„ ExchangeClient å¯¹è±¡åŸºç¡€ä¸Šæ·»åŠ äº†å¼•ç”¨è®¡æ•°åŠŸèƒ½ï¼Œç”¨äºå…±äº«è¿æ¥æ¨¡å¼ã€‚åœ¨ä»‹ç»ä¿¡æ¯äº¤æ¢å±‚çš„å®¢æˆ·ç«¯æ—¶ï¼Œå…¶ä¸­çš„ HeaderExchangeClient ä¹Ÿæ˜¯å¯¹ ExchangeClient æ¥å£çš„ç›´æ¥å®ç°ï¼Œè¿™é‡Œ ReferenceCountExchangeClient è£…é¥°çš„ ExchangeClient å°±æ˜¯ HeaderExchangeClient å¯¹è±¡ã€‚Dubbo åè®®å®¢æˆ·ç«¯ç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸‹é¢å¯¹ ReferenceCountExchangeClient è¿›è¡Œä»‹ç»ã€‚ å±æ€§123456789101112131415161718192021222324252627282930313233343536final class ReferenceCountExchangeClient implements ExchangeClient &#123; /** * URL */ private final URL url; /** * å¼•ç”¨è®¡æ•°å˜é‡ï¼Œç”¨äºè®°å½• Client è¢«åº”ç”¨çš„æ¬¡æ•°ã€‚ æ¯å½“è¯¥å¯¹è±¡è¢«å¼•ç”¨ä¸€æ¬¡refenceCount éƒ½ä¼šè¿›è¡Œè‡ªå¢ã€‚ æ¯å½“closeæ–¹æ³•è¢«è°ƒç”¨æ—¶ï¼ŒreferenceCount å°±ä¼šè¿›è¡Œè‡ªå‡ */ private final AtomicInteger refenceCount = new AtomicInteger(0); /** * ç»´æŠ¤closeæ‰çš„clientï¼Œç”¨äºå…œåº•ã€‚å’Œ &#123;@link Protocol#ghostClentMap&#125; ä¸€è‡´ */ private final ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap; /** * å®¢æˆ·ç«¯ ã€ç±»å‹æ˜¯ï¼š HeaderExchangeClientã€‘ï¼Œè¢«è£…é¥°å¯¹è±¡ */ private ExchangeClient client; /** * å°†HeaderExchangeClient å®ä¾‹å°è£…ä¸ºReferenceCountExchangeClientã€‚ * * @param client * @param ghostClientMap */ public ReferenceCountExchangeClient(ExchangeClient client, ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap) &#123; this.client = client; // å¼•ç”¨è®¡æ•°é€’å¢ refenceCount.incrementAndGet(); this.url = client.getUrl(); if (ghostClientMap == null) &#123; throw new IllegalStateException(\"ghostClientMap can not be null, url: \" + url); &#125; this.ghostClientMap = ghostClientMap; &#125;&#125; ReferenceCountExchangeClient ä¸­æŒæœ‰çš„ client å±æ€§å°±æ˜¯è¢«è£…é¥°çš„ä¿¡æ¯äº¤æ¢å±‚çš„å®¢æˆ·ç«¯å¯¹è±¡ï¼ŒrefenceCount å±æ€§ç”¨äºè®°å½•è¯¥ Client è¢«å¼•ç”¨çš„æ¬¡æ•°ï¼Œåœ¨ ReferenceCountExchangeClient çš„æ„é€ æ–¹æ³•ä»¥åŠ incrementAndGetCount() æ–¹æ³•ä¸­ä¼šå¢åŠ å¼•ç”¨æ¬¡æ•°ï¼Œåœ¨ close() æ–¹æ³•ä¸­åˆ™ä¼šå‡å°‘å¼•ç”¨æ¬¡æ•°ã€‚ 1234567+--- ReferenceCountExchangeClient /** * è¯¥æ–¹æ³•ä¸€èˆ¬ç”±å¤–éƒ¨è°ƒç”¨ï¼Œå¼•ç”¨è®¡æ•°é€’å¢ */ public void incrementAndGetCount() &#123; refenceCount.incrementAndGet(); &#125; å…¶å®ƒæ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128+--- ReferenceCountExchangeClient // ----------- ExchangeChannel æ¥å£æ–¹æ³•å®ç° --------------/ @Override public ResponseFuture request(Object request) throws RemotingException &#123; return client.request(request); &#125; @Override public ResponseFuture request(Object request, int timeout) throws RemotingException &#123; return client.request(request, timeout); &#125; @Override public ExchangeHandler getExchangeHandler() &#123; return client.getExchangeHandler(); &#125; // ------------- Endpoint æ¥å£æ–¹æ³•å®ç° -----------------/ @Override public void send(Object message, boolean sent) throws RemotingException &#123; client.send(message, sent); &#125; @Override public void send(Object message) throws RemotingException &#123; client.send(message); &#125; @Override public URL getUrl() &#123; return client.getUrl(); &#125; @Override public ChannelHandler getChannelHandler() &#123; return client.getChannelHandler(); &#125; @Override public InetSocketAddress getLocalAddress() &#123; return client.getLocalAddress(); &#125; @Override public void reset(Parameters parameters) &#123; client.reset(parameters); &#125; @Override public void reset(URL url) &#123; client.reset(url); &#125; /** * close() is not idempotent any longer */ @Override public void close() &#123; close(0); &#125; /** * å¼•ç”¨æ¬¡æ•°å‡å°‘åˆ°0æ—¶ ï¼ŒExchangeClient è¿æ¥å…³é—­ * * @param timeout */ @Override public void close(int timeout) &#123; // å¼•ç”¨è®¡æ•°å‡ä¸€ï¼Œè‹¥æ— æŒ‡å‘ï¼Œè¿›è¡ŒçœŸæ­£çš„å…³é—­ if (refenceCount.decrementAndGet() &lt;= 0) &#123; if (timeout == 0) &#123; client.close(); &#125; else &#123; client.close(timeout); &#125; // å…³é—­ExchangeClientå¯¹è±¡ä¹‹åï¼Œä¼šæ›¿æ¢ client ä¸º LazyConnectExchangeClient å¯¹è±¡ï¼Œå³å°†å…³é—­ä¹‹åçš„è¿æ¥å˜æˆä¸€ä¸ªæ‡’åŠ è½½çš„client client = replaceWithLazyClient(); &#125; &#125; @Override public void startClose() &#123; client.startClose(); &#125; @Override public boolean isClosed() &#123; return client.isClosed(); &#125; // ---- Channel æ¥å£å®ç° ----------/ @Override public boolean isConnected() &#123; return client.isConnected(); &#125; @Override public Object getAttribute(String key) &#123; return client.getAttribute(key); &#125; @Override public boolean hasAttribute(String key) &#123; return client.hasAttribute(key); &#125; @Override public void setAttribute(String key, Object value) &#123; client.setAttribute(key, value); &#125; @Override public void removeAttribute(String key) &#123; client.removeAttribute(key); &#125; @Override public InetSocketAddress getRemoteAddress() &#123; return client.getRemoteAddress(); &#125; // --- Client æ¥å£å®ç° ----------/ @Override public void reconnect() throws RemotingException &#123; client.reconnect(); &#125; é‡‡ç”¨è£…é¥°å™¨æ¨¡å¼ï¼Œæ¯ä¸ªæ–¹æ³•çš„å®ç°éƒ½æ˜¯äº¤ç»™è¢«è£…é¥°çš„ client å¤„ç†ï¼Œä¹Ÿå°±æ˜¯ HeaderExchangeClient å¤„ç†ã€‚ä»¥ä¸Šæ–¹æ³•å®ç°æ¥æºäºä¸åŒçš„æ¥å£æˆ–ç±»ï¼Œå’Œ HeaderExchangeClient ä¸­çš„å®ç°å‡ ä¹ä¸€è‡´ï¼Œçœ‹èµ·æ¥æ¯”è¾ƒä¹±ï¼Œä½†æ˜¯è¿½æº¯åˆ°æœ€åº•å±‚å¯ä»¥å‘ç°ï¼Œè¿™äº›æ–¹æ³•å‡ ä¹éƒ½æ˜¯äº¤ç»™é€šé“ Channel æ¥å¤„ç†çš„ï¼ŒClient åªå®Œæˆäº†é‡è¿çš„é€»è¾‘ã€‚ å…³é—­12345678910111213141516171819202122232425262728293031323334353637383940+--- ReferenceCountExchangeClient @Override public void close(int timeout) &#123; // å¼•ç”¨è®¡æ•°å‡ä¸€ï¼Œè‹¥æ— æŒ‡å‘ï¼Œè¿›è¡ŒçœŸæ­£çš„å…³é—­ if (refenceCount.decrementAndGet() &lt;= 0) &#123; if (timeout == 0) &#123; client.close(); &#125; else &#123; client.close(timeout); &#125; // å…³é—­ExchangeClientå¯¹è±¡ä¹‹åï¼Œä¼šæ›¿æ¢ client ä¸º LazyConnectExchangeClient å¯¹è±¡ï¼Œå³å°†å…³é—­ä¹‹åçš„è¿æ¥å˜æˆä¸€ä¸ªæ‡’åŠ è½½çš„client client = replaceWithLazyClient(); &#125; &#125; private LazyConnectExchangeClient replaceWithLazyClient() &#123; // åœ¨åŸæœ‰çš„URLä¹‹ä¸Šï¼Œæ·»åŠ ä¸€äº›LazyConnectExchangeClientç‰¹æœ‰çš„å‚æ•° URL lazyUrl = url.addParameter(Constants.LAZY_CONNECT_INITIAL_STATE_KEY, Boolean.FALSE) // å…³é—­é‡è¿ .addParameter(Constants.RECONNECT_KEY, Boolean.FALSE) .addParameter(Constants.SEND_RECONNECT_KEY, Boolean.TRUE.toString()) .addParameter(\"warning\", Boolean.TRUE.toString()) .addParameter(LazyConnectExchangeClient.REQUEST_WITH_WARNING_KEY, true) .addParameter(\"_client_memo\", \"referencecounthandler.replacewithlazyclient\"); // ä» ghostClientMap ç¼“å­˜ä¸­æŸ¥æ‰¾ String key = url.getAddress(); // in worst case there's only one ghost connection. LazyConnectExchangeClient gclient = ghostClientMap.get(key); // å¦‚æœå½“å‰clientå­—æ®µå·²ç»æŒ‡å‘äº†LazyConnectExchangeClientï¼Œåˆ™ä¸éœ€è¦å†æ¬¡åˆ›å»º if (gclient == null || gclient.isClosed()) &#123; // ChannelHandler ä¾æ—§ä½¿ç”¨åŸå§‹ExchangeClientä½¿ç”¨çš„Handlerï¼Œå³DubboProtocolä¸­çš„requestHandlerå­—æ®µ gclient = new LazyConnectExchangeClient(lazyUrl, client.getExchangeHandler()); ghostClientMap.put(key, gclient); &#125; return gclient; &#125; ä» ReferenceCountExchangeClient å…³é—­é€»è¾‘å¯ä»¥å‘ç°ï¼š å½“å¼•ç”¨æ¬¡æ•°å‡åˆ° 0 çš„æ—¶å€™ï¼ŒExchangeClient è¿æ¥å…è®¸å…³é—­ã€‚å½“å¼•ç”¨æ¬¡æ•°æœªå‡åˆ° 0 çš„æ—¶å€™ï¼Œåº•å±‚çš„ ExchangeClient ä¸èƒ½å…³é—­ã€‚ åœ¨å…³é—­åº•å±‚ ExchangeClient å¯¹è±¡ä¹‹åï¼Œä¼šç«‹å³åˆ›å»ºä¸€ä¸ª LazyConnectExchangeClient å¯¹è±¡ï¼Œç”¨äºå¼‚å¸¸æƒ…å†µçš„å…œåº•ã€‚è¿™ä¸ªè¿æ¥çš„ç‰¹ç‚¹æ˜¯åœ¨éœ€è¦å‘é€è¯·æ±‚çš„æ—¶å€™æ‰ä¼šè¿›è¡Œ Client çš„åˆ›å»ºã€‚ å‰æ–‡ä¹Ÿæåˆ°ï¼Œå…±äº«è¿æ¥çš„åˆ›å»ºæ˜¯åœ¨ç‹¬äº«è¿æ¥çš„åŸºç¡€ä¸Šï¼Œç‹¬äº«è¿æ¥åˆ›å»ºæ˜¯é€šè¿‡ initClient æ–¹æ³•ï¼Œè€Œå…±äº«è¿æ¥æ˜¯ä»¥åœ°å€ï¼ˆhost:portï¼‰ä½œä¸ºæ ‡è¯†å°†ç‹¬äº«è¿æ¥ç¼“å­˜ï¼Œé¿å…åŒä¸€åœ°å€åˆ›å»ºå¤šæ¡è¿æ¥ã€‚ä¸‹é¢æˆ‘ä»¬å°±æ¥åˆ†æç‹¬äº«è¿æ¥çš„åˆ›å»ºã€‚ ç‹¬äº«è¿æ¥123456789101112131415161718192021222324252627282930313233343536+--- DubboProtocol private ExchangeClient initClient(URL url) &#123; // 1. è·å–å®¢æˆ·ç«¯ç±»å‹ï¼Œé»˜è®¤ä¸ºnettyã€‚ä¸‹é¢é€»è¾‘ä¼šæ£€æŸ¥è¯¥æ‰©å±• String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT)); // 2. è®¾ç½®ç¼–è§£ç å™¨Codec2çš„æ‰©å±•å,å³DubboCountCodec &#123;@link DubboCountCodec&#125; url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME); // 3. é»˜è®¤å¼€å¯heartbeat,60 * 1000 url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT)); // æ ¡éªŒé…ç½®çš„Client çš„ Dubbo SPIæ‹“å±•æ˜¯å¦å­˜åœ¨ï¼Œè‹¥ä¸å­˜åœ¨ï¼ŒæŠ›å‡ºRpcException if (str != null &amp;&amp; str.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123; throw new RpcException(\"Unsupported client type: \" + str + \",\" + \" supported client type is \" + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), \" \")); &#125; // 4 è¿æ¥æœåŠ¡å™¨ï¼Œåˆ›å»ºå®¢æˆ·ç«¯ ExchangeClient client; try &#123; // 4.1 å¦‚æœé…ç½®äº†å»¶è¿Ÿåˆ›å»ºè¿æ¥çš„ç‰¹æ€§ if (url.getParameter(Constants.LAZY_CONNECT_KEY, false)) &#123; // åˆ›å»ºå»¶è¿Ÿå»ºç«‹è¿æ¥çš„å¯¹è±¡ï¼ˆåœ¨è¯·æ±‚æ—¶æ‰ä¼šåˆå§‹åŒ–è¿æ¥ï¼‰ client = new LazyConnectExchangeClient(url, requestHandler); // 4.2 æœªä½¿ç”¨å»¶è¿Ÿè¿æ¥åŠŸèƒ½ï¼Œåˆ™é€šè¿‡Exchangersçš„ connect æ–¹æ³•åˆ›å»º ExchangeClient å®¢æˆ·ç«¯ï¼Œè¿™é‡Œæ˜¯ HeaderExchangeClient &#125; else &#123; client = Exchangers.connect(url, requestHandler); &#125; &#125; catch (RemotingException e) &#123; throw new RpcException(\"Fail to create remoting client for service(\" + url + \"): \" + e.getMessage(), e); &#125; return client; &#125; DubboProtocol åˆ›å»ºè¿æ¥çš„æµç¨‹å¦‚ä¸‹ï¼š å¯¹å®¢æˆ·ç«¯æ‰©å±•åè¿›è¡Œæ ¡éªŒï¼Œé»˜è®¤ä½¿ç”¨ netty è®¾ç½®ç¼–è§£ç å™¨ Codec2 çš„æ‰©å±•åï¼Œè¿™é‡Œå›ºå®šæ˜¯ DubboCountCodec è®¾ç½®å¿ƒè·³æ—¶é—´ è¿æ¥NIOæœåŠ¡å™¨ï¼Œåˆ›å»ºå®¢æˆ·ç«¯ã€‚è¿™é‡Œä¼šæ ¹æ®æ˜¯å¦è®¾ç½®å»¶è¿Ÿåˆ›å»ºè¿æ¥çš„ç‰¹æ€§åˆ›å»ºä¸åŒçš„ Client æ²¡æœ‰è®¾ç½®å»¶è¿Ÿåˆ›å»ºè¿æ¥çš„é…ç½®é¡¹æ—¶ç›´æ¥ä½¿ç”¨ä¿¡æ¯äº¤æ¢å±‚çš„ Exchangers.connect åˆ›å»º HeaderExchangeClient å¯¹è±¡ï¼Œå¦åˆ™åˆ›å»º LazyConnectExchangeClient å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ä¸ä¼šç«‹åˆ»åˆå§‹åŒ–è¿æ¥è€Œæ˜¯åœ¨è¯·æ±‚æ—¶æ‰ä¼šåˆå§‹åŒ–ã€‚ LazyConnectExchangeClientLazyConnectExchangeClient åŒæ ·æ˜¯ ExchangeClient çš„è£…é¥°å™¨ï¼Œå®ƒä¼šåœ¨åŸæœ‰ ExchangeClient å¯¹è±¡çš„åŸºç¡€ä¸Šæ·»åŠ å»¶è¿Ÿåˆå§‹åŒ–è¿æ¥çš„åŠŸèƒ½ï¼Œå³åœ¨å‘é€è¯·æ±‚çš„æ—¶å€™æ‰ä¼šè¿›è¡Œåˆå§‹åŒ–ã€‚ å±æ€§1234567891011121314151617181920212223242526272829303132333435final class LazyConnectExchangeClient implements ExchangeClient &#123; private final static Logger logger = LoggerFactory.getLogger(LazyConnectExchangeClient.class); // å»¶è¿Ÿè¿æ¥å‘Šè­¦é…ç½®é¡¹ static final String REQUEST_WITH_WARNING_KEY = \"lazyclient_request_with_warning\"; /** * è¯·æ±‚æ—¶ï¼Œæ˜¯å¦æ£€æŸ¥å‘Šè­¦ */ protected final boolean requestWithWarning; /** * URL */ private final URL url; /** * é€šé“å¤„ç†å™¨ */ private final ExchangeHandler requestHandler; /** * è¿æ¥é” */ private final Lock connectLock = new ReentrantLock(); /** * æ‡’è¿æ¥åˆå§‹åŒ–çŠ¶æ€ */ private final boolean initialState; /** * é€šä¿¡å®¢æˆ·ç«¯ */ private volatile ExchangeClient client; /** * è­¦å‘Šè®¡æ•°å™¨ã€‚æ¯è¶…è¿‡ä¸€å®šæ¬¡æ•°ï¼Œæ‰“å°å‘Šè­¦æ—¥å¿—ã€‚å‚è§ &#123;@link #warning(Object)&#125; */ private AtomicLong warningcount = new AtomicLong(0);&#125; LazyConnectExchangeClient ä¸­çš„ url å’Œ requestHandler æ˜¯åˆ›å»ºå¯¹è±¡çš„æ—¶å€™å°è£…çš„å±æ€§ï¼ŒLazyConnectExchangeClient åœ¨æ„é€ æ–¹æ³•ä¸­ä¸ä¼šåˆ›å»ºåº•å±‚æŒæœ‰è¿æ¥çš„ Clientï¼Œè€Œæ˜¯åœ¨éœ€è¦å‘é€è¯·æ±‚çš„æ—¶å€™æ‰ä¼šè°ƒç”¨ initClient() æ–¹æ³•è¿›è¡Œ Client çš„åˆ›å»ºã€‚ æ„é€ æ–¹æ³•123456789+--- LazyConnectExchangeClient public LazyConnectExchangeClient(URL url, ExchangeHandler requestHandler) &#123; // å»¶è¿Ÿè¿æ¥éœ€è¦è®¾ç½® send.reconnect ä¸º trueï¼Œé˜²æ­¢é€šé“ä¸è‰¯çŠ¶æ€ this.url = url.addParameter(Constants.SEND_RECONNECT_KEY, Boolean.TRUE.toString()); this.requestHandler = requestHandler; // æ‡’è¿æ¥åˆå§‹åŒ–çŠ¶æ€é»˜è®¤å€¼ä¸º true this.initialState = url.getParameter(Constants.LAZY_CONNECT_INITIAL_STATE_KEY, Constants.DEFAULT_LAZY_CONNECT_INITIAL_STATE); this.requestWithWarning = url.getParameter(REQUEST_WITH_WARNING_KEY, false); &#125; è¯·æ±‚æ–¹æ³•1234567891011121314151617181920212223242526272829303132+--- LazyConnectExchangeClient @Override public ResponseFuture request(Object request) throws RemotingException &#123; warning(request); initClient(); return client.request(request); &#125; @Override public ResponseFuture request(Object request, int timeout) throws RemotingException &#123; warning(request); initClient(); return client.request(request, timeout); &#125; /** * å‘é€æ¶ˆæ¯/è¯·æ±‚å‰ï¼Œéƒ½ä¼šè°ƒç”¨è¯¥æ–¹æ³•ï¼Œç¡®ä¿å®¢æˆ·ç«¯å·²ç»åˆå§‹åŒ– * * @param message * @throws RemotingException */ @Override public void send(Object message) throws RemotingException &#123; initClient(); client.send(message); &#125; @Override public void send(Object message, boolean sent) throws RemotingException &#123; initClient(); client.send(message, sent); &#125; åˆå§‹åŒ–è¿æ¥1234567891011121314151617181920212223+--- LazyConnectExchangeClient private void initClient() throws RemotingException &#123; // å·²åˆå§‹åŒ–ï¼Œåˆ™è·³è¿‡ if (client != null) &#123; return; &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Lazy connect to \" + url); &#125; // è·å¾—é” connectLock.lock(); try &#123; // å·²åˆå§‹åŒ–ï¼Œè·³è¿‡ if (client != null) &#123; return; &#125; // åˆ›å»ºClient,è¿æ¥æœåŠ¡å™¨ this.client = Exchangers.connect(url, requestHandler); &#125; finally &#123; // é‡Šæ”¾é” connectLock.unlock(); &#125; &#125; å…¶å®ƒæ–¹æ³•LazyConnectExchangeClient ä¸­çš„å…¶å®ƒæ–¹æ³•åŒæ ·æ˜¯å¯¹ä¸åŒæ¥å£å’Œç±»ä¸­çš„æ–¹æ³•å®ç°ï¼Œå¦‚è·å–åœ°å€çš„æ–¹æ³•ï¼Œè·å–å¤„ç†å™¨çš„æ–¹æ³•ï¼Œå…³é—­ç›¸å…³çš„æ–¹æ³•ä»¥åŠå’Œé€šé“å±æ€§ç›¸å…³çš„æ–¹æ³•ã€‚ æœåŠ¡å¼•ç”¨æµç¨‹å›¾ Dubbo æ¡†æ¶é‡‡ç”¨ Dubbo åè®®è¿›è¡ŒæœåŠ¡å¼•ç”¨çš„æµç¨‹å›¾å¦‚ä¸Šå›¾æ‰€ç¤ºã€‚ä» Protocol åè®®å±‚ çš„ getClients æ–¹æ³•ä¼šä¸€è·¯è°ƒç”¨åˆ° Exchange ä¿¡æ¯äº¤æ¢å±‚ã€Transport ç½‘ç»œä¼ è¾“å±‚ï¼Œæœ€ç»ˆå¯åŠ¨å®¢æˆ·ç«¯å¹¶è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œåç»­å°±å¯ä»¥ä½¿ç”¨å¤„äºå¥åº·çŠ¶æ€çš„è¿æ¥è¿›è¡ŒåŒå‘è¿œç¨‹é€šä¿¡äº†ã€‚ é”€æ¯åœ¨ DubboProtocol é”€æ¯çš„æ—¶å€™ï¼Œä¼šè°ƒç”¨ destroy() æ–¹æ³•é‡Šæ”¾åº•å±‚èµ„æºã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364+--- DubboProtocol @Override public void destroy() &#123; // 1 é”€æ¯æ‰€æœ‰é€šä¿¡æœåŠ¡å™¨ ExchangeServer for (String key : new ArrayList&lt;String&gt;(serverMap.keySet())) &#123; // 1.1 å…ˆä»ç¼“å­˜ä¸­åˆ é™¤é€šä¿¡æœåŠ¡å™¨ ExchangeServer server = serverMap.remove(key); if (server != null) &#123; try &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Close dubbo server: \" + server.getLocalAddress()); &#125; // åœ¨close()æ–¹æ³•ä¸­ï¼Œä¸‹å±‚ï¼ˆå¦‚HeaderExchangeServerï¼‰ä¼šå‘é€ReadOnlyè¯·æ±‚ã€é˜»å¡æŒ‡å®šæ—¶é—´ã€å…³é—­åº•å±‚çš„å®šæ—¶ä»»åŠ¡ã€å…³é—­ç›¸å…³çº¿ç¨‹æ± ï¼Œæœ€ç»ˆï¼Œä¼šæ–­å¼€æ‰€æœ‰è¿æ¥ï¼Œå…³é—­Serverã€‚ // è¿™äº›é€»è¾‘åœ¨å‰æ–‡ä»‹ç»HeaderExchangeServerã€NettyServerç­‰å®ç°çš„æ—¶å€™ // åœ¨ä¼˜é›…åœæœºçš„ç­‰å¾…æ—¶é•¿å†…å…³é—­ [ä¿è¯äº†æœåŠ¡å¹³æ»‘çš„ä¸‹çº¿] server.close(ConfigUtils.getServerShutdownTimeout()); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125; // 2 é”€æ¯æ‰€æœ‰é€šä¿¡å®¢æˆ·ç«¯ ExchangeClient for (String key : new ArrayList&lt;String&gt;(referenceClientMap.keySet())) &#123; // 2.1 å…ˆä»ç¼“å­˜ä¸­åˆ é™¤é€šä¿¡å®¢æˆ·ç«¯ ExchangeClient client = referenceClientMap.remove(key); if (client != null) &#123; try &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Close dubbo connect: \" + client.getLocalAddress() + \"--&gt;\" + client.getRemoteAddress()); &#125; // ReferenceCountExchangeClient ä¸­åªæœ‰å¼•ç”¨å‡åˆ° 0ï¼Œåº•å±‚çš„ Client æ‰ä¼šçœŸæ­£é”€æ¯ // åœ¨ä¼˜é›…åœæœºçš„ç­‰å¾…æ—¶é•¿å†…å…³é—­ ã€ä¿è¯åœ¨å¤„ç†çš„è¯·æ±‚èƒ½å¤Ÿå°½å¯èƒ½çš„åœ¨ä¼˜é›…åœæœºæ—¶é—´å†…å®Œæˆå¤„ç†ã€‘ client.close(ConfigUtils.getServerShutdownTimeout()); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125; // 3 é”€æ¯æ‰€æœ‰çš„é€šä¿¡å®¢æˆ·ç«¯ LazyConnectExchangeClient for (String key : new ArrayList&lt;String&gt;(ghostClientMap.keySet())) &#123; // 3.1 å…ˆä»ç¼“å­˜ä¸­åˆ é™¤ ExchangeClient client = ghostClientMap.remove(key); if (client != null) &#123; try &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Close dubbo connect: \" + client.getLocalAddress() + \"--&gt;\" + client.getRemoteAddress()); &#125; // åœ¨ä¼˜é›…åœæœºçš„ç­‰å¾…æ—¶é•¿å†…å…³é—­ client.close(ConfigUtils.getServerShutdownTimeout()); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125; // æ¸…ç† stub ç¼“å­˜ stubServiceMethodsMap.clear(); // 4 æ‰§è¡Œçˆ¶ç±» AbstractProtocol çš„é”€æ¯æ–¹æ³• super.destroy(); &#125; DubboProtocol æ‰§è¡Œé”€æ¯çš„é€»è¾‘ä¸»è¦é’ˆå¯¹ä¸‰ç±»å¯¹è±¡ï¼Œåˆ†åˆ«å¯¹è¯¥ä¸‰ç±»å¯¹è±¡è¿›è¡Œä¼˜é›…å…³é—­ã€‚ ä¼˜é›…å…³é—­ExchangeServerå¯¹è±¡ï¼Œä¿è¯æœåŠ¡å¹³ç¨³ä¸‹çº¿ã€‚ ä¼˜é›…å…³é—­ExchangeClientå¯¹è±¡ï¼Œå°½å¯èƒ½ä¿è¯è¯·æ±‚å®Œæˆã€‚ ä¼˜é›…å…³é—­LazyConnectExchangeClientå¯¹è±¡ã€‚ é¢†åŸŸæ¨¡å‹DubboProtocol.refer() æ–¹æ³•ä¼šå°†åº•å±‚çš„ ExchangeClient é›†åˆå°è£…æˆ DubboInvokerï¼Œç„¶åç”±ä¸Šå±‚é€»è¾‘å°è£…æˆä»£ç†å¯¹è±¡ã€‚è¿™æ ·ä¸šåŠ¡å±‚å°±å¯ä»¥åƒè°ƒç”¨æœ¬åœ°å¯¹è±¡ä¸€æ ·ï¼Œå®Œæˆè¿œç¨‹è°ƒç”¨ã€‚ç›¸å…³ç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š å…³äº AbstractInvoker åœ¨å‰é¢å·²ç»ä»‹ç»è¿‡äº†ï¼Œå¯ä»¥å‚è€ƒ AbstractInvoker ã€‚ä¸‹é¢æˆ‘ä»¬å¯¹ DubboInvoker è¿›è¡Œä»‹ç»ã€‚ DubboInvokerDubboInvoker æ˜¯ AbstractInvoker çš„å®ç°ç±»ï¼Œå…¶ doInvoke() æ–¹æ³•æ˜¯è¿œç¨‹è°ƒç”¨çš„ç›´æ¥å…¥å£ã€‚ å±æ€§123456789101112131415161718192021222324252627282930313233343536public class DubboInvoker&lt;T&gt; extends AbstractInvoker&lt;T&gt; &#123; /** * è¿œç¨‹é€šä¿¡å®¢æˆ·ç«¯æ•°ç»„ */ private final ExchangeClient[] clients; /** * ä½¿ç”¨çš„ &#123;@link #clients&#125; çš„ä½ç½® */ private final AtomicPositiveInteger index = new AtomicPositiveInteger(); /** * ç‰ˆæœ¬ */ private final String version; /** * é”€æ¯æ–¹æ³•ä¸­ä½¿ç”¨çš„jvm é” */ private final ReentrantLock destroyLock = new ReentrantLock(); /** * Invoker é›†åˆï¼Œä»&#123;@link DubboProtocol#invokers&#125; è·å– */ private final Set&lt;Invoker&lt;?&gt;&gt; invokers; public DubboInvoker(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients) &#123; this(serviceType, url, clients, null); &#125; public DubboInvoker(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients, Set&lt;Invoker&lt;?&gt;&gt; invokers) &#123; super(serviceType, url, new String[]&#123;Constants.INTERFACE_KEY, Constants.GROUP_KEY, Constants.TOKEN_KEY, Constants.TIMEOUT_KEY&#125;); this.clients = clients; // get version. this.version = url.getParameter(Constants.VERSION_KEY, \"0.0.0\"); this.invokers = invokers; &#125;&#125; è¿œç¨‹è°ƒç”¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475+--- DubboInvoker@Override protected Result doInvoke(final Invocation invocation) throws Throwable &#123; RpcInvocation inv = (RpcInvocation) invocation; // 1 è·å¾—å½“å‰è°ƒç”¨çš„æ–¹æ³•å final String methodName = RpcUtils.getMethodName(invocation); // 2 å‘Invocationä¸­æ·»åŠ é™„åŠ ä¿¡æ¯ï¼Œè¿™é‡Œå°†URLçš„pathï¼ˆæœåŠ¡åï¼‰ï¼Œversion æ·»åŠ åˆ° attachment ä¸­ inv.setAttachment(Constants.PATH_KEY, getUrl().getPath()); inv.setAttachment(Constants.VERSION_KEY, version); // 3 é€‰æ‹©ä¸€ä¸ªè¿œç¨‹é€šä¿¡å®¢æˆ·ç«¯ ExchangeClient ExchangeClient currentClient; // é»˜è®¤æ˜¯å•ä¸€é•¿è¿æ¥ if (clients.length == 1) &#123; currentClient = clients[0]; &#125; else &#123; currentClient = clients[index.getAndIncrement() % clients.length]; &#125; // 4 è¿œç¨‹è°ƒç”¨ try &#123; // 4.1 åˆ¤æ–­æ˜¯å¦å¼‚æ­¥è°ƒç”¨ boolean isAsync = RpcUtils.isAsync(getUrl(), invocation); // 4.2 åˆ¤æ–­æ˜¯å¦å•å‘è°ƒç”¨ boolean isOneway = RpcUtils.isOneway(getUrl(), invocation); // 4.3 æ ¹æ®è°ƒç”¨çš„æ–¹æ³•åç§°å’Œé…ç½®è·å–æ­¤æ¬¡è°ƒç”¨çš„è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œé»˜è®¤æ˜¯ 1s int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT); /** * - å‘é€ oneway è¯·æ±‚çš„æ–¹å¼æ˜¯send() æ–¹æ³•ï¼Œè€Œåé¢å‘é€ twoway è¯·æ±‚çš„æ–¹å¼æ˜¯ request() æ–¹æ³• * - request() æ–¹æ³•ä¼šç›¸åº”åœ°åˆ›å»º DefaultFuture å¯¹è±¡ä»¥åŠæ£€æµ‹è¶…æ—¶çš„å®šæ—¶ä»»åŠ¡ï¼Œè€Œ send() æ–¹æ³•åˆ™ä¸ä¼šåˆ›å»ºè¿™äº›ä¸œè¥¿ï¼Œå®ƒæ˜¯ç›´æ¥å°† Invocation åŒ…è£…æˆ oneway ç±»å‹çš„ Request å‘é€å‡ºå» */ // 4.4 å•å‘è°ƒç”¨ï¼Œä¸éœ€è¦å…³æ³¨è¿”å›å€¼çš„è¯·æ±‚ if (isOneway) &#123; boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false); // æ³¨æ„ï¼Œè°ƒç”¨çš„æ˜¯ ExchangeClient#send(invocation, sent) æ–¹æ³• currentClient.send(inv, isSent); // è®¾ç½® RpcContext.future = null ï¼Œæ— éœ€å¼‚æ­¥å›è°ƒ RpcContext.getContext().setFuture(null); // è¿”å› ç©ºç»“æœ return new RpcResult(); // 4.5 å¼‚æ­¥è°ƒç”¨ï¼Œéœ€è¦å…³æ³¨è¿”å›å€¼çš„è¯·æ±‚ &#125; else if (isAsync) &#123; /** * è°ƒç”¨ ExchangeClient#request(invocation, timeout) æ–¹æ³•ï¼Œå‘é€è¯·æ±‚ * DefaultFutureæ˜¯ResponseFutureçš„å®ç°ç±»ï¼Œå®é™…ä¸Šè¿™é‡Œè¿”å›çš„å°±æ˜¯DefaultFutureå®ä¾‹ï¼Œè€Œè¯¥å®ä¾‹å°±æ˜¯HeaderExchangeChannel.request(Object request, int timeout)è¿”å›çš„futureå®ä¾‹ */ ResponseFuture future = currentClient.request(inv, timeout); /** * 1 è°ƒç”¨ RpcContext#setFuture(future) æ–¹æ³•ï¼Œåœ¨éœ€è¦çš„æ—¶å€™å¯ä»¥ä½¿ç”¨ Future è¿›è¡Œå›è°ƒã€‚ * 2 å°†DefaultFuture å¯¹è±¡å°è£…åˆ° FutureAdapterå®ä¾‹ä¸­ï¼Œå¹¶å°† FutureAdapterå®ä¾‹è®¾ç½®åˆ°RpcContext ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨éœ€è¦çš„åœ°æ–¹å–å‡ºä½¿ç”¨ ã€åœ¨åˆé€‚çš„åœ°æ–¹è°ƒç”¨ getæ–¹æ³•ã€‘ * 3 FutureAdapter æ˜¯ä¸€ä¸ªé€‚é…å™¨ï¼Œç”¨äºå°† Dubbo ä¸­çš„ ResponseFuture ä¸ JDK ä¸­çš„ Future è¿›è¡Œé€‚é…ï¼Œè¿™æ ·å½“ç”¨æˆ·çº¿ç¨‹è°ƒç”¨ Future çš„ get æ–¹æ³•æ—¶ï¼Œç»è¿‡ FutureAdapter é€‚é…ï¼Œæœ€ç»ˆä¼šè°ƒç”¨ ResponseFuture å®ç°ç±»å¯¹è±¡çš„ get æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯ DefaultFuture çš„ get æ–¹æ³• */ RpcContext.getContext().setFuture(new FutureAdapter&lt;Object&gt;(future)); // è¿”å› ç©ºç»“æœ return new RpcResult(); // 4.6 åŒæ­¥è°ƒç”¨ &#125; else &#123; // è®¾ç½® RpcContext.future = nullï¼Œæ— éœ€å¼‚æ­¥å›è°ƒ RpcContext.getContext().setFuture(null); /** * 1 è°ƒç”¨ ExchangeClient#request(invocation, timeout) æ–¹æ³•ï¼Œå‘é€è¯·æ±‚ * 2 ç”¨ ResponseFuture#get() æ–¹æ³•ï¼Œé˜»å¡ç­‰å¾…è¿”å›ç»“æœ */ return (Result) currentClient.request(inv, timeout).get(); &#125; &#125; catch (TimeoutException e) &#123; throw new RpcException(RpcException.TIMEOUT_EXCEPTION, \"Invoke remote method timeout. method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; catch (RemotingException e) &#123; throw new RpcException(RpcException.NETWORK_EXCEPTION, \"Failed to invoke remote method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; DubboInvoker.doInvoke() æ–¹æ³•æ˜¯è°ƒç”¨æ–¹ä½¿ç”¨ ExchangeClient å‘æœåŠ¡æä¾›æ–¹å‘èµ·è¯·æ±‚çš„å…¥å£ï¼Œä¸‹é¢å¯¹è¯¥è¿‡ç¨‹è¿›è¡Œåˆ†æï¼š å‘ Invocation è°ƒç”¨ä¿¡æ¯ä¸­æ·»åŠ  pathã€version å±æ€§ã€‚ è·å–å½“å‰è°ƒç”¨çš„è¶…æ—¶æ—¶é—´ï¼Œé»˜è®¤æ˜¯ 1s ã€‚åŒå‘è°ƒç”¨æ—¶æ˜¯è°ƒç”¨ç«¯æœ€å¤§ç­‰å¾…æ—¶é•¿ï¼Œå¦åˆ™æŠ›å‡ºè¯·æ±‚è¶…æ—¶å¼‚å¸¸ã€‚ åˆ¤æ–­è°ƒç”¨æ¨¡å¼ï¼Œå•å‘è°ƒç”¨ or å¼‚æ­¥è°ƒç”¨ or åŒæ­¥è°ƒç”¨ã€‚ å•å‘è°ƒç”¨ï¼šä½¿ç”¨ ExchangeClient.send æ–¹æ³•ï¼Œæ— éœ€å…³æ³¨è¿”å›å€¼ã€‚RpcContext ä¸­çš„ Future ç½®ç©ºï¼Œæ— éœ€å¼‚æ­¥å›è°ƒã€‚ å¼‚æ­¥è°ƒç”¨ï¼šä½¿ç”¨ ExchangeClient.request æ–¹æ³•ï¼Œè°ƒç”¨æ—¶ä¼ å…¥è¶…æ—¶æ—¶é—´ï¼Œä½œä¸ºè°ƒç”¨æ–¹æœ€å¤§ç­‰å¾…æ—¶é•¿ã€‚è¿”å›ç»“æœ ResponseFuture ä½œä¸º RpcContext ä¸­çš„ Future ï¼Œåœ¨éœ€è¦çš„æ—¶å€™å¯ä»¥å–å‡º Future è¿›è¡Œå›è°ƒã€‚ åŒæ­¥è°ƒç”¨ï¼šå’Œå¼‚æ­¥è°ƒç”¨ç±»ä¼¼ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯ï¼ŒåŒæ­¥è°ƒç”¨æ˜¯æ‹¿åˆ°è¿”å›çš„ ResponseFuture åç«‹å³è°ƒç”¨å…¶ get() è¿›è¡Œè°ƒç”¨ç»“æœçš„è·å–ï¼Œåœ¨ç»“æœæ²¡æœ‰è¿”å›æ—¶å°†é˜»å¡ä¸šåŠ¡çº¿ç¨‹ã€‚ Invoker çŠ¶æ€1234567891011121314151617181920+--- DubboInvoker @Override public boolean isAvailable() &#123; // å½“å‰ Invoker çš„çŠ¶æ€ - æ˜¯å¦å¯ç”¨ if (!super.isAvailable()) &#123; return false; &#125; for (ExchangeClient client : clients) &#123; /** * å³ä½¿Clientå¤„äºè¿æ¥ä¸­ï¼Œä½†å¦‚æœ Server å¤„äºæ­£åœ¨å…³é—­ä¸­ï¼Œè¿æ¥ä¹Ÿæ˜¯ä¸å¯ç”¨çš„ï¼Œå³æœåŠ¡ç«¯å¹¿æ’­å®¢æˆ·ç«¯ READONLY_EVENT äº‹ä»¶ * * &#123;@link HeaderExchangeServer#sendChannelReadOnlyEvent()&#125; */ if (client.isConnected() &amp;&amp; !client.hasAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY)) &#123; //cannot write == not Available ? return true; &#125; &#125; return false; &#125; DubboInvoker.isAvailable() æ–¹æ³•ç”¨äºæ£€æŸ¥å½“å‰ DubboInvoker æ˜¯å¦å¯ç”¨ï¼Œæ˜¯å¦å¯ä»¥ä½“ç°å¦‚ä¸‹ï¼š å½“å‰ Invoker çš„çŠ¶æ€æ˜¯å¦æ˜¯å¯ç”¨çš„ å½“å‰ Invoker å°è£…çš„è¿æ¥æ˜¯å¦æœ‰å¯ç”¨çš„ å½“å‰ Invoker å°è£…çš„è¿æ¥çš„å¯¹ç«¯æ˜¯å¦å…³é—­ï¼Œæ ¹æ®æ˜¯å¦å¹¿æ’­åªè¯»äº‹ä»¶ é”€æ¯ Invoker123456789101112131415161718192021222324252627282930313233343536373839+--- DubboInvoker @Override public void destroy() &#123; // å¦‚æœå·²ç»é”€æ¯ï¼Œåˆ™å¿½ç•¥ if (super.isDestroyed()) &#123; return; &#125; else &#123; // double check to avoid dup close // åŒé‡æ£€é”ï¼Œé¿å…å·²ç»é”€æ¯ destroyLock.lock(); try &#123; // å†æ¬¡æ£€æµ‹æ˜¯å¦é”€æ¯ if (super.isDestroyed()) &#123; return; &#125; // æ ‡è®° DubboInvoker é”€æ¯ super.destroy(); // ä»ç¼“å­˜ä¸­ç§»é™¤å½“å‰Invoker if (invokers != null) &#123; invokers.remove(this); &#125; // å…³é—­å½“å‰ Invoker ä¸­å°è£…çš„è¿æ¥ for (ExchangeClient client : clients) &#123; try &#123; // ç­‰å¾…æ—¶é•¿å†…å…³é—­ ExchangeClient client.close(ConfigUtils.getServerShutdownTimeout()); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125; finally &#123; // é‡Šæ”¾é” destroyLock.unlock(); &#125; &#125; &#125; é”€æ¯ DubboInvoker é¦–å…ˆè®¾ç½®è‡ªèº«çš„é”€æ¯çŠ¶æ€ï¼Œæ¥ç€å…³é—­å°è£…çš„è¿æ¥ã€‚ ç¼–è§£ç å™¨DubboProtocol çš„æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨éƒ½è®¾ç½®äº†ç¼–è§£ç  DubboCountCodecï¼Œå…³äºç¼–è§£ç å™¨å¯ä»¥å‚è€ƒ ç¼–è§£ç å™¨ ä¸€æ–‡ï¼Œè¿™é‡Œå°±ä¸å†é‡å¤è¯´æ˜ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« ä¸»è¦å¯¹ Dubbo åè®®ä¸‹çš„æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨çš„æ ¸å¿ƒæµç¨‹è¿›è¡Œäº†ä»‹ç»ã€‚æœåŠ¡æš´éœ²æ¶‰åŠåˆ° NIO æœåŠ¡çš„å¯åŠ¨ï¼ŒRpcInvocation å®ç°ï¼Œé€šé“å¤„ç†å™¨çš„å®ç°ä»¥åŠä¼˜åŒ–åºåˆ—å®ç°ã€‚æœç”¨å¼•ç”¨æ¶‰åŠåˆ° Client çš„åˆå§‹åŒ–ï¼ŒDubbo æ”¯æŒ å…±äº«è¿æ¥ å’Œ ç‹¬äº«è¿æ¥ï¼Œå…¶ä¸­ä½¿ç”¨ ReferenceCountExchangeClient å’Œ LazyConnectExchangeClient å¯¹ ExchangeClient è¿›è¡Œè£…é¥°ï¼Œåˆ†åˆ«å®ç°å…·æœ‰å¼•ç”¨è®¡æ•°åŠŸèƒ½å’Œå»¶æ—¶åˆå§‹åŒ–åŠŸèƒ½çš„å®¢æˆ·ç«¯ã€‚æ¥ç€å¯¹ç›¸å…³çš„é¢†åŸŸæ¨¡å‹ DubboExpoter å’Œ DubboInvoker è¿›è¡Œäº†ä»‹ç»ï¼Œè¿™ä¸¤ä¸ªæ˜¯éå¸¸é‡è¦çš„æ¨¡å‹ï¼Œä½œä¸ºæä¾›æ–¹æœåŠ¡æš´éœ²å®ç°å’Œæ¶ˆè´¹æ–¹æœåŠ¡å¼•ç”¨å®ç°ã€‚DubboProtocol ç›¸å…³çš„ç¼–è§£ç ç”±äºåœ¨ä¹‹å‰çš„æ–‡ç« ä¸­å·²ç»è¯¦ç»†è¯´æ˜ï¼Œå°±ä¸å†ä»‹ç»ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œåœ¨ Dubbo 2.7.x ç‰ˆæœ¬ä¸­è¿›è¡Œäº†å¼‚æ­¥åŒ–æ”¹é€ ï¼Œå¯¹æ¶ˆè´¹ç«¯å’Œæä¾›çš„è°ƒç”¨è¿›è¡Œäº†ä¼˜åŒ–ï¼Œå…³äºå·®å¼‚éƒ¨åˆ†ä¼šåœ¨åé¢çš„æ–‡ç« ä¸­å•ç‹¬è¯´æ˜ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Protocol","slug":"Protocol","permalink":"https://gentryhuang.com/tags/Protocol/"}]},{"title":"Dubboæºç åˆ†æ - å¤šåè®®æ¦‚è§ˆ","slug":"rpc/å¤šåè®®æ¦‚è§ˆ","date":"2020-08-24T16:00:00.000Z","updated":"2021-03-10T05:53:22.017Z","comments":false,"path":"posts/450e3eda/","link":"","permalink":"https://gentryhuang.com/posts/450e3eda/","excerpt":"","text":"å‰è¨€åœ¨åè®®å±‚æ€»è§ˆä¸­å¯¹Protocolå±‚è¿›è¡Œäº†æ€»ä½“ä»‹ç»ï¼Œå…¶ä¸­å¯¹ç›¸å…³çš„æ ¸å¿ƒåŒ…å’Œæ ¸å¿ƒç±»è¿›è¡Œäº†è¯´æ˜ã€‚æœ¬ç¯‡æ–‡ç« å°†å¯¹ Dubbo ä¸­çš„å¤šåè®®è¿›è¡Œæ¦‚è§ˆï¼Œåç»­æ–‡ç« ä¸­å°†å¯¹å…·ä½“åè®®å®ç°è¿›è¡Œä»‹ç»ã€‚ ProtocolProtocol æ¥å£ä¸­ä¸»è¦å®šä¹‰äº† export() å’Œ refer() æ–¹æ³•ï¼Œåˆ†åˆ«ç”¨äºæœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨ã€‚Protocol æ¥å£ç›¸å…³çš„ UML å›¾å¦‚ä¸‹ï¼š éœ€è¦è¯´æ˜çš„æ˜¯ï¼ŒProtocol çš„ RegistryProtocol å®ç°ç±»å¹¶æ²¡æœ‰åŒ…å«åœ¨å†…ï¼Œè™½ç„¶å®ƒä¸æ˜¯åè®®çš„ç›´æ¥ç›¸å…³å®ç°ç±»ï¼Œä½†å®ƒä¸å¯æˆ–ç¼ºã€‚å®ƒæ˜¯æœåŠ¡æä¾›è€…ã€æœåŠ¡æ¶ˆè´¹è€…ä»¥åŠæ³¨å†Œä¸­å¿ƒä¹‹é—´çš„çº½å¸¦ã€‚ Protocol æ¥å£å…·ä½“å®šä¹‰å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@SPI(\"dubbo\")public interface Protocol &#123; /** * é»˜è®¤ç«¯å£ * Get default port when user doesn't config the port. * * @return default port */ int getDefaultPort(); /** * å°†ä¸€ä¸ª Invoker æš´éœ²å‡ºå» &lt;br&gt; * 1. æ¥æ”¶åˆ°è¯·æ±‚åï¼Œåè®®åº”è¯¥è®°å½•è¯·æ±‚æºåœ°å€: RpcContext.getContext().setRemoteAddress();&lt;br&gt; * 2. export()å¿…é¡»æ˜¯å¹‚ç­‰çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æš´éœ²ç›¸åŒçš„URLæ—¶ï¼Œè°ƒç”¨ä¸€æ¬¡å’Œè°ƒç”¨ä¸¤æ¬¡æ²¡æœ‰åŒºåˆ« &lt;br&gt; * 3. Invoker æ˜¯ç”±æ¡†æ¶ä¼ å…¥çš„ï¼Œåè®®ä¸éœ€è¦å…³å¿ƒ &lt;br&gt; * * @param &lt;T&gt; Service type * @param invoker Service invoker * @return exporter reference for exported service, useful for unexport the service later * @throws RpcException thrown when error occurs during export the service, for example: port is occupied */ @Adaptive &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException; /** * å¼•ç”¨ä¸€ä¸ª Invoker &lt;br&gt; * 1. åè®®çš„è´£ä»»æ˜¯æ ¹æ®å‚æ•°è¿”å›ä¸€ä¸ª Invoker å¯¹è±¡ï¼Œç”± refer() æ–¹æ³•è¿”å›ã€‚&lt;br&gt; * 2. Consumerç«¯å¯ä»¥é€šè¿‡è¿™ä¸ªInvokerè¯·æ±‚åˆ°Providerç«¯çš„æœåŠ¡. &lt;br&gt; * * @param &lt;T&gt; Service type * @param type Service class * @param url URL address for the remote service * @return invoker service's local proxy * @throws RpcException when there's any error while connecting to the service provider */ @Adaptive &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException; /** * é‡Šæ”¾å½“å‰ Protocol å¯¹è±¡åº•å±‚å ç”¨çš„èµ„æº &lt;br&gt; * 1. é”€æ¯export()æ–¹æ³•ä»¥åŠrefer()æ–¹æ³•ä½¿ç”¨åˆ°çš„Invokerå¯¹è±¡ &lt;br&gt; * 2. é‡Šæ”¾æ‰€æœ‰å ç”¨èµ„æº, å¦‚: è¿æ¥, ç«¯å£, ç­‰ç­‰. &lt;br&gt; * 3. åè®®å¯ä»¥ç»§ç»­å¯¼å‡ºå’Œå¼•ç”¨æ–°çš„æœåŠ¡ï¼Œå³ä½¿å®ƒè¢«é”€æ¯ã€‚ */ void destroy();&#125; åœ¨ Protocol æ¥å£çš„å®ç°ä¸­ï¼Œexport() æ–¹æ³•å¹¶ä¸æ˜¯ç®€å•åœ°å°† Invoker å¯¹è±¡åŒ…è£…æˆ Exporter å¯¹è±¡è¿”å›ï¼Œè¯¥è¿‡ç¨‹è¿˜ä¼šæ¶‰åŠä»£ç†å¯¹è±¡çš„åˆ›å»ºã€åº•å±‚ Server çš„å¯åŠ¨ç­‰æ“ä½œã€‚refer() æ–¹æ³•é™¤äº†æ ¹æ®ä¼ å…¥çš„æœåŠ¡æ¥å£ä»¥åŠURLå‚æ•°æŸ¥è¯¢ Invoker ä¹‹å¤–ï¼Œè¿˜ä¼šæ¶‰åŠåˆ° Client çš„åˆ›å»ºç­‰æ“ä½œã€‚Protocol æ¥å£çš„ç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä»ä¸Šå›¾çš„ Protocol æ¥å£çš„ç»§æ‰¿å…³ç³»å›¾å¯ä»¥å‘ç°ï¼Œå…·ä½“åè®®å®ç°æœ‰ä¸¤ä¸ªåˆ†æ”¯ï¼šä»¥ AbstractProtocol ä¸ºä¸€æ”¯çš„åè®®å®ç°ï¼Œä»¥ AbstractProxyProtocol ä¸ºå¦ä¸€æ”¯çš„åè®®å®ç°ã€‚ä»æ•´ä½“ä¸Šçœ‹è¿™ä¸¤ä¸ªåˆ†æ”¯ä½“ç°äº† Dubbo çš„å¤šåè®®ï¼Œåé¢ä¼šè¯¦ç»†è¯´æ˜ã€‚ AbstractProtocol1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public abstract class AbstractProtocol implements Protocol &#123; protected final Logger logger = LoggerFactory.getLogger(getClass()); /** * ç”¨äºå­˜å‚¨æš´éœ²å‡ºå»çš„æœåŠ¡é›†åˆï¼ˆåŒ…æ‹¬ injvm åè®®æš´éœ²çš„æœåŠ¡ï¼‰ * 1 key: æœåŠ¡é”®ï¼Œ&#123;@link #serviceKey(URL)&#125; æˆ–è€… &#123;@link URL#getServiceKey()&#125;,ä¸åŒåè®®ä¼šæœ‰æ‰€å·®åˆ«ï¼š * - InjvmProtocolä½¿ç”¨ URL#getServicekey() * - DubboProtocolä½¿ç”¨ #serviceKey(URL) * 2 value: æœåŠ¡é”®å¯¹åº”çš„ Exporter å¯¹è±¡ */ protected final Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap = new ConcurrentHashMap&lt;String, Exporter&lt;?&gt;&gt;(); /** * æœåŠ¡å¼•ç”¨é›†åˆ */ protected final Set&lt;Invoker&lt;?&gt;&gt; invokers = new ConcurrentHashSet&lt;Invoker&lt;?&gt;&gt;(); /** * è·å–æœåŠ¡å¥ * * @param url * @return */ protected static String serviceKey(URL url) &#123; // ç»‘å®šç«¯å£ int port = url.getParameter(Constants.BIND_PORT_KEY, url.getPort()); return serviceKey( port, // ç«¯å£ url.getPath(),// æœåŠ¡æ¥å£å…¨è·¯å¾„å url.getParameter(Constants.VERSION_KEY), // æœåŠ¡ç‰ˆæœ¬ url.getParameter(Constants.GROUP_KEY)); // åˆ†ç»„å &#125; /** * è·å–æœåŠ¡é”® * * @param port ç«¯å£ * @param serviceName æœåŠ¡å * @param serviceVersion æœåŠ¡ç‰ˆæœ¬ * @param serviceGroup åˆ†ç»„å * @return */ protected static String serviceKey(int port, String serviceName, String serviceVersion, String serviceGroup) &#123; return ProtocolUtils.serviceKey(port, serviceName, serviceVersion, serviceGroup); &#125; /** * 1 é”€æ¯å…¨éƒ¨çš„æœåŠ¡å¼•ç”¨ * 2 é”€æ¯å‘å¸ƒå‡ºå»çš„æœåŠ¡ */ @Override public void destroy() &#123; // é”€æ¯åè®®å¯¹åº”çš„æœåŠ¡æ¶ˆè´¹è€…çš„æ‰€æœ‰ Invokerï¼Œ // å¦‚ï¼š å¦‚æœæ˜¯Dubboåè®®ï¼Œé‚£ä¹ˆè¿™é‡Œçš„æœåŠ¡æ¶ˆè´¹è€…çš„æ‰€æœ‰Invokeråˆ™ä¸º DubboInvoker for (Invoker&lt;?&gt; invoker : invokers) &#123; if (invoker != null) &#123; invokers.remove(invoker); try &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Destroy reference: \" + invoker.getUrl()); &#125; invoker.destroy(); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125; // é”€æ¯åè®®å¯¹åº”çš„æœåŠ¡æä¾›è€…çš„æ‰€æœ‰Exporter // å¦‚ï¼šå¦‚æœæ˜¯Dubboåè®®ï¼Œé‚£ä¹ˆè¿™é‡Œçš„æœåŠ¡æä¾›è€…çš„æ‰€æœ‰Exporteråˆ™ä¸º DubboExporter for (String key : new ArrayList&lt;String&gt;(exporterMap.keySet())) &#123; Exporter&lt;?&gt; exporter = exporterMap.remove(key); if (exporter != null) &#123; try &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Unexport service: \" + exporter.getInvoker().getUrl()); &#125; exporter.unexport(); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125; &#125;&#125; AbstractProtocol å®ç°äº† Protocol ï¼Œæä¾›äº†ä¸€äº› Protocol å®ç°æ‰€éœ€çš„å…¬å…±æ–¹æ³•åŠå­—æ®µï¼Œæ¦‚æ‹¬å¦‚ä¸‹ï¼š 1 å­˜å‚¨æš´éœ²æœåŠ¡çš„ Map 2 å­˜å‚¨æœåŠ¡å¼•ç”¨çš„ Set 3 è·å–æœåŠ¡é”®æ–¹æ³•ï¼ˆInjvm æ‰€éœ€æœåŠ¡é”®éè¿™é‡Œçš„æ–¹æ³•ï¼Œå¹¶ä¸”ä¸¤è€…æœåŠ¡é”®æ„æˆæœ‰æ‰€å·®åˆ«ï¼‰ 4 é‡Šæ”¾åè®®åº•å±‚å ç”¨èµ„æº æœåŠ¡é”®æ ¼å¼å¦‚ä¸‹ï¼š Injvm åè®®ä¸­çš„æœåŠ¡é”®æ ¼å¼å¦‚ä¸‹ï¼š AbstractProxyProtocolAbstractProxyProtocol ç»§æ‰¿äº† AbstractProtocol æŠ½è±¡ç±»ï¼Œä»å‘½åå°±å¯ä»¥çœ‹å‡ºè¯¥ç±»æ˜¯ä¸€ä¸ªä»£ç†åè®®ç±»ï¼Œå…¶æœ¬èº«åŠå…¶å®ç°æœ¬è´¨ä¸Šå¹¶æ²¡æœ‰å•ç‹¬å®ç°ä¸€å¥—åè®®ï¼Œè€Œæ˜¯ä½¿ç”¨ HTTP åè®®è¿›è¡Œé€šä¿¡ã€‚ å±æ€§1234567891011121314151617181920212223242526272829303132public abstract class AbstractProxyProtocol extends AbstractProtocol &#123; /** * éœ€è¦æŠ›å‡ºçš„å¼‚å¸¸ç±»é›†åˆï¼Œè¯¦ç»†: &#123;@link #doRefer(Class, URL)&#125; æ–¹æ³• */ private final List&lt;Class&lt;?&gt;&gt; rpcExceptions = new CopyOnWriteArrayList&lt;Class&lt;?&gt;&gt;(); /** * ä»£ç†å·¥å‚ - IOCæ³¨å…¥ */ private ProxyFactory proxyFactory; public AbstractProxyProtocol() &#123; &#125; public AbstractProxyProtocol(Class&lt;?&gt;... exceptions) &#123; for (Class&lt;?&gt; exception : exceptions) &#123; addRpcException(exception); &#125; &#125; public void addRpcException(Class&lt;?&gt; exception) &#123; this.rpcExceptions.add(exception); &#125; public ProxyFactory getProxyFactory() &#123; return proxyFactory; &#125; public void setProxyFactory(ProxyFactory proxyFactory) &#123; this.proxyFactory = proxyFactory; &#125;&#125; AbstractProxyProtocol ä¸­çš„ proxyFactory ç”¨äºä¸ºä¼ å…¥çš„ Invoker åˆ›å»ºä»£ç†å¯¹è±¡ï¼Œå¹¶ä¸”æ”¯æŒå°†æœåŠ¡å®ä¾‹å°è£…æˆ Invoker ã€‚rpcExceptions ç”¨äºä¿å­˜å½“å‰åè®®æŒ‡å®šçš„å¼‚å¸¸ï¼Œæ‰§è¡Œ RPC è°ƒç”¨å‡ºç°å¼‚å¸¸æ—¶ï¼Œå¦‚æœå¼‚å¸¸æ˜¯åè®®å¯¹åº”çš„å¼‚å¸¸ï¼Œåˆ™æŠ›å‡ºå½“å‰å¼‚å¸¸ã€‚ æœåŠ¡æš´éœ²123456789101112131415161718192021222324252627282930313233343536373839404142434445464748+--- AbstractProxyProtocol /** * æœåŠ¡æš´éœ² * * @param invoker Service invoker * @param &lt;T&gt; * @return * @throws RpcException */ @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; invoker) throws RpcException &#123; // è·å¾—æœåŠ¡é”® final String uri = serviceKey(invoker.getUrl()); // è·å¾—æœåŠ¡å¥å¯¹åº”çš„ Exporter å¯¹è±¡ï¼Œè‹¥å·²ç»æš´éœ²ï¼Œç›´æ¥è¿”å› Exporter&lt;T&gt; exporter = (Exporter&lt;T&gt;) exporterMap.get(uri); if (exporter != null) &#123; return exporter; &#125; // é€šè¿‡ ProxyFactory åˆ›å»ºä»£ç†å¯¹è±¡ï¼Œå°† Invoker å°è£…æˆä¸šåŠ¡æ¥å£çš„ä»£ç†å¯¹è±¡ã€‚ final Runnable runnable = doExport(proxyFactory.getProxy(invoker, true), invoker.getInterface(), invoker.getUrl()); // åˆ›å»º Exporter å¯¹è±¡ exporter = new AbstractExporter&lt;T&gt;(invoker) &#123; /** * åŸºäº AbstractExporter æŠ½è±¡ç±»è¦†å†™ unexportæ–¹æ³•ï¼Œä¼šè°ƒç”¨ Runnable */ @Override public void unexport() &#123; // å–æ¶ˆæœåŠ¡æš´éœ² super.unexport(); // ä»ç¼“å­˜ä¸­ç§»é™¤å¯¹åº”çš„ Exporter exporterMap.remove(uri); // doExport()æ–¹æ³•è¿”å›çš„ Runnable æ˜¯ä¸€ä¸ªå›è°ƒï¼Œå…¶ä¸­ä¼šé”€æ¯åº•å±‚çš„ Serverã€‚ if (runnable != null) &#123; try &#123; runnable.run(); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125; &#125;; // æ·»åŠ åˆ° Exporter é›†åˆä¸­ exporterMap.put(uri, exporter); return exporter; &#125; AbstractProxyProtocol è¿›è¡ŒæœåŠ¡æš´éœ²æ—¶ï¼Œä¼šé€šè¿‡å­ç±»å®ç°çš„ doExport() æ–¹æ³•å¯åŠ¨åº•å±‚æœåŠ¡ï¼Œä»¥æ¥æ”¶ HTTP è¯·æ±‚ï¼Œè¯·æ±‚çš„å¤„ç†äº¤ç»™ä»£ç†å¯¹è±¡ï¼Œå…·ä½“çš„ HTTP æœåŠ¡å™¨å®ç°å–å†³äºå…·ä½“å­ç±»å®ç°ã€‚ä¸‹é¢å¯¹æœåŠ¡æš´éœ²è¿‡ç¨‹è¿›è¡Œç®€å•æ¦‚è¿°ï¼š æ ¹æ®æœåŠ¡å¥æ£€æŸ¥ Exporter ç¼“å­˜ï¼Œåˆ¤æ–­æ˜¯å¦å·²ç»æš´éœ²è¿‡æœåŠ¡ã€‚ ç¼“å­˜æ²¡æœ‰å‘½ä¸­åˆ™è°ƒç”¨ ProxyFactory.getProxy() æ–¹æ³•å°† Invoker å°è£…æˆä¸šåŠ¡æ¥å£çš„ä»£ç†å¯¹è±¡ï¼Œè¿™é‡Œç»Ÿä¸€å¯¹æ³›åŒ–è¿›è¡Œäº†æ”¯æŒï¼Œä»£ç†å¯¹è±¡è´Ÿè´£å¯¹è¯·æ±‚çš„å¤„ç†ã€‚ é€šè¿‡ AbstractProxyProtocol çš„å­ç±»å®ç°çš„ doExport() æ–¹æ³•å¯åŠ¨åº•å±‚çš„æœåŠ¡ï¼Œè¿™ä¸ªåº•å±‚æœåŠ¡å¯ä»¥æ˜¯ Servletã€Tomcatï¼ŒJettyã€‚ åˆ›å»º AbstractExporter åŒ¿åå¯¹è±¡ï¼Œè¿›è¡ŒæœåŠ¡æš´éœ²ï¼Œä¸”åŸºäº AbstractExporter æŠ½è±¡ç±»è¦†å†™ unexportæ–¹æ³•ï¼Œè°ƒç”¨ Runnable ä»¥é”€æ¯åº•å±‚çš„ Serverã€‚ æœåŠ¡å¼•ç”¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354+--- AbstractProxyProtocol /** * æœåŠ¡å¼•ç”¨ * * @param type Service class * @param url URL address for the remote service * @param &lt;T&gt; * @return * @throws RpcException */ @Override public &lt;T&gt; Invoker&lt;T&gt; refer(final Class&lt;T&gt; type, final URL url) throws RpcException &#123; // æ‰§è¡Œå¼•ç”¨æœåŠ¡å¹¶é€šè¿‡ä»£ç†å·¥å‚è·å–å¯¹åº”çš„ Invoker å¯¹è±¡ final Invoker&lt;T&gt; target = proxyFactory.getInvoker(doRefer(type, url), type, url); // åˆ›å»º Invoker åŒ¿åå¯¹è±¡ Invoker&lt;T&gt; invoker = new AbstractInvoker&lt;T&gt;(type, url) &#123; /** * è¦†å†™ doInvoke æ–¹æ³• * @param invocation * @return * @throws Throwable */ @Override protected Result doInvoke(Invocation invocation) throws Throwable &#123; try &#123; // æ‰§è¡ŒRPCè°ƒç”¨ Result result = target.invoke(invocation); // è‹¥æ‰§è¡Œå¼‚å¸¸ï¼Œå¹¶ä¸”æ˜¯éœ€è¦æŠ›å‡ºçš„å¼‚å¸¸ï¼Œåˆ™ç›´æ¥æŠ›å‡º Throwable e = result.getException(); if (e != null) &#123; for (Class&lt;?&gt; rpcException : rpcExceptions) &#123; if (rpcException.isAssignableFrom(e.getClass())) &#123; throw getRpcException(type, url, invocation, e); &#125; &#125; &#125; return result; &#125; catch (RpcException e) &#123; // è‹¥æ˜¯æœªçŸ¥å¼‚å¸¸ï¼Œè·å¾—å¼‚å¸¸å¯¹åº”çš„é”™è¯¯ç  if (e.getCode() == RpcException.UNKNOWN_EXCEPTION) &#123; e.setCode(getErrorCode(e.getCause())); &#125; throw e; &#125; catch (Throwable e) &#123; // æŠ›å‡º RpcException å¼‚å¸¸ throw getRpcException(type, url, invocation, e); &#125; &#125; &#125;; // æ·»åŠ åˆ°Invoker é›†åˆ invokers.add(invoker); return invoker; &#125; AbstractProxyProtocol è¿›è¡ŒæœåŠ¡å¼•ç”¨æ—¶ï¼Œä¼šé€šè¿‡å­ç±»å®ç°çš„ doRefer() æ–¹æ³•è¿”å›è¿œç¨‹æœåŠ¡å¯¹è±¡ï¼Œä¸€èˆ¬æ˜¯ä¸ªä»£ç†å¯¹è±¡ï¼Œé€šè¿‡è¯¥å¯¹è±¡å¯ä»¥å‘èµ· HTTP è¯·æ±‚ã€‚æ¥ç€é€šè¿‡ ProxyFactory.getInvoker() æ–¹æ³•å°†è¿œç¨‹æœåŠ¡å¯¹è±¡å°è£…æˆä¸€ä¸ª Invoker å¯¹è±¡ï¼Œè¯¥å¯¹è±¡å…·å¤‡è°ƒç”¨è¿œç¨‹æœåŠ¡çš„èƒ½åŠ›ï¼Œå®¢æˆ·ç«¯çš„ä»£ç†å¯¹è±¡å°±æ˜¯ä½¿ç”¨è¯¥å¯¹è±¡çš„èƒ½åŠ›å‘èµ·è¿œç¨‹è°ƒç”¨çš„ã€‚ä¸‹é¢å¯¹æœåŠ¡å¼•ç”¨è¿‡ç¨‹è¿›è¡Œç®€å•æ¦‚è¿°ï¼š é€šè¿‡å­ç±»å®ç°çš„ doRefer() æ–¹æ³•è·å–è¿œç¨‹æœåŠ¡ï¼Œä¸€èˆ¬æ˜¯ä¸ªä»£ç†å¯¹è±¡ã€‚ è°ƒç”¨ ProxyFactory.getInvoker() æ–¹æ³•å¯¹è¿œç¨‹æœåŠ¡è¿›è¡Œå°è£…ï¼ŒåŒ…è£…æˆ Invoker å¯¹è±¡ã€‚ åˆ›å»ºä¸€ä¸ªåŒ¿å AbstractInvoker å¯¹è±¡ï¼Œå†…éƒ¨è°ƒç”¨é€»è¾‘ä½¿ç”¨çš„å°±æ˜¯ç¬¬ 2 æ­¥å°è£…çš„ Invoker çš„æ‰§è¡Œé€»è¾‘ã€‚ è¿”å›åˆ›å»ºçš„åŒ¿å AbstractInvoker å¯¹è±¡ã€‚ æœåŠ¡åœ°å€1234567891011121314151617+--- AbstractProxyProtocol /** * è·å–URLä¸­çš„ bind.ip å’Œ bind.port * * @param url * @return */ protected String getAddr(URL url) &#123; // å…ˆä»URLä¸­è·å–bind.ipçš„å€¼ä½œä¸ºipçš„å€¼ String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost()); // å¦‚æœURLä¸­è®¾ç½®äº†anyhostå±æ€§ï¼Œé‚£ä¹ˆipçš„å€¼å– 0.0.0.0 if (url.getParameter(Constants.ANYHOST_KEY, false)) &#123; bindIp = Constants.ANYHOST_VALUE; &#125; // è¿”å›ï¼š ip:port return NetUtils.getIpByHost(bindIp) + \":\" + url.getParameter(Constants.BIND_PORT_KEY, url.getPort()); &#125; è·å–æœåŠ¡åœ°å€çš„æ—¶å€™éœ€è¦æ³¨æ„ç»‘å®šåœ°å€å’Œæ³¨å†Œåœ°å€ï¼Œç»‘å®šåœ°å€æ˜¯å¯åŠ¨æœåŠ¡çš„åœ°å€ï¼Œæ³¨å†Œåœ°å€æ˜¯æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒï¼Œä¾›æ¶ˆè´¹è€…è¿›è¡ŒæœåŠ¡æŸ¥æ‰¾ã€‚ æ¨¡ç‰ˆæ–¹æ³•1234567891011121314151617181920212223+--- AbstractProxyProtocol /** * æ‰§è¡Œæš´éœ²ï¼Œå¹¶è¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable * * @param impl æœåŠ¡ Proxy å¯¹è±¡ * @param type æœåŠ¡æ¥å£ç±»å‹ * @param url URL * @param &lt;T&gt; æœåŠ¡æ¥å£ * @return å–æ¶ˆæœåŠ¡æš´éœ²çš„å›è°ƒ Runnable * @throws RpcException */ protected abstract &lt;T&gt; Runnable doExport(T impl, Class&lt;T&gt; type, URL url) throws RpcException; /** * æ‰§è¡Œå¼•ç”¨ï¼Œå¹¶è¿”å›è°ƒç”¨è¿œç¨‹æœåŠ¡çš„Service å¯¹è±¡ * * @param type æœåŠ¡æ¥å£ * @param url URL * @param &lt;T&gt; æœåŠ¡æ¥å£ * @return è°ƒç”¨è¿œç¨‹æœåŠ¡çš„Service å¯¹è±¡ * @throws RpcException */ protected abstract &lt;T&gt; T doRefer(Class&lt;T&gt; type, URL url) throws RpcException; AbstractProxyProtocol ä¸­çš„æ¨¡ç‰ˆæ–¹æ³•æœ‰ä¸¤ä¸ªï¼Œåˆ†åˆ«å®šä¹‰äº†æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨æ–¹æ³•ï¼Œå‰è€…ç”¨äºå¯åŠ¨HTTPæœåŠ¡ï¼Œåè€…ç”¨äºåˆ›å»ºè¿œç¨‹æœåŠ¡çš„ä»£ç†å¯¹è±¡ã€‚ é¢†åŸŸæ¨¡å‹AbstractExporter123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class AbstractExporter&lt;T&gt; implements Exporter&lt;T&gt; &#123; protected final Logger logger = LoggerFactory.getLogger(getClass()); /** * Invokerå¯¹è±¡ */ private final Invoker&lt;T&gt; invoker; /** * æ˜¯å¦å–æ¶ˆæœåŠ¡æš´éœ² */ private volatile boolean unexported = false; public AbstractExporter(Invoker&lt;T&gt; invoker) &#123; if (invoker == null) &#123; throw new IllegalStateException(\"service invoker == null\"); &#125; if (invoker.getInterface() == null) &#123; throw new IllegalStateException(\"service type == null\"); &#125; if (invoker.getUrl() == null) &#123; throw new IllegalStateException(\"service url == null\"); &#125; this.invoker = invoker; &#125; @Override public Invoker&lt;T&gt; getInvoker() &#123; return invoker; &#125; /** * å–æ¶ˆæœåŠ¡çš„æš´éœ² */ @Override public void unexport() &#123; // å·²ç»å–æ¶ˆæš´éœ²å°±ç›´æ¥è¿”å› if (unexported) &#123; return; &#125; // æ ‡è®°å·²ç»å–æ¶ˆæš´éœ² unexported = true; // é”€æ¯ getInvoker().destroy(); &#125;&#125; AbstractExporter æ˜¯å¯¹ Invoker çš„ç®€å•å°è£…ï¼Œå¹¶ä¸”å®ç°äº†å–æ¶ˆæœåŠ¡æš´éœ²çš„æ–¹æ³•ã€‚ AbstractInvokerAbstractInvoker ä¸»è¦æä¾›äº† Invoker çš„é€šç”¨å±æ€§å’Œ #invoke() æ–¹æ³•çš„é€šç”¨å®ç°ï¼Œå…·ä½“çš„å®ç°é€»è¾‘äº¤ç»™å­ç±»ã€‚ å±æ€§12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public abstract class AbstractInvoker&lt;T&gt; implements Invoker&lt;T&gt; &#123; protected final Logger logger = LoggerFactory.getLogger(getClass()); /** * è¯¥ Invoker å¯¹è±¡å°è£…çš„ä¸šåŠ¡æ¥å£ */ private final Class&lt;T&gt; type; /** * ä¸å½“å‰ Invoker å…³è”çš„ URL å¯¹è±¡ï¼Œå…¶ä¸­åŒ…å«äº†å…¨éƒ¨çš„é…ç½®ä¿¡æ¯ */ private final URL url; /** * å½“å‰ Invoker å…³è”çš„ä¸€äº›é™„åŠ ä¿¡æ¯ï¼Œè¿™äº›é™„åŠ ä¿¡æ¯å¯ä»¥æ¥è‡ªå…³è”çš„ URL. * å…±ç”¨çš„éšå¼ä¼ å‚ï¼Œåœ¨&#123;@link #invoke(Invocation)&#125;æ–¹æ³•ä¸­ä½¿ç”¨ */ private final Map&lt;String, String&gt; attachment; /** * å½“å‰ Invoker çš„çŠ¶æ€ - æ˜¯å¦å¯ç”¨ */ private volatile boolean available = true; /** * å½“å‰ Invoker çš„çŠ¶æ€ - æ˜¯å¦é”€æ¯ */ private AtomicBoolean destroyed = new AtomicBoolean(false); public AbstractInvoker(Class&lt;T&gt; type, URL url) &#123; this(type, url, (Map&lt;String, String&gt;) null); &#125; /** * è°ƒç”¨ convertAttachment() æ–¹æ³•ï¼Œä¼šä»å…³è”çš„ URL å¯¹è±¡è·å–æŒ‡å®šçš„ KV è®°å½•åˆ° attachment ä¸­ * * @param type * @param url * @param keys */ public AbstractInvoker(Class&lt;T&gt; type, URL url, String[] keys) &#123; this(type, url, convertAttachment(url, keys)); &#125; public AbstractInvoker(Class&lt;T&gt; type, URL url, Map&lt;String, String&gt; attachment) &#123; if (type == null) &#123; throw new IllegalArgumentException(\"service type == null\"); &#125; if (url == null) &#123; throw new IllegalArgumentException(\"service url == null\"); &#125; this.type = type; this.url = url; this.attachment = attachment == null ? null : Collections.unmodifiableMap(attachment); &#125;&#125; AbstractInvoker é€šç”¨å±æ€§åŒ…æ‹¬ï¼šä¸šåŠ¡æ¥å£ã€URLã€é™„åŠ å‚æ•°ä»¥åŠç”¨äºæ ‡è®°æœåŠ¡çŠ¶æ€çš„ä¸¤ä¸ªå­—æ®µã€‚ æ ‡è®°é”€æ¯12345678910+--- AbstractInvoker @Override public void destroy() &#123; // destroyed è®¾ç½®ä¸º true if (!destroyed.compareAndSet(false, true)) &#123; return; &#125; // available è®¾ç½®ä¸º false setAvailable(false); &#125; æœåŠ¡è°ƒç”¨12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667+--- AbstractInvoker @Override public Result invoke(Invocation inv) throws RpcException &#123; // if invoker is destroyed due to address refresh from registry, let's allow the current invoke to proceed if (destroyed.get()) &#123; logger.warn(\"Invoker for service \" + this + \" on consumer \" + NetUtils.getLocalHost() + \" is destroyed, \" + \", dubbo version is \" + Version.getVersion() + \", this invoker should not be used any longer\"); &#125; // 1 å°†ä¼ å…¥çš„ Invocation è½¬ä¸º RpcInvocation RpcInvocation invocation = (RpcInvocation) inv; // æ³¨æ„ï¼š æ‰§è¡Œåˆ°è¿™é‡Œæ˜¯çœŸæ­£çš„Invokerï¼Œä¹‹å‰çš„Invokeréƒ½æ˜¯å±‚å±‚åµŒå¥— invocation.setInvoker(this); // 2 å°† attachmenté›†åˆæ·»åŠ ä¸º Invocation çš„é™„åŠ ä¿¡æ¯ if (attachment != null &amp;&amp; attachment.size() &gt; 0) &#123; invocation.addAttachmentsIfAbsent(attachment); &#125; // 3 å°† RpcContext çš„é™„åŠ ä¿¡æ¯æ·»åŠ åˆ° Invocation çš„é™„åŠ ä¿¡æ¯ä¸­ã€‚æ³¨æ„ä½¿ç”¨RpcContextè¿›è¡Œéšå¼ä¼ å‚ã€‚ Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments(); if (contextAttachments != null &amp;&amp; contextAttachments.size() != 0) &#123; invocation.addAttachments(contextAttachments); &#125; // 4 å¦‚æœæ–¹æ³•æ˜¯å¼‚æ­¥çš„å°±è®¾ç½®å¼‚æ­¥æ ‡å¿— if (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false)) &#123; // 4.1 è®¾ç½®å¼‚æ­¥ä¿¡æ¯åˆ° RpcInvocation#attachment ä¸­ invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString()); &#125; // 4.2 å¦‚æœæ˜¯å¼‚æ­¥è°ƒç”¨ï¼Œç»™invocationçš„attachment æ·»åŠ ä¸€ä¸ª id å±æ€§ï¼Œå¹¶è®¾ç½®å”¯ä¸€IDå€¼ã€‚ RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation); try &#123; // 5 æ‰§è¡Œè°ƒç”¨ï¼Œç”±ä¸åŒåè®®å¯¹åº”å…·ä½“çš„å­ç±»å®ç° return doInvoke(invocation); &#125; catch (InvocationTargetException e) &#123; // biz exception Throwable te = e.getTargetException(); if (te == null) &#123; return new RpcResult(e); &#125; else &#123; if (te instanceof RpcException) &#123; ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION); &#125; return new RpcResult(te); &#125; &#125; catch (RpcException e) &#123; if (e.isBiz()) &#123; return new RpcResult(e); &#125; else &#123; throw e; &#125; &#125; catch (Throwable e) &#123; return new RpcResult(e); &#125; &#125; /** * å­ç±»å®ç°è°ƒç”¨é€»è¾‘ * * @param invocation * @return * @throws Throwable */ protected abstract Result doInvoke(Invocation invocation) throws Throwable; å°ç»“æœ¬ç¯‡æ–‡ç« ä¸»è¦å¯¹ Protocol çš„ç»§æ‰¿ä½“ç³»æŠ½è±¡éƒ¨åˆ†è¿›è¡Œäº†ä»‹ç»ï¼Œè¿™äº›æŠ½è±¡å®šä¹‰å¯ä»¥çœ‹ä½œæ˜¯å…·ä½“å®ç°çš„é€šç”¨é€»è¾‘å’Œå·¥å…·ã€‚åœ¨æ¥ä¸‹æ¥çš„å‡ ç¯‡æ–‡ç« ä¸­ä¼šå¯¹ä¸åŒçš„å®ç°è¿›è¡Œè¯¦ç»†åˆ†æã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Protocol","slug":"Protocol","permalink":"https://gentryhuang.com/tags/Protocol/"}]},{"title":"Dubboæºç åˆ†æ - æ³›åŒ–å®ç°","slug":"rpc/Dubboè¿‡æ»¤å™¨-æ³›åŒ–å®ç°","date":"2020-08-14T16:00:00.000Z","updated":"2021-02-22T06:01:32.390Z","comments":false,"path":"posts/bb5fc918/","link":"","permalink":"https://gentryhuang.com/posts/bb5fc918/","excerpt":"","text":"æ¦‚è¿°Dubbo ä¸­çš„æ³›åŒ–æ¥å£å®ç°ä¸»è¦ç”¨äºæœåŠ¡ç«¯æ²¡æœ‰ API æ¥å£åŠæ¨¡å‹ç±»å…ƒçš„æƒ…å†µï¼Œæ³›åŒ–å®ç°éœ€è¦å®ç° GenericService æ¥å£ã€‚è°ƒç”¨ç«¯åœ¨å¼•ç”¨æŸä¸ªæœåŠ¡æ—¶å¯ä»¥æŒ‡å®šé€šç”¨è°ƒç”¨ï¼ˆgenericé…ç½®é¡¹ï¼‰ï¼Œè¿›è€Œå¯ä»¥è°ƒç”¨è¯¥æœåŠ¡å¯¹åº”çš„æ³›åŒ–å®ç°ã€‚æœåŠ¡æ¶ˆè´¹ç«¯æ— éœ€å…³æ³¨æ³›åŒ–å®ç°çš„ç»†èŠ‚ï¼Œåªéœ€è¦å¼•ç”¨æœåŠ¡çš„æ—¶å€™æŒ‡å®šé€šç”¨è°ƒç”¨å³å¯ã€‚ åº”ç”¨åœºæ™¯é€šå¸¸ç”¨äºæ¡†æ¶é›†æˆï¼Œæ¯”å¦‚ï¼šå®ç°ä¸€ä¸ªé€šç”¨çš„è¿œç¨‹æœåŠ¡ Mock æ¡†æ¶ï¼Œå¯é€šè¿‡å®ç° GenericService æ¥å£å¤„ç†æ‰€æœ‰æœåŠ¡è¯·æ±‚ã€‚ ä½¿ç”¨ç¤ºä¾‹æœåŠ¡ç«¯æœåŠ¡ç«¯éœ€è¦å®ç° GenericService æ¥å£ä»¥å®ç°æ³›åŒ–åŠŸèƒ½ã€‚ æ³›åŒ–å®ç° 12345678910111213141516171819@Servicepublic class MyGenericService implements GenericService &#123; /** * æ³›åŒ–å®ç° * * @param method è°ƒç”¨ç«¯è°ƒç”¨çš„æ–¹æ³•å * @param parameterTypes æ–¹æ³•å‚æ•°ç±»å‹ * @param args å‚æ•°å€¼ * @return * @throws GenericException */ @Override public Object $invoke(String method, String[] parameterTypes, Object[] args) throws GenericException &#123; if (\"sayHello\".equals(method)) &#123; return \"print \" + args[0]; &#125; return \"not find method!\"; &#125;&#125; æœåŠ¡æš´éœ²1&lt;dubbo:service interface=\"com.code.dubbo.DemoService\" ref=\"myGenericService\"/&gt; è¯´æ˜ï¼šæ³›åŒ–å®ç°æš´éœ²å‡ºå»éœ€è¦ä¾æ‰˜å·²æœ‰çš„æœåŠ¡æ¥å£ï¼Œå°†æ¥å£çš„å®ç°è®¾ç½®æˆæ³›åŒ–å®ç°å³å¯ã€‚ æ¶ˆè´¹ç«¯ æœåŠ¡å¼•å…¥1&lt;dubbo:reference id=\"demoService\" interface=\"com.code.dubbo.DemoService\" generic=\"true\"/&gt; è¯´æ˜ï¼š æ¶ˆè´¹ç«¯éœ€è¦å¼•å…¥ interface é…ç½®é¡¹çš„ä¾èµ–ï¼Œå¹¶ä¸”è®¾ç½® generic å±æ€§ï¼Œä»¥æŒ‡å®šå¼•ç”¨çš„æœåŠ¡ä¸ºé€šç”¨è°ƒç”¨ã€‚ generic é…ç½®é¡¹æ”¯æŒè®¾ç½® trueã€nativejava ä»¥åŠ beanï¼Œåœ¨ Dubbo 2.7 ä¸­è¿˜æ”¯æŒäº† protobuf-json å’Œ raw.return ï¼Œç”¨äºå¯¹å‚æ•°è¿›è¡Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–ã€‚ æ¶ˆè´¹ç«¯è°ƒç”¨æœåŠ¡å’Œæ™®é€šçš„æ¶ˆè´¹è€…ä¸€æ‘¸ä¸€æ ·ã€‚ è¿œç¨‹è°ƒç”¨12DemoService demoService = (DemoService) applicationContext.getBean(\"demoService\");String result = demoService.sayHello(\"gentryhuang\"); GenericImplFilter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145@Activate(group = Constants.CONSUMER, value = Constants.GENERIC_KEY, order = 20000)public class GenericImplFilter implements Filter &#123; private static final Logger logger = LoggerFactory.getLogger(GenericImplFilter.class); /** * æ³›åŒ–å‚æ•°ç±»å‹ */ private static final Class&lt;?&gt;[] GENERIC_PARAMETER_TYPES = new Class&lt;?&gt;[]&#123;String.class, String[].class, Object[].class&#125;; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; // 1. è·å¾— generic é…ç½®é¡¹ String generic = invoker.getUrl().getParameter(Constants.GENERIC_KEY); // æ³›åŒ–å®ç°çš„è°ƒç”¨ - å®¢æˆ·ç«¯è°ƒç”¨çš„æœåŠ¡æ˜¯ GenericService if (ProtocolUtils.isGeneric(generic) // åˆ¤æ–­æ˜¯å¦å¼€å¯äº†æ³›åŒ–å¼•ç”¨ &amp;&amp; !Constants.$INVOKE.equals(invocation.getMethodName()) // æ–¹æ³•åé $invoke // è°ƒç”¨ä¿¡æ¯æ˜¯ RpcInvocation ç±»å‹ &amp;&amp; invocation instanceof RpcInvocation) &#123; // 2. åºåˆ—åŒ–å‚æ•° RpcInvocation invocation2 = (RpcInvocation) invocation; // è°ƒç”¨çš„æ–¹æ³•å String methodName = invocation2.getMethodName(); // å‚æ•°ç±»å‹åˆ—è¡¨ Class&lt;?&gt;[] parameterTypes = invocation2.getParameterTypes(); // å‚æ•°å€¼åˆ—è¡¨ Object[] arguments = invocation2.getArguments(); // å‚æ•°ç±»å‹ååˆ—è¡¨ String[] types = new String[parameterTypes.length]; for (int i = 0; i &lt; parameterTypes.length; i++) &#123; types[i] = ReflectUtils.getName(parameterTypes[i]); &#125; // 3. æ ¹æ® generic çš„å€¼é€‰æ‹©å¯¹åº”åºåˆ—åŒ–å‚æ•°çš„æ–¹å¼ Object[] args; // 3.1 generic == bean if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123; args = new Object[arguments.length]; for (int i = 0; i &lt; arguments.length; i++) &#123; // å°†å‚æ•°è¿›è¡Œè½¬æ¢ï¼š POJO -&gt; JavaBeanDescriptor args[i] = JavaBeanSerializeUtil.serialize(arguments[i], JavaBeanAccessor.METHOD); &#125; // 3.2 generic != bean &#125; else &#123; // å°†å‚æ•°è¿›è¡Œè½¬æ¢ï¼šPOJO -&gt; Map args = PojoUtils.generalize(arguments); &#125; // 4ã€é‡æ–°è®¾ç½®RPCè°ƒç”¨ä¿¡æ¯ï¼Œé€šè¿‡æ–°çš„PpcInvocationå°±èƒ½è°ƒç”¨åˆ°æ³›åŒ–å®ç°çš„æœåŠ¡ // 4.1 è®¾ç½®è°ƒç”¨æ–¹æ³•çš„åå­—ä¸º $invoke invocation2.setMethodName(Constants.$INVOKE); // 4.2 è®¾ç½®è°ƒç”¨æ–¹æ³•çš„å‚æ•°ç±»å‹ä¸º GENERIC_PARAMETER_TYPES invocation2.setParameterTypes(GENERIC_PARAMETER_TYPES); // 4.3 è®¾ç½®è°ƒç”¨æ–¹æ³•çš„å‚æ•°æ•°æ®ï¼Œåˆ†åˆ«ä¸ºæ–¹æ³•åï¼Œå‚æ•°ç±»å‹æ•°ç»„ï¼Œå‚æ•°æ•°ç»„ invocation2.setArguments(new Object[]&#123;methodName, types, args&#125;); // 5 æ–¹æ³•è°ƒç”¨ Result result = invoker.invoke(invocation2); // 6ã€ååºåˆ—åŒ–ç»“æœåŠå¼‚å¸¸ç»“æœå¤„ç† if (!result.hasException()) &#123; // è·å–è°ƒç”¨ç»“æœ Object value = result.getValue(); try &#123; // åå°„æ–¹æ³•å¯¹è±¡ Method method = invoker.getInterface().getMethod(methodName, parameterTypes); // generic=bean çš„æƒ…å†µï¼Œååºåˆ—åŒ–ï¼š JavaBeanDescriptor -&gt; ç»“æœ if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123; if (value == null) &#123; return new RpcResult(value); &#125; else if (value instanceof JavaBeanDescriptor) &#123; return new RpcResult(JavaBeanSerializeUtil.deserialize((JavaBeanDescriptor) value)); &#125; else &#123; throw new RpcException( \"The type of result value is \" + value.getClass().getName() + \" other than \" + JavaBeanDescriptor.class.getName() + \", and the result is \" + value); &#125; // generic = trueï¼Œååºåˆ—åŒ–ï¼š Map -&gt; Pojo &#125; else &#123; return new RpcResult(PojoUtils.realize(value, method.getReturnType(), method.getGenericReturnType())); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new RpcException(e.getMessage(), e); &#125; // å¼‚å¸¸ç»“æœå¤„ç† &#125; else if (result.getException() instanceof GenericException) &#123; GenericException exception = (GenericException) result.getException(); try &#123; String className = exception.getExceptionClass(); Class&lt;?&gt; clazz = ReflectUtils.forName(className); Throwable targetException = null; Throwable lastException = null; try &#123; // åˆ›å»ºå¼‚å¸¸å¯¹è±¡ targetException = (Throwable) clazz.newInstance(); &#125; catch (Throwable e) &#123; lastException = e; for (Constructor&lt;?&gt; constructor : clazz.getConstructors()) &#123; try &#123; targetException = (Throwable) constructor.newInstance(new Object[constructor.getParameterTypes().length]); break; &#125; catch (Throwable e1) &#123; lastException = e1; &#125; &#125; &#125; if (targetException != null) &#123; try &#123; Field field = Throwable.class.getDeclaredField(\"detailMessage\"); if (!field.isAccessible()) &#123; field.setAccessible(true); &#125; field.set(targetException, exception.getExceptionMessage()); &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; result = new RpcResult(targetException); &#125; else if (lastException != null) &#123; throw lastException; &#125; &#125; catch (Throwable e) &#123; throw new RpcException(\"Can not deserialize exception \" + exception.getExceptionClass() + \", message: \" + exception.getExceptionMessage(), e); &#125; &#125; return result; &#125; // çœç•¥æ³›åŒ–å¼•ç”¨çš„è°ƒç”¨ - GenericService è°ƒç”¨æœåŠ¡æ¥å£ // æ™®é€šè°ƒç”¨ return invoker.invoke(invocation); &#125; GenericImplFilter æ˜¯æœåŠ¡æ¶ˆè´¹ç«¯çš„è¿‡æ»¤å™¨ï¼Œä¸»è¦æ˜¯å¯¹ æ³›åŒ–å¼•ç”¨ å’Œ æ³›åŒ–å®ç° åœ¨è°ƒç”¨ç«¯çš„å¤„ç†ã€‚å…³äºæ³›åŒ–å¼•ç”¨éƒ¨åˆ†åœ¨æ³›åŒ–è°ƒç”¨ä¸­å·²ç»è¯¦ç»†è¯´æ˜ï¼Œä¸‹é¢å¯¹æ³›åŒ–å®ç°çš„é€»è¾‘è¿›è¡Œè¯´æ˜ï¼š è·å– generic é…ç½®é¡¹ï¼Œåˆ¤æ–­æ˜¯å¦å¼€å¯æ³›åŒ–å¼•ç”¨ã€‚ ä»è°ƒç”¨ä¿¡æ¯å¯¹è±¡ RpcInvocation ä¸­è·å–è°ƒç”¨çš„æ–¹æ³•åã€å‚æ•°ç±»å‹åˆ—è¡¨ã€å‚æ•°å€¼åˆ—è¡¨ã€‚ æ ¹æ® generic çš„å€¼é€‰æ‹©å¯¹åº”çš„åºåˆ—åŒ–æ–¹å¼å¯¹å‚æ•°è¿›è¡Œåºåˆ—åŒ–ã€‚ é‡ç½®è°ƒç”¨ä¿¡æ¯å¯¹è±¡ä¸­çš„æ–¹æ³•åã€æ–¹æ³•å‚æ•°ç±»å‹ã€æ–¹æ³•å‚æ•°ï¼Œæœ¬è´¨ä¸Šå°†æ™®é€šæ–¹æ³•è°ƒç”¨è½¬ä¸º $invoke æ–¹æ³•è°ƒç”¨ï¼Œé‡ç½®å®Œæˆåè¿›è¡Œæ–¹æ³•è°ƒç”¨ã€‚ å¯¹æ­£å¸¸ç»“æœè¿›è¡Œååºåˆ—åŒ–ï¼Œä»¥åŠæ ¹æ® GenericException å¼‚å¸¸ï¼Œåˆ›å»ºåŸå§‹å¼‚å¸¸ targetException å¹¶è¿”å›ç»™è°ƒç”¨ç«¯ã€‚ è¿™é‡Œéœ€è¦è¯´æ˜çš„æ˜¯ä¸Šè¿°çš„ç¬¬ 5 æ­¥ï¼Œä¸ºä»€ä¹ˆæ‰§è¡Œ invoker.invoke(invocation2) æ–¹æ³•å°±ä¼šè°ƒç”¨æ³›åŒ–å®ç° $invoke æ–¹æ³•ï¼Ÿ åŸå› å¦‚ä¸‹ï¼š æœåŠ¡æš´éœ²çš„è¿‡ç¨‹ç¡®å®šäº†æœåŠ¡å®ç°å¯¹è±¡å’ŒæœåŠ¡æ¥å£12345678910+--- ServiceConfig#doExport // æ£€æµ‹refæ˜¯å¦æ³›åŒ–æ¥å£çš„å®ç° if (ref instanceof GenericService) &#123; // è®¾ç½® interfaceClass ä¸º GenericService.class interfaceClass = GenericService.class; if (StringUtils.isEmpty(generic)) &#123; // è®¾ç½® generic = \"true\" generic = Boolean.TRUE.toString(); &#125; &#125; æ³¨æ„ï¼š è™½ç„¶æ¥å£è®¾ç½®ä¸ºäº† GenericService ï¼Œä½†æ˜¯ä¸å½±å“æœåŠ¡æš´éœ²ï¼ŒæœåŠ¡æš´éœ²çš„ URL ä¸­ä½¿ç”¨æ¥å£åè¡¨ç¤ºæœåŠ¡æ¥å£ä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯ interface çš„å€¼ã€‚ å°†æœåŠ¡å®ä¾‹å°è£…æˆ Invoker ,æœåŠ¡å®ä¾‹å°±æ˜¯ GenericService å®ä¾‹ã€‚12345678910111213/** * å°†ä¼ å…¥çš„æœåŠ¡å®ä¾‹å°è£…æˆInvoker * &lt;p&gt; * create invoker. * * @param &lt;T&gt; * @param proxy Serviceå¯¹è±¡ * @param type Serviceæ¥å£ç±»å‹ * @param url Serviceå¯¹åº”çš„Dubbo URL * @return invoker */@Adaptive(&#123;Constants.PROXY_KEY&#125;)&lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException; GenericFilterGenericFilter ä¸ä¼šç‰¹åˆ«å¤„ç†æ³›åŒ–å®ç°çš„è°ƒç”¨ï¼Œå°†è¿™ç§æƒ…å†µå½“ä½œæ™®é€šè°ƒç”¨å¯¹å¾…ã€‚ æ³›åŒ–å®ç°æµç¨‹å›¾ å°ç»“Dubbo æä¾›äº† GenericService æ¥å£ç”¨äºå®ç°æ³›åŒ–æœåŠ¡ï¼Œç”±äºæ³›åŒ–å®ç°å¯¹äºè°ƒç”¨ç«¯æ¥è¯´æ˜¯æ²¡æœ‰å…·ä½“æ¥å£çš„ï¼Œå› æ­¤æ³›åŒ–å®ç°å¿…é¡»ä¾æ‰˜ç°æœ‰çš„æœåŠ¡æ¥å£ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"}]},{"title":"Dubboæºç åˆ†æ - æ³›åŒ–è°ƒç”¨","slug":"rpc/Dubboè¿‡æ»¤å™¨-æ³›åŒ–è°ƒç”¨","date":"2020-08-12T14:59:38.000Z","updated":"2021-02-22T05:59:04.128Z","comments":false,"path":"posts/ffce7d6d/","link":"","permalink":"https://gentryhuang.com/posts/ffce7d6d/","excerpt":"","text":"æ¦‚è¿°Dubbo ä¸­çš„æ³›åŒ–è°ƒç”¨ä¸»è¦ç”¨äºå®¢æˆ·ç«¯æ²¡æœ‰ APIæ¥å£åŠæ¨¡å‹ç±»å…ƒ çš„æƒ…å†µã€‚å³å®¢æˆ·ç«¯åªéœ€æ ¹æ®æœåŠ¡ç«¯æä¾›çš„APIæ–‡æ¡£ï¼Œæ— éœ€å¼•å…¥ç›¸å…³æ¥å£ä¾èµ–ï¼Œç›´æ¥é€šè¿‡ GenericSerive æ¥å£æ¥å‘èµ·æœåŠ¡è°ƒç”¨ï¼Œå‚æ•°åŠè¿”å›å€¼ä¸­çš„æ‰€æœ‰ POJO å‡ä½¿ç”¨ Map è¡¨ç¤ºã€‚æ³›åŒ–è°ƒç”¨å¯¹äºæœåŠ¡æä¾›ç«¯æ˜¯æ— éœ€å…³æ³¨çš„ï¼ŒæŒ‰æ­£å¸¸æœåŠ¡æš´éœ²å³å¯ã€‚ åº”ç”¨åœºæ™¯æœåŠ¡æµ‹è¯•æ¡†æ¶æœåŠ¡æµ‹è¯•æ¡†æ¶æ˜¯ä½œä¸ºå„ä¸ª RPC æœåŠ¡çš„è°ƒç”¨ç«¯ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œè°ƒç”¨ç«¯æ˜¯éœ€è¦ä¾èµ–æœåŠ¡æä¾›æ–¹æ¥å£çš„ã€‚è€Œä½œä¸ºä¸€ä¸ªé€šç”¨çš„æµ‹è¯•æ¡†æ¶ä¸åº”è¯¥ä¾èµ–æ‰€æœ‰æœåŠ¡æä¾›æ–¹çš„æ¥å£ï¼Œä¸èƒ½å› ä¸ºæ¯å‘å¸ƒä¸€ä¸ªæ–°çš„æœåŠ¡å°±å‡çº§è¿™ä¸ªæµ‹è¯•æ¡†æ¶ã€‚è¿™æ—¶å°±éœ€è¦è®©è°ƒç”¨æ–¹åœ¨æ²¡æœ‰æœåŠ¡æä¾›æ–¹æ¥å£çš„æƒ…å†µä¸‹ï¼Œä»ç„¶å¯ä»¥æ­£å¸¸åœ°å‘èµ· RPC è°ƒç”¨ã€‚ æœåŠ¡ç½‘å…³å„ä¸ªä¸šåŠ¡æ–¹å¯ä»¥ä½¿ç”¨ HTTP çš„æ–¹å¼ï¼Œé€šè¿‡æœåŠ¡ç½‘å…³è°ƒç”¨å…¶å®ƒæœåŠ¡ã€‚è¿™ç§åœºæ™¯å’Œé€šç”¨çš„æœåŠ¡æµ‹è¯•æ¡†æ¶æœ‰åŒæ ·çš„é—®é¢˜ï¼Œä¸åº”è¯¥ä¹Ÿä¸èƒ½ä¾èµ–æ‰€æœ‰æœåŠ¡æä¾›æ–¹çš„æ¥å£ï¼Œä¹Ÿéœ€è¦è°ƒç”¨æ–¹åœ¨æ²¡æœ‰æœåŠ¡æä¾›æ–¹æ¥å£çš„æƒ…å†µä¸‹ï¼Œä»ç„¶å¯ä»¥æ­£å¸¸åœ°å‘èµ· RPC è°ƒç”¨ã€‚ ä»£ç†å¿…è¦æ€§åœ¨ Dubbo è°ƒç”¨çš„è¿‡ç¨‹ä¸­ï¼Œè°ƒç”¨ç«¯æ˜¯é€šè¿‡åŠ¨æ€ä»£ç†å‘æœåŠ¡ç«¯å‘èµ·è¿œç¨‹è°ƒç”¨ï¼Œä¸€èˆ¬è°ƒç”¨ç«¯æ˜¯é€šè¿‡æœåŠ¡ç«¯æ¥å£è‡ªåŠ¨ç”Ÿæˆä»£ç†å¯¹è±¡çš„ã€‚ä½† RPC è°ƒç”¨çš„æœ¬è´¨æ˜¯è°ƒç”¨ç«¯å‘æœåŠ¡ç«¯å‘é€ä¸€æ¡è¯·æ±‚æ¶ˆæ¯ï¼ŒæœåŠ¡ç«¯æ¥æ”¶å¹¶å¤„ç†ï¼Œç„¶åå‘è°ƒç”¨ç«¯å‘é€ä¸€æ¡å“åº”æ¶ˆæ¯ï¼Œè°ƒç”¨ç«¯æ”¶åˆ°å¹¶å¤„ç†å“åº”æ¶ˆæ¯ï¼Œä¸€æ¬¡ RPC è°ƒç”¨å°±å®Œæˆäº†ã€‚ä¸éš¾çœ‹å‡ºï¼Œæ˜¯å¦ä½¿ç”¨ä»£ç†ï¼Œæ˜¯å¦ä½¿ç”¨æœåŠ¡æ¥å£ä»£ç†ä¸æ˜¯æœ€é‡è¦çš„ï¼Œé‡è¦çš„æ˜¯è°ƒç”¨ç«¯åœ¨æ²¡æœ‰æœåŠ¡æ¥å£çš„æƒ…å†µä¸‹ä»ç„¶èƒ½å¤Ÿå‘æœåŠ¡ç«¯å‘é€æ­£ç¡®çš„è¯·æ±‚æ¶ˆæ¯ã€‚å¯¹äºè°ƒç”¨ç«¯æ¥è¯´ï¼ŒæœåŠ¡æ¥å£çš„ä½œç”¨ä»…ç”¨äºåˆ›å»ºä»£ç†å¯¹è±¡ï¼ŒåŸºäºé¢å‘æ¥å£å¼€å‘ã€‚ å…³é”®ç‚¹åœ¨äºï¼Œåªè¦è°ƒç”¨ç«¯å°†è°ƒç”¨ç¯å¢ƒä¿¡æ¯ï¼Œå¦‚æ¥å£åï¼Œæ–¹æ³•åï¼Œå‚æ•°ä¿¡æ¯ç­‰å‘é€ç»™æœåŠ¡ç«¯ï¼ŒæœåŠ¡ç«¯å°±èƒ½è§£æå¹¶å¤„ç†è¿™æ¡è¯·æ±‚æ¶ˆæ¯ã€‚ä½† Dubbo çš„è°ƒç”¨ç«¯å‘æœåŠ¡ç«¯å‘é€æ¶ˆæ¯æ˜¯é€šè¿‡ä»£ç†å¯¹è±¡æ¥å®Œæˆçš„ï¼ŒåŸºäºè¿™ç§æƒ…å†µï¼ŒDubbo å®šä¹‰äº†ä¸€ä¸ªç»Ÿä¸€çš„æ¥å£ GenericSerive ï¼Œè°ƒç”¨ç«¯åœ¨ä½¿ç”¨è¯¥æ¥å£çš„ä»£ç†æ—¶æŒ‡å®šç›¸å…³è°ƒç”¨ä¿¡æ¯å³å¯ã€‚GenericSerive æ¥å£å®šä¹‰å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930public interface GenericService &#123; /** * æ³›åŒ–è°ƒç”¨ * * @param method æ–¹æ³•å * @param parameterTypes å‚æ•°ç±»å‹æ•°ç»„ * @param args å‚æ•°æ•°ç»„ * @return invocation è°ƒç”¨ç»“æœ * @throws GenericException potential exception thrown from the invocation */ Object $invoke(String method, String[] parameterTypes, Object[] args) throws GenericException; /** * æ³›åŒ–è°ƒç”¨å¼‚æ­¥æ”¯æŒ ï¼ˆ2.7 æ–°å¢ï¼‰ * * @param method * @param parameterTypes * @param args * @return * @throws GenericException */ default CompletableFuture&lt;Object&gt; $invokeAsync(String method, String[] parameterTypes, Object[] args) throws GenericException &#123; Object object = $invoke(method, parameterTypes, args); if (object instanceof CompletableFuture) &#123; return (CompletableFuture&lt;Object&gt;) object; &#125; return CompletableFuture.completedFuture(object); &#125;&#125; ä½¿ç”¨ç¤ºä¾‹æœåŠ¡ç«¯æœåŠ¡ç«¯æ— éœ€å…³æ³¨æ³›åŒ–è°ƒç”¨ï¼Œä¸åšä»»ä½•å¤„ç†ï¼Œæ­£å¸¸æœåŠ¡æš´éœ²å³å¯ã€‚ æ¥å£å®šä¹‰ 123public interface NotGenericService &#123; String getRemark(GenericRequest request);&#125; æœåŠ¡æš´éœ²1&lt;dubbo:service interface=\"com.code.dubbo.NotGenericService\" ref=\"notGenericServiceImpl\"/&gt; æ¶ˆè´¹ç«¯ æœåŠ¡å¼•å…¥1&lt;dubbo:reference id=\"notGenericService\" interface=\"com.code.dubbo.NotGenericService\" generic=\"true\"/&gt; è¯´æ˜ï¼š æ¶ˆè´¹ç«¯æ— éœ€å¼•å…¥ interface é…ç½®é¡¹çš„ä¾èµ–ï¼Œå› ä¸ºè®¾ç½®äº† generic å±æ€§ï¼Œæ­¤æ—¶ Dubbo åªä¼šå°†è¯¥é…ç½®é¡¹å€¼çœ‹ä½œæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä¸ä¼šæ£€æŸ¥è¯¥æ¥å£æ˜¯å¦å­˜åœ¨ã€‚ interface é…ç½®é¡¹çš„å€¼æ˜¯è¦å¼•ç”¨çš„æœåŠ¡ï¼Œé€šè¿‡è¯¥é…ç½®ï¼Œå¯ä»¥ä»æ³¨å†Œä¸­å¿ƒè·å–åˆ°æ‰€æœ‰è¯¥æœåŠ¡çš„æä¾›æ–¹çš„åœ°å€ã€‚ generic é…ç½®é¡¹æ”¯æŒè®¾ç½® trueã€nativejava ä»¥åŠ beanï¼Œåœ¨ Dubbo 2.7 ä¸­è¿˜æ”¯æŒäº† protobuf-json å’Œ raw.return ï¼Œç”¨äºå¯¹å‚æ•°è¿›è¡Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–ã€‚ æœåŠ¡è°ƒç”¨1234567GenericService genericService = (GenericService) applicationContext.getBean(\"notGenericService\");// é€šè¿‡ GenericSerive å‘èµ·æœåŠ¡è°ƒç”¨ï¼Œå‚æ•°åŠè¿”å›å€¼ä¸­çš„æ‰€æœ‰ `POJO` å‡ä½¿ç”¨ `Map` è¡¨ç¤ºMap&lt;String, Object&gt; genericParamMap = new HashMap&lt;&gt;(2);genericParamMap.put(\"class\",\"com.code.dubbo.GenericRequest\");genericParamMap.put(\"remark\", \"this is remark!\");// æ³›åŒ–å€¼ç±»å‹ MapObject getRemark = genericService.$invoke(\"getRemark\", new String[]&#123;\"com.code.dubbo.GenericRequest\"&#125;, new Object[]&#123;genericParamMap&#125;); æ³›åŒ–æ¥å£ç±»å‹è°ƒç”¨æ–¹åœ¨è¿›è¡Œæ³›åŒ–è°ƒç”¨çš„æ—¶å€™ä¹‹æ‰€ä»¥å¯ä»¥ç›´æ¥ä½¿ç”¨ GenericService è½¬æ¢ï¼Œæ˜¯åœ¨æœåŠ¡å¼•ç”¨çš„æ—¶å€™ä¼šåˆ¤æ–­æ˜¯å¦æ˜¯æ³›åŒ–å¼•ç”¨ï¼Œå¦‚æœæ˜¯æ³›åŒ–å¼•ç”¨åˆ™å°†æ¥å£ç±»å‹è®¾ç½®ä¸º GenericService ã€‚ 1234567891011121314151617+--- ReferenceConfig#init // æ˜¯å¦æ˜¯æ³›åŒ–å¼•ç”¨ï¼Œå°±ç›´æ¥è®¾ç½®å½“å‰æ¥å£ä¸º GenericService if (ProtocolUtils.isGeneric(getGeneric())) &#123; interfaceClass = GenericService.class; // æ™®é€šæ¥å£çš„å®ç° &#125; else &#123; try &#123; // æ ¹æ®æ¥å£åï¼Œè·å¾—å¯¹åº”çš„æ¥å£ç±» interfaceClass = Class.forName(interfaceName, true, Thread.currentThread().getContextClassLoader()); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; // æ ¡éªŒæ¥å£å’Œæ–¹æ³• checkInterfaceAndMethods(interfaceClass, methods); &#125; è¯´æ˜ï¼š æ³›åŒ–å¼•ç”¨è™½ç„¶ä¼šå°†æœåŠ¡æ¥å£ç±»å‹è®¾ç½®ä¸º GenericService ï¼Œä½†æ˜¯å¹¶ä¸å½±å“æœåŠ¡å‘ç°ã€‚ GenericImplFilter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Activate(group = Constants.CONSUMER, value = Constants.GENERIC_KEY, order = 20000)public class GenericImplFilter implements Filter &#123; private static final Logger logger = LoggerFactory.getLogger(GenericImplFilter.class); /** * æ³›åŒ–å‚æ•°ç±»å‹ */ private static final Class&lt;?&gt;[] GENERIC_PARAMETER_TYPES = new Class&lt;?&gt;[]&#123;String.class, String[].class, Object[].class&#125;; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; // 1. è·å¾— generic é…ç½®é¡¹ String generic = invoker.getUrl().getParameter(Constants.GENERIC_KEY); // æ³›åŒ–å®ç°çš„è°ƒç”¨ - å®¢æˆ·ç«¯è°ƒç”¨çš„æœåŠ¡æ˜¯ GenericService if (ProtocolUtils.isGeneric(generic) // åˆ¤æ–­æ˜¯å¦å¼€å¯äº†æ³›åŒ–å¼•ç”¨ &amp;&amp; !Constants.$INVOKE.equals(invocation.getMethodName()) // æ–¹æ³•åé $invoke // è°ƒç”¨ä¿¡æ¯æ˜¯ RpcInvocation ç±»å‹ &amp;&amp; invocation instanceof RpcInvocation) &#123; // çœç•¥å®¢æˆ·ç«¯è°ƒç”¨æ³›åŒ–å®ç°çš„é€»è¾‘ &#125; // æ³›åŒ–å¼•ç”¨çš„è°ƒç”¨ - GenericService è°ƒç”¨æœåŠ¡æ¥å£ if (invocation.getMethodName().equals(Constants.$INVOKE) // è°ƒç”¨æ–¹æ³•æ˜¯ $invoke &amp;&amp; invocation.getArguments() != null &amp;&amp; invocation.getArguments().length == 3 // æ–¹æ³•å‚æ•°æ˜¯ 3 ä¸ª // åˆ¤æ–­æ˜¯å¦å¼€å¯äº†æ³›åŒ–å¼•ç”¨ &amp;&amp; ProtocolUtils.isGeneric(generic)) &#123; // 2 æ–¹æ³•å‚æ•°åˆ—è¡¨ Object[] args = (Object[]) invocation.getArguments()[2]; // 3. æ ¹æ® generic çš„å€¼æ ¡éªŒå‚æ•°å€¼ // 3.1 genecric = nativejavaçš„æƒ…å†µï¼Œæ ¡éªŒæ–¹æ³•å‚æ•°æ˜¯å¦éƒ½ä¸º byte[] if (ProtocolUtils.isJavaGenericSerialization(generic)) &#123; for (Object arg : args) &#123; if (!(byte[].class == arg.getClass())) &#123; error(generic, byte[].class.getName(), arg.getClass().getName()); &#125; &#125; // 3.2 generic = bean çš„æƒ…å†µï¼Œæ ¡éªŒæ–¹æ³•å‚æ•° ä¸º JavaBeanDescriptor &#125; else if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123; for (Object arg : args) &#123; if (!(arg instanceof JavaBeanDescriptor)) &#123; error(generic, JavaBeanDescriptor.class.getName(), arg.getClass().getName()); &#125; &#125; &#125; // 4 é€šè¿‡éšå¼å‚æ•°ï¼Œä¼ é€’ generic é…ç½®é¡¹ ((RpcInvocation) invocation).setAttachment(Constants.GENERIC_KEY, invoker.getUrl().getParameter(Constants.GENERIC_KEY)); &#125; // 5 æ™®é€šè°ƒç”¨ return invoker.invoke(invocation); &#125;&#125; GenericImplFilter æ˜¯æœåŠ¡æ¶ˆè´¹ç«¯çš„è¿‡æ»¤å™¨ï¼Œä¸»è¦æ˜¯å¯¹ æ³›åŒ–å¼•ç”¨ å’Œ æ³›åŒ–å®ç° åœ¨è°ƒç”¨ç«¯çš„å¤„ç†ã€‚ æ³›åŒ–è°ƒç”¨è°ƒç”¨ç«¯è¿›è¡Œæ³›åŒ–è°ƒç”¨çš„æ—¶å€™ï¼Œä¼šå¯¹å‚æ•°è¿›è¡Œæ ¡éªŒï¼Œé˜²æ­¢æœåŠ¡ç«¯æ¥æ”¶åˆ°å‚æ•°æ—¶ååºåˆ—åŒ–å¤±è´¥ï¼›è¿˜ä¼šå°† generic é…ç½®é¡¹é€šè¿‡éšå¼å‚æ•°çš„å½¢å¼ä¼ é€’åˆ°æœåŠ¡ç«¯ã€‚ æ³›åŒ–å®ç°è°ƒç”¨ç«¯å¯¹æ³›åŒ–å®ç°çš„æœåŠ¡è¿›è¡Œè°ƒç”¨æ—¶ï¼Œä¼šå¯¹å‚æ•°è¿›è¡Œåºåˆ—åŒ–ï¼Œå¹¶é‡æ–°è®¾ç½® RpcInvocation çš„æ–¹æ³•åã€å‚æ•°ç±»å‹ä»¥åŠå‚æ•°å€¼ã€‚ GenericFilter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116@Activate(group = Constants.PROVIDER, order = -20000)public class GenericFilter implements Filter &#123; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv) throws RpcException &#123; // 1 æ˜¯å¦æ˜¯æ³›åŒ–è°ƒç”¨: æ–¹æ³•åï¼š$invoke &amp; å‚æ•°ä¸ªæ•°ï¼š3 &amp; è°ƒç”¨æ¥å£é GenericService if (inv.getMethodName().equals(Constants.$INVOKE) &amp;&amp; inv.getArguments() != null &amp;&amp; inv.getArguments().length == 3 &amp;&amp; !invoker.getInterface().equals(GenericService.class)) &#123; // è°ƒç”¨çš„æœåŠ¡æ–¹æ³•å String name = ((String) inv.getArguments()[0]).trim(); // è°ƒç”¨çš„æœåŠ¡æ–¹æ³•å‚æ•°ç±»å‹ String[] types = (String[]) inv.getArguments()[1]; // å—²ç”¨çš„æœåŠ¡æ–¹æ³•å‚æ•°åˆ—è¡¨ Object[] args = (Object[]) inv.getArguments()[2]; try &#123; // 2. åå°„è·å¾—æä¾›æ–¹çš„æ–¹æ³•å¯¹è±¡ï¼Œæ³¨æ„è¿™é‡Œçš„ invoker æ˜¯æœåŠ¡ç«¯çš„ï¼Œå› æ­¤ interface æ˜¯æœåŠ¡æ¥å£ï¼Œè€ŒéGenericService Method method = ReflectUtils.findMethodByMethodSignature(invoker.getInterface(), name, types); // 2.1 è·å–æœåŠ¡æä¾›æ–¹çš„ç›®æ ‡æ–¹æ³•çš„å‚æ•°ç±»å‹ Class&lt;?&gt;[] params = method.getParameterTypes(); if (args == null) &#123; args = new Object[params.length]; &#125; // 3 è·å¾— generic é…ç½®é¡¹ String generic = inv.getAttachment(Constants.GENERIC_KEY); if (StringUtils.isBlank(generic)) &#123; generic = RpcContext.getContext().getAttachment(Constants.GENERIC_KEY); &#125; // 4 æ ¹æ® generic çš„é…ç½®é¡¹ååºåˆ—åŒ–å‚æ•°å€¼ // 4.1 å¦‚æœæ²¡æœ‰è®¾ç½® generic æˆ–è€… generic = trueï¼Œååºåˆ—åŒ–å‚æ•°ï¼ŒMap-&gt;Pojo (åœ¨ java ä¸­ï¼Œpojoé€šå¸¸ç”¨mapæ¥è¡¨ç¤º) if (StringUtils.isEmpty(generic) || ProtocolUtils.isDefaultGenericSerialization(generic)) &#123; args = PojoUtils.realize(args, params, method.getGenericParameterTypes()); // 4.2 generic = nativejava, ååºåˆ—åŒ–å‚æ•°ï¼Œ byte[]-&gt; Pojo &#125; else if (ProtocolUtils.isJavaGenericSerialization(generic)) &#123; for (int i = 0; i &lt; args.length; i++) &#123; if (byte[].class == args[i].getClass()) &#123; try &#123; UnsafeByteArrayInputStream is = new UnsafeByteArrayInputStream((byte[]) args[i]); args[i] = ExtensionLoader.getExtensionLoader(Serialization.class) .getExtension(Constants.GENERIC_SERIALIZATION_NATIVE_JAVA) .deserialize(null, is).readObject(); &#125; catch (Exception e) &#123; throw new RpcException(\"Deserialize argument [\" + (i + 1) + \"] failed.\", e); &#125; &#125; else &#123; throw new RpcException( \"Generic serialization [\" + Constants.GENERIC_SERIALIZATION_NATIVE_JAVA + \"] only support message type \" + byte[].class + \" and your message type is \" + args[i].getClass()); &#125; &#125; // 4.3 generic = bean ï¼Œååºåˆ—åŒ–å‚æ•°ï¼ŒJavaBeanDescriptor -&gt; Pojo &#125; else if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123; for (int i = 0; i &lt; args.length; i++) &#123; if (args[i] instanceof JavaBeanDescriptor) &#123; args[i] = JavaBeanSerializeUtil.deserialize((JavaBeanDescriptor) args[i]); &#125; else &#123; throw new RpcException( \"Generic serialization [\" + Constants.GENERIC_SERIALIZATION_BEAN + \"] only support message type \" + JavaBeanDescriptor.class.getName() + \" and your message type is \" + args[i].getClass().getName()); &#125; &#125; &#125; // 5 æ–¹æ³•å‚æ•°è½¬æ¢å®Œæ¯•ï¼Œè¿›è¡Œæ–¹æ³•è°ƒç”¨ã€‚ // æ³¨æ„æ­¤æ—¶åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ RpcInvocation å¯¹è±¡ã€‚$invoke æ³›åŒ–è°ƒç”¨è¢«è½¬ä¸ºå…·ä½“çš„æ™®é€šè°ƒç”¨ Result result = invoker.invoke(new RpcInvocation(method, args, inv.getAttachments())); // å¦‚æœè°ƒç”¨ç»“æœæœ‰å¼‚å¸¸ï¼Œå¹¶ä¸”éGenericExceptionå¼‚å¸¸ï¼Œåˆ™ä½¿ç”¨ GenericException åŒ…è£… if (result.hasException() &amp;&amp; !(result.getException() instanceof GenericException)) &#123; return new RpcResult(new GenericException(result.getException())); &#125; // generic=nativejavaçš„æƒ…å†µä¸‹ï¼Œåºåˆ—åŒ–ç»“æœï¼Œ ç»“æœ -&gt; btyp[] if (ProtocolUtils.isJavaGenericSerialization(generic)) &#123; try &#123; UnsafeByteArrayOutputStream os = new UnsafeByteArrayOutputStream(512); ExtensionLoader.getExtensionLoader(Serialization.class) .getExtension(Constants.GENERIC_SERIALIZATION_NATIVE_JAVA) .serialize(null, os).writeObject(result.getValue()); return new RpcResult(os.toByteArray()); &#125; catch (IOException e) &#123; throw new RpcException(\"Serialize result failed.\", e); &#125; // generic=bean çš„æƒ…å†µä¸‹ï¼Œåºåˆ—åŒ–ç»“æœï¼Œ ç»“æœ -&gt; JavaBeanDescriptor &#125; else if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123; return new RpcResult(JavaBeanSerializeUtil.serialize(result.getValue(), JavaBeanAccessor.METHOD)); // generic=true çš„æƒ…å†µä¸‹ï¼Œåºåˆ—åŒ–ç»“æœï¼ŒPojo -&gt; Map &#125; else &#123; return new RpcResult(PojoUtils.generalize(result.getValue())); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new RpcException(e.getMessage(), e); &#125; catch (ClassNotFoundException e) &#123; throw new RpcException(e.getMessage(), e); &#125; &#125; // æ™®é€šè°ƒç”¨ï¼ˆåŒ…æ‹¬è°ƒç”¨æ³›åŒ–å®ç°ï¼‰ return invoker.invoke(inv); &#125;&#125; GenericFilter æ˜¯æœåŠ¡ç«¯çš„è¿‡æ»¤å™¨ï¼Œç”¨äºå¤„ç†æ³›åŒ–è°ƒç”¨é€»è¾‘ï¼Œä¸ä¼šå¤„ç†å¯¹æ³›åŒ–å®ç°çš„è°ƒç”¨ï¼Œä¼šå°†å…¶å½“ä½œæ™®é€šè°ƒç”¨å¤„ç†ã€‚è¯¥è¿‡æ»¤ä¸»è¦é€»è¾‘å¦‚ä¸‹ï¼š ä»è°ƒç”¨ä¿¡æ¯ Invocation ä¸­è·å–æœåŠ¡æ–¹æ³•åã€æ–¹æ³•å‚æ•°ç±»å‹ã€æ–¹æ³•å‚æ•°åˆ—è¡¨ã€‚ åå°„è·å–æä¾›æ–¹çš„æ–¹æ³•å¯¹è±¡ï¼Œæ³¨æ„è¿™é‡Œçš„ invoker æ˜¯æœåŠ¡ç«¯çš„ï¼Œå› æ­¤ interface æ˜¯æœåŠ¡æ¥å£ï¼Œè€ŒéGenericService ã€‚ ä»éšå¼å‚æ•°ä¸­è·å– generic é…ç½®é¡¹ï¼Œè¯¥é…ç½®é¡¹å†³å®šäº†å‚æ•°ååºåˆ—åŒ–çš„æ–¹å¼ã€‚ æ„å»ºæ–°çš„ RpcInvocation å¯¹è±¡è¿›è¡Œæ–¹æ³•è°ƒç”¨ï¼Œæœ¬è´¨ä¸Šæ˜¯å°† $invoke æ³›åŒ–è°ƒç”¨è¢«è½¬ä¸ºå…·ä½“çš„æ™®é€šè°ƒç”¨ã€‚ å¯¹è°ƒç”¨ç»“æœè¿›è¡Œå¤„ç†ï¼Œå…¶ä¸­ä¼šå¯¹æ­£å¸¸ç»“æœè¿›è¡Œåºåˆ—åŒ–å¤„ç†ï¼Œç„¶åå“åº”ç»™è°ƒç”¨ç«¯ã€‚è‹¥æ˜¯å¼‚å¸¸ç»“æœï¼Œä¸”é GenericException å¼‚å¸¸ï¼Œåˆ™ä½¿ç”¨ GenericException åŒ…è£…åè¿”å›ï¼Œé˜²æ­¢å¼‚å¸¸åœ¨æœåŠ¡æ¶ˆè´¹ç«¯ä¸å­˜åœ¨å¯¼è‡´ååºåˆ—åŒ–å¤±è´¥ã€‚ æ³›åŒ–è°ƒç”¨æµç¨‹å›¾ å°ç»“Dubbo æ³›åŒ–è°ƒç”¨å®é™…æ˜¯åœ¨ Filter è¿‡æ»¤é“¾ä¸Šæ‰§è¡Œçš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–æ“ä½œï¼ŒæœåŠ¡ç«¯é€šè¿‡è°ƒç”¨ç«¯ä¼ é€’çš„è°ƒç”¨ä¿¡æ¯åå°„è·å–å¯¹åº”çš„æœåŠ¡æ–¹æ³•ï¼Œè¿›è€Œè¿›è¡ŒæœåŠ¡è°ƒç”¨ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"}]},{"title":"Dubboè¿‡æ»¤å™¨ - FutureFilter","slug":"rpc/Dubboè¿‡æ»¤å™¨-FutureFilter","date":"2020-08-10T12:20:38.000Z","updated":"2021-02-26T08:06:23.729Z","comments":false,"path":"posts/a87a4615/","link":"","permalink":"https://gentryhuang.com/posts/a87a4615/","excerpt":"","text":"æ¦‚è¿°FutureFilter æ˜¯ Dubbo åœ¨æ¶ˆè´¹ç«¯çš„è¿‡æ»¤å™¨ï¼Œç”¨äºå¤„ç†æ¶ˆè´¹ç«¯çš„äº‹ä»¶é€šçŸ¥ã€‚åœ¨è°ƒç”¨ä¹‹å‰ã€è°ƒç”¨ä¹‹åã€å‡ºç°å¼‚å¸¸æ—¶ï¼Œä¼šè§¦å‘ oninvokeã€onreturnã€onthrow ä¸‰ä¸ªäº‹ä»¶ï¼Œå¯ä»¥é…ç½®å½“äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œé€šçŸ¥å“ªä¸ªç±»çš„å“ªä¸ªæ–¹æ³•ã€‚ ç¤ºä¾‹æœåŠ¡æ¥å£123interface IDemoService &#123; String sayHello(String name);&#125; æœåŠ¡æä¾›ç«¯æœåŠ¡å®ç°1234567@Servicepublic class DemoServiceImpl implements DemoService &#123; @Override public String sayHello(String name) &#123; return \"nice to meet you - \" + name; &#125;&#125; æœåŠ¡é…ç½®1&lt;dubbo:service interface=\"com.code.dubbo.DemoService\" ref=\"demoServiceImpl\"/&gt; æœåŠ¡æ¶ˆè´¹ç«¯Callback æ¥å£12345678910111213141516171819202122232425public interface Notify &#123; /** * å‰ç½®æ–¹æ³•ï¼Œå¿…é¡»å…·æœ‰ä¸åŸè°ƒç”¨æ–¹æ³•ç›¸åŒçš„å…¥å‚åˆ—è¡¨ * * @param requestParam è¯·æ±‚å‚æ•° */ void oninvoke(String requestParam); /** * æ­£å¸¸å›è°ƒæ–¹æ³•ï¼Œè‡³å°‘è¦æœ‰ä¸€ä¸ªå…¥å‚æ¥æ¥æ”¶è¿”å›ç»“æœ * * @param result ç”¨äºæ¥æ”¶åŸè°ƒç”¨æ–¹æ³•çš„ç»“æœ * @param requestParam ç”¨äºæ¥æ”¶åŸè°ƒç”¨æ–¹æ³•çš„è¯·æ±‚å‚æ•° */ void onreturn(String result, String requestParam); /** * å¼‚å¸¸å›è°ƒæ–¹æ³•ï¼Œè‡³å°‘è¦æœ‰ä¸€ä¸ªå…¥å‚ä¸”ç¬¬ä¸€ä¸ªå…¥å‚ç±»å‹ä¸ºThrowableæˆ–å…¶å­ç±»æ¥æ”¶è¿”å›ç»“æœ * * @param ex ç”¨äºæ¥æ”¶è°ƒç”¨å‡ºç°çš„å¼‚å¸¸ * @param requestPram ç”¨äºæ¥æ”¶åŸè°ƒç”¨æ–¹æ³•çš„è¯·æ±‚å‚æ•° */ void onthrow(Throwable ex, String requestPram);&#125; Callback å®ç°1234567891011121314151617@Servicepublic class NotifyImpl implements Notify &#123; @Override public void oninvoke(String requestParam) &#123; System.out.println(\"oninvoke is running !\"); &#125; @Override public void onreturn(String result, String requestParam) &#123; System.out.println(\"onreturn is running !\"); &#125; @Override public void onthrow(Throwable ex, String requestParam) &#123; System.out.println(\"onthrow is running !\"); &#125;&#125; æ¶ˆè´¹é…ç½®1234567891011&lt;!-- 1 oninvoke åœ¨æ–¹æ³•è°ƒç”¨å‰è§¦å‘ï¼ˆå¦‚æœè°ƒç”¨å‡ºç°å¼‚å¸¸åˆ™ä¼šç›´æ¥è§¦å‘onthrowæ–¹æ³•ï¼‰ 2 onreturn åœ¨æ–¹æ³•è¿”å›ä¼šè§¦å‘ï¼ˆå¦‚æœè°ƒç”¨å‡ºç°å¼‚å¸¸åˆ™ä¼šç›´æ¥è§¦å‘onthrowæ–¹æ³•ï¼‰ 3 onthrow è°ƒç”¨å‡ºç°å¼‚å¸¸æ—¶å€™è§¦å‘ --&gt; &lt;dubbo:reference id=\"demoService\" check=\"false\" interface=\"com.code.dubbo.DemoService\"&gt; &lt;dubbo:method name=\"sayHello\" oninvoke=\"notifyImpl.oninvoke\" onreturn=\"notifyImpl.onreturn\" onthrow=\"notifyImpl.onthrow\"/&gt; &lt;/dubbo:reference&gt; FutureFilter123456789101112131415161718192021222324252627@Activate(group = Constants.CONSUMER)public class FutureFilter implements Filter &#123; protected static final Logger logger = LoggerFactory.getLogger(FutureFilter.class); @Override public Result invoke(final Invoker&lt;?&gt; invoker, final Invocation invocation) throws RpcException &#123; // 1 æ˜¯å¦å¼‚æ­¥è°ƒç”¨ final boolean isAsync = RpcUtils.isAsync(invoker.getUrl(), invocation); // 2 è§¦å‘å‰ç½®æ–¹æ³•ï¼Œå³ æ‰§è¡Œ Callback.oninvoke æ–¹æ³• fireInvokeCallback(invoker, invocation); // 3 è°ƒç”¨æœåŠ¡æä¾›è€… Result result = invoker.invoke(invocation); // 4 å¼‚æ­¥å›è°ƒ onreturn/onthrow if (isAsync) &#123; asyncCallback(invoker, invocation); // 5 åŒæ­¥å›è°ƒç”¨ onreturn/onth &#125; else &#123; syncCallback(invoker, invocation, result); &#125; // è¿”å›ç»“æœï¼Œå¦‚æœæ˜¯å¼‚æ­¥è°ƒç”¨æˆ–å•å‘è°ƒç”¨ï¼Œç»“æœæ˜¯ç©ºçš„ return result; &#125;&#125; FutureFilter ç”¨äºè§¦å‘æ¶ˆè´¹ç«¯çš„äº‹ä»¶é€šçŸ¥ï¼Œæ‰§è¡Œé€»è¾‘å¦‚ä¸‹ï¼š åœ¨æ–¹æ³•è°ƒç”¨å‰è§¦å‘ oninvoke æŒ‡å®šçš„æ–¹æ³•ã€‚ æœåŠ¡è°ƒç”¨ã€‚ æ ¹æ®åŒæ­¥è°ƒç”¨è¿˜æ˜¯å¼‚æ­¥è°ƒç”¨ï¼Œèµ°ä¸åŒçš„é€»è¾‘åˆ†æ”¯ã€‚åŒæ­¥å’Œå¼‚æ­¥è°ƒç”¨çš„ä¸»è¦å¤„ç†åŒºåˆ«ï¼š åŒæ­¥è°ƒç”¨ï¼Œäº‹ä»¶è§¦å‘æ˜¯ç›´æ¥è°ƒç”¨çš„ï¼Œæ²¡æœ‰é¢å¤–é€»è¾‘ã€‚ å¼‚æ­¥è°ƒç”¨ï¼Œéœ€è¦ä»ä¸Šä¸‹æ–‡ä¸­å…ˆè·å–åˆ°è°ƒç”¨äº§ç”Ÿçš„ Future å¯¹è±¡ï¼Œç»™è¯¥å¯¹è±¡è®¾ç½®å›è°ƒå¯¹è±¡ï¼Œå›è°ƒå¯¹è±¡åœ¨åˆé€‚çš„æ—¶æœºè§¦å‘äº‹ä»¶é€šçŸ¥ã€‚ è§¦å‘ oninvoke12345678910111213141516171819202122232425262728293031+--- FutureFilter private void fireInvokeCallback(final Invoker&lt;?&gt; invoker, final Invocation invocation) &#123; // è·å¾—å‰ç½®æ–¹æ³•å’Œæ–¹æ³•æ‰€åœ¨å¯¹è±¡ final Method onInvokeMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_INVOKE_METHOD_KEY)); final Object onInvokeInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_INVOKE_INSTANCE_KEY)); // æ²¡æœ‰è®¾ç½®ç›´æ¥è¿”å› if (onInvokeMethod == null &amp;&amp; onInvokeInst == null) &#123; return; &#125; if (onInvokeMethod == null || onInvokeInst == null) &#123; throw new IllegalStateException(\"service:\" + invoker.getUrl().getServiceKey() + \" has a onreturn callback config , but no such \" + (onInvokeMethod == null ? \"method\" : \"instance\") + \" found. url:\" + invoker.getUrl()); &#125; // è®¾ç½®è®¿é—®æƒé™ if (!onInvokeMethod.isAccessible()) &#123; onInvokeMethod.setAccessible(true); &#125; // è·å¾—åŸè°ƒç”¨æ–¹æ³•çš„å…¥å‚ Object[] params = invocation.getArguments(); try &#123; // åå°„è°ƒç”¨å‰ç½®æ–¹æ³•ï¼Œå¯ä»¥å‘ç° oninvoke çš„æ–¹æ³•å‚æ•°è¦ä¸è°ƒç”¨çš„æ–¹æ³•å‚æ•°ä¸€è‡´ onInvokeMethod.invoke(onInvokeInst, params); &#125; catch (InvocationTargetException e) &#123; // è§¦å‘å¼‚å¸¸å›è°ƒ fireThrowCallback(invoker, invocation, e.getTargetException()); &#125; catch (Throwable e) &#123; // è§¦å‘å¼‚å¸¸å›è°ƒ fireThrowCallback(invoker, invocation, e); &#125; &#125; oninvoke æŒ‡å®šçš„æ–¹æ³•å°±æ˜¯å‰ç½®æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¼šåœ¨è°ƒç”¨æœåŠ¡ä¹‹å‰æ‰§è¡Œï¼Œä¸”è¯¥æ–¹æ³•å¿…é¡»å…·æœ‰å’ŒåŸè°ƒç”¨æ–¹æ³•ç›¸åŒçš„å…¥å‚åˆ—è¡¨ã€‚ åŒæ­¥å›è°ƒ123456789101112+--- FutureFilter private void syncCallback(final Invoker&lt;?&gt; invoker, final Invocation invocation, final Result result) &#123; // æœ‰å¼‚å¸¸ï¼Œè§¦å‘å¼‚å¸¸å›è°ƒ if (result.hasException()) &#123; // æ³¨æ„ï¼šå¦‚æœæ˜¯consumerè‡ªå·±throwçš„å¼‚å¸¸ï¼Œä¸ä¼šèµ°åˆ°è¿™é‡Œ,è€Œæ˜¯ç›´æ¥æ‰§è¡Œ onthrow æ–¹æ³• fireThrowCallback(invoker, invocation, result.getException()); // æ­£å¸¸ï¼Œè§¦å‘æ­£å¸¸å›è°ƒ &#125; else &#123; // æ‰§è¡Œ onreturn æ–¹æ³• fireReturnCallback(invoker, invocation, result.getValue()); &#125; &#125; åŒæ­¥è°ƒç”¨ï¼Œäº‹ä»¶è§¦å‘æ˜¯ç›´æ¥è°ƒç”¨çš„ã€‚è°ƒç”¨ç»“æœæœ‰å¼‚å¸¸åˆ™è§¦å‘ onthrow æ–¹æ³•ï¼Œæ²¡æœ‰å¼‚å¸¸åˆ™è§¦å‘ onreturn æ–¹æ³•ã€‚ å¼‚æ­¥å›è°ƒ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748+--- FutureFilterprivate void asyncCallback(final Invoker&lt;?&gt; invoker, final Invocation invocation) &#123; // è·å¾— Future å¯¹è±¡ ã€‚ç”±äºå¼‚æ­¥ä¸çŸ¥é“æœåŠ¡æä¾›æ–¹ä»€ä¹ˆæ—¶å€™ä¼šæ‰§è¡Œå®Œæ¯•ï¼Œæ‰€ä»¥è¦æ·»åŠ å›è°ƒç­‰å¾…æœåŠ¡æä¾›è€…è¿”å›ç»“æœã€‚ Future&lt;?&gt; f = RpcContext.getContext().getFuture(); // è®¾ç½®å›è°ƒ ResponseCallback åˆ° DefaultFutureä¸­ if (f instanceof FutureAdapter) &#123; ResponseFuture future = ((FutureAdapter&lt;?&gt;) f).getFuture(); // å½“providerè¿”å›å“åº”æ—¶ï¼Œæ‰§è¡Œ DefaultFuture.doReceived æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¼šè°ƒç”¨ResponseCallbackå¯¹è±¡çš„doneæˆ–è€…caughtæ–¹æ³• future.setCallback(new ResponseCallback() &#123; /** * æ­£å¸¸å›è°ƒ * @param rpcResult */ @Override public void done(Object rpcResult) &#123; if (rpcResult == null) &#123; logger.error(new IllegalStateException(\"invalid result value : null, expected \" + Result.class.getName())); return; &#125; ///must be rpcResult if (!(rpcResult instanceof Result)) &#123; logger.error(new IllegalStateException(\"invalid result type :\" + rpcResult.getClass() + \", expected \" + Result.class.getName())); return; &#125; // æ ¹æ®è°ƒç”¨ç»“æœï¼Œè°ƒç”¨ ResponseCallback å¯¹è±¡çš„ done æˆ–è€… caught æ–¹æ³• Result result = (Result) rpcResult; if (result.hasException()) &#123; fireThrowCallback(invoker, invocation, result.getException()); &#125; else &#123; fireReturnCallback(invoker, invocation, result.getValue()); &#125; &#125; /** * è§¦å‘å¼‚å¸¸å›è°ƒæ–¹æ³• * @param exception */ @Override public void caught(Throwable exception) &#123; fireThrowCallback(invoker, invocation, exception); &#125; &#125;); &#125; &#125; å¼‚æ­¥äº‹ä»¶é€šçŸ¥é€»è¾‘éœ€è¦ä»ä¸Šä¸‹æ–‡ä¸­å…ˆè·å–åˆ°è°ƒç”¨äº§ç”Ÿçš„ Future å¯¹è±¡ï¼Œç„¶åç»™è¯¥å¯¹è±¡è®¾ç½®å›è°ƒå¯¹è±¡ï¼Œå›è°ƒå¯¹è±¡åœ¨åˆé€‚çš„æ—¶æœºè§¦å‘äº‹ä»¶é€šçŸ¥ã€‚ä¿¡æ¯äº¤æ¢å±‚ ä¸­çš„ç»“æœé€šçŸ¥å’Œå›è°ƒç´§å¯†å…³è”ï¼Œå…³äºä¸¤è€…çš„äº¤äº’å¯ä»¥å‚è€ƒ ä¿¡æ¯äº¤æ¢å±‚ã€‚ è§¦å‘ onreturn123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657+--- FutureFilter private void fireReturnCallback(final Invoker&lt;?&gt; invoker, final Invocation invocation, final Object result) &#123; // è·å¾— onreturn æ–¹æ³•å’Œå¯¹è±¡ final Method onReturnMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_RETURN_METHOD_KEY)); final Object onReturnInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_RETURN_INSTANCE_KEY)); //not set onreturn callback if (onReturnMethod == null &amp;&amp; onReturnInst == null) &#123; return; &#125; if (onReturnMethod == null || onReturnInst == null) &#123; throw new IllegalStateException(\"service:\" + invoker.getUrl().getServiceKey() + \" has a onreturn callback config , but no such \" + (onReturnMethod == null ? \"method\" : \"instance\") + \" found. url:\" + invoker.getUrl()); &#125; if (!onReturnMethod.isAccessible()) &#123; onReturnMethod.setAccessible(true); &#125; // åŸè°ƒç”¨æ–¹æ³•çš„å…¥å‚ Object[] args = invocation.getArguments(); Object[] params; // onreturn æ–¹æ³•çš„å‚æ•°åˆ—è¡¨ Class&lt;?&gt;[] rParaTypes = onReturnMethod.getParameterTypes(); // onreturn æ–¹æ³•çš„å‚æ•°å¤šäº1ä¸ª if (rParaTypes.length &gt; 1) &#123; // onreturn(xx, Object[]) ä¸¤ä¸ªå‚æ•°ï¼šç¬¬ä¸€ä¸ªå‚æ•°ä¸çœŸå®æ–¹æ³•è¿”å›ç»“æœç±»å‹ç›¸åŒã€ç”¨æ¥æ¥æ”¶è¿”å›ç»“æœã€‘ï¼Œç¬¬äºŒä¸ªæ¥æ”¶æ‰€æœ‰çš„çœŸå®è¯·æ±‚å‚æ•° if (rParaTypes.length == 2 &amp;&amp; rParaTypes[1].isAssignableFrom(Object[].class)) &#123; params = new Object[2]; params[0] = result; params[1] = args; // onreturn(xx, Object... args) å¤šä¸ªå‚æ•°ï¼šç¬¬ä¸€ä¸ªå‚æ•°ä¸çœŸå®æ–¹æ³•çš„è¿”å›ç»“æœç±»å‹ç›¸åŒï¼Œåè¾¹å‡ ä¸ªæ¥æ”¶æ‰€æœ‰çš„çœŸå®è¯·æ±‚å‚æ•° &#125; else &#123; params = new Object[args.length + 1]; params[0] = result; System.arraycopy(args, 0, params, 1, args.length); &#125; // onreturn(xx) åªæœ‰ä¸€ä¸ªå‚æ•°ï¼šæ¥æ”¶è¿”å›æ‰§è¡Œç»“æœ &#125; else &#123; params = new Object[]&#123;result&#125;; &#125; // è°ƒç”¨æ–¹æ³• try &#123; onReturnMethod.invoke(onReturnInst, params); &#125; catch (InvocationTargetException e) &#123; fireThrowCallback(invoker, invocation, e.getTargetException()); &#125; catch (Throwable e) &#123; fireThrowCallback(invoker, invocation, e); &#125; &#125; onreturn æŒ‡å®šçš„æ–¹æ³•æ˜¯è¿”å›æ­£å¸¸ç»“æœé€šçŸ¥æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¼šåœ¨è°ƒç”¨ç»“æœæ²¡æœ‰å¼‚å¸¸çš„æƒ…å†µä¸‹æ‰§è¡Œï¼Œä¸”è¯¥æ–¹æ³•å¿…é¡»è‡³å°‘è¦æœ‰ä¸€ä¸ªå…¥å‚æ¥æ¥æ”¶è¿”å›ç»“æœã€‚ è§¦å‘ onthrow123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960+--- FutureFilterprivate void fireThrowCallback(final Invoker&lt;?&gt; invoker, final Invocation invocation, final Throwable exception) &#123; // è·å¾— onthrow æ–¹æ³•å’Œå¯¹è±¡ final Method onthrowMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_THROW_METHOD_KEY)); final Object onthrowInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_THROW_INSTANCE_KEY)); if (onthrowMethod == null &amp;&amp; onthrowInst == null) &#123; return; &#125; if (onthrowMethod == null || onthrowInst == null) &#123; throw new IllegalStateException(\"service:\" + invoker.getUrl().getServiceKey() + \" has a onthrow callback config , but no such \" + (onthrowMethod == null ? \"method\" : \"instance\") + \" found. url:\" + invoker.getUrl()); &#125; if (!onthrowMethod.isAccessible()) &#123; onthrowMethod.setAccessible(true); &#125; // è·å– onthrow æ–¹æ³•çš„å‚æ•°åˆ—è¡¨ Class&lt;?&gt;[] rParaTypes = onthrowMethod.getParameterTypes(); // onthrow æ–¹æ³•çš„å‚æ•°ç¬¬ä¸€ä¸ªå€¼å¿…é¡»ä¸ºå¼‚å¸¸ç±»å‹ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦æ„é€ å‚æ•°åˆ—è¡¨ if (rParaTypes[0].isAssignableFrom(exception.getClass())) &#123; try &#123; // åŸè°ƒç”¨æ–¹æ³•çš„å‚æ•°åˆ—è¡¨ Object[] args = invocation.getArguments(); Object[] params; // onthrow æ–¹æ³•çš„å‚æ•°ä¸ªæ•° &gt; 1 if (rParaTypes.length &gt; 1) &#123; // åŸè°ƒç”¨æ–¹æ³•åªæœ‰ä¸€ä¸ªå‚æ•°ï¼Œè€Œä¸”è¿™ä¸ªå‚æ•°æ˜¯æ•°ç»„ç±»å‹ // onthrow(xx, Object[]) ä¸¤ä¸ªå‚æ•°ï¼šç¬¬ä¸€ä¸ªå‚æ•°æ¥æ”¶ exceptionï¼Œç¬¬äºŒä¸ªæ¥æ”¶æ‰€æœ‰çš„çœŸå®è¯·æ±‚å‚æ•° if (rParaTypes.length == 2 &amp;&amp; rParaTypes[1].isAssignableFrom(Object[].class)) &#123; params = new Object[2]; params[0] = exception; params[1] = args; // åŸè°ƒç”¨æ–¹æ³•çš„å‚æ•°å¤šäºä¸€ä¸ª // onthrow(xx, Object... args) å¤šä¸ªå‚æ•°ï¼šç¬¬ä¸€ä¸ªå‚æ•°æ¥æ”¶exceptionï¼Œåè¾¹å‡ ä¸ªæ¥æ”¶æ‰€æœ‰çš„çœŸå®è¯·æ±‚å‚æ•° &#125; else &#123; params = new Object[args.length + 1]; params[0] = exception; System.arraycopy(args, 0, params, 1, args.length); &#125; // åŸè°ƒç”¨æ–¹æ³•æ²¡æœ‰å‚æ•° // onthrow(xx) åªæœ‰ä¸€ä¸ªå‚æ•°ï¼šæ¥æ”¶exception &#125; else &#123; params = new Object[]&#123;exception&#125;; &#125; // è°ƒç”¨æ–¹æ³• onthrowMethod.invoke(onthrowInst, params); &#125; catch (Throwable e) &#123; logger.error(invocation.getMethodName() + \".call back method invoke error . callback method :\" + onthrowMethod + \", url:\" + invoker.getUrl(), e); &#125; &#125; else &#123; logger.error(invocation.getMethodName() + \".call back method invoke error . callback method :\" + onthrowMethod + \", url:\" + invoker.getUrl(), exception); &#125; &#125;&#125; onthrow æŒ‡å®šçš„æ–¹æ³•æ˜¯è¿”å›å¼‚å¸¸ç»“æœé€šçŸ¥æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¼šåœ¨è°ƒç”¨ç»“æœæœ‰å¼‚å¸¸çš„æƒ…å†µä¸‹æ‰§è¡Œï¼Œä¸”è¯¥æ–¹æ³•å¿…é¡»è‡³å°‘æœ‰ä¸€ä¸ªå…¥å‚ä¸”ç¬¬ä¸€ä¸ªå…¥å‚ç±»å‹ä¸ºThrowableæˆ–å…¶å­ç±»æ¥æ”¶è¿”å›çš„å¼‚å¸¸ç»“æœã€‚ å°ç»“FutureFilter ç”¨äºæ¶ˆè´¹ç«¯äº‹ä»¶é€šçŸ¥ï¼Œä»¥è¿‡æ»¤å™¨çš„å½¢å¼ç»Ÿä¸€å¤„ç†ï¼Œæ”¯æŒåœ¨æœåŠ¡è°ƒç”¨ä¹‹å‰ã€è°ƒç”¨åä»¥åŠè°ƒç”¨å¼‚å¸¸çš„é€»è¾‘å¤„ç†ï¼Œå’Œåˆ‡é¢å¸¦æ¥çš„ç»“æœç±»ä¼¼ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"}]},{"title":"Dubboè¿‡æ»¤å™¨ - ExceptionFilter","slug":"rpc/Dubboè¿‡æ»¤å™¨-ExceptionFilter","date":"2020-08-08T13:59:38.000Z","updated":"2021-02-19T14:29:14.789Z","comments":false,"path":"posts/c5f1bd62/","link":"","permalink":"https://gentryhuang.com/posts/c5f1bd62/","excerpt":"","text":"æ¦‚è¿°ExceptionFilter æ˜¯æœåŠ¡ç«¯çš„è¿‡æ»¤å™¨ï¼Œå®ƒä¸æ˜¯ä¸€ä¸ªç»Ÿä¸€å¤„ç†å¼‚å¸¸çš„è¿‡æ»¤å™¨ï¼Œå…³æ³¨ç‚¹ä¸åœ¨äºæ•è·å¼‚å¸¸ï¼Œè€Œæ˜¯ä¸ºäº†æ‰¾åˆ°é‚£äº›è¿”å›çš„è‡ªå®šä¹‰å¼‚å¸¸ï¼Œä¼šæŠŠå¼‚å¸¸åŒ…è£…æˆ RuntimeException ã€‚ å› ä¸ºå¼‚å¸¸ç±»å¯èƒ½ä¸å­˜åœ¨äºæ¶ˆè´¹ç«¯ï¼Œé¿å…æ¶ˆè´¹ç«¯å‡ºç°ä¸èƒ½ååºåˆ—åŒ–å¼‚å¸¸çš„æƒ…å†µã€‚ ExceptionFilter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@Activate(group = Constants.PROVIDER)public class ExceptionFilter implements Filter &#123; private final Logger logger; public ExceptionFilter() &#123; this(LoggerFactory.getLogger(ExceptionFilter.class)); &#125; public ExceptionFilter(Logger logger) &#123; this.logger = logger; &#125; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; try &#123; // æœåŠ¡è°ƒç”¨ Result result = invoker.invoke(invocation); // 1. æ³›åŒ–è°ƒç”¨ç›´æ¥æŠ›å‡ºï¼Œéæ³›åŒ–è°ƒç”¨åˆ†ç±»å¤„ç† if (result.hasException() &amp;&amp; GenericService.class != invoker.getInterface()) &#123; try &#123; // è·å–å¼‚å¸¸å¯¹è±¡ Throwable exception = result.getException(); // 2. å¦‚æœæ˜¯ checked å¼‚å¸¸ï¼Œåˆ™ç›´æ¥æŠ›å‡º if (!(exception instanceof RuntimeException) &amp;&amp; (exception instanceof Exception)) &#123; return result; &#125; // 3. åœ¨æ–¹æ³•ç­¾åä¸Šæœ‰å£°æ˜ï¼Œç›´æ¥æŠ›å‡º try &#123; Method method = invoker.getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes()); Class&lt;?&gt;[] exceptionClassses = method.getExceptionTypes(); for (Class&lt;?&gt; exceptionClass : exceptionClassses) &#123; if (exception.getClass().equals(exceptionClass)) &#123; return result; &#125; &#125; &#125; catch (NoSuchMethodException e) &#123; return result; &#125; // æœªåœ¨æ–¹æ³•ç­¾åä¸Šå®šä¹‰çš„å¼‚å¸¸ï¼Œåœ¨æœåŠ¡ç«¯æ‰“å° é”™è¯¯æ—¥å¿— logger.error(\"Got unchecked and undeclared exception which called by \" + RpcContext.getContext().getRemoteHost() + \". service: \" + invoker.getInterface().getName() + \", method: \" + invocation.getMethodName() + \", exception: \" + exception.getClass().getName() + \": \" + exception.getMessage(), exception); // 4. å¼‚å¸¸ç±»å’Œæ¥å£ç±»åœ¨åŒä¸€ä¸ª jar åŒ…é‡Œï¼Œç›´æ¥æŠ›å‡º String serviceFile = ReflectUtils.getCodeBase(invoker.getInterface()); String exceptionFile = ReflectUtils.getCodeBase(exception.getClass()); if (serviceFile == null || exceptionFile == null || serviceFile.equals(exceptionFile)) &#123; return result; &#125; // 5. æ˜¯JDKè‡ªå¸¦çš„å¼‚å¸¸ï¼Œç›´æ¥æŠ›å‡º String className = exception.getClass().getName(); if (className.startsWith(\"java.\") || className.startsWith(\"javax.\")) &#123; return result; &#125; // 6. æ˜¯Dubboä¸­å®šä¹‰å¼‚å¸¸ï¼Œç›´æ¥æŠ›å‡º if (exception instanceof RpcException) &#123; return result; &#125; // 7. å¦åˆ™ï¼ŒåŒ…è£…æˆRuntimeException æŠ›ç»™å®¢æˆ·ç«¯ return new RpcResult(new RuntimeException(StringUtils.toString(exception))); &#125; catch (Throwable e) &#123; logger.warn(\"Fail to ExceptionFilter when called by \" + RpcContext.getContext().getRemoteHost() + \". service: \" + invoker.getInterface().getName() + \", method: \" + invocation.getMethodName() + \", exception: \" + e.getClass().getName() + \": \" + e.getMessage(), e); return result; &#125; &#125; // ç›´æ¥æŠ›å‡º return result; &#125; catch (RuntimeException e) &#123; logger.error(\"Got unchecked and undeclared exception which called by \" + RpcContext.getContext().getRemoteHost() + \". service: \" + invoker.getInterface().getName() + \", method: \" + invocation.getMethodName() + \", exception: \" + e.getClass().getName() + \": \" + e.getMessage(), e); throw e; &#125; &#125;&#125; Dubbo å†…éƒ¨çš„å¼‚å¸¸å¤„ç†ç±» ExceptionFilter çš„å¤„ç†é€»è¾‘å¦‚ä¸Šé¢ä»£ç æ‰€ç¤ºï¼Œå…¶ä¸­ 1-6 ç§æƒ…å†µå®¢æˆ·ç«¯éƒ½èƒ½ååºåˆ—åŒ–æˆåŠŸï¼Œç¬¬ 7 æ­¥æ˜¯ä¸€ä¸ªå…œåº•æ“ä½œï¼Œä¸ºäº†é˜²æ­¢å®¢æˆ·ç«¯ååºåˆ—åŒ–å¼‚å¸¸å¤±è´¥ã€‚ å¼‚å¸¸å¤„ç†Dubbo å®˜æ–¹æ¨èå¼‚å¸¸å¤„ç†æ–¹å¼å¦‚ä¸‹ï¼š 1234567* å»ºè®®ä½¿ç”¨å¼‚å¸¸æ±‡æŠ¥é”™è¯¯ï¼Œè€Œä¸æ˜¯è¿”å›é”™è¯¯ç ï¼Œå¼‚å¸¸ä¿¡æ¯èƒ½æºå¸¦æ›´å¤šä¿¡æ¯ï¼Œå¹¶ä¸”è¯­ä¹‰æ›´å‹å¥½ã€‚* å¦‚æœæ‹…å¿ƒæ€§èƒ½é—®é¢˜ï¼Œåœ¨å¿…è¦æ—¶ï¼Œå¯ä»¥é€šè¿‡ override æ‰å¼‚å¸¸ç±»çš„ fillInStackTrace() æ–¹æ³•ä¸ºç©ºæ–¹æ³•ï¼Œä½¿å…¶ä¸æ‹·è´æ ˆä¿¡æ¯ã€‚* æŸ¥è¯¢æ–¹æ³•ä¸å»ºè®®æŠ›å‡º checked å¼‚å¸¸ï¼Œå¦åˆ™è°ƒç”¨æ–¹åœ¨æŸ¥è¯¢æ—¶å°†è¿‡å¤šçš„ try...catchï¼Œå¹¶ä¸”ä¸èƒ½è¿›è¡Œæœ‰æ•ˆå¤„ç†ã€‚* æœåŠ¡æä¾›æ–¹ä¸åº”å°† DAO æˆ– SQL ç­‰å¼‚å¸¸æŠ›ç»™æ¶ˆè´¹æ–¹ï¼Œåº”åœ¨æœåŠ¡å®ç°ä¸­å¯¹æ¶ˆè´¹æ–¹ä¸å…³å¿ƒçš„å¼‚å¸¸è¿›è¡ŒåŒ…è£…ï¼Œå¦åˆ™å¯èƒ½å‡ºç°æ¶ˆè´¹æ–¹æ— æ³•ååºåˆ—åŒ–ç›¸åº”å¼‚å¸¸ã€‚ è‡ªå®šä¹‰å¼‚å¸¸é€šè¿‡ ExceptionFilter æºç å¯çŸ¥ï¼Œè‡ªå®šä¹‰çš„å¼‚å¸¸å¦‚æœä¸ç¬¦åˆå‰é¢çš„ 6 ç§æƒ…å†µï¼Œé‚£ä¹ˆæœ€åè¿”å›ç»™å®¢æˆ·ç«¯çš„å¼‚å¸¸ä¼šè¢«åŒ…è£…æˆ RuntimeException ï¼Œè‡ªå®šä¹‰çš„å¼‚å¸¸ä¹Ÿå°±æ— æ•ˆäº†ã€‚æ—¢ç„¶å¦‚æ­¤ï¼Œèƒ½ä¸èƒ½å‰”é™¤æ‰ ExceptionFilter è¿‡æ»¤å™¨ï¼Œè¿™æ ·å°±ä¸ä¼šå°†è‡ªå®šä¹‰çš„å¼‚å¸¸è‡ªåŠ¨åŒ…è£…äº†ã€‚ä½†æ˜¯è¿™æ ·çš„è¯åˆå›åˆ°äº†æœ€å¼€å§‹çš„ç—›ç‚¹ï¼Œæ²¡æœ‰ ExceptionFilter è¿‡æ»¤å™¨å¤„ç†å®¢æˆ·ç«¯å¯èƒ½æ— æ³•æ­£ç¡®ååºåˆ—åŒ–è‡ªå®šä¹‰çš„å¼‚å¸¸ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°±å¯ä»¥è‡ªå®šä¹‰ä¸€ä¸ª Filter æ¥ç»Ÿä¸€å¤„ç†è¿™ç§æƒ…å†µã€‚ BizExceptionä¸€èˆ¬è‡ªå®šä¹‰å¼‚å¸¸éƒ½æ˜¯unchecked ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class BizException extends RuntimeException &#123; private static final long serialVersionUID = 8056580241015398148L; /** * å¼‚å¸¸ä¸šåŠ¡ç¼–ç  */ private String code; /** * é»˜è®¤å¼‚å¸¸æ„é€ å™¨. */ public BizException() &#123; super(); &#125; /** * æ ¹æ®å¼‚å¸¸ä¿¡æ¯å’ŒåŸç”Ÿå¼‚å¸¸æ„é€ å¯¹è±¡. * * @param code é”™è¯¯ç  * @param msg å¼‚å¸¸ä¿¡æ¯. * @param cause åŸç”Ÿå¼‚å¸¸. */ public BizException(final String code, final String msg, final Throwable cause) &#123; super(msg, cause); this.code = code; &#125; /** * æ ¹æ®å¼‚å¸¸æ„é€ ä¸šåŠ¡å¯¹è±¡ï¼Œè®¾ç½® ç¼–ç åŠ æ¶ˆæ¯ * * @param code * @param msg */ public BizException(final String code, final String msg) &#123; super(msg); this.code = code; &#125; /** * æ ¹æ®å¼‚å¸¸ä¿¡æ¯å’ŒåŸç”Ÿå¼‚å¸¸æ„é€ å¯¹è±¡. * * @param msg å¼‚å¸¸ä¿¡æ¯. * @param cause åŸç”Ÿå¼‚å¸¸. */ public BizException(final String msg, final Throwable cause) &#123; super(msg, cause); &#125; /** * æ ¹æ®å¼‚å¸¸ä¿¡æ¯æ„é€ å¯¹è±¡. * * @param msg å¼‚å¸¸ä¿¡æ¯. */ public BizException(final String msg) &#123; super(msg); &#125; /** * æ ¹æ®å¼‚å¸¸æ„é€ ä¸šåŠ¡å¯¹è±¡ï¼Œè®¾ç½® ç¼–ç åŠ æ¶ˆæ¯ * * @param resultCode */ public BizException(final ResultCode resultCode) &#123; super(resultCode.getMsg()); this.code = resultCode.getCode(); &#125; /** * æ ¹æ®å¼‚å¸¸æ„é€ ä¸šåŠ¡å¯¹è±¡ï¼Œè®¾ç½® ç¼–ç åŠ æ¶ˆæ¯ * * @param resultCode */ public BizException(final ResultCode resultCode, final Throwable cause) &#123; super(resultCode.getMsg(), cause); this.code = resultCode.getCode(); &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; /** * æ ¹æ®åŸç”Ÿå¼‚å¸¸æ„é€ å¯¹è±¡. * * @param cause åŸç”Ÿå¼‚å¸¸. */ public BizException(final Throwable cause) &#123; super(cause); &#125; @Override public synchronized Throwable fillInStackTrace() &#123; return this; &#125;&#125; è‡ªå®šä¹‰ Filter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Activate(group = &#123;CommonConstants.PROVIDER&#125;, order = 999999)public class ProviderExceptionFilter implements Filter &#123; private Environment environment; public Environment getEnvironment() &#123; return environment; &#125; public void setEnvironment(Environment environment) &#123; this.environment = environment; &#125; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; JsonKvFormat kvFormat = makeJsonKvFormat(invoker, invocation); Result result = null; try &#123; long startTime = System.currentTimeMillis(); // invoke result = invoker.invoke(invocation); long endTime = System.currentTimeMillis(); long timeOut = Long.parseLong(environment.getProperty(\"time.out\")); if ((endTime - startTime) &gt; timeOut) &#123; recordTimeOutLog(kvFormat, endTime - startTime); &#125; // åˆ¤æ–­è°ƒç”¨æ˜¯å¦æœ‰å¼‚å¸¸ if (result.hasException() &amp;&amp; GenericService.class != invoker.getInterface()) &#123; Throwable exception = result.getException(); // æ˜¯å¦æ˜¯è‡ªå®šä¹‰å¼‚å¸¸ if (exception instanceof BizException) &#123; String code = ((BizException) exception).getCode(); recordBizLog(kvFormat, result); result.setValue(com.yunhu.rpc.result.Result.failResult(code, exception.getMessage())); // æ˜¯å¦æ˜¯ä¸è®°å½•æ—¥å¿—çš„è‡ªå®šä¹‰å¼‚å¸¸ &#125; else if (exception instanceof NoRecordException) &#123; String code = ((NoRecordException) exception).getCode(); result.setValue(com.yunhu.rpc.result.Result.failResult(code, exception.getMessage())); // éè‡ªå®šä¹‰å¼‚å¸¸ç»Ÿä¸€å¤„ç† &#125; else &#123; recordErrorLog(kvFormat, exception); result.setValue(com.yunhu.rpc.result.Result.failResult(BizExceptionEnum.SYSTEM_ERROR.getCode(), BizExceptionEnum.SYSTEM_ERROR.getMessage())); &#125; //æ¸…é™¤å¼‚å¸¸ï¼Œå¦åˆ™è°ƒç”¨æ–¹ä¼šä»¥è¿è¡Œæ—¶å¼‚å¸¸æŠ¥é”™ï¼ result.setException(null); return result; &#125; return result; &#125; catch (Exception e) &#123; recordErrorLog(kvFormat, e); result.setException(null); result.setValue(com.yunhu.rpc.result.Result.failResult(BizExceptionEnum.SYSTEM_ERROR.getCode(), BizExceptionEnum.SYSTEM_ERROR.getMessage())); &#125; return result; &#125; è¯´æ˜ï¼š è¿™é‡Œè‡ªå®šä¹‰ Filter çš„å‰ææ˜¯è¿”å›ç»“æœæ˜¯ä»¥çŠ¶æ€ç è¡¨ç¤ºçš„ï¼Œå¼‚å¸¸çš„å¤„ç†æœ€ç»ˆä¹Ÿæ˜¯é€šè¿‡çŠ¶æ€ç è¿”å›ã€‚ è‡ªå®šä¹‰çš„ Filter çš„ä¼˜å…ˆçº§ç›¸æ¯”è¾ƒ Dubbo å†…ç½®çš„ ExceptionFilter çš„ä¼˜å…ˆçº§è¦é«˜ã€‚å³ä½¿è°ƒç”¨å‡ºç°å¼‚å¸¸ï¼Œè‡ªå®šä¹‰ Filter ä¼šæ¸…é™¤å¼‚å¸¸ä¿¡æ¯ï¼Œåˆ° ExceptionFilter æ—¶å°±ä¸ä¼šèµ°å¼‚å¸¸å¤„ç†æµç¨‹äº†ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« å¯¹ Dubbo æ¡†æ¶çš„å¼‚å¸¸å¤„ç†è¿‡æ»¤å™¨è¿›è¡Œäº†ä»‹ç»ï¼Œå¹¶å®ç°äº†è‡ªå®šä¹‰çš„å¼‚å¸¸å¤„ç†ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"}]},{"title":"Dubboè¿‡æ»¤å™¨ - TokenFilter","slug":"rpc/Dubboè¿‡æ»¤å™¨-TokenFilter","date":"2020-08-06T12:59:38.000Z","updated":"2021-02-22T03:24:49.937Z","comments":false,"path":"posts/4c117d83/","link":"","permalink":"https://gentryhuang.com/posts/4c117d83/","excerpt":"","text":"æ¦‚è¿°Dubbo æ¡†æ¶æ”¯æŒé€šè¿‡ä»¤ç‰ŒéªŒè¯åœ¨æ³¨å†Œä¸­å¿ƒæ§åˆ¶æƒé™ï¼Œä»¥å†³å®šæ˜¯å¦ä¸‹å‘ä»¤ç‰Œç»™æ¶ˆè´¹è€…ï¼Œä»¥é˜²æ­¢æ¶ˆè´¹è€…ç»•è¿‡æ³¨å†Œä¸­å¿ƒè®¿é—®æœåŠ¡æä¾›è€…ï¼Œå¦å¤–é€šè¿‡æ³¨å†Œä¸­å¿ƒå¯çµæ´»æ”¹å˜æˆæƒæ–¹å¼ï¼Œè€Œä¸éœ€ä¿®æ”¹æˆ–å‡çº§æä¾›è€…ã€‚ é…ç½® å…¨å±€å¼€å¯ä»¤ç‰Œ1234&lt;!--éšæœºtokenä»¤ç‰Œï¼Œä½¿ç”¨UUIDç”Ÿæˆ--&gt;&lt;dubbo:provider interface=\"com.foo.BarService\" token=\"true\" /&gt;&lt;!--å›ºå®štokenä»¤ç‰Œï¼Œç›¸å½“äºå¯†ç --&gt;&lt;dubbo:provider interface=\"com.foo.BarService\" token=\"123456\" /&gt; æœåŠ¡çº§åˆ«å¼€å¯ä»¤ç‰Œ1234&lt;!--éšæœºtokenä»¤ç‰Œï¼Œä½¿ç”¨UUIDç”Ÿæˆ--&gt;&lt;dubbo:service interface=\"com.foo.BarService\" token=\"true\" /&gt;&lt;!--å›ºå®štokenä»¤ç‰Œï¼Œç›¸å½“äºå¯†ç --&gt;&lt;dubbo:service interface=\"com.foo.BarService\" token=\"123456\" /&gt; Token æµè½¬æœåŠ¡æä¾›ç«¯12345678910+--- ServiceConfig#doExportUrlsFor1Protocol // token ã€ä½¿æš´éœ²å‡ºå»çš„æœåŠ¡æ›´å®‰å…¨ï¼Œä½¿ç”¨tokenåšå®‰å…¨æ ¡éªŒã€‘ if (!ConfigUtils.isEmpty(token)) &#123; // true || default æ—¶ï¼ŒUUID éšæœºç”Ÿæˆ if (ConfigUtils.isDefault(token)) &#123; map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString()); &#125; else &#123; map.put(Constants.TOKEN_KEY, token); &#125; &#125; æœåŠ¡æä¾›è€…å°†è®¾ç½®çš„ Token æœ€ç»ˆä¼šè®¾ç½®åˆ° URL ä¸­ï¼Œæœ€ç»ˆå†™å…¥åˆ°æ³¨å†Œä¸­å¿ƒä¸Šã€‚ æœåŠ¡æ¶ˆè´¹ç«¯æœåŠ¡æ¶ˆè´¹è€…ä»æ³¨å†Œä¸­å¿ƒè·å–æœåŠ¡æä¾›è€…çš„ URL ï¼Œä»è€Œè·å¾—è¯¥æœåŠ¡çš„ Token ã€‚åœ¨åˆ›å»º RpcInvocation æ—¶ä¼šè‡ªåŠ¨å¸¦ä¸Š Tokenï¼Œæœ€ç»ˆä¼šå°† Token å‘é€åˆ°æœåŠ¡æä¾›æ–¹ï¼Œè€Œ TokenFilter å°±æ˜¯å¤„ç†æ¥è‡ªæœåŠ¡æ¶ˆè´¹æ–¹çš„ Token çš„ã€‚ TokenFilter12345678910111213141516171819202122232425262728@Activate(group = Constants.PROVIDER, value = Constants.TOKEN_KEY)public class TokenFilter implements Filter &#123; /** * å¯¹è¯·æ±‚çš„ä»¤ç‰Œåšæ ¡éªŒ * * @param invoker service * @param inv * @return * @throws RpcException */ @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv) throws RpcException &#123; // è·å¾—æœåŠ¡æä¾›è€…é…ç½®çš„Token å€¼ String token = invoker.getUrl().getParameter(Constants.TOKEN_KEY); if (ConfigUtils.isNotEmpty(token)) &#123; Class&lt;?&gt; serviceType = invoker.getInterface(); // ä» RpcInvocation çš„ éšå¼å‚æ•°ä¸­ï¼Œè·å¾— Token å€¼ Map&lt;String, String&gt; attachments = inv.getAttachments(); String remoteToken = attachments == null ? null : attachments.get(Constants.TOKEN_KEY); // éªŒè¯æ¶ˆè´¹æ–¹ã€RpcInvocationçš„ä¿¡æ¯ã€‘ä¼ è¿‡æ¥çš„çš„Token å’Œ æœåŠ¡æä¾›è€…é…ç½®çš„Token é‡Šæ”¾ä¸€è‡´ï¼Œä¸ä¸€è‡´å°±æŠ›å‡ºå¼‚å¸¸ if (!token.equals(remoteToken)) &#123; throw new RpcException(\"Invalid token! Forbid invoke remote service \" + serviceType + \" method \" + inv.getMethodName() + \"() from consumer \" + RpcContext.getContext().getRemoteHost() + \" to provider \" + RpcContext.getContext().getLocalHost()); &#125; &#125; return invoker.invoke(inv); &#125;&#125;","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"}]},{"title":"Dubboè¿‡æ»¤å™¨ - EchoFilter","slug":"rpc/Dubboè¿‡æ»¤å™¨-EchoFilter","date":"2020-08-03T14:59:38.000Z","updated":"2021-02-19T02:16:35.529Z","comments":false,"path":"posts/2e2f77b9/","link":"","permalink":"https://gentryhuang.com/posts/2e2f77b9/","excerpt":"","text":"æ¦‚è¿°å›å£°æµ‹è¯•ç”¨äºæ£€æµ‹æœåŠ¡æ˜¯å¦å¯ç”¨ï¼Œå›å£°æµ‹è¯•æŒ‰ç…§æ­£å¸¸è¯·æ±‚æµç¨‹æ‰§è¡Œï¼Œèƒ½å¤Ÿæµ‹è¯•æ•´ä¸ªè°ƒç”¨æ˜¯å¦é€šç•…ï¼Œå¯ç”¨äºç›‘æ§ã€‚ EchoService1234567891011public interface EchoService &#123; /** * echo test. * * @param message message. * @return message. */ Object $echo(Object message);&#125; æ¶ˆè´¹ç«¯çš„æœåŠ¡å¯¹è±¡ï¼ˆä»£ç†å¯¹è±¡ï¼‰è‡ªåŠ¨å®ç° EchoService æ¥å£ï¼Œåªéœ€å°†ä»»æ„æœåŠ¡å¼•ç”¨å¼ºåˆ¶è½¬å‹ä¸º EchoService å³å¯ä½¿ç”¨ã€‚å…³äºåˆ›å»ºæœåŠ¡æ¶ˆè´¹ç«¯çš„ä»£ç†å¯¹è±¡æ—¶ï¼Œè‡ªåŠ¨å®ç° EchoService æ¥å£å¯ä»¥å‚è€ƒ å›å£°æ¢æµ‹æ¥å£å®ç° ã€‚æœåŠ¡æä¾›è€…æ˜¯ä¸å®ç° EchoService æ¥å£ï¼Œè€Œæ˜¯é€šè¿‡ EchoFilter æ¥å¤„ç†å›å£°æ¢æµ‹è¯·æ±‚ã€‚ EchoFilter1234567891011121314@Activate(group = Constants.PROVIDER, order = -110000)public class EchoFilter implements Filter &#123; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv) throws RpcException &#123; // å¦‚æœæ˜¯å›å£°æ¢æµ‹æ–¹æ³• $echo(message) ,ç›´æ¥è¿”å›æ–¹æ³•å‚æ•°ã€‚ // æ–¹åä¸º $echo,æ–¹æ³•å‚æ•°ä»…æœ‰ä¸€ä¸ª --&gt; å›å£°æ¢æµ‹æ–¹æ³• if (inv.getMethodName().equals(Constants.$ECHO) &amp;&amp; inv.getArguments() != null &amp;&amp; inv.getArguments().length == 1) &#123; return new RpcResult(inv.getArguments()[0]); &#125; // éå›å£°æ¢æµ‹è°ƒç”¨ï¼Œç»§ç»­èµ°åé¢çš„æµç¨‹ return invoker.invoke(inv); &#125;&#125;","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"}]},{"title":"Dubboè¿‡æ»¤å™¨ - TimeoutFilter","slug":"rpc/Dubboè¿‡æ»¤å™¨-TimeoutFilter","date":"2020-08-02T16:00:00.000Z","updated":"2021-02-19T01:57:04.384Z","comments":false,"path":"posts/8338833e/","link":"","permalink":"https://gentryhuang.com/posts/8338833e/","excerpt":"","text":"æ¦‚è¿°æœåŠ¡æä¾›ç«¯çš„è¶…æ—¶è¿‡æ»¤å™¨ï¼Œå³å¦‚æœæœåŠ¡è°ƒç”¨è¶…æ—¶ï¼Œè®°å½•å‘Šè­¦æ—¥å¿—ï¼Œä¸å¹²æ¶‰æœåŠ¡çš„è¿è¡Œã€‚ TimeoutFilter1234567891011121314151617181920212223242526272829@Activate(group = Constants.PROVIDER)public class TimeoutFilter implements Filter &#123; private static final Logger logger = LoggerFactory.getLogger(TimeoutFilter.class); @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; // è°ƒç”¨å¼€å§‹æ—¶é—´ long start = System.currentTimeMillis(); // æ‰§è¡ŒæœåŠ¡è°ƒç”¨é€»è¾‘ Result result = invoker.invoke(invocation); // è®¡ç®—è°ƒç”¨æ¶ˆè€—æ—¶é•¿ long elapsed = System.currentTimeMillis() - start; /** * æ³¨æ„ï¼š * 1 è¿™é‡Œtimeout æ˜¯æœåŠ¡æä¾›è€…çš„é…ç½®ï¼Œä¸åŒäºæœåŠ¡æ¶ˆè´¹è€…çš„é…ç½®ã€‚ * 2 æœåŠ¡æä¾›è€…æ‰§è¡ŒæœåŠ¡å³ä½¿è¶…æ—¶äº†ä¹Ÿä¸ä¼šå–æ¶ˆæ‰§è¡Œï¼Œè€Œæ¶ˆè´¹è€…å·²ç»ç»“æŸäº†è°ƒç”¨ï¼Œè¿”å›è°ƒç”¨è¶…æ—¶ */ if (invoker.getUrl() != null &amp;&amp; elapsed &gt; invoker.getUrl().getMethodParameter(invocation.getMethodName(), \"timeout\", Integer.MAX_VALUE)) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"invoke time out. method: \" + invocation.getMethodName() + \" arguments: \" + Arrays.toString(invocation.getArguments()) + \" , url is \" + invoker.getUrl() + \", invoke elapsed \" + elapsed + \" ms.\"); &#125; &#125; return result; &#125;&#125; å°ç»“TimeoutFilter ç”¨äºè®°å½•æœåŠ¡ç«¯æ‰§è¡Œé€»è¾‘è¶…æ—¶æ—¥å¿—ï¼Œæ˜¯å¯¹ Dubbo æ¡†æ¶ä¸­æ‰€æœ‰æœåŠ¡çš„ç›‘æ§ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"}]},{"title":"Dubboè¿‡æ»¤å™¨ - TpsLimitFilter","slug":"rpc/Dubboè¿‡æ»¤å™¨-TpsLimitFilter","date":"2020-08-01T16:00:00.000Z","updated":"2021-02-19T01:35:33.578Z","comments":false,"path":"posts/f715f3aa/","link":"","permalink":"https://gentryhuang.com/posts/f715f3aa/","excerpt":"","text":"æ¦‚è¿°TpsLimitFilter æ˜¯æœåŠ¡æä¾›ç«¯å¯¹ TPS é™æµçš„å®ç°ã€‚è¯¥è¿‡æ»¤å™¨çš„é™æµæ˜¯åŸºäºä»¤ç‰Œçš„ï¼Œæœ¬è´¨ä¸Šæ˜¯è®¡æ•°å™¨é™æµçš„å®ç°æ–¹å¼ï¼Œå³ä¸€ä¸ªæ—¶é—´æ®µå†…åªåˆ†é… N ä¸ªä»¤ç‰Œï¼Œæ¯ä¸ªè¯·æ±‚è¿‡æ¥éƒ½ä¼šæ¶ˆè€—ä¸€ä¸ªä»¤ç‰Œï¼Œè€—å®Œå³æ­¢ï¼Œåé¢å†æ¥çš„è¯·æ±‚éƒ½ä¼šè¢«æ‹’ç»ã€‚è®¡æ•°å™¨ç®—æ³•ç®€å•ç²—æš´ï¼Œæ˜“äºå®ç°ã€‚ä½†æ˜¯ç¼ºç‚¹ä¹Ÿæ˜¯å¾ˆå¤§çš„ï¼Œå®¹æ˜“é€ æˆå‰ä¸€ä¸ªæ—¶é—´æ®µéå¸¸å¿™ç¢Œï¼Œä¸‹ä¸€æ—¶é—´æ®µåˆéå¸¸ç©ºé—²ã€‚ é…ç½®1234&lt;!-- æ¯æ¬¡å‘æ”¾ 100 ä¸ªä»¤ç‰Œ --&gt;&lt;dubbo:parameter key=\"tps\" value=\"100\" /&gt;&lt;!-- ä»¤ç‰Œåˆ·æ–°çš„é—´éš”æ˜¯ 1sï¼Œå¦‚æœä¸é…ç½®åˆ™é»˜è®¤ 60s --&gt;&lt;dubbo:parameter key=\"tps.interval\" value=\"1000\" /&gt; å°†ä»¥ä¸Šçš„é…ç½®é¡¹æ·»åŠ åˆ° &lt;dubbo:provider/&gt; æˆ– &lt;dubbo:service/&gt; æˆ– &lt;dubbo:protocol/&gt; ä¸­å¼€å¯å³å¯ã€‚ æ³¨æ„ï¼Œç›®å‰ Dubbo Filter çš„ SPI é…ç½®æ–‡ä»¶ä¸­å¹¶æ²¡æœ‰é…ç½® TpsLimitFilter ï¼Œå¦‚æœéœ€è¦ä½¿ç”¨åˆ™é…ç½®ï¼š 12# com.alibaba.dubbo.rpc.Filter æ–‡ä»¶tps&#x3D;com.alibaba.dubbo.rpc.filter.TpsLimitFilter TpsLimitFilter123456789101112131415161718192021@Activate(group = Constants.PROVIDER, value = Constants.TPS_LIMIT_RATE_KEY)public class TpsLimitFilter implements Filter &#123; /** * é™æµå™¨ */ private final TPSLimiter tpsLimiter = new DefaultTPSLimiter(); @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; // æ ¹æ®tpsé™æµè§„åˆ™åˆ¤æ–­æ˜¯å¦é™åˆ¶æ­¤æ¬¡è°ƒç”¨ï¼Œå¦‚æœæ˜¯å°±æŠ›å‡ºå¼‚å¸¸ã€‚ç›®å‰ä½¿ç”¨ TPSLimiterä½œä¸ºé™æµå™¨çš„å®ç°ç±» if (!tpsLimiter.isAllowable(invoker.getUrl(), invocation)) &#123; throw new RpcException( \"Failed to invoke service \" + invoker.getInterface().getName() + \".\" + invocation.getMethodName() + \" because exceed max service tps.\"); &#125; return invoker.invoke(invocation); &#125;&#125; TPSLimiter1234567891011121314public interface TPSLimiter &#123; /** * æ ¹æ® tps é™æµè§„åˆ™åˆ¤æ–­æ˜¯å¦é™åˆ¶æ­¤æ¬¡è°ƒç”¨ * &lt;p&gt; * judge if the current invocation is allowed by TPS rule * * @param url url * @param invocation invocation * @return true allow the current invocation, otherwise, return false */ boolean isAllowable(URL url, Invocation invocation);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * é»˜è®¤TPSé™åˆ¶å™¨å®ç°ç±»ï¼Œä»¥æœåŠ¡ä¸ºçº¬åº¦ */public class DefaultTPSLimiter implements TPSLimiter &#123; /** * StatItem é›†åˆï¼Œå³ç¼“å­˜æ¯ä¸ªæ¥å£çš„ä»¤ç‰Œæ•° * key: æœåŠ¡é”®ï¼Œinterface + group + version * value: StatItem */ private final ConcurrentMap&lt;String, StatItem&gt; stats = new ConcurrentHashMap&lt;String, StatItem&gt;(); /** * æ˜¯å¦è§¦å‘é™æµ * * @param url url * @param invocation invocation * @return */ @Override public boolean isAllowable(URL url, Invocation invocation) &#123; // è·å¾— tps é…ç½®é¡¹ï¼Œå³ä»¤ç‰Œæ•° int rate = url.getParameter(Constants.TPS_LIMIT_RATE_KEY, -1); // è·å¾— tps.interval å‘¨æœŸé…ç½®é¡¹ï¼Œé»˜è®¤60 ç§’ï¼Œå³ä»¤ç‰Œåˆ·æ–°æ—¶é—´é—´éš” long interval = url.getParameter(Constants.TPS_LIMIT_INTERVAL_KEY, Constants.DEFAULT_TPS_LIMIT_INTERVAL); // è·å¾—æœåŠ¡é”® String serviceKey = url.getServiceKey(); // å¦‚æœè®¾ç½®äº†ä»¤ç‰Œæ•°ï¼Œåˆ™å¼€å§‹é™æµå¤„ç† if (rate &gt; 0) &#123; // è·å–æœåŠ¡é”®å¯¹åº”çš„ StatItem å¯¹è±¡ StatItem statItem = stats.get(serviceKey); // ä¸å­˜åœ¨ï¼Œåˆ™è¿›è¡Œåˆ›å»º if (statItem == null) &#123; stats.putIfAbsent(serviceKey, new StatItem(serviceKey, rate, interval)); statItem = stats.get(serviceKey); &#125; // æ ¹æ® tps é™æµè§„åˆ™åˆ¤æ–­æ˜¯å¦é™åˆ¶æ­¤æ¬¡è°ƒç”¨ return statItem.isAllowable(); // ä¸è¿›è¡Œé™æµ &#125; else &#123; // ç§»é™¤å½“å‰æœåŠ¡é”®å…³è”çš„ StatItem StatItem statItem = stats.get(serviceKey); if (statItem != null) &#123; stats.remove(serviceKey); &#125; &#125; return true; &#125;&#125; TPSLimiter æ¥å£ä¸­çš„æ ¸å¿ƒæ˜¯ isAllowable() æ–¹æ³•ï¼Œåœ¨ DefaultTPSLimiter å®ç°ä¸­ï¼Œä½¿ç”¨ ConcurrentHashMap ä¸ºæ¯ä¸ªæœåŠ¡å¥ç»´æŠ¤äº†ä¸€ä¸ªç›¸åº”çš„ StatItem å¯¹è±¡ã€‚åœ¨ isAllowable() æ–¹æ³•å®ç°ä¸­ï¼Œä¼šä» URL ä¸­è¯»å– tps å‚æ•°å€¼ï¼ˆé»˜è®¤ä¸º -1ï¼Œå³æ²¡æœ‰é™æµï¼‰ï¼Œå¯¹äºéœ€è¦é™æµçš„è¯·æ±‚ï¼Œä¼šä» stats é›†åˆä¸­è·å–ï¼ˆæˆ–åˆ›å»ºï¼‰ç›¸åº” StatItem å¯¹è±¡ï¼Œç„¶åè°ƒç”¨ StatItem å¯¹è±¡çš„isAllowable() æ–¹æ³•åˆ¤æ–­æ˜¯å¦è¢«é™æµã€‚ StatItem12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class StatItem &#123; /** * ç»Ÿè®¡åï¼Œç›®å‰ä½¿ç”¨æœåŠ¡é”® */ private String name; /** * æœ€åé‡ç½®æ—¶é—´ */ private long lastResetTime; /** * ä»¤ç‰Œåˆ·æ–°æ—¶é—´é—´éš”ï¼Œå³é‡ç½® token å€¼çš„æ—¶é—´å‘¨æœŸï¼Œè¿™æ ·å°±å®ç°äº†åœ¨ interval æ—¶é—´æ®µå†…èƒ½å¤Ÿé€šè¿‡ rate ä¸ªè¯·æ±‚çš„æ•ˆæœã€‚ */ private long interval; /** * ä»¤ç‰Œæ•°,åˆå§‹å€¼ä¸º rate å€¼ï¼Œæ¯é€šè¿‡ä¸€ä¸ªè¯·æ±‚ token é€’å‡ä¸€ï¼Œå½“å‡ä¸º 0 æ—¶ï¼Œä¸å†é€šè¿‡ä»»ä½•è¯·æ±‚ï¼Œå®ç°é™æµçš„ä½œç”¨ã€‚ */ private AtomicInteger token; /** * ä¸€æ®µæ—¶é—´å†…èƒ½é€šè¿‡çš„ TPS ä¸Šé™ */ private int rate; /** * æ„é€ æ–¹æ³• * * @param name æœåŠ¡é”® * @param rate é™åˆ¶å¤§å° * @param interval é™åˆ¶å‘¨æœŸ */ StatItem(String name, int rate, long interval) &#123; this.name = name; this.rate = rate; this.interval = interval; // è®°å½•æ—¶é—´æˆ³ this.lastResetTime = System.currentTimeMillis(); this.token = new AtomicInteger(rate); &#125; /** * é™æµè§„åˆ™åˆ¤æ–­æ˜¯å¦é™åˆ¶æ­¤æ¬¡è°ƒç”¨ * * @return */ public boolean isAllowable() &#123; // å‘¨æœŸæ€§é‡ç½®token long now = System.currentTimeMillis(); if (now &gt; lastResetTime + interval) &#123; token.set(rate); // è®°å½•æœ€è¿‘ä¸€æ¬¡é‡ç½®tokençš„æ—¶é—´æˆ³ lastResetTime = now; &#125; // CASï¼Œç›´åˆ°è·å¾—ä¸€ä¸ªä»¤ç‰Œï¼Œæˆ–è€…æ²¡æœ‰è¶³å¤Ÿçš„ä»¤ç‰Œæ‰ç»“æŸ int value = token.get(); boolean flag = false; while (value &gt; 0 &amp;&amp; !flag) &#123; flag = token.compareAndSet(value, value - 1); value = token.get(); &#125; // æ˜¯å¦å…è®¸è®¿é—® ã€å–å†³æ˜¯å¦èƒ½å¤Ÿæ‹¿åˆ°ä»¤ç‰Œã€‘ return flag; &#125; long getLastResetTime() &#123; return lastResetTime; &#125; int getToken() &#123; return token.get(); &#125;&#125; StatItem åŒ…è£…äº†ä»¤ç‰Œåˆ·æ–°çš„æ—¶é—´é—´éš”ã€æ¯æ¬¡å‘æ”¾çš„ä»¤ç‰Œæ•°ç­‰å±æ€§ã€‚å®ƒçš„æ ¸å¿ƒæ˜¯ isAllowable æ–¹æ³•ï¼Œè¿™ä¹Ÿæ˜¯æ•´ä¸ª TPS é™æµç®—æ³•çš„æ ¸ã€‚ å®ƒçš„ä¸»è¦é€»è¾‘å¦‚ä¸‹ï¼š åˆ¤æ–­ä¸Šæ¬¡å‘æ”¾ä»¤ç‰Œçš„æ—¶é—´ç‚¹åˆ°ç°åœ¨æ˜¯å¦è¶…è¿‡ä»¤ç‰Œåˆ·æ–°çš„æ—¶é—´é—´éš”ï¼Œå¦‚æœè¶…è¿‡å°±é‡æ–°å‘é€ä»¤ç‰Œï¼Œä¹‹å‰æ²¡ç”¨å®Œçš„ä¸ä¼šå åŠ ï¼Œè€Œæ˜¯é‡æ–°è®¾ç½®ä»¤ç‰Œæ•°ã€‚ é€šè¿‡ CAS é€’å‡ä»¤ç‰Œï¼Œå‡æ‰åä»¤ç‰Œæ•°å¦‚æœå°äº 0 åˆ™ä¼šè§¦å‘é™æµã€‚ å°ç»“TpsLimitFilter ä¸­çš„é™æµç®—æ³•æ˜¯åŸºäºè®¡æ•°å™¨ï¼Œæ³¨æ„å’Œä»¤ç‰Œæ¡¶ç®—æ³•çš„åŒºåˆ«ã€‚å¸¸è§çš„é™æµç®—æ³•æœ‰è®¡æ•°å™¨ã€ä»¤ç‰Œæ¡¶ã€æ¼æ¡¶ç­‰ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"}]},{"title":"Dubboè¿‡æ»¤å™¨ - ContextFilter & ConsumerContextFilter","slug":"rpc/Dubboè¿‡æ»¤å™¨-RpcContext","date":"2020-07-30T16:00:00.000Z","updated":"2021-02-26T02:29:28.260Z","comments":false,"path":"posts/c72fde05/","link":"","permalink":"https://gentryhuang.com/posts/c72fde05/","excerpt":"","text":"æ¦‚è¿°ContextFilter å’Œ ConsumerContextFilter åˆ†åˆ«ç”¨æ¥åˆå§‹åŒ–æœåŠ¡æä¾›ç«¯å’Œæ¶ˆè´¹ç«¯çš„ä¸Šä¸‹æ–‡ RpcContext ã€‚æ— è®ºæ˜¯æ¶ˆè´¹ç«¯å‘èµ·çš„è°ƒç”¨ï¼Œè¿˜æ˜¯æœåŠ¡ç«¯æ”¶åˆ°çš„è°ƒç”¨ï¼Œä»èŠ‚ç‚¹çš„è§’åº¦çœ‹éƒ½æ˜¯ä¸€æ¬¡è°ƒç”¨ï¼Œéƒ½å¯èƒ½äº§ç”Ÿå¾ˆå¤šä¸­é—´ä¸´æ—¶ä¿¡æ¯ï¼Œæˆ‘ä»¬ä¸å¯èƒ½è¦æ±‚åœ¨æ¯ä¸ªæ–¹æ³•çš„å‚æ•°ä½ç½®éƒ½åŠ ä¸€ä¸ªä¸Šä¸‹æ–‡å‚æ•°ï¼Œç„¶åä¸€è·¯å¾€ä¸‹ä¼ ã€‚é€šå¸¸åšæ³•éƒ½æ˜¯æ”¾åœ¨ ThreadLocal ä¸­ï¼Œä½œä¸ºä¸€ä¸ªå…¨å±€å‚æ•°ï¼Œå½“å‰çº¿ç¨‹ä¸­çš„ä»»ä½•ä¸€ä¸ªåœ°æ–¹éƒ½å¯ä»¥ç›´æ¥æ“ä½œä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚ RPC ä¸Šä¸‹æ–‡RpcContext æ˜¯ Dubbo çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š 1 ä¸Šä¸‹æ–‡ä¸­å­˜æ”¾çš„æ˜¯å½“å‰è°ƒç”¨è¿‡ç¨‹ä¸­æ‰€éœ€çš„ç¯å¢ƒä¿¡æ¯ï¼Œå¦‚ Invokerä¿¡æ¯ï¼ŒInvocationä¿¡æ¯ã€åœ°å€ä¿¡æ¯ç­‰ã€‚2 RpcContext æ˜¯ä¸€ä¸ª ThreadLocal çš„ä¸´æ—¶çŠ¶æ€è®°å½•å™¨ï¼Œè¯¥å¯¹è±¡ç»´æŠ¤ä¸¤ä¸ª InternalThreadLocalï¼Œåˆ†åˆ«è®°å½• local å’Œ server çš„ä¸Šä¸‹æ–‡ã€‚æ¯æ¬¡æ”¶åˆ°æˆ–å‘èµ· RPC è°ƒç”¨çš„æ—¶å€™ï¼Œä¸Šä¸‹æ–‡ä¿¡æ¯éƒ½ä¼šå‘ç”Ÿæ”¹å˜ã€‚æ¯”å¦‚ï¼šA è°ƒç”¨ Bï¼ŒB å†è°ƒç”¨ Cï¼Œåˆ™ B æœºå™¨ä¸Šï¼šåœ¨ B è°ƒ C ä¹‹å‰ï¼ŒRpcContext è®°å½•çš„æ˜¯ A è°ƒ B çš„ä¸Šä¸‹ä¿¡æ¯ï¼Œåœ¨ B å¼€å§‹è°ƒ C æ—¶ ï¼ŒRpcContext è®°å½•çš„æ˜¯ B è°ƒ C çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚å‘èµ·è°ƒç”¨çš„æ—¶å€™ä¸Šä¸‹æ–‡æ˜¯ç”± ConsumerContextFilter å®ç°çš„ï¼ŒContextFilter ä¿å­˜çš„æ˜¯æ”¶åˆ°çš„è¯·æ±‚çš„ä¸Šä¸‹æ–‡ã€‚ æœåŠ¡æ¶ˆè´¹æ–¹12345678910// è¿œç¨‹è°ƒç”¨xxxService.xxx();// æœ¬ç«¯æ˜¯å¦ä¸ºæ¶ˆè´¹ç«¯ï¼Œè¿™é‡Œä¼šè¿”å›trueboolean isConsumerSide = RpcContext.getContext().isConsumerSide();// è·å–æœ€åä¸€æ¬¡è°ƒç”¨çš„æä¾›æ–¹IPåœ°å€String serverIP = RpcContext.getContext().getRemoteHost();// è·å–å½“å‰æœåŠ¡é…ç½®ä¿¡æ¯ï¼Œæ‰€æœ‰é…ç½®ä¿¡æ¯éƒ½å°†è½¬æ¢ä¸ºURLçš„å‚æ•°String application = RpcContext.getContext().getUrl().getParameter(\"application\");// æ³¨æ„ï¼šæ¯å‘èµ·RPCè°ƒç”¨ï¼Œä¸Šä¸‹æ–‡çŠ¶æ€ä¼šå˜åŒ–yyyService.yyy(); æœåŠ¡åœä¾›æ–¹123456789101112131415public class XxxServiceImpl implements XxxService &#123; public void xxx() &#123; // æœ¬ç«¯æ˜¯å¦ä¸ºæä¾›ç«¯ï¼Œè¿™é‡Œä¼šè¿”å›true boolean isProviderSide = RpcContext.getContext().isProviderSide(); // è·å–è°ƒç”¨æ–¹IPåœ°å€ String clientIP = RpcContext.getContext().getRemoteHost(); // è·å–å½“å‰æœåŠ¡é…ç½®ä¿¡æ¯ï¼Œæ‰€æœ‰é…ç½®ä¿¡æ¯éƒ½å°†è½¬æ¢ä¸ºURLçš„å‚æ•° String application = RpcContext.getContext().getUrl().getParameter(\"application\"); // æ³¨æ„ï¼šæ¯å‘èµ·RPCè°ƒç”¨ï¼Œä¸Šä¸‹æ–‡çŠ¶æ€ä¼šå˜åŒ– yyyService.yyy(); // æ­¤æ—¶æœ¬ç«¯å˜æˆæ¶ˆè´¹ç«¯ï¼Œè¿™é‡Œä¼šè¿”å›false boolean isProviderSide = RpcContext.getContext().isProviderSide(); &#125; &#125; ConsumerContextFilteråœ¨æœåŠ¡æ¶ˆè´¹è€…ä¸­ä½¿ç”¨ï¼Œè´Ÿè´£å‘èµ·è°ƒç”¨æ—¶åˆå§‹åŒ– RpcContext ã€‚ 1234567891011121314151617181920212223242526272829303132@Activate(group = Constants.CONSUMER, order = -10000)public class ConsumerContextFilter implements Filter &#123; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; RpcContext.getContext() // è®°å½•Invoker .setInvoker(invoker) // è®°å½•æœåŠ¡è°ƒç”¨å‚æ•° .setInvocation(invocation) // æœ¬åœ°åœ°å€ .setLocalAddress(NetUtils.getLocalHost(), 0) // è¿œç«¯åœ°å€ .setRemoteAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort()); // è®¾ç½® RpcInvocation å¯¹è±¡çš„ invoker å±æ€§ if (invocation instanceof RpcInvocation) &#123; ((RpcInvocation) invocation).setInvoker(invoker); &#125; try &#123; RpcResult result = (RpcResult) invoker.invoke(invocation); RpcContext.getServerContext().setAttachments(result.getAttachments()); return result; &#125; finally &#123; /** * æ¸…ç†éšå¼å‚æ•°é›†åˆ * æ³¨æ„ï¼šæ¯æ¬¡æœåŠ¡è°ƒç”¨å®Œæˆï¼ŒRpcContextè®¾ç½®çš„éšå¼å‚æ•°éƒ½ä¼šè¢«æ¸…ç† */ RpcContext.getContext().clearAttachments(); &#125; &#125;&#125; ConsumerContextFilter é€šå¸¸ä¼šå’Œ ContextFilter é…åˆä½¿ç”¨ï¼Œå› ä¸ºåœ¨å¾®æœåŠ¡ç¯å¢ƒä¸­æœ‰å¾ˆå¤šé“¾å¼è°ƒç”¨ã€‚æ”¶åˆ°è¯·æ±‚æ—¶ï¼Œå½“å‰èŠ‚ç‚¹å¯ä»¥è¢«çœ‹ä½œä¸€ä¸ªæœåŠ¡æä¾›è€…ï¼Œç”± ContextFilter è®¾ç½®ä¸Šä¸‹æ–‡ã€‚å½“å‘èµ·è¯·æ±‚è°ƒç”¨å…¶ä»–æœåŠ¡ï¼Œå½“å‰æœåŠ¡å˜æˆä¸€ä¸ªæ¶ˆè´¹è€…ï¼Œç”± ConsumerContextFilter è®¾ç½®ä¸Šä¸‹æ–‡ã€‚ ContextFilteråœ¨æœåŠ¡æä¾›è€…ä¸­ä½¿ç”¨ï¼Œè´Ÿè´£è¢«è°ƒç”¨æ—¶åˆå§‹åŒ– RpcContext ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Activate(group = Constants.PROVIDER, order = -10000)public class ContextFilter implements Filter &#123; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; /** * åˆ›å»ºæ–°çš„ attachments é›†åˆï¼Œæ¸…ç†å…¬ç”¨çš„éšå¼å‚æ•°ã€‚å…¬ç”¨çš„éšå¼å‚æ•°ï¼Œè®¾ç½®çš„åœ°æ–¹å¦‚ä¸‹ï¼š * @see RpcInvocation#RpcInvocation(com.alibaba.dubbo.rpc.Invocation, com.alibaba.dubbo.rpc.Invoker) */ Map&lt;String, String&gt; attachments = invocation.getAttachments(); // pathï¼Œgroupï¼Œversionï¼Œdubboï¼Œtokenï¼Œtimeoutï¼Œasync éƒ½æ˜¯ä¿ç•™å­—æ®µï¼Œä¸èƒ½ä½œä¸ºéšå¼å‚æ•°çš„ key if (attachments != null) &#123; attachments = new HashMap&lt;String, String&gt;(attachments); // æ¸…ç† path attachments.remove(Constants.PATH_KEY); // æ¸…ç† group attachments.remove(Constants.GROUP_KEY); // æ¸…ç† version attachments.remove(Constants.VERSION_KEY); // æ¸…ç† dubbo attachments.remove(Constants.DUBBO_VERSION_KEY); // æ¸…ç† token attachments.remove(Constants.TOKEN_KEY); // æ¸…ç† timeout attachments.remove(Constants.TIMEOUT_KEY); // æ¸…é™¤å¼‚æ­¥å±æ€§ï¼Œé˜²æ­¢å¼‚æ­¥å±æ€§ä¼ åˆ°è¿‡æ»¤å™¨ä¸‹ä¸€ä¸ªç¯èŠ‚ attachments.remove(Constants.ASYNC_KEY); &#125; // è¿™é‡Œå’Œ ConsumerContextFilter ä¸åŒï¼Œæ²¡æœ‰è®¾ç½® remoteAddress çš„å€¼ï¼Œåšä¸ºæœåŠ¡ç«¯çš„è¿‡æ»¤å™¨ï¼Œåœ¨æ”¶åˆ°è¯·æ±‚çš„æ—¶å€™å°±å·²ç»è®¾ç½®äº† remoteAddress çš„å€¼ // @see com.alibaba.dubbo.remoting.exchange.support.ExchangeHandlerAdapter.reply RpcContext.getContext() .setInvoker(invoker) .setInvocation(invocation)// .setAttachments(attachments) // merged from dubbox .setLocalAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort()); // mreged from dubbox // we may already added some attachments into RpcContext before this filter (e.g. in rest protocol) if (attachments != null) &#123; if (RpcContext.getContext().getAttachments() != null) &#123; RpcContext.getContext().getAttachments().putAll(attachments); &#125; else &#123; RpcContext.getContext().setAttachments(attachments); &#125; &#125; // è®¾ç½® RpcInvocation å¯¹è±¡çš„ 'invoker' å±æ€§ if (invocation instanceof RpcInvocation) &#123; ((RpcInvocation) invocation).setInvoker(invoker); &#125; try &#123; // è°ƒç”¨è¿‡æ»¤å™¨é“¾çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ RpcResult result = (RpcResult) invoker.invoke(invocation); // å°† SERVER_LOCAL è¿™ä¸ª RpcContext ä¸­çš„é™„åŠ ä¿¡æ¯æ·»åŠ åˆ° RpcResult çš„ attachments å­—æ®µä¸­ï¼Œè¿”å›ç»™ Consumerã€‚ result.addAttachments(RpcContext.getServerContext().getAttachments()); return result; &#125; finally &#123; // æ¸…é™¤ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå½“å‰çº¿ç¨‹å¤„ç†ä¸‹ä¸€ä¸ªè°ƒç”¨çš„æ—¶å€™ï¼Œä¼šåˆ›å»ºæ–°çš„ RpcContext RpcContext.removeContext(); RpcContext.getServerContext().clearAttachments(); &#125; &#125;&#125; éšå¼å‚æ•°Dubbo ä¸­çš„ Attachment åœ¨æœåŠ¡æ¶ˆè´¹æ–¹å’Œæä¾›æ–¹ä¹‹é—´éšå¼ä¼ é€’å‚æ•°ï¼Œå¯ä»¥é€šè¿‡ RpcContext ä¸Šçš„ setAttachment å’Œ getAttachment åœ¨æœåŠ¡æ¶ˆè´¹æ–¹å’Œæä¾›æ–¹ä¹‹é—´è¿›è¡Œå‚æ•°çš„éšå¼ä¼ é€’ï¼Œè€Œä¼ é€’çš„è½½ä½“å°±æ˜¯ Invocation å¯¹è±¡ã€‚Attachment ä¼ é€’çš„è¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ³¨æ„ï¼š path, group, version, dubbo, token, timeout,async å‡ ä¸ª key æ˜¯ä¿ç•™å­—æ®µï¼Œåœ¨è®¾ç½® Attachment å‚æ•°çš„ key æ—¶éœ€è¦ä½¿ç”¨å…¶å®ƒåç§°ã€‚ æ¶ˆè´¹ç«¯åœ¨æ¶ˆè´¹ç«¯ä½¿ç”¨ setAttachment è®¾ç½® KV å¯¹ï¼Œåœ¨å®Œæˆä¸€æ¬¡è¿œç¨‹è°ƒç”¨ä¼šè¢«æ¸…ç©ºï¼Œå³å¤šæ¬¡è¿œç¨‹è°ƒç”¨è¦å¤šæ¬¡è®¾ç½®ã€‚ 12345// éšå¼ä¼ å‚ï¼Œåé¢çš„è¿œç¨‹è°ƒç”¨éƒ½ä¼šéšå¼å°†è¿™äº›å‚æ•°å‘é€åˆ°æœåŠ¡å™¨ç«¯ï¼Œç±»ä¼¼cookieï¼Œç”¨äºæ¡†æ¶é›†æˆï¼Œä¸å»ºè®®å¸¸è§„ä¸šåŠ¡ä½¿ç”¨ã€‚RpcContext.getContext().setAttachment(\"index\", \"1\"); // è¿œç¨‹è°ƒç”¨Invoker.invoke(); // ... æœåŠ¡ç«¯åœ¨æœåŠ¡æä¾›ç«¯ä½¿ç”¨ getAttachment è·å–éšå¼å‚æ•°ã€‚ 12// è·å–å®¢æˆ·ç«¯éšå¼ä¼ å…¥çš„å‚æ•°ï¼Œç”¨äºæ¡†æ¶é›†æˆï¼Œä¸å»ºè®®å¸¸è§„ä¸šåŠ¡ä½¿ç”¨String index = RpcContext.getContext().getAttachment(\"index\"); å°ç»“æœ¬ç¯‡æ–‡ç« å¯¹ RpcContext åˆ†åˆ«åœ¨æœåŠ¡æä¾›ç«¯å’ŒæœåŠ¡æ¶ˆè´¹ç«¯çš„åˆå§‹åŒ–è¿›è¡Œäº†ä»‹ç»ï¼Œåˆå§‹åŒ–çš„æ—¶æœºæ˜¯æ¯æ¬¡å‘èµ·è°ƒç”¨å’Œæ¯æ¬¡è¢«è°ƒç”¨ã€‚æœ‰äº† RpcContext å°±ä¸éœ€è¦å°†è°ƒç”¨ç›¸å…³ä¿¡æ¯é€šè¿‡æ–¹æ³•ä¾æ¬¡ä¼ é€’äº†ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"}]},{"title":"Dubboè¿‡æ»¤å™¨ - ClassLoaderFilter","slug":"rpc/Dubboè¿‡æ»¤å™¨-ClassLoaderFilter","date":"2020-07-25T16:00:00.000Z","updated":"2021-02-18T09:53:39.254Z","comments":false,"path":"posts/3fc82a32/","link":"","permalink":"https://gentryhuang.com/posts/3fc82a32/","excerpt":"","text":"æ¦‚è¿°ClassLoaderFilter æ˜¯æœåŠ¡æä¾›ç«¯çš„ä¸€ä¸ª Filter å®ç°ï¼Œç”¨äºåˆ‡æ¢å½“å‰å·¥ä½œçº¿ç¨‹çš„ç±»åŠ è½½å™¨åˆ°æ¥å£çš„ç±»åŠ è½½å™¨ï¼Œä»¥ä¾¿å’Œæ¥å£çš„ç±»åŠ è½½å™¨çš„ä¸Šä¸‹æ–‡ä¸€èµ·å·¥ä½œã€‚ ClassLoaderFilter123456789101112131415161718Activate(group = Constants.PROVIDER, order = -30000)public class ClassLoaderFilter implements Filter &#123; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; // è·å¾—å½“å‰çº¿ç¨‹çš„ç±»åŠ è½½å™¨ ClassLoader ocl = Thread.currentThread().getContextClassLoader(); // åˆ‡æ¢å½“å‰çº¿ç¨‹çš„ç±»åŠ è½½å™¨ä¸ºæœåŠ¡æ¥å£çš„ç±»åŠ è½½å™¨ Thread.currentThread().setContextClassLoader(invoker.getInterface().getClassLoader()); try &#123; // ç»§ç»­è¿‡æ»¤å™¨é“¾çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ return invoker.invoke(invocation); &#125; finally &#123; // åˆ‡æ¢å½“å‰çº¿ç¨‹çš„ç±»åŠ è½½å™¨ä¸ºåŸæ¥çš„ç±»åŠ è½½å™¨ Thread.currentThread().setContextClassLoader(ocl); &#125; &#125;&#125; ClassLoaderFilter çš„é€»è¾‘ï¼šé¦–å…ˆè·å–å½“å‰çº¿ç¨‹å…³è”çš„ ClassLoaderï¼Œç„¶åå°†å…¶ ClassLoader è®¾ç½®ä¸º invoker.getInterface().getClassLoader()ï¼Œä¹Ÿå°±æ˜¯åŠ è½½æœåŠ¡æ¥å£ç±»çš„ç±»åŠ è½½å™¨ï¼›ä¹‹åæ‰§è¡Œ invoker.invoke() æ–¹æ³•ï¼Œæ‰§è¡Œåç»­çš„ Filter é€»è¾‘ä»¥åŠä¸šåŠ¡é€»è¾‘ï¼›æœ€åï¼Œå°†å½“å‰çº¿ç¨‹å…³è”çš„ ClassLoader é‡ç½®ä¸ºåŸæ¥çš„ ClassLoader ocl ã€‚ åŒäº²å§”æ´¾æ¨¡å‹å¦‚æœ ClassA å’Œ ClassB éƒ½æ˜¯åŒä¸€ä¸ªç±»åŠ è½½å™¨åŠ è½½çš„ï¼Œåˆ™å®ƒä»¬ä¹‹é—´æ˜¯å¯ä»¥ç›¸äº’è®¿é—®çš„ã€‚å¦‚æœ ClassA å’Œ ClassB æ˜¯ä¸åŒçš„ç±»åŠ è½½å™¨åŠ è½½çš„ï¼Œç¤ºä¾‹å›¾å¦‚ä¸‹ï¼š æ ¹æ®åŒäº²å§”æ´¾æ¨¡å‹ï¼Œå¦‚æœ ClassA è¦è®¿é—® ClassBï¼Œå¤§è‡´æµç¨‹å¦‚ä¸‹ï¼š ClassA ä¼šä» ClassLoaderA ä¸­æŸ¥æ‰¾ ClassBï¼Œçœ‹æ˜¯å¦å·²ç»åŠ è½½ã€‚ æ²¡æœ‰æ‰¾åˆ° ClassB åˆ™ä¼šç»§ç»­å¾€ä¸Šå±‚æŸ¥æ‰¾ï¼Œçœ‹çˆ¶ç±»åŠ è½½å™¨ ParentClassLoader æ˜¯å¦å¯ä»¥æŸ¥æ‰¾åˆ° ClassBï¼Œå¦‚æœæ‰¾ä¸åˆ°ä¼šç»§ç»­å¾€ä¸Šå±‚çˆ¶ç±»åŠ è½½å™¨æŸ¥æ‰¾ã€‚ æœ€ç»ˆæ²¡æœ‰æ‰¾åˆ°ï¼Œä¼šæŠ›å‡º ClassNotFoundException å¼‚å¸¸ã€‚ å¦‚æœè¦å®ç°è¿ååŒäº²å§”æ´¾æ¨¡å‹æ¥æŸ¥æ‰¾ Classï¼Œé€šå¸¸ä¼šä½¿ç”¨ä¸Šä¸‹æ–‡ç±»åŠ è½½å™¨ ContextClassFilter ã€‚ QAQ: ClassLoaderFilter çš„å…·ä½“ä½œç”¨ï¼Ÿ A: Dubbo æ¡†æ¶çº¿ç¨‹çš„ç±»åŠ è½½å™¨å¯èƒ½å’ŒæœåŠ¡æ¥å£çš„ç±»åŠ è½½å™¨ä¸æ˜¯åŒä¸€ä¸ªï¼Œè€Œå½“å‰æ¡†æ¶çº¿ç¨‹ä¸­åˆéœ€è¦è·å–æœåŠ¡æ¥å£çš„ç±»åŠ è½½ä¸­çš„ä¸€äº› Classï¼Œä¸ºäº†é¿å…å‡ºç° ClassNotFoundExceptionï¼Œæ­¤æ—¶åªéœ€è¦å°†æ¡†æ¶çº¿ç¨‹çš„ç±»åŠ è½½å™¨åˆ‡æ¢åˆ°åŠ è½½äº†æ¥å£å®šä¹‰çš„ç±»åŠ è½½å™¨ï¼Œè¿›è€Œå°±èƒ½è·å¾—è¿™ä¸ªç±»åŠ è½½ä¸­çš„ Class ã€‚ Extra: Dubbo ä¸­è¿›è¡Œåºåˆ—åŒ–ä¼˜åŒ–æ—¶ï¼Œä¼šæ ¹æ® Invoker ä¸­é…ç½®çš„ optimizer å‚æ•°è·å–æ‰©å±•çš„è‡ªå®šä¹‰åºåˆ—åŒ–å¤„ç†ç±»ï¼Œè¿™äº›å¤–éƒ¨å¼•å…¥çš„åºåˆ—åŒ–ç±»åœ¨æ¡†æ¶çš„ç±»åŠ è½½å™¨ä¸­è‚¯å®šæ²¡æœ‰ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ Invoker çš„ç±»åŠ è½½å™¨è·å–å¯¹åº”çš„ç±»ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152+--- DubboProtocol/** * è¿›è¡Œåºåˆ—åŒ–ä¼˜åŒ–ï¼Œæ³¨å†Œéœ€è¦ä¼˜åŒ–çš„ç±» * * @param url * @throws RpcException */ private void optimizeSerialization(URL url) throws RpcException &#123; // è·å¾— optimizer åºåˆ—åŒ–ä¼˜åŒ–å™¨ é…ç½®é¡¹ String className = url.getParameter(Constants.OPTIMIZER_KEY, \"\"); // å¦‚æœç³»ç»Ÿä¸­æ²¡æœ‰åºåˆ—åŒ–ä¼˜åŒ–å™¨å°±ç›´æ¥è¿”å› if (StringUtils.isEmpty(className) || optimizers.contains(className)) &#123; return; &#125; logger.info(\"Optimizing the serialization process for Kryo, FST, etc...\"); try &#123; // æ ¹æ® åºåˆ—åŒ–ä¼˜åŒ–å™¨å åŠ è½½ SerializationOptimizer å®ç°ç±»ã€‚ // è¿™é‡Œçš„å½“å‰çº¿ç¨‹çš„ ClassLoader æ˜¯å¤„ç†è¿‡çš„ï¼Œä½¿ç”¨çš„æ˜¯ Invoker çš„ç±»åŠ è½½å™¨ Class clazz = Thread.currentThread().getContextClassLoader().loadClass(className); // æ˜¯å¦æ˜¯ SerializationOptimizer.classï¼Œæˆ–è€… æ˜¯SerializationOptimizerçš„å­ if (!SerializationOptimizer.class.isAssignableFrom(clazz)) &#123; throw new RpcException(\"The serialization optimizer \" + className + \" isn't an instance of \" + SerializationOptimizer.class.getName()); &#125; // åˆ›å»º SerializationOptimizer å¯¹è±¡ SerializationOptimizer optimizer = (SerializationOptimizer) clazz.newInstance(); // æ²¡æœ‰è¦ä¼˜åŒ–çš„ç±»ç›´æ¥è¿”å› if (optimizer.getSerializableClasses() == null) &#123; return; &#125; // å°†è¦ä¼˜åŒ–çš„ç±»æ³¨å†Œåˆ° SerializableClassRegistry ä¸­ ï¼ˆtodo åœ¨ä½¿ç”¨ Kryo,FST ç­‰åºåˆ—åŒ–ç®—æ³•æ—¶ï¼Œä¼šè¯»å–è¯¥é›†åˆä¸­çš„ç±»ï¼Œå®Œæˆæ³¨å†Œï¼‰ for (Class c : optimizer.getSerializableClasses()) &#123; SerializableClassRegistry.registerClass(c); &#125; // å°† åºåˆ—åŒ–ä¼˜åŒ–å™¨å®ç°ç±»å åŠ å…¥åˆ°ç¼“å­˜ä¸­ optimizers.add(className); &#125; catch (ClassNotFoundException e) &#123; throw new RpcException(\"Cannot find the serialization optimizer class: \" + className, e); &#125; catch (InstantiationException e) &#123; throw new RpcException(\"Cannot instantiate the serialization optimizer class: \" + className, e); &#125; catch (IllegalAccessException e) &#123; throw new RpcException(\"Cannot instantiate the serialization optimizer class: \" + className, e); &#125; &#125; å°ç»“æœ¬ç¯‡æ–‡ä»¶ç®€å•ä»‹ç»äº† Dubbo Filter ä¹‹ æœåŠ¡ç«¯çš„ ClassLoader è¿‡æ»¤å™¨ï¼Œå®ƒçš„ä½œç”¨å°±æ˜¯ç”¨äºåˆ‡æ¢å½“å‰å·¥ä½œçº¿ç¨‹çš„ç±»åŠ è½½å™¨åˆ°æ¥å£çš„ç±»åŠ è½½å™¨ï¼Œä»¥ä¾¿å’Œæ¥å£çš„ç±»åŠ è½½å™¨çš„ä¸Šä¸‹æ–‡ä¸€èµ·å·¥ä½œã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"}]},{"title":"Dubboè¿‡æ»¤å™¨ - ExecuteLimitFilter & ActiveLimitFilter","slug":"rpc/Dubboè¿‡æ»¤å™¨-ExecuteLimitFilter","date":"2020-07-19T16:00:00.000Z","updated":"2021-02-17T06:01:12.350Z","comments":false,"path":"posts/bfcb5211/","link":"","permalink":"https://gentryhuang.com/posts/bfcb5211/","excerpt":"","text":"æ¦‚è¿°ExecuteLimitFilter æ˜¯ Dubbo åœ¨æœåŠ¡æä¾›ç«¯é™æµçš„å®ç°ï¼Œç”¨äºé™åˆ¶æ¯ä¸ªæœåŠ¡ä¸­æ¯ä¸ªæ–¹æ³•çš„æœ€å¤§å¹¶å‘æ•°ï¼ˆæˆ–å ç”¨çº¿ç¨‹æ± çº¿ç¨‹æ•°ï¼‰ã€‚ActiveLimitFilter æ˜¯ Dubbo åœ¨æ¶ˆè´¹ç«¯çš„é™æµå®ç°ï¼Œç”¨äºé™åˆ¶ä¸€ä¸ªæ¶ˆè´¹è€…å¯¹ä¸€ä¸ªæœåŠ¡ç«¯æ–¹æ³•çš„å¹¶å‘è°ƒç”¨é‡ï¼ˆæˆ–å ç”¨è¿æ¥çš„è¯·æ±‚æ•°ï¼‰ã€‚å®ƒä»¬éƒ½æ”¯æŒæ¥å£çº§åˆ«å’Œæ–¹æ³•çº§åˆ«çš„é…ç½®ã€‚ è¯´æ˜Dubbo åœ¨ 2.6 å’Œ 2.7 ç‰ˆæœ¬çš„å®ç°ä¸­æœ‰äº›è®¸å·®å¼‚ï¼Œä¸‹é¢æˆ‘ä»¬åˆ†åˆ«å¯¹ä¸åŒç‰ˆæœ¬çš„å®ç°è¿›è¡Œè¯´æ˜ã€‚ Dubbo 2.6 å®ç°ExecuteLimitFilteræœåŠ¡ç«¯é™æµ é…ç½®æ–¹å¼1234567&lt;!-- æ¥å£çº§åˆ«é…ç½®ï¼Œæ¯ä¸ªæ–¹æ³•çš„å¹¶å‘æ‰§è¡Œæ•°ï¼ˆæˆ–å ç”¨çº¿ç¨‹æ± çº¿ç¨‹æ•°ï¼‰ä¸èƒ½è¶…è¿‡ N ä¸ª --&gt;&lt;dubbo:service interface=\"com.foo.BarService\" executes=\"N\"/&gt;&lt;!-- æ–¹æ³•çº§åˆ«é…ç½®ï¼ŒsayHelloæ–¹æ³•çš„å¹¶å‘æ‰§è¡Œæ•°ï¼ˆæˆ–å ç”¨çº¿ç¨‹æ± çº¿ç¨‹æ•°ï¼‰ä¸èƒ½è¶…è¿‡ N ä¸ª --&gt;&lt;dubbo:service interface=\"com.foo.BarService\"&gt; &lt;dubbo:method name=\"sayHello\" executes=\"N\"&gt;&lt;/dubbo:service&gt; æ³¨æ„ï¼Œå¦‚æœä¸è®¾ç½®ï¼Œåˆ™é»˜è®¤ä¸åšé™åˆ¶ï¼Œå¦‚æœè®¾ç½®äº†å°äºç­‰äº0ï¼Œé‚£ä¹ˆåŒæ ·æ˜¯ä¸åšä»»ä½•é™åˆ¶ã€‚ ä»£ç å®ç°1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Activate(group = Constants.PROVIDER, value = Constants.EXECUTES_KEY)public class ExecuteLimitFilter implements Filter &#123; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; // è·å¾—URL URL url = invoker.getUrl(); // è·å¾—æ–¹æ³•å String methodName = invocation.getMethodName(); // ä¿¡å·é‡ Semaphore executesLimit = null; // æ˜¯å¦è·å¾—ä¿¡å·é‡ boolean acquireResult = false; // è·å¾—æœåŠ¡æä¾›æ–¹å½“å‰æ–¹æ³•æœ€å¤§å¯å¹¶å‘è¯·æ±‚æ•° int max = url.getMethodParameter(methodName, Constants.EXECUTES_KEY, 0); // æœ€å¤§å¯å¹¶å‘è¯·æ±‚æ•°å¤§äº0 if (max &gt; 0) &#123; // åŸºäº æœåŠ¡URL + æ–¹æ³•çº¬åº¦ï¼Œåˆ›å»º/è·å– RpcStatus è®¡æ•°å™¨ RpcStatus count = RpcStatus.getStatus(url, invocation.getMethodName()); // åˆ›å»º/è·å– RpcStatus è®¡æ•°å™¨å¯¹åº”çš„ä¿¡å·é‡ executesLimit = count.getSemaphore(max); // å°è¯•è·å–ä¿¡å·é‡ï¼Œè·å–å¤±è´¥åˆ™æŠ›å‡ºå¼‚å¸¸ if (executesLimit != null &amp;&amp; !(acquireResult = executesLimit.tryAcquire())) &#123; throw new RpcException(\"Failed to invoke method \" + invocation.getMethodName() + \" in provider \" + url + \", cause: The service using threads greater than &lt;dubbo:service executes=\\\"\" + max + \"\\\" /&gt; limited.\"); &#125; &#125; long begin = System.currentTimeMillis(); boolean isSuccess = true; // è®¡æ•°å™¨ +1 RpcStatus.beginCount(url, methodName); try &#123; // æœåŠ¡è°ƒç”¨ Result result = invoker.invoke(invocation); return result; &#125; catch (Throwable t) &#123; // æ ‡è®°å¤±è´¥ isSuccess = false; if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new RpcException(\"unexpected exception when ExecuteLimitFilter\", t); &#125; &#125; finally &#123; // è®¡æ•°å™¨-1 [è°ƒç”¨å¤±è´¥/æˆåŠŸï¼Œçœ‹isSuccessçš„å€¼] RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, isSuccess); // é‡Šæ”¾ä¿¡å·é‡ if (acquireResult) &#123; executesLimit.release(); &#125; &#125; &#125;&#125; ExecuteLimitFilter æœ¬è´¨ä¸Šæ˜¯åˆ©ç”¨ RpcStatus ä¸­ç»´æŠ¤çš„ Semaphore è¿›è¡Œå¹¶å‘æ§åˆ¶ï¼Œè¿›è€Œè¾¾åˆ°é™æµçš„ç›®çš„ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼ŒExecuteLimitFilter è™½ç„¶ä½¿ç”¨åˆ°äº†è®¡æ•°å™¨ï¼Œä½†æ˜¯èµ·åˆ°é™æµä½œç”¨çš„å¹¶ä¸æ˜¯å®ƒï¼Œè€Œæ˜¯è®¡æ•°å™¨å¯¹åº”çš„ä¿¡å·é‡ Semaphore ã€‚åœ¨ Dubbo 2.7 ç‰ˆæœ¬ä¸­ç§»é™¤äº†ä¿¡å·é‡çš„å®ç°ï¼Œä½¿ç”¨è®¡æ•°å™¨çš„åŸå­ç±»æ“ä½œå’ŒCASæœºåˆ¶å®ç°é™æµã€‚ ActiveLimitFilterå®¢æˆ·ç«¯é™æµ é…ç½®æ–¹å¼1234567891011&lt;!-- æ¥å£çº§åˆ«é…ç½®ï¼Œæ¯ä¸ªæ–¹æ³•åœ¨æ¯ä¸ªå®¢æˆ·ç«¯çš„å¹¶å‘è°ƒç”¨æ•°ï¼ˆå ç”¨è¿æ¥çš„è¯·æ±‚æ•°ï¼‰ä¸èƒ½è¶…è¿‡ N ä¸ª --&gt;&lt;dubbo:service interface=\"com.foo.BarService\" actives=\"N\"/&gt; &lt;!--åœ¨æœåŠ¡ç«¯é…ç½®--&gt;&lt;dubbo:reference interface=\"com.foo.BarService\" actives=\"N\"/&gt; &lt;!--åœ¨å®¢æˆ·ç«¯é…ç½®--&gt;&lt;!-- æ–¹æ³•çº§åˆ«é…ç½®ï¼ŒsayHelloæ–¹æ³•åœ¨æ¯ä¸ªå®¢æˆ·ç«¯çš„å¹¶å‘è°ƒç”¨æ•°ï¼ˆå ç”¨è¿æ¥çš„è¯·æ±‚æ•°ï¼‰ä¸èƒ½è¶…è¿‡ N ä¸ª --&gt;&lt;dubbo:service interface=\"com.foo.BarService\"&gt; &lt;dubbo:method name=\"sayHello\" actives=\"N\"&gt;&lt;!--åœ¨æœåŠ¡ç«¯é…ç½®--&gt;&lt;/dubbo:service&gt;&lt;dubbo:reference interface=\"com.foo.BarService\"&gt; &lt;dubbo:method name=\"sayHello\" actives=\"N\"&gt;&lt;!--åœ¨æœåŠ¡ç«¯é…ç½®--&gt;&lt;/dubbo:reference&gt; æ³¨æ„ï¼Œå¦‚æœæœåŠ¡ç«¯ä¾§å’Œæ¶ˆè´¹ç«¯ä¾§éƒ½é…ç½®äº† activesï¼Œåˆ™æ¶ˆè´¹ç«¯ä¾§ä¼˜å…ˆã€‚å¦‚æœè®¾ç½®äº† actives å°äºç­‰äº 0ï¼Œåˆ™ä¸åšå¹¶å‘é™åˆ¶ã€‚ ä»£ç å®ç°1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@Activate(group = Constants.CONSUMER, value = Constants.ACTIVES_KEY)public class ActiveLimitFilter implements Filter &#123; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; // è·å–URL URL url = invoker.getUrl(); // è·å–æ–¹æ³•å String methodName = invocation.getMethodName(); // è·å–å½“å‰æ–¹æ³•åœ¨å½“å‰å®¢æˆ·ç«¯çš„æœ€å¤§è°ƒç”¨é‡ int max = invoker.getUrl().getMethodParameter(methodName, Constants.ACTIVES_KEY, 0); // åŸºäºæœåŠ¡URL + æ–¹æ³•çº¬åº¦ï¼Œ è·å¾— RpcStatus å¯¹è±¡ RpcStatus count = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()); if (max &gt; 0) &#123; /** * è·å¾—è¶…æ—¶æ—¶é—´ [æ³¨æ„ï¼šè¿™é‡Œçš„è¶…æ—¶å€¼ä¸å ç”¨è°ƒç”¨æœåŠ¡çš„è¶…æ—¶æ—¶é—´] ï¼Œæ˜¯ç”¨æ¥æ§åˆ¶ç­‰å¾…è¯·æ±‚é‡Šæ”¾èµ„æºçš„æ—¶é—´ï¼Œé˜²æ­¢ç­‰å¾…æ—¶é—´å¤ªä¹…ã€‚ * åœ¨æç«¯æƒ…å†µä¸‹ï¼Œè°ƒç”¨æœåŠ¡çš„æ—¶é—´å‡ ä¹æ˜¯ 2 * timeout */ long timeout = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.TIMEOUT_KEY, 0); long start = System.currentTimeMillis(); long remain = timeout; // è·å–å½“å‰å¹¶å‘åº¦ int active = count.getActive(); // å¦‚æœè¾¾åˆ°é™æµé˜ˆå€¼ï¼Œå’ŒæœåŠ¡æä¾›è€…ä¸ä¸€æ ·ï¼Œå¹¶ä¸æ˜¯ç›´æ¥æŠ›å‡ºå¼‚å¸¸ï¼Œè€Œæ˜¯å…ˆç­‰å¾…ç›´åˆ°è¶…æ—¶ä»¥ç­‰å¾…å¹¶å‘åº¦é™ä½ï¼Œå› ä¸ºè¯·æ±‚æ˜¯å…è®¸æœ‰è¶…æ—¶æ—¶é—´çš„ã€‚ if (active &gt;= max) &#123; // å¹¶å‘æ§åˆ¶ synchronized (count) &#123; /** * * å¾ªç¯è·å–å½“å‰å¹¶å‘æ•°ï¼Œå¦‚æœå¤§äºé™æµé˜ˆå€¼åˆ™ç­‰å¾… * ä¼šæœ‰ä¸¤ç§ç»“æœï¼š * 1 æŸä¸ªInvokeråœ¨è°ƒç”¨ç»“æŸåï¼Œå¹¶å‘æŠŠè®¡æ•°å™¨åŸå­-1å¹¶å”¤é†’ç­‰å¾…çº¿ç¨‹ï¼Œä¼šæœ‰ä¸€ä¸ªç­‰å¾…çŠ¶æ€çš„çº¿ç¨‹è¢«å”¤é†’å¹¶ç»§ç»­æ‰§è¡Œé€»è¾‘ * 2 waitç­‰å¾…è¶…æ—¶éƒ½æ²¡æœ‰è¢«å”¤é†’ï¼Œæ­¤æ—¶æŠ›å‡ºå¼‚å¸¸ */ while ((active = count.getActive()) &gt;= max) &#123; try &#123; // ç­‰å¾…ï¼Œç›´åˆ°è¶…æ—¶ï¼Œæˆ–è€…è¢«å”¤é†’ count.wait(remain); &#125; catch (InterruptedException e) &#123; &#125; // æ˜¯å¦è¶…æ—¶ï¼Œè¶…æ—¶åˆ™æŠ›å‡ºå¼‚å¸¸ long elapsed = System.currentTimeMillis() - start; remain = timeout - elapsed; if (remain &lt;= 0) &#123; throw new RpcException(\"Waiting concurrent invoke timeout in client-side for service: \" + invoker.getInterface().getName() + \", method: \" + invocation.getMethodName() + \", elapsed: \" + elapsed + \", timeout: \" + timeout + \". concurrent invokes: \" + active + \". max concurrent invoke limit: \" + max); &#125; &#125; &#125; &#125; &#125; try &#123; long begin = System.currentTimeMillis(); // å¼€å§‹è®¡æ•°ï¼Œå¹¶å‘åŸå­æ•° + 1 RpcStatus.beginCount(url, methodName); try &#123; // è°ƒç”¨æœåŠ¡ Result result = invoker.invoke(invocation); // ç»“æŸè®¡æ•°ï¼ˆè°ƒç”¨æˆåŠŸï¼‰ï¼Œå¹¶å‘åŸå­æ•° - 1 RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, true); return result; &#125; catch (RuntimeException t) &#123; // ç»“æŸè®¡æ•°ï¼ˆè°ƒç”¨å¤±è´¥ï¼‰ï¼Œå¹¶å‘åŸå­æ•° -1 RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, false); throw t; &#125; &#125; finally &#123; // å”¤é†’ç­‰å¾…çš„ç›¸åŒæœåŠ¡çš„ç›¸åŒæ–¹æ³•çš„è¯·æ±‚ if (max &gt; 0) &#123; synchronized (count) &#123; count.notify(); &#125; &#125; &#125; &#125;&#125; ActiveLimitFilter ä¾èµ– RpcStatus çš„ beginCount() æ–¹æ³•å’Œ endCount() æ–¹æ³•æ¥å®ç° RpcStatus.active å­—æ®µçš„å¢å‡æ¥è¾¾åˆ°é™æµçš„ç›®çš„ã€‚ æ­¤å¤–ï¼Œåšä¸ºæ¶ˆè´¹ç«¯çš„é™æµè¿‡æ»¤å™¨ï¼Œè¾¾åˆ°é™æµçš„é˜ˆå€¼æ—¶å¹¶ä¸æ˜¯ç›´æ¥æŠ›å‡ºå¼‚å¸¸ï¼Œè€Œæ˜¯å……åˆ†åˆ©ç”¨è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼Œå…è®¸åœ¨è¯·æ±‚è¶…æ—¶æ—¶é—´å†…ç­‰å¾…å¹¶å‘åº¦é™ä½ã€‚ RpcStatusRpcStatus åšä¸º ExecuteLimitFilter å’Œ ActiveLimitFilter å®ç°é™æµçš„æ ¸å¿ƒç±»ï¼Œå‰è€…é™æµä½¿ç”¨ RpcStatus å°è£…çš„ä¿¡å·é‡ Semaphore ï¼Œåè€…é™æµä½¿ç”¨ RpcStatus ç»´æŠ¤çš„åŸå­ç±»å‹çš„ AtomicInteger active å±æ€§ã€‚ä¸‹é¢æˆ‘ä»¬å¯¹ RpcStatus çš„æ ¸å¿ƒä»£ç å®ç°è¿›è¡Œåˆ†æã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318public class RpcStatus &#123; /** * æœåŠ¡çŠ¶æ€ä¿¡æ¯ * key: URL * value: RpcStatus è®¡æ•°å™¨ */ private static final ConcurrentMap&lt;String, RpcStatus&gt; SERVICE_STATISTICS = new ConcurrentHashMap&lt;String, RpcStatus&gt;(); /** * æœåŠ¡æ¯ä¸ªæ–¹æ³•çš„çŠ¶æ€ä¿¡æ¯ * key1: URL * key2: æ–¹æ³•å * RpcStatus è®¡æ•°å™¨ */ private static final ConcurrentMap&lt;String, ConcurrentMap&lt;String, RpcStatus&gt;&gt; METHOD_STATISTICS = new ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, RpcStatus&gt;&gt;(); private final ConcurrentMap&lt;String, Object&gt; values = new ConcurrentHashMap&lt;String, Object&gt;(); /** * å½“å‰å¹¶å‘åº¦ * * @see com.alibaba.dubbo.rpc.filter.ActiveLimitFilter */ private final AtomicInteger active = new AtomicInteger(); /** * æ€»è°ƒç”¨æ¬¡æ•° */ private final AtomicLong total = new AtomicLong(); /** * æ€»è°ƒç”¨å¤±è´¥æ¬¡æ•° */ private final AtomicInteger failed = new AtomicInteger(); /** * æ€»è°ƒç”¨æ—¶é•¿ï¼Œå•ä½ï¼š æ¯«ç§’ */ private final AtomicLong totalElapsed = new AtomicLong(); /** * æ€»è°ƒç”¨å¤±è´¥æ—¶é•¿ï¼Œå•ä½ï¼šæ¯«ç§’ */ private final AtomicLong failedElapsed = new AtomicLong(); /** * æ‰€æœ‰è°ƒç”¨ä¸­æœ€é•¿çš„è€—æ—¶ï¼Œå•ä½ï¼šæ¯«ç§’ */ private final AtomicLong maxElapsed = new AtomicLong(); /** * æ‰€æœ‰å¤±è´¥è°ƒç”¨ä¸­æœ€é•¿çš„è€—æ—¶ï¼Œå•ä½ï¼šæ¯«ç§’ */ private final AtomicLong failedMaxElapsed = new AtomicLong(); /** * æ‰€æœ‰æˆåŠŸè°ƒç”¨ä¸­æœ€é•¿çš„è€—æ—¶ï¼Œå•ä½ï¼šæ¯«ç§’ */ private final AtomicLong succeededMaxElapsed = new AtomicLong(); /** * Semaphore used to control concurrency limit set by `executes` * &lt;p&gt; * æœåŠ¡æ‰§è¡Œä¿¡å·é‡ã€åŒ…å«æœåŠ¡æ‰§è¡Œä¿¡å·é‡å¤§å°ã€‘ * * @see com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter */ private volatile Semaphore executesLimit; /** * æœåŠ¡æ‰§è¡Œä¿¡å·é‡å¤§å° */ private volatile int executesPermits; private RpcStatus() &#123; &#125; /** * æ ¹æ®æœåŠ¡URLä¸ºçº¬åº¦çš„è·å¾—RpcStatus * * @param url * @return status */ public static RpcStatus getStatus(URL url) &#123; // URLçš„å­—ç¬¦ä¸² String uri = url.toIdentityString(); // æ˜¯å¦å­˜åœ¨ RpcStatus status = SERVICE_STATISTICS.get(uri); // ä¸å­˜åœ¨åˆ™åˆ›å»ºï¼Œå¹¶ä¸”æ”¾å…¥ç¼“å­˜ä¸­ if (status == null) &#123; SERVICE_STATISTICS.putIfAbsent(uri, new RpcStatus()); status = SERVICE_STATISTICS.get(uri); &#125; return status; &#125; /** * æ ¹æ® æœåŠ¡URL + æ–¹æ³• è·å¾—RpcStatus * * @param url * @param methodName * @return status */ public static RpcStatus getStatus(URL url, String methodName) &#123; String uri = url.toIdentityString(); // è·å¾—æ–¹æ³•é›†åˆ ConcurrentMap&lt;String, RpcStatus&gt; map = METHOD_STATISTICS.get(uri); if (map == null) &#123; METHOD_STATISTICS.putIfAbsent(uri, new ConcurrentHashMap&lt;String, RpcStatus&gt;()); map = METHOD_STATISTICS.get(uri); &#125; RpcStatus status = map.get(methodName); if (status == null) &#123; map.putIfAbsent(methodName, new RpcStatus()); status = map.get(methodName); &#125; return status; &#125; /** * æœåŠ¡è°ƒç”¨å¼€å§‹è®¡æ•° * * @param url URL å¯¹è±¡ * @param methodName æ–¹æ³•å */ public static void beginCount(URL url, String methodName) &#123; // SERVICE_STATISTICS -&gt; åŸºäºæœåŠ¡URLçš„è®¡æ•° beginCount(getStatus(url)); // METHOD_STATISTICS -&gt; åŸºäºæœåŠ¡URL + æ–¹æ³•çš„è®¡æ•° beginCount(getStatus(url, methodName)); &#125; /** * è®¡æ•° - è°ƒç”¨ä¸­çš„æ¬¡æ•° * * @param status */ private static void beginCount(RpcStatus status) &#123; status.active.incrementAndGet(); &#125; /** * æœåŠ¡è°ƒç”¨ç»“æŸçš„è®¡æ•° * * @param url URLå¯¹è±¡ * @param methodName æ–¹æ³•å * @param elapsed æ—¶é•¿ï¼Œæ¯«ç§’ * @param succeeded æ˜¯å¦æˆåŠŸ */ public static void endCount(URL url, String methodName, long elapsed, boolean succeeded) &#123; // SERVICE_STATISTICS -&gt; åŸºäºæœåŠ¡URLçš„è®¡æ•° endCount(getStatus(url), elapsed, succeeded); // METHOD_STATISTICS -&gt; åŸºäºæœåŠ¡URL + æ–¹æ³•çš„è®¡æ•° endCount(getStatus(url, methodName), elapsed, succeeded); &#125; /** * ç»“æŸè®¡æ•° * * @param status * @param elapsed * @param succeeded */ private static void endCount(RpcStatus status, long elapsed, boolean succeeded) &#123; // è°ƒç”¨çš„æ¬¡æ•°è¦é€’å‡ status.active.decrementAndGet(); // æ€»è°ƒç”¨æ¬¡æ•°é€’å¢ status.total.incrementAndGet(); // æ€»è°ƒç”¨æ—¶é•¿é€’å¢ status.totalElapsed.addAndGet(elapsed); // æ›´æ–°æœ€å¤§è°ƒç”¨æ—¶é•¿ if (status.maxElapsed.get() &lt; elapsed) &#123; status.maxElapsed.set(elapsed); &#125; // æ˜¯å¦è°ƒç”¨æˆåŠŸ if (succeeded) &#123; // æ›´æ–°æœ€å¤§æˆåŠŸè°ƒç”¨æ—¶é•¿ if (status.succeededMaxElapsed.get() &lt; elapsed) &#123; status.succeededMaxElapsed.set(elapsed); &#125; &#125; else &#123; // è°ƒç”¨å¤±è´¥æ¬¡æ•°é€’å¢ status.failed.incrementAndGet(); // æ€»è°ƒç”¨å¤±è´¥æ—¶é•¿ status.failedElapsed.addAndGet(elapsed); // æ›´æ–°æœ€å¤§å¤±è´¥è°ƒç”¨æ—¶é•¿ if (status.failedMaxElapsed.get() &lt; elapsed) &#123; status.failedMaxElapsed.set(elapsed); &#125; &#125; &#125; /** * set value. * * @param key * @param value */ public void set(String key, Object value) &#123; values.put(key, value); &#125; /** * get value. * * @param key * @return value */ public Object get(String key) &#123; return values.get(key); &#125; /** * get active. * * @return active */ public int getActive() &#123; return active.get(); &#125; /** * get total. * * @return total */ public long getTotal() &#123; return total.longValue(); &#125; /** * get total elapsed. * * @return total elapsed */ public long getTotalElapsed() &#123; return totalElapsed.get(); &#125; /** * get failed. * * @return failed */ public int getFailed() &#123; return failed.get(); &#125; /** * get failed elapsed. * * @return failed elapsed */ public long getFailedElapsed() &#123; return failedElapsed.get(); &#125; /** * get succeeded. * * @return succeeded */ public long getSucceeded() &#123; return getTotal() - getFailed(); &#125; /** * get succeeded elapsed. * * @return succeeded elapsed */ public long getSucceededElapsed() &#123; return getTotalElapsed() - getFailedElapsed(); &#125; /** * get succeeded average elapsed. * * @return succeeded average elapsed */ public long getSucceededAverageElapsed() &#123; long succeeded = getSucceeded(); if (succeeded == 0) &#123; return 0; &#125; return getSucceededElapsed() / succeeded; &#125; /** * get succeeded max elapsed. * * @return succeeded max elapsed. */ public long getSucceededMaxElapsed() &#123; return succeededMaxElapsed.get(); &#125; /** * è·å–ä¿¡å·é‡ * &lt;p&gt; * Get the semaphore for thread number. Semaphore's permits is decided by &#123;@link Constants#EXECUTES_KEY&#125; * * @param maxThreadNum value of &#123;@link Constants#EXECUTES_KEY&#125; * @return thread number semaphore */ public Semaphore getSemaphore(int maxThreadNum) &#123; if (maxThreadNum &lt;= 0) &#123; return null; &#125; // è‹¥ä¿¡å·é‡ä¸å­˜åœ¨ï¼Œæˆ–è€…ä¿¡å·é‡å¤§å°æ”¹å˜ï¼Œåˆ™åˆ›å»ºæ–°çš„ä¿¡å·é‡ if (executesLimit == null || executesPermits != maxThreadNum) &#123; synchronized (this) &#123; if (executesLimit == null || executesPermits != maxThreadNum) &#123; // åˆ›å»ºä¿¡å·é‡ executesLimit = new Semaphore(maxThreadNum); executesPermits = maxThreadNum; &#125; &#125; &#125; // è¿”å›ä¿¡å·é‡ return executesLimit; &#125;&#125; Dubbo 2.7 å®ç°ExecuteLimitFilteré…ç½®æ–¹å¼é…ç½®æ–¹å¼åŒ Dubbo 2.6 ç‰ˆæœ¬å®ç°ã€‚ ä»£ç å®ç°12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Activate(group = CommonConstants.PROVIDER, value = EXECUTES_KEY)public class ExecuteLimitFilter implements Filter, Filter.Listener &#123; private static final String EXECUTE_LIMIT_FILTER_START_TIME = \"execute_limit_filter_start_time\"; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; // è·å–ç›¸å…³å‚æ•°ï¼Œä¸ºä¸‹é¢çš„é€»è¾‘åšå‡†å¤‡ URL url = invoker.getUrl(); String methodName = invocation.getMethodName(); int max = url.getMethodParameter(methodName, EXECUTES_KEY, 0); // å°è¯•å¢åŠ activeçš„å€¼ï¼Œå½“å¹¶å‘åº¦è¾¾åˆ°executesé…ç½®æŒ‡å®šçš„é˜ˆå€¼ï¼Œåˆ™ç›´æ¥æŠ›å‡ºå¼‚å¸¸ if (!RpcStatus.beginCount(url, methodName, max)) &#123; throw new RpcException(RpcException.LIMIT_EXCEEDED_EXCEPTION, \"Failed to invoke method \" + invocation.getMethodName() + \" in provider \" + url + \", cause: The service using threads greater than &lt;dubbo:service executes=\\\"\" + max + \"\\\" /&gt; limited.\"); &#125; // è®¾ç½®é™æµçš„å¼€å§‹æ—¶é—´ï¼Œç”¨äºè°ƒç”¨å®Œæˆæˆ–è°ƒç”¨å¼‚å¸¸åçš„æ¶ˆè€—æ—¶é—´è®¡ç®— invocation.put(EXECUTE_LIMIT_FILTER_START_TIME, System.currentTimeMillis()); try &#123; return invoker.invoke(invocation); &#125; catch (Throwable t) &#123; if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new RpcException(\"unexpected exception when ExecuteLimitFilter\", t); &#125; &#125; &#125; /** * è°ƒç”¨ç»“æŸ - Filter.Listener æ¥å£å®ç° * * @param appResponse * @param invoker * @param invocation */ @Override public void onResponse(Result appResponse, Invoker&lt;?&gt; invoker, Invocation invocation) &#123; // å‡å° active çš„å€¼ï¼ŒåŒæ—¶å®Œæˆå¯¹ä¸€æ¬¡è°ƒç”¨çš„ç»Ÿè®¡ RpcStatus.endCount(invoker.getUrl(), invocation.getMethodName(), getElapsed(invocation), true); &#125; /** * è°ƒç”¨å¤±è´¥ - Filter.Listener æ¥å£å®ç° * * @param t * @param invoker * @param invocation */ @Override public void onError(Throwable t, Invoker&lt;?&gt; invoker, Invocation invocation) &#123; if (t instanceof RpcException) &#123; RpcException rpcException = (RpcException) t; if (rpcException.isLimitExceed()) &#123; return; &#125; &#125; // å‡å° active çš„å€¼ï¼ŒåŒæ—¶å®Œæˆå¯¹ä¸€æ¬¡è°ƒç”¨çš„ç»Ÿè®¡ RpcStatus.endCount(invoker.getUrl(), invocation.getMethodName(), getElapsed(invocation), false); &#125; private long getElapsed(Invocation invocation) &#123; Object beginTime = invocation.get(EXECUTE_LIMIT_FILTER_START_TIME); return beginTime != null ? System.currentTimeMillis() - (Long) beginTime : 0; &#125;&#125; ExecuteLimitFilter ä¾èµ– RpcStatus çš„ beginCount() æ–¹æ³•å’Œ endCount() æ–¹æ³•æ¥å®ç° RpcStatus.active å­—æ®µçš„å¢å‡æ¥è¾¾åˆ°é™æµçš„ç›®çš„ï¼Œæ”¾å¼ƒäº† Dubbo 2.6 çš„ä¿¡å·é‡é™æµå®ç°ã€‚ ActiveLimitFilteré…ç½®æ–¹å¼é…ç½®æ–¹å¼åŒ Dubbo 2.6 ç‰ˆæœ¬å®ç°ã€‚ ä»£ç å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111@Activate(group = CONSUMER, value = ACTIVES_KEY)public class ActiveLimitFilter implements Filter, Filter.Listener &#123; private static final String ACTIVELIMIT_FILTER_START_TIME = \"activelimit_filter_start_time\"; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; URL url = invoker.getUrl(); String methodName = invocation.getMethodName(); // è·å–æœ€å¤§å¹¶å‘åº¦ int max = invoker.getUrl().getMethodParameter(methodName, ACTIVES_KEY, 0); // è·å–æœåŠ¡æ–¹æ³•çš„ RpcStatus final RpcStatus rpcStatus = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()); // å°è¯•å¢åŠ activeçš„å€¼ï¼Œå½“å¹¶å‘åº¦è¾¾åˆ°executesé…ç½®æŒ‡å®šçš„é˜ˆå€¼æ—¶ï¼Œåˆ™æ ¹æ®è¶…æ—¶æ—¶é—´è¿›è¡Œç­‰å¾…é‡æ–°è·å– if (!RpcStatus.beginCount(url, methodName, max)) &#123; long timeout = invoker.getUrl().getMethodParameter(invocation.getMethodName(), TIMEOUT_KEY, 0); long start = System.currentTimeMillis(); long remain = timeout; // åŠ é” synchronized (rpcStatus) &#123; // å†æ¬¡å°è¯•å¹¶å‘åº¦åŠ ä¸€ while (!RpcStatus.beginCount(url, methodName, max)) &#123; try &#123; // å½“å‰çº¿ç¨‹é˜»å¡ï¼Œç­‰å¾…å¹¶å‘åº¦é™ä½ rpcStatus.wait(remain); &#125; catch (InterruptedException e) &#123; // ignore &#125; long elapsed = System.currentTimeMillis() - start; remain = timeout - elapsed; // è¶…æ—¶äº†åˆ™æŠ›å‡ºé™æµå¼‚å¸¸ if (remain &lt;= 0) &#123; throw new RpcException(RpcException.LIMIT_EXCEEDED_EXCEPTION, \"Waiting concurrent invoke timeout in client-side for service: \" + invoker.getInterface().getName() + \", method: \" + invocation.getMethodName() + \", elapsed: \" + elapsed + \", timeout: \" + timeout + \". concurrent invokes: \" + rpcStatus.getActive() + \". max concurrent invoke limit: \" + max); &#125; &#125; &#125; &#125; // è®¾ç½®è°ƒç”¨æœåŠ¡å‰çš„æ—¶é—´æˆ³ invocation.put(ACTIVELIMIT_FILTER_START_TIME, System.currentTimeMillis()); return invoker.invoke(invocation); &#125; /** * è°ƒç”¨å®Œæˆ-Filter.Listener æ¥å£å®ç° * * @param appResponse * @param invoker * @param invocation */ @Override public void onResponse(Result appResponse, Invoker&lt;?&gt; invoker, Invocation invocation) &#123; String methodName = invocation.getMethodName(); URL url = invoker.getUrl(); int max = invoker.getUrl().getMethodParameter(methodName, ACTIVES_KEY, 0); // å‡å° active çš„å€¼ï¼ŒåŒæ—¶å®Œæˆå¯¹ä¸€æ¬¡è°ƒç”¨çš„ç»Ÿè®¡ RpcStatus.endCount(url, methodName, getElapsed(invocation), true); // è°ƒç”¨ notifyFinish() æ–¹æ³•å”¤é†’é˜»å¡åœ¨å¯¹åº” RpcStatus å¯¹è±¡ä¸Šçš„çº¿ç¨‹ notifyFinish(RpcStatus.getStatus(url, methodName), max); &#125; /** * è°ƒç”¨å¤±è´¥ - Filter.Listener æ¥å£å®ç° * * @param t * @param invoker * @param invocation */ @Override public void onError(Throwable t, Invoker&lt;?&gt; invoker, Invocation invocation) &#123; String methodName = invocation.getMethodName(); URL url = invoker.getUrl(); int max = invoker.getUrl().getMethodParameter(methodName, ACTIVES_KEY, 0); if (t instanceof RpcException) &#123; RpcException rpcException = (RpcException) t; // é™æµå¼‚å¸¸ä¸å¤„ç† if (rpcException.isLimitExceed()) &#123; return; &#125; &#125; // å‡å° active çš„å€¼ï¼ŒåŒæ—¶å®Œæˆå¯¹ä¸€æ¬¡è°ƒç”¨çš„ç»Ÿè®¡ RpcStatus.endCount(url, methodName, getElapsed(invocation), false); // è°ƒç”¨ notifyFinish() æ–¹æ³•å”¤é†’é˜»å¡åœ¨å¯¹åº” RpcStatus å¯¹è±¡ä¸Šçš„çº¿ç¨‹ï¼ˆæ‰€æœ‰é˜»å¡ç­‰å¾…çš„çº¿ç¨‹ï¼‰ notifyFinish(RpcStatus.getStatus(url, methodName), max); &#125; private long getElapsed(Invocation invocation) &#123; Object beginTime = invocation.get(ACTIVELIMIT_FILTER_START_TIME); return beginTime != null ? System.currentTimeMillis() - (Long) beginTime : 0; &#125; /** * å”¤é†’å› é™æµå¯¼è‡´é˜»å¡ç­‰å¾…çš„çº¿ç¨‹ * * @param rpcStatus * @param max */ private void notifyFinish(final RpcStatus rpcStatus, int max) &#123; if (max &gt; 0) &#123; synchronized (rpcStatus) &#123; rpcStatus.notifyAll(); &#125; &#125; &#125;&#125; ActiveLimitFilter åŒæ ·ä¾èµ– RpcStatus çš„ beginCount() æ–¹æ³•å’Œ endCount() æ–¹æ³•æ¥å®ç° RpcStatus.active å­—æ®µçš„å¢å‡æ¥è¾¾åˆ°é™æµçš„ç›®çš„ã€‚ RpcStatusåŒæ ·åœ°ï¼ŒRpcStatus æ˜¯æœåŠ¡ç«¯å’Œæ¶ˆè´¹ç«¯å®ç°é™æµçš„æ ¸å¿ƒå®ç°ï¼Œä¸‹é¢å¯¹è¯¥å¯¹è±¡è¿›è¡Œè¯´æ˜ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179public class RpcStatus &#123; /** * æœåŠ¡çŠ¶æ€ä¿¡æ¯ * key: URL * value: RpcStatus */ private static final ConcurrentMap&lt;String, RpcStatus&gt; SERVICE_STATISTICS = new ConcurrentHashMap&lt;String, RpcStatus&gt;(); /** * æœåŠ¡æ¯ä¸ªæ–¹æ³•çš„çŠ¶æ€ä¿¡æ¯ * key1: URL * key2: æ–¹æ³•å * value: RpcStatus */ private static final ConcurrentMap&lt;String, ConcurrentMap&lt;String, RpcStatus&gt;&gt; METHOD_STATISTICS = new ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, RpcStatus&gt;&gt;(); private final ConcurrentMap&lt;String, Object&gt; values = new ConcurrentHashMap&lt;String, Object&gt;(); /** * å½“å‰å¹¶å‘åº¦ */ private final AtomicInteger active = new AtomicInteger(); /** * è°ƒç”¨çš„æ€»æ•° */ private final AtomicLong total = new AtomicLong(); /** * å¤±è´¥çš„è°ƒç”¨æ•° */ private final AtomicInteger failed = new AtomicInteger(); /** * æ‰€æœ‰è°ƒç”¨çš„æ€»è€—æ—¶ */ private final AtomicLong totalElapsed = new AtomicLong(); /** * æ‰€æœ‰å¤±è´¥è°ƒç”¨çš„æ€»è€—æ—¶ */ private final AtomicLong failedElapsed = new AtomicLong(); /** * æ‰€æœ‰è°ƒç”¨ä¸­æœ€é•¿çš„è€—æ—¶ */ private final AtomicLong maxElapsed = new AtomicLong(); /** * æ‰€æœ‰å¤±è´¥è°ƒç”¨ä¸­æœ€é•¿çš„è€—æ—¶ */ private final AtomicLong failedMaxElapsed = new AtomicLong(); /** * æ‰€æœ‰æˆåŠŸè°ƒç”¨ä¸­æœ€é•¿çš„è€—æ—¶ */ private final AtomicLong succeededMaxElapsed = new AtomicLong(); private RpcStatus() &#123; &#125; /** * @param url * @return status */ public static RpcStatus getStatus(URL url) &#123; String uri = url.toIdentityString(); return SERVICE_STATISTICS.computeIfAbsent(uri, key -&gt; new RpcStatus()); &#125; /** * @param url */ public static void removeStatus(URL url) &#123; String uri = url.toIdentityString(); SERVICE_STATISTICS.remove(uri); &#125; /** * @param url * @param methodName * @return status */ public static RpcStatus getStatus(URL url, String methodName) &#123; String uri = url.toIdentityString(); ConcurrentMap&lt;String, RpcStatus&gt; map = METHOD_STATISTICS.computeIfAbsent(uri, k -&gt; new ConcurrentHashMap&lt;&gt;()); return map.computeIfAbsent(methodName, k -&gt; new RpcStatus()); &#125; /** * @param url */ public static void removeStatus(URL url, String methodName) &#123; String uri = url.toIdentityString(); ConcurrentMap&lt;String, RpcStatus&gt; map = METHOD_STATISTICS.get(uri); if (map != null) &#123; map.remove(methodName); &#125; &#125; public static void beginCount(URL url, String methodName) &#123; beginCount(url, methodName, Integer.MAX_VALUE); &#125; /** * åœ¨è¿œç¨‹è°ƒç”¨å¼€å§‹ä¹‹å‰æ‰§è¡Œï¼Œå…¶ä¸­ä¼šè·å– æœåŠ¡å’ŒæœåŠ¡æ–¹æ³• å¯¹åº”çš„ RpcStatus å¯¹è±¡ï¼Œç„¶ååˆ†åˆ«å°†å®ƒä»¬çš„ active å­—æ®µ+1 * * @param url * @param methodName * @param max * @return */ public static boolean beginCount(URL url, String methodName, int max) &#123; max = (max &lt;= 0) ? Integer.MAX_VALUE : max; // è·å–æœåŠ¡å¯¹åº”çš„ RpcStatus RpcStatus appStatus = getStatus(url); // è·å–æœåŠ¡æ–¹æ³•å¯¹åº”çš„ RpcStatus RpcStatus methodStatus = getStatus(url, methodName); // æ˜¯å¦éœ€è¦é™æµ if (methodStatus.active.get() == Integer.MAX_VALUE) &#123; return false; &#125; // è‡ªæ—‹ + CAS æ›´æ–°æœåŠ¡æ–¹æ³•çš„å¹¶å‘åº¦ for (int i; ; ) &#123; i = methodStatus.active.get(); // å¹¶å‘åº¦è¶…è¿‡ max ä¸Šé™ï¼Œç›´æ¥è¿”å› false if (i + 1 &gt; max) &#123; return false; &#125; if (methodStatus.active.compareAndSet(i, i + 1)) &#123; break; &#125; &#125; // æœåŠ¡çš„å¹¶å‘åº¦+1 appStatus.active.incrementAndGet(); return true; &#125; /** * ä¼šå¯¹æœåŠ¡å’ŒæœåŠ¡æ–¹æ³•ä¸¤ä¸ªç»´åº¦çš„ RpcStatus ä¸­çš„æ‰€æœ‰å­—æ®µè¿›è¡Œæ›´æ–°ï¼Œå®Œæˆç»Ÿè®¡. * * @param url * @param elapsed * @param succeeded */ public static void endCount(URL url, String methodName, long elapsed, boolean succeeded) &#123; endCount(getStatus(url), elapsed, succeeded); endCount(getStatus(url, methodName), elapsed, succeeded); &#125; private static void endCount(RpcStatus status, long elapsed, boolean succeeded) &#123; // é™ä½å¹¶å‘åº¦ status.active.decrementAndGet(); // è°ƒç”¨æ€»æ¬¡æ•°å¢åŠ  status.total.incrementAndGet(); // è°ƒç”¨æ€»è€—æ—¶å¢åŠ  status.totalElapsed.addAndGet(elapsed); // æ›´æ–°æœ€å¤§è€—æ—¶ if (status.maxElapsed.get() &lt; elapsed) &#123; status.maxElapsed.set(elapsed); &#125; // å¦‚æœæ­¤æ¬¡è°ƒç”¨æˆåŠŸï¼Œåˆ™ä¼šæ›´æ–°æˆåŠŸè°ƒç”¨çš„æœ€å¤§è€—æ—¶ if (succeeded) &#123; if (status.succeededMaxElapsed.get() &lt; elapsed) &#123; status.succeededMaxElapsed.set(elapsed); &#125; // å¦‚æœæ­¤æ¬¡è°ƒç”¨å¤±è´¥ï¼Œåˆ™ä¼šæ›´æ–°å¤±è´¥è°ƒç”¨çš„æœ€å¤§è€—æ—¶ &#125; else &#123; status.failed.incrementAndGet(); status.failedElapsed.addAndGet(elapsed); if (status.failedMaxElapsed.get() &lt; elapsed) &#123; status.failedMaxElapsed.set(elapsed); &#125; &#125; &#125; /** * get active. * * @return active */ public int getActive() &#123; return active.get(); &#125; // çœç•¥å…¶å®ƒä»£ç &#125; å°ç»“ExecuteLimitFilter å’Œ ActiveLimitFilter åˆ†åˆ«ä½œä¸ºæœåŠ¡ç«¯å’Œæ¶ˆè´¹ç«¯çš„é™æµå®ç°ï¼Œä¹‹æ‰€ä»¥å‰è€…æ˜¯é’ˆå¯¹æœåŠ¡ç«¯çš„åè€…æ˜¯é’ˆå¯¹æ¶ˆè´¹ç«¯çš„ï¼Œå› ä¸ºè¿‡æ»¤å™¨è®¾ç½®çš„é’ˆå¯¹çš„å¯¹è±¡ä¸åŒè€Œå·²ã€‚æˆ‘ä»¬å¯ä»¥å‘ç° Dubbo 2.7 ä¸­ä¸¤è€…å®ç°é€»è¾‘å‡ ä¹ä¸€è‡´ï¼ŒDubbo 2.6 ä¸­æœåŠ¡ç«¯çš„é™æµå®ç°å€ŸåŠ©äº†ä¿¡å·é‡ï¼Œæ¶ˆè´¹ç«¯é™æµå®ç°åŒæ ·æ˜¯åŸå­ç±»ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"}]},{"title":"Dubboè¿‡æ»¤å™¨ - AccessLogFilter","slug":"rpc/Dubboè¿‡æ»¤å™¨-AccessLogFilter","date":"2020-07-18T16:00:00.000Z","updated":"2021-02-26T03:40:43.928Z","comments":false,"path":"posts/40c720c7/","link":"","permalink":"https://gentryhuang.com/posts/40c720c7/","excerpt":"","text":"æ¦‚è¿°AccessLogFilter æ˜¯ä¸€ä¸ªæ—¥å¿—è¿‡æ»¤å™¨ï¼Œåœ¨æœåŠ¡æä¾›ç«¯ç”Ÿæ•ˆï¼Œä¸»è¦ç”¨äºè®°å½•æœåŠ¡æ¯ä¸€æ¬¡çš„è¯·æ±‚æ—¥å¿—ã€‚è™½ç„¶ AccessLogFilter é»˜è®¤ä¼šè¢«æ¿€æ´»ï¼Œä½†è¿˜æ˜¯éœ€è¦æ‰‹åŠ¨é…ç½®æ¥å¼€å¯æ—¥å¿—çš„æ‰“å°ã€‚æ³¨æ„ï¼šæ­¤æ—¥å¿—é‡æ¯”è¾ƒå¤§ï¼Œè¯·æ³¨æ„ç£ç›˜å®¹é‡ã€‚ é…ç½® æ ‡ç­¾123&lt;dubbo:protocol accesslog=\"xxx\"&gt;&lt;dubbo:provider accesslog=\"xxx\"&gt;&lt;dubbo:service accesslog=\"xxx\"&gt; é…ç½®æ–¹å¼ accesslog = â€œtrueâ€ æˆ– accesslog=â€defaultâ€ ï¼š å‘æ—¥å¿—ç»„ä»¶ Logger ä¸­è¾“å‡ºè®¿é—®æ—¥å¿—ï¼Œå¦‚logbakï¼Œå°†æ—¥å¿—è¾“å‡ºåˆ°åº”ç”¨æœ¬èº«çš„ log ç›®å½•ä¸‹ã€‚ accesslog = â€œæ–‡ä»¶è·¯å¾„â€ ï¼šç›´æ¥æŠŠè®¿é—®æ—¥å¿—è¾“å‡ºåˆ°æŒ‡å®šæ–‡ä»¶ä¸­ã€‚ æ—¥å¿—æ‰“å°è§„åˆ™ï¼šå¦‚æœé…ç½®çš„æ˜¯å°†æ—¥å¿—è¾“å‡ºåˆ°æ—¥å¿—ç»„ä»¶ï¼Œåˆ™ç«‹å³å†™å…¥ã€‚å¦‚æœé…ç½®çš„æ˜¯å°†æ—¥å¿—è¾“å‡ºåˆ°æ–‡ä»¶ä¸­ï¼Œåˆ™å°†æ—¥å¿—æ”¾å…¥å†…å­˜æ—¥å¿—é›†åˆä¸­ï¼Œå¹¶å¼€å¯å®šæ—¶ä»»åŠ¡è¿›è¡Œæ—¥å¿—æŒä¹…åŒ–ã€‚ ä»£ç å®ç°å±æ€§12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Activate(group = Constants.PROVIDER, value = Constants.ACCESS_LOG_KEY)public class AccessLogFilter implements Filter &#123; private static final Logger logger = LoggerFactory.getLogger(AccessLogFilter.class); //--------------- ä½¿ç”¨æ—¥å¿—ç»„ä»¶è¾“å‡ºç›¸å…³å±æ€§ -------------------------/ /** * æ—¥å¿—åå‰ç¼€ï¼Œç”¨äºè·å–æ—¥å¿—ç»„ä»¶ã€‚ç”¨äº accesslog = trueï¼Œæˆ– accesslog = default çš„æƒ…å†µ */ private static final String ACCESS_LOG_KEY = \"dubbo.accesslog\"; //--------------- é…ç½®è¾“å‡ºåˆ°æŒ‡å®šæ–‡ä»¶çš„ç›¸å…³å±æ€§ ---------------------/ /** * æ—¥å¿—çš„æ–‡ä»¶åç¼€ */ private static final String FILE_DATE_FORMAT = \"yyyyMMdd\"; /** * æ—¶é—´æ ¼å¼åŒ– */ private static final String MESSAGE_DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\"; /** * é˜Ÿåˆ—å¤§å° */ private static final int LOG_MAX_BUFFER = 5000; /** * æ—¥å¿—è¾“å‡ºé¢‘ç‡ï¼Œå•ä½ï¼šæ¯«ç§’ */ private static final long LOG_OUTPUT_INTERVAL = 5000; /** * æ—¥å¿—é˜Ÿåˆ— * key: è‡ªå®šçš„ accesslog çš„å€¼ï¼Œå¦‚ï¼š accesslog=\"accesslog.log\" * value: æ—¥å¿—é›†åˆ */ private final ConcurrentMap&lt;String, Set&lt;String&gt;&gt; logQueue = new ConcurrentHashMap&lt;String, Set&lt;String&gt;&gt;(); /** * å®šæ—¶ä»»åŠ¡çº¿ç¨‹æ±  */ private final ScheduledExecutorService logScheduled = Executors.newScheduledThreadPool(2, new NamedThreadFactory(\"Dubbo-Access-Log\", true)); /** * è®°å½•æ—¥å¿—ä»»åŠ¡ */ private volatile ScheduledFuture&lt;?&gt; logFuture = null; // çœç•¥å…¶å®ƒä»£ç &#125; invoke æ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475+--- AccessLogFilter@Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv) throws RpcException &#123; try &#123; // è®°å½•è®¿é—®æ—¥å¿—çš„æ–‡ä»¶å String accesslog = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY); if (ConfigUtils.isNotEmpty(accesslog)) &#123; // dubbo ä¸Šä¸‹æ–‡ RpcContext context = RpcContext.getContext(); // æœåŠ¡å String serviceName = invoker.getInterface().getName(); // ç‰ˆæœ¬å· String version = invoker.getUrl().getParameter(Constants.VERSION_KEY); // åˆ†ç»„ String group = invoker.getUrl().getParameter(Constants.GROUP_KEY); // æ‹¼æ¥æ—¥å¿—å†…å®¹ StringBuilder sn = new StringBuilder(); sn.append(\"[\") // æ—¶é—´ .append(new SimpleDateFormat(MESSAGE_DATE_FORMAT).format(new Date())) // è°ƒç”¨æ–¹åœ°å€ .append(\"] \").append(context.getRemoteHost()).append(\":\").append(context.getRemotePort()) // æœ¬åœ°åœ°å€ .append(\" -&gt; \").append(context.getLocalHost()).append(\":\").append(context.getLocalPort()) .append(\" - \"); // åˆ†ç»„ if (null != group &amp;&amp; group.length() &gt; 0) &#123; sn.append(group).append(\"/\"); &#125; // æœåŠ¡å sn.append(serviceName); // ç‰ˆæœ¬ if (null != version &amp;&amp; version.length() &gt; 0) &#123; sn.append(\":\").append(version); &#125; sn.append(\" \"); // æ–¹æ³•å sn.append(inv.getMethodName()); sn.append(\"(\"); // å‚æ•°ç±»å‹ Class&lt;?&gt;[] types = inv.getParameterTypes(); if (types != null &amp;&amp; types.length &gt; 0) &#123; boolean first = true; for (Class&lt;?&gt; type : types) &#123; if (first) &#123; first = false; &#125; else &#123; sn.append(\",\"); &#125; sn.append(type.getName()); &#125; &#125; sn.append(\") \"); // å‚æ•°å€¼ Object[] args = inv.getArguments(); if (args != null &amp;&amp; args.length &gt; 0) &#123; sn.append(JSON.toJSONString(args)); &#125; // æ—¥å¿—ä¿¡æ¯å­—ç¬¦ä¸² String msg = sn.toString(); // è®¾ç½® accesslog = true æˆ– accesslog=defaultï¼Œå°†æ—¥å¿—è¾“å‡ºåˆ°æ—¥å¿—ç»„ä»¶Loggerï¼Œå¦‚ logbackä¸­ if (ConfigUtils.isDefault(accesslog)) &#123; // å†™æ—¥å¿— LoggerFactory.getLogger(ACCESS_LOG_KEY + \".\" + invoker.getInterface().getName()).info(msg); &#125; else &#123; // å¼‚æ­¥è¾“å‡ºåˆ°æŒ‡å®šæ–‡ä»¶ log(accesslog, msg); &#125; &#125; &#125; catch (Throwable t) &#123; logger.warn(\"Exception in AcessLogFilter of service(\" + invoker + \" -&gt; \" + inv + \")\", t); &#125; return invoker.invoke(inv); &#125; è¾…åŠ©æ–¹æ³•ä»…ç”¨äºè®¾ç½®æ—¥å¿—å†™å…¥åˆ°æ–‡ä»¶çš„æƒ…å†µä¸‹ã€‚ å†™æ—¥å¿—1234567891011121314151617181920212223+--- AccessLogFilter /** * æ·»åŠ æ—¥å¿—å†…å®¹åˆ°æ—¥å¿—é˜Ÿåˆ— * * @param accesslog æ—¥å¿—è·¯å¾„ * @param logmessage æ—¥å¿—å†…å®¹ */ private void log(String accesslog, String logmessage) &#123; // åˆå§‹åŒ–ä»»åŠ¡ init(); // è·å¾—æ—¥å¿—é˜Ÿåˆ— Set&lt;String&gt; logSet = logQueue.get(accesslog); if (logSet == null) &#123; logQueue.putIfAbsent(accesslog, new ConcurrentHashSet&lt;String&gt;()); logSet = logQueue.get(accesslog); &#125; // è‹¥æœªè¶…è¿‡é˜Ÿåˆ—å¤§å°ï¼Œæ·»åŠ åˆ°é˜Ÿåˆ—ä¸­ if (logSet.size() &lt; LOG_MAX_BUFFER) &#123; logSet.add(logmessage); &#125; &#125; åˆå§‹åŒ–ä»»åŠ¡1234567891011121314+--- AccessLogFilter /** * åˆå§‹åŒ–ä»»åŠ¡ */ private void init() &#123; // åŒé‡æ£€é”æœºåˆ¶ï¼Œé˜²æ­¢é‡å¤åˆå§‹åŒ– if (logFuture == null) &#123; synchronized (logScheduled) &#123; if (logFuture == null) &#123; logFuture = logScheduled.scheduleWithFixedDelay(new LogTask(), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS); &#125; &#125; &#125; &#125; æ—¥å¿—ä»»åŠ¡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162+--- AccessLogFilter /** * æ—¥å¿—ä»»åŠ¡ */ private class LogTask implements Runnable &#123; @Override public void run() &#123; try &#123; if (logQueue != null &amp;&amp; logQueue.size() &gt; 0) &#123; // éå†æ—¥å¿—é˜Ÿåˆ— for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : logQueue.entrySet()) &#123; try &#123; // è·å¾—æ—¥å¿—æ–‡ä»¶è·¯å¾„ String accesslog = entry.getKey(); // è·å¾—æ—¥å¿—é›†åˆ Set&lt;String&gt; logSet = entry.getValue(); // åˆ›å»ºæ—¥å¿—æ–‡ä»¶ File file = new File(accesslog); File dir = file.getParentFile(); if (null != dir &amp;&amp; !dir.exists()) &#123; dir.mkdirs(); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Append log to \" + accesslog); &#125; // å½’æ¡£å†å²æ—¥å¿—æ–‡ä»¶ï¼Œä¾‹å¦‚ï¼š xxx.20191217 if (file.exists()) &#123; String now = new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date()); String last = new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date(file.lastModified())); if (!now.equals(last)) &#123; File archive = new File(file.getAbsolutePath() + \".\" + last); file.renameTo(archive); &#125; &#125; // è¾“å‡ºæ—¥å¿—åˆ°æŒ‡å®šæ–‡ä»¶ FileWriter writer = new FileWriter(file, true); try &#123; for (Iterator&lt;String&gt; iterator = logSet.iterator(); iterator.hasNext(); iterator.remove()) &#123; // å†™å…¥ä¸€è¡Œæ—¥å¿— writer.write(iterator.next()); // æ¢è¡Œ writer.write(\"\\r\\n\"); &#125; // åˆ·ç›˜ writer.flush(); &#125; finally &#123; writer.close(); &#125; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; &#125; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; &#125; å°ç»“ AccessLogFilter ä¸­ä¼šå¼€å¯ä¸€ä¸ªå®šæ—¶çº¿ç¨‹æ± ï¼Œè¯¥çº¿ç¨‹æ± åªæœ‰åœ¨æŒ‡å®šäº†è¾“å‡ºçš„æ–‡ä»¶æ—¶æ‰ä¼šç”¨åˆ°ï¼Œè¯¥å®šæ—¶çº¿ç¨‹æ± ä¼šå®šæ—¶å°†é˜Ÿåˆ—ä¸­çš„æ—¥å¿—å†™å…¥æ–‡ä»¶ä¸­ã€‚ å¦‚æœç”¨æˆ·é…ç½®äº†ä½¿ç”¨åº”ç”¨æœ¬èº«çš„æ—¥å¿—ç»„ä»¶ï¼Œåˆ™ç›´æ¥é€šè¿‡å°è£…çš„ LoggerFactory æ‰“å°æ—¥å¿—ã€‚å¦‚æœç”¨æˆ·é…ç½®äº†æ—¥å¿—è¦è¾“å‡ºåˆ°è‡ªå®šä¹‰çš„æ–‡ä»¶ä¸­ï¼Œåˆ™ä¼šæŠŠæ—¥å¿—åŠ å…¥åˆ°Mapç¼“å­˜ä¸­ï¼Œkey æ˜¯å®šä¹‰çš„ accesslog çš„å€¼ï¼Œvalue æ˜¯å¯¹åº”çš„æ—¥å¿—é›†åˆã€‚åç»­ç­‰å¾…å®šæ—¶çº¿ç¨‹ä¸æ–­éå†Mapç¼“å­˜ï¼ŒæŠŠæ—¥å¿—å†™å…¥åˆ°å¯¹åº”çš„æ–‡ä»¶ä¸­ã€‚ å¦‚æœæ˜¯æ—¥å¿—è¾“å…¥åˆ°æ–‡ä»¶çš„æƒ…å†µï¼Œä¼šæœ‰ä¸¤ä¸ªé—®é¢˜ï¼š ç”±äºSeté›†åˆæ˜¯æ— åºçš„ï¼Œå› æ­¤æ—¥å¿—è¾“å‡ºåˆ°æ–‡ä»¶ä¹Ÿæ˜¯æ— åºçš„ ç”±äºæ˜¯å¼‚æ­¥åˆ·ç›˜ï¼Œå¦‚æœæœåŠ¡çªç„¶å®•æœºä¼šå¯¼è‡´ä¸€éƒ¨åˆ†æ—¥å¿—ä¸¢å¤±","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"}]},{"title":"Dubboæºç åˆ†æ - Dubboè¿‡æ»¤å™¨","slug":"rpc/Dubboè¿‡æ»¤å™¨","date":"2020-07-17T16:00:00.000Z","updated":"2021-02-18T09:02:47.576Z","comments":false,"path":"posts/96cae18/","link":"","permalink":"https://gentryhuang.com/posts/96cae18/","excerpt":"","text":"æ¦‚è¿°Dubbo ä¸­çš„è¿‡æ»¤å™¨å’Œ Web åº”ç”¨ä¸­çš„è¿‡æ»¤å™¨çš„æ¦‚å¿µæ˜¯ä¸€æ ·çš„ï¼Œæä¾›äº†åœ¨æœåŠ¡è°ƒç”¨å‰åæ’å…¥è‡ªå®šä¹‰é€»è¾‘çš„é€”å¾„ã€‚è¿‡æ»¤å™¨æ˜¯æ•´ä¸ª Dubbo æ¡†æ¶ä¸­éå¸¸é‡è¦çš„ç»„æˆéƒ¨åˆ†ï¼ŒDubbo ä¸­å¾ˆå¤šåŠŸèƒ½éƒ½æ˜¯åŸºäºè¿‡æ»¤å™¨æ‰©å±•è€Œæ¥çš„ã€‚è¿‡æ»¤å™¨æä¾›äº†æœåŠ¡æä¾›æ–¹å’Œæ¶ˆè´¹æ–¹è°ƒç”¨è¿‡ç¨‹çš„æ‹¦æˆªï¼Œè™½ç„¶æ‹¦æˆªå™¨åŠŸèƒ½å¼ºå¤§ï¼Œä½†ç”±äºæ¯æ¬¡è°ƒç”¨æ—¶éƒ½ä¼šæ‰§è¡Œï¼Œå› æ­¤åœ¨ä½¿ç”¨çš„æ—¶å€™éœ€è¦è€ƒè™‘å®ƒå¯¹æ€§èƒ½çš„å½±å“ã€‚ Dubbo Filter åœ¨ Dubbo æ¶æ„ä¸­çš„ä½ç½®å¦‚ä¸‹ï¼š ä½¿ç”¨è§„åˆ™Dubbo ä¸­å†…ç½®äº†å¾ˆå¤šè¿‡æ»¤å™¨ï¼Œå¤§å¤šæ•°é»˜è®¤æ˜¯å¯ç”¨çš„ã€‚ä½¿ç”¨æ–¹è‡ªå®šä¹‰çš„è¿‡æ»¤å™¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä¸¤ç§æ–¹å¼å¯ç”¨ï¼š ä½¿ç”¨ @Activate æ³¨è§£é»˜è®¤å¯ç”¨1234567@Activate(group = &#123;CommonConstants.PROVIDER&#125;, order = 999999)public class ProviderExceptionFilter implements Filter &#123; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; //... &#125;&#125; 12# é…ç½®æ‰©å±•ä¿¡æ¯providerExceptionFilter&#x3D;com.yunhu.order.system.filter.ProviderExceptionFilter é€šè¿‡åœ¨XMLé…ç½®æ–‡ä»¶ä¸­é…ç½®12345678&lt;!-- æ¶ˆè´¹æ–¹è°ƒç”¨è¿‡ç¨‹æ‹¦æˆª --&gt;&lt;dubbo:reference filter=\"xxx,yyy\"/&gt;&lt;!-- æ¶ˆè´¹æ–¹è°ƒç”¨è¿‡ç¨‹é»˜è®¤æ‹¦æˆªå™¨ï¼Œå°†æ‹¦æˆªæ‰€æœ‰ reference --&gt;&lt;dubbo:reference filter=\"xxx,yyy\"/&gt;&lt;!-- æœåŠ¡æä¾›æ–¹è°ƒç”¨è¿‡ç¨‹æ‹¦æˆªå™¨ --&gt;&lt;dubbo:service filter=\"xxx,yyy\"/&gt;&lt;!-- æœåŠ¡ä¾›æ–¹è°ƒç”¨è¿‡ç¨‹é»˜è®¤æ‹¦æˆªå™¨ --&gt;&lt;dubbo:provider filter=\"xxx,yyy\"/&gt; ç‰¹åˆ«è¯´æ˜ è¿‡æ»¤å™¨é¡ºåº è‡ªå®šä¹‰çš„è¿‡æ»¤å™¨çš„é¡ºåºé»˜è®¤ä¼šåœ¨ Dubbo å†…ç½®è¿‡æ»¤å™¨ä¹‹åï¼Œä½¿ç”¨æ–¹å¯ä»¥ä½¿ç”¨ filter=â€xxx,defaultâ€ é…ç½®æ–¹å¼æŒ‡å®šè¿‡æ»¤å™¨æ‰§è¡Œé¡ºåºï¼Œå‰é¢çš„è¿‡æ»¤å™¨ä¼šæ¯”åé¢çš„è¿‡æ»¤è¦é å‰ã€‚ å‰”é™¤è¿‡æ»¤å™¨ ä½¿ç”¨æ–¹å¯ä»¥ä½¿ç”¨ â€œ-â€œ åŠ è¿‡æ»¤å™¨åç§°æ¥å‰”é™¤å¯¹åº”çš„è¿‡æ»¤å™¨ï¼Œå¦‚ filter=â€-xxFilterâ€ ä¼šä½¿ xxFilter ä¸ç”Ÿæ•ˆã€‚å¦‚æœä¸æƒ³ä½¿ç”¨Dubboå†…ç½®çš„è¿‡æ»¤å™¨ï¼Œå¯ä»¥é…ç½® filter=â€-defaultâ€ æ¥å‰”é™¤ï¼Œä½†æ˜¯ä¸€èˆ¬ä¸è¿™æ ·åšï¼Œå› ä¸ºå†…ç½®è¿‡æ»¤å™¨ä¼šå®Œæˆç‰¹å®šçš„åŠŸèƒ½ã€‚ è¿‡æ»¤å™¨å åŠ  å¦‚æœæœåŠ¡æä¾›æ–¹å’Œæ¶ˆè´¹æ–¹éƒ½é…ç½®äº†è¿‡æ»¤å™¨ï¼Œåˆ™ä¸¤è¾¹çš„è¿‡æ»¤å™¨ä¸ä¼šç›¸äº’è¦†ç›–ï¼Œè€Œæ˜¯ç›¸äº’å åŠ ï¼Œéƒ½ä¼šç”Ÿæ•ˆã€‚ è¿‡æ»¤å™¨é“¾è¿‡æ»¤å™¨å®ç°ç±»ä¼šåœ¨æ‰©å±•ç‚¹åˆå§‹åŒ–æ—¶è¿›è¡ŒåŠ è½½ã€æ’åºç­‰ï¼Œæ‰€æœ‰çš„ Filter ä¼šè¿æ¥æˆä¸€ä¸ªè¿‡æ»¤å™¨é“¾ï¼Œæ¯ä¸ªè¯·æ±‚éƒ½ä¼šç»è¿‡æ•´ä¸ªé“¾è·¯ä¸­çš„æ¯ä¸€ä¸ª Filterã€‚è¿‡æ»¤å™¨é“¾çš„ç»„è£…å‘ç”Ÿåœ¨æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨çš„è¿‡ç¨‹ï¼Œä¹Ÿå°±æ˜¯åœ¨æœåŠ¡çš„æš´éœ²å’Œå¼•ç”¨è¿‡ç¨‹ä¸­ï¼Œä¼šä½¿ç”¨ ProtocolFilterWrapper#buildInvokerChain æ–¹æ³•ç»„è£…æ•´ä¸ªè¿‡æ»¤å™¨é“¾ã€‚ æœåŠ¡æš´éœ²å’Œå¼•ç”¨è¿‡ç¨‹12345678910111213141516171819202122232425+--- ProtocolFilterWrapper @Override public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; // å¦‚æœ Invokerçš„URLä¸­ protocol=registry,è¯´æ˜ä¸æ˜¯æœ¬åœ°æš´éœ²ï¼Œinvoker.urlæ˜¯æ³¨å†Œä¸­å¿ƒçš„ã€‚æ— éœ€åˆ›å»ºFilterè¿‡æ»¤å™¨ã€‚ if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123; return protocol.export(invoker); &#125; // å»ºç«‹å¸¦æœ‰Filter è¿‡æ»¤é“¾çš„ Invokerï¼Œå†æš´éœ²æœåŠ¡ã€‚ // Constants.PROVIDER æ ‡è¯†è‡ªå·±æ˜¯æœåŠ¡æä¾›è€…ç±»å‹çš„è°ƒç”¨é“¾ return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER)); &#125; @Override public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123; // å½“invoker.url.protocol=registryå°±ç›´æ¥æ‰§è¡ŒRegistryProtocolçš„referæ–¹æ³•ã€‚æœ¬åœ°å¼•ç”¨æœåŠ¡ä¸ç¬¦åˆè¿™ä¸ªåˆ¤æ–­ï¼Œè¿œç¨‹å¼•ç”¨æœåŠ¡ç¬¦åˆåˆ¤æ–­ if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123; return protocol.refer(type, url); &#125; /** * 1 å¼•ç”¨æœåŠ¡ï¼Œè¿”å› Invoker å¯¹è±¡ * 2 å¼•ç”¨æœåŠ¡å®Œæˆåï¼Œè°ƒç”¨ buildInvokerChain(invoker,key,group)æ–¹æ³•ï¼Œåˆ›å»ºå¸¦æœ‰Filterè¿‡æ»¤å™¨çš„Invokerå¯¹è±¡ã€‚å’ŒæœåŠ¡æš´éœ²åŒºåˆ«åœ¨groupçš„å€¼ä¸Šï¼Œ * Constants.CONSUMER æ ‡è¯†è‡ªå·±æ˜¯æ¶ˆè´¹ç±»å‹çš„è°ƒç”¨é“¾ */ return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER); &#125; æ„é€ è¿‡æ»¤å™¨é“¾1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465+--- ProtocolFilterWrapper /** * åˆ›å»ºå¸¦Filteré“¾çš„Invoker å¯¹è±¡ * * @param invoker Invokerå¯¹è±¡ * @param key URLä¸­å‚æ•°å ã€å¦‚ï¼šç”¨äºè·å¾—ServiceConfigæˆ–ReferenceConfigé…ç½®çš„è‡ªå®šä¹‰è¿‡æ»¤å™¨ã€‘ * @param group åˆ†ç»„ ã€æš´éœ²æœåŠ¡æ—¶ï¼šgroup=provider; å¼•ç”¨æœåŠ¡æ—¶ï¼šgroup=consumerã€‘ * @param &lt;T&gt; * @return åœ¨æ‰§è¡Œçš„æ—¶å€™æ‰§è¡ŒFilter */ private static &lt;T&gt; Invoker&lt;T&gt; buildInvokerChain(final Invoker&lt;T&gt; invoker, String key, String group) &#123; // ä¿å­˜å¼•ç”¨ï¼Œåç»­ç”¨äºå°†çœŸæ­£çš„Invoker æŒ‚åˆ°è¿‡æ»¤å™¨é“¾çš„æœ€å Invoker&lt;T&gt; last = invoker; // è·å–æ‰€æœ‰çš„è¿‡æ»¤å™¨ï¼ŒåŒ…æ‹¬ç±»ä¸Šå¸¦æœ‰@Activeæ³¨è§£çš„å’Œåœ¨XMLä¸­é…ç½®çš„ List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group); // å€’åºå¾ªç¯ Filterï¼Œé€’å½’åŒ…è£…Invokerï¼Œå°±æ˜¯ä¸€ä¸ªé“¾è¡¨ç»“æ„ï¼š Xx1Filter-&gt;Xx2Filter-&gt;Xx3Filter-&gt;...-&gt;Invoker if (!filters.isEmpty()) &#123; for (int i = filters.size() - 1; i &gt;= 0; i--) &#123; final Filter filter = filters.get(i); final Invoker&lt;T&gt; next = last; //åŒ¿å Invoker å¯¹è±¡ last = new Invoker&lt;T&gt;() &#123; @Override public Class&lt;T&gt; getInterface() &#123; return invoker.getInterface(); &#125; @Override public URL getUrl() &#123; return invoker.getUrl(); &#125; @Override public boolean isAvailable() &#123; return invoker.isAvailable(); &#125; /** * è°ƒç”¨Invokerçš„invokeæ–¹æ³•çš„æ—¶å€™ä¼šæ‰§è¡Œ * 1 è°ƒç”¨Filter#invoke(invoker,invocation)æ–¹æ³•ï¼Œä¸æ–­æ‰§è¡Œè¿‡æ»¤å™¨é€»è¾‘ * 2 åœ¨Filterä¸­ä¼šè°ƒç”¨Invoker#invoker(invocation)æ–¹æ³•ï¼Œæœ€åä¼šæ‰§è¡Œåˆ°Invokerã€å¦‚ï¼šInjvmInvoker,DubboInvokerç­‰ã€‘çš„invokeæ–¹æ³• * * @param invocation * @return * @throws RpcException */ @Override public Result invoke(Invocation invocation) throws RpcException &#123; return filter.invoke(next, invocation); &#125; @Override public void destroy() &#123; invoker.destroy(); &#125; @Override public String toString() &#123; return invoker.toString(); &#125; &#125;; &#125; &#125; return last; &#125; æ„å»º Invoker çš„è¿‡å™¨æ»¤é“¾è¿‡ç¨‹å¦‚ä¸‹ï¼š ä½¿ç”¨è£…é¥°è€…æ¨¡å¼ï¼Œå¢å¼ºåŸæœ‰çš„ Invoker ï¼Œå°†è¿‡æ»¤å™¨ä¸€ä¸ªåˆä¸€ä¸ªåœ°å¥—åˆ° Invoker ä¸Šã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿”å›çš„ Invoker æ˜¯ä¸€ä¸ªåŒ¿åå†…éƒ¨ç±»å¯¹è±¡ï¼Œè¯¥å¯¹è±¡çš„ invoke æ–¹æ³•æ²¡æœ‰å…¶å®ƒé€»è¾‘ï¼Œä»…ç”¨æ¥æ‰§è¡Œ Filter.invoke æ–¹æ³•ã€‚å½“å‘è¯¥ Invoker å‘èµ·è°ƒç”¨æ—¶ï¼Œä¼šå…ˆæ‰§è¡Œè¿‡æ»¤å™¨é“¾ï¼Œåªæœ‰å½“è¿‡æ»¤å™¨é“¾æ‰§è¡Œå®Œæ¯•åï¼Œæ‰ä¼šæ‰§è¡ŒçœŸæ­£çš„ Invoker çš„é€»è¾‘ã€‚ QAQ: è¿‡æ»¤å™¨ä¸ºä»€ä¹ˆè¦å€’æ’ï¼ŸA: å› ä¸ºè¿‡æ»¤å™¨é“¾æ˜¯ä»é‡Œåˆ°å¤–æ„é€ åŒ¿åInvokeå¯¹è±¡çš„æ–¹å¼æ„å»ºçš„ï¼Œæ‰€ä»¥åªæœ‰å€’æ’ï¼Œæœ€å¤–å±‚çš„ Invoker æ‰èƒ½æ˜¯ç¬¬ä¸€ä¸ªè¿‡æ»¤å™¨ã€‚è¯´æ˜å‡è®¾æœ‰è¿‡æ»¤å™¨ Aã€Bã€C å’Œ Invokerï¼Œä¼šæŒ‰ç…§ Cã€Bã€A å€’åºéå†ï¼Œè¿‡æ»¤å™¨é“¾çš„æ„å»ºé¡ºåºä¸ºï¼š C-&gt;Invoker ï¼ˆåŒ¿åInvokerå¯¹è±¡ï¼‰B-&gt;C-&gt;Invoker ï¼ˆåŒ¿åInvokerå¯¹è±¡ï¼‰A-&gt;B-&gt;C-&gt;Invoker ï¼ˆåŒ¿åInvokerå¯¹è±¡ï¼‰ æœ€ç»ˆè°ƒç”¨æ—¶çš„é¡ºåºå°±ä¼šå˜æˆ A æ˜¯ç¬¬ä¸€ä¸ªè¿‡æ»¤å™¨ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« å¯¹è¿‡æ»¤æ€»ä½“è¿›è¡Œäº†ç®€å•è¯´æ˜ï¼Œæ¥ä¸‹æ¥çš„å‡ ç¯‡æ–‡ç« å°†å¯¹ä¸åŒçš„è¿‡æ»¤è¿›è¡Œåˆ†æã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - åè®®å±‚æ€»è§ˆ","slug":"rpc/åè®®å±‚æ€»è§ˆ","date":"2020-07-09T16:00:00.000Z","updated":"2021-03-09T06:52:52.758Z","comments":false,"path":"posts/3131d6ea/","link":"","permalink":"https://gentryhuang.com/posts/3131d6ea/","excerpt":"","text":"å‰è¨€åœ¨å‰é¢çš„æ–‡ç« ä¸­å¯¹ Dubbo æ¶æ„ä¸­çš„ Dubbo Remoting å±‚ è¿›è¡Œäº†è¯¦ç»†è¯´æ˜ï¼Œæœ¬ç¯‡æ–‡ç« å°†ä»‹ç» Dubbo Remoting å±‚ çš„ä½¿ç”¨è€… Protocol å±‚ã€‚Protocol å±‚ä¼šé€šè¿‡ Exchangers é—¨é¢ç±»åˆ›å»ºå®¢æˆ·ç«¯ ExchangeClient å’ŒæœåŠ¡ç«¯ ExchangeServerï¼Œæ­¤å¤–è¿˜ä¼šåˆ›å»ºé€šé“å¤„ç†å™¨ ChannelHandler ä»¥åŠç¼–è§£ç å™¨ Codec2ï¼Œæœ€åå°†å®ƒä»¬äº¤ç»™ Exchange å±‚è¿›è¡Œè£…é¥°ã€‚ æ¦‚è¿°å‰é¢å·²ç»ä»‹ç»è¿‡äº†åºåˆ—åŒ–å±‚ã€ä¼ è¾“å±‚ã€ä¿¡æ¯äº¤æ¢å±‚ä»¥åŠä»£ç†å±‚ï¼Œå®ƒä»¬å„è‡ªè´Ÿè´£ RPC ç”Ÿå‘½å‘¨æœŸä¸­çš„ä¸€ç¯ï¼Œè€Œåè®®å±‚åˆ™æ˜¯ä½äºå®ƒä»¬ä¹‹ä¸Šçš„ä¸€å±‚ã€‚Protocol å±‚åœ¨ Dubbo æ¶æ„ä¸­çš„ä½ç½®å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š Protocol å±‚åœ¨ Dubbo æºç ä¸­å¯¹åº”çš„æ˜¯ dubbo-rpc æ¨¡å—ï¼Œè¯¥æ¨¡å—çš„ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä»ä¸Šå›¾ä¸éš¾çœ‹å‡ºï¼Œdubbo-rpc å’Œå‰é¢ä»‹ç»è¿‡çš„æ¨¡å—ç±»ä¼¼ï¼Œä¸€ä¸ªæŠ½è±¡æ¨¡å—å’Œå¤šä¸ªå…·ä½“å®ç°æ¨¡å—ã€‚dubbo-rpc-api æ˜¯å¯¹å…·ä½“åè®®ã€æœåŠ¡æš´éœ²ã€æœåŠ¡å¼•ç”¨ä»¥åŠä»£ç†ç­‰çš„æŠ½è±¡ï¼Œæ˜¯æ•´ä¸ª Protocol å±‚çš„æ ¸å¿ƒã€‚å…¶å®ƒæ¨¡å—éƒ½æ˜¯å¯¹ dubbo-rpc-api æ¨¡å—çš„å…·ä½“å®ç°ï¼Œéƒ½æ˜¯ Dubbo æ”¯æŒçš„å…·ä½“åè®®ï¼Œåœ¨åé¢çš„æ–‡ç« ä¸­ä¼šæŒ‘é€‰å‡ ä¸ªå…·æœ‰ä»£è¡¨æ€§çš„å…·ä½“åè®®å®ç°è¿›è¡Œè¯¦ç»†åˆ†æã€‚ä¸‹é¢æˆ‘ä»¬å¯¹ dubbo-rpc-api æ¨¡å—è¿›è¡Œæ•´ä½“è¯´æ˜ã€‚ æŠ½è±¡æ¨¡å— ä¸Šå›¾å±•ç¤ºäº† dubbo-rpc-api æ¨¡å—çš„ç»“æ„ï¼Œä¸‹é¢æˆ‘ä»¬å¯¹å…¶æ ¸å¿ƒåŒ…å’Œç±»è¿›è¡Œç®€å•ä»‹ç»ã€‚ æ ¸å¿ƒåŒ… filter åŒ…ï¼š åœ¨è¿›è¡ŒæœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨æ—¶ï¼ŒåŸºäº Dubbo SPI Active æœºåˆ¶åŠ è½½åŒ¹é…å¯¹åº”çš„è¿‡æ»¤å™¨é›†åˆï¼Œç”¨äºåˆ›å»ºå¸¦æœ‰è¿‡æ»¤å™¨é“¾çš„ Invoker å¯¹è±¡ã€‚ listener åŒ…ï¼š åœ¨æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨æ—¶ï¼Œå¯ä»¥é€šè¿‡æ·»åŠ  Listener æ¥ç›‘å¬ç›¸åº”çš„äº‹ä»¶ï¼Œä¸ Listener ç›¸å…³çš„æ¥å£çš„ XxxAdapterã€XxxWrapper å®ç°å°±åœ¨è¿™ä¸ªåŒ…ä¸­ã€‚ protocol åŒ…ï¼š ä¸€äº›å®ç°äº† Protocol æ¥å£ã€Invoker æ¥å£ä»¥åŠ Exporter æ¥å£çš„æŠ½è±¡ç±»ä½äºè¯¥åŒ…ä¸­ï¼Œå®ƒä»¬ä¸»è¦ä¸ºå…·ä½“å®ç°æä¾›ä¸€äº›å…¬å…±çš„é€»è¾‘ã€‚ proxy åŒ…ï¼š æä¾›åˆ›å»ºä»£ç†çš„èƒ½åŠ›ï¼Œè¯¥åŒ…ä¸­æ”¯æŒ JDK åŠ¨æ€ä»£ç†ä»¥åŠJavassist å­—èŠ‚ç ä¸¤ç§æ–¹å¼ç”Ÿæˆä»£ç†ç±»ã€‚ service åŒ…ï¼š æä¾›äº†å›å£°æ£€æµ‹æ¥å£ EchoServe å’Œæ³›åŒ–è°ƒç”¨æ¥å£ GenericService ï¼Œåœ¨ Dubbo 2.7ä¸­å·²ç»å°†æ­¤åŒ…ç§»é™¤ã€‚ support åŒ…ï¼š æä¾›äº† RpcUtils å·¥å…·ç±»ã€Mock ç›¸å…³çš„ Protocol å®ç°ä»¥åŠ Invoker å®ç°ã€‚ æ ¸å¿ƒç±»åœ¨ Dubbo Protocol å±‚ä¸­æ¶‰åŠçš„æ ¸å¿ƒæ¥å£æœ‰ Exporterã€Invokerã€Invocationã€Resultã€Protocolã€Filter ã€ProxyFactory ç­‰ï¼Œè¿™äº›æ¥å£åˆ†åˆ«æŠ½è±¡äº† Dubbo RPC å±‚çš„ä¸åŒæ¦‚å¿µï¼Œå®ƒä»¬ç›¸äº’ååŒï¼Œæ„å»ºäº† Dubbo Protocol å±‚çš„éª¨æ¶ã€‚ä¸‹é¢æˆ‘ä»¬å°†é€ä¸€ä»‹ç»è¿™äº›æ ¸å¿ƒæ¥å£çš„å«ä¹‰ã€‚ Invoker æ¥å£Invoker æ˜¯å®ä½“åŸŸï¼Œå®ƒæ˜¯ Dubbo çš„æ ¸å¿ƒæ¨¡å‹ï¼Œå…¶å®ƒæ¨¡å‹éƒ½å‘å®ƒé æ‰°ï¼Œæˆ–è½¬æ¢æˆå®ƒï¼Œå®ƒä»£è¡¨ä¸€ä¸ªå¯æ‰§è¡Œä½“ï¼Œå¯å‘å®ƒå‘èµ· invoke è°ƒç”¨ï¼Œå®ƒæœ‰å¯èƒ½æ˜¯ä¸€ä¸ªæœ¬åœ°çš„å®ç°ï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ªè¿œç¨‹çš„å®ç°ï¼Œä¹Ÿå¯èƒ½ä¸€ä¸ªé›†ç¾¤å®ç°ã€‚å…·ä½“å®šä¹‰å¦‚ä¸‹ï¼š 12345678910111213141516171819public interface Invoker&lt;T&gt; extends Node &#123; /** * æœåŠ¡æ¥å£ * * @return service interface. */ Class&lt;T&gt; getInterface(); /** * ä¸€æ¬¡è°ƒç”¨ * * @param invocation * @return result * @throws RpcException */ Result invoke(Invocation invocation) throws RpcException;&#125; Consumer ç«¯åœ¨è°ƒç”¨ Providerç«¯æ—¶ï¼Œä¼šé¦–å…ˆè°ƒç”¨æœ¬åœ°çš„ Proxy ä»£ç†å¯¹è±¡ï¼Œä»£ç†å¯¹è±¡ä¼šå°†è¯·æ±‚äº¤ç»™æœ¬åœ°çš„ Invoker ï¼Œç”± Invoker å‘èµ·è¿œç¨‹è°ƒç”¨ï¼Œç„¶åè¯·æ±‚åˆ°è¾¾ Provider ç«¯çš„ Invoker ï¼Œç„¶åä¼ é€’ç»™ä¸Šå±‚çš„å…·ä½“çš„æœåŠ¡å®ç°ã€‚ç®€å•ç¤ºæ„å›¾å¦‚ä¸‹ï¼š åœ¨ Consumer ç«¯ä¼šæŒæœ‰æ¥å£çš„ä»£ç†å¯¹è±¡ï¼Œè¯¥ä»£ç†å¯¹è±¡ä¼šå°è£…ä¸€ä¸ªå…·æœ‰è¿œç¨‹é€šä¿¡åŠŸèƒ½çš„ *Invoker å¯¹è±¡ï¼Œä»£ç†å¯¹è±¡å‘èµ·è°ƒç”¨åº•å±‚æ˜¯é€šè¿‡ Invoker å®Œæˆç½‘ç»œè°ƒç”¨ã€‚Provider ç«¯çš„æ¥å£å®ç°ä¼šè¢«å°è£…æˆä¸€ä¸ª AbstractProxyInvoker å®ä¾‹ï¼Œè¿›ä¸€æ­¥åŒ…è£…æˆå¯¹åº”çš„ Exporter å®ä¾‹ï¼Œå½“ Provider ç«¯æ¥æ”¶åˆ°ä¸€ä¸ªè¯·æ±‚ä¹‹åä¼šå…ˆæ‰¾åˆ°å¯¹åº”çš„ Exporter å®ä¾‹ï¼Œç„¶åè°ƒç”¨å…¶å¯¹åº”çš„ AbstractProxyInvoker å®ä¾‹ï¼Œä»è€Œå®Œæˆ Provider é€»è¾‘çš„è°ƒç”¨ã€‚ Invocation æ¥å£Invocation æ¥å£ä½œä¸ºä¸€æ¬¡è°ƒç”¨çš„æ–¹æ³•å‚æ•°ï¼Œæ˜¯å¯¹ä¸€æ¬¡ RPC è°ƒç”¨çš„ç›®æ ‡æœåŠ¡ã€æ–¹æ³•ä¿¡æ¯ã€å‚æ•°ä¿¡æ¯ã€å…·ä½“å‚æ•°å€¼ä»¥åŠä¸€äº›é™„åŠ ä¿¡æ¯çš„æŠ½è±¡ã€‚å…·ä½“å®šä¹‰å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public interface Invocation &#123; /** * è°ƒç”¨çš„æ–¹æ³•åç§° * * @return method name. * @serial */ String getMethodName(); /** * å‚æ•°ç±»å‹é›†åˆ * * @return parameter types. * @serial */ Class&lt;?&gt;[] getParameterTypes(); /** * æ­¤æ¬¡è°ƒç”¨å…·ä½“çš„å‚æ•°å€¼ * * @return arguments. * @serial */ Object[] getArguments(); /** * Invocationå¯ä»¥æºå¸¦KVä¿¡æ¯ä½œä¸ºé™„åŠ ä¿¡æ¯ï¼Œä¸€å¹¶ä¼ é€’ç»™Providerã€‚ * æ³¨æ„ï¼šattachment å’Œ attribute çš„åŒºåˆ« * * @return attachments. * @serial */ Map&lt;String, String&gt; getAttachments(); /** * get attachment by key. * * @return attachment value. * @serial */ String getAttachment(String key); /** * get attachment by key with default value. * * @return attachment value. * @serial */ String getAttachment(String key, String defaultValue); /** * æ­¤æ¬¡è°ƒç”¨å…³è”çš„Invoker å¯¹è±¡ * * @return invoker. * @transient */ Invoker&lt;?&gt; getInvoker();&#125; Result æ¥å£Result æ¥å£æ˜¯ä¸€æ¬¡è°ƒç”¨çš„è¿”å›å€¼ï¼ŒæŠ½è±¡äº†ä¸€æ¬¡è°ƒç”¨çš„è¿”å›ç»“æœï¼Œå…¶ä¸­åŒ…å«äº†è¢«è°ƒç”¨æ–¹è¿”å›å€¼ï¼ˆæˆ–å¼‚å¸¸ï¼‰ä»¥åŠé™„åŠ ä¿¡æ¯ã€‚Result æ¥å£å®šäºå¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public interface Result &#123; /** * è·å–è°ƒç”¨çš„è¿”å›å€¼ * * @return result. if no result return null. */ Object getValue(); /** * å¦‚æœæ­¤æ¬¡è°ƒç”¨å‘ç”Ÿå¼‚å¸¸ï¼Œç”¨äºè·å–å¼‚å¸¸ä¿¡æ¯ * * @return exception. if no exception return null. */ Throwable getException(); /** * Has exception. * * @return has exception. */ boolean hasException(); /** * recreate()æ–¹æ³•æ˜¯ä¸€ä¸ªå¤åˆæ“ä½œï¼Œå¦‚æœæ­¤æ¬¡è°ƒç”¨å‘ç”Ÿå¼‚å¸¸ï¼Œåˆ™ç›´æ¥æŠ›å‡ºå¼‚å¸¸ã€‚å¦‚æœæ²¡æœ‰å¼‚å¸¸ï¼Œåˆ™è¿”å›ç»“æœ * &lt;p&gt; * &lt;code&gt; * if (hasException()) &#123; * throw getException(); * &#125; else &#123; * return getValue(); * &#125; * &lt;/code&gt; * * @return result. * @throws if has exception throw it. */ Object recreate() throws Throwable; /** * @see com.alibaba.dubbo.rpc.Result#getValue() * @deprecated Replace to getValue() */ @Deprecated Object getResult(); /** * Resultä¸­åŒæ ·å¯ä»¥æºå¸¦é™„åŠ ä¿¡æ¯ * * @return attachments. */ Map&lt;String, String&gt; getAttachments(); /** * get attachment by key. * * @return attachment value. */ String getAttachment(String key); /** * get attachment by key with default value. * * @return attachment value. */ String getAttachment(String key, String defaultValue);&#125; Dubbo 2.7 æ”¯æŒæ·»åŠ å›è°ƒæ–¹æ³•ï¼Œåœ¨ RPC è°ƒç”¨æ–¹æ³•ç»“æŸæ—¶ä¼šè§¦å‘è¿™äº›å›è°ƒï¼Œå®šä¹‰å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public interface Result extends Serializable &#123; // è·å–/è®¾ç½®æ­¤æ¬¡è°ƒç”¨çš„è¿”å›å€¼ Object getValue(); void setValue(Object value); // å¦‚æœæ­¤æ¬¡è°ƒç”¨å‘ç”Ÿå¼‚å¸¸ï¼Œåˆ™å¯ä»¥é€šè¿‡ä¸‹é¢ä¸‰ä¸ªæ–¹æ³•è·å– Throwable getException(); void setException(Throwable t); boolean hasException(); // recreate()æ–¹æ³•æ˜¯ä¸€ä¸ªå¤åˆæ“ä½œï¼Œå¦‚æœæ­¤æ¬¡è°ƒç”¨å‘ç”Ÿå¼‚å¸¸ï¼Œåˆ™ç›´æ¥æŠ›å‡ºå¼‚å¸¸ï¼Œ // å¦‚æœæ²¡æœ‰å¼‚å¸¸ï¼Œåˆ™è¿”å›ç»“æœ Object recreate() throws Throwable; // æ·»åŠ ä¸€ä¸ªå›è°ƒï¼Œå½“RPCè°ƒç”¨å®Œæˆæ—¶ï¼Œä¼šè§¦å‘è¿™é‡Œæ·»åŠ çš„å›è°ƒ Result whenCompleteWithContext(BiConsumer&lt;Result, Throwable&gt; fn); &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;Result, ? extends U&gt; fn); // é˜»å¡çº¿ç¨‹ï¼Œç­‰å¾…æ­¤æ¬¡RPCè°ƒç”¨å®Œæˆ(æˆ–æ˜¯è¶…æ—¶) Result get() throws InterruptedException, ExecutionException; Result get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; // Resultä¸­åŒæ ·å¯ä»¥æºå¸¦é™„åŠ ä¿¡æ¯ Map&lt;String, String&gt; getAttachments(); Map&lt;String, Object&gt; getObjectAttachments(); void addAttachments(Map&lt;String, String&gt; map); void addObjectAttachments(Map&lt;String, Object&gt; map); void setAttachments(Map&lt;String, String&gt; map); void setObjectAttachments(Map&lt;String, Object&gt; map); String getAttachment(String key); Object getObjectAttachment(String key); String getAttachment(String key, String defaultValue); Object getObjectAttachment(String key, Object defaultValue); void setAttachment(String key, String value); void setAttachment(String key, Object value); void setObjectAttachment(String key, Object valu&#125; Exporter æ¥å£é€šè¿‡å‰æ–‡çš„ä»‹ç»ï¼Œæˆ‘ä»¬çŸ¥é“ä¸šåŠ¡æ¥å£å®ç°ä¼šè¢«åŒ…è£…æˆä¸€ä¸ª AbstractProxyInvoker å®ä¾‹ï¼Œç„¶åé€šè¿‡ Exporter å®ä¾‹æš´éœ²å‡ºå»ï¼Œä»¥ä¾¿ Consumer ç«¯å¯ä»¥è°ƒç”¨åˆ°è¯¥æœåŠ¡ã€‚Exporter æš´éœ² Invoker \bçš„å®ç°ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯è®© Provider ç«¯èƒ½å¤Ÿæ ¹æ®è¯·æ±‚çš„å„ç§ä¿¡æ¯æ‰¾åˆ°å¯¹åº”çš„ Invoker å¯¹è±¡ã€‚Dubbo é€šè¿‡ç»´æŠ¤ä¸€ä¸ª Mapï¼Œå…¶ä¸­ key ä¸ºæœåŠ¡é”®ï¼Œvalue ä¸ºå°è£…æœåŠ¡çš„ Exporter å®ä¾‹ï¼Œè¿™æ ·å°±å¯ä»¥å®ç°æœåŠ¡çš„æš´éœ²äº†ã€‚ Exporter æ¥å£çš„å®šä¹‰å¦‚ä¸‹ï¼š 123456789101112131415161718public interface Exporter&lt;T&gt; &#123; /** * è·å–åº•å±‚å°è£…çš„Invokerå¯¹è±¡ * * @return invoker */ Invoker&lt;T&gt; getInvoker(); /** * å–æ¶ˆå‘å¸ƒåº•å±‚çš„Invokerå¯¹è±¡ * &lt;p&gt; * &lt;code&gt; * getInvoker().destroy(); * &lt;/code&gt; */ void unexport();&#125; ExporterListener æ¥å£ExporterListener æ˜¯ä¸€ä¸ªæ‰©å±•æ¥å£ï¼Œ è¯¥æ¥å£ç”¨äºç›‘å¬æœåŠ¡çš„æš´éœ²å’Œå–æ¶ˆï¼Œç›®å‰ Dubbo æœ¬èº«æ²¡æœ‰æä¾›ç‰¹åˆ«æœ‰ç”¨çš„æ‰©å±•å®ç°ï¼Œæä¾›è¯¥æ¥å£ä¸»è¦ä¸ºä½¿ç”¨æ–¹æä¾›æ‰©å±•åŠŸèƒ½ã€‚è¯¥æ¥å£å®šä¹‰å¦‚ä¸‹ï¼š 12345678910111213141516171819202122@SPIpublic interface ExporterListener &#123; /** * ç›‘å¬ æœåŠ¡æš´éœ² * * @param exporter * @throws RpcException * @see org.apache.dubbo.rpc.Protocol#export(Invoker) */ void exported(Exporter&lt;?&gt; exporter) throws RpcException; /** * ç›‘å¬ å–æ¶ˆæœåŠ¡æš´éœ² * * @param exporter * @throws RpcException * @see org.apache.dubbo.rpc.Exporter#unexport() */ void unexported(Exporter&lt;?&gt; exporter);&#125; InvokerListener æ¥å£InvokerListener æ¥å£æ˜¯ä¸€ä¸ªæ‰©å±•æ¥å£ï¼Œç”¨äºç›‘å¬æœåŠ¡å¼•ç”¨å’Œé”€æ¯å¼•ç”¨ã€‚åŒæ ·åœ°ï¼Œç›®å‰ Dubbo æœ¬èº«æ²¡æœ‰æä¾›ç‰¹åˆ«æœ‰ç”¨çš„æ‰©å±•å®ç°ã€‚è¯¥æ¥å£å®šä¹‰å¦‚ä¸‹ï¼š 123456789101112131415161718192021@SPIpublic interface InvokerListener &#123; /** * ç›‘å¬æœåŠ¡å¼•ç”¨å®Œæˆ * * @param invoker * @throws RpcException * @see com.alibaba.dubbo.rpc.Protocol#refer(Class, com.alibaba.dubbo.common.URL) */ void referred(Invoker&lt;?&gt; invoker) throws RpcException; /** * ç›‘å¬é”€æ¯å¼•ç”¨å®Œæˆ * * @param invoker * @see com.alibaba.dubbo.rpc.Invoker#destroy() */ void destroyed(Invoker&lt;?&gt; invoker);&#125; Protocol æ¥å£Protocol æ¥å£ä¸­ä¸»è¦å®šä¹‰äº† export() å’Œ refer() æ–¹æ³•ï¼Œåˆ†åˆ«ç”¨äºæœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨ã€‚å…·ä½“å®šä¹‰å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@SPI(\"dubbo\")public interface Protocol &#123; /** * é»˜è®¤ç«¯å£ * Get default port when user doesn't config the port. * * @return default port */ int getDefaultPort(); /** * å°†ä¸€ä¸ª Invoker æš´éœ²å‡ºå» &lt;br&gt; * 1. æ¥æ”¶åˆ°è¯·æ±‚åï¼Œåè®®åº”è¯¥è®°å½•è¯·æ±‚æºåœ°å€: RpcContext.getContext().setRemoteAddress();&lt;br&gt; * 2. export()å¿…é¡»æ˜¯å¹‚ç­‰çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æš´éœ²ç›¸åŒçš„URLæ—¶ï¼Œè°ƒç”¨ä¸€æ¬¡å’Œè°ƒç”¨ä¸¤æ¬¡æ²¡æœ‰åŒºåˆ« &lt;br&gt; * 3. Invoker æ˜¯ç”±æ¡†æ¶ä¼ å…¥çš„ï¼Œåè®®ä¸éœ€è¦å…³å¿ƒ &lt;br&gt; * * @param &lt;T&gt; Service type * @param invoker Service invoker * @return exporter reference for exported service, useful for unexport the service later * @throws RpcException thrown when error occurs during export the service, for example: port is occupied */ @Adaptive &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException; /** * å¼•ç”¨ä¸€ä¸ª Invoker &lt;br&gt; * 1. åè®®çš„è´£ä»»æ˜¯æ ¹æ®å‚æ•°è¿”å›ä¸€ä¸ª Invoker å¯¹è±¡ï¼Œç”± refer() æ–¹æ³•è¿”å›ã€‚&lt;br&gt; * 2. Consumerç«¯å¯ä»¥é€šè¿‡è¿™ä¸ªInvokerè¯·æ±‚åˆ°Providerç«¯çš„æœåŠ¡. &lt;br&gt; * * @param &lt;T&gt; Service type * @param type Service class * @param url URL address for the remote service * @return invoker service's local proxy * @throws RpcException when there's any error while connecting to the service provider */ @Adaptive &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException; /** * é‡Šæ”¾å½“å‰ Protocol å¯¹è±¡åº•å±‚å ç”¨çš„èµ„æº &lt;br&gt; * 1. é”€æ¯export()æ–¹æ³•ä»¥åŠrefer()æ–¹æ³•ä½¿ç”¨åˆ°çš„Invokerå¯¹è±¡ &lt;br&gt; * 2. é‡Šæ”¾æ‰€æœ‰å ç”¨èµ„æº, å¦‚: è¿æ¥, ç«¯å£, ç­‰ç­‰. &lt;br&gt; * 3. åè®®å¯ä»¥ç»§ç»­å¯¼å‡ºå’Œå¼•ç”¨æ–°çš„æœåŠ¡ï¼Œå³ä½¿å®ƒè¢«é”€æ¯ã€‚ */ void destroy();&#125; åœ¨ Protocol æ¥å£çš„å®ç°ä¸­ï¼Œexport() æ–¹æ³•å¹¶ä¸æ˜¯ç®€å•åœ°å°† Invoker å¯¹è±¡åŒ…è£…æˆ Exporter å¯¹è±¡è¿”å›ï¼Œè¯¥è¿‡ç¨‹è¿˜ä¼šæ¶‰åŠä»£ç†å¯¹è±¡çš„åˆ›å»ºã€åº•å±‚ Server çš„å¯åŠ¨ç­‰æ“ä½œã€‚refer() æ–¹æ³•é™¤äº†æ ¹æ®ä¼ å…¥çš„æœåŠ¡æ¥å£ä»¥åŠURLå‚æ•°æŸ¥è¯¢ Invoker ä¹‹å¤–ï¼Œè¿˜ä¼šæ¶‰åŠåˆ° Client çš„åˆ›å»ºç­‰æ“ä½œã€‚ ProxyFactory æ¥å£ProxyFactory æ¥å£ç”¨äºåœ¨æœåŠ¡æš´éœ²æ—¶å°†æœåŠ¡å®ä¾‹å°è£…æˆ Invoker å¯¹è±¡ï¼Œåœ¨æœåŠ¡å¼•ç”¨æ—¶ä¸º Invoker åˆ›å»ºä»£ç†å¯¹è±¡ã€‚æ¥å£å…·ä½“å®šä¹‰å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738@SPI(\"javassist\")public interface ProxyFactory &#123; /** * ä¸ºä¼ å…¥çš„ Invoker åˆ›å»ºä»£ç†å¯¹è±¡ï¼Œåœ¨å¼•ç”¨æœåŠ¡çš„è¿‡ç¨‹ä¼šè°ƒç”¨è¯¥æ–¹æ³• * &lt;p&gt; * create proxy. * * @param invoker æ¶ˆè´¹è€…å¯¹æä¾›è€…è°ƒç”¨çš„Invoker * @return proxy ä»£ç†å¯¹è±¡ */ @Adaptive(&#123;Constants.PROXY_KEY&#125;) &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException; /** * æ”¯æŒæ˜¯å¦æ³›å‹ * * @param invoker * @return proxy */ @Adaptive(&#123;Constants.PROXY_KEY&#125;) &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, boolean generic) throws RpcException; /** * å°†ä¼ å…¥çš„æœåŠ¡å®ä¾‹å°è£…æˆInvokerï¼Œåœ¨æš´éœ²æœåŠ¡æ—¶ä¼šè°ƒç”¨ * &lt;p&gt; * create invoker. * * @param &lt;T&gt; * @param proxy Serviceå¯¹è±¡ * @param type Serviceæ¥å£ç±»å‹ * @param url Serviceå¯¹åº”çš„Dubbo URL * @return invoker */ @Adaptive(&#123;Constants.PROXY_KEY&#125;) &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException;&#125; FilterDubbo ä¸­çš„ Filter ç”¨æ¥æ‹¦æˆª Dubbo è¯·æ±‚ï¼ŒFilter æ˜¯ä¸€ä¸ªæ‰©å±•æ¥å£ã€‚Dubbo å†…ç½®äº†ä¸°å¯Œçš„ Filter æ‰©å±•å®ç°ï¼Œè¿™äº›å†…ç½®çš„æ‰©å±•å®ç°éå¸¸é‡è¦ï¼Œå®ƒä»¬å¯ä»¥å®Œæˆç‰¹å®šçš„åŠŸèƒ½ã€‚æ­¤å¤–ï¼Œä½¿ç”¨æ–¹å¯ä»¥æ ¹æ®ä¸šåŠ¡éœ€è¦æ¥æ‰©å±•å®ç° Dubbo çš„åŠŸèƒ½ã€‚Filter æ¥å£å…·ä½“å®šä¹‰å¦‚ä¸‹ï¼š 12345678910111213141516171819202122@SPIpublic interface Filter &#123; /** * å°†è¯·æ±‚ä¼ é€’ç»™åç»­çš„ Invoker å¤„ç†ï¼Œæ³¨æ„ï¼Œåç»­çš„ Invoker å¯¹è±¡å¯èƒ½æ˜¯ä¸€ä¸ª Filter å°è£…è€Œæˆçš„ã€‚ * &lt;p&gt; * &lt;code&gt; * // before filter * Result result = invoker.invoke(invocation); * // after filter * return result; * &lt;/code&gt; * * @param invoker service * @param invocation invocation. * @return invoke result. * @throws RpcException * @see com.alibaba.dubbo.rpc.Invoker#invoke(Invocation) */ Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException;&#125; å°ç»“æœ¬ç¯‡æ–‡ç« é¦–å…ˆä»‹ç»äº† Dubbo Protocol åœ¨ Dubbo æ¶æ„ä¸­æ‰€å¤„ä½ç½®ï¼Œæ¥ç€ç®€å•åˆ†æäº†åè®®å±‚å¯¹åº”çš„ä»£ç æ¨¡å—ï¼Œæœ€åå¯¹ Protocol å±‚ç›¸å…³çš„æ ¸å¿ƒæ¥å£è¿›è¡Œäº†è¯´æ˜ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - ç¼–è§£ç å™¨","slug":"rpc/ç¼–è§£ç å™¨","date":"2020-06-28T16:00:00.000Z","updated":"2020-12-23T08:27:10.332Z","comments":false,"path":"posts/61d79ae/","link":"","permalink":"https://gentryhuang.com/posts/61d79ae/","excerpt":"","text":"å‰è¨€åœ¨ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ å’Œ ç½‘ç»œä¼ è¾“å±‚ ä¸­åˆ†åˆ«ä»‹ç»äº†ç¼–è§£ç çš„é¡¶çº§æ¥å£ Codec2 å’Œ Codec ï¼Œå¹¶å¯¹æŠ½è±¡å®ç°ç±» AbstractCodec ä»¥åŠ Transport å±‚çš„ TransportCodec è¿›è¡Œäº†ä»‹ç»ã€‚æœ¬ç¯‡æ–‡ç« å°†ä»‹ç» Exchange å±‚å’Œ Protocol å±‚ç›¸å…³çš„ç¼–è§£ç å™¨å®ç°ã€‚ æ¦‚è¿°ç¼–è§£ç å™¨ä¸»è¦å®ç°å¯¹æ¶ˆæ¯çš„ç¼–ç å’Œè§£ç ï¼Œè§£å†³ç²˜åŒ…å’Œæ‹†åŒ…ç­‰é—®é¢˜ï¼Œæ˜¯åœ¨åºåˆ—åŒ–ä¹‹ä¸Šå°è£…çš„ä¸€å±‚é€»è¾‘ã€‚ç¼–ç å™¨ç»§æ‰¿ä½“ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š åœ¨ä»‹ç»ç¼–è§£ç å™¨ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå¯¹ Dubbo åè®®è¿›è¡Œè¯´æ˜ï¼Œè„±ç¦»äº† Dubbo åè®®ç¼–è§£ç å™¨æ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚ Dubbo åè®® Dubbo åè®®è®¾è®¡å‚è€ƒäº†ç°æœ‰çš„ TCP/IP åè®®ï¼Œä¸€æ¬¡ RPC è°ƒç”¨åŒ…æ‹¬åè®®å¤´å’Œåè®®ä½“ä¸¤éƒ¨åˆ†ã€‚ä¸‹é¢å¯¹ Dubbo åè®®å†…å®¹è¿›è¡Œè¯¦ç»†è¯´æ˜ï¼š åç§»æ¯”ç‰¹ä½ è¡¨è¿° å«ä¹‰ 0 ï½ 7 ä½å’Œ 8 ï½ 15 ä½ Magic High å’Œ Magic Low åˆ†åˆ«æ˜¯é­”æ•°é«˜ä½å’Œé­”æ•°ä½ä½ï¼Œéƒ½æ˜¯å›ºå®šå€¼ï¼Œå¯ä»¥é€šè¿‡è¿™ 2 ä¸ª Byte åˆ¤æ–­ä¸€ä¸ªæ•°æ®åŒ…æ˜¯å¦ä¸º Dubbo åè®® 16 ä½ Req/Res æ•°æ®åŒ…ç±»å‹ï¼Œæ ‡è¯†å½“å‰æ¶ˆæ¯æ˜¯è¯·æ±‚è¿˜æ˜¯å“åº”ã€‚0 - Responseï¼Œ1 - Request 17 ä½ 2Way æ ‡è¯†å½“å‰æ¶ˆæ¯æ˜¯å•å‘è¿˜æ˜¯åŒå‘ï¼Œä»…åœ¨ç¬¬ 16 ä½è¢«è®¾ä¸º 1ï¼ˆè¯·æ±‚ï¼‰æ—¶æœ‰æ•ˆï¼Œ0 - å•å‘ï¼Œ1 - åŒå‘ 18 ä½ Event æ ‡è¯†å½“å‰æ¶ˆæ¯æ˜¯å¦ä¸ºäº‹ä»¶æ¶ˆæ¯ã€‚0 - è¯·æ±‚æˆ–å“åº”åŒ…ï¼Œ1 - äº‹ä»¶æ¶ˆæ¯ 19 ï½ 23 ä½ Serialization ID åºåˆ—åŒ–å™¨ç¼–å·ï¼Œæ ‡è¯†å½“å‰æ¶ˆæ¯ä½¿ç”¨å“ªä¸€ç§åºåˆ—åŒ–ç®—æ³•ã€‚å¦‚ 2 - Hessian2Serialization â€¦ 24 ï½ 31 ä½ Status è®°å½•å“åº”çš„çŠ¶æ€ï¼Œä»…åœ¨ç¬¬ 16 ä½è¢«è®¾ä¸º 0ï¼ˆå“åº”ï¼‰æ—¶æœ‰æ•ˆã€‚å¦‚ 20 - OK â€¦ 32 ï½ 95 ä½ RPC Request ID è¯·æ±‚ç¼–å·ï¼Œç”¨äºè®°å½•è¯·æ±‚çš„å”¯ä¸€æ ‡è¯†ï¼Œç”¨æ¥å°†è¯·æ±‚å’Œå“åº”åšå…³è”ï¼Œç±»å‹ä¸º long 96 ï½ 127 ä½ Data Length åºåˆ—åŒ–åçš„æ¶ˆæ¯ä½“é•¿åº¦ï¼Œè¯¥å€¼æŒ‰å­—èŠ‚è®¡æ•°ï¼Œç±»å‹ä½ int 128 ï½ Body Content æ¶ˆæ¯ä½“å†…å®¹ï¼Œå³è¯·æ±‚åŒ…æˆ–å“åº”åŒ…é€šè¿‡ç‰¹å®šåºåˆ—åŒ–ç®—æ³•åºåˆ—åŒ–åçš„ç»“æœ Dubbo åè®®ä¸­å‰ 128 ä½æ˜¯åè®®å¤´ï¼Œä¹‹åçš„å†…å®¹æ˜¯æ¶ˆæ¯ä½“ï¼Œè€Œåè®®å¤´å°±æ˜¯é€šè¿‡ ExchangeCodec å®ç°ç¼–è§£ç çš„ã€‚åœ¨æ¶ˆæ¯ä½“ä¸­ï¼Œå®¢æˆ·ç«¯ä¾§ä¸¥æ ¼æŒ‰ç…§åºåˆ—åŒ–é¡ºåºå†™å…¥æ¶ˆæ¯ï¼ŒæœåŠ¡ç«¯ä¾§ä¼šéµå¾ªç›¸åŒçš„é¡ºåºè¯»å–æ¶ˆæ¯ã€‚ TCP/IP åè®®å†…å®¹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ‹†åŒ…ç²˜åŒ…é—®é¢˜TCP é€šè®¯åè®®æ˜¯é¢å‘æµçš„ï¼ŒåŒ…å’ŒåŒ…ä¹‹é—´æ²¡æœ‰ç•Œé™ã€‚TCP ä¸ºäº†æé«˜æ€§èƒ½ï¼Œå‘é€ç«¯ä¼šæ ¹æ®ç¼“å†²åŒºå®é™…æƒ…å†µè¿›è¡Œåˆ’åˆ†ï¼Œä¸€ä¸ªå®Œæ•´çš„åŒ…å¯èƒ½ä¼šæ‹†åˆ†æˆå¤šä¸ªåŒ…è¿›è¡Œå‘é€ï¼Œä¹Ÿå¯èƒ½æŠŠå¤šä¸ªå°åŒ…å°è£…æˆä¸€ä¸ªå¤§çš„æ•°æ®åŒ…å‘é€ã€‚åŒç†ï¼Œæ¥æ”¶ç«¯ä¹Ÿä¼šç»´æŠ¤ç¼“å†²åŒºã€‚è¿™å°±æ˜¯ TCP æ‹†åŒ…å’Œç²˜åŒ…ã€‚ å›¾ç‰‡æ¥æº å‘ç”ŸåŸå›  åº”ç”¨ç¨‹åºå†™å…¥çš„æ•°æ®å¤§äºç¼“å†²åŒºå¤§å°ï¼Œä¼šå‘ç”Ÿæ‹†åŒ…ã€‚ åº”ç”¨ç¨‹åºå†™å…¥çš„æ•°æ®å°äºç¼“å†²åŒºå¤§å°ï¼Œä¼šå‘ç”Ÿç²˜åŒ…ã€‚ æ¥æ”¶ç«¯ä¸åŠæ—¶è¯»å–ç¼“å†²åŒºæ•°æ®ï¼Œä¼šå‘ç”Ÿç²˜åŒ…ã€‚ è§£å†³æ–¹æ¡ˆç”±äº TCP é€šè®¯åè®®æ˜¯é¢å‘æµçš„ï¼Œæ— æ³•åˆ†åŒºåŒ…çš„ç•Œé™ï¼Œè§£å†³æ‹†åŒ…ç²˜åŒ…é—®é¢˜æœ¬è´¨ä¸Šå°±æ˜¯è§£å†³åŒ…ç•Œé™çš„é—®é¢˜ã€‚ å›ºå®šé•¿åº¦ è®¾ç½®å®šé•¿æ¶ˆæ¯ï¼Œæ¶ˆæ¯é•¿åº¦ä¸å¤Ÿè¡¥å……ç›¸å…³é»˜è®¤å€¼ï¼Œå¦‚ç©ºæ ¼ç­‰ï¼Œæ¥æ”¶æ–¹æ¯æ¬¡è¯»å–æ—¢å®šé•¿åº¦çš„å†…å®¹ä½œä¸ºä¸€æ¡å®Œæ•´æ¶ˆæ¯ã€‚è¯¥æ–¹å¼çš„ç¼ºç‚¹æ˜¯æµªè´¹äº†éƒ¨åˆ†å­˜å‚¨ç©ºé—´å’Œå¸¦å®½ã€‚ ç‰¹æ®Šåˆ†éš”ç¬¦ è®¾ç½®æ•°æ®åŒ…çš„è¾¹ç•Œï¼Œå¦‚æ·»åŠ ç‰¹å®šç¬¦å·ï¼ˆå›è½¦ã€æ¢è¡Œç¬¦å·ï¼‰ï¼Œæ¥æ”¶æ–¹é€šè¿‡è¿™ä¸ªè¾¹ç•Œå°±å¯ä»¥å°†ä¸åŒçš„æ•°æ®åŒ…æ‹†åˆ†å¼€ã€‚ æ¶ˆæ¯å¤´ + å›ºå®šé•¿åº¦ æŠŠæ¶ˆæ¯æ•°æ®åˆ†æˆæ¶ˆæ¯å¤´å’Œæ¶ˆæ¯ä½“ï¼Œæ¶ˆæ¯å¤´å¸¦æ¶ˆæ¯ä½“çš„é•¿åº¦ï¼Œæ¥æ”¶æ–¹æ ¹æ®æ¶ˆæ¯å¤´ä¸­çš„é•¿åº¦è§£ææ•°æ®ã€‚ Dubbo åè®®è§£å†³æ–¹æ¡ˆDubbo åè®®ä½¿ç”¨æ¶ˆæ¯å¤´ + å›ºå®šé•¿åº¦çš„æ–¹å¼å¤„ç†ç²˜åŒ…å’Œæ‹†åŒ…é—®é¢˜ã€‚æ¶ˆæ¯å¤´å­˜å‚¨æ¶ˆæ¯å¼€å§‹æ ‡è¯†åŠæ¶ˆæ¯é•¿åº¦ï¼Œæ¥æ”¶ç«¯è·å–æ¶ˆæ¯å¤´çš„æ—¶å€™è§£æå‡ºæ¶ˆæ¯é•¿åº¦ï¼Œç„¶åæ ¹æ®è¯¥é•¿åº¦å‘åè¯»å–æ¶ˆæ¯å†…å®¹ã€‚ä¹Ÿå°±æ˜¯ä½¿ç”¨ç¼–è§£ç å¤„ç†æ¶ˆæ¯å¤´ï¼Œä½¿ç”¨åºåˆ—åŒ–å’Œååºåˆ—åŒ–å¤„ç†æ¶ˆæ¯ä½“ã€‚ ExchangeCodecExchangeCodec ç»§æ‰¿äº† TelnetCodec ç±»ï¼Œæ˜¯ä¿¡æ¯äº¤æ¢ç¼–è§£ç å™¨ï¼Œå…³äº TelnetCodec åœ¨æœ¬ç¯‡æ–‡ç« ä¸­æš‚ä¸å±•å¼€ä»‹ç»ã€‚è¯¥ç¼–è§£ç å™¨åªå¤„ç† Dubbo åè®®å¤´ï¼ŒDubboCodec é€šè¿‡ç»§æ‰¿çš„æ–¹å¼åœ¨ ExchangeCodec åŸºç¡€ä¸Šæ·»åŠ äº†è§£æ Dubbo æ¶ˆæ¯ä½“çš„åŠŸèƒ½ã€‚ å±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445464748+--- ExchangeCodec /** * åè®®å¤´çš„å­—èŠ‚æ•°: 16Bytes = 128 Bits */ protected static final int HEADER_LENGTH = 16; /** * åè®®å¤´å‰16ä½ï¼Œåˆ†ä¸º MAGIC_HIGH å’Œ MAGIC_LOW 2ä¸ªå­—èŠ‚ã€‚æ˜¯ä¸ªå›ºå®šå€¼ï¼Œæ ‡å¿—ç€ä¸€ä¸ªæ•°æ®åŒ…æ˜¯å¦æ˜¯ Dubbo åè®® * * 11011010 10111011 */ protected static final short MAGIC = (short) 0xdabb; // -9541 /** * é­”æ•°é«˜ä½ * * 11011010 */ protected static final byte MAGIC_HIGH = Bytes.short2bytes(MAGIC)[0]; // -38 /** * é­”æ•°ä½ä½ * * 10111011 */ protected static final byte MAGIC_LOW = Bytes.short2bytes(MAGIC)[1]; // -69 /** * æ ‡è¯†æ˜¯è¯·æ±‚è¿˜æ˜¯å“åº” 1 ä¸ºrequestè¯·æ±‚ 0 ä¸ºå“åº” * * 10000000 */ protected static final byte FLAG_REQUEST = (byte) 0x80; // -128 /** * æ ‡è¯†æ˜¯åŒå‘ä¼ è¾“è¿˜æ˜¯å•å‘ä¼ è¾“ 1 ä¸ºåŒå‘ä¼ è¾“ 0 ä¸ºæ˜¯å•å‘ä¼ è¾“ * * 01000000 */ protected static final byte FLAG_TWOWAY = (byte) 0x40; // 64 /** * æ ‡ç¤ºæ˜¯å¦ä¸ºäº‹ä»¶ï¼š 0 - å½“å‰æ•°æ®åŒ…æ˜¯è¯·æ±‚æˆ–å“åº”åŒ…ï¼Œ1 - å½“å‰æ•°æ®åŒ…æ˜¯å¿ƒè·³åŒ… * * 00100000 */ protected static final byte FLAG_EVENT = (byte) 0x20; // 32 /** * ç”¨äºè·å–åºåˆ—åŒ–ç±»å‹ IDçš„æ©ç ã€‚ * * 00011111 */ protected static final int SERIALIZATION_MASK = 0x1f; // 31 Dubbo åè®®å¤´ä¸­æ¯ä¸€ä½çš„å€¼è¦ä¹ˆç›´æ¥æ˜¯ä¸Šè¿°å±æ€§çš„å€¼ï¼Œè¦ä¹ˆæ˜¯ä¸Šè¿°å±æ€§ä½è¿ç®—åçš„ç»“æœã€‚ ç¼–ç å¤„ç†Dubbo ä¸­çš„ç¼–ç å™¨ä¸»è¦ç”¨äºå°† Java å¯¹è±¡ç¼–ç æˆå­—èŠ‚æµè¿”å›ç»™å¯¹ç«¯ï¼Œè¯¥è¿‡ç¨‹æ¶‰åŠä¸¤éƒ¨åˆ†äº‹æƒ…ï¼Œä¸€ä¸ªæ˜¯æ„é€ åè®®å¤´ï¼Œå¦ä¸€ä¸ªæ˜¯å¯¹æ¶ˆæ¯ä½“è¿›è¡Œåºåˆ—åŒ–å¤„ç†ã€‚ ExchangeCodec ç¼–ç é€»è¾‘ä¸»è¦æ­¥éª¤å¦‚ä¸‹ï¼š åˆ›å»ºä¸€ä¸ª 16 å­—èŠ‚çš„åè®®å¤´æ•°ç»„ã€‚ æ ¹æ®æ¶ˆæ¯åŒ…ç±»å‹ç¡®å®šåè®®å¤´æ•°ç»„ä¸­æ¯ä¸€ä½å¡«å……å€¼ã€‚ åè®®å¤´ä¸­æ¶ˆæ¯ä½“é•¿åº¦ä½éœ€è¦å…ˆå¯¹æ¶ˆæ¯ä½“è¿›è¡Œåºåˆ—åŒ–ï¼Œç„¶åå†å°†é•¿åº¦è®¾ç½®åˆ°åè®®å¤´ä¸­çš„æ¶ˆæ¯ä½“é•¿åº¦ä½ç½®ã€‚æ¶ˆæ¯ä½“åºåˆ—åŒ–ä»»åŠ¡äº¤ç»™ DubboCodec å®Œæˆï¼ˆäº‹ä»¶æ¶ˆæ¯é™¤å¤–ï¼‰ã€‚ å°†åè®®ä½“å’Œåè®®å¤´å…ˆåå†™å…¥ buffer ä¸­ã€‚ 123456789101112131415161718192021222324+--- ExchangeCodec /** * ç¼–ç  - è¯·æ±‚å¤´ * * @param channel Dubbo åº•å±‚ Channel * @param buffer Dubbo åº•å±‚ Buffer * @param msg å‡ºç«™æ¶ˆæ¯ * @throws IOException */ @Override public void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException &#123; // å¯¹è¯·æ±‚å¯¹è±¡è¿›è¡Œç¼–ç  if (msg instanceof Request) &#123; encodeRequest(channel, buffer, (Request) msg); // å¯¹å“åº”å¯¹è±¡è¿›è¡Œç¼–ç  &#125; else if (msg instanceof Response) &#123; encodeResponse(channel, buffer, (Response) msg); // æäº¤ç»™çˆ¶ç±»(Telnet)å¤„ç†ï¼Œ ç¼–ç Telnetå‘½ä»¤çš„ç»“æœ &#125; else &#123; super.encode(channel, buffer, msg); &#125; &#125; ExchangeCodec çš„ encode() æ–¹æ³•ä¸­ä¼šæ ¹æ®éœ€è¦ç¼–ç çš„æ¶ˆæ¯ç±»å‹è¿›è¡Œåˆ†ç±»ï¼Œä¸‹é¢æˆ‘ä»¬ä¾æ¬¡æ¥çœ‹å¯¹è¯·æ±‚å¯¹è±¡å’Œå“åº”å¯¹è±¡çš„ç¼–ç ï¼Œå…³äºç¼–ç  Telnet å‘½ä»¤æš‚ä¸è¯´æ˜ã€‚ è¯·æ±‚æ¶ˆæ¯ç¼–ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465+--- ExchangeCodec protected void encodeRequest(Channel channel, ChannelBuffer buffer, Request req) throws IOException &#123; // è·å–åºåˆ—åŒ–æ–¹å¼ï¼Œå¦‚æœæ²¡æœ‰é…ç½®ï¼Œé»˜è®¤æ˜¯ hessian2 Serialization serialization = getSerialization(channel); // åˆ›å»ºåè®®å¤´å­—èŠ‚æ•°ç»„ï¼Œé•¿åº¦ä¸º16 byte[] header = new byte[HEADER_LENGTH]; // è®¾ç½®é­”æ•°ï¼Œå ç”¨2ä¸ªå­—èŠ‚: [0-7] -&gt; é­”æ•°é«˜ä½ -38ï¼Œã€8-15ã€‘ -&gt; é­”æ•°ä½ä½ -69 Bytes.short2bytes(MAGIC, header); // è®¾ç½®æ•°æ®åŒ…ç±»å‹ï¼ˆRequest/Responseï¼Œ0 - Response 1- Requestï¼‰[16] å’Œåºåˆ—åŒ–å™¨ç¼–å· [19,23] header[2] = (byte) (FLAG_REQUEST | serialization.getContentTypeId()); // è®¾ç½®é€šä¿¡æ–¹å¼ (twoWay)ï¼Œå³æ˜¯åŒå‘ä¼ è¾“è¿˜æ˜¯å•å‘ï¼Œ0 - å•å‘è°ƒç”¨ï¼Œ1 - åŒå‘è°ƒç”¨ [17] if (req.isTwoWay()) &#123; header[2] |= FLAG_TWOWAY; &#125; // æ˜¯å¦ä¸ºäº‹ä»¶ï¼ˆeventï¼‰[18] if (req.isEvent()) &#123; header[2] |= FLAG_EVENT; &#125; // è®¾ç½®è¯·æ±‚ç¼–å·ï¼Œ8ä¸ªå­—èŠ‚ï¼Œä»ç¬¬5ä¸ªå­—èŠ‚å¼€å§‹è®¾ç½® [32 - 95] è¯·æ±‚ id ç¼–å·ï¼ŒLong å‹ã€‚ // æ³¨æ„ï¼Œå­—èŠ‚æ•°ç»„çš„ç¬¬4ä¸ªå­—èŠ‚[27- 31]æ²¡æœ‰è®¾ç½®å€¼ï¼Œå› ä¸ºstatus çŠ¶æ€ï¼ŒRequestæ²¡æœ‰ï¼ŒResponseæ‰æœ‰ Bytes.long2bytes(req.getId(), header, 4); // è·å– buffer å½“å‰çš„å†™ä½ç½® int savedWriteIndex = buffer.writerIndex(); // æ›´æ–° writerIndexï¼Œä¸ºåè®®å¤´é¢„ç•™ 16 ä¸ªå­—èŠ‚çš„ç©ºé—´ buffer.writerIndex(savedWriteIndex + HEADER_LENGTH); // è·å–åºåˆ—åŒ–å™¨ï¼Œå¦‚ Hessian2ObjectOutput ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer); ObjectOutput out = serialization.serialize(channel.getUrl(), bos); // å¯¹äº‹ä»¶è¿›è¡Œåºåˆ—åŒ– if (req.isEvent()) &#123; encodeEventData(channel, out, req.getData()); &#125; else &#123; // å¯¹æ™®é€šè¯·æ±‚çš„æ•°æ®è¿›è¡Œåºåˆ—åŒ–ï¼Œå³å°†req.dataï¼ˆä¸€èˆ¬æ˜¯RpcInvocationï¼‰ å†™å…¥åˆ°è¾“å‡ºæµoutä¸­ï¼ŒChannelBufferOutputStreamè¿›è¡Œæ¥æ”¶ï¼Œç„¶åå­˜å‚¨åˆ°ChannelBufferã€‚ encodeRequestData(channel, out, req.getData(), req.getVersion()); &#125; out.flushBuffer(); if (out instanceof Cleanable) &#123; ((Cleanable) out).cleanup(); &#125; bos.flush(); bos.close(); // æŒ‰ç…§å­—èŠ‚è®¡æ•°è¯·æ±‚çš„æ•°æ®åºåˆ—åŒ–åå¤§å°ï¼Œæ˜¯å¦è¶…è¿‡æ¶ˆæ¯ä¸Šé™ã€‚é»˜è®¤æœ€å¤§ä¸º 8Mï¼Œå¯ä»¥é€šè¿‡ payload å‚æ•°é…ç½®ã€‚ int len = bos.writtenBytes(); // å¯èƒ½ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œå³ä½¿æŠ›å‡ºå¼‚å¸¸ä¹Ÿæ— éœ€å¤ä½ bufferï¼Œæ¯ä¸€ä¸ªè¯·æ±‚æŒ‚è½½çš„ ChannelBuffer éƒ½æ˜¯æ–°å»ºçš„ã€‚ checkPayload(channel, len); // å°† æ¶ˆæ¯ä½“é•¿åº¦å†™å…¥åˆ°æ¶ˆæ¯å¤´ä¸­ [96 - 127]ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ ChannelBuffer è¦å…ˆå†™å…¥æ¶ˆæ¯ä½“çš„åŸå› ã€‚ Bytes.int2bytes(len, header, 12); // å°† buffer æŒ‡é’ˆç§»åŠ¨åˆ° savedWriteIndexï¼Œä¸ºå†™æ¶ˆæ¯å¤´åšå‡†å¤‡ buffer.writerIndex(savedWriteIndex); // ä» savedWriteIndex ä¸‹æ ‡å¤„å†™å…¥æ¶ˆæ¯å¤´ buffer.writeBytes(header); // è°ƒæ•´ ChannelBuffer å†™å…¥ä½ç½®ï¼Œå³writerIndex = åŸå†™ä¸‹æ ‡ + æ¶ˆæ¯å¤´é•¿åº¦ + æ¶ˆæ¯ä½“é•¿åº¦ buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len); &#125; ç†è§£äº† Dubbo çš„åè®®åä¸Šé¢çš„ä»£ç å°±éå¸¸ç®€å•äº†ã€‚è¯¥æ–¹æ³•ä¸»è¦é€»è¾‘æ˜¯ç¼–ç åè®®å¤´ï¼Œå¹¶ä¸”å¯¹äº‹ä»¶å’Œæ™®é€šè¯·æ±‚æ¶ˆæ¯åˆ†åˆ«åšå¤„ç†ï¼ŒencodeEventData() æ–¹æ³•æ²¡æœ‰ä»€ä¹ˆé€»è¾‘å¤„ç†ï¼Œç›´æ¥å°†äº‹ä»¶å†™å…¥åˆ°è¾“å‡ºæµ out ä¸­ï¼ŒencodeRequestData() æ–¹æ³•æ˜¯å¯¹æ™®é€šè¯·æ±‚æ•°æ®çš„å¤„ç†ï¼Œå…¶å®å°±æ˜¯å¯¹ RpcInvocation è°ƒç”¨è¿›è¡Œç¼–ç ï¼ŒDubboCode å¯¹ encodeRequestData() æ–¹æ³•è¿›è¡Œäº†é‡å†™ï¼Œä¸»è¦ä¸ºäº†å®ç°å¯¹ RpcInvocation å’Œ RpcResult ä½œä¸ºæ¶ˆæ¯ä½“çš„ç¼–ç å¤„ç†ï¼Œåœ¨ DubboCode ä¸­ä¼šè¯¦ç»†è¯´æ˜è¯¥æ–¹æ³•ã€‚ äº‹ä»¶åºåˆ—åŒ–1234567+--- ExchangeCodec private void encodeEventData(Channel channel, ObjectOutput out, Object data) throws IOException &#123; encodeEventData(out, data); &#125; private void encodeEventData(ObjectOutput out, Object data) throws IOException &#123; out.writeObject(data); &#125; è¯·æ±‚æ¶ˆæ¯åºåˆ—åŒ–1234567+--- ExchangeCodec protected void encodeRequestData(Channel channel, ObjectOutput out, Object data, String version) throws IOException &#123; encodeRequestData(out, data); &#125; protected void encodeRequestData(ObjectOutput out, Object data) throws IOException &#123; out.writeObject(data); &#125; å“åº”ç¼–ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118+--- ExchangeCodec protected void encodeResponse(Channel channel, ChannelBuffer buffer, Response res) throws IOException &#123; // è·å–å†™çš„ä½ç½® int savedWriteIndex = buffer.writerIndex(); try &#123; // è·å–åºåˆ—åŒ–å™¨ Serialization serialization = getSerialization(channel); // åˆ›å»ºæ¶ˆæ¯å¤´å­—èŠ‚æ•°ç»„ï¼Œé•¿åº¦ä¸º16 byte[] header = new byte[HEADER_LENGTH]; // è®¾ç½®é­”æ•°ï¼Œå 2ä¸ªå­—èŠ‚ [0-15] Bytes.short2bytes(MAGIC, header); // è®¾ç½®åºåˆ—åŒ–å™¨ç¼–å·,å headerç¬¬3ä¸ªå­—èŠ‚çš„å5ä½ [19 -23]ã€‚ // æ•°æ®åŒ…ç±»å‹ï¼ˆRequest/Responseï¼Œ0 - Response 1- Requestï¼‰[16] è¿™é‡Œä½¿ç”¨é»˜è®¤ 0 ï¼Œå› ä¸ºæ˜¯å“åº”åŒ… header[2] = serialization.getContentTypeId(); // å¦‚æœå¿ƒè·³æ•°æ®åŒ…ï¼Œå°±è®¾ç½®headerç¬¬3ä¸ªå­—èŠ‚çš„ç¬¬3ä½ [18] if (res.isHeartbeat()) &#123; header[2] |= FLAG_EVENT; &#125; // è®¾ç½®å“åº”çŠ¶æ€ï¼Œå 1ä¸ªå­—èŠ‚ ï¼Œ[24-31] byte status = res.getStatus(); header[3] = status; // è®¾ç½®è¯·æ±‚ç¼–å·ï¼Œæ³¨æ„Responseä¸­çš„idå°±æ˜¯Requestçš„ç¼–å·ï¼Œå 8ä¸ªå­—èŠ‚ [32-95] Bytes.long2bytes(res.getId(), header, 4); // æ›´æ–° writerIndexï¼Œä¸ºæ¶ˆæ¯å¤´é¢„ç•™ 16 ä¸ªå­—èŠ‚çš„ç©ºé—´ buffer.writerIndex(savedWriteIndex + HEADER_LENGTH); ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer); ObjectOutput out = serialization.serialize(channel.getUrl(), bos); // ç¼–ç å“åº”æ•°æ®æˆ–é”™è¯¯ä¿¡æ¯ if (status == Response.OK) &#123; if (res.isHeartbeat()) &#123; // å¯¹å¿ƒè·³å“åº”ç»“æœè¿›è¡Œåºåˆ—åŒ– encodeHeartbeatData(channel, out, res.getResult()); &#125; else &#123; // å¯¹å“åº”æ¶ˆæ¯è¿›è¡Œåºåˆ—åŒ–ï¼Œres.getResult() ä¸€èˆ¬æ˜¯ Result å¯¹è±¡ encodeResponseData(channel, out, res.getResult(), res.getVersion()); &#125; &#125; else &#123; // å¯¹é”™è¯¯ä¿¡æ¯è¿›è¡Œåºåˆ—åŒ– out.writeUTF(res.getErrorMessage()); &#125; out.flushBuffer(); if (out instanceof Cleanable) &#123; ((Cleanable) out).cleanup(); &#125; bos.flush(); bos.close(); // è·å–æ¶ˆæ¯ä½“é•¿åº¦ int len = bos.writtenBytes(); // æ ¡éªŒæ¶ˆæ¯é•¿åº¦æœ‰æ²¡æœ‰è¶…å‡ºå½“å‰è®¾ç½®çš„ä¸Šé™ checkPayload(channel, len); // å°†æ¶ˆæ¯ä½“é•¿åº¦å†™å…¥åˆ°æ¶ˆæ¯å¤´ä¸­ï¼Œå 4ä¸ªå­—èŠ‚ [96-127] Bytes.int2bytes(len, header, 12); // å°† buffer æŒ‡é’ˆç§»åŠ¨åˆ° savedWriteIndexï¼Œä¸ºå†™æ¶ˆæ¯å¤´åšå‡†å¤‡ buffer.writerIndex(savedWriteIndex); // ä» savedWriteIndex ä¸‹æ ‡å¤„å†™å…¥æ¶ˆæ¯å¤´ buffer.writeBytes(header); // è®¾ç½®æ–°çš„ writerIndexï¼ŒwriterIndex = åŸå†™ä¸‹æ ‡ + æ¶ˆæ¯å¤´é•¿åº¦ + æ¶ˆæ¯ä½“é•¿åº¦ buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len); // å¤„ç†å¼‚å¸¸ &#125; catch (Throwable t) &#123; // clear buffer å¤ä½ buffer buffer.writerIndex(savedWriteIndex); // send error message to Consumer, otherwise, Consumer will wait till timeout. // æ³¨æ„å’Œç¼–ç è¯·æ±‚çš„ä¸åŒ if (!res.isEvent() &amp;&amp; res.getStatus() != Response.BAD_RESPONSE) &#123; Response r = new Response(res.getId(), res.getVersion()); r.setStatus(Response.BAD_RESPONSE); // æ¶ˆæ¯å†…å®¹è¿‡å¤§ if (t instanceof ExceedPayloadLimitException) &#123; logger.warn(t.getMessage(), t); try &#123; r.setErrorMessage(t.getMessage()); channel.send(r); return; &#125; catch (RemotingException e) &#123; logger.warn(\"Failed to send bad_response info back: \" + t.getMessage() + \", cause: \" + e.getMessage(), e); &#125; &#125; else &#123; // FIXME log error message in Codec and handle in caught() of IoHanndler? logger.warn(\"Fail to encode response: \" + res + \", send bad_response info instead, cause: \" + t.getMessage(), t); try &#123; r.setErrorMessage(\"Failed to send response: \" + res + \", cause: \" + StringUtils.toString(t)); channel.send(r); return; &#125; catch (RemotingException e) &#123; logger.warn(\"Failed to send bad_response info back: \" + res + \", cause: \" + e.getMessage(), e); &#125; &#125; &#125; // Rethrow exception if (t instanceof IOException) &#123; throw (IOException) t; &#125; else if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else if (t instanceof Error) &#123; throw (Error) t; &#125; else &#123; throw new RuntimeException(t.getMessage(), t); &#125; &#125; &#125; encodeResponse() æ–¹æ³•ç¼–ç å“åº”çš„æ–¹å¼ä¸ encodeRequest() æ–¹æ³•ç¼–ç è¯·æ±‚çš„æ–¹å¼ç±»ä¼¼ï¼ŒåŒºåˆ«ç‚¹å¦‚ä¸‹: ç¼–ç å“åº”ä¼šåœ¨åè®®å¤´ä¸­ status ä¿å­˜å“åº”çš„çŠ¶æ€ç ï¼Œç¼–ç è¯·æ±‚æ˜¯ä¸å…·å¤‡çš„ã€‚ ç¼–ç å“åº”ä¸ä¼šå¯¹ 2Way è¿›è¡Œå¤„ç†ï¼Œåªæœ‰æ˜¯è¯·æ±‚åŒ…æ—¶æ‰ä¼šè®¾ç½®ã€‚ ç¼–ç å“åº”ä¼šå¯¹å¼‚å¸¸è¿›è¡Œå¤„ç†ä¸“é—¨å¤„ç† å¤ä½ ChannelBufferï¼Œé˜²æ­¢ç¼“å†²åŒºä¸­æ•°æ®é”™ä¹±ã€‚ å°†å¼‚å¸¸å“åº”è¿”å›ç»™å¯¹ç«¯ï¼Œé˜²æ­¢å¯¹ç«¯åªæœ‰ç­‰å¾…è¶…æ—¶æ‰èƒ½è¿”å›ï¼Œå°½é‡é¿å…æ— æ•ˆç­‰å¾…ã€‚ å¯¹å¼‚å¸¸è¿›è¡Œç»†åˆ†ï¼Œä¸”å°†å¼‚å¸¸ä¿¡æ¯è½¬æˆå­—ç¬¦ä¸²é˜²æ­¢å¯¹ç«¯æ— æ³•æ­£å¸¸ååºåˆ—åŒ–å¼‚å¸¸å¯¹è±¡ã€‚ æ­¤å¤–ï¼Œç¼–ç å“åº”å’Œç¼–ç è¯·æ±‚ç±»ä¼¼ï¼Œå¯¹å¿ƒè·³å“åº”çš„å¤„ç†ä¹Ÿæ˜¯ç›´æ¥å†™å…¥åˆ° out æµä¸­ï¼Œè€Œå¯¹å“åº”çš„ç¼–ç  encodeResponseData() æ–¹æ³•ä¹Ÿè¢« DubboCodec è¿›è¡Œäº†é‡å†™ã€‚ å¿ƒè·³å“åº”åºåˆ—åŒ–123456789101112+--- ExchangeCodec @Deprecated protected void encodeHeartbeatData(Channel channel, ObjectOutput out, Object data) throws IOException &#123; encodeHeartbeatData(out, data); &#125; @Deprecated protected void encodeHeartbeatData(ObjectOutput out, Object data) throws IOException &#123; encodeEventData(out, data); &#125; private void encodeEventData(ObjectOutput out, Object data) throws IOException &#123; out.writeObject(data); &#125; å“åº”æ•°æ®åºåˆ—åŒ–1234567+--- ExchangeCodec protected void encodeResponseData(Channel channel, ObjectOutput out, Object data, String version) throws IOException &#123; encodeResponseData(out, data); &#125; protected void encodeResponseData(ObjectOutput out, Object data) throws IOException &#123; out.writeObject(data); &#125; è§£ç å¤„ç†Dubbo çš„è§£ç å™¨æ¶‰åŠä¸¤éƒ¨åˆ†å·¥ä½œï¼Œä¸€ä¸ªæ˜¯è§£ç åè®®å¤´ï¼Œå¦ä¸€ä¸ªæ˜¯è§£ç åè®®ä½“ã€‚å®ƒæ˜¯ç¼–ç çš„é€†è¿‡ç¨‹ï¼Œä¼šå…ˆæ£€æŸ¥é­”æ•°ï¼Œç„¶åè¯»å–åè®®å¤´å’Œæ¶ˆæ¯çš„é•¿åº¦ï¼Œæœ€åæ ¹æ®åè®®å¤´ä¸­çš„å„ä¸ªæ ‡å¿—ä½è¿›è¡Œé€»è¾‘å¤„ç†ï¼Œä»¥åŠååºåˆ—åŒ–æ¶ˆæ¯æ•°æ®ã€‚ ExchangeCodec è§£ç é€»è¾‘ä¸»è¦æ­¥éª¤å¦‚ä¸‹ï¼š ä» buffer ä¸­è¯»å–ä¸€å®šçš„å­—èŠ‚ï¼Œå¯èƒ½æ˜¯ 16 ä¸ªå­—èŠ‚ä¹Ÿå¯èƒ½å°äº 16 å­—èŠ‚ï¼Œä½œä¸ºåè®®å¤´æ•°æ®ã€‚ å¦‚æœæ˜¯ Telnet å‘½ä»¤æ¶ˆæ¯ï¼Œåˆ™éœ€è¦å°† buffer ä¸­æ•°æ®å…¨éƒ¨è¯»å‡ºå¹¶è°ƒç”¨TelnetCodecçš„decodeæ–¹æ³•å¯¹æ•°æ®åŒ…è¿›è¡Œè§£ç ã€‚ å¦‚æœé Telnet å‘½ä»¤æ¶ˆæ¯ï¼Œåˆ™å±äº Dubbo åè®®æ¶ˆæ¯ï¼Œæ¶ˆæ¯çš„æ ¼å¼å’Œé•¿åº¦å¿…é¡»éµå¾ª Dubbo åè®®ã€‚ ç¬¬ 3 æ­¥å®Œæˆçš„æ˜¯è¯»å–åè®®å¤´ï¼Œå¯¹åè®®ä½“çš„å¤„ç†åˆ™äº¤ç»™ DubboCodec å¤„ç†ã€‚ æ¶ˆæ¯è§£ç 123456789101112+--- ExchangeCodec @Override public Object decode(Channel channel, ChannelBuffer buffer) throws IOException &#123; // ä»Buffer ä¸­è¯»å–å­—èŠ‚æ•° int readable = buffer.readableBytes(); // åˆ›å»ºåè®®å¤´å­—èŠ‚æ•°ç»„ï¼Œä¼˜å…ˆè§£æ Dubbo åè®®ï¼Œè€Œä¸æ˜¯ Telnet å‘½ä»¤ byte[] header = new byte[Math.min(readable, HEADER_LENGTH)]; // ä»ç®¡é“ä¸­å–å‡ºheader.lengthä¸ªå­—èŠ‚ buffer.readBytes(header); // è§£ç  return decode(channel, buffer, readable, header); &#125; æ³¨æ„ buffer.readBytes() æ–¹æ³•ç”¨äºä» Channel ä¸­è¯»å–å‡º header.length ä¸ªå­—èŠ‚ï¼Œå¯èƒ½ç›®å‰ Channel ä¸­æ•°æ®ä¸è¶³ 16 ä¸ªå­—èŠ‚ï¼Œä¹Ÿå¯èƒ½å¤§äº 16 ä¸ªå­—èŠ‚ã€‚ä¸‹é¢æˆ‘ä»¬çœ‹å…·ä½“çš„è§£ç é€»è¾‘æ–¹æ³• decode() ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263+--- ExchangeCodec @Override protected Object decode(Channel channel, ChannelBuffer buffer, int readable, byte[] header) throws IOException &#123; // é€šè¿‡é­”æ•°åˆ¤æ–­æ˜¯å¦Dubbo æ¶ˆæ¯,ä¸æ˜¯çš„æƒ…å†µä¸‹ç›®å‰æ˜¯Telnet å‘½ä»¤è¡Œå‘å‡ºçš„æ•°æ®åŒ… if (readable &gt; 0 &amp;&amp; header[0] != MAGIC_HIGH || readable &gt; 1 &amp;&amp; header[1] != MAGIC_LOW) &#123; int length = header.length; // å¦‚æœ header.length &lt; readable æˆç«‹ï¼Œè¯´æ˜ buffer ä¸­æ•°æ®æ²¡æœ‰è¯»å®Œï¼Œå› æ­¤éœ€è¦å°†æ•°æ®å…¨éƒ¨è¯»å–å‡ºæ¥ã€‚å› ä¸ºè¿™ä¸æ˜¯ Dubbo åè®®ã€‚ if (header.length &lt; readable) &#123; header = Bytes.copyOf(header, readable); buffer.readBytes(header, length, readable - length); &#125; for (int i = 1; i &lt; header.length - 1; i++) &#123; if (header[i] == MAGIC_HIGH &amp;&amp; header[i + 1] == MAGIC_LOW) &#123; buffer.readerIndex(buffer.readerIndex() - header.length + i); header = Bytes.copyOf(header, i); break; &#125; &#125; // é€šè¿‡telnetå‘½ä»¤è¡Œå‘é€çš„æ•°æ®åŒ…ä¸åŒ…å«æ¶ˆæ¯å¤´ï¼Œæ‰€ä»¥è¿™é‡Œè°ƒç”¨TelnetCodecçš„decodeæ–¹æ³•å¯¹æ•°æ®åŒ…è¿›è¡Œè§£ç  return super.decode(channel, buffer, readable, header); &#125; // æ£€æŸ¥å¯è¯»æ•°æ®å­—èŠ‚æ•°æ˜¯å¦å°‘äºå›ºå®šé•¿åº¦ ï¼Œè‹¥å°äºåˆ™è¿”å›éœ€è¦æ›´å¤šçš„è¾“å…¥ã€‚å› ä¸ºDubboåè®®é‡‡ç”¨ åè®®å¤´ + payload çš„æ–¹å¼ if (readable &lt; HEADER_LENGTH) &#123; return DecodeResult.NEED_MORE_INPUT; &#125; // ä»æ¶ˆæ¯å¤´ä¸­è·å–æ¶ˆæ¯ä½“çš„é•¿åº¦ - [96 - 127]ï¼Œé€šè¿‡è¯¥é•¿åº¦è¯»å–æ¶ˆæ¯ä½“ã€‚ int len = Bytes.bytes2int(header, 12); // æ£€æµ‹æ¶ˆæ¯ä½“é•¿åº¦æ˜¯å¦è¶…å‡ºé™åˆ¶ï¼Œè¶…å‡ºåˆ™æŠ›å‡ºå¼‚å¸¸ checkPayload(channel, len); // æ£€æµ‹å¯è¯»çš„å­—èŠ‚æ•°æ˜¯å¦å°äºå®é™…çš„å­—èŠ‚æ•°ã€æ¶ˆæ¯å¤´ + æ¶ˆæ¯ä½“ çš„å­—èŠ‚é•¿åº¦å’Œã€‘ï¼Œå¦‚æœæ˜¯åˆ™è¿”å›éœ€è¦æ›´å¤šçš„è¾“å…¥ int tt = len + HEADER_LENGTH; if (readable &lt; tt) &#123; return DecodeResult.NEED_MORE_INPUT; &#125; // limit input stream. æ ¹æ®æ¶ˆæ¯ä½“é•¿åº¦åˆ›å»ºè¾“å…¥æµå¯¹è±¡ ChannelBufferInputStream is = new ChannelBufferInputStream(buffer, len); try &#123; // è§£æ Header + Body,æ ¹æ®æƒ…å†µï¼Œæ ¹æ®å…·ä½“æ•°æ®åŒ…ç±»å‹è¿”å› Request æˆ– Reponse return decodeBody(channel, is, header); &#125; finally &#123; // è·³è¿‡æœªè¯»å®Œçš„æµï¼Œå¹¶æ‰“å°é”™è¯¯æ—¥å¿— if (is.available() &gt; 0) &#123; try &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Skip input stream \" + is.available()); &#125; StreamUtils.skipUnusedStream(is); &#125; catch (IOException e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; &#125; &#125; ExchangeCodec çš„ decodeBody() æ–¹æ³•è¢« DubboCodec é‡å†™äº†ï¼Œä»¥æ”¯æŒæ¶ˆæ¯ä½“çš„ç¼–è§£ç åŠŸèƒ½ï¼Œå°±ä¸å†å¯¹ ExchangeCodec çš„è¯¥æ–¹æ³•è¿›è¡Œè¯´æ˜ã€‚ ExchangeCodec ä¸­çš„æ¶ˆæ¯è§£ç å’Œæ¶ˆæ¯ç¼–ç ç€é‡ç‚¹ç›¸åŒï¼Œéƒ½æ˜¯å¯¹åè®®å¤´çš„ç¼–ç å’Œè§£ç ï¼Œå¯¹æ¶ˆæ¯ä½“çš„å¤„ç†éƒ½æ˜¯äº¤ç»™äº†å­ç±» DubboCodec æ¥å®Œæˆçš„ã€‚æ¥ä¸‹æ¥å°±å¯¹ DubboCodec çš„ç¼–ç ç å®ç°è¿›è¡Œåˆ†æã€‚ DubboCodecDubboCodec æ˜¯ Protocol å±‚çš„ç¼–è§£ç å™¨ï¼Œç»§æ‰¿äº† Exchange å±‚çš„ ExchangeCodec ç¼–è§£ç å®ç°ç±»ã€‚ExchangeCodec æ˜¯åŸºäºåè®®å¤´å¯¹ Request å’Œ Response çš„é€šç”¨è§£æï¼ŒDubbo åè®®ä¸­ RpcInvocation å’Œ RpcResult ä½œä¸ºæ¶ˆæ¯ä½“çš„å¤„ç†äº¤ç»™äº† DubboCodec æ¥å®Œæˆï¼Œå¹¶ä¸” DubboCodec è¿˜æ”¯æŒå‚æ•°å›è°ƒç­‰å¤„ç†ã€‚ å±æ€§1234567891011121314151617181920212223242526272829303132333435363738394041424344public class DubboCodec extends ExchangeCodec implements Codec2 &#123; private static final Logger log = LoggerFactory.getLogger(DubboCodec.class); /** * åè®®å */ public static final String NAME = \"dubbo\"; /** * åè®®ç‰ˆæœ¬ */ public static final String DUBBO_VERSION = Version.getProtocolVersion(); /** * å¼‚å¸¸å“åº” */ public static final byte RESPONSE_WITH_EXCEPTION = 0; /** * æ­£å¸¸å“åº”ï¼Œæœ‰ç»“æœ */ public static final byte RESPONSE_VALUE = 1; /** * æ­£å¸¸å“åº”ï¼Œæ— ç»“æœ */ public static final byte RESPONSE_NULL_VALUE = 2; /** * å¼‚å¸¸è¿”å›åŒ…å«éšè—å‚æ•° */ public static final byte RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS = 3; /** * å“åº”ç»“æœåŒ…å«éšè—å‚æ•° */ public static final byte RESPONSE_VALUE_WITH_ATTACHMENTS = 4; /** * å“åº”ç©ºå€¼åŒ…å«éšè—å‚æ•° */ public static final byte RESPONSE_NULL_VALUE_WITH_ATTACHMENTS = 5; /** * æ–¹æ³•å‚æ•° */ public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0]; /** * æ–¹æ³•å‚æ•°ç±»å‹ */ public static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];&#125; DubboCodec ä¸­çš„å±æ€§ä¸»è¦æ˜¯å¯¹ Dubbo å“åº”æ ‡è®°çš„å®šä¹‰ï¼Œå¤–åŠ é»˜è®¤æ–¹æ³•å‚æ•°åŠç±»å‹ã€‚ ç¼–ç æ¶ˆæ¯ä½“DubboCodec ä¸­çš„ç¼–ç æ¶ˆæ¯ä½“çš„æ–¹æ³•éƒ½æ˜¯å¯¹ ExchangeCodec æ–¹æ³•çš„é‡å†™ã€‚ ç¼–ç è¯·æ±‚æ¶ˆæ¯ä½“å¯¹ ExchangeCodec çš„ encodeRequestData() æ–¹æ³•çš„é‡å†™ã€‚ 12345+--- DubboCodec @Override protected void encodeRequestData(Channel channel, ObjectOutput out, Object data) throws IOException &#123; encodeRequestData(channel, out, data, DUBBO_VERSION); &#125; 1234567891011121314151617181920212223242526+--- DubboCoec @Override protected void encodeRequestData(Channel channel, ObjectOutput out, Object data, String version) throws IOException &#123; // å°†è¯·æ±‚æ¶ˆæ¯è½¬æˆ RpcInvocation å¯¹è±¡ RpcInvocation inv = (RpcInvocation) data; // å†™å…¥ `dubbo` `path` `version` out.writeUTF(version); // å†™å…¥æ¡†æ¶ç‰ˆæœ¬ out.writeUTF(inv.getAttachment(Constants.PATH_KEY)); // å†™å…¥è°ƒç”¨æ¥å£ out.writeUTF(inv.getAttachment(Constants.VERSION_KEY)); // å†™å…¥æ¥å£æŒ‡å®šçš„ç‰ˆæœ¬ï¼Œé»˜è®¤ä¸º 0.0.0 // å†™å…¥æ–¹æ³•åã€å‚æ•°ç±»å‹ã€å‚æ•°å€¼ out.writeUTF(inv.getMethodName()); out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes())); // è·å–æ–¹æ³•å‚æ•°ï¼Œä¾æ¬¡å†™å…¥æ–¹æ³•å‚æ•°å€¼ Object[] args = inv.getArguments(); if (args != null) &#123; for (int i = 0; i &lt; args.length; i++) &#123; // è°ƒç”¨ CallbackServiceCodec#encodeInvocationArgument(...) æ–¹æ³•ç¼–ç å‚æ•°ï¼Œä¸»è¦ç”¨äºå‚æ•°å›è°ƒåŠŸèƒ½ out.writeObject(encodeInvocationArgument(channel, inv, i)); &#125; &#125; // å†™å…¥éšå¼å‚æ•° Map out.writeObject(inv.getAttachments()); &#125; æ ¹æ® Dubbo åè®®çš„æ ¼å¼ç¼–ç è¯·æ±‚ä½“ RpcInvocationï¼ŒæŒ‰ç…§é¡ºåºä¾æ¬¡å°†æ‰€éœ€å­—æ®µç¼–ç æˆå­—èŠ‚æµï¼Œå¯¹åº”çš„è§£ç åœ¨ DecodeableRpcInvocation å¯¹è±¡ä¸­ã€‚éœ€è¦æ³¨æ„ out å‚æ•°ï¼Œè¯¥å¯¹è±¡ç”±é…ç½®çš„åºåˆ—åŒ–å†³å®šï¼Œå¦‚é…ç½® &lt;dubbo:protocol serialization=â€fastjsonâ€/&gt;ï¼Œout å°±æ˜¯ FastJsonObjectOutputã€‚ ç¼–ç å“åº”æ¶ˆæ¯ä½“å¯¹ ExchangeCodec çš„ encodeResponseData() æ–¹æ³•çš„é‡å†™ã€‚ 12345+--- DubboCodec @Override protected void encodeResponseData(Channel channel, ObjectOutput out, Object data) throws IOException &#123; encodeResponseData(channel, out, data, DUBBO_VERSION); &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849+--- DubboCodec @Override protected void encodeResponseData(Channel channel, ObjectOutput out, Object data, String version) throws IOException &#123; // å°†å“åº”è½¬ä¸º Result å¯¹è±¡ Result result = (Result) data; // æ£€æµ‹å½“å‰åè®®ç‰ˆæœ¬æ˜¯å¦æ”¯æŒéšå¼å‚æ•° boolean attach = Version.isSupportResponseAttatchment(version); Throwable th = result.getException(); // å“åº”ç»“æœæ²¡æœ‰å¼‚å¸¸ä¿¡æ¯ if (th == null) &#123; // æå–æ­£å¸¸è¿”å›ç»“æœ Object ret = result.getValue(); // è°ƒç”¨ç»“æœä¸ºç©º if (ret == null) &#123; // åºåˆ—åŒ–å“åº”ç±»å‹ out.writeByte(attach ? RESPONSE_NULL_VALUE_WITH_ATTACHMENTS : RESPONSE_NULL_VALUE); // è°ƒç”¨ç»“æœéç©º &#125; else &#123; // åºåˆ—åŒ–å“åº”ç±»å‹ out.writeByte(attach ? RESPONSE_VALUE_WITH_ATTACHMENTS : RESPONSE_VALUE); // åºåˆ—åŒ–è°ƒç”¨ç»“æœ out.writeObject(ret); &#125; //å“åº”ç»“æœæœ‰å¼‚å¸¸ &#125; else &#123; // åºåˆ—åŒ–å“åº”ç±»å‹ out.writeByte(attach ? RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS : RESPONSE_WITH_EXCEPTION); // åºåˆ—åŒ–å¼‚å¸¸å¯¹è±¡ out.writeObject(th); &#125; // å½“å‰åè®®ç‰ˆæœ¬æ”¯æŒResponseå¸¦æœ‰attachmentsé›†åˆ if (attach) &#123; // è®°å½• Dubbo åè®®ç‰ˆæœ¬ï¼Œè¿”å›ç»™æœåŠ¡æ¶ˆè´¹ç«¯ result.getAttachments().put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion()); // åºåˆ—åŒ– attachments é›†åˆ out.writeObject(result.getAttachments()); &#125; &#125; æ ¹æ® Dubbo åè®®çš„æ ¼å¼ç¼–ç å“åº”ä½“ï¼Œä¸»è¦å°† Dubbo å“åº”çŠ¶æ€å’Œå“åº”å€¼ç¼–ç æˆå­—èŠ‚æµï¼Œå¯¹åº”çš„è§£ç åœ¨ DecodeableRpcResult å¯¹è±¡ä¸­ã€‚out å‚æ•°æ³¨æ„äº‹é¡¹åŒç¼–ç è¯·æ±‚æ¶ˆæ¯ä½“ã€‚ è§£ç æ¶ˆæ¯ä½“å¯¹ ExchangeCodec çš„ decodeBody() æ–¹æ³•çš„é‡å†™ï¼Œç”¨äºå°†æ•°æ®åŒ…è§£ææˆ Request å’Œ Response æ¨¡å‹ã€‚ è§£ç è¯·æ±‚ä½“å°†è¯·æ±‚åŒ…è§£ææˆ Request æ¨¡å‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384+--- DubboCodec @Override protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException &#123; // åè®®å¤´ç¬¬ 3 ä¸ªå­—èŠ‚ byte flag = header[2]; // è·å–åºåˆ—åŒ–å™¨ç¼–å· byte proto = (byte) (flag &amp; SERIALIZATION_MASK); // è·å¾—è°ƒç”¨ç¼–å·ï¼ˆè¯·æ±‚æ—¶ç”Ÿæˆçš„ä¸€ä¸ªidï¼Œç”¨æ¥æ ‡è¯†ä¸€æ¬¡è°ƒç”¨ï¼‰ long id = Bytes.bytes2long(header, 4); // Req/Res -&gt; 0 ï¼Œå³å“åº”åŒ… if ((flag &amp; FLAG_REQUEST) == 0) &#123; // çœç•¥è§£ç å“åº”é€»è¾‘ // Req/Res -&gt; 0 ï¼Œå³è¯·æ±‚åŒ… &#125; else &#123; // åˆ›å»ºRequest Request req = new Request(id); req.setVersion(Version.getProtocolVersion()); // è®¾ç½®æ¶ˆæ¯å•å‘æˆ–åŒå‘ req.setTwoWay((flag &amp; FLAG_TWOWAY) != 0); // è®¾ç½®æ¶ˆæ¯æ˜¯å¦ä¸ºäº‹ä»¶æ¶ˆæ¯ if ((flag &amp; FLAG_EVENT) != 0) &#123; // è®¾ç½®å¿ƒè·³äº‹ä»¶åˆ°Requestå¯¹è±¡ä¸­ req.setEvent(Request.HEARTBEAT_EVENT); &#125; try &#123; Object data; // é€šè¿‡åºåˆ—åŒ–å™¨ç¼–å·é—´æ¥è·å–è¾“å…¥æµ ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto); // è§£ç å¿ƒè·³äº‹ä»¶ï¼Œå¿ƒè·³æŠ¥æ–‡æ²¡æœ‰æ¶ˆæ¯ä½“ if (req.isHeartbeat()) &#123; // å¯¹å¿ƒè·³åŒ…è¿›è¡Œè§£ç ï¼Œè¯¥æ–¹æ³•å·²ç»åºŸå¼ƒï¼Œçˆ¶ç±» ExchangeCodec ä¸­çš„æ–¹æ³• data = decodeHeartbeatData(channel, in); // å¯¹å…¶ä»–äº‹ä»¶æ•°æ®è§£ç ï¼Œè¿™é‡Œæ˜¯ readonly äº‹ä»¶ &#125; else if (req.isEvent()) &#123; // çˆ¶ç±» ExchangeCodec ä¸­çš„æ–¹æ³• data = decodeEventData(channel, in); // è§£ç æ™®é€šè¯·æ±‚ &#125; else &#123; DecodeableRpcInvocation inv; // æ ¹æ®urlå‚æ•°åˆ¤æ–­ï¼Œæ˜¯å¦åœ¨é€šä¿¡æ¡†æ¶ï¼ˆå¦‚Nettyï¼‰çš„IOçº¿ç¨‹ä¸Šå¯¹æ¶ˆæ¯ä½“è¿›è¡Œè§£ç ï¼Œé»˜è®¤ä¸º true if (channel.getUrl().getParameter(Constants.DECODE_IN_IO_THREAD_KEY, Constants.DEFAULT_DECODE_IN_IO_THREAD)) &#123; // åˆ›å»ºå¯è§£ç çš„ DecodeableRpcInvocation å¯¹è±¡ inv = new DecodeableRpcInvocation(channel, req, is, proto); // ç›´æ¥è°ƒç”¨decode()æ–¹æ³•åœ¨å½“å‰çº¿ç¨‹ï¼Œå³IOçº¿ç¨‹ä¸Šè¿›è¡Œè§£ç å·¥ä½œ inv.decode(); // åœ¨ Dubbo ThreadPool çº¿ç¨‹ä¸Šè§£ç ï¼Œä½¿ç”¨ DecodeHandler &#125; else &#123; inv = new DecodeableRpcInvocation(channel, req, new UnsafeByteArrayInputStream(readMessageData(is)), proto); &#125; // å¹¶æ²¡æœ‰è§£ç ï¼Œå»¶è¿Ÿåˆ°ä¸šåŠ¡çº¿ç¨‹æ± ä¸­è§£ç  data = inv; &#125; // è®¾ç½®data åˆ° Request å¯¹è±¡ä¸­, req.setData(data); &#125; catch (Throwable t) &#123; if (log.isWarnEnabled()) &#123; log.warn(\"Decode request failed: \" + t.getMessage(), t); &#125; // åœ¨è§£ç çš„è¿‡ç¨‹ä¸­å‡ºç°å¼‚å¸¸ï¼Œåˆ™è®¾ç½® broken å­—æ®µæ ‡è¯†è¯·æ±‚å¼‚å¸¸ï¼Œå¹¶å°†å¼‚å¸¸å¯¹è±¡è®¾ç½®åˆ°Requestå¯¹è±¡ä¸­ req.setBroken(true); req.setData(t); &#125; return req; &#125; &#125; è§£ç å“åº”ä½“å°†å“åº”åŒ…è§£ææˆ Response æ¨¡å‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687+--- DubboCodec @Override protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException &#123; // åè®®å¤´ç¬¬ 3 ä¸ªå­—èŠ‚ byte flag = header[2]; // è·å–åºåˆ—åŒ–å™¨ç¼–å· byte proto = (byte) (flag &amp; SERIALIZATION_MASK); // è·å¾—è°ƒç”¨ç¼–å·ï¼ˆè¯·æ±‚æ—¶ç”Ÿæˆçš„ä¸€ä¸ªidï¼Œç”¨æ¥æ ‡è¯†ä¸€æ¬¡è°ƒç”¨ï¼‰ long id = Bytes.bytes2long(header, 4); // Req/Res -&gt; 0 ï¼Œå³å“åº”åŒ… if ((flag &amp; FLAG_REQUEST) == 0) &#123; // åˆ›å»º Response å¯¹è±¡ï¼Œæ³¨æ„ id Response res = new Response(id); // è®¾ç½®å¿ƒè·³äº‹ä»¶ if ((flag &amp; FLAG_EVENT) != 0) &#123; res.setEvent(Response.HEARTBEAT_EVENT); &#125; // è·å–å¹¶è®¾ç½®å“åº”çŠ¶æ€ byte status = header[3]; res.setStatus(status); try &#123; // é€šè¿‡åºåˆ—åŒ–å™¨ç¼–å·é—´æ¥è·å–è¾“å…¥æµ ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto); // è°ƒç”¨è¿‡ç¨‹æ­£å¸¸ if (status == Response.OK) &#123; Object data; // å¿ƒè·³äº‹ä»¶ if (res.isHeartbeat()) &#123; // ååºåˆ—åŒ–å¿ƒè·³æ•°æ®ï¼Œçˆ¶ç±» ExchangeCodec ä¸­çš„æ–¹æ³• data = decodeHeartbeatData(channel, in); // ååºåˆ—åŒ–å…¶ä»–äº‹ä»¶æ•°æ® &#125; else if (res.isEvent()) &#123; data = decodeEventData(channel, in); // è§£ç æ™®é€šå“åº” &#125; else &#123; DecodeableRpcResult result; // æ ¹æ®é…ç½®å†³å®šæ˜¯å¦åœ¨å½“å‰é€šä¿¡æ¡†æ¶ï¼ˆå¦‚ï¼šNettyï¼‰çš„IOçº¿ç¨‹ä¸Šè§£ç ï¼Œé»˜è®¤true if (channel.getUrl().getParameter(Constants.DECODE_IN_IO_THREAD_KEY, Constants.DEFAULT_DECODE_IN_IO_THREAD)) &#123; // åˆ›å»º DecodeableRpcResult å¯¹è±¡ result = new DecodeableRpcResult(channel, res, is, (Invocation) getRequestData(id), proto); // è§£ç  result.decode(); // åœ¨ Dubbo ThreadPool çº¿ç¨‹ï¼Œè§£ç ã€‚ä¼šåœ¨DecodeHandlerä¸­ä¼šè°ƒç”¨ DecodeableRpcResult#decode()æ–¹æ³• &#125; else &#123; result = new DecodeableRpcResult(channel, res, new UnsafeByteArrayInputStream(readMessageData(is)), (Invocation) getRequestData(id), proto); &#125; data = result; &#125; // è®¾ç½® DecodeableRpcResult å¯¹è±¡åˆ° Response å¯¹è±¡ä¸­ res.setResult(data); // å“åº”çŠ¶æ€é OKï¼Œè¡¨æ˜è°ƒç”¨è¿‡ç¨‹å‡ºç°äº†å¼‚å¸¸ &#125; else &#123; // ååºåˆ—åŒ–å¼‚å¸¸ä¿¡æ¯ï¼Œå¹¶è®¾ç½®åˆ° Response å¯¹è±¡ä¸­ res.setErrorMessage(in.readUTF()); &#125; &#125; catch (Throwable t) &#123; if (log.isWarnEnabled()) &#123; log.warn(\"Decode response failed: \" + t.getMessage(), t); &#125; // è§£ç è¿‡ç¨‹ä¸­å‡ºç°äº†é”™è¯¯ï¼Œæ­¤æ—¶è®¾ç½® CLIENT_ERROR çŠ¶æ€ç åˆ° Response å¯¹è±¡ä¸­ res.setStatus(Response.CLIENT_ERROR); res.setErrorMessage(StringUtils.toString(t)); &#125; return res; // è¯·æ±‚åŒ… &#125; else &#123; // çœç•¥è§£ç è¯·æ±‚é€»è¾‘ &#125; &#125; DecodeableRpcInvocationDecodeableRpcInvocation å®ç°äº† Codec å’Œ Decodeable æ¥å£ï¼Œå¹¶ä¸”ç»§æ‰¿äº† RpcInvocation ç±»ï¼Œæ˜¯ä¸€ä¸ªå¯è§£ç çš„ Invocation å®ç°ç±»ã€‚æœåŠ¡æ¶ˆè´¹æ–¹æ˜¯å¯¹ RpcInvocation å¯¹è±¡çš„ç¼–ç ï¼Œå°†æ‰€éœ€å­—æ®µç¼–ç æˆå­—èŠ‚æµã€‚æœåŠ¡æä¾›æ–¹å°†å­—èŠ‚æµæ¶ˆæ¯è§£ç æˆ DecodeableRpcInvocation å¯¹è±¡ï¼Œä½œä¸º Request çš„è¯·æ±‚ä½“æ•°æ®ã€‚ å±æ€§12345678910111213141516171819202122232425262728293031323334353637383940414243public class DecodeableRpcInvocation extends RpcInvocation implements Codec, Decodeable &#123; private static final Logger log = LoggerFactory.getLogger(DecodeableRpcInvocation.class); /** * Dubbo çš„é€šé“ */ private Channel channel; /** * Serialization ç±»å‹ç¼–å· */ private byte serializationType; /** * æ¶ˆæ¯å­—èŠ‚æµ */ private InputStream inputStream; /** * è¯·æ±‚ */ private Request request; /** * æ˜¯å¦å·²ç»è§£ç å®Œæˆ */ private volatile boolean hasDecoded; /** * å¯è§£ç  Invocation * * @param channel Dubbo åº•å±‚é€šé“ * @param request è¯·æ±‚ * @param is å­—èŠ‚æµæ¶ˆæ¯ * @param id åºåˆ—åŒ–ç¼–å· */ public DecodeableRpcInvocation(Channel channel, Request request, InputStream is, byte id) &#123; Assert.notNull(channel, \"channel == null\"); Assert.notNull(request, \"request == null\"); Assert.notNull(is, \"inputStream == null\"); this.channel = channel; this.request = request; this.inputStream = is; this.serializationType = id; &#125;&#125; è§£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899+--- DecodeableRpcInvocation @Override public void decode() throws Exception &#123; if (!hasDecoded &amp;&amp; channel != null &amp;&amp; inputStream != null) &#123; try &#123; decode(channel, inputStream); &#125; catch (Throwable e) &#123; if (log.isWarnEnabled()) &#123; log.warn(\"Decode rpc invocation failed: \" + e.getMessage(), e); &#125; // è§£ç å¤±è´¥ï¼Œè®¾ç½®å¤±è´¥æ ‡å¿— request.setBroken(true); request.setData(e); &#125; finally &#123; hasDecoded = true; &#125; &#125; &#125;+--- DecodeableRpcInvocation @Override public Object decode(Channel channel, InputStream input) throws IOException &#123; // è·å–åºåˆ—åŒ–æ–¹å¼ï¼Œç„¶åé€šè¿‡ååºåˆ—åŒ–å¾—åˆ°æ‰€éœ€çš„è°ƒç”¨ä¿¡æ¯ ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType).deserialize(channel.getUrl(), input); // æ¡†æ¶ç‰ˆæœ¬ String dubboVersion = in.readUTF(); request.setVersion(dubboVersion); // é€šè¿‡ååºåˆ—åŒ–å¾—åˆ° `dubbo` `path` `version`ï¼Œå¹¶ä¿å­˜åˆ° attachments å˜é‡ä¸­ setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion); setAttachment(Constants.PATH_KEY, in.readUTF()); // è¯»å–è°ƒç”¨æ¥å£ setAttachment(Constants.VERSION_KEY, in.readUTF()); // è¯»å–æ¥å£æŒ‡å®šçš„ç‰ˆæœ¬ï¼Œé»˜è®¤ä¸º 0.0.0 // é€šè¿‡ååºåˆ—åŒ–å¾—åˆ°è°ƒç”¨æ–¹æ³•å setMethodName(in.readUTF()); try &#123; // å‚æ•°åˆ—è¡¨ Object[] args; // å‚æ•°ç±»å‹åˆ—è¡¨ Class&lt;?&gt;[] pts; // é€šè¿‡ååºåˆ—åŒ–å¾—åˆ°å‚æ•°ç±»å‹å­—ç¬¦ä¸²ï¼Œå¦‚ï¼š Ljava/lang/String String desc = in.readUTF(); if (desc.length() == 0) &#123; pts = DubboCodec.EMPTY_CLASS_ARRAY; args = DubboCodec.EMPTY_OBJECT_ARRAY; &#125; else &#123; // å°† desc è§£æä¸ºå‚æ•°ç±»å‹æ•°ç»„ pts = ReflectUtils.desc2classArray(desc); args = new Object[pts.length]; // ä¸€æ¬¡è¯»å–æ–¹æ³•å‚æ•°å€¼ for (int i = 0; i &lt; args.length; i++) &#123; try &#123; // è§£æè¿è¡Œæ—¶å‚æ•° args[i] = in.readObject(pts[i]); &#125; catch (Exception e) &#123; if (log.isWarnEnabled()) &#123; log.warn(\"Decode argument failed: \" + e.getMessage(), e); &#125; &#125; &#125; &#125; // è®¾ç½®å‚æ•°ç±»å‹æ•°ç»„ setParameterTypes(pts); // é€šè¿‡ååºåˆ—åŒ–å¾—åˆ°åŸ attachments çš„å†…å®¹å³éšå¼å‚æ•° Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) in.readObject(Map.class); if (map != null &amp;&amp; map.size() &gt; 0) &#123; Map&lt;String, String&gt; attachment = getAttachments(); if (attachment == null) &#123; attachment = new HashMap&lt;String, String&gt;(); &#125; attachment.putAll(map); setAttachments(attachment); &#125; // å‚æ•°å›è°ƒç”¨ for (int i = 0; i &lt; args.length; i++) &#123; args[i] = decodeInvocationArgument(channel, this, pts, i, args[i]); &#125; // è®¾ç½®å‚æ•°åˆ—è¡¨ setArguments(args); &#125; catch (ClassNotFoundException e) &#123; throw new IOException(StringUtils.toString(\"Read invocation data failed.\", e)); &#125; finally &#123; if (in instanceof Cleanable) &#123; ((Cleanable) in).cleanup(); &#125; &#125; return this; &#125; DecodeableRpcInvocation æ˜¯ä¸€ä¸ªæ”¯æŒè§£ç åŠŸèƒ½çš„å®ç°ç±»ï¼Œå¹¶ä¸æ”¯æŒç¼–ç åŠŸèƒ½ã€‚ åœ¨è§£ç è¯·æ±‚æ—¶ï¼Œæ˜¯ä¸¥æ ¼æŒ‰ç…§å†™æ•°æ®é¡ºåºæ¥å¤„ç†çš„ã€‚é€šè¿‡ååºåˆ—åŒ–å°†è¯¸å¦‚ pathã€versionã€methodName ä»¥åŠ å‚æ•°åˆ—è¡¨ç­‰ä¿¡æ¯è§£æå‡ºæ¥ï¼Œå¹¶è®¾ç½®åˆ°å¯¹åº”çš„å­—æ®µä¸­ï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªå…·æœ‰å®Œæ•´è°ƒç”¨ä¿¡æ¯çš„ DecodeableRpcInvocation å¯¹è±¡ã€‚ DecodeableRpcResultDecodeableRpcResult å®ç°äº† Codec å’Œ Decodeable æ¥å£ï¼Œä¸”ç»§æ‰¿äº† RpcResult ï¼Œå¯è§£ç çš„ Result å®ç°ç±»ã€‚å’Œ DecodeableRpcInvocation ç±»ä¼¼ï¼ŒæœåŠ¡æä¾›æ–¹æ˜¯å¯¹ Result å¯¹è±¡çš„ç¼–ç ï¼Œå°†å“åº”çŠ¶æ€å’Œå“åº”ç»“æœç¼–ç æˆå­—èŠ‚æµã€‚æœåŠ¡æ¶ˆè´¹æ–¹å°†å“åº”æ¶ˆæ¯è§£ç æˆ DecodeableRpcResult å¯¹è±¡ï¼Œå¹¶ä½œä¸º Response çš„å“åº”ç»“æœã€‚ å±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DecodeableRpcResult extends RpcResult implements Codec, Decodeable &#123; private static final Logger log = LoggerFactory.getLogger(DecodeableRpcResult.class); /** * Dubbo åº•å±‚é€šé“ */ private Channel channel; /** * Serialization ç±»å‹ç¼–å· */ private byte serializationType; /** * è¾“å…¥æµ */ private InputStream inputStream; /** * å“åº” */ private Response response; /** * Invocation å¯¹è±¡ */ private Invocation invocation; /** * æ˜¯å¦å·²ç»è§£ç å®Œæˆ */ private volatile boolean hasDecoded; /** * å¯è§£ç  Result * * @param channel Dubbo åº•å±‚é€šé“ * @param response å“åº” * @param is å­—èŠ‚æµå“åº” * @param invocation è°ƒç”¨ä¿¡æ¯ * @param id åºåˆ—åŒ–ç¼–å· */ public DecodeableRpcResult(Channel channel, Response response, InputStream is, Invocation invocation, byte id) &#123; Assert.notNull(channel, \"channel == null\"); Assert.notNull(response, \"response == null\"); Assert.notNull(is, \"inputStream == null\"); this.channel = channel; this.response = response; this.inputStream = is; this.invocation = invocation; this.serializationType = id; &#125;&#125; è§£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111+--- DecodeableRpcResult @Override public void decode() throws Exception &#123; if (!hasDecoded &amp;&amp; channel != null &amp;&amp; inputStream != null) &#123; try &#123; // æ‰§è¡Œååºåˆ—åŒ–æ“ä½œ decode(channel, inputStream); &#125; catch (Throwable e) &#123; if (log.isWarnEnabled()) &#123; log.warn(\"Decode rpc result failed: \" + e.getMessage(), e); &#125; // ååºåˆ—åŒ–å¤±è´¥ï¼Œè®¾ç½® CLIENT_ERROR çŠ¶æ€åˆ° Response å¯¹è±¡ä¸­ response.setStatus(Response.CLIENT_ERROR); // è®¾ç½®å¼‚å¸¸ä¿¡æ¯ response.setErrorMessage(StringUtils.toString(e)); &#125; finally &#123; hasDecoded = true; &#125; &#125; &#125;+--- DecodeableRpcResult @Override public Object decode(Channel channel, InputStream input) throws IOException &#123; // é€šè¿‡åºåˆ—åŒ–å™¨è·å–è¾“å…¥æµ ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType).deserialize(channel.getUrl(), input); // ååºåˆ—åŒ–å“åº”ç±»å‹(ç¼–ç åºåˆ—åŒ–æ—¶è®¾ç½®çš„) byte flag = in.readByte(); // åŒ¹é…å“åº”ç±»å‹ switch (flag) &#123; // æ— è¿”å›å€¼ case DubboCodec.RESPONSE_NULL_VALUE: break; // æœ‰è¿”å›å€¼ case DubboCodec.RESPONSE_VALUE: try &#123; Type[] returnType = RpcUtils.getReturnTypes(invocation); // è®¾ç½®ç»“æœ setValue(returnType == null || returnType.length == 0 ? in.readObject() : // è¿”å›ç»“æœ:Type[]&#123;method.getReturnType(), method.getGenericReturnType()&#125; (returnType.length == 1 ? in.readObject((Class&lt;?&gt;) returnType[0]) : in.readObject((Class&lt;?&gt;) returnType[0], returnType[1]))); &#125; catch (ClassNotFoundException e) &#123; throw new IOException(StringUtils.toString(\"Read response data failed.\", e)); &#125; break; // æœ‰å¼‚å¸¸ case DubboCodec.RESPONSE_WITH_EXCEPTION: try &#123; Object obj = in.readObject(); if (obj instanceof Throwable == false) &#123; throw new IOException(\"Response data error, expect Throwable, but get \" + obj); &#125; setException((Throwable) obj); &#125; catch (ClassNotFoundException e) &#123; throw new IOException(StringUtils.toString(\"Read response data failed.\", e)); &#125; break; // è¿”å›å€¼ä¸ºç©ºï¼Œä¸”æºå¸¦äº† attachments é›†åˆ case DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS: try &#123; // ååºåˆ—åŒ– attachments é›†åˆï¼Œå¹¶å­˜å‚¨èµ·æ¥ setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class)); &#125; catch (ClassNotFoundException e) &#123; throw new IOException(StringUtils.toString(\"Read response data failed.\", e)); &#125; break; // è¿”å›å€¼ä¸ä¸ºç©ºï¼Œä¸”æºå¸¦äº† attachments é›†åˆ case DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS: try &#123; // è·å–è¿”å›å€¼ç±»å‹ Type[] returnType = RpcUtils.getReturnTypes(invocation); // ååºåˆ—åŒ–è°ƒç”¨ç»“æœï¼Œå¹¶ä¿å­˜èµ·æ¥ setValue(returnType == null || returnType.length == 0 ? in.readObject() : (returnType.length == 1 ? in.readObject((Class&lt;?&gt;) returnType[0]) : in.readObject((Class&lt;?&gt;) returnType[0], returnType[1]))); // ååºåˆ—åŒ– attachments é›†åˆï¼Œå¹¶å­˜å‚¨èµ·æ¥ setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class)); &#125; catch (ClassNotFoundException e) &#123; throw new IOException(StringUtils.toString(\"Read response data failed.\", e)); &#125; break; // å¼‚å¸¸å¯¹è±¡ä¸ä¸ºç©ºï¼Œä¸”æºå¸¦äº† attachments é›†åˆ case DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS: try &#123; // ååºåˆ—åŒ–å¼‚å¸¸å¯¹è±¡ Object obj = in.readObject(); if (obj instanceof Throwable == false) &#123; throw new IOException(\"Response data error, expect Throwable, but get \" + obj); &#125; // è®¾ç½®å¼‚å¸¸å¯¹è±¡ setException((Throwable) obj); // ååºåˆ—åŒ– attachments é›†åˆï¼Œå¹¶å­˜å‚¨èµ·æ¥ setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class)); &#125; catch (ClassNotFoundException e) &#123; throw new IOException(StringUtils.toString(\"Read response data failed.\", e)); &#125; break; default: throw new IOException(\"Unknown result flag, expect '0' '1' '2', get \" + flag); &#125; if (in instanceof Cleanable) &#123; ((Cleanable) in).cleanup(); &#125; return this; &#125; DecodeableRpcResult æ˜¯ä¸€ä¸ªæ”¯æŒè§£ç åŠŸèƒ½çš„å®ç°ç±»ï¼ŒåŒæ ·ä¸æ”¯æŒç¼–ç åŠŸèƒ½ã€‚ åœ¨è§£ç å“åº”æ—¶ï¼Œé€šè¿‡ååºåˆ—åŒ–å°† resultæˆ–exception ä»¥åŠ attachments è§£æå‡ºæ¥ï¼Œå¹¶è®¾ç½®åˆ°å¯¹åº”çš„å­—æ®µä¸­ï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªå®Œæ•´å“åº”ç»“æœçš„ DecodeableRpcResult å¯¹è±¡ã€‚ DubboCountCodecDubboCountCodec å®ç°äº† Codec2 é¡¶çº§æ¥å£ï¼Œç¼–è§£ç çš„ä»»åŠ¡éƒ½æ˜¯äº¤ç»™ DubboCodec å¯¹è±¡å»å®Œæˆã€‚DubboProtocol é»˜è®¤æŒ‡å®šçš„ç¼–è§£ç å™¨å°±æ˜¯ DubboCountCodecï¼Œç¼–ç ä»»åŠ¡ç›´æ¥å§”æ‰˜ç»™ DubboCodec å¤„ç†ï¼Œè§£ç æ”¯æŒå¤šæ¶ˆæ¯å¤„ç†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public final class DubboCountCodec implements Codec2 &#123; /** * Dubboçš„ç¼–è§£ç å™¨ */ private DubboCodec codec = new DubboCodec(); /** * ç¼–ç ç›´æ¥å§”æ‰˜ç»™ DubboCodec å¤„ç† * * @param channel * @param buffer * @param msg * @throws IOException */ @Override public void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException &#123; codec.encode(channel, buffer, msg); &#125; /** * è§£ç  * * @param channel * @param buffer * @return * @throws IOException */ @Override public Object decode(Channel channel, ChannelBuffer buffer) throws IOException &#123; // è®°å½•å½“å‰è¯»ä½ç½®ï¼Œç”¨äºä¸‹é¢è®¡ç®—æ¯æ¡æ¶ˆæ¯çš„é•¿åº¦ int save = buffer.readerIndex(); // åˆ›å»ºMultiMessageå¯¹è±¡ï¼Œå¯¹å¤šæ¶ˆæ¯çš„å°è£…ï¼ŒMultiMessageHandlerå¤„ç†å™¨ä¼šå¯¹è¯¥æ¶ˆæ¯è¿›è¡Œåˆ†å‘å¤„ç†ã€‚ MultiMessage result = MultiMessage.create(); // å¾ªç¯è§£ç æ¶ˆæ¯ do &#123; // é€šè¿‡ DubboCodec è§£ç ä¸€æ¡æ¶ˆæ¯ Object obj = codec.decode(channel, buffer); // å­—èŠ‚æ•°ä¸å¤Ÿï¼Œé‡ç½®è¯»æŒ‡é’ˆï¼Œç„¶åç»“æŸè§£æ if (Codec2.DecodeResult.NEED_MORE_INPUT == obj) &#123; buffer.readerIndex(save); break; // å°†æˆåŠŸè§£ç å‡ºçš„æ¶ˆæ¯æ·»åŠ åˆ° MultiMessage ä¸­ &#125; else &#123; // æ·»åŠ ç»“æœæ¶ˆæ¯ result.addMessage(obj); // è®°å½•æ¶ˆæ¯é•¿åº¦ logMessageLength(obj, buffer.readerIndex() - save); // è®°å½•å½“å‰è¯»ä½ç½®ï¼Œç”¨äºè®¡ç®—ä¸‹ä¸€æ¡æ¶ˆæ¯çš„é•¿åº¦ save = buffer.readerIndex(); &#125; &#125; while (true); // æ²¡æœ‰è§£ç å‡ºæ¶ˆæ¯ï¼Œåˆ™è¿”å›NEED_MORE_INPUTé”™è¯¯ç  if (result.isEmpty()) &#123; return Codec2.DecodeResult.NEED_MORE_INPUT; &#125; // åªè§£ç å‡ºæ¥ä¸€æ¡æ¶ˆæ¯ï¼Œåˆ™ç›´æ¥è¿”å›è¯¥æ¡æ¶ˆæ¯ if (result.size() == 1) &#123; return result.get(0); &#125; // è§£ç å‡ºå¤šæ¡æ¶ˆæ¯åˆ™å°†MultiMessageè¿”å› return result; &#125;&#125;","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - ä¿¡æ¯äº¤æ¢å±‚","slug":"rpc/Exchangeå±‚","date":"2020-06-17T16:00:00.000Z","updated":"2021-03-18T08:19:19.178Z","comments":false,"path":"posts/26722deb/","link":"","permalink":"https://gentryhuang.com/posts/26722deb/","excerpt":"","text":"å‰è¨€å‰é¢çš„å‡ ç¯‡æ–‡ç« è¯¦ç»†ä»‹ç»äº† Dubbo Remoting ä¸­çš„ Transport å±‚ï¼Œè¯¥å±‚åªè´Ÿè´£å•å‘æ¶ˆæ¯ä¼ è¾“ï¼Œæ˜¯ Dubbo ä¸­ç«¯åˆ°ç«¯çš„ç»Ÿä¸€ç½‘ç»œä¼ è¾“å®ç°ã€‚æœ¬ç¯‡æ–‡ç« å°†ä»‹ç»ç½‘ç»œä¼ è¾“å±‚å³ Transport å±‚ä¹‹ä¸Šçš„ Exchange å±‚ï¼ŒåŒæ—¶å®ƒä¹Ÿæ˜¯ Dubbo Remoting å±‚çš„æœ€é¡¶å±‚ã€‚ æ¦‚è¿°ä¿¡æ¯äº¤æ¢å±‚ Exchange åœ¨ä¼ è¾“å±‚ä¹‹ä¸Šå»ºç«‹äº† Request-Response æ¨¡å‹ï¼Œå®ç°äº†åœ¨ä¸åŒä¼ è¾“æ–¹å¼ä¹‹ä¸Šéƒ½èƒ½åšåˆ°ç»Ÿä¸€çš„è¯·æ±‚-å“åº”å¤„ç†ï¼Œå®ç°äº†åŒæ­¥è½¬å¼‚æ­¥ã€‚ä»¥ Request, Response ä¸ºä¸­å¿ƒï¼Œæ‰©å±•æ¥å£ä¸º Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer ã€‚ ä¸€æ¬¡ RPC è°ƒç”¨ï¼Œä¸Šå±‚è¯·æ±‚ Request åªå…³æ³¨å¯¹åº”çš„å“åº” Responseï¼Œè‡³äºæ˜¯åŒæ­¥è¯·æ±‚è¿˜æ˜¯å¼‚æ­¥è¯·æ±‚ï¼Œåˆæˆ–è€…ä½¿ç”¨ä»€ä¹ˆä¼ è¾“æ ¹æœ¬ä¸å…³å¿ƒã€‚è€Œ Transport å±‚ä»¥ Message ä¸ºä¸­å¿ƒæä¾›å•å‘æ¶ˆæ¯ä¼ è¾“ï¼Œæ˜¯æ— æ³•æ»¡è¶³è¿™é¡¹è¯‰æ±‚çš„ï¼Œå› æ­¤ Dubbo åŸºäº Transport å±‚åšäº†æ›´é«˜å±‚æ¬¡çš„å°è£…ï¼Œæ„å»ºäº† Exchange å±‚ã€‚ Exchange å±‚ä»£ç ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š Exchange å±‚æ„å»ºäº Transport å±‚ä¹‹ä¸Šï¼Œæ˜¯ Transport å±‚çš„ä½¿ç”¨è€…ï¼Œå†ç»“åˆä¸Šå›¾ä¸­çš„ä»£ç ç»“æ„ä¸éš¾å‘ç°ï¼ŒExchange å±‚åŒæ ·å…·å¤‡ç«¯ç‚¹ Endpointï¼ˆServer å’Œ Clientï¼‰ã€é€šé“ Channelã€å¤„ç†å™¨ Handler ä»¥åŠç¼–è§£ç å™¨ Codec ç­‰ç»„ä»¶ï¼ŒåŒºåˆ«åœ¨äº Exchange å±‚å°† Transport å±‚çš„ Message åˆ†æˆäº† Request å’Œ Response ä¸¤ç§ç±»å‹ï¼Œä¸”æ‰€æœ‰ç»„ä»¶éƒ½æ˜¯ä»¥è¿™ä¸¤ä¸ªæ¨¡å‹ä¸ºä¸­å¿ƒè¿›è¡Œå®ç°ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬ä» Request å’Œ Response è¿™ä¸€å¯¹æ ¸å¿ƒç±»å¼€å§‹ï¼Œä¾æ¬¡ä»‹ç» Exchange å±‚æ¶‰åŠçš„æ ¸å¿ƒæ¥å£å’Œå®ç°ç±»ã€‚ Request-Response æ¨¡å‹Exchange å±‚çš„ Request å’Œ Response æ˜¯å¯¹è¯·æ±‚å’Œå“åº”çš„æŠ½è±¡ã€‚ Request æ¨¡å‹å¯¹ä¸€æ¬¡ RPC è°ƒç”¨çš„è¯·æ±‚è¿›è¡ŒæŠ½è±¡ã€‚ å±æ€§1234567891011121314151617181920212223242526272829303132333435363738394041public class Request &#123; /** * å¿ƒè·³äº‹ä»¶ */ public static final String HEARTBEAT_EVENT = null; /** * åªè¯»äº‹ä»¶ */ public static final String READONLY_EVENT = \"R\"; /** * è¯·æ±‚ç¼–å·è‡ªå¢åºåˆ—ï¼Œæ³¨æ„å½“é€’å¢åˆ°Long.MAX_VALUEä¹‹åï¼Œä¼šæº¢å‡ºåˆ°Long.MIN_VALUEï¼Œä½†æ˜¯è¿™ä¸å½±å“ç»§ç»­ä½¿ç”¨è¯¥è´Ÿæ•°ä½œä¸ºæ¶ˆæ¯ID */ private static final AtomicLong INVOKE_ID = new AtomicLong(0); /** * è¯·æ±‚ç¼–å· ï¼Œæ³¨æ„è¿™ä¸ªç¼–å·ç”¨æ¥å’Œè¯¥è¯·æ±‚å¯¹åº”çš„å“åº”Responseå…³è”ï¼ŒResponseä¸­çš„mIdå°±æ˜¯è¯¥è¯·æ±‚çš„mId */ private final long mId; /** * è¯·æ±‚ç‰ˆæœ¬å· */ private String mVersion; /** * è¯·æ±‚æ˜¯å¦éœ€è¦å“åº”ï¼š true-&gt; éœ€è¦ false-&gt; ä¸éœ€è¦ */ private boolean mTwoWay = true; /** * äº‹ä»¶æ ‡è¯†ï¼Œå¦‚å¿ƒè·³è¯·æ±‚ã€åªè¯»è¯·æ±‚ã€‚ */ private boolean mEvent = false; /** * æ˜¯å¦å¼‚å¸¸çš„è¯·æ±‚ï¼Œä¸»è¦ç”¨äºï¼š * æœåŠ¡ç«¯æ”¶åˆ°è¯·æ±‚åï¼Œå¦‚æœä½¿ç”¨ DecodeHandler å°†äºŒè¿›åˆ¶æ•°æ®è§£ç æˆRequestå¯¹è±¡ï¼Œè¿™ä¸ªè§£ç è¿‡ç¨‹å¯èƒ½ä¼šå‡ºç°å¼‚å¸¸ï¼Œ * å¦‚æœå‡ºç°å¼‚å¸¸ï¼Œé‚£ä¹ˆå°±ç”¨è¯¥å±æ€§è¿›è¡Œæ ‡è¯†ï¼Œå…¶å®ƒ ChannelHandler å¯ä»¥æ ¹æ®è¯¥æ ‡å¿—åšè¿›ä¸€æ­¥å¤„ç†ã€‚ */ private boolean mBroken = false; /** * è¯·æ±‚ä½“ï¼Œå¯ä»¥æ˜¯ä»»ä½•ç±»å‹çš„æ•°æ®ï¼Œä¹Ÿå¯ä»¥æ˜¯null */ private Object mData;&#125; æ„é€ æ–¹æ³•12345678910111213141516171819202122232425/** * é»˜è®¤æ„é€ æ–¹æ³•ã€‚ */public Request() &#123; // å¯¹è¯·æ±‚ç¼–å·è¿›è¡Œèµ‹å€¼ mId = newId();&#125;/** * ä¼ å…¥è¯·æ±‚ç¼–å· * * @param id */public Request(long id) &#123; mId = id;&#125;/** * JVMè¿›ç¨‹å†…å”¯ä¸€ï¼ŒåŸå­è‡ªå¢ * * @return */private static long newId() &#123; return INVOKE_ID.getAndIncrement();&#125; æ ¸å¿ƒæ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839404142/** * åˆ¤æ–­æ˜¯å¦æ˜¯å¿ƒè·³è¯·æ±‚æ¡ä»¶ï¼š * 1. éœ€è¦æ˜¯äº‹ä»¶è¯·æ±‚ * 2. åˆ¤æ–­è¯·æ±‚ä½“æ˜¯å¦ä¸º null * * @return */ public boolean isHeartbeat() &#123; return mEvent &amp;&amp; HEARTBEAT_EVENT == mData; &#125; /** * è®¾ç½®å¿ƒè·³è¯·æ±‚ä¿¡æ¯ * 1. è®¾ç½® mEvent = true ï¼Œæ ‡å¿—æ˜¯äº‹ä»¶ * 2. è®¾ç½® mData = null * 3. ä»¥ä¸Šä¸¤è€…å…±åŒç¡®å®šæ˜¯å¿ƒè·³è¯·æ±‚ * * @param isHeartbeat */ public void setHeartbeat(boolean isHeartbeat) &#123; if (isHeartbeat) &#123; setEvent(HEARTBEAT_EVENT); &#125; &#125; /** * æ˜¯å¦æ˜¯äº‹ä»¶è¯·æ±‚ * * @return */ public boolean isEvent() &#123; return mEvent; &#125; /** * è¯·æ±‚ä½“æ˜¯å¦ä¸åˆæ³•ï¼ˆè§£ç è¯·æ±‚ä½“å¤±è´¥æ—¶ä¼šè®¾ç½® mBroken = trueï¼‰ * * @return */ public boolean isBroken() &#123; return mBroken; &#125; Response æ¨¡å‹å¯¹ä¸€æ¬¡ RPC å“åº”è¿›è¡ŒæŠ½è±¡ã€‚ å±æ€§1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Response &#123; /** * å¿ƒè·³äº‹ä»¶ */ public static final String HEARTBEAT_EVENT = null; /** * åªè¯»äº‹ä»¶ */ public static final String READONLY_EVENT = \"R\"; /** * è¯·æ±‚æˆåŠŸ */ public static final byte OK = 20; /** * å®¢æˆ·ç«¯ä¾§è¶…æ—¶ */ public static final byte CLIENT_TIMEOUT = 30; /** * æœåŠ¡ç«¯è¶…æ—¶ */ public static final byte SERVER_TIMEOUT = 31; // ... çœç•¥å…¶å®ƒå“åº”çŠ¶æ€ /** * å“åº”ç¼–å·ï¼Œå’Œå¯¹åº”çš„ Request çš„ mId ä¸€è‡´ã€‚ */ private long mId = 0; /** * å½“å‰åè®®çš„ç‰ˆæœ¬å·ï¼Œä¸è¯·æ±‚ç‰ˆæœ¬å·ä¸€è‡´ */ private String mVersion; /** * å“åº”çŠ¶æ€ç ï¼Œæœ‰ OKã€CLIENT_TIMEOUTã€SERVER_TIMEOUT ç­‰åå¤šç§ï¼Œ é»˜è®¤æ˜¯OKã€‚ */ private byte mStatus = OK; /** * äº‹ä»¶æ ‡è¯†ã€‚æ³¨æ„ï¼Œåªè¯»äº‹ä»¶ä¸éœ€è¦å“åº”ï¼Œä¹Ÿå°±ä¸ä¼šä½¿ç”¨åˆ°è¯¥å±æ€§ */ private boolean mEvent = false; /** * é”™è¯¯å“åº”æ¶ˆæ¯ */ private String mErrorMsg; /** * å“åº”ä½“ */ private Object mResult;&#125; æ„é€ æ–¹æ³•1234567891011121314151617181920212223/** * æ— å‚æ„é€ å‡½æ•° */ public Response() &#123; &#125; /** * å“åº”ç¼–å·ï¼Œå’Œå¯¹åº”çš„è¯·æ±‚ç¼–å·ä¸€è‡´ * * @param id å“åº”ç¼–å· */ public Response(long id) &#123; mId = id; &#125; /** * @param id å“åº”ç¼–å·ï¼Œå’Œå¯¹åº”çš„è¯·æ±‚ç¼–å·ä¸€è‡´ * @param version å½“å‰åè®®ç‰ˆæœ¬å·ï¼Œå’Œå¯¹åº”çš„è¯·æ±‚ç‰ˆæœ¬å·ä¸€è‡´ */ public Response(long id, String version) &#123; mId = id; mVersion = version; &#125; æ ¸å¿ƒæ–¹æ³•12345678910111213141516171819202122232425262728293031/** * åˆ¤æ–­æ˜¯å¦æ˜¯å¿ƒè·³äº‹ä»¶ * 1. éœ€è¦æ˜¯äº‹ä»¶ * 2. åˆ¤æ–­å“åº”ä½“æ˜¯å¦ä¸º null * * @return */ public boolean isHeartbeat() &#123; return mEvent &amp;&amp; HEARTBEAT_EVENT == mResult; &#125; /** * åªè¯»è¯·æ±‚æ˜¯ä¸éœ€è¦å“åº”çš„ï¼Œå¿ƒè·³è¯·æ±‚éœ€è¦å“åº” * * @param isHeartbeat */ @Deprecated public void setHeartbeat(boolean isHeartbeat) &#123; if (isHeartbeat) &#123; setEvent(HEARTBEAT_EVENT); &#125; &#125; /** * æ˜¯å¦æ˜¯äº‹ä»¶ * * @return */ public boolean isEvent() &#123; return mEvent; &#125; Exchange å±‚ä¸ºæ¡†æ¶å¼•å…¥çš„ Request å’Œ Response è¯­ä¹‰å°±ä»‹ç»åˆ°è¿™é‡Œï¼Œéœ€è¦å†æ¬¡è¯´æ˜ï¼Œè¿™ä¸¤ä¸ªå¯¹è±¡æ˜¯ Exchange å±‚çš„æ ¸å¿ƒï¼Œæ•´ä¸ª Exchange å±‚éƒ½æ˜¯å›´ç»•è¿™ä¸¤ä¸ªå¯¹è±¡è¿›è¡Œä»»åŠ¡çš„å¤„ç†ï¼Œåœ¨åé¢çš„åˆ†æè¿‡ç¨‹ä¸­ä¼šçœ‹åˆ°ã€‚ MultiMessageMultiMessage æ˜¯å¯¹å¤šä¸ªæ¶ˆæ¯çš„å°è£…ï¼Œå®ç°äº† Iterable æ¥å£ï¼Œæ”¯æŒå¯¹å°è£…çš„æ¶ˆæ¯é›†åˆè¿›è¡Œéå†ã€‚ 12345678910111213public final class MultiMessage implements Iterable &#123; /** * å¤šæ¶ˆæ¯çš„å°è£… */ private final List messages = new ArrayList(); @Override public Iterator iterator() &#123; return messages.iterator(); &#125; // çœç•¥å…¶å®ƒä»£ç ...&#125; Exchangerä¿¡æ¯äº¤æ¢æ¥å£ï¼Œæ˜¯ Dubbo çš„æ‰©å±•æ¥å£ï¼Œé»˜è®¤æ‰©å±•åä¸º header ï¼Œå¯¹åº”çš„é»˜è®¤æ‰©å±•å®ç°ä¸º HeaderExchanger ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ Exchanger æ¥å£çš„å”¯ä¸€æœ‰æ•ˆå®ç°ï¼Œè¯¥æ¥å£ä¸»è¦ç”¨æ¥å°è£…è¯·æ±‚-å“åº”æ¨¡å¼ã€‚ 1234567891011121314151617181920212223@SPI(HeaderExchanger.NAME)public interface Exchanger &#123; /** * ç»‘å®šä¸€ä¸ªæœåŠ¡å™¨ * * @param url æœåŠ¡å™¨åœ°å€ * @param handler æ•°æ®äº¤æ¢å¤„ç†å™¨ * @return message server æœåŠ¡å™¨ */ @Adaptive(&#123;Constants.EXCHANGER_KEY&#125;) ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException; /** * è¿æ¥æœåŠ¡å™¨ï¼Œå³åˆ›å»ºä¸€ä¸ªå®¢æˆ·ç«¯ * * @param url æœåŠ¡å™¨åœ°å€ * @param handler æ•°æ®äº¤æ¢å¤„ç†å™¨ * @return message channel å®¢æˆ·ç«¯ */ @Adaptive(&#123;Constants.EXCHANGER_KEY&#125;) ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException;&#125; ä»ä¸Šé¢ä»£ç å¯ä»¥çœ‹å‡ºï¼ŒExchanger æ¥å£å’Œ Transporter æ¥å£æå…¶ç›¸ä¼¼ï¼Œå› ä¸º Exchanger æ˜¯å¯¹ Transporter çš„å°è£…ï¼Œæ¥ä¸‹æ¥é€šè¿‡ HeaderExchanger å°±èƒ½éªŒè¯è¿™ä¸€ç‚¹ã€‚ HeaderExchanger1234567891011121314151617181920212223242526272829303132public class HeaderExchanger implements Exchanger &#123; /** * æ‰©å±•å */ public static final String NAME = \"header\"; /** * è¿æ¥æœåŠ¡ï¼Œåˆ›å»ºå®¢æˆ·ç«¯ã€‚ * * @param url æœåŠ¡å™¨åœ°å€ * @param handler æ•°æ®äº¤æ¢å¤„ç†å™¨ * @return * @throws RemotingException */ @Override public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException &#123; return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true); &#125; /** * ç»‘å®šæœåŠ¡å™¨ * * @param url æœåŠ¡å™¨åœ°å€ * @param handler æ•°æ®äº¤æ¢å¤„ç†å™¨ * @return * @throws RemotingException */ @Override public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123; return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler)))); &#125;&#125; é€šè¿‡ä¸Šé¢ä»£ç å¯ä»¥çœ‹å‡ºï¼ŒExchanger åˆ›å»ºçš„ HeaderExchangeServer å’Œ HeaderExchangeClient åˆ†åˆ«æ˜¯å¯¹ Transporter åˆ›å»ºçš„ Server å’Œ Client çš„å°è£…ï¼Œæ˜¯ Exchange å±‚çš„æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ï¼Œä¸‹é¢å¯¹è¿™ä¸¤ä¸ªè¿‡ç¨‹è¿›è¡Œè¯´æ˜ï¼š åˆ›å»º HeaderExchangeClient é»˜è®¤å¯åŠ¨å¿ƒè·³æ£€æµ‹ å¤„ç†å™¨çš„é¡ºåºä¸ºï¼šTransporterå±‚çš„Handleré“¾ =&gt; DecodeHandler =&gt; HeaderExchangeHandler =&gt; ExchangeHandler å°†Transporteråˆ›å»ºçš„å®¢æˆ·ç«¯å°è£…åˆ°HeaderExchangeClientä¸­ åˆ›å»º HeaderExchangeServer é»˜è®¤å¯åŠ¨å¿ƒè·³æ£€æµ‹ å¤„ç†å™¨çš„é¡ºåºä¸ºï¼šTransporterå±‚çš„Handleré“¾ =&gt; DecodeHandler =&gt; HeaderExchangeHandler =&gt; ExchangeHandler å°†Transporteråˆ›å»ºçš„æœåŠ¡å°è£…åˆ°HeaderExchangeServerä¸­ éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œæˆªæ­¢åˆ° HeaderExchanger å¯¹æœåŠ¡å’Œå®¢æˆ·ç«¯çš„åˆ›å»ºï¼Œä¸€æ¬¡ RPC è°ƒç”¨ Remoting å±‚çš„é€šé“å¤„ç†å™¨ Handler å·²ç»å…¨éƒ¨åˆ›å»ºå®Œæ¯•ï¼Œè¿™äº› Handler åœ¨ Dubbo çš„æ•´ä¸ªç½‘ç»œé€šä¿¡ä¸­å‘æŒ¥ç€å·¨å¤§ä½œç”¨ã€‚åˆ†æå®Œ Exchanger æ•°æ®äº¤æ¢æ¥å£åï¼Œæˆ‘ä»¬ç»§ç»­çœ‹ Exchanger çš„è®¿é—®å…¥å£ç±» Exchangers ã€‚ ExchangersExchangers æ˜¯æ•°æ®äº¤æ¢é—¨é¢ç±»ï¼Œå±äºå¤–è§‚æ¨¡å¼çš„å®ç°ã€‚å¯¹äº Exchange çš„ä¸Šå±‚æ¥è¯´ï¼ŒExchange å±‚çš„å…¥å£æ­£æ˜¯ Exchangers è¿™ä¸ªé—¨é¢ç±»ï¼Œå…¶ä¸­æä¾›äº†å¤šä¸ª bind() å’Œ connect() æ–¹æ³•çš„é‡è½½ï¼Œè¿™äº›æ–¹æ³•æœ€ç»ˆä¼šé€šè¿‡ Dubbo SPI æœºåˆ¶è·å– Exchanger æ¥å£çš„æ‰©å±•å®ç°ã€‚æ•´ä½“æµç¨‹å’Œ Transport å±‚ä¸€è‡´ï¼ŒTransport å±‚çš„å…¥å£ä¹Ÿæ˜¯è¦é€šè¿‡ Transports é—¨é¢ç±»ã€‚ä¸‹é¢æˆ‘ä»¬ç®€å•çœ‹çœ‹å®ƒçš„ä»£ç å®ç°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class Exchangers &#123; static &#123; // check duplicate jar package Version.checkDuplicate(Exchangers.class); &#125; private Exchangers() &#123; &#125; /** * å¯åŠ¨æœåŠ¡ * * @param url URLä¸² * @param handler æ•°æ®äº¤æ¢å¤„ç†å™¨ * @return æœåŠ¡ * @throws RemotingException */ public static ExchangeServer bind(String url, ExchangeHandler handler) throws RemotingException &#123; return bind(URL.valueOf(url), handler); &#125; public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; if (handler == null) &#123; throw new IllegalArgumentException(\"handler == null\"); &#125; url = url.addParameterIfAbsent(Constants.CODEC_KEY, \"exchange\"); return getExchanger(url).bind(url, handler); &#125; /** * è¿æ¥æœåŠ¡ * * @param url URLä¸² * @param handler æ•°æ®äº¤æ¢å¤„ç†å™¨ * @return å®¢æˆ·ç«¯ * @throws RemotingException */ public static ExchangeClient connect(String url, ExchangeHandler handler) throws RemotingException &#123; return connect(URL.valueOf(url), handler); &#125; public static ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; if (handler == null) &#123; throw new IllegalArgumentException(\"handler == null\"); &#125; url = url.addParameterIfAbsent(Constants.CODEC_KEY, \"exchange\"); return getExchanger(url).connect(url, handler); &#125; /** * è·å– Exchanger æ‰©å±•å®ç° * * @param url * @return */ public static Exchanger getExchanger(URL url) &#123; // ä» URL ä¸­è·å– exchanger çš„å€¼ï¼Œé»˜è®¤ä¸º header String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER); return getExchanger(type); &#125; /** * 1 è·å–Exchangerï¼Œé»˜è®¤ä¸º HeaderExchangerã€‚ * 2 ç´§æ¥ç€è°ƒç”¨ HeaderExchangerçš„bindæ–¹æ³•åˆ›å»º ExchangeServerå®ä¾‹ * * @param type æ‰©å±•å * @return */ public static Exchanger getExchanger(String type) &#123; return ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type); &#125;&#125; ç”±äºç›®å‰ Dubbo çš„ Exchanger æœ‰æ•ˆæ‰©å±•å®ç°åªæœ‰ HeaderExchanger ï¼Œå› æ­¤ Exchangers ä¸­åªä¿ç•™äº†å’Œ HeaderExchanger ç›¸å…³çš„ä»£ç ã€‚ äº†è§£äº† Exchange å±‚çš„ Request-Response æ¨¡å‹ä»¥åŠå…¥å£åï¼Œä¸‹é¢æˆ‘ä»¬åˆ†åˆ«å¯¹ Exchange å±‚çš„ç«¯ç‚¹ Endpointã€é€šé“ Channelã€å¤„ç†å™¨ Handler ä»¥åŠç¼–è§£ç å™¨ Codec2 è¿›è¡Œè¯¦ç»†è¯´æ˜ã€‚ é€šé“Exchange å±‚é€šé“ Channel ç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š åœ¨å‰é¢çš„æ–‡ç« ä¸­å·²ç»è¯¦ç»†ä»‹ç»äº† Channel æ¥å£ä»¥åŠ Transport å±‚å¯¹ Channel æ¥å£çš„å®ç°ã€‚Exchange å±‚åŸºäº Channel æ¥å£æŠ½è±¡å‡ºäº† ExchangeChannel æ¥å£ï¼Œè¡¨ç¤ºè¯¥å±‚çš„ç½‘è·¯è¿æ¥ï¼Œç”¨æ¥å‘é€è¯·æ±‚ç­‰æ“ä½œã€‚ ExchangeChannel æ¥å£ä¸­çš„æ–¹æ³•å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸Šå›¾ä¸­çš„ç°è‰²æ–¹æ³•ç»§æ‰¿è‡ª Endpoint å’Œ Channel æ¥å£ï¼Œå…¶ä¸­ 4 ä¸ªç™½è‰²çš„æ–¹æ³•æ˜¯ Exchange å±‚å®šä¹‰å‡ºçš„æ–¹æ³•ï¼Œrequest() æ–¹æ³•è´Ÿè´£å‘é€è¯·æ±‚ï¼ŒgetExchangeHandler() æ–¹æ³•ç”¨äºè·å–ä¿¡æ¯äº¤æ¢å¤„ç†å™¨ï¼Œclose() æ–¹æ³•ç”¨äºå…³é—­é€šé“ã€‚ExchangeChannel æ¥å£å®šä¹‰å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536public interface ExchangeChannel extends Channel &#123; /** * å‘é€è¯·æ±‚ * * @param request * @return future * @throws RemotingException */ ResponseFuture request(Object request) throws RemotingException; /** * å‘é€è¯·æ±‚ * * @param request * @param timeout * @return future * @throws RemotingException */ ResponseFuture request(Object request, int timeout) throws RemotingException; /** * è·å¾—ä¿¡æ¯äº¤æ¢å¤„ç†å™¨ * * @return message handler */ ExchangeHandler getExchangeHandler(); /** * ä¼˜é›…å…³é—­ * * @param timeout */ @Override void close(int timeout);&#125; ExchangeChannel æ¥å£æœ¬èº«æ–°å®šä¹‰äº†è¯·æ±‚å‘é€ request() æ–¹æ³•ã€è·å¾—ä¿¡æ¯äº¤æ¢å¤„ç†å™¨ getExchangeHandler() æ–¹æ³•ä»¥åŠå…³é—­æ–¹æ³•ï¼Œå…¶å®ƒæ–¹æ³•åˆ†åˆ«ç»§æ‰¿è‡ª Endpoint å’Œ Channel æ¥å£ä¸­çš„æ–¹æ³•ã€‚ä¸‹é¢æˆ‘ä»¬ç»§ç»­çœ‹å®ƒçš„ HeaderExchangeChannel å®ç°ç±»ã€‚ HeaderExchangeChannelHeaderExchangeChannel å®ç°äº† ExchangeChannel æ¥å£ï¼ŒåŸºäºæ¶ˆæ¯å¤´çš„ä¿¡æ¯äº¤æ¢é€šé“å®ç°ç±»ã€‚å®ƒæœ¬èº«æ˜¯ Channel çš„è£…é¥°å™¨ï¼Œå°è£…äº†ä¸€ä¸ª Channel å¯¹è±¡ï¼Œsend() å’Œ request() æ–¹æ³•çš„å®ç°éƒ½å§”æ‰˜ç»™è¿™ä¸ª Channel å¯¹è±¡ã€‚ å±æ€§1234567891011121314151617181920212223242526272829final class HeaderExchangeChannel implements ExchangeChannel &#123; private static final Logger logger = LoggerFactory.getLogger(HeaderExchangeChannel.class); /** * ä½œä¸º channel çš„å±æ€§ keyï¼Œvalue æ˜¯ HeaderExchangeChannel å¯¹è±¡ */ private static final String CHANNEL_KEY = HeaderExchangeChannel.class.getName() + \".CHANNEL\"; /** * è¢«è£…é¥°çš„ Channelï¼Œå¦‚ NettyChannelã€NettyClient */ private final Channel channel; /** * æ˜¯å¦å…³é—­ */ private volatile boolean closed = false; /** * HeaderExchangeChannel æ˜¯ä¼ å…¥channelçš„è£…é¥°å™¨ * * @param channel è¢«è£…é¥°çš„ Channel */ HeaderExchangeChannel(Channel channel) &#123; if (channel == null) &#123; throw new IllegalArgumentException(\"channel == null\"); &#125; this.channel = channel; &#125;&#125; HeaderExchangeChannel ä¸­æœ‰ 3 ä¸ªå±æ€§ï¼Œè¿™ä¸‰ä¸ªå±æ€§éƒ½æœ‰å„è‡ªçš„ä½œç”¨ï¼š CHANNEL_KEY: é™æ€å¸¸é‡ï¼Œä½œä¸º Channel å­˜å‚¨ HeaderExchangeChannel å¯¹è±¡çš„ keyï¼Œä¿è¯äº†åŒä¸€ä¸ª Channel åˆ›å»ºå”¯ä¸€çš„ HeaderExchangeChannel å¯¹è±¡ã€‚ channel: HeaderExchangeChannel è£…é¥°çš„ Channelï¼Œæ­¤ channel ä¸­ä¼šå­˜å‚¨ HeaderExchangeChannel å¯¹è±¡ï¼Œkey å°±æ˜¯ CHANNEL_KEY è¿™ä¸ªå¸¸é‡å€¼ã€‚ closed: ç”¨äºæ ‡è®°é€šé“æ˜¯å¦å…³é—­ï¼Œrequest() å’Œ send() æ–¹æ³•å—è¯¥å€¼å½±å“ã€‚ è·å– HeaderExchangeChannel12345678910111213141516171819202122--- HeaderExchangeChannel /** * åˆ›å»ºHeaderExchangeChannel å¯¹è±¡ã€‚ * * @param ch Channel * @return */ static HeaderExchangeChannel getOrAddChannel(Channel ch) &#123; if (ch == null) &#123; return null; &#125; // é€šè¿‡ ch.getAttribute(CHANNEL_KEY) ï¼Œä¿è¯ ch ç»‘å®šå”¯ä¸€çš„ HeaderExchangeChannel å¯¹è±¡ HeaderExchangeChannel ret = (HeaderExchangeChannel) ch.getAttribute(CHANNEL_KEY); if (ret == null) &#123; ret = new HeaderExchangeChannel(ch); // ch å¿…é¡»æ˜¯å·²è¿æ¥çŠ¶æ€ï¼Œå¦åˆ™ä¸ä¼šç»‘å®šå¯¹åº”çš„ HeaderExchangeChannel å¯¹è±¡ if (ch.isConnected()) &#123; ch.setAttribute(CHANNEL_KEY, ret); &#125; &#125; return ret; &#125; getOrAddChannel() æ–¹æ³•ç”¨äºè·å–ä¼ å…¥çš„ Channel å¯¹åº”çš„ HeaderExchangeChannel å¯¹è±¡ï¼Œå¹¶ä¸” HeaderExchangeChannel å¯¹è±¡ä¼šå¯¹ä¼ å…¥çš„ Channel è¿›è¡Œå°è£…ã€è£…é¥°ã€‚ä¸éš¾çœ‹å‡ºä¸¤è€…æœŸæœ›æ˜¯ç›¸äº’ç»‘å®šå…³ç³»ï¼Œä½†è¦æ±‚ Channel ä¸€æ–¹å¿…é¡»æ˜¯å¤„äºè¿æ¥çŠ¶æ€ã€‚ ç§»é™¤ HeaderExchangeChannel1234567--- HeaderExchangeChannel static void removeChannelIfDisconnected(Channel ch) &#123; // ch æ–­å¼€äº†è¿æ¥ï¼Œåˆ™è§£é™¤é‚¦å®šçš„ HeaderExchangeChannel å¯¹è±¡ if (ch != null &amp;&amp; !ch.isConnected()) &#123; ch.removeAttribute(CHANNEL_KEY); &#125; &#125; removeChannelIfDisconnected() æ–¹æ³•ç”¨äºè§£é™¤å¤„äºæ–­å¼€è¿æ¥çŠ¶æ€çš„ Channel ç»‘å®šçš„ HeaderExchangeChannel å¯¹è±¡ã€‚ å…³é—­12345678910111213141516171819202122232425262728293031323334353637383940414243/** * ä¼˜é›…å…³é—­ * * @param timeout */ @Override public void close(int timeout) &#123; // å¦‚æœå·²ç»å…³é—­ï¼Œå°±ç›´æ¥è¿”å› if (closed) &#123; return; &#125; // è®¾ç½®å…³é—­æ ‡è¯†ï¼Œé˜²æ­¢å‘èµ·æ–°çš„è¯·æ±‚ closed = true; // ç­‰å¾…è¯·æ±‚å®Œæˆ if (timeout &gt; 0) &#123; long start = System.currentTimeMillis(); // è¯·æ±‚å¤„ç†å®Œæˆ–è€…å…³é—­è¶…æ—¶ï¼Œåˆ™ç»“æŸ while (DefaultFuture.hasFuture(channel) &amp;&amp; System.currentTimeMillis() - start &lt; timeout) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; &#125; // å…³é—­é€šé“ close(); &#125;/** * å…³é—­é€šé“ */ @Override public void close() &#123; try &#123; // æ‰§è¡Œ channel çš„å…³é—­åŠ¨ä½œ channel.close(); &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; HeaderExchangeChannel ä¼˜é›…å…³é—­ä¸»è¦åšäº†ä¸‰ä»¶äº‹ï¼š å°†è‡ªèº«çš„å…³é—­æ ‡å¿— closed è®¾ç½®ä¸º true ï¼Œé˜²æ­¢å‘èµ·æ–°çš„è¯·æ±‚ã€‚ ç­‰å¾…å½“å‰ Channel ä¸Šçš„è¯·æ±‚è¢«å¤„ç†å®Œæˆï¼Œé™¤éè¶…æ—¶é€€å‡ºã€‚ å…³é—­è¢«è£…é¥°çš„ channel ï¼Œå³ Transport å±‚çš„ Channel ã€‚å¦‚ NettyChannel ä¼šå…ˆå°†è‡ªèº«çš„ closed å­—æ®µè®¾ç½®ä¸º true ç­‰å…¶å®ƒæ“ä½œï¼Œæœ€åæ‰ä¼šå…³é—­åº•å±‚ Netty å±‚é¢çš„ Channel ã€‚ send æ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940/** * Endpoint æ–¹æ³• * * @param message * @throws RemotingException */ @Override public void send(Object message) throws RemotingException &#123; // é»˜è®¤ä¸ç­‰å¾…æ¶ˆæ¯å‘å‡ºå°±è¿”å› send(message, getUrl().getParameter(Constants.SENT_KEY, false)); &#125; /** * Endpoint æ–¹æ³• * * @param message * @param sent true: ä¼šç­‰å¾…æ¶ˆæ¯å‘å‡ºï¼Œæ¶ˆæ¯å‘é€å¤±è´¥ä¼šæŠ›å‡ºå¼‚å¸¸ï¼› false: ä¸ç­‰å¾…æ¶ˆæ¯å‘å‡ºï¼Œå°†æ¶ˆæ¯æ”¾å…¥IOé˜Ÿåˆ—ï¼Œå³å¯è¿”å› * @throws RemotingException */ @Override public void send(Object message, boolean sent) throws RemotingException &#123; // å¦‚æœå¤„äºå…³é—­çŠ¶æ€ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ if (closed) &#123; throw new RemotingException(this.getLocalAddress(), null, \"Failed to send message \" + message + \", cause: The channel \" + this + \" is closed!\"); &#125; // å¦‚æœæ¶ˆæ¯æ˜¯ Requestã€Responseã€String ç±»å‹ï¼Œç›´æ¥äº¤ç»™ Channel.send() æ–¹æ³• if (message instanceof Request || message instanceof Response || message instanceof String) &#123; channel.send(message, sent); &#125; else &#123; // æ„å»º Request å¯¹è±¡ï¼Œå¹¶ä¸”ä¸éœ€è¦å“åº” Request request = new Request(); request.setVersion(Version.getProtocolVersion()); request.setTwoWay(false); request.setData(message); channel.send(request, sent); &#125; &#125; HeaderExchangeChannel ä¸­çš„ send() æ–¹æ³•å®ç°æ˜¯ Endpoint æ¥å£ä¸­çš„æ–¹æ³•ï¼Œè¯¥æ–¹æ³•æ¯”è¾ƒç®€å•ï¼Œæ€»ä½“ä¸Šæ˜¯ç›´æ¥å°†æ¶ˆæ¯é€šè¿‡è¢«è£…é¥°çš„ Channel å‘é€å‡ºå»ï¼Œä¸å…³å¿ƒå“åº”ç»“æœ ã€‚ request æ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * å‘é€è¯·æ±‚ * * @param request * @return * @throws RemotingException */ @Override public ResponseFuture request(Object request) throws RemotingException &#123; // è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼Œé»˜è®¤ 1000 return request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT)); &#125; /** * å‘é€è¯·æ±‚ * * @param request * @param timeout è¯·æ±‚è¶…æ—¶æ—¶é—´ * @return * @throws RemotingException */ @Override public ResponseFuture request(Object request, int timeout) throws RemotingException &#123; // å¦‚æœå·²ç»å…³é—­ï¼Œä¸èƒ½å‘èµ·è¯·æ±‚ if (closed) &#123; throw new RemotingException(this.getLocalAddress(), null, \"Failed to send request \" + request + \", cause: The channel \" + this + \" is closed!\"); &#125; // åˆ›å»ºè¯·æ±‚ï¼Œå¹¶åˆå§‹åŒ–è¯·æ±‚ç¼–å· Request req = new Request(); // Dubbo ç‰ˆæœ¬ req.setVersion(Version.getProtocolVersion()); // éœ€è¦å“åº” req.setTwoWay(true); // å…·ä½“æ•°æ® ä¸º RpcInvocation req.setData(request); // åˆ›å»ºDefaultFuture å¯¹è±¡,è¯¥å¯¹è±¡è¡¨ç¤ºæ­¤æ¬¡è¯·æ±‚-å“åº”æ˜¯å¦å®Œæˆ DefaultFuture future = new DefaultFuture(channel, req, timeout); try &#123; // ä½¿ç”¨è¢«è£…é¥°çš„ Channel å‘é€è¯·æ±‚ channel.send(req); &#125; catch (RemotingException e) &#123; // å‘é€è¯·æ±‚å¤±è´¥å°±å–æ¶ˆ DefaultFuture future.cancel(); throw e; &#125; // è¿”å› DefaultFuture å¯¹è±¡ return future; &#125; request() æ–¹æ³•éå¸¸é‡è¦ï¼Œä¸‹é¢å¯¹è¯¥æ–¹æ³•è¿›è¡Œè¯´æ˜ï¼š åˆ›å»º Request å¯¹è±¡ï¼Œåˆ›å»ºçš„è¿‡ç¨‹ä¼šåˆå§‹åŒ–ä¸€ä¸ªè¯·æ±‚ç¼–å·ï¼Œè¯¥ç¼–å·æ ‡å¿—å½“å‰è¯·æ±‚ è¯¥æ–¹æ³•éœ€è¦å“åº”ï¼Œä¹Ÿå°±æ˜¯è¯´æœåŠ¡å™¨æ”¶åˆ°è¯·æ±‚åè¦ç»™å¯¹ç«¯å‘é€å¤„ç†åçš„ç»“æœ åˆ›å»º DefaultFuture å¯¹è±¡ï¼Œè¯¥å¯¹è±¡è¡¨ç¤ºæ­¤æ¬¡è¯·æ±‚-å“åº”æ˜¯å¦å®Œæˆ è¯·æ±‚çš„å‘é€äº¤ç»™è¢«è£…é¥°çš„ Channel è¯·æ±‚å¤±è´¥å°±å–æ¶ˆ DefaultFutureï¼Œå¹¶æŠ›å‡ºå¼‚å¸¸ å‘é€è¯·æ±‚çš„ request() æ–¹æ³•ä¾èµ– DefaultFuture ï¼Œå…³å¿ƒå“åº”ç»“æœï¼Œè¿™ä¹Ÿæ˜¯å’Œ send() æ–¹æ³•æœ€å¤§çš„ä¸åŒã€‚ ç‰¹åˆ«è¯´æ˜ï¼š send() æ–¹æ³•æœ¬èº«ä¸å…³å¿ƒå“åº”ç»“æœ; request() æ–¹æ³•å…³å¿ƒå“åº”ç»“æœï¼Œæœ€ç»ˆæ˜¯é€šè¿‡ DefaultFuture å¯¹è±¡æ¥ä¼ é€’å“åº”ç»“æœã€‚ Dubbo æ”¯æŒåŒæ­¥å’Œå¼‚æ­¥ä¸¤ç§è°ƒç”¨æ–¹å¼ï¼Œé»˜è®¤ä½¿ç”¨åŒæ­¥è°ƒç”¨æ–¹å¼ï¼Œè‹¥è¦ä½¿ç”¨å¼‚æ­¥è°ƒç”¨ï¼Œéœ€è¦æœåŠ¡æ¶ˆè´¹æ–¹æ‰‹åŠ¨è¿›è¡Œé…ç½®ã€‚å…¶ä¸­å¼‚æ­¥è°ƒç”¨è¿˜å¯ç»†åˆ†ä¸ºæœ‰è¿”å›å€¼çš„å¼‚æ­¥è°ƒç”¨å’Œæ— è¿”å›å€¼çš„å¼‚æ­¥è°ƒç”¨ã€‚ Dubbo çš„åŒæ­¥è°ƒç”¨å‘é€è¯·æ±‚çš„æ–¹æ³•æ˜¯ request()ï¼›æ— è¿”å›å€¼çš„å¼‚æ­¥è°ƒç”¨å‘é€è¯·æ±‚çš„æ–¹æ³•æ˜¯ send()ï¼›æœ‰è¿”å›å€¼çš„å¼‚æ­¥è°ƒç”¨å‘é€è¯·æ±‚çš„æ–¹æ³•æ˜¯ request()ã€‚ Dubbo çš„åŒæ­¥è°ƒç”¨å’Œæœ‰è¿”å›å€¼çš„å¼‚æ­¥è°ƒç”¨éƒ½å…³å¿ƒè°ƒç”¨ç»“æœï¼Œå› æ­¤éœ€è¦ä½¿ç”¨å…³å¿ƒå“åº”ç»“æœçš„ request() æ–¹æ³•æ¥å‘é€è¯·æ±‚ã€‚è€Œæ— è¿”å›å€¼çš„å¼‚æ­¥è°ƒç”¨ä¸å…³å¿ƒè°ƒç”¨ç»“æœï¼Œä½¿ç”¨ä¸å…³å¿ƒå“åº”ç»“æœçš„ send() æ–¹æ³•å³å¯ã€‚ ç»¼ä¸Šï¼Œæ˜¯åŒæ­¥è°ƒç”¨è¿˜æ˜¯å¼‚æ­¥è°ƒç”¨ï¼Œéœ€è¦è°ƒç”¨ç»“æœè¿˜æ˜¯ä¸éœ€è¦è°ƒç”¨ç»“æœï¼Œè¿™å–å†³äº Exchange å±‚çš„ä½¿ç”¨æ–¹ã€‚request() æ–¹æ³•ä¼šè¿”å›ä¸€ä¸ª DefaultFuture å¯¹è±¡ï¼Œè¯¥å¯¹è±¡å¹¶ä¸æ˜¯è¯·æ±‚çš„ç»“æœï¼Œè€Œæ˜¯å¯¹æ­¤æ¬¡è¯·æ±‚-å“åº”çš„ç®¡ç†ã€‚è¿™æ„å‘³ç€å¯ä»¥ä» DefaultFuture å¯¹è±¡ä¸­è·å–è¯·æ±‚å¯¹åº”çš„å“åº”ä¿¡æ¯ï¼Œåªä¸è¿‡åœ¨å“åº”ç»“æœæ²¡æœ‰è¿”å›ä¹‹å‰è·å–åŠ¨ä½œä¼šå¤„äºé˜»å¡çŠ¶æ€ï¼ˆé™¤éè¶…æ—¶æˆ–ç»“æœè¿”å›ï¼‰ï¼Œå› æ­¤ï¼Œå¯¹äºåŒæ­¥è°ƒç”¨ä¸€èˆ¬æ˜¯è·å–åˆ°è¿”å›çš„ DefaultFuture å¯¹è±¡åé˜»å¡ç­‰å¾…å“åº”ç»“æœï¼Œåœ¨ç»“æœè¿”å›ä¹‹å‰ä¸ä¼šè¿›è¡Œå…¶å®ƒé€»è¾‘å¤„ç†ï¼Œå¯¹äºå¼‚æ­¥è°ƒç”¨ä¸šåŠ¡æ–¹å¯ä»¥åœ¨åˆé€‚çš„æ—¶æœºä» DefaultFuture ä¸­è·å–å“åº”ç»“æœã€‚ æœ‰å…³åŒæ­¥è°ƒç”¨å’Œå¼‚æ­¥è°ƒç”¨è¯¦ç»†ç»†èŠ‚ä¼šåœ¨åé¢çš„æ–‡ç« ä¸­è¿›è¡Œä»‹ç»ï¼Œä¸‹é¢å¯¹ Exchange å±‚çš„ DefaultFuture ç›¸å…³ä½“ç³»è¿›è¡Œè¯¦ç»†åˆ†æï¼Œå®ƒæ˜¯ Dubbo å†…éƒ¨è¿›è¡Œè°ƒç”¨è½¬æ¢çš„æ ¸å¿ƒã€‚ ResponseFuture Dubbo ä¸­çš„ Future å…³è”å…³ç³»å¦‚ä¸Šå›¾æ‰€ç¤ºï¼ŒDefaultFuture å®ç°äº† ResponseFuture æ¥å£ï¼Œrequest() æ–¹æ³•è¿”å›å€¼å°±æ˜¯ ResponseFuture ç±»å‹ï¼Œè¿™ä¹Ÿæ„å‘³ç€å¯¹äº request() æ–¹æ³•æ¥è¯´æ— è®ºæ˜¯åŒæ­¥è°ƒç”¨è¿˜æ˜¯å¼‚æ­¥è°ƒç”¨ï¼Œåªæœ‰è¿”å› ResponseFuture æ‰ç®—å‘é€æ“ä½œå®Œæˆã€‚éœ€è¦æ³¨æ„ï¼Œrequest() æ–¹æ³•å…¶å®æ˜¯åŸºäº send() æ–¹æ³•çš„ï¼Œæˆ‘ä»¬çŸ¥é“ send() æ–¹æ³•æ˜¯æ²¡æœ‰è¿”å›å€¼çš„ï¼Œå› æ­¤ request() æ–¹æ³•å¼•å…¥äº† DefaultFuture å¯¹è±¡æ¥ç®¡ç† Request å’Œ Response å…³ç³»ï¼Œä»ä¸Šé¢çš„ç»§ç»­å…³ç³»ä¸­å°±å¯ä»¥æ˜ç¡®è¿™ä¸€ç‚¹ã€‚ 12345678910111213141516171819202122232425262728293031public interface ResponseFuture &#123; /** * è·å–å“åº”ç»“æœ * * @return result. */ Object get() throws RemotingException; /** * åœ¨æŒ‡å®šçš„æ—¶é—´å†…è·å–ç»“æœ * * @param timeoutInMillis timeout. * @return result. */ Object get(int timeoutInMillis) throws RemotingException; /** * è®¾ç½®å›è°ƒ * * @param callback */ void setCallback(ResponseCallback callback); /** * æ˜¯å¦å®Œæˆ * * @return done or not. */ boolean isDone();&#125; ResponseFuture æœ‰ç‚¹ç±»ä¼¼ JDK ä¸­çš„ Future æ¥å£ï¼Œæ”¯æŒè·å–å“åº”ç»“æœã€åˆ¤æ–­å“åº”ç»“æœæ˜¯å¦è¿”å›ï¼Œå…¶ä¸­è®¾ç½®å›è°ƒæ–¹æ³• setCallback(ResponseCallback callback) ä¼šåœ¨ FutureFilter ä¸­ä½¿ç”¨ï¼Œä¸»è¦ç”¨äºå¼‚æ­¥è°ƒç”¨æƒ…å†µä¸‹çš„äº‹ä»¶é€šçŸ¥ï¼Œåœ¨åé¢çš„æ–‡ç« ä¸­ä¼šè¿›è¡Œä»‹ç»ï¼Œè¿™é‡Œä¸è¿›è¡Œå±•å¼€è¯´æ˜ã€‚ DefaultFutureDefaultFuture è¡¨ç¤ºä¸€æ¬¡è¯·æ±‚-å“åº”çš„ç»“æœï¼Œæ¯ä¸€ä¸ªè¯·æ±‚ï¼ˆé€šè¿‡request()æ–¹æ³•å‘é€çš„è¯·æ±‚ï¼‰éƒ½å¯¹åº”ä¸€ä¸ª DefaultFuture å¯¹è±¡ï¼ŒDefaultFuture åŒæ—¶ä¹Ÿæ˜¯æ‰€æœ‰ DefaultFuture çš„ç®¡ç†å®¹å™¨ã€‚éœ€è¦ç‰¹åˆ«è¯´æ˜çš„æ˜¯ï¼ŒDubbo æ¡†æ¶åº•å±‚æ•°æ®ä¼ è¾“ä½¿ç”¨çš„ NIO ç»„ä»¶å¤„ç†è¯·æ±‚ç†è®ºä¸Šæ˜¯å¼‚æ­¥çš„ï¼Œä½†æ˜¯ Dubbo æ¡†æ¶åšäº†å¼‚æ­¥è½¬åŒæ­¥çš„å¤„ç†ï¼ŒDefaultFuture åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­æ‰®æ¼”ç€é‡è¦è§’è‰²ã€‚ é™æ€å±æ€§1234567891011121314151617181920212223/** * Request ç¼–å·åˆ° Dubboé€šé“çš„æ˜ å°„ * key: è¯·æ±‚ç¼–å· * value: Dubbo æŠ½è±¡çš„é€šé“ï¼Œç”¨æ¥å‘é€è¯·æ±‚ */ private static final Map&lt;Long, Channel&gt; CHANNELS = new ConcurrentHashMap&lt;Long, Channel&gt;(); /** * Request ç¼–å·åˆ° DefaultFuture çš„æ˜ å°„ * key: è¯·æ±‚ç¼–å· * value: DefaultFuture */ private static final Map&lt;Long, DefaultFuture&gt; FUTURES = new ConcurrentHashMap&lt;Long, DefaultFuture&gt;(); /** * å¯åŠ¨æ‰«æå“åº”è¶…æ—¶ä»»åŠ¡ */ static &#123; Thread th = new Thread(new RemotingInvocationTimeoutScan(), \"DubboResponseTimeoutScanTimer\"); // å®ˆæŠ¤çº¿ç¨‹ th.setDaemon(true); th.start(); &#125; å‰é¢è¯´åˆ° DefaultFuture è‡ªèº«å°±æ˜¯ä¸ªç®¡ç†å®¹å™¨ï¼ŒåŸå› å°±åœ¨ FUTURES å±æ€§ä¸Šã€‚å½“ DefaultFuture åŠ è½½æ—¶ä¼šå¯åŠ¨æ‰«æå“åº”è¶…æ—¶ä»»åŠ¡çº¿ç¨‹ï¼Œä¸‹é¢æˆ‘ä»¬å°±æ¥çœ‹çœ‹ RemotingInvocationTimeoutScan è¿™ä¸ªä»»åŠ¡ä½“çš„é€»è¾‘ã€‚ æ‰«æè¶…æ—¶è¯·æ±‚12345678910111213141516171819202122232425262728293031323334private static class RemotingInvocationTimeoutScan implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; // éå†è¯·æ±‚å…³è”çš„ DefaultFuture é›†åˆ for (DefaultFuture future : FUTURES.values()) &#123; // å¦‚æœ future ä¸ºç©ºï¼Œæˆ–è¯·æ±‚å·²ç»å“åº”åˆ™è¿›è¡Œä¸‹ä¸€ä¸ª if (future == null || future.isDone()) &#123; continue; &#125; // è¯·æ±‚æ²¡æœ‰å“åº”ï¼Œåˆ¤æ–­æ˜¯å¦è¶…æ—¶ï¼ˆè¯·æ±‚æ—¶é—´ - è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼‰ï¼Œè¶…æ—¶å°±è¿›å…¥è¶…æ—¶å¤„ç†æµç¨‹ if (System.currentTimeMillis() - future.getStartTimestamp() &gt; future.getTimeout()) &#123; // åˆ›å»º Request å¯¹åº”çš„ è¶…æ—¶ Response å¯¹è±¡ Response timeoutResponse = new Response(future.getId()); // è®¾ç½®å“åº”çŠ¶æ€ï¼Œå¦‚æœè¯·æ±‚å·²ç»å‘é€åˆ™æ˜¯æœåŠ¡ç«¯è¶…æ—¶ï¼Œå¦åˆ™å®¢æˆ·ç«¯è¶…æ—¶ timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT); // å¼‚å¸¸ä¿¡æ¯ timeoutResponse.setErrorMessage(future.getTimeoutMessage(true)); // å“åº”ç»“æœï¼Œé¿å…å®¢æˆ·ç«¯ç­‰å¾… DefaultFuture.received(future.getChannel(), timeoutResponse); &#125; &#125; // ä¼‘çœ 30 ms Thread.sleep(30); &#125; catch (Throwable e) &#123; logger.error(\"Exception when scan the timeout invocation of remoting.\", e); &#125; &#125; &#125; &#125; Dubbo åœ¨ DefaultFuture ç±»åŠ è½½æ—¶ä¼šå¼€å¯ä¸€ä¸ªå®ˆæŠ¤çº¿ç¨‹ï¼Œè¯¥çº¿ç¨‹ç”¨äºè½®è¯¢è¯·æ±‚å…³è”çš„ DefaultFuture é›†åˆï¼ŒåŠæ—¶å¯¹è¶…æ—¶çš„è¯·æ±‚è¿›è¡Œå¼‚å¸¸ç»“æœçš„å“åº”ï¼Œå°½å¯èƒ½å‡å°‘å®¢æˆ·ç«¯çš„ç­‰å¾…æ—¶é—´ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œè¯¥ä»»åŠ¡æ˜¯å¯¹æ‰€æœ‰çš„ twoway è°ƒç”¨è¯·æ±‚è¿›è¡Œæ£€æµ‹ï¼Œä¸ç®¡æ˜¯åŒæ­¥è°ƒç”¨è¿˜æ˜¯å¼‚æ­¥è°ƒç”¨ï¼Œåªè¦è¶…æ—¶ç«‹å³ç»™è°ƒç”¨æ–¹å“åº”ä¸€ä¸ªè¶…æ—¶å¼‚å¸¸ç»“æœï¼Œåªæ˜¯ä¸€èˆ¬æƒ…å†µä¸‹å¼‚æ­¥è°ƒç”¨ä¸ä¼šç«‹åˆ»é˜»å¡ç­‰å¾…ç»“æœè€Œå·²ã€‚ å¯¹è±¡å±æ€§12345678910111213141516171819202122232425262728293031323334353637383940414243+--- DefaultFuture /** * è¯·æ±‚ */ private final Request request; /** * invoke id. è¯·æ±‚çš„ç¼–å· */ private final long id; /** * å‘é€è¯·æ±‚çš„ Channel */ private final Channel channel; /** * è¯·æ±‚-å“åº”çš„è¶…æ—¶æ—¶é—´ */ private final int timeout; /** * å½“å‰ DefaultFuture åˆ›å»ºçš„å¼€å§‹æ—¶é—´ */ private final long start = System.currentTimeMillis(); /** * è¯·æ±‚å‘é€çš„æ—¶é—´ */ private volatile long sent; /** * å“åº” */ private volatile Response response; /** * é” */ private final Lock lock = new ReentrantLock(); /** * é”çš„é€‰æ‹©å™¨ */ private final Condition done = lock.newCondition(); /** * å›è°ƒï¼Œé€‚ç”¨äºå¼‚æ­¥è¯·æ±‚ * * @see com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter */ private volatile ResponseCallback callback; å¯¹è±¡å±æ€§ä¸­çš„ Requestã€Responseã€Lock ä»¥åŠ Condition æ˜¯å®ç°å¼‚æ­¥è½¬åŒæ­¥çš„å¿…è¦å¯¹è±¡ã€‚Dubbo çš„å¼‚æ­¥è½¬åŒæ­¥æœ¬è´¨ä¸Šæ˜¯åˆ©ç”¨ç­‰å¾…é€šçŸ¥æœºåˆ¶ï¼Œç­‰åˆ°åˆ†æ HeaderExchangeHandler æ—¶è¿˜ä¼šå›è¿‡å¤´æ¥çœ‹è¿™ä¸€å—çš„ã€‚ æ„é€ æ–¹æ³•12345678910111213141516171819/** * åˆ›å»º DefaultFuture æ—¶ï¼Œä¼šæŠŠåˆ›å»ºçš„è¯¥å®ä¾‹æ”¾å…¥ FUTURES ç¼“å­˜ä¸­ * * @param channel å‘é€è¯·æ±‚çš„ Channel * @param request è¯·æ±‚ * @param timeout è¯·æ±‚-å“åº”çš„è¶…æ—¶æ—¶é—´ */public DefaultFuture(Channel channel, Request request, int timeout) &#123; this.channel = channel; this.request = request; // è®¾ç½®è¯·æ±‚idï¼Œè¿™ä¸ªidæ˜¯requestå’Œresponseæ˜ å°„çš„ä¾æ®ï¼Œéå¸¸é‡è¦ this.id = request.getId(); // è®¾ç½®è¶…æ—¶æ—¶é—´ï¼Œå¦‚æœä¼ å…¥çš„ timeout &gt; 0 å°±å–ä¼ å…¥çš„å€¼ï¼Œå¦åˆ™å– URL ä¸­timeoutçš„å€¼ï¼Œé»˜è®¤ä¸º 1000 this.timeout = timeout &gt; 0 ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT); // Request ç¼–å·åˆ° DefaultFuture çš„æ˜ å°„ï¼ŒDefaultFuture ç®¡ç†æ¯ä¸ªè¯·æ±‚å…³è”çš„DefaultFutureå¯¹è±¡ã€‚ FUTURES.put(id, this); // Request ç¼–å·åˆ° Dubboé€šé“çš„æ˜ å°„ CHANNELS.put(id, channel);&#125; åˆ›å»º DefaultFuture å¯¹è±¡æ—¶ä¼šåˆå§‹åŒ–å¯¹è±¡å±æ€§ï¼Œå…¶ä¸­ sent å’Œ response å±æ€§ä¼šåœ¨ HeaderExchangeHandler å¤„ç†æ–¹æ³•ä¸­è¿›è¡Œå€¼çš„æ›´æ–°ã€‚ Request å…³è”å±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051+--- DefaultFuture /** * è·å– request å…³è”çš„ DefaultFuture å¯¹è±¡ * * @param id è¯·æ±‚id * @return */ public static DefaultFuture getFuture(long id) &#123; return FUTURES.get(id); &#125; /** * åˆ¤æ–­é€šé“æ˜¯å¦æœ‰æœªå“åº”çš„è¯·æ±‚ * * @param channel å‘é€è¯·æ±‚çš„ Channel * @return */ public static boolean hasFuture(Channel channel) &#123; return CHANNELS.containsValue(channel); &#125; /** * å‘é€è¯·æ±‚æ—¶æ›´æ–° sent å±æ€§ã€‚ * * @param channel * @param request * @see HeaderExchangeHandler#sent(com.alibaba.dubbo.remoting.Channel, java.lang.Object) */ public static void sent(Channel channel, Request request) &#123; // è·å–è¯·æ±‚å…³è”çš„ DefaultFuture å¯¹è±¡ DefaultFuture future = FUTURES.get(request.getId()); if (future != null) &#123; future.doSent(); &#125; &#125; /** * æ›´æ–° sent å±æ€§ï¼Œè®°å½•è¯·æ±‚å‘é€æ—¶é—´æˆ³ */ private void doSent() &#123; sent = System.currentTimeMillis(); &#125; /** * åˆ¤æ–­è°ƒç”¨ç»“æœæ˜¯å¦è¿”å›ï¼Œå³åˆ¤æ–­ response å­—æ®µæ˜¯å¦ä¸ºç©º * * @return */ @Override public boolean isDone() &#123; return response != null; &#125; è·å–å“åº”ç»“æœ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Overridepublic Object get() throws RemotingException &#123; // è¶…æ—¶æ—¶é—´å– timeout çš„å€¼ return get(timeout);&#125;@Overridepublic Object get(int timeout) throws RemotingException &#123; if (timeout &lt;= 0) &#123; // é»˜è®¤ 1000 timeout = Constants.DEFAULT_TIMEOUT; &#125; // isDone()æ–¹æ³•ç”¨æ¥åˆ¤æ–­Responseæ˜¯å¦æœ‰å€¼ï¼Œå³æ˜¯å¦æœ‰è¿”å›ç»“æœ if (!isDone()) &#123; // ç­‰å¾…è¯·æ±‚ç»“æœï¼Œè®¡æ—¶å¼€å§‹ long start = System.currentTimeMillis(); lock.lock(); try &#123; // ç­‰å¾…å®Œæˆæˆ–è¶…æ—¶ while (!isDone()) &#123; // ç­‰å¾…è¯·æ±‚ç»“æœï¼Œé‡Šæ”¾é” done.await(timeout, TimeUnit.MILLISECONDS); // å¦‚æœè°ƒç”¨ç»“æœæˆåŠŸè¿”å›ï¼Œæˆ–ç­‰å¾…è¶…æ—¶ï¼Œåˆ™è·³å‡ºwhileå¾ªç¯ç»§ç»­æ‰§è¡Œåé¢é€»è¾‘ if (isDone() || System.currentTimeMillis() - start &gt; timeout) &#123; break; &#125; &#125; &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; finally &#123; // é‡Šæ”¾é” lock.unlock(); &#125; // æœªå®Œæˆï¼ŒæŠ›å‡ºè¶…æ—¶å¼‚å¸¸ if (!isDone()) &#123; throw new TimeoutException(sent &gt; 0, channel, getTimeoutMessage(false)); &#125; &#125; // è¿”å›å“åº” return returnFromResponse();&#125;/** * è¿”å›å“åº” * * @return * @throws RemotingException */private Object returnFromResponse() throws RemotingException &#123; Response res = response; if (res == null) &#123; throw new IllegalStateException(\"response cannot be null\"); &#125; // æ­£å¸¸è¿”å›ç»“æœ if (res.getStatus() == Response.OK) &#123; return res.getResult(); &#125; // è¶…æ—¶ï¼ŒæŠ›å‡ºè¶…æ—¶å¼‚å¸¸ if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123; throw new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()); &#125; throw new RemotingException(channel, res.getErrorMessage());&#125; ä¸Šé¢çš„æ–¹æ³•ç”¨äºåœ¨æŒ‡å®šçš„è¶…æ—¶æ—¶é—´å†…è·å–è¯·æ±‚çš„å“åº”ç»“æœï¼Œå¦‚æœåœ¨è¶…æ—¶æ—¶é—´å†…å“åº”ç»“æœè¿”å›åˆ™æœ¬æ¬¡è¯·æ±‚å®Œæˆï¼Œå¦åˆ™æŠ›å‡ºè¶…æ—¶å¼‚å¸¸ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨è¶…æ—¶æ—¶é—´å†…è¿”å›çš„å“åº”ç»“æœä¸ä¸€å®šæ˜¯æˆåŠŸçŠ¶æ€ï¼Œå› æ­¤åœ¨å“åº”ä¸šåŠ¡çº¿ç¨‹ç»“æœæ—¶ï¼Œåœ¨ returnFromResponse() æ–¹æ³•ä¸­éœ€è¦å¯¹å“åº”çš„çŠ¶æ€è¿›è¡Œåˆ¤æ–­ã€‚ä¸Šè¿°ä»£ç å°±æ˜¯ç­‰å¾…é€šçŸ¥æœºåˆ¶ä¸­çš„ç­‰å¾…éƒ¨åˆ†ã€‚ å“åº”ç»“æœ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * æ”¶åˆ°å“åº”ç»“æœ * * @param channel é€šé“ * @param response å“åº”ç»“æœ */public static void received(Channel channel, Response response) &#123; try &#123; // è¯·æ±‚ä¸è¿”å›ç»“æœè¿›è¡ŒåŒ¹é…ï¼ŒåŒ¹é…æˆåŠŸåˆ™ç§»é™¤å…³è”çš„DefaultFutureå¯¹è±¡ DefaultFuture future = FUTURES.remove(response.getId()); // æ¥æ”¶ç»“æœ,æ›´æ–°ç›¸å…³å­—æ®µæ ‡è¯† if (future != null) &#123; future.doReceived(response); &#125; else &#123; logger.warn(\"The timeout response finally returned at \" + (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\").format(new Date())) + \", response \" + response + (channel == null ? \"\" : \", channel: \" + channel.getLocalAddress() + \" -&gt; \" + channel.getRemoteAddress())); &#125; // æ”¶åˆ°ç»“æœåï¼Œç§»é™¤å…³è”çš„çš„ Channelï¼Œå®ƒçš„ä½¿å‘½å·²å®Œæˆ &#125; finally &#123; CHANNELS.remove(response.getId()); &#125;&#125;/** * è®¾ç½®å“åº”ç»“æœ * * @param res */private void doReceived(Response res) &#123; // åŠ é” lock.lock(); try &#123; // è®¾ç½®ç»“æœ response = res; /** * å”¤é†’ç­‰å¾…çº¿ç¨‹ &#123;@link #get()&#125;ï¼Œç„¶åæ‰§è¡Œ returnFromResponse æ–¹æ³•è¿”å›ç»“æœ */ if (done != null) &#123; done.signal(); &#125; &#125; finally &#123; // é‡Šæ”¾é” lock.unlock(); &#125; // æœ‰äº‹ä»¶å›è°ƒï¼Œå°±æ‰§è¡Œå›è°ƒé€»è¾‘ã€‚ if (callback != null) &#123; invokeCallback(callback); &#125;&#125; å½“è¯·æ±‚çš„å“åº”ç»“æœè¿”å›æ—¶ï¼Œä¼šæ‰¾åˆ°å“åº”å…³è”çš„ DefaultFuture å¯¹è±¡ï¼ˆæ ¹æ®è¯·æ±‚ç¼–å·ä»ç¼“å­˜é›†åˆä¸­æŸ¥æ‰¾ï¼‰å¹¶è°ƒç”¨ doReceived() æ–¹æ³•ï¼Œè¿›è€Œè®¾ç½®å“åº”ç»“æœ response å±æ€§çš„å€¼ã€‚ä¸Šè¿°ä»£ç å°±æ˜¯ç­‰å¾…é€šçŸ¥æœºåˆ¶ä¸­çš„é€šçŸ¥éƒ¨åˆ†ã€‚ è¿æ¥æ–­å¼€å¼‚å¸¸1234567891011121314151617181920212223242526/** * å½“ Channel æ–­å¼€è¿æ¥æ—¶ï¼Œåº”è¯¥å¯¹å…¶å…³è”çš„ request è¿›è¡Œå¼‚å¸¸ç»“æœå“åº”ï¼Œä»¥ç»“æŸé˜»å¡ç­‰å¾…çš„ä¸šåŠ¡çº¿ç¨‹ã€‚ * * @param channel channel to close */public static void closeChannel(Channel channel) &#123; for (long id : CHANNELS.keySet()) &#123; // å–å‡ºæ–­å¼€è¿æ¥çš„Channelå…³è”çš„Requestå¯¹åº”çš„ DefaultFuture if (channel.equals(CHANNELS.get(id))) &#123; DefaultFuture future = getFuture(id); // å¦‚æœè¯·æ±‚ç»“æœè¿˜æ²¡æœ‰è¿”å›ï¼Œåˆ™è¿”å›å¼‚å¸¸çŠ¶æ€çš„ç»“æœ if (future != null &amp;&amp; !future.isDone()) &#123; // æ„é€ å“åº” Response ï¼Œæ³¨æ„å“åº”ç¼–å·ã€‚ Response disconnectResponse = new Response(future.getId()); disconnectResponse.setStatus(Response.CHANNEL_INACTIVE); disconnectResponse.setErrorMessage(\"Channel \" + channel + \" is inactive. Directly return the unFinished request : \" + future.getRequest()); // è®¾ç½®å“åº”ç»“æœ response DefaultFuture.received(channel, disconnectResponse); &#125; &#125; &#125;&#125; closeChannel() æ–¹æ³•æ¯”è¾ƒç®€å•ï¼Œç”¨äºå¤„ç†è¿æ¥æ–­å¼€æ— æ³•æ­£å¸¸å“åº”ç»“æœç»™ä¸šåŠ¡çº¿ç¨‹çš„æƒ…å†µï¼Œå’Œå‰æ–‡çš„æ‰«æè¶…æ—¶ä»»åŠ¡ RemotingInvocationTimeoutScan ä¸€è‡´ï¼Œé˜²æ­¢ä¸šåŠ¡çº¿ç¨‹å‚»ç­‰è¯·æ±‚ç»“æœã€‚ å–æ¶ˆ DefaultFuture12345678910111213+---- DefaultFuture /** * ç§»é™¤å½“å‰è¯·æ±‚å…³è”çš„ Channelã€DefaultFuture */ public void cancel() &#123; // åˆ›å»ºå“åº”ç»“æœå¯¹è±¡ Response errorResult = new Response(id); errorResult.setErrorMessage(\"request future has been canceled.\"); response = errorResult; // ç§»é™¤è¯·æ±‚å…³è”çš„ DefaultFutureï¼ŒChannel FUTURES.remove(id); CHANNELS.remove(id); &#125; ç”¨äºå‘é€è¯·æ±‚å¤±è´¥çš„æƒ…å†µï¼Œç”±äºå‘é€è¯·æ±‚ä¹‹å‰è¯·æ±‚å…³è”äº† DefaultFuture å’Œ Channel ï¼Œå› æ­¤éœ€è¦ç§»é™¤è¯¥è¯·æ±‚å…³è”çš„å¯¹è±¡ã€‚æ­¤å¤–ï¼Œåˆ›å»ºä¸€ä¸ªå¼‚å¸¸ç»“æœï¼Œé˜²æ­¢æœ‰ä¸šåŠ¡çº¿ç¨‹è¿˜åœ¨å‚»å‚»åœ°ç­‰å¾…è¯·æ±‚ç»“æœã€‚ è®¾ç½®å›è°ƒ12345678910111213141516171819202122232425262728293031+--- DefaultFuture /** * è®¾ç½®å›è°ƒ * * @param callback * @see com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter#asyncCallback(com.alibaba.dubbo.rpc.Invoker, com.alibaba.dubbo.rpc.Invocation) */ @Override public void setCallback(ResponseCallback callback) &#123; // å¦‚æœæœ‰å“åº”åˆ™ç«‹å³æ‰§è¡Œå›è°ƒ if (isDone()) &#123; invokeCallback(callback); &#125; else &#123; boolean isdone = false; lock.lock(); try &#123; // å¦‚æœæ²¡æœ‰å“åº”ï¼Œåˆ™å…ˆä¿å­˜å›è°ƒï¼Œæ”¶åˆ°ç»“æœå†æ‰§è¡Œå›è°ƒé€»è¾‘ if (!isDone()) &#123; this.callback = callback; &#125; else &#123; isdone = true; &#125; &#125; finally &#123; lock.unlock(); &#125; // å†å°è¯•ä¸€æ¬¡ if (isdone) &#123; invokeCallback(callback); &#125; &#125; &#125; è®¾ç½®å›è°ƒæ˜¯ FutureFilter å¤„ç†å¼‚æ­¥è°ƒç”¨æ—¶ä½¿ç”¨çš„ï¼Œç›®çš„æ˜¯åœ¨è¿”å›è°ƒç”¨ç»“æœæ—¶æ‰§è¡Œäº‹ä»¶å›è°ƒã€‚ æ‰§è¡Œå›è°ƒ123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * æ‰§è¡Œå›è°ƒé€»è¾‘ * * @param c */ private void invokeCallback(ResponseCallback c) &#123; ResponseCallback callbackCopy = c; if (callbackCopy == null) &#123; throw new NullPointerException(\"callback cannot be null.\"); &#125; Response res = response; if (res == null) &#123; throw new IllegalStateException(\"response cannot be null. url:\" + channel.getUrl()); &#125; // æ­£å¸¸å“åº” if (res.getStatus() == Response.OK) &#123; try &#123; // æ‰§è¡Œå›è°ƒ - å¤„ç†æ‰§è¡Œç»“æœ callbackCopy.done(res.getResult()); &#125; catch (Exception e) &#123; logger.error(\"callback invoke error .reasult:\" + res.getResult() + \",url:\" + channel.getUrl(), e); &#125; // è¶…æ—¶å¤„ç† TimeoutException å¼‚å¸¸ &#125; else if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123; try &#123; TimeoutException te = new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()); // æ‰§è¡Œå›è°ƒ - å¤„ç† TimeoutException å¼‚å¸¸ callbackCopy.caught(te); &#125; catch (Exception e) &#123; logger.error(\"callback invoke error ,url:\" + channel.getUrl(), e); &#125; // å¤„ç†å…¶ä»–å¼‚å¸¸ &#125; else &#123; try &#123; RuntimeException re = new RuntimeException(res.getErrorMessage()); // æ‰§è¡Œå›è°ƒ - å¤„ç†RuntimeException callbackCopy.caught(re); &#125; catch (Exception e) &#123; logger.error(\"callback invoke error ,url:\" + channel.getUrl(), e); &#125; &#125; &#125; åœ¨è®¾ç½®å“åº”ç»“æœåï¼Œå¦‚æœè®¾ç½®äº†äº‹ä»¶å›è°ƒåˆ™æ‰§è¡Œå›è°ƒé€»è¾‘ã€‚ å¤„ç†å™¨Exchange å±‚é€šé“å¤„ç†å™¨ç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š åœ¨ Transport å±‚å·²ç»ä»‹ç»äº†å¤§é‡ ChannelHandlerï¼Œç‰¹åˆ«æ˜¯ ChannelHandlerDelegate ç±»å‹çš„ ChannelHandler ï¼Œå®ƒä»¬å±äºå¤„ç†å™¨è£…é¥°è€…æ¥å£ï¼Œåœ¨ Exchange å±‚æ–°å®šä¹‰äº†ä¸¤ä¸ªè¯¥ç±»å‹çš„å¤„ç†å™¨ HeartbeatHandler å’Œ HeaderExchangeHandlerã€‚æ­¤å¤–ï¼ŒExchange å±‚è¿˜å®šä¹‰äº†ä¸€ä¸ªä¾›ä¸Šå±‚ä½¿ç”¨çš„ ExchangeHandler æ¥å£åŠå…¶æŠ½è±¡å®ç°ç±» ExchangeHandlerAdapterã€‚æ— è®ºæ˜¯å‘é€è¯·æ±‚è¿˜æ˜¯å¤„ç†å“åº”éƒ½ä¼šæ¶‰åŠåˆ° ChannelHandlerã€‚ HeartbeatHandlerä¸“é—¨å¤„ç†å¿ƒè·³æ¶ˆæ¯çš„ ChannelHandler å®ç°ï¼ŒåŒæ ·æ˜¯åœ¨åŸæœ‰çš„ ChannelHandler çš„åŸºç¡€ä¸Šæ·»åŠ ä¸€äº›åŠŸèƒ½ã€‚ å±æ€§12345678910111213141516171819202122public class HeartbeatHandler extends AbstractChannelHandlerDelegate &#123; private static final Logger logger = LoggerFactory.getLogger(HeartbeatHandler.class); /** * è®¾ç½®Channelçš„è¯»æ—¶é—´æˆ³ çš„ key */ public static String KEY_READ_TIMESTAMP = \"READ_TIMESTAMP\"; /** * è®¾ç½®Channelçš„å†™æ—¶é—´æˆ³ çš„ key */ public static String KEY_WRITE_TIMESTAMP = \"WRITE_TIMESTAMP\"; /** * è£…é¥° ChannelHandler * * @param handler */ public HeartbeatHandler(ChannelHandler handler) &#123; super(handler); &#125;&#125; è¾…åŠ©æ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * è®¾ç½® Channel è¯»æ—¶é—´æˆ³ * * @param channel */ private void setReadTimestamp(Channel channel) &#123; channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis()); &#125; /** * è®¾ç½® Channel å†™æ—¶é—´æˆ³ * * @param channel */ private void setWriteTimestamp(Channel channel) &#123; channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis()); &#125; /** * æ¸…ç† Channel ä¸­è¯»æ—¶é—´æˆ³ * * @param channel */ private void clearReadTimestamp(Channel channel) &#123; channel.removeAttribute(KEY_READ_TIMESTAMP); &#125; /** * æ¸…ç† Channel ä¸­å†™æ—¶é—´æˆ³ * * @param channel */ private void clearWriteTimestamp(Channel channel) &#123; channel.removeAttribute(KEY_WRITE_TIMESTAMP); &#125; /** * æ˜¯å¦æ˜¯å¿ƒè·³è¯·æ±‚ * * @param message * @return */ private boolean isHeartbeatRequest(Object message) &#123; return message instanceof Request &amp;&amp; ((Request) message).isHeartbeat(); &#125; /** * æ˜¯å¦æ˜¯å¿ƒè·³å“åº” * * @param message * @return */ private boolean isHeartbeatResponse(Object message) &#123; return message instanceof Response &amp;&amp; ((Response) message).isHeartbeat(); &#125; è¿æ¥å»ºç«‹12345678910111213/** * è¿æ¥å®Œæˆæ—¶ï¼Œè®¾ç½®é€šé“çš„æœ€åè¯»å†™æ—¶é—´ * * @param channel * @throws RemotingException */@Overridepublic void connected(Channel channel) throws RemotingException &#123; setReadTimestamp(channel); setWriteTimestamp(channel); // è®¾ç½®æœ€åè¯»å†™æ—¶é—´åï¼Œä¼ é€’ç»™åº•å±‚çš„ ChannelHandler å¯¹è±¡è¿›è¡Œå¤„ç† handler.connected(channel);&#125; HeartbeatHandler å¤„ç†è¿æ¥å»ºç«‹åªæ˜¯è®°å½•äº†é€šé“çš„æœ€åè¯»å†™æ—¶é—´ã€‚ è¿æ¥æ–­å¼€12345678910111213/** * è¿æ¥æ–­å¼€æ—¶ï¼Œæ¸…ç©ºé€šé“çš„æœ€åè¯»å†™æ—¶é—´ * * @param channel * @throws RemotingException */@Overridepublic void disconnected(Channel channel) throws RemotingException &#123; clearReadTimestamp(channel); clearWriteTimestamp(channel); // æ¸…ç†è¯»å†™æ—¶é—´åï¼Œä¼ é€’ç»™åº•å±‚çš„ ChannelHandler å¯¹è±¡è¿›è¡Œå¤„ç† handler.disconnected(channel);&#125; HeartbeatHandler å¤„ç†è¿æ¥æ–­å¼€åªæ˜¯æ¸…ç†äº†æœ€åè¯»å†™æ—¶é—´ã€‚ å‘é€æ¶ˆæ¯12345678910111213/** * å‘é€æ¶ˆæ¯åï¼Œè®¾ç½®æœ€åå†™çš„æ—¶é—´ * * @param channel * @param message * @throws RemotingException */ @Override public void sent(Channel channel, Object message) throws RemotingException &#123; setWriteTimestamp(channel); // è®°å½•æœ€åå†™æ—¶é—´åï¼Œä¼ é€’ç»™åº•å±‚çš„ ChannelHandler å¯¹è±¡è¿›è¡Œå¤„ç† handler.sent(channel, message); &#125; HeartbeatHandler å¤„ç†å‘é€æ¶ˆæ¯åªæ˜¯è®°å½•äº†æœ€åçš„å†™æ—¶é—´ï¼Œç„¶åä¼ é€’ç»™åº•å±‚çš„ ChannelHandler å¯¹è±¡ç»§ç»­å¤„ç†ã€‚ æ¥æ”¶æ¶ˆæ¯1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * æ”¶åˆ°æ¶ˆæ¯ï¼Œè®¾ç½®æœ€åè¯»æ—¶é—´ * 1. æ”¶åˆ°å¿ƒè·³è¯·æ±‚çš„æ—¶å€™ï¼Œä¼šç”Ÿæˆç›¸åº”çš„å¿ƒè·³å“åº”å¹¶è¿”å›ï¼› * 2. æ”¶åˆ°å¿ƒè·³å“åº”çš„æ—¶å€™ï¼Œä¼šæ‰“å°ç›¸åº”çš„æ—¥å¿—ï¼› * 3. åœ¨æ”¶åˆ°å…¶ä»–ç±»å‹çš„æ¶ˆæ¯æ—¶ï¼Œä¼šä¼ é€’ç»™åº•å±‚çš„ ChannelHandler å¯¹è±¡è¿›è¡Œå¤„ç† * * @param channel * @param message * @throws RemotingException */ @Override public void received(Channel channel, Object message) throws RemotingException &#123; // 1 è®¾ç½®æœ€åè¯»æ—¶é—´ setReadTimestamp(channel); // 2 æ”¶åˆ°å¿ƒè·³è¯·æ±‚ï¼Œåˆ™ç”Ÿæˆå¯¹åº”çš„å¿ƒè·³å“åº”å¹¶è¿”å› if (isHeartbeatRequest(message)) &#123; Request req = (Request) message; // éœ€è¦å“åº” if (req.isTwoWay()) &#123; // è®¾ç½®è¯·æ±‚idï¼Œä¸ºäº†å’Œè¯·æ±‚ä¸€ä¸€å¯¹åº” Response res = new Response(req.getId(), req.getVersion()); // å¿ƒè·³äº‹ä»¶ res.setEvent(Response.HEARTBEAT_EVENT); // å¿ƒè·³å“åº” channel.send(res); if (logger.isInfoEnabled()) &#123; int heartbeat = channel.getUrl().getParameter(Constants.HEARTBEAT_KEY, 0); if (logger.isDebugEnabled()) &#123; logger.debug(\"Received heartbeat from remote channel \" + channel.getRemoteAddress() + \", cause: The channel has no data-transmission exceeds a heartbeat period\" + (heartbeat &gt; 0 ? \": \" + heartbeat + \"ms\" : \"\")); &#125; &#125; &#125; return; &#125; // 3 æ”¶åˆ°å¿ƒè·³å“åº”ï¼Œåˆ™æ‰“å°æ—¥å¿— if (isHeartbeatResponse(message)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Receive heartbeat response in thread \" + Thread.currentThread().getName()); &#125; return; &#125; // 4 å…¶å®ƒç±»å‹æ¶ˆæ¯ï¼Œåˆ™ä¼ é€’ç»™åº•å±‚çš„ ChannelHandler å¯¹è±¡è¿›è¡Œå¤„ç† handler.received(channel, message); &#125; HeartbeatHandler åœ¨å¤„ç†æ¥æ”¶æ¶ˆæ¯æ—¶æœ‰å‡ ä¸ªç‚¹éœ€è¦æ³¨æ„ï¼š æ”¶åˆ°æ¶ˆæ¯ä¼šè®°å½•æœ€åè¯»çš„æ—¶é—´ã€‚ å¦‚æœæ”¶åˆ°çš„æ˜¯å¿ƒè·³è¯·æ±‚æ¶ˆæ¯ï¼Œåˆ™ç”Ÿæˆè¯¥è¯·æ±‚çš„å“åº”å¹¶è¿”å›ç»™ä¸šåŠ¡çº¿ç¨‹ï¼Œä¸ä¼šå†å¾€ä¸‹ä¼ é€’å³HeartbeatHandleråé¢çš„ChannelHandleræ²¡æœ‰æœºä¼šå¤„ç†è¿™ä¸ªæ¶ˆæ¯ã€‚ å¦‚æœæ”¶åˆ°çš„æ˜¯å¿ƒè·³å“åº”æ¶ˆæ¯ï¼Œåˆ™æ‰“å°æ—¥å¿—å³å¯ï¼ŒåŒæ ·ä¸ä¼šå†å¾€ä¸‹ä¼ é€’å³HeartbeatHandleråé¢çš„ChannelHandleræ²¡æœ‰æœºä¼šå¤„ç†è¿™ä¸ªæ¶ˆæ¯ã€‚ å¦‚æœä¸æ˜¯ 2ã€3 æ­¥çš„æƒ…å†µï¼Œåˆ™ç›´æ¥ä¼ é€’ç»™åº•å±‚çš„ ChannelHandler å¯¹è±¡è¿›è¡Œå¤„ç†ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒHeartbeatHandler å®šä¹‰åœ¨ Exchange å±‚ï¼Œä½†æ˜¯ä½¿ç”¨æ˜¯åœ¨ transport å±‚ï¼Œå…·ä½“ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415/** * æ— è®ºæ˜¯Clientè¿˜æ˜¯Serverï¼Œåœ¨æ„é€ æ–¹æ³•ä¸­éƒ½ä¼šå°†ä¼ å…¥çš„ChannelHandlerè¿›è¡ŒåŒ…è£…ï¼Œä¸ºè¯¥ ChannelHandler å¢åŠ äº† Dubbo æ¶ˆæ¯æ´¾å‘ã€å¿ƒè·³å¤„ç†ä»¥åŠå¤šæ¶ˆæ¯å¤„ç†çš„åŠŸèƒ½ã€‚ * @param handler * @param url * @return */ protected ChannelHandler wrapInternal(ChannelHandler handler, URL url) &#123; return new MultiMessageHandler( // å¤šæ¶ˆæ¯å¤„ç† new HeartbeatHandler( // å¿ƒè·³å¤„ç† ExtensionLoader.getExtensionLoader(Dispatcher.class) .getAdaptiveExtension() .dispatch(handler, url) // è¿”å›çš„æ˜¯ä¸€ä¸ª ChannelHandlerDelegate ç±»å‹çš„å¯¹è±¡ï¼Œé»˜è®¤æ˜¯ AllChannelHandlerï¼Œç¡®å®šäº†å…·ä½“çš„çº¿ç¨‹æ¨¡å‹ ) ); &#125; HeaderExchangeHandlerHeaderExchangeHandler æ˜¯ä¸€ä¸ªè£…é¥°è€…ç±»å‹çš„ ChannelHandlerï¼Œå†…éƒ¨å°è£…äº† ExchangeHandler å¯¹è±¡ï¼Œè€Œ ExchangeHandler æ˜¯ä¸Šå±‚ä¸ Exchange å±‚äº¤äº’çš„é‡è¦æ¥å£ï¼Œä¸Šå±‚è°ƒç”¨æ–¹å¯ä»¥å®ç°è¯¥æ¥å£å®Œæˆç‰¹å®šåŠŸèƒ½ã€‚ç»è¿‡ HeaderExchangeHandler è£…é¥°çš„ ExchangeHandler å¯¹è±¡å…·å¤‡ Exchange å±‚å¤„ç†è¯·æ±‚å’Œå“åº”çš„èƒ½åŠ›ï¼Œæœ€åå†ç»è¿‡ Transport å±‚çš„ ChannelHandler è£…é¥°è€Œå…·å¤‡ Transport å±‚å¤„ç†æ¶ˆæ¯çš„èƒ½åŠ›ã€‚è£…é¥°æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š HeaderExchangeHandler ä½œä¸ºä¸€ä¸ªè£…é¥°å™¨ï¼Œå…¶ å¯¹ Channel ä¸­çš„é€»è¾‘å¤„ç†æœ€ç»ˆéƒ½ä¼šå§”æ‰˜ç»™è¢«è£…é¥°çš„å¯¹è±¡å³ä¸Šå±‚æä¾›çš„ ExchangeHandler è¿›è¡Œå¤„ç†ï¼ŒHeaderExchangeHandler æœ¬èº«å…³æ³¨ç‚¹åœ¨äºå¯¹ Request å’Œ Response çš„å¤„ç†é€»è¾‘ã€‚ ä¸‹é¢åˆ†æ HeaderExchangeHandler å¯¹ Channel ä¸­çš„é€»è¾‘å¤„ç†ã€‚ å±æ€§123456789101112131415161718192021222324252627282930public class HeaderExchangeHandler implements ChannelHandlerDelegate &#123; protected static final Logger logger = LoggerFactory.getLogger(HeaderExchangeHandler.class); /** * è®¾ç½®Channelçš„è¯»æ—¶é—´æˆ³ çš„ key */ public static String KEY_READ_TIMESTAMP = HeartbeatHandler.KEY_READ_TIMESTAMP; /** * è®¾ç½®Channelçš„å†™æ—¶é—´æˆ³ çš„ key */ public static String KEY_WRITE_TIMESTAMP = HeartbeatHandler.KEY_WRITE_TIMESTAMP; /** * è¢«è£…é¥°çš„ ChannelHandler,ç”±ä¸Šå±‚ä¼ å…¥ */ private final ExchangeHandler handler; /** * æ„é€ æ–¹æ³• * * @param handler */ public HeaderExchangeHandler(ExchangeHandler handler) &#123; if (handler == null) &#123; throw new IllegalArgumentException(\"handler == null\"); &#125; this.handler = handler; &#125;&#125; HeaderExchangeHandler å®ç°äº† ChannelHandlerDelegate æ¥å£ï¼ŒåŸºäºæ¶ˆæ¯å¤´éƒ¨çš„ä¿¡æ¯äº¤æ¢å¤„ç†å™¨å®ç°ç±»ã€‚ è·å–è¢«è£…é¥°çš„ ChannelHandler1234567891011121314/** * è·å–è¢«è£…é¥°çš„ ChannelHandler * * @return */ @Override public ChannelHandler getHandler() &#123; // å¦‚æœè¢«è£…é¥°çš„ ChannelHandler å±äºè£…é¥°è€…ç±»å‹å°±è·å–å…¶è£…é¥°çš„ handler if (handler instanceof ChannelHandlerDelegate) &#123; return ((ChannelHandlerDelegate) handler).getHandler(); &#125; else &#123; return handler; &#125; &#125; è¿æ¥å»ºç«‹12345678910111213141516171819202122/** * å¯¹è¿æ¥å»ºç«‹çš„å¤„ç† * * @param channel åº•å±‚çš„ Dubbo Channel * @throws RemotingException */ @Override public void connected(Channel channel) throws RemotingException &#123; // 1. è®¾ç½®è¯»å†™æ—¶é—´æˆ³ channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis()); channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis()); // 2. åˆ›å»º channel ç›¸åº”çš„ HeaderExchangeChannel å¹¶å°†ä¸¤è€…ç»‘å®š. ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel); try &#123; // 3. é€šçŸ¥ä¸Šå±‚ ExchangeHandler å¤„ç† connect äº‹ä»¶ handler.connected(exchangeChannel); &#125; finally &#123; // 4. è‹¥channelå·²ç»æ–­å¼€ï¼Œåˆ™ è§£ç»‘ channel ä¸ HeaderExchangeChannel çš„è”ç³» HeaderExchangeChannel.removeChannelIfDisconnected(channel); &#125; &#125; è¿æ¥æ–­å¼€12345678910111213141516171819202122232425262728/** * å¯¹è¿æ¥æ–­å¼€çš„å¤„ç† * * @param channel channel. * @throws RemotingException */@Overridepublic void disconnected(Channel channel) throws RemotingException &#123; // 1. è®¾ç½®è¯»å†™æ—¶é—´æˆ³ channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis()); channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis()); // 2. åˆ›å»º channel ç›¸åº”çš„ HeaderExchangeChannel å¹¶å°†ä¸¤è€…ç»‘å®š. ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel); try &#123; // 3. é€šçŸ¥ä¸Šå±‚ ExchangeHandler å¤„ç† disconnect handler.disconnected(exchangeChannel); &#125; finally &#123; // 4. è°ƒç”¨ DefaultFuture.closeChannel æ–¹æ³•é€šçŸ¥ DefaultFuture è¿æ¥æ–­å¼€äº†ï¼Œé¿å…è¿æ¥æ–­å¼€äº†è¿˜åœ¨é˜»å¡ä¸šåŠ¡çº¿ç¨‹ã€‚ // DefaultFuture æ¥åˆ°è¿æ¥æ–­å¼€é€šçŸ¥åä¼šå…ˆè·å–è¿æ¥å¯¹åº”çš„è¯·æ±‚ï¼Œå†é€šè¿‡è¯·æ±‚æ‰¾åˆ°å…³è”çš„ DefaultFutureï¼Œåˆ¤æ–­è¯¥è¯·æ±‚æ˜¯å¦å“åº”ï¼Œæ²¡æœ‰å“åº”å°±åˆ›å»ºä¸€ä¸ªçŠ¶æ€ç ä¸º CHANNEL_INACTIVE çš„ Response å¹¶è®¾ç½®åˆ°ç»“æœå±æ€§ã€‚ DefaultFuture.closeChannel(channel); // 5. è§£ç»‘ channel ä¸ HeaderExchangeChannel çš„è”ç³» HeaderExchangeChannel.removeChannelIfDisconnected(channel); &#125;&#125; å‘é€æ¶ˆæ¯12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * å¤„ç†å‘é€çš„æ•°æ® * * @param channel åº•å±‚çš„ Dubbo Channel * @param message å¯èƒ½æ˜¯è¯·æ±‚/å“åº” æ¶ˆæ¯ * @throws RemotingException */@Overridepublic void sent(Channel channel, Object message) throws RemotingException &#123; Throwable exception = null; try &#123; // 1. è®¾ç½®å†™æ—¶é—´ channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis()); // 2. åˆ›å»º channel ç›¸åº”çš„ HeaderExchangeChannel å¹¶å°†ä¸¤è€…ç»‘å®š. ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel); try &#123; // 3. é€šçŸ¥ä¸Šå±‚ ExchangeHandler å®ç°çš„ sent() æ–¹æ³• handler.sent(exchangeChannel, message); &#125; finally &#123; // 4. è‹¥channelå·²ç»æ–­å¼€ï¼Œåˆ™ è§£ç»‘ channel ä¸ HeaderExchangeChannel çš„è”ç³» HeaderExchangeChannel.removeChannelIfDisconnected(channel); &#125; // ä¸Šå±‚ ExchangeHandler å®ç°çš„ sent() æ–¹æ³• æ‰§è¡Œå¼‚å¸¸ &#125; catch (Throwable t) &#123; exception = t; &#125; // 5. å¦‚æœæ˜¯è¯·æ±‚ï¼Œåˆ™è°ƒç”¨ DefaultFuture.sent() æ–¹æ³•æ›´æ–°è¯·æ±‚çš„å…·ä½“å‘é€æ—¶é—´ if (message instanceof Request) &#123; Request request = (Request) message; DefaultFuture.sent(channel, request); &#125; // 6. å¦‚æœå‘é€æ¶ˆæ¯å‡ºç°å¼‚å¸¸ï¼Œåˆ™è¿›è¡Œå¤„ç† if (exception != null) &#123; if (exception instanceof RuntimeException) &#123; throw (RuntimeException) exception; &#125; else if (exception instanceof RemotingException) &#123; throw (RemotingException) exception; &#125; else &#123; throw new RemotingException(channel.getLocalAddress(), channel.getRemoteAddress(), exception.getMessage(), exception); &#125; &#125;&#125; åœ¨ HeaderExchangeChannel.request() æ–¹æ³•ä¸­åˆ›å»ºäº† DefaultFuture å¯¹è±¡ï¼Œç„¶åå°†è¯·æ±‚é€šè¿‡è£…é¥°çš„ Dubbo Channel å‘é€å‡ºå»ã€‚è¯·æ±‚ä¼šé€šè¿‡ Channel è¿›è¡Œä¼ è¾“ï¼Œåœ¨ä¼ è¾“çš„è¿‡ç¨‹ä¸­ä¼šè§¦å‘æ²¿é€”çš„ ChannelHandler.sent() ç­‰æ–¹æ³•ï¼ŒHeaderExchangeHandler çš„ sent() å¤„ç†é€»è¾‘åŒ…æ‹¬è°ƒç”¨ DefaultFuture.sent() æ–¹æ³•æ›´æ–° DefaultFuture ä¸­çš„ sent çš„å€¼å³æ›´æ–°è¯·æ±‚å‘é€æ—¶é—´ã€‚ å¼‚å¸¸å¤„ç†123456789101112131415161718192021222324252627282930313233343536373839/** * æ•è·åˆ°å¼‚å¸¸ * * @param channel åº•å±‚çš„ Dubbo Channel * @param exception exception. * @throws RemotingException */ @Override public void caught(Channel channel, Throwable exception) throws RemotingException &#123; // 1. å½“å‘ç”Ÿ ExecutionException å¼‚å¸¸ï¼ˆçº¿ç¨‹æ± å¤„ç†ä»»åŠ¡å¼‚å¸¸ï¼‰ if (exception instanceof ExecutionException) &#123; ExecutionException e = (ExecutionException) exception; Object msg = e.getRequest(); // 1.1 è¯·æ±‚æ¶ˆæ¯ if (msg instanceof Request) &#123; Request req = (Request) msg; // 1.2 å¦‚æœå½“å‰è¯·æ±‚éœ€è¦å“åº”ä¸”éå¿ƒè·³è¯·æ±‚ï¼Œåˆ™å‘é€å¼‚å¸¸å¤„ç†ç»“æœç»™è°ƒç”¨æ–¹ if (req.isTwoWay() &amp;&amp; !req.isHeartbeat()) &#123; // å‘é€çŠ¶æ€ç ä¸º SERVER_ERROR çš„å“åº” Response res = new Response(req.getId(), req.getVersion()); res.setStatus(Response.SERVER_ERROR); res.setErrorMessage(StringUtils.toString(e)); channel.send(res); return; &#125; &#125; &#125; // 2. éçº¿ç¨‹æ± å¤„ç†å¼‚å¸¸æ—¶ï¼Œå°†å¼‚å¸¸äº¤ç»™ä¸Šå±‚ Handler å¤„ç† ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel); try &#123; // 3. é€šçŸ¥ä¸Šå±‚ ExchangeHandler å®ç°çš„ caught() æ–¹æ³• handler.caught(exchangeChannel, exception); &#125; finally &#123; // 4. è‹¥channelå·²ç»æ–­å¼€ï¼Œåˆ™ è§£ç»‘ channel ä¸ HeaderExchangeChannel çš„è”ç³» HeaderExchangeChannel.removeChannelIfDisconnected(channel); &#125; &#125; HeaderExchangeHandler å±äº Dubbo çš„ ChannelHandler é“¾çš„ä¸€éƒ¨åˆ†ï¼Œå¹¶ä¸”æ˜¯ Transport å±‚ ChannelHandler è£…é¥°çš„å¯¹è±¡ï¼ŒTransport å±‚å®ç°äº† Dubbo çš„çº¿ç¨‹æ¨¡å‹ï¼Œä½†æ˜¯çº¿ç¨‹æ± æ‰§è¡Œæ—¶å¯èƒ½ä¼šå‘ç”Ÿå¼‚å¸¸ï¼Œè€Œè¿™ä¸ªå¼‚å¸¸ç±»å‹å°±æ˜¯ ExecutionException ã€‚ å¦‚æœçº¿ç¨‹æ± æ‰§è¡Œä»»åŠ¡å‘ç”Ÿå¼‚å¸¸å°±ä¼šæŠ›å‡ºè¯¥å¼‚å¸¸ï¼ŒHeaderExchangeHandler æœ€åä¼šæ•è·åˆ°è¯¥å¼‚å¸¸ã€‚å¼‚å¸¸å…·ä½“ä½ç½®å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ¥æ”¶æ¶ˆæ¯12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * æ¥æ”¶æ¶ˆæ¯ * * @param channel åº•å±‚çš„ Dubbo Channel * @param message message æ¶ˆæ¯ * @throws RemotingException */ @Override public void received(Channel channel, Object message) throws RemotingException &#123; // 1. è®¾ç½®æœ€åçš„è¯»æ—¶é—´ channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis()); // 2. åˆ›å»º channel ç›¸åº”çš„ HeaderExchangeChannel å¹¶å°†ä¸¤è€…ç»‘å®š. ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel); // 3. å¯¹æ”¶åˆ°çš„æ¶ˆæ¯åˆ†ç±» try &#123; // 3.1 å¤„ç†è¯·æ±‚æ¶ˆæ¯ if (message instanceof Request) &#123; Request request = (Request) message; // 3.1.1 åªè¯»è¯·æ±‚ if (request.isEvent()) &#123; // åœ¨Channelä¸Šè®¾ç½®'channel.readonly' æ ‡å¿—ï¼Œç„¶åå¾€ä¸‹ä¼ å³å¯ã€‚ handlerEvent(channel, request); // å¤„ç†æ™®é€šè¯·æ±‚ &#125; else &#123; // 3.1.2 éœ€è¦å“åº”ï¼Œè¦å°†å“åº”å†™å›è¯·æ±‚æ–¹ if (request.isTwoWay()) &#123; // å¤„ç†è¯·æ±‚ Response response = handleRequest(exchangeChannel, request); // å°†è°ƒç”¨ç»“æœè¿”å›ç»™æœåŠ¡æ¶ˆè´¹ç«¯ channel.send(response); // 3.1.3 ä¸éœ€è¦å“åº”ï¼Œç›´æ¥äº¤ç»™ä¸Šå±‚å®ç°çš„ ExchangeHandler è¿›è¡Œå¤„ç† &#125; else &#123; handler.received(exchangeChannel, request.getData()); &#125; &#125; // 3.2 å¤„ç†å“åº”å“åº”æ¶ˆæ¯ &#125; else if (message instanceof Response) &#123; // å°†å…³è”çš„ DefaultFuture è®¾ç½®ä¸ºå®ŒæˆçŠ¶æ€ï¼ˆæˆ–æ˜¯å¼‚å¸¸å®ŒæˆçŠ¶æ€ï¼‰ handleResponse(channel, (Response) message); // 3.3 å¤„ç†Stringç±»å‹çš„æ¶ˆæ¯ï¼Œæ ¹æ®å½“å‰æœåŠ¡çš„è§’è‰²è¿›è¡Œåˆ†ç±»å¤„ç† &#125; else if (message instanceof String) &#123; // 3.3.1 å®¢æˆ·ç«¯ä¾§ ä¸æ”¯æŒString if (isClientSide(channel)) &#123; Exception e = new Exception(\"Dubbo client can not supported string message: \" + message + \" in channel: \" + channel + \", url: \" + channel.getUrl()); logger.error(e.getMessage(), e); // 3.3.2 æœåŠ¡ç«¯ä¾§ï¼Œç›®å‰ä»…æœ‰ telnet å‘½ä»¤çš„æƒ…å†µ &#125; else &#123; // è°ƒç”¨ handler çš„ telnetæ–¹æ³•ï¼Œå¤„ç†telnetå‘½ä»¤ï¼Œå¹¶å°†æ‰§è¡Œå‘½ä»¤çš„ç»“æœå‘é€å¯å®¢æˆ·ç«¯ã€‚ã€æ³¨æ„ï¼šExchangeHandlerå®ç°äº†TelnetHandleræ¥å£ã€‘ String echo = handler.telnet(channel, (String) message); if (echo != null &amp;&amp; echo.length() &gt; 0) &#123; channel.send(echo); &#125; &#125; // 3.4 å…¶ä»–æƒ…å†µï¼Œç›´æ¥äº¤ç»™ä¸Šå±‚å®ç°çš„ ExchangeHandler è¿›è¡Œå¤„ç† &#125; else &#123; handler.received(exchangeChannel, message); &#125; &#125; finally &#123; // 4. è‹¥channelå·²ç»æ–­å¼€ï¼Œåˆ™ è§£ç»‘ channel ä¸ HeaderExchangeChannel çš„è”ç³» HeaderExchangeChannel.removeChannelIfDisconnected(channel); &#125; &#125; ç”±äºæ”¶åˆ°æ¶ˆæ¯çš„ç±»å‹å¯èƒ½æœ‰å¤šç§ï¼Œä¸åŒç±»å‹å¤„ç†é€»è¾‘ä¹Ÿä¸ç›¸åŒï¼Œä¸‹é¢å¯¹æ¶ˆæ¯åˆ†ç±»å¤„ç†è¿›è¡Œè¯´æ˜ã€‚ åªè¯»è¯·æ±‚åªè¯»è¯·æ±‚ç”± handlerEvent() æ–¹æ³•è¿›è¡Œå¤„ç†ï¼Œå®ƒä¼šåœ¨ Channel ä¸Šè®¾ç½® channel.readonly æ ‡è¯†ï¼Œå®¢æˆ·ç«¯æ”¶åˆ°åªè¯»äº‹ä»¶è¯·æ±‚åï¼Œåç»­ä¸å†å‘å¯¹åº”çš„æœåŠ¡å‘é€æ–°çš„è¯·æ±‚ã€‚ 1234567891011121314/** * å¤„ç†åªè¯»äº‹ä»¶è¯·æ±‚ * * @param channel åº•å±‚ Dubbo é€šé“ * @param req è¯·æ±‚ * @throws RemotingException */ void handlerEvent(Channel channel, Request req) throws RemotingException &#123; // å¦‚æœæ˜¯åªè¯»è¯·æ±‚ 'R' if (req.getData() != null &amp;&amp; req.getData().equals(Request.READONLY_EVENT)) &#123; // å®¢æˆ·ç«¯æ”¶åˆ° READONLY_EVENT äº‹ä»¶è¯·æ±‚åè®°å½•åˆ°é€šé“ï¼Œåç»­ä¸å†å‘è¯¥æœåŠ¡å™¨å‘é€æ–°çš„è¯·æ±‚ã€‚[æœåŠ¡è°ƒç”¨æ—¶ä¼šæ£€æŸ¥æœåŠ¡çš„çŠ¶æ€] channel.setAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY, Boolean.TRUE); &#125; &#125; åŒå‘è¯·æ±‚åŒå‘è¯·æ±‚å³éœ€è¦å“åº”çš„è¯·æ±‚ç”± handleRequest() æ–¹æ³•è¿›è¡Œå¤„ç†ï¼Œè¯¥æ–¹æ³•ä¼šå…ˆåˆ¤æ–­è¯·æ±‚æ˜¯å¦è§£ç å¤±è´¥ï¼Œå¦‚æœè§£ç å¤±è´¥åˆ™è¿”å›å¼‚å¸¸å“åº”ï¼Œå¦‚æœè¯·æ±‚è§£ç æˆåŠŸåˆ™ä¼šå°†æ­£å¸¸è§£ç çš„è¯·æ±‚äº¤ç»™ä¸Šå±‚å®ç°çš„ ExchangeHandler è¿›è¡Œå¤„ç†ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * å¤„ç†æ™®é€šè¯·æ±‚ - éœ€è¦å“åº” * * @param channel åº•å±‚ Dubbo é€šé“ * @param req * @return * @throws RemotingException */ Response handleRequest(ExchangeChannel channel, Request req) throws RemotingException &#123; // åˆ›å»ºå“åº”å¯¹è±¡ Response res = new Response(req.getId(), req.getVersion()); // å¦‚æœæ˜¯è§£ç å¤±è´¥çš„è¯·æ±‚ï¼Œåˆ™è¿”å›çŠ¶æ€ä¸º BAD_REQUEST çš„å¼‚å¸¸ç»“æœ if (req.isBroken()) &#123; // è¯·æ±‚æ•°æ®ï¼Œè½¬æˆ msg Object data = req.getData(); String msg; if (data == null) &#123; msg = null; &#125; else if (data instanceof Throwable) &#123; msg = StringUtils.toString((Throwable) data); &#125; else &#123; msg = data.toString(); &#125; res.setErrorMessage(\"Fail to decode request due to: \" + msg); res.setStatus(Response.BAD_REQUEST); // è¿”å› return res; &#125; // è·å–è¯·æ±‚æ•°æ®ï¼Œè¿™é‡Œä¸€èˆ¬æ˜¯ RpcInvocation å¯¹è±¡ Object msg = req.getData(); try &#123; // äº¤ç»™ä¸Šå±‚å®ç°çš„ ExchangeHandler è¿›è¡Œå¤„ç† Object result = handler.reply(channel, msg); // å°è£…è¯·æ±‚çŠ¶æ€å’Œç»“æœ res.setStatus(Response.OK); res.setResult(result); // ä¸Šå±‚å®ç°çš„ ExchangeHandler å¤„ç†å¼‚å¸¸ &#125; catch (Throwable e) &#123; // è‹¥è°ƒç”¨è¿‡ç¨‹å‡ºç°å¼‚å¸¸ï¼Œåˆ™è®¾ç½® SERVICE_ERRORï¼Œè¡¨ç¤ºæœåŠ¡ç«¯å¼‚å¸¸ res.setStatus(Response.SERVICE_ERROR); res.setErrorMessage(StringUtils.toString(e)); &#125; // è¿”å›å“åº” return res; &#125; éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œåœ¨ Dubbo 2.7.x ç‰ˆæœ¬ä¸­å·²ç»æ”¯æŒæœåŠ¡ç«¯çš„å¼‚æ­¥å¤„ç†ï¼Œé€šè¿‡ Java 8 çš„ CompletableFuture æ¥å®ç°ã€‚ä» 2.7.0 å¼€å§‹ï¼ŒDubbo çš„æ‰€æœ‰å¼‚æ­¥ç¼–ç¨‹æ¥å£å¼€å§‹ä»¥ CompletableFuture ä¸ºåŸºç¡€ ã€‚å¤„ç†è¯·æ±‚çš„ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435void handleRequest(final ExchangeChannel channel, Request req) throws RemotingException &#123; // åˆ›å»ºå“åº”å¯¹è±¡ Response res = new Response(req.getId(), req.getVersion()); // è¯·æ±‚è§£ç å¤±è´¥ if (req.isBroken()) &#123; Object data = req.getData(); // è®¾ç½®å¼‚å¸¸ä¿¡æ¯å’Œå“åº”ç ï¼Œå°†å¼‚å¸¸å“åº”è¿”å›ç»™å¯¹ç«¯ res.setErrorMessage(\"Fail to decode request due to: \" + msg); res.setStatus(Response.BAD_REQUEST); channel.send(res); return; &#125; Object msg = req.getData(); // äº¤ç»™ä¸Šå±‚å®ç°çš„ExchangeHandlerè¿›è¡Œå¤„ç†ã€‚ // DubboProtocol ä¸­çš„ requestHandler çš„ reply æ–¹æ³•è¿”å›çš„ç±»å‹æ˜¯ CompletableFuture ã€‚ CompletionStage&lt;Object&gt; future = handler.reply(channel, msg); // è¯·æ±‚å¤„ç†åçš„å›è°ƒ future.whenComplete((appResult, t) -&gt; &#123; // è¿”å›æ­£å¸¸å“åº” if (t == null) &#123; res.setStatus(Response.OK); res.setResult(appResult); // å¤„ç†è¿‡ç¨‹å‘ç”Ÿå¼‚å¸¸ï¼Œè®¾ç½®å¼‚å¸¸ä¿¡æ¯å’Œé”™è¯¯ç  &#125; else &#123; res.setStatus(Response.SERVICE_ERROR); res.setErrorMessage(StringUtils.toString(t)); &#125; // å‘é€å“åº” channel.send(res); &#125;);&#125; å•å‘è¯·æ±‚å•å‘è¯·æ±‚å³è°ƒç”¨æ–¹ä¸éœ€è¦è¿”å›ç»“æœï¼Œç›´æ¥äº¤ç»™ä¸Šå±‚ ExchangeHandler å®ç°çš„ received() æ–¹æ³•è¿›è¡Œå¤„ç†ã€‚å¯¹äº DubboProtocol æ¥è¯´ï¼Œreceived() æ–¹æ³•ä¼šä¾èµ– reply() æ–¹æ³•ï¼Œå•å‘è¯·æ±‚ä¸ä½¿ç”¨ reply() æ–¹æ³•çš„è¿”å›ç»“æœè€Œå·²ã€‚ 12345678910111213+--- HeaderExchangeHandler handler.received(exchangeChannel, request.getData());+--- DubboProtocl @Override public void received(Channel channel, Object message) throws RemotingException &#123; // åˆ¤æ–­æ¶ˆæ¯ç±»å‹æ˜¯ä¸æ˜¯ Invocation if (message instanceof Invocation) &#123; reply((ExchangeChannel) channel, message); &#125; else &#123; super.received(channel, message); &#125; &#125; å¤„ç†å“åº”å¤„ç†æ¥æ”¶åˆ°çš„ Response æ¶ˆæ¯ï¼Œä¹Ÿå°±æ˜¯è¿”å›äº†ç»“æœï¼Œåªéœ€è¦ HeaderExchangeHandler è°ƒç”¨ handleResponse() æ–¹æ³•å°†å…³è”çš„ DefaultFuture è®¾ç½®ä¸ºå®ŒæˆçŠ¶æ€ï¼ˆæˆ–æ˜¯å¼‚å¸¸å®ŒæˆçŠ¶æ€ï¼‰ï¼Œç„¶åå‘ä¸‹ä¼ é€’å³å¯ã€‚ 12345678910111213/** * å¤„ç†å“åº” - å®¢æˆ·ç«¯æ”¶åˆ°æœåŠ¡ç«¯çš„å“åº” * * @param channel åº•å±‚ Dubbo é€šé“ * @param response å“åº” * @throws RemotingException */ static void handleResponse(Channel channel, Response response) throws RemotingException &#123; // åªå¤„ç†éå¿ƒè·³äº‹ä»¶å“åº”ï¼Œè°ƒç”¨DefaultFuture#received(channel, response) æ–¹æ³•è®¾ç½®å“åº”ç»“æœä»¥åŠå”¤é†’ç­‰å¾…è¯·æ±‚ç»“æœçš„çº¿ç¨‹ã€‚ if (response != null &amp;&amp; !response.isHeartbeat()) &#123; DefaultFuture.received(channel, response); &#125; &#125; åœ¨ HeaderExchangeChannel.request() æ–¹æ³•ä¸­å®Œæˆ DefaultFuture å¯¹è±¡çš„åˆ›å»ºåï¼Œä¼šå°†è¯·æ±‚é€šè¿‡è£…é¥°çš„ Dubbo Channel å‘é€å‡ºå»ï¼Œå‘é€çš„è¿‡ç¨‹ä¼šè§¦å‘ Dubbo Channel ä¸­ ChannelHandler é“¾ï¼Œè‡³äºæ˜¯ IO çº¿ç¨‹å¤„ç†è¯·æ±‚è¿˜æ˜¯é€šè¿‡çº¿ç¨‹æ± æ¥å¤„ç†è¯·æ±‚ï¼Œéœ€è¦çœ‹å…·ä½“çš„æ¶ˆæ¯æ´¾å‘ç­–ç•¥ã€‚æœåŠ¡ç«¯å¤„ç†å®Œè¯·æ±‚åï¼Œä¼šå°†ç»“æœå‘é€åˆ°å¯¹ç«¯ï¼Œæ¶ˆè´¹ç«¯è¯»å–åˆ°å®Œæ•´å“åº”åï¼ŒåŒæ ·ä¼šè§¦å‘ Dubbo Channel ä¸­ ChannelHandler é“¾ï¼Œå½“å“åº”ä¼ é€’åˆ° HeaderExchangeHandler æ—¶ received() æ–¹æ³•ä¼šè§¦å‘ï¼Œæ‰§è¡Œè¯¥æ–¹æ³•çš„å†…éƒ¨é€»è¾‘ï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨ handleResponse() æ–¹æ³•è®¾ç½®å“åº”ç»“æœå¹¶å”¤é†’ç­‰å¾…è¯·æ±‚ç»“æœçš„çº¿ç¨‹ã€‚ å¤„ç†Stringç±»å‹æ¶ˆæ¯å¯¹äº String ç±»å‹çš„æ¶ˆæ¯ï¼ŒHeaderExchangeHandler ä¼šæ ¹æ®å½“å‰æœåŠ¡çš„è§’è‰²è¿›è¡Œåˆ†ç±»å¤„ç†ï¼Œç›®å‰ä»…æ”¯æŒ telnet å‘½ä»¤ã€‚ å…œåº•å¤„ç†å¦‚æœæ¥æ”¶çš„æ¶ˆæ¯ä¸æ˜¯ä»¥ä¸Šç±»å‹ï¼Œåˆ™ç›´æ¥äº¤ç»™ä¸Šå±‚å®ç°çš„ ExchangeHandler è¿›è¡Œå¤„ç†ã€‚ ExchangeHandlerExchangeHandler æ˜¯ Exchange å±‚å®šä¹‰çš„ä¾›ä¸Šå±‚ä½¿ç”¨çš„ä¿¡æ¯äº¤æ¢å¤„ç†å™¨æ¥å£ï¼Œè¯¥æ¥å£ç»§æ‰¿äº† ChannelHandler å’Œ TelnetHandler æ¥å£ï¼Œå®ƒåŒæ ·æ˜¯ä¸€ä¸ª ChannelHandler ã€‚ 123456789101112public interface ExchangeHandler extends ChannelHandler, TelnetHandler &#123; /** * å¤„ç†è¯·æ±‚ * * @param channel é€šé“ * @param request è¯·æ±‚ * @return response è¿”å›è¯·æ±‚ç»“æœ * @throws RemotingException */ Object reply(ExchangeChannel channel, Object request) throws RemotingException;&#125; ExchangeHandler æ–°å®šä¹‰äº† reply() æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸»è¦ç”¨æ¥å¤„ç†è¯·æ±‚å¹¶è¿”å›è¯·æ±‚ç»“æœï¼Œä¸Šæ–‡ä¸­çš„ HeaderExchangeHandler.handleRequest() æ–¹æ³•å¤„ç†åŒå‘è¯·æ±‚çš„è¿‡ç¨‹å°±æ˜¯å°† reply() æ–¹æ³•è¿”å›ç»“æœè®¾ç½®åˆ° Response.mResult å±æ€§ä¸­ã€‚ ExchangeHandlerAdapterä¿¡æ¯äº¤æ¢å¤„ç†å™¨é€‚é…å™¨æŠ½è±¡ç±»ï¼Œå®ç°äº† ExchangeHandler æ¥å£å¹¶ç»§æ‰¿äº† TelnetHandlerAdapter ç±»ï¼Œç©ºå®ç°äº† reply æ–¹æ³•ã€‚ 123456789101112131415public abstract class ExchangeHandlerAdapter extends TelnetHandlerAdapter implements ExchangeHandler &#123; /** * å¤„ç†è¯·æ±‚ * * @param channel é€šé“ * @param msg * @return * @throws RemotingException */ @Override public Object reply(ExchangeChannel channel, Object msg) throws RemotingException &#123; return null; &#125;&#125; ExchangeHandler æ¥å£è™½ç„¶å±äº ChannelHandler ç±»å‹ï¼Œä½†æ˜¯è¯¥æ¥å£çš„å®šä½æ˜¯ä¾› Exchange å±‚çš„ä¸Šå±‚ä½¿ç”¨ï¼Œå…¶å®å°±æ˜¯ Protocol å±‚ã€‚æˆªæ­¢åˆ°ç›®å‰ï¼Œæˆ‘ä»¬ä¸éš¾å‘ç° ExchangeHandler çš„å®ç°å°±æ˜¯æ•´ä¸ª ChannelHandler é“¾çš„æœ€å°¾çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™æ„å‘³ç€ä¸Šå±‚é€»è¾‘çš„ç›´æ¥å¤„ç†å¯¹è±¡å°±æ˜¯è¯¥å®ç°ã€‚ ç”±äº ExchangeHandlerAdapter å®ç°äº† ExchangeHandler æ¥å£ï¼Œåœ¨ DubboProtocolã€ThirftProtocol ä¸­éƒ½ä¼šåŸºäº ExchangeHandlerAdapter å®ç°è‡ªå·±çš„å¤„ç†å™¨ï¼Œå¤„ç†è¯·æ±‚å¹¶è¿”å›ç»“æœï¼Œå¦‚ DubboProtocol ä¸­çš„å¤„ç†å™¨å®ç°ï¼Œç”¨äºå°†è¯·æ±‚æœ€ç»ˆäº¤ç»™å¯¹åº”çš„ Invoker å¯¹è±¡å¤„ç†ï¼Œç®€åŒ–åçš„ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() &#123; // ç”¨äºå¤„ç†æœåŠ¡æ¶ˆè´¹è€…çš„åŒæ­¥è°ƒç”¨å’Œå¼‚æ­¥è°ƒç”¨çš„è¯·æ±‚ @Override public Object reply(ExchangeChannel channel, Object message) throws RemotingException &#123; if (message instanceof Invocation) &#123; // è½¬æˆ Invocation Invocation inv = (Invocation) message; // æ ¹æ®è°ƒç”¨ä¿¡æ¯è·å– Invoker Invoker&lt;?&gt; invoker = getInvoker(channel, inv); // æ‰§è¡Œè°ƒç”¨ return invoker.invoke(inv); &#125; &#125; @Override public void received(Channel channel, Object message) throws RemotingException &#123; //... çœç•¥ä»£ç  &#125; @Override public void connected(Channel channel) throws RemotingException &#123; //... çœç•¥ä»£ç  &#125; @Override public void disconnected(Channel channel) throws RemotingException &#123; //... çœç•¥ä»£ç  &#125; &#125; å¼‚æ­¥è½¬åŒæ­¥Dubbo åè®®ä¸‹ä½¿ç”¨çš„ç½‘ç»œé€šä¿¡åº•å±‚ä¾èµ–çš„æ˜¯ NIO ç»„ä»¶ï¼Œè€Œè¿™äº› NIO ç»„ä»¶æ˜¯å¼‚æ­¥é€šè®¯æœºåˆ¶ã€‚æ­¤å¤–ï¼ŒTCP åè®®æœ¬èº«å°±æ˜¯å¼‚æ­¥çš„ï¼Œåœ¨ TCP åè®®å±‚é¢å‘é€å®Œ RPC è¯·æ±‚åï¼Œçº¿ç¨‹æ˜¯ä¸ä¼šç­‰å¾… RPC çš„å“åº”ç»“æœçš„ã€‚æ—¢ç„¶åº•å±‚æ˜¯å¼‚æ­¥å¤„ç†è¯·æ±‚ï¼Œé‚£ä¹ˆ Dubbo æ˜¯æ€æ ·å®ç°åŒæ­¥è°ƒç”¨çš„å‘¢ï¼Ÿå…¶å® Dubbo å¼‚æ­¥è°ƒç”¨å’ŒåŒæ­¥è°ƒç”¨å·®ä¸å¤šï¼ŒåŒºåˆ«åœ¨äºè·å–è°ƒç”¨ç»“æœçš„æ—¶æœºã€‚åœ¨åˆ†æå¼‚æ­¥è½¬åŒæ­¥å‰ï¼Œæˆ‘ä»¬å…ˆç®€å•è¯´æ˜ä¸‹ Dubbo ä¸­çš„åŒæ­¥è°ƒç”¨å’Œå¼‚æ­¥è°ƒç”¨ã€‚ åŒæ­¥è°ƒç”¨åŒæ­¥è°ƒç”¨æ˜¯ä¸€ç§é˜»å¡å¼çš„è°ƒç”¨æ–¹å¼ï¼Œæ¶ˆè´¹æ–¹å‘èµ·è°ƒç”¨åä¼šå¤„äºé˜»å¡ç­‰å¾…çŠ¶æ€ï¼Œç›´åˆ°æœåŠ¡æä¾›æ–¹è¿”å›ç»“æœï¼ˆè¿™é‡Œä¸è€ƒè™‘è¶…æ—¶ã€å‡ºé”™ç­‰å¼‚å¸¸æµï¼‰ã€‚è¿‡ç¨‹å¦‚ä¸‹ï¼š æ¶ˆè´¹æ–¹ä¸šåŠ¡çº¿ç¨‹è°ƒç”¨è¿œç¨‹æœåŠ¡æ¥å£ï¼ŒåŒæ—¶å½“å‰ä¸šåŠ¡çº¿ç¨‹å¤„äºé˜»å¡çŠ¶æ€å³é˜»å¡ç­‰å¾…è°ƒç”¨ç»“æœã€‚ æœåŠ¡æä¾›æ–¹æ”¶åˆ°æ¶ˆè´¹æ–¹çš„è¯·æ±‚åä¼šå¯¹è¯·æ±‚è¿›è¡Œå¤„ç†ï¼Œå¤„ç†å®Œæ¯•ä¼šå°†ç»“æœå‘é€åˆ°å¯¹ç«¯ã€‚ æ¶ˆè´¹æ–¹æ”¶åˆ°è°ƒç”¨ç»“æœåï¼Œé˜»å¡çš„ä¸šåŠ¡çº¿ç¨‹ç»§ç»­å¾€ä¸‹æ‰§è¡Œã€‚ ä¸Šè¿°åŒæ­¥è°ƒç”¨è¿‡ç¨‹æœ‰ 3 ä¸ªç‚¹å€¼å¾—å…³æ³¨ï¼š ä¸šåŠ¡çº¿ç¨‹æ˜¯æ€ä¹ˆè¿›å…¥é˜»å¡çŠ¶æ€çš„ å¦‚ä½•å®šä¹‰æ¶ˆè´¹æ–¹æ”¶åˆ°è°ƒç”¨ç»“æœ ä¸šåŠ¡çº¿ç¨‹æ˜¯å¦‚ä½•å”¤é†’çš„ è¦å¼„æ¸…æ¥šä¸Šé¢çš„é—®é¢˜éœ€è¦ä»æºç ä¸­æ‰¾çº¿ç´¢ï¼Œæˆ‘ä»¬å…ˆä¸‹é¢çš„ä»£ç ã€‚ 12345678910111213141516171819202122232425262728+--- DubboInvoker.doInvoke() // å¼‚æ­¥æ— è¿”å›å€¼ if (isOneway) &#123; boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false); // å‘é€è¯·æ±‚ currentClient.send(inv, isSent); // è®¾ç½®ä¸Šä¸‹æ–‡ä¸­çš„ future ä¸º null RpcContext.getContext().setFuture(null); // è¿”å›ä¸€ä¸ªç©ºçš„ RpcResult return new RpcResult(); &#125; // å¼‚æ­¥æœ‰è¿”å›å€¼ else if (isAsync) &#123; // å‘é€è¯·æ±‚ï¼Œè·å¾— ResponseFuture å®ä¾‹ ResponseFuture future = currentClient.request(inv, timeout); // è®¾ç½® future åˆ°ä¸Šä¸‹æ–‡ä¸­ RpcContext.getContext().setFuture(new FutureAdapter&lt;Object&gt;(future)); // æš‚æ—¶è¿”å›ä¸€ä¸ªç©ºç»“æœ return new RpcResult(); &#125; // åŒæ­¥è°ƒç”¨ else &#123; RpcContext.getContext().setFuture(null); // å‘é€è¯·æ±‚ï¼Œå¾—åˆ°ä¸€ä¸ª ResponseFuture å®ä¾‹ï¼Œå¹¶è°ƒç”¨è¯¥å®ä¾‹çš„ get æ–¹æ³•è¿›è¡Œç­‰å¾… return (Result) currentClient.request(inv, timeout).get(); &#125; çœ‹åˆ°ä¸Šé¢çš„ä»£ç åï¼Œæ˜¯ä¸æ˜¯å·²ç»æœ‰äº†ç»“è®ºã€‚å…³é”®ç‚¹åœ¨æ¶ˆè´¹æ–¹è°ƒç”¨åä¼šå¾—åˆ°ä¸€ä¸ª ResponseFuture å¯¹è±¡ï¼Œè¯¥å¯¹è±¡åœ¨å‰æ–‡å·²ç»è¯¦ç»†ä»‹ç»è¿‡äº†ã€‚åŒæ­¥è°ƒç”¨æ—¶ï¼Œä¸šåŠ¡çº¿ç¨‹ç›´æ¥æ‰§è¡Œ ResponseFuture.get() æ–¹æ³•é˜»å¡ç­‰å¾…ç»“æœè¿”å›ï¼Œä¸€èˆ¬æ¶ˆè´¹æ–¹ä¼šå®šä¹‰è¶…æ—¶æ—¶é—´ï¼ˆæ²¡æœ‰å®šä¹‰åˆ™ä½¿ç”¨é»˜è®¤è¶…æ—¶æ—¶é—´ï¼‰ã€‚å½“æœåŠ¡æä¾›æ–¹è¿”å›ç»“æœåï¼Œé€šè¿‡æ‰§è¡Œ received() æ–¹æ³•å°†ç»“æœè®¾ç½®åˆ° ResponseFuture ä¸­ï¼Œå¹¶å”¤é†’é˜»å¡ç­‰å¾…çš„ä¸šåŠ¡çº¿ç¨‹ã€‚å¦‚æœè¶…è¿‡æœ€å¤§ç­‰å¾…æ—¶é—´ç»“æœè¿˜æœªè¿”å›ï¼Œåˆ™ä¸šåŠ¡çº¿ç¨‹ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚ å¼‚æ­¥è°ƒç”¨Dubbo é»˜è®¤ä½¿ç”¨çš„æ˜¯åŒæ­¥è°ƒç”¨ï¼Œå¦‚æœè¦ä½¿ç”¨å¼‚æ­¥è°ƒç”¨éœ€è¦æ¶ˆè´¹æ–¹è‡ªè¡Œé…ç½®ã€‚Dubbo çš„å¼‚æ­¥è°ƒç”¨å’ŒåŒæ­¥è°ƒç”¨ç±»ä¼¼ï¼ŒåŒºåˆ«åœ¨äºä¸šåŠ¡çº¿ç¨‹è·å–è°ƒç”¨ç»“æœçš„æ—¶æœºæ˜¯å¯æ§çš„ã€‚ä¸šåŠ¡çº¿ç¨‹å‘èµ·è°ƒç”¨åå¹¶æ²¡æœ‰ç«‹å³è·å–è°ƒç”¨ç»“æœï¼Œè€Œæ˜¯å°† ResponseFuture ä¿å­˜åˆ°äº† Dubbo çš„ä¸Šçº¿æ–‡ä¸­ï¼Œç„¶åç»§ç»­å‘ä¸‹æ‰§è¡Œå…¶å®ƒé€»è¾‘ï¼Œå½“éœ€è¦è°ƒç”¨ç»“æœæ—¶å¯ä»¥éšæ—¶ä»ä¸Šä¸‹æ–‡ä¸­å–å‡º ResponseFuture å¹¶æ‰§è¡Œ get() æ–¹æ³•æ¥è·å–ã€‚ è½¬åŒ–æµç¨‹å›¾ ä¸Šå›¾ç®€å•æè¿°äº† Dubbo å¼‚æ­¥è½¬åŒæ­¥çš„è¿‡ç¨‹ï¼ŒåŒ…æ‹¬äº†åŒæ­¥è°ƒç”¨å’Œå¼‚æ­¥è°ƒç”¨ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå›¾ä¸­è®¾ç½®å“åº”ç»“æœæ˜¯ HeaderExchangeHandler å¤„ç†çš„ï¼Œå…¶å®è¿˜æœ‰ä¸€ç§å¤„ç†å“åº”ç»“æœçš„æ–¹å¼ï¼Œä¹Ÿæ˜¯å‰æ–‡å·²ç»è¯´æ˜çš„ï¼Œé€šè¿‡å®šæ—¶ä»»åŠ¡æ‰«æè°ƒç”¨è¶…æ—¶çš„è¯·æ±‚ä»¥åŠæ—¶å“åº”ç»“æœï¼Œå¦‚æœæ˜¯åŒæ­¥è°ƒç”¨åˆ™å¯ä»¥å°½å¯èƒ½å‡å°‘ä¸šåŠ¡çº¿ç¨‹é˜»å¡ç­‰å¾…çš„æ—¶é—´ã€‚ å®¢æˆ·ç«¯Exchange å±‚çš„å®¢æˆ·ç«¯ç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ExchangeClient12public interface ExchangeClient extends Client, ExchangeChannel &#123;&#125; Exchange å±‚å®šä¹‰çš„ Client æ¥å£æ˜¯ä¸ªç©ºæ¥å£ï¼Œæ²¡æœ‰å®šä¹‰ä»»ä½•æ–¹æ³•ï¼Œåªæ˜¯ç»§æ‰¿äº†æœ€åŸºæœ¬çš„ Client å’Œ ExchangeChannel æ¥å£ï¼Œç›®å‰åªæ˜¯å……å½“æ ‡è®°æ¥å£è§’è‰²ã€‚ä¸ºä»€ä¹ˆè¯´ Client å’Œ ExchangeChannel æ˜¯æœ€åŸºæœ¬çš„æ¥å£å‘¢ï¼Ÿä» Client çš„è§’åº¦çœ‹ï¼ŒClient æ¥å£æ ‡è¯†æ˜¯å®¢æˆ·ç«¯ï¼Œè¿™ä¸ªå¾ˆå¥½ç†è§£ã€‚ä½†æ˜¯ç»§æ‰¿ ExchangeChannel æ¥å£çš„ç›®çš„æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ è¿™æ˜¯å› ä¸º ExchangeClient è¦ä½¿ç”¨ ExchangeChannel æ¥å‘é€æ¶ˆæ¯ï¼Œå› æ­¤ ExchangeClient å®ä¾‹å†…éƒ¨ä¼šå°è£…ä¸€ä¸ª ExchangeChannel å®ä¾‹ï¼ŒåŸºäºé¢å‘æ¥å£å¼€å‘åŸåˆ™ç»§æ‰¿ ExchangeChannel è¿œæ¯”è‡ªå®šä¹‰å‘é€æ¶ˆæ¯æ¥å£è¦ä¼˜é›…å¾—å¤šã€‚ä¸ä»… Exchange å±‚è¿™æ ·è®¾è®¡ï¼ŒTransport å±‚çš„ Client ä¹Ÿæ˜¯åŒæ ·çš„è®¾è®¡æ–¹å¼ã€‚ ä¸‹é¢æˆ‘ä»¬çœ‹ ExchangeClient çš„å®ç°ç±» HeaderExchangeClient ã€‚ HeaderExchangeClientå®ç°äº† ExchangeClient æ¥å£ï¼Œå¹¶ä¸”é—´æ¥å®ç°äº† ExchangeChannel å’Œ Client æ¥å£ã€‚HeaderExchangeClient æ˜¯ Client çš„è£…é¥°å™¨ï¼Œä¸»è¦ä¸ºè£…é¥°çš„ Client æ·»åŠ ä»¥ä¸‹åŠŸèƒ½ï¼š é€šè¿‡å®šæ—¶å‘é€å¿ƒè·³æ¶ˆæ¯æ¥ç»´æŒä¸ Server çš„é•¿è¿æ¥çŠ¶æ€ã€‚ é€šè¿‡å®šæ—¶æ£€æŸ¥è¿æ¥çŠ¶æ€æ¥å®ç°æ–­çº¿é‡è¿åŠŸèƒ½ã€‚ å±æ€§12345678910111213141516171819202122232425+--- HeaderExchangeClient /** * å®šæ—¶ä»»åŠ¡çº¿ç¨‹æ±  */ private static final ScheduledThreadPoolExecutor scheduled = new ScheduledThreadPoolExecutor(2, new NamedThreadFactory(\"dubbo-remoting-client-heartbeat\", true)); /** * Transport å±‚çš„ Client å®ä¾‹ */ private final Client client; /** * ä¿¡æ¯äº¤æ¢é€šé“ï¼ŒClient å’Œ Server å»ºç«‹çš„è¿æ¥ */ private final ExchangeChannel channel; /** * å®šæ—¶ä»»åŠ¡Future */ private ScheduledFuture&lt;?&gt; heartbeatTimer; /** * å¿ƒè·³é—´éš” */ private int heartbeat; /** * å¿ƒè·³è¶…æ—¶æ—¶é—´ */ private int heartbeatTimeout; HeaderExchangeClient ä¸­çš„å±æ€§å­—æ®µè¯´æ˜å¦‚ä¸‹ï¼š client ï¼šè¢«è£…é¥°çš„ Client å¯¹è±¡ï¼ŒHeaderExchangeClient ä¸­å¯¹ Client æ¥å£çš„å®ç°éƒ½ä¼šå§”æ‰˜ç»™è¿™ä¸ªè¢«è£…é¥°çš„å¯¹è±¡å¤„ç†ã€‚ channel ï¼šHeaderExchangeClient ä¸­å¯¹ ExchangeChannel æ¥å£çš„å®ç°ï¼Œéƒ½ä¼šå§”æ‰˜ç»™è¯¥å¯¹è±¡è¿›è¡Œå¤„ç†ã€‚ scheduled ï¼šç”¨äºå®šæ—¶ å‘é€å¿ƒè·³æ¶ˆæ¯ä»¥ç»´æŒå’Œ Server çš„é•¿è¿æ¥çŠ¶æ€å’Œæ£€æŸ¥è¿æ¥çŠ¶æ€ä»¥å®ç°æ–­çº¿é‡è¿åŠŸèƒ½ã€‚ heartbeat å’Œ heartbeatTimeout ï¼šä½œä¸ºå¿ƒè·³ç›¸å…³çš„æ—¶é—´å±æ€§ï¼Œä»¥æ­¤ä¸ºä¾æ®åˆ¤æ–­æ˜¯å¦è¦å‘é€å¿ƒè·³å’Œé‡è¿ã€‚ ä¸Šè¿°å±æ€§ä¼šåœ¨ HeaderExchangeClient æ„é€ æ–¹æ³•ä¸­å®Œæˆåˆå§‹åŒ–ã€‚ æ„é€ æ–¹æ³•1234567891011121314151617181920212223242526272829303132/** * @param client Transport å±‚çš„ Client å®ä¾‹ * @param needHeartbeat æ˜¯å¦å¼€å¯å¿ƒè·³ä»»åŠ¡ */ public HeaderExchangeClient(Client client, boolean needHeartbeat) &#123; if (client == null) &#123; throw new IllegalArgumentException(\"client == null\"); &#125; // è®¾ç½® client å±æ€§ this.client = client; // åˆ›å»º HeaderExchangeChannel å¯¹è±¡ï¼Œå¯¹ Transportå±‚çš„Clientè¿›è¡Œè£…é¥° this.channel = new HeaderExchangeChannel(client); // è·å– Dubbo ç‰ˆæœ¬ String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY); // è¯»å–å¿ƒè·³ç›¸å…³çš„é…ç½®,é»˜è®¤å¼€å¯å¿ƒè·³æœºåˆ¶ this.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != null &amp;&amp; dubbo.startsWith(\"1.0.\") ? Constants.DEFAULT_HEARTBEAT : 0); this.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * 3); // é¿å…å¿ƒè·³é—´éš”å¤ªçŸ­ if (heartbeatTimeout &lt; heartbeat * 2) &#123; throw new IllegalStateException(\"heartbeatTimeout &lt; heartbeatInterval * 2\"); &#125; // æ˜¯å¦å¯åŠ¨å¿ƒè·³ if (needHeartbeat) &#123; // å¯åŠ¨å¿ƒè·³å®šæ—¶ä»»åŠ¡ startHeartbeatTimer(); &#125; &#125; æ„é€ æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ Transport å±‚çš„ Client å¯¹è±¡ï¼Œå¦‚ NettyClient å¯¹è±¡ï¼Œç¬¬äºŒå‚æ•°è¡¨ç¤ºæ˜¯å¦å¼€å¯å¿ƒè·³ä»»åŠ¡ï¼Œç”±å‰æ–‡çŸ¥è¯¥å‚æ•°åœ¨ HeaderExchanger.connect() æ–¹æ³•ä¸­ä¼ å…¥çš„æ˜¯ trueï¼Œå³è¡¨ç¤ºå¼€å¯å®¢æˆ·ç«¯ä¾§çš„å¿ƒè·³å®šæ—¶ä»»åŠ¡ã€‚ä¸‹é¢æˆ‘ä»¬é‡ç‚¹åˆ†æè¯¥å¿ƒè·³é€»è¾‘ã€‚ å¼€å¯å¿ƒè·³å®šæ—¶ä»»åŠ¡1234567891011121314151617181920212223242526/** * å¼€å¯å¿ƒè·³å®šæ—¶ä»»åŠ¡ */ private void startHeartbeatTimer() &#123; // å¼€å¯ä¸€ä¸ªæ–°çš„å¿ƒè·³å®šæ—¶ä»»åŠ¡æ—¶ï¼Œéœ€è¦åœæ­¢åŸæœ‰çš„å®šæ—¶ä»»åŠ¡ stopHeartbeatTimer(); // å¼€å¯æ–°çš„å®šæ—¶ä»»åŠ¡ if (heartbeat &gt; 0) &#123; heartbeatTimer = scheduled.scheduleWithFixedDelay( /** * åˆ›å»ºå¿ƒè·³ä»»åŠ¡ */ new HeartBeatTask(new HeartBeatTask.ChannelProvider() &#123; /** * æ¯ä¸ªå®¢æˆ·ç«¯ç«¯ä¾§åªæœ‰ä¸€ä¸ªé€šé“ï¼Œè¿™é‡Œæ˜¯ HeaderExchangeClient å¯¹è±¡è‡ªå·± * @return */ @Override public Collection&lt;Channel&gt; getChannels() &#123; return Collections.&lt;Channel&gt;singletonList(HeaderExchangeClient.this); &#125; &#125;, heartbeat, heartbeatTimeout), heartbeat, heartbeat, TimeUnit.MILLISECONDS); &#125; &#125; å¼€å¯å¿ƒè·³å®šæ—¶ä»»åŠ¡æ¯”è¾ƒç®€å•ï¼Œä¸»è¦æ˜¯åˆ›å»ºä¸€ä¸ªå¿ƒè·³ä»»åŠ¡ HeartBeatTask å¹¶ä¼ å…¥å…¶æ„é€ æ–¹æ³•æ‰€éœ€çš„å‚æ•°ï¼ŒChannel(è¿™é‡Œæ˜¯ HeaderExchangeClient å¯¹è±¡)ã€å¿ƒè·³é—´éš” heartbeat å’Œ å¿ƒè·³è¶…æ—¶æ—¶é—´ heartbeatTimeoutï¼Œæœ€åå°†åˆ›å»ºçš„å¿ƒè·³ä»»åŠ¡äº¤ç»™å®šæ—¶ä»»åŠ¡çº¿ç¨‹æ± å¤„ç†ã€‚å¯ä»¥çœ‹å‡ºï¼Œä¸ç®¡æ˜¯å¿ƒè·³æ£€æµ‹è¿˜æ˜¯æ–­çº¿é‡è¿ï¼Œæ ¸å¿ƒç‚¹æ˜¯ HeartBeatTask ä»»åŠ¡ã€‚ å…³äºè¯¥ä»»åŠ¡æˆ‘ä»¬å¾…ä¼šè¯¦ç»†åˆ†æï¼Œç°åœ¨å›åˆ° HeaderExchangeClient ç±»ä¸­æ¥ã€‚åœæ­¢å¿ƒè·³å®šæ—¶ä»»åŠ¡æ¯”è¾ƒç®€å•å°±ä¸å†ä»‹ç»ã€‚ä¸‹é¢å¯¹å‰©ä½™çš„æ–¹æ³•åˆ†ç±»è¯´æ˜ã€‚ å…¶å®ƒæ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109+--- HeaderExchangeClient //------------------------ ExchangeChannel æ¥å£æ–¹æ³•çš„å®ç° -------------------/ @Override public ResponseFuture request(Object request) throws RemotingException &#123; return channel.request(request); &#125; @Override public ResponseFuture request(Object request, int timeout) throws RemotingException &#123; return channel.request(request, timeout); &#125; @Override public ExchangeHandler getExchangeHandler() &#123; return channel.getExchangeHandler(); &#125; // ExchangeChannel å¯¹ Endpoint çš„ close(int timeout) æ–¹æ³•çš„é‡å†™ï¼ŒHeaderExchangeClient å¯¹å…¶è¿›è¡Œå®ç°ã€‚ @Override public void close(int timeout) &#123; // Mark the client into the closure process startClose(); // å°† closing å­—æ®µè®¾ç½®ä¸ºtrue doClose(); // å…³é—­å¿ƒè·³å®šæ—¶ä»»åŠ¡ channel.close(timeout); // å…³é—­ HeaderExchangeChannel &#125; //-------------------------- Endpoint æ¥å£æ–¹æ³•çš„å®ç° ----------------------/ @Override public URL getUrl() &#123; return channel.getUrl(); &#125; // è·å–åº•å±‚Channelå…³è”çš„ChannelHandlerã€‚ Channelæ¥å£ç»§æ‰¿Endpointæ¥å£æ˜¯æœ‰åŸå› çš„å“Ÿã€‚ @Override public ChannelHandler getChannelHandler() &#123; return channel.getChannelHandler(); &#125; // Channelæ¥å£ç»§æ‰¿Endpointæ¥å£æ˜¯æœ‰åŸå› çš„å“Ÿã€‚ @Override public InetSocketAddress getLocalAddress() &#123; return channel.getLocalAddress(); &#125; @Override public void send(Object message) throws RemotingException &#123; channel.send(message); &#125; @Override public void send(Object message, boolean sent) throws RemotingException &#123; channel.send(message, sent); &#125; @Override public boolean isClosed() &#123; return channel.isClosed(); &#125; @Override public void close() &#123; doClose(); channel.close(); &#125; @Override public void startClose() &#123; channel.startClose(); &#125; //------------------------------- Channel æ¥å£æ–¹æ³•çš„å®ç° -------------------------/ @Override public InetSocketAddress getRemoteAddress() &#123; return channel.getRemoteAddress(); &#125; @Override public boolean isConnected() &#123; return channel.isConnected(); &#125; @Override public Object getAttribute(String key) &#123; return channel.getAttribute(key); &#125; @Override public void setAttribute(String key, Object value) &#123; channel.setAttribute(key, value); &#125; @Override public void removeAttribute(String key) &#123; channel.removeAttribute(key); &#125; @Override public boolean hasAttribute(String key) &#123; return channel.hasAttribute(key); &#125; //----------------------------- Client æ¥å£æ–¹æ³•çš„å®ç° ---------------------------/ @Override public void reconnect() throws RemotingException &#123; client.reconnect(); &#125; å¯¹ HeaderExchangeClient ä¸­çš„å…¶å®ƒæ–¹æ³•åšäº†ç®€å•çš„åˆ†ç±»ï¼Œåˆ†ç±»ä¸æ˜¯ç›®çš„ï¼Œç›®çš„æ˜¯æƒ³è¯´æ˜ä¸€ä¸ªç°è±¡ã€‚Client å’Œ Server éƒ½æ˜¯å…·æœ‰è¯­ä¹‰çš„ç«¯ç‚¹ï¼Œä¸¤è€…ä¹‹é—´çš„ TCP è¿æ¥æŠ½è±¡ä¸º Channelï¼Œç«¯ç‚¹ä¸€èˆ¬ä¸è¿›è¡Œæ•°æ®ä¼ è¾“åŠ¨ä½œï¼Œè¿›è¡Œæ•°æ®ä¼ è¾“çš„åŠ¨ä½œéƒ½æ˜¯ç”±ç«¯ç‚¹çš„é€šé“æ‰§è¡Œçš„ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°ç«¯ç‚¹æœ‰å®ç°æ•°æ®ä¼ è¾“çš„æ¥å£æ–¹æ³•ï¼Œä½†æ˜¯å…·ä½“çš„åŠ¨ä½œè¿˜æ˜¯äº¤ç»™äº†å…¶é€šé“æ‰§è¡Œã€‚é€šè¿‡ä¸Šé¢çš„ä»£ç æˆ‘ä»¬ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œè¢«è£…é¥°çš„Clientå¯¹è±¡åªå¤„ç†äº†é‡è¿åŠ¨ä½œï¼Œè¿™æ˜¯ç«¯ç‚¹çš„åŠ¨ä½œã€‚å…¶å®ƒçš„æ–¹æ³•éƒ½æ˜¯äº¤ç»™äº†è¢«è£…é¥°çš„ ExchangeChannel å¯¹è±¡ã€‚ å¿ƒè·³ä»»åŠ¡HeartBeatTask å®ç°äº† Runnable æ¥å£ï¼Œè¯¥ä»»åŠ¡ä¸»è¦è¿›è¡Œå¿ƒè·³æ£€æµ‹å’Œæ–­çº¿é‡è¿ã€‚ å±æ€§1234567891011121314151617181920212223242526272829303132333435363738394041424344final class HeartBeatTask implements Runnable &#123; private static final Logger logger = LoggerFactory.getLogger(HeartBeatTask.class); /** * ç”¨äºè·å–éœ€è¦å¿ƒè·³æ£€æµ‹çš„é€šé“æ•°ç»„çš„å¯¹è±¡ */ private ChannelProvider channelProvider; /** * å¿ƒè·³é—´éš”ï¼Œå•ä½ï¼š æ¯«ç§’ */ private int heartbeat; /** * å¿ƒè·³è¶…æ—¶æ—¶é—´ï¼Œå•ä½ï¼šæ¯«ç§’ */ private int heartbeatTimeout; /** * è·å–é€šé“åŠ©æ‰‹å†…éƒ¨æ¥å£ */ interface ChannelProvider &#123; /** * è·å–éœ€è¦å¿ƒè·³æ£€æµ‹çš„ Channelï¼ŒChannel æ˜¯åŒå‘é€šä¿¡çš„å³ä¸ä»…ä»…æ”¯æŒå®¢æˆ·ç«¯è¿æ¥æœåŠ¡ç«¯ï¼Œè¿˜æ”¯æŒæœåŠ¡ç«¯å‘é€æ•°æ®åŒ…ç»™å®¢æˆ·ç«¯ * * @return */ Collection&lt;Channel&gt; getChannels(); &#125; /** * æ„é€ æ–¹æ³• * * @param provider é€šé“åŠ©æ‰‹å¯¹è±¡ * @param heartbeat å¿ƒè·³é—´éš” * @param heartbeatTimeout å¿ƒè·³è¶…æ—¶æ—¶é—´ */ HeartBeatTask(ChannelProvider provider, int heartbeat, int heartbeatTimeout) &#123; this.channelProvider = provider; this.heartbeat = heartbeat; this.heartbeatTimeout = heartbeatTimeout; &#125;&#125; å¿ƒè·³ä»»åŠ¡æœ‰ä¸‰ä¸ªæ ¸å¿ƒå±æ€§ï¼Œå…¶ä¸­ ChannelProvider æ¥å£æ˜¯å†…éƒ¨æ¥å£ï¼Œä¾›å®¢æˆ·ç«¯ä¾§å’ŒæœåŠ¡ç«¯ä¾§å®ç°ï¼Œä»¥åˆ†åˆ«è·å–å®¢æˆ·ç«¯çš„é€šé“ Channel å’ŒæœåŠ¡ç«¯çš„é€šé“ Channel é›†åˆã€‚ ä»»åŠ¡é€»è¾‘1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * ä»»åŠ¡é€»è¾‘ */@Overridepublic void run() &#123; try &#123; // å½“å‰æ—¶é—´ long now = System.currentTimeMillis(); //ä»ChannelProviderä¸­è·å–åˆ°éœ€è¦å¿ƒè·³æ£€æµ‹çš„channel for (Channel channel : channelProvider.getChannels()) &#123; // é€šé“å…³é—­åˆ™ä¸éœ€è¦æ£€æµ‹ if (channel.isClosed()) &#123; continue; &#125; try &#123; // ä»å¾…å¤„ç†æ£€æµ‹çš„Channelçš„é™„åŠ å±æ€§ä¸­è·å–æœ€åä¸€æ¬¡è¯»ã€å†™æ—¶é—´ Long lastRead = (Long) channel.getAttribute(HeaderExchangeHandler.KEY_READ_TIMESTAMP); Long lastWrite = (Long) channel.getAttribute(HeaderExchangeHandler.KEY_WRITE_TIMESTAMP); // æœ€åä¸€æ¬¡è¯»/å†™æ—¶é—´è¶…è¿‡å¿ƒè·³é—´éš”ï¼Œå°±ä¼šå‘é€å¿ƒè·³è¯·æ±‚ if ((lastRead != null &amp;&amp; now - lastRead &gt; heartbeat) || (lastWrite != null &amp;&amp; now - lastWrite &gt; heartbeat)) &#123; // åˆ›å»ºå¿ƒè·³è¯·æ±‚å¯¹è±¡ Request req = new Request(); req.setVersion(Version.getProtocolVersion()); // éœ€è¦å“åº” req.setTwoWay(true); // æ˜¯å¿ƒè·³äº‹ä»¶ req.setEvent(Request.HEARTBEAT_EVENT); // å‘é€å¿ƒè·³è¯·æ±‚ channel.send(req); if (logger.isDebugEnabled()) &#123; logger.debug(\"Send heartbeat to remote channel \" + channel.getRemoteAddress() + \", cause: The channel has no data-transmission exceeds a heartbeat period: \" + heartbeat + \"ms\"); &#125; &#125; // æœ€åä¸€æ¬¡è¯»æ—¶é—´è¶…è¿‡å¿ƒè·³è¶…æ—¶æ—¶é—´ï¼ˆ3 * å¿ƒè·³æ—¶é—´ï¼‰ï¼Œåˆ™å®¢æˆ·ç«¯é‡æ–°è¿æ¥æœåŠ¡ç«¯ï¼›æœåŠ¡ç«¯ç›´æ¥å…³é—­å®¢æˆ·ç«¯è¿æ¥ã€‚ if (lastRead != null &amp;&amp; now - lastRead &gt; heartbeatTimeout) &#123; logger.warn(\"Close channel \" + channel + \", because heartbeat read idle time out: \" + heartbeatTimeout + \"ms\"); // å®¢æˆ·ç«¯çš„é€šé“ï¼Œåˆ™é‡æ–°è¿æ¥æœåŠ¡ç«¯ if (channel instanceof Client) &#123; try &#123; ((Client) channel).reconnect(); &#125; catch (Exception e) &#123; //do nothing &#125; // æœåŠ¡ç«¯é€šé“ï¼Œåˆ™å…³é—­å®¢æˆ·ç«¯è¿æ¥ &#125; else &#123; channel.close(); &#125; &#125; &#125; catch (Throwable t) &#123; logger.warn(\"Exception when heartbeat to remote channel \" + channel.getRemoteAddress(), t); &#125; &#125; &#125; catch (Throwable t) &#123; logger.warn(\"Unhandled exception when heartbeat, cause: \" + t.getMessage(), t); &#125;&#125; å¿ƒè·³ä»»åŠ¡ä¸»è¦å·¥ä½œå¦‚ä¸‹ï¼š ä»ChannelProviderä¸­è·å–ä¸åŒä¾§çš„é€šé“ Channelï¼Œå®¢æˆ·ç«¯ä¾§åªæœ‰ä¸€ä¸ª Channel ï¼ŒæœåŠ¡ç«¯ä¾§æœ‰å¤šä¸ª Channelï¼Œä»»åŠ¡åªé’ˆå¯¹æœªå…³é—­çš„ Channel ã€‚ ä»å¾…å¤„ç†çš„Channelé™„åŠ å±æ€§ä¸­è·å–æœ€åä¸€æ¬¡è¯»ã€å†™æ—¶é—´ï¼Œç„¶åè®¡ç®—è·ç¦»å½“å‰çš„æ—¶é—´ï¼Œå¦‚æœå¤§äºå¿ƒè·³é—´éš”å°±ä¼šå‘é€ä¸€ä¸ªå¿ƒè·³è¯·æ±‚ç»™å¯¹ç«¯ï¼Œå› ä¸ºè¿™é‡Œæ—¢å¯èƒ½æ˜¯å®¢æˆ·ç«¯ä¾§é€šé“ä¹Ÿå¯èƒ½æ˜¯æœåŠ¡ç«¯ä¾§é€šé“ã€‚ æ ¹æ®æœ€åä¸€æ¬¡è¯»æ—¶é—´ï¼Œè®¡ç®—è·ç¦»å½“å‰çš„æ—¶é—´æ˜¯å¦å¤§äºå¿ƒè·³è¶…æ—¶æ—¶é—´ï¼Œå¦‚æœå¤§äºå¿ƒè·³è¶…æ—¶æ—¶é—´ï¼Œå®¢æˆ·ç«¯ä¾§ä¼šè¿›è¡Œé‡è¿æœåŠ¡ç«¯ï¼ŒæœåŠ¡ç«¯ä¾§ä¼šç«‹å³å…³é—­é€šé“ã€‚ å…¶ä¸­ç¬¬ 2 ä¸ªå·¥ä½œæ˜¯å¿ƒè·³æ£€æµ‹ï¼Œç¬¬ 3 ä¸ªå·¥ä½œæ˜¯æ–­çº¿é‡è¿ã€‚å€¼å¾—è¯´æ˜çš„æ˜¯ï¼ŒChannel é™„åŠ å±æ€§ä¸­çš„è¯»å†™æ—¶é—´ä¸»è¦æ˜¯å¿ƒè·³å¤„ç†å™¨ HeartbeatHandler è®°å½•çš„ï¼Œå…¶ connected() è®°å½•æœ€åä¸€æ¬¡è¯»å†™æ“ä½œæ—¶é—´ã€sent() è®°å½•æœ€åä¸€æ¬¡å†™æ“ä½œæ—¶é—´ã€received() è®°å½•æœ€åä¸€æ¬¡è¯»æ“ä½œæ—¶é—´ï¼Œè€Œ disconnected() ä¼šæ¸…ç†é€šé“ Channel ä¸­çš„è¯»å†™æ—¶é—´æˆ³ ã€‚ æœåŠ¡ç«¯Exchange å±‚çš„æœåŠ¡ç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸Šå›¾ä¸­çš„ Endpointã€Server å’Œ Resetable è¿™ä¸‰ä¸ªæ¥å£åœ¨å‰é¢çš„æ–‡ç« ä¸­å·²ç»è¯¦ç»†ä»‹ç»è¿‡äº†ï¼Œè¿™é‡Œä¸å†é‡å¤ï¼Œä¸‹é¢å¯¹ Exchange å±‚å®šä¹‰çš„ Server è¿›è¡Œè¯¦ç»†è¯´æ˜ã€‚ ExchangeServer æ¥å£1234567891011121314151617public interface ExchangeServer extends Server &#123; /** * è·å¾—ä¿¡æ¯äº¤æ¢é€šé“é›†åˆ * * @return channels */ Collection&lt;ExchangeChannel&gt; getExchangeChannels(); /** * æ ¹æ®åœ°å€è·å–ä¿¡æ¯äº¤æ¢é€šé“ * * @param remoteAddress * @return channel */ ExchangeChannel getExchangeChannel(InetSocketAddress remoteAddress);&#125; ExchangeServer ç»§æ‰¿äº† Server æ¥å£ï¼Œåœ¨å…¶åŸºç¡€ä¹‹ä¸Šæ–°å¢äº†ä¸¤ä¸ªå’Œä¿¡æ¯äº¤æ¢å±‚ç›¸å…³çš„é€šé“æ–¹æ³•ã€‚ HeaderExchangeServerHeaderExchangeServer å®ç°äº† ExchangeServer æ¥å£ï¼ŒåŸºäºæ¶ˆæ¯å¤´çš„ä¿¡æ¯äº¤æ¢æœåŠ¡å®ç°ç±»ï¼Œæ˜¯ Transport å±‚ Server çš„è£…é¥°å™¨ï¼Œå®ç°è‡ª Server æ¥å£çš„æ–¹æ³•ï¼ˆåŒ…æ‹¬ Server ç»§æ‰¿çš„æ¥å£ï¼‰å‡ ä¹éƒ½æ˜¯å§”æ‰˜ç»™è£…é¥°çš„ Server å¯¹è±¡ã€‚HeaderExchangeServer ä¸»è¦ä¸ºå…¶ä¿®é¥°çš„ Server æ·»åŠ äº†å®šæ—¶å‘é€å¿ƒè·³æ¶ˆæ¯çš„å®ç°ï¼Œç”¨ä»¥å…³é—­é•¿æ—¶é—´æ²¡æœ‰å®¢æˆ·ç«¯è¿æ¥çš„é€šé“ã€‚ å±æ€§123456789101112131415161718192021222324252627282930public class HeaderExchangeServer implements ExchangeServer &#123; protected final Logger logger = LoggerFactory.getLogger(getClass()); /** * å¿ƒè·³æ£€æµ‹ Schedule */ private final ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"dubbo-remoting-server-heartbeat\", true)); /** * è¢«è£…é¥°çš„ Transport å±‚çš„æœåŠ¡ */ private final Server server; /** * å¿ƒè·³æ£€æµ‹å®šæ—¶å™¨ Future */ private ScheduledFuture&lt;?&gt; heartbeatTimer; /** * å¿ƒè·³é—´éš”æ—¶é—´ï¼Œæ¯«ç§’ */ private int heartbeat; /** * å¿ƒè·³è¶…æ—¶æ—¶é—´ï¼Œæ¯«ç§’ */ private int heartbeatTimeout; /** * æ˜¯å¦å…³é—­ï¼Œé»˜è®¤éå…³é—­çŠ¶æ€ */ private AtomicBoolean closed = new AtomicBoolean(false);&#125; å…³é”®å±æ€§ Serverã€heartbeat ä»¥åŠ heartbeatTimeout æ˜¯åœ¨ HeaderExchangeServer æ„é€ æ–¹æ³•ä¸­å®Œæˆåˆå§‹åŒ–çš„ã€‚ æ„é€ æ–¹æ³•12345678910111213141516171819202122232425262728/** * æ„é€ æ–¹æ³• * @param server Transport å±‚çš„ Server å¯¹è±¡ */public HeaderExchangeServer(Server server) &#123; if (server == null) &#123; throw new IllegalArgumentException(\"server == null\"); &#125; // HeaderExchangeServer çš„å·¥ä½œéƒ½ä¼šå§”æ‰˜ç»™è¯¥å¯¹è±¡ this.server = server; // åœ¨æ­¤ä¹‹å‰ Constants.HEARTBEAT_KEY é»˜è®¤å·²ç»æœ‰å€¼äº†ï¼Œ å¦‚æœæ‰‹åŠ¨é…ç½®å°±ä½¿ç”¨é…ç½®çš„ï¼Œå¦‚æœæ²¡æœ‰é…ç½®é»˜è®¤æ˜¯ 60 this.heartbeat = server.getUrl().getParameter(Constants.HEARTBEAT_KEY, 0); // heartbeatTimeoutï¼šé»˜è®¤æ˜¯ heartbeat * 3 this.heartbeatTimeout = server.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * 3); // æ£€æµ‹å¿ƒè·³è¶…æ—¶æ—¶é—´æ˜¯å¦åˆæ³• if (heartbeatTimeout &lt; heartbeat * 2) &#123; throw new IllegalStateException(\"heartbeatTimeout &lt; heartbeatInterval * 2\"); &#125; /** * é»˜è®¤åœ¨ heartbeatï¼ˆé»˜è®¤æ˜¯60sï¼‰å†…å¦‚æœæ²¡æœ‰æ”¶åˆ°æ¶ˆæ¯ï¼Œå°±ä¼šå‘é€å¿ƒè·³æ¶ˆæ¯ï¼Œå¦‚æœè¿ç€3æ¬¡ï¼ˆé»˜è®¤180sï¼‰æ²¡æœ‰æ”¶åˆ°å¿ƒè·³å“åº”ï¼Œproviderä¼šå…³é—­ Channel ã€‚ */ startHeartbeatTimer(); &#125; æ„é€ æ–¹æ³•ä¸»è¦çš„å·¥ä½œå¦‚ä¸‹ï¼š å°è£… Transport å±‚çš„ Server å¯¹è±¡ï¼Œæ­¤å HeaderExchangeServer çš„æœåŠ¡å·¥ä½œéƒ½ä¼šäº¤ç»™è¯¥å¯¹è±¡ã€‚ è¯»å–å¿ƒè·³ç›¸å…³é…ç½®ï¼Œæ³¨æ„å¿ƒè·³é—´éš”å’Œå¿ƒè·³è¶…æ—¶æ—¶é—´çš„å…³ç³»ï¼Œä»¥åŠå„è‡ªçš„é»˜è®¤å€¼ å¯åŠ¨å¿ƒè·³æ£€æµ‹ Schedule å‘é€æ¶ˆæ¯12345678910111213141516+--- HeaderExchangeServer @Override public void send(Object message) throws RemotingException &#123; if (closed.get()) &#123; throw new RemotingException(this.getLocalAddress(), null, \"Failed to send message \" + message + \", cause: The server \" + getLocalAddress() + \" is closed!\"); &#125; server.send(message); &#125; @Override public void send(Object message, boolean sent) throws RemotingException &#123; if (closed.get()) &#123; throw new RemotingException(this.getLocalAddress(), null, \"Failed to send message \" + message + \", cause: The server \" + getLocalAddress() + \" is closed!\"); &#125; server.send(message, sent); &#125; å‘é€æ¶ˆæ¯æ˜¯äº¤ç»™è£…é¥°çš„ server æ¥å®Œæˆï¼Œåº•å±‚è¿˜æ˜¯åˆ©ç”¨ Channel æ¥å‘é€ã€‚ å¼€å¯å¿ƒè·³å®šæ—¶ä»»åŠ¡12345678910111213141516171819+--- HeaderExchangeServer private void startHeartbeatTimer() &#123; // å…³é—­åŸæœ‰å®šæ—¶ä»»åŠ¡ stopHeartbeatTimer(); // å‘èµ·æ–°çš„å®šæ—¶ä»»åŠ¡ if (heartbeat &gt; 0) &#123; heartbeatTimer = scheduled.scheduleWithFixedDelay( new HeartBeatTask(new HeartBeatTask.ChannelProvider() &#123; @Override public Collection&lt;Channel&gt; getChannels() &#123; /** * è·å–NettyServerä¸­çš„å…¨éƒ¨channelè¿æ¥ï¼ŒServer æŒæœ‰å¤šä¸ªClient è¿æ¥çš„ Channel */ return Collections.unmodifiableCollection(HeaderExchangeServer.this.getChannels()); &#125; &#125;, heartbeat, heartbeatTimeout), heartbeat, heartbeat, TimeUnit.MILLISECONDS); &#125; &#125; å¼€å¯å¿ƒè·³å®šæ—¶ä»»åŠ¡å’Œ HeaderExchangeClient ä¸­çš„é€»è¾‘ä¸€æ ·ï¼ŒåŒºåˆ«åœ¨ HeaderExchangeServer å¯ä»¥æŒæœ‰å¤šä¸ªè¿æ¥ï¼Œè·å–è¿æ¥ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425+--- HeaderExchangeServer @Override @SuppressWarnings(&#123;\"unchecked\", \"rawtypes\"&#125;) public Collection&lt;Channel&gt; getChannels() &#123; return (Collection) getExchangeChannels(); &#125; /** * è·å–NettyServerä¸­çš„å…¨éƒ¨channelè¿æ¥ * * @return */ @Override public Collection&lt;ExchangeChannel&gt; getExchangeChannels() &#123; Collection&lt;ExchangeChannel&gt; exchangeChannels = new ArrayList&lt;ExchangeChannel&gt;(); // è·å– server ç»´æŠ¤çš„ Channel é€šé“é›†åˆ Collection&lt;Channel&gt; channels = server.getChannels(); if (channels != null &amp;&amp; !channels.isEmpty()) &#123; for (Channel channel : channels) &#123; // æ ¹æ® Channel è·å– Exchange å±‚çš„ Channel exchangeChannels.add(HeaderExchangeChannel.getOrAddChannel(channel)); &#125; &#125; return exchangeChannels; &#125; å…³äºå¿ƒè·³ä»»åŠ¡å·²ç»åœ¨å‰æ–‡ä¸­è¯¦ç»†è¯´æ˜ï¼Œè¿™é‡Œä¸å†é‡å¤ä»‹ç»ã€‚ ä¼˜é›…å…³é—­12345678910111213141516171819202122232425262728293031+--- HeaderExchangeServer @Override public void close(final int timeout) &#123; // å°†è£…é¥°çš„serverçš„closingè®¾ç½®ä¸º trueï¼Œè¡¨ç¤ºå½“å‰serverå¤„äºæ­£åœ¨å…³é—­çŠ¶æ€ï¼Œä¸å†ä¸Clientå»ºç«‹è¿æ¥ startClose(); if (timeout &gt; 0) &#123; final long max = timeout; final long start = System.currentTimeMillis(); // å‘é€ READONLY äº‹ä»¶ç»™æ‰€æœ‰ Client ï¼Œè¡¨ç¤ºServerä¸å†æ¥æ”¶æ–°çš„æ¶ˆæ¯ if (getUrl().getParameter(Constants.CHANNEL_SEND_READONLYEVENT_KEY, true)) &#123; // å¹¿æ’­å®¢æˆ·ç«¯ï¼ŒREADONLY_EVENT äº‹ä»¶æ¶ˆæ¯ sendChannelReadOnlyEvent(); &#125; // ç­‰å¾… Client ä¸ å½“å‰Server ç»´æŒçš„é•¿è¿æ¥å…¨éƒ¨æ–­å¼€æˆ–è¶…æ—¶ while (HeaderExchangeServer.this.isRunning() &amp;&amp; System.currentTimeMillis() - start &lt; max) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; &#125; // å…³é—­å¿ƒè·³å®šæ—¶ä»»åŠ¡ï¼Œä¸”å°†è‡ªèº«closedè®¾ç½®ä¸ºtrue doClose(); // å…³é—­Transportå±‚çš„Server server.close(timeout); &#125; æœåŠ¡å…³é—­æµç¨‹éå¸¸é‡è¦ï¼Œä¸‹é¢å¯¹ HeaderExchangeServer ä¼˜é›…å…³é—­çš„è¿‡ç¨‹è¿›è¡Œè¯¦ç»†è¯´æ˜ï¼š è°ƒç”¨ startClose() æ–¹æ³•å°†è¢«è£…é¥°çš„ Server çš„ closing è®¾ç½®ä¸º trueï¼Œè¡¨ç¤ºè¯¥ Server ç«¯å¤„äºæ­£åœ¨å…³é—­çŠ¶æ€ä¸å†ä¸ Client å»ºç«‹è¿æ¥ã€‚1234567891011121314151617+--- HeaderExchangeServer @Override public void startClose() &#123; server.startClose(); &#125;+--- AbstractServer @Override public void connected(Channel ch) throws RemotingException &#123; // å¦‚æœ Server å¤„äºæ­£åœ¨å…³é—­çŠ¶æ€æˆ–å…³é—­çŠ¶æ€ï¼Œåˆ™ä¸å†æ¥æ”¶æ–°è¿æ¥ if (this.isClosing() || this.isClosed()) &#123; logger.warn(\"Close new channel \" + ch + \", cause: server is closing or has been closed. For example, receive a new connect request while in shutdown process.\"); // å…³é—­æ–°å»ºçš„ Client ch.close(); return; &#125; &#125; å‘é€ READONLY äº‹ä»¶ç»™æ‰€æœ‰ Client ï¼Œè¡¨ç¤º Server ä¸å†æ¥æ”¶æ–°çš„æ¶ˆæ¯ï¼Œé¿å…æœ‰æ–°çš„æ¶ˆæ¯å‘é€è¿‡æ¥ã€‚åœ¨æ”¶åˆ°è¯¥æ¶ˆæ¯åï¼ŒClient ç«¯çš„ HeaderExchangeHandler ä¼šåœ¨ Channel ä¸Šæ·»åŠ  key ä¸º channel.readonly çš„é™„åŠ ä¿¡æ¯ï¼Œä¸Šå±‚è°ƒç”¨æ–¹ä¼šæ ¹æ®è¯¥é™„åŠ ä¿¡æ¯åˆ¤æ–­è¯¥è¿æ¥æ˜¯å¦å¯å†™ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647+--- HeaderExchangeServerprivate void sendChannelReadOnlyEvent() &#123; // åˆ›å»º READONLY_EVENT è¯·æ±‚ Request request = new Request(); request.setEvent(Request.READONLY_EVENT); // åªè¯»è¯·æ±‚ä¸éœ€è¦å“åº” request.setTwoWay(false); request.setVersion(Version.getProtocolVersion()); // å‘é€ç»™æ‰€æœ‰ Client Collection&lt;Channel&gt; channels = getChannels(); for (Channel channel : channels) &#123; try &#123; if (channel.isConnected()) &#123; channel.send(request, getUrl().getParameter(Constants.CHANNEL_READONLYEVENT_SENT_KEY, true)); &#125; &#125; catch (RemotingException e) &#123; logger.warn(\"send cannot write message error.\", e); &#125; &#125; &#125;+--- DubboInvoker /** * è¿æ¥æ˜¯å¦æœ‰æ•ˆï¼ŒServer å…·æœ‰ä¸€ç¥¨å¦å†³æƒ * * @return */ @Override public boolean isAvailable() &#123; if (!super.isAvailable()) &#123; return false; &#125; for (ExchangeClient client : clients) &#123; /** * å³ä½¿Clientå¤„äºè¿æ¥ä¸­ï¼Œä½†å¦‚æœ Server å¤„äºæ­£åœ¨å…³é—­ä¸­ï¼Œè¿æ¥ä¹Ÿæ˜¯ä¸å¯ç”¨çš„ã€‚[channel.readonly çš„é™„åŠ ä¿¡æ¯çš„ä½œç”¨åœ¨è¿™é‡Œ] * * &#123;@link HeaderExchangeServer#sendChannelReadOnlyEvent()&#125; */ if (client.isConnected() &amp;&amp; !client.hasAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY)) &#123; //cannot write == not Available ? return true; &#125; &#125; return false; &#125; ç¬¬ 2 æ­¥å®Œæˆåï¼Œç­‰å¾…æ‰€æœ‰çš„ Client ä¸ å½“å‰ Server ç»´æŒçš„é•¿è¿æ¥æ–­å¼€æˆ–è¶…æ—¶ã€‚12345678910private boolean isRunning() &#123; Collection&lt;Channel&gt; channels = getChannels(); for (Channel channel : channels) &#123; // å­˜åœ¨ä»»æ„ä¸€ä¸ªClientä¸å½“å‰Serverå¤„äºè¿æ¥çŠ¶æ€ï¼ŒServer éƒ½ä¸èƒ½ä¸å…³é—­ if (channel.isConnected()) &#123; return true; &#125; &#125; return false; &#125; ç¬¬ 3 æ­¥å®Œæˆåï¼Œè°ƒç”¨ doClose() æ–¹æ³•å…³é—­å¿ƒè·³å®šæ—¶ä»»åŠ¡ï¼Œä¸”å°† closed å­—æ®µæ›´æ–°ä¸º trueã€‚1234567891011private void doClose() &#123; if (!closed.compareAndSet(false, true)) &#123; return; &#125; stopHeartbeatTimer(); try &#123; scheduled.shutdown(); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125;&#125; çœŸæ­£å…³é—­æœåŠ¡å™¨å³Transportå±‚çš„Server ï¼Œå¦‚ä½¿ç”¨ Netty ä½œä¸º NIO ç»„ä»¶ï¼Œå…³é—­çš„å°±æ˜¯ NettyServer ã€‚ NettyServer.close() æ–¹æ³•ä¼šå…ˆè°ƒç”¨ AbstractPeer çš„ close() æ–¹æ³•å°†è‡ªèº«çš„ closed å­—æ®µè®¾ç½®ä¸º trueã€‚12345678910111213141516171819@Override public void close() &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Close \" + getClass().getSimpleName() + \" bind \" + getBindAddress() + \", export \" + getLocalAddress()); &#125; ExecutorUtil.shutdownNow(executor, 100); try &#123; // è®¾ç½®çˆ¶ç±»ä¸­çš„ closed å­—æ®µä¸ºtrue super.close(); &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; try &#123; // è°ƒç”¨å­ç±»å®ç°ï¼Œå…³é—­å…·ä½“æœåŠ¡ doClose(); &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; è°ƒç”¨ doClose() æ–¹æ³•å…³é—­ boss Channel å³æ¥æ”¶å®¢æˆ·ç«¯è¿æ¥çš„ Channelï¼›å…³é—­ä¸ Client ä¹‹é—´çš„è¿æ¥å¹¶æ¸…ç† channels é›†åˆï¼›æœ€åï¼Œå…³é—­ bossGroup å’Œ workerGroup ä¸¤ä¸ªçº¿ç¨‹ç»„ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445@Overrideprotected void doClose() throws Throwable &#123; try &#123; if (channel != null) &#123; // å…³é—­æœåŠ¡å™¨é€šé“ channel.close(); &#125; &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; // å…³é—­è¿æ¥åˆ°æœåŠ¡å™¨çš„å®¢æˆ·ç«¯é€šé“ try &#123; Collection&lt;com.alibaba.dubbo.remoting.Channel&gt; channels = getChannels(); if (channels != null &amp;&amp; channels.size() &gt; 0) &#123; // ä¾æ¬¡éå†è¿æ¥åˆ°æœåŠ¡å™¨çš„å®¢æˆ·ç«¯é€šé“ï¼Œç„¶åè¿›è¡Œå…³é—­æ“ä½œ for (com.alibaba.dubbo.remoting.Channel channel : channels) &#123; try &#123; channel.close(); &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; &#125; &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; // ä¼˜é›…å…³é—­çº¿ç¨‹ç»„ try &#123; if (bootstrap != null) &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; // æ¸…ç©ºè¿æ¥åˆ°æœåŠ¡å™¨çš„å®¢æˆ·ç«¯é€šé“ try &#123; if (channels != null) &#123; channels.clear(); &#125; &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125;&#125; HeaderExchangeServer ä¸­çš„å…¶å®ƒæ–¹æ³•ä¸æ˜¯å¾ˆé‡è¦å°±ä¸ä¸€ä¸€ä»‹ç»äº†ï¼Œè‡³æ­¤ Exchange å±‚çš„æœåŠ¡å®ç°éƒ¨åˆ†ä»‹ç»å®Œæ¯•äº†ï¼Œé­”é¬¼å­˜åœ¨äºç»†èŠ‚ä¹‹ä¸­ã€‚ ç¼–è§£ç å™¨Exchange å±‚ç¼–è§£ç å™¨ç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š TransportCodec åŠä¸Šå±‚ç¼–è§£ç å™¨å·²ç»åœ¨ Transport å±‚è¯¦ç»†è¯´æ˜ï¼ŒTelnetCodec ç»§æ‰¿äº† TransportCodec åºåˆ—åŒ–å’Œååºåˆ—åŒ–çš„åŸºæœ¬èƒ½åŠ›ï¼ŒåŒæ—¶è¿˜æä¾›äº†å¯¹ Telnet å‘½ä»¤å¤„ç†çš„èƒ½åŠ›ã€‚è€Œ ExchangeCodec æ˜¯åœ¨ TelnetCodec çš„åŸºç¡€ä¹‹ä¸Šæ·»åŠ äº†å¤„ç†åè®®å¤´çš„èƒ½åŠ›ã€‚è€ƒè™‘åˆ°ç¼–è§£ç å™¨åœ¨ Dubbo åè®®çš„ç½‘ç»œä¼ è¾“ä¸­æ‰®æ¼”ç€é‡è¦è§’è‰²ï¼Œå¹¶ä¸”é€»è¾‘ç›¸å¯¹æ¯”è¾ƒå¤æ‚ï¼Œå› æ­¤ä¼šå•ç‹¬èµ·ä¸€ç¯‡æ–‡ç« å¯¹æ•´ä¸ªç¼–è§£ç å™¨ä½“ç³»è¿›è¡Œè¯¦ç»†åˆ†æï¼Œè¿™é‡Œå…ˆä¸è¿›è¡Œå±•å¼€è¯´æ˜ï¼Œæˆ‘ä»¬ä¸‹ä¸€ç¯‡æ–‡ç« è§ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« å¼€ç¯‡å¯¹ Exchange å±‚äº§ç”Ÿçš„èƒŒæ™¯è¿›è¡Œäº†ç®€å•è¯´æ˜ï¼Œéšåä» Exchange å±‚çš„æ ¸å¿ƒæ¨¡å‹ Request å’Œ Response å‡ºå‘ï¼Œç„¶åä»¥ Exchanger æ¥å£åŠå…¶å®ç°ä¸ºä¸­å¿ƒå¼•å‡º Exchange å±‚çš„æ ¸å¿ƒç»„ä»¶ï¼Œå…ˆæ˜¯å¯¹ Exchange å±‚çš„ Channel è¿›è¡Œè¯´æ˜ï¼ŒåŒæ—¶å¯¹å…¶å…³è”çš„ ResponseFuture è¿›è¡Œäº†åˆ†æï¼Œå®ƒæ˜¯å®ç° Dubbo è°ƒç”¨æ–¹å¼è½¬æ¢çš„å…³é”®ã€‚æ¥ç€å¯¹ Exchange å±‚çš„ ChannelHandler è¿›è¡Œäº†æ·±å…¥åˆ†æï¼ŒHeartbeatHandler å’Œå¿ƒè·³ä»»åŠ¡ HeartBeatTask æ˜¯å¯¹å¿ƒè·³æ£€æµ‹å’Œæ–­çº¿é‡è¿çš„å¤„ç†ï¼ŒHeaderExchangeHandler ç»“åˆ DefaultFuture å¯¹è¯·æ±‚-å“åº”ç»Ÿä¸€å¤„ç†ï¼ŒExchangeHandler æ˜¯ Exchange å±‚å®šä¹‰çš„ä¾›ä¸Šå±‚ä½¿ç”¨çš„ä¿¡æ¯äº¤æ¢å¤„ç†å™¨ã€‚æœ€åå¯¹ Exchange å±‚çš„ Client å’Œ Server è¿›è¡Œäº†è¯´æ˜ã€‚æ–‡ç« æœ€åï¼Œå¯¹ Exchange å±‚çš„ç¼–è§£ç å™¨è¿›è¡Œäº†ç®€å•ä»‹ç»ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - çº¿ç¨‹æ± ","slug":"rpc/threadpool","date":"2020-06-12T14:42:08.000Z","updated":"2020-12-16T10:02:30.509Z","comments":false,"path":"posts/f3cd85ef/","link":"","permalink":"https://gentryhuang.com/posts/f3cd85ef/","excerpt":"","text":"å‰è¨€åœ¨ ç½‘ç»œä¼ è¾“å±‚ ä¸­æˆ‘ä»¬ä»‹ç» WrappedChannelHandler ç±»çš„æ„é€ æ–¹æ³•æ—¶ï¼Œæåˆ°äº†çº¿ç¨‹æ± çš„åˆ›å»ºçš„ï¼Œæœ¬ç¯‡æ–‡ç« æˆ‘ä»¬å¯¹çº¿ç¨‹æ± éƒ¨åˆ†è¯¦ç»†åˆ†æã€‚ æ¦‚è¿°åœ¨ Dubbo çš„çº¿ç¨‹æ¨¡å‹ä¸­ï¼ŒDubbo æä¾›äº†å››ç§çº¿ç¨‹æ± çš„å®ç°ï¼Œå…·ä½“å¦‚ä¸‹ï¼š fixed å›ºå®šå¤§å°çº¿ç¨‹æ± ï¼Œå¯åŠ¨æ—¶å»ºç«‹çº¿ç¨‹ï¼Œä¸å…³é—­ï¼Œä¸€ç›´æŒæœ‰ã€‚(ç¼ºçœ) cached ç¼“å­˜çº¿ç¨‹æ± ï¼Œç©ºé—²ä¸€å®šæ—¶é—´è‡ªåŠ¨åˆ é™¤ï¼Œéœ€è¦æ—¶é‡å»ºã€‚ limited å¯ä¼¸ç¼©çº¿ç¨‹æ± ï¼Œä½†æ± ä¸­çš„çº¿ç¨‹æ•°åªä¼šå¢é•¿ä¸ä¼šæ”¶ç¼©ã€‚åªå¢é•¿ä¸æ”¶ç¼©çš„ç›®çš„æ˜¯ä¸ºäº†é¿å…æ”¶ç¼©æ—¶çªç„¶æ¥äº†å¤§æµé‡å¼•èµ·çš„æ€§èƒ½é—®é¢˜ã€‚ eager ä¼˜å…ˆåˆ›å»ºWorkerçº¿ç¨‹æ± ã€‚åœ¨ä»»åŠ¡æ•°é‡å¤§äºcorePoolSizeä½†æ˜¯å°äºmaximumPoolSizeæ—¶ï¼Œä¼˜å…ˆåˆ›å»ºWorkeræ¥å¤„ç†ä»»åŠ¡ã€‚å½“ä»»åŠ¡æ•°é‡å¤§äºmaximumPoolSizeæ—¶ï¼Œå°†ä»»åŠ¡æ”¾å…¥é˜»å¡é˜Ÿåˆ—ä¸­ã€‚é˜»å¡é˜Ÿåˆ—å……æ»¡æ—¶æŠ›å‡ºRejectedExecutionExceptionã€‚(ç›¸æ¯”äºcached:cachedåœ¨ä»»åŠ¡æ•°é‡è¶…è¿‡maximumPoolSizeæ—¶ç›´æ¥æŠ›å‡ºå¼‚å¸¸è€Œä¸æ˜¯å°†ä»»åŠ¡æ”¾å…¥é˜»å¡é˜Ÿåˆ—) ä¸€èˆ¬æƒ…å†µä¸‹ï¼ŒDubbo çº¿ç¨‹æ± å’Œ Dubbo æ¶ˆæ¯æ´¾å‘ç­–ç•¥ç»„åˆä½¿ç”¨ï¼Œå³é…ç½® Dubbo ä¸­çš„çº¿ç¨‹æ¨¡å‹ï¼Œä»¥åº”å¯¹ä¸åŒçš„åœºæ™¯ã€‚å¦‚ä¸‹é¢çš„é…ç½®æ¡ˆä¾‹ï¼š 1&lt;dubbo:protocol name=\"dubbo\" dispatcher=\"all\" threadpool=\"fixed\" threads=\"100\" /&gt; æœ‰å…³æ¶ˆæ¯æ´¾å‘æœºåˆ¶éƒ¨åˆ†åœ¨ ç½‘ç»œä¼ è¾“å±‚ ä¸­å·²ç»è¯¦ç»†è¯´æ˜ï¼Œè¿™é‡Œä¸å†ä»‹ç»ã€‚çº¿ç¨‹æ± ç›¸å…³çš„æ¥å£å’Œå®ç°ä½äº dubbo-common æ¨¡å—ä¸­ï¼Œä¸‹é¢æˆ‘ä»¬å¼€å§‹ä»‹ç» Dubbo çº¿ç¨‹æ¨¡å‹ä¸­çš„çº¿ç¨‹æ± éƒ¨åˆ†ã€‚ ThreadPool1234567891011@SPI(\"fixed\")public interface ThreadPool &#123; /** * çº¿ç¨‹æ± æ‰§è¡Œå™¨ * * @param url URL contains thread parameter * @return thread pool */ @Adaptive(&#123;Constants.THREADPOOL_KEY&#125;) Executor getExecutor(URL url);&#125; ThreadPool æ¥å£è¢« @SPI æ³¨è§£ä¿®é¥°ï¼Œæ˜¯ Dubbo çš„æ‰©å±•ç‚¹ï¼Œé»˜è®¤æ‰©å±•å®ç°åä¸º fixed ï¼Œå¯¹åº”çš„æ‰©å±•å®ç°ä¸º FixedThreadPool ã€‚ThreadPool æ¥å£ä¸­çš„ getExecutor() æ–¹æ³•è¢« @Adaptive æ³¨è§£ä¿®é¥°ï¼Œä¼šåŠ¨æ€ç”Ÿæˆè‡ªé€‚åº”ç±»å³é€‚é…å™¨ç±»ï¼Œè¯¥ç±»ä¼šä¼˜å…ˆæ ¹æ® url.threadpool å‚æ•°é€‰æ‹© ThreadPool çš„æ‰©å±•å®ç°ã€‚çº¿ç¨‹æ±  SPI é…ç½®å¦‚ä¸‹ï¼š 1234fixed&#x3D;com.alibaba.dubbo.common.threadpool.support.fixed.FixedThreadPoolcached&#x3D;com.alibaba.dubbo.common.threadpool.support.cached.CachedThreadPoollimited&#x3D;com.alibaba.dubbo.common.threadpool.support.limited.LimitedThreadPooleager&#x3D;com.alibaba.dubbo.common.threadpool.support.eager.EagerThreadPool ThreadPool ç»§æ‰¿å…³ç³» UML å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸åŒçš„ ThreadPool æ‰©å±•å®ç°ä¼šæ ¹æ® URL å‚æ•°åˆ›å»ºä¸åŒç‰¹æ€§çš„çº¿ç¨‹æ± ã€‚ FixedThreadPoolå›ºå®šå¤§å°çº¿ç¨‹æ± ï¼Œå¯åŠ¨æ—¶å»ºç«‹çº¿ç¨‹ï¼Œä¸å…³é—­ï¼Œä¸€ç›´æŒæœ‰ï¼Œæ˜¯ Dubbo é»˜è®¤çš„çº¿ç¨‹æ± ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738public class FixedThreadPool implements ThreadPool &#123; @Override public Executor getExecutor(URL url) &#123; // çº¿ç¨‹åï¼Œè·å– url.threadname çš„å€¼ï¼Œé»˜è®¤ä¸º Dubbo String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME); // çº¿ç¨‹æ•°ï¼Œè·å– url.threads çš„å€¼ï¼Œé»˜è®¤ä¸º 200 int threads = url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS); // é˜Ÿåˆ—æ•°ï¼Œè·å– url.queues çš„å€¼ï¼Œé»˜è®¤ä¸º 0 int queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES); // åˆ›å»ºçº¿ç¨‹æ± æ‰§è¡Œå™¨ return new ThreadPoolExecutor( /* æ ¸å¿ƒçº¿ç¨‹æ•°*/ threads, /* æœ€å¤§çº¿ç¨‹æ•° */ threads, /* ç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´ */ 0, /* ç©ºé—²å­˜æ´»æ—¶é—´å•ä½ */ TimeUnit.MILLISECONDS, /* é˜»å¡é˜Ÿåˆ—,æ ¹æ®é…ç½®çš„é˜Ÿåˆ—æ•°ï¼Œé€‰æ‹©å¯¹åº”çš„é˜Ÿåˆ— * 1 queues == 0 - SynchronousQueue * 2 queues &lt; 0 - LinkedBlockingQueue * 3 queues &gt; 0 - å¸¦é˜Ÿåˆ—æ•°çš„LinkedBlockingQueue */ queues == 0 ? new SynchronousQueue&lt;Runnable&gt;() : (queues &lt; 0 ? new LinkedBlockingQueue&lt;Runnable&gt;() : new LinkedBlockingQueue&lt;Runnable&gt;(queues)), /* çº¿ç¨‹å·¥å‚ */ new NamedInternalThreadFactory(name, true), /* æ‹’ç»ç­–ç•¥ */ new AbortPolicyWithReport(name, url) ); &#125; /** * é…ç½®æ–¹å¼:ä½¿ç”¨ &lt;dubbo:parameter key=\"xxx\" value=\"yyy\" /&gt; é…ç½® */&#125; FixedThreadPool çš„æ ¸å¿ƒçº¿ç¨‹æ•°å’Œæœ€å¤§çº¿ç¨‹æ•°ä¸€è‡´ï¼Œä¸”ä¸ä¼šè¢«å›æ”¶ã€‚ CacheThreadPoolç¼“å­˜çº¿ç¨‹æ± ï¼Œç©ºé—²ä¸€å®šæ—¶é—´è‡ªåŠ¨åˆ é™¤ï¼Œéœ€è¦æ—¶é‡å»ºã€‚ 12345678910111213141516171819202122232425262728293031323334353637public class CachedThreadPool implements ThreadPool &#123; @Override public Executor getExecutor(URL url) &#123; // çº¿ç¨‹åï¼Œè·å– url.threadname çš„å€¼ï¼Œé»˜è®¤ä¸º Dubbo String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME); // æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œè·å– url.corethreads çš„å€¼ï¼Œé»˜è®¤ä¸º 0 int cores = url.getParameter(Constants.CORE_THREADS_KEY, Constants.DEFAULT_CORE_THREADS); // æœ€å¤§çº¿ç¨‹æ•°ï¼Œè·å– url.threads çš„å€¼ï¼Œé»˜è®¤ä¸º Integer çš„æœ€å¤§å€¼ int threads = url.getParameter(Constants.THREADS_KEY, Integer.MAX_VALUE); // é˜Ÿåˆ—æ•°ï¼Œè·å– url.queues çš„å€¼ï¼Œé»˜è®¤ä¸º 0 int queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES); // çº¿ç¨‹å­˜æ´»æ—¶é•¿ï¼Œè·å– url.alive çš„å€¼ï¼Œé»˜è®¤ä¸º 60 * 1000 int alive = url.getParameter(Constants.ALIVE_KEY, Constants.DEFAULT_ALIVE); // åˆ›å»ºæ‰§è¡Œå™¨ return new ThreadPoolExecutor( cores, threads, alive, TimeUnit.MILLISECONDS, /* é˜»å¡é˜Ÿåˆ—,æ ¹æ®é…ç½®çš„é˜Ÿåˆ—æ•°ï¼Œé€‰æ‹©å¯¹åº”çš„é˜Ÿåˆ— * 1 queues == 0 - SynchronousQueue * 2 queues &lt; 0 - LinkedBlockingQueue * 3 queues &gt; 0 - å¸¦é˜Ÿåˆ—æ•°çš„LinkedBlockingQueue */ queues == 0 ? new SynchronousQueue&lt;Runnable&gt;() : (queues &lt; 0 ? new LinkedBlockingQueue&lt;Runnable&gt;() : new LinkedBlockingQueue&lt;Runnable&gt;(queues)), /* çº¿ç¨‹å·¥å‚ */ new NamedInternalThreadFactory(name, true), /* æ‹’ç»ç­–ç•¥ */ new AbortPolicyWithReport(name, url) ); /** * é…ç½®æ–¹å¼:ä½¿ç”¨ &lt;dubbo:parameter key=\"xxx\" value=\"yyy\" /&gt; é…ç½® */ &#125;&#125; CacheThreadPool ç¼“å­˜çº¿ç¨‹æ± ï¼Œå¯ä»¥æŒ‡å®šæ ¸å¿ƒçº¿ç¨‹æ•°ã€æœ€å¤§çº¿ç¨‹æ•°ã€ç¼“å†²é˜Ÿåˆ—é•¿åº¦ç©ºä»¥åŠç©ºé—²æ—¶é—´ï¼Œç©ºé—²ä¸€å®šæ—¶é—´éæ ¸å¿ƒçº¿ç¨‹ä¼šè¢«å›æ”¶ï¼Œéœ€è¦æ—¶é‡å»ºã€‚ LimitedThreadPoolå¯ä¼¸ç¼©çº¿ç¨‹æ± ï¼Œä½†æ± ä¸­çš„çº¿ç¨‹æ•°åªä¼šå¢é•¿ä¸ä¼šæ”¶ç¼©ã€‚åªå¢é•¿ä¸æ”¶ç¼©çš„ç›®çš„æ˜¯ä¸ºäº†é¿å…æ”¶ç¼©æ—¶çªç„¶æ¥äº†å¤§æµé‡å¼•èµ·çš„æ€§èƒ½é—®é¢˜ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839public class LimitedThreadPool implements ThreadPool &#123; @Override public Executor getExecutor(URL url) &#123; // çº¿ç¨‹åï¼Œè·å– url.threadname çš„å€¼ï¼Œé»˜è®¤ä¸º Dubbo String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME); // æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œè·å– url.corethreads çš„å€¼ï¼Œé»˜è®¤ä¸º 0 int cores = url.getParameter(Constants.CORE_THREADS_KEY, Constants.DEFAULT_CORE_THREADS); // æœ€å¤§çº¿ç¨‹æ•°ï¼Œè·å– url.threads çš„å€¼ï¼Œé»˜è®¤ä¸º 200 int threads = url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS); // é˜Ÿåˆ—æ•°ï¼Œè·å– url.queues çš„å€¼ï¼Œé»˜è®¤ä¸º 0 int queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES); // åˆ›å»ºæ‰§è¡Œå™¨ return new ThreadPoolExecutor( cores, threads, /** ç©ºé—²æ—¶é—´æ— é™å¤§ï¼Œå³ä¸ä¼šè‡ªåŠ¨åˆ é™¤ */ Long.MAX_VALUE, TimeUnit.MILLISECONDS, /* é˜»å¡é˜Ÿåˆ—,æ ¹æ®é…ç½®çš„é˜Ÿåˆ—æ•°ï¼Œé€‰æ‹©å¯¹åº”çš„é˜Ÿåˆ— * 1 queues == 0 - SynchronousQueue * 2 queues &lt; 0 - LinkedBlockingQueue * 3 queues &gt; 0 - å¸¦é˜Ÿåˆ—æ•°çš„LinkedBlockingQueue */ queues == 0 ? new SynchronousQueue&lt;Runnable&gt;() : (queues &lt; 0 ? new LinkedBlockingQueue&lt;Runnable&gt;() : new LinkedBlockingQueue&lt;Runnable&gt;(queues)), /* çº¿ç¨‹å·¥å‚ */ new NamedInternalThreadFactory(name, true), /* æ‹’ç»ç­–ç•¥ */ new AbortPolicyWithReport(name, url) ); &#125; /** * é…ç½®æ–¹å¼: ä½¿ç”¨ &lt;dubbo:parameter /&gt; é…ç½® */&#125; LimitedThreadPool å¯ä¼¸ç¼©çº¿ç¨‹æ± ï¼Œå¯ä»¥æŒ‡å®šæ ¸å¿ƒçº¿ç¨‹æ•°ã€æœ€å¤§çº¿ç¨‹æ•°ä»¥åŠç¼“å†²é˜Ÿåˆ—é•¿åº¦ï¼ŒLimitedThreadPool åˆ›å»ºçš„çº¿ç¨‹æ± çš„éæ ¸å¿ƒçº¿ç¨‹ä¸ä¼šè¢«å›æ”¶ã€‚ ä»¥ä¸Šä¸‰ç§ç±»å‹çš„çº¿ç¨‹æ± éƒ½æ˜¯åŸºäº JDK ThreadPoolExecutor çº¿ç¨‹æ± ï¼Œåœ¨æ ¸å¿ƒçº¿ç¨‹å…¨éƒ¨è¢«å ç”¨çš„æ—¶å€™ä¼šå…ˆæŠŠä»»åŠ¡æ”¾åˆ°ç¼“å†²é˜Ÿåˆ—ä¸­ï¼Œå½“ç¼“å†²é˜Ÿåˆ—æ»¡äº†ä¹‹åï¼Œæ‰ä¼šå°è¯•åˆ›å»ºæ–°çº¿ç¨‹æ¥å¤„ç†ä»»åŠ¡ã€‚EagerThreadPool åˆ™æœ‰å¾ˆå¤§å·®å¼‚ï¼Œå…·ä½“æˆ‘ä»¬æ¥ç€åˆ†æã€‚ EagerThreadPool123456789101112131415161718192021222324252627282930313233343536373839public class EagerThreadPool implements ThreadPool &#123; @Override public Executor getExecutor(URL url) &#123; // çº¿ç¨‹åï¼Œè·å– url.threadname çš„å€¼ï¼Œé»˜è®¤ä¸º Dubbo String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME); // æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œè·å– url.corethreads çš„å€¼ï¼Œé»˜è®¤ä¸º 0 int cores = url.getParameter(Constants.CORE_THREADS_KEY, Constants.DEFAULT_CORE_THREADS); // æœ€å¤§çº¿ç¨‹æ•°ï¼Œè·å– url.threads çš„å€¼ï¼Œé»˜è®¤ä¸º Integer çš„æœ€å¤§å€¼ int threads = url.getParameter(Constants.THREADS_KEY, Integer.MAX_VALUE); // é˜Ÿåˆ—æ•°ï¼Œè·å– url.queues çš„å€¼ï¼Œé»˜è®¤ä¸º 0 int queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES); // çº¿ç¨‹å­˜æ´»æ—¶é•¿ï¼Œè·å– url.alive çš„å€¼ï¼Œé»˜è®¤ä¸º 60 * 1000 int alive = url.getParameter(Constants.ALIVE_KEY, Constants.DEFAULT_ALIVE); // åˆ›å»ºä»»åŠ¡é˜Ÿåˆ—ï¼Œæ³¨æ„è™½ç„¶æ˜¯ LinkedBlockingQueue ç±»å‹ï¼Œä½†ç”±äºè®¾ç½®å¤§å°äº†ï¼Œå› æ­¤å˜æˆäº†æœ‰ç•Œé˜Ÿåˆ—ã€‚ TaskQueue&lt;Runnable&gt; taskQueue = new TaskQueue&lt;Runnable&gt;(queues &lt;= 0 ? 1 : queues); // åˆ›å»º EagerThreadPoolExecutor å¯¹è±¡ EagerThreadPoolExecutor executor = new EagerThreadPoolExecutor( cores, threads, alive, TimeUnit.MILLISECONDS, /* TaskQueue é˜Ÿåˆ—*/ taskQueue, new NamedInternalThreadFactory(name, true), new AbortPolicyWithReport(name, url)); // å°†åˆ›å»ºçš„ eager çº¿ç¨‹æ± å¯¹è±¡è®¾ç½®åˆ° taskQueue ä¸­ taskQueue.setExecutor(executor); return executor; &#125; /** * é…ç½®æ–¹å¼ï¼šä½¿ç”¨ &lt;dubbo:parameter /&gt; é…ç½® */&#125; EagerThreadPool å¹¶æ²¡æœ‰ç›´æ¥ä½¿ç”¨ JDK ThreadPoolExecutor çº¿ç¨‹æ± ï¼Œè€Œæ˜¯ä½¿ç”¨äº†ç»§æ‰¿ ThreadPoolExecutor çš„ EagerThreadPoolExecutor çº¿ç¨‹æ± ã€‚è€Œä¸”ä½¿ç”¨çš„é˜Ÿåˆ— TaskQueue ï¼Œç»§æ‰¿äº† LinkedBlockingQueueã€‚EagerThreadPool çš„ä¸åŒå°±ä½“ç°åœ¨è¿™ä¸¤ä¸ªå¯¹è±¡ä¸Šã€‚ TaskQueue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * LinkedBlockingQueue å†…éƒ¨ç”±å•é“¾è¡¨å®ç°çš„é˜»å¡é˜Ÿåˆ—ï¼Œåªèƒ½ä»headå–å…ƒç´ ï¼Œä»tailæ·»åŠ å…ƒç´ ã€‚ * 1 take() å–æ•°æ®ï¼Œå½“é˜Ÿåˆ—ä¸ºç©ºæ—¶é˜»å¡ * 2 poll() å–æ•°æ®ï¼Œå¼¹å‡ºé˜Ÿåˆ—å¤´éƒ¨å…ƒç´ ï¼Œé˜Ÿåˆ—ä¸ºç©ºæ—¶è¿”å›ç©º * 3 offer() æ·»åŠ æ•°æ®ï¼Œå½“é˜Ÿåˆ—æ»¡æ—¶è¿”å› false * 4 put() æ·»åŠ æ•°æ®ï¼Œå½“é˜Ÿåˆ—æ»¡æ—¶é˜»å¡ */public class TaskQueue&lt;R extends Runnable&gt; extends LinkedBlockingQueue&lt;Runnable&gt; &#123; private static final long serialVersionUID = -2635853580887179627L; /** * eager çº¿ç¨‹æ±  */ private EagerThreadPoolExecutor executor; public TaskQueue(int capacity) &#123; super(capacity); &#125; public void setExecutor(EagerThreadPoolExecutor exec) &#123; executor = exec; &#125; /** * é‡å†™ LinkedBlockingQueue çš„ offer() æ–¹æ³•ã€‚ * ä¸»è¦å®ç°ï¼š * 1 åœ¨ä»»åŠ¡æ•°é‡å¤§äºcorePoolSizeä½†æ˜¯å°äºmaximumPoolSizeæ—¶ï¼Œä¼˜å…ˆåˆ›å»ºWorkeræ¥å¤„ç†ä»»åŠ¡ * 2 å½“ä»»åŠ¡æ•°é‡å¤§äºmaximumPoolSizeæ—¶ï¼Œå°†ä»»åŠ¡æ”¾å…¥é˜»å¡é˜Ÿåˆ—ä¸­ã€‚é˜»å¡é˜Ÿåˆ—å……æ»¡æ—¶æŠ›å‡ºRejectedExecutionException * * @param runnable * @return */ @Override public boolean offer(Runnable runnable) &#123; if (executor == null) &#123; throw new RejectedExecutionException(\"The task queue does not have executor!\"); &#125; // è·å–å½“å‰çº¿ç¨‹æ± ä¸­çš„æ´»è·ƒçº¿ç¨‹æ•°(æ³¨æ„éæ ¸å¿ƒçº¿ç¨‹æ•°å¯èƒ½è¢«å›æ”¶) int currentPoolThreadSize = executor.getPoolSize(); // å½“å‰æœ‰çº¿ç¨‹ç©ºé—²ï¼Œç›´æ¥å°†ä»»åŠ¡æäº¤åˆ°é˜Ÿåˆ—ä¸­ï¼Œç©ºé—²çº¿ç¨‹ä¼šç›´æ¥ä»ä¸­è·å–ä»»åŠ¡æ‰§è¡Œ if (executor.getSubmittedTaskCount() &lt; currentPoolThreadSize) &#123; // å°†ä»»åŠ¡å…¥é˜Ÿ return super.offer(runnable); &#125; // return false to let executor create new worker. // å½“å‰æ²¡æœ‰ç©ºé—²çº¿ç¨‹ï¼Œä½†æ´»è·ƒçº¿ç¨‹æ•°å°äºæœ€å¤§çº¿ç¨‹æ•°å³è¿˜å¯ä»¥åˆ›å»ºçº¿ç¨‹ï¼Œåˆ™è¿”å› falseï¼Œè®©çº¿ç¨‹æ± åˆ›å»ºæ–°çš„çº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ if (currentPoolThreadSize &lt; executor.getMaximumPoolSize()) &#123; return false; &#125; // currentPoolThreadSize &gt;= max // å½“å‰æ´»è·ƒçº¿ç¨‹è¾¾åˆ°ä¸Šçº¿ï¼Œåˆ™åªèƒ½å°†ä»»åŠ¡æ”¾å…¥ç¼“å†²é˜Ÿåˆ— return super.offer(runnable); &#125; /** * å†æ¬¡å°†ä»»åŠ¡åŠ å…¥é˜Ÿåˆ— * * @param o task * @return offer success or not * @throws RejectedExecutionException if executor is terminated. */ public boolean retryOffer(Runnable o, long timeout, TimeUnit unit) throws InterruptedException &#123; if (executor.isShutdown()) &#123; throw new RejectedExecutionException(\"Executor is shutdown!\"); &#125; return super.offer(o, timeout, unit); &#125;&#125; TaskQueue ç»§æ‰¿äº† LinkedBlockingQueue é˜»å¡é˜Ÿåˆ—ï¼Œå®ƒå¤å†™äº† LinkedBlockingQueue çš„ offer() æ–¹æ³•ï¼Œä¼šåˆ¤æ–­çº¿ç¨‹æ±  EagerThreadPoolExecutor çš„ submittedTaskCount å€¼æ˜¯å¦å·²ç»è¾¾åˆ°æœ€å¤§çº¿ç¨‹æ•°ï¼Œå¦‚æœæ²¡æœ‰è¶…è¿‡åˆ™è¿”å› falseï¼Œçº¿ç¨‹æ± ä¼šåˆ›å»ºæ–°çº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ã€‚è¿™ç‚¹éå¸¸é‡è¦ï¼Œeager çº¿ç¨‹æ± ä¼˜å…ˆåˆ›å»ºçº¿ç¨‹æ‰§è¡Œä»»åŠ¡çš„é€»è¾‘åˆ¤æ–­å°±è¿™è¿™é‡Œã€‚ EagerThreadPoolExecutor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class EagerThreadPoolExecutor extends ThreadPoolExecutor &#123; /** * è®°å½•å½“å‰åœ¨çº¿ç¨‹æ± ä¸­çš„ä»»åŠ¡æ€»æ•°ï¼ˆæ­£åœ¨çº¿ç¨‹ä¸­æ‰§è¡Œçš„ä»»åŠ¡æ•°+é˜Ÿåˆ—ä¸­ç­‰å¾…çš„ä»»åŠ¡æ•°ï¼‰ */ private final AtomicInteger submittedTaskCount = new AtomicInteger(0); public EagerThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, TaskQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); &#125; /** * è¿”å›å½“å‰çº¿ç¨‹æ± çš„ä»»åŠ¡æ€»æ•° * * @return current tasks which are executed */ public int getSubmittedTaskCount() &#123; return submittedTaskCount.get(); &#125; /** * å¤å†™ ThreadPoolExecutor çš„ afterExecute() æ–¹æ³• * * @param r * @param t */ @Override protected void afterExecute(Runnable r, Throwable t) &#123; // ä»»åŠ¡æ‰§è¡Œç»“æŸï¼Œé€’å‡ submittedTaskCount submittedTaskCount.decrementAndGet(); &#125; /** * å¤å†™ ThreadPoolExecutor çš„ execute() æ–¹æ³• * * @param command */ @Override public void execute(Runnable command) &#123; if (command == null) &#123; throw new NullPointerException(); &#125; // ä»»åŠ¡æäº¤ä¹‹å‰ï¼Œé€’å¢submittedTaskCount submittedTaskCount.incrementAndGet(); try &#123; // æäº¤ä»»åŠ¡ ï¼ˆå½“çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°è¾¾åˆ°æ ¸å¿ƒçº¿ç¨‹æ•°ï¼ŒThreadPoolExecutor åº•å±‚ä¼šæ‰§è¡Œ TaskQueue çš„ poll() æ–¹æ³•ï¼‰ super.execute(command); // æäº¤ä»»åŠ¡è¢«æ‹’ç» &#125; catch (RejectedExecutionException rx) &#123; // è·å–ç¼“å­˜é˜Ÿåˆ— final TaskQueue queue = (TaskQueue) super.getQueue(); try &#123; // å°è¯•å°†è¢«æ‹’ç»çš„ä»»åŠ¡å†æ¬¡äº¤ç»™çº¿ç¨‹æ± å¤„ç†ï¼Œå¦‚æœçº¿ç¨‹æ± å…³é—­æˆ–é˜Ÿåˆ—æ»¡äº†ï¼Œåˆ™é€’å‡ submittedTaskCount if (!queue.retryOffer(command, 0, TimeUnit.MILLISECONDS)) &#123; submittedTaskCount.decrementAndGet(); throw new RejectedExecutionException(\"Queue capacity is full.\"); &#125; // ä¸­æ–­å¼‚å¸¸ï¼Œé€’å‡ submittedTaskCount &#125; catch (InterruptedException x) &#123; submittedTaskCount.decrementAndGet(); throw new RejectedExecutionException(x); &#125; // æäº¤ä»»åŠ¡å‘ç”Ÿå…¶å®ƒå¼‚å¸¸ï¼Œé€’å‡ submittedTaskCount &#125; catch (Throwable t) &#123; // decrease any way submittedTaskCount.decrementAndGet(); &#125; &#125;&#125; å½“æ´»è·ƒçº¿ç¨‹æ•°æ²¡æœ‰è¾¾åˆ°æœ€å¤§çº¿ç¨‹æ•°æ—¶ä¸”æ— ç©ºé—²çº¿ç¨‹ï¼ŒEagerThreadPoolExecutor ä¼šä¼˜å…ˆåˆ›å»ºçº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ï¼Œè€Œä¸æ˜¯æ”¾åˆ°ç¼“å†²é˜Ÿåˆ—ä¸­ï¼Œå½“æ´»è·ƒçº¿ç¨‹æ•°è¾¾åˆ°æœ€å¤§å€¼æ—¶ï¼ŒEagerThreadPoolExecutor ä¼šå°†ä»»åŠ¡æ”¾å…¥ç¼“å†²é˜Ÿåˆ—ä¸­ç­‰å¾…ç©ºé—²çº¿ç¨‹æ‰§è¡Œï¼Œé˜»å¡é˜Ÿåˆ—å……æ»¡æ—¶æŠ›å‡ºå¼‚å¸¸ã€‚ AbortPolicyWithReport123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * æ‹’ç»ç­–ç•¥å®ç°ç±»ï¼Œç»§æ‰¿äº† ThreadPoolExecutor.AbortPolicyï¼Œè¿™é‡Œæ‰“å°JStackï¼Œåˆ†æçº¿ç¨‹çŠ¶æ€ * &lt;p&gt; * Abort Policy. * Log warn info when abort. */public class AbortPolicyWithReport extends ThreadPoolExecutor.AbortPolicy &#123; protected static final Logger logger = LoggerFactory.getLogger(AbortPolicyWithReport.class); /** * çº¿ç¨‹ */ private final String threadName; /** * URLå¯¹è±¡ */ private final URL url; /** * æœ€åæ‰“å°æ—¶é—´ */ private static volatile long lastPrintTime = 0; /** * ä¿¡å·é‡ */ private static Semaphore guard = new Semaphore(1); public AbortPolicyWithReport(String threadName, URL url) &#123; this.threadName = threadName; this.url = url; &#125; /** * å¤å†™äº† rejectedExecution æ–¹æ³• * * @param r * @param e */ @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; // æ‰“å°å‘Šè­¦æ—¥å¿— String msg = String.format(\"Thread pool is EXHAUSTED!\" + \" Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d), Task: %d (completed: %d),\" + \" Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!\", threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(), e.getLargestPoolSize(), e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating(), url.getProtocol(), url.getIp(), url.getPort()); logger.warn(msg); // æ‰“å°JStackï¼Œåˆ†æçº¿ç¨‹çŠ¶æ€ dumpJStack(); // æŠ›å‡º RejectedExecutionException å¼‚å¸¸ throw new RejectedExecutionException(msg); &#125; /** * æ‰“å°JStackï¼Œç”¨æ¥åˆ†æçº¿ç¨‹çŠ¶æ€ */ private void dumpJStack() &#123; // å½“å‰æ—¶é—´ long now = System.currentTimeMillis(); //10åˆ†é’Ÿæ‰“å°ä¸€æ¬¡ if (now - lastPrintTime &lt; 10 * 60 * 1000) &#123; return; &#125; // è·å¾—ä¿¡å·é‡ ,ç”¨ä»¥ä¿è¯åŒä¸€æ—¶é—´æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œæ‰“å° if (!guard.tryAcquire()) &#123; return; &#125; // åˆ›å»ºçº¿ç¨‹æ± ï¼Œåå°æ‰§è¡Œæ‰“å°é€»è¾‘ Executors.newSingleThreadExecutor().execute(new Runnable() &#123; @Override public void run() &#123; // è·å¾—ç³»ç»Ÿ String dumpPath = url.getParameter(Constants.DUMP_DIRECTORY, System.getProperty(\"user.home\")); SimpleDateFormat sdf; // è·å¾—è·¯å¾„ String OS = System.getProperty(\"os.name\").toLowerCase(); // window system don't support \":\" in file name if (OS.contains(\"win\")) &#123; sdf = new SimpleDateFormat(\"yyyy-MM-dd_HH-mm-ss\"); &#125; else &#123; sdf = new SimpleDateFormat(\"yyyy-MM-dd_HH:mm:ss\"); &#125; String dateStr = sdf.format(new Date()); // è¾“å‡ºæµ FileOutputStream jstackStream = null; try &#123; jstackStream = new FileOutputStream(new File(dumpPath, \"Dubbo_JStack.log\" + \".\" + dateStr)); // æ‰“å°JStack ä¿¡æ¯ JVMUtil.jstack(jstackStream); &#125; catch (Throwable t) &#123; logger.error(\"dump jstack error\", t); &#125; finally &#123; // é‡Šæ”¾ä¿¡å·é‡ guard.release(); if (jstackStream != null) &#123; try &#123; jstackStream.flush(); jstackStream.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; // è®°å½•æœ€åæ‰“å°æ—¶é—´ lastPrintTime = System.currentTimeMillis(); &#125; &#125;); &#125;&#125; å°ç»“æœ¬ç¯‡æ–‡ç« å¯¹ Dubbo çº¿ç¨‹æ¨¡å‹ä¸­çš„çº¿ç¨‹æ± éƒ¨åˆ†è¿›è¡Œäº†ä»‹ç»ï¼ŒDubbo ç›®å‰æ”¯æŒå››ç§çº¿ç¨‹æ± ï¼Œå…¶ä¸­ eager çº¿ç¨‹æ± æ¯”è¾ƒç‰¹åˆ«ï¼Œä½¿ç”¨çš„ç¼“å†²é˜Ÿåˆ— TaskQueue é‡å†™äº† LinkedBlockingQueue çš„ offer() æ–¹æ³•ï¼Œè¯¥æ–¹æ³•çš„é€»è¾‘æ˜¯åˆ¤æ–­çº¿ç¨‹æ± çš„ä¸­çš„ä»»åŠ¡ï¼ˆæ‰§è¡Œä¸­çš„å’Œé˜Ÿåˆ—ä¸­çš„ï¼‰æ˜¯å¦å·²ç»è¾¾åˆ°æœ€å¤§çº¿ç¨‹æ•°ï¼Œå¦‚æœæ²¡æœ‰è¶…è¿‡å°±ä½¿çº¿ç¨‹æ± åˆ›å»ºæ–°çº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ã€‚å…¶å®ƒä¸‰ä¸ªçº¿ç¨‹çš„æ˜¯åŸºäº JDK ThreadPoolExecutor çº¿ç¨‹æ± ï¼Œåœ¨æ ¸å¿ƒçº¿ç¨‹å…¨éƒ¨è¢«å ç”¨çš„æ—¶å€™ä¼šå…ˆæŠŠä»»åŠ¡æ”¾åˆ°ç¼“å†²é˜Ÿåˆ—ä¸­ï¼Œå½“ç¼“å†²é˜Ÿåˆ—æ»¡äº†ä¹‹åï¼Œæ‰ä¼šå°è¯•åˆ›å»ºæ–°çº¿ç¨‹æ¥å¤„ç†ä»»åŠ¡ã€‚æœ€åï¼Œä»‹ç»äº†è¿™å››ä¸ªçº¿ç¨‹æ± ä½¿ç”¨çš„æ‹’ç»ç­–ç•¥ï¼Œç”¨äºæ‰“å°JStackï¼Œåˆ†æçº¿ç¨‹çŠ¶æ€ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - Minaç½‘ç»œé€šä¿¡","slug":"rpc/Minaç½‘ç»œé€šä¿¡","date":"2020-06-06T16:00:00.000Z","updated":"2020-12-01T01:45:15.779Z","comments":false,"path":"posts/543ee8c5/","link":"","permalink":"https://gentryhuang.com/posts/543ee8c5/","excerpt":"","text":"å‰è¨€åœ¨ ç½‘ç»œä¼ è¾“å±‚ ä¸­å¯¹ Transport é€šç”¨å±‚æˆ–è€…è¯´æ˜¯æŠ½è±¡å±‚è¿›è¡Œäº†è¯¦ç»†åˆ†æã€‚ä¸Šä¸€ç¯‡æ–‡ç«  Netty4ç½‘ç»œé€šä¿¡ ä¸­æˆ‘ä»¬è¯¦ç»†åˆ†æäº† Dubbo æ¥å…¥ Netty4 å®ç°çš„ç½‘ç»œé€šä¿¡ï¼Œæœ¬ç¯‡æ–‡ç« å°†åˆ†æ Dubbo å¦‚ä½•æ¥å…¥ Mina åº“ã€‚ æ¦‚è¿°Dubbo ä¸ºäº†é›†æˆä¸åŒä¼˜ç§€å¼€æºçš„ NIO åº“ï¼Œä¸“é—¨å®ç°äº†ä¸€ä¸ªæŠ½è±¡å±‚ï¼Œå¯¹åº”çš„æ¨¡å—æ˜¯ dubbo-remoting-apiï¼Œåœ¨ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ä¸­ä»‹ç»äº†è¯¥æ¨¡å—æ ¸å¿ƒçš„æ¥å£å’Œç±»ã€‚é’ˆå¯¹æ¯ä¸€ä¸ª NIO æ¡†æ¶çš„æ¥å…¥ï¼ŒDubbo éƒ½æ„å»ºä¸€ä¸ªå•ç‹¬çš„æ¨¡å—ï¼Œè¯¥æ¨¡å—åªéœ€å®ç°æŠ½è±¡æ¨¡å— dubbo-remoting-api å³å¯ï¼Œç»“åˆ Dubbo SPI æœºåˆ¶å¯ä»¥çµæ´»åˆ‡æ¢åˆ°ä¸åŒçš„ NIO åº“ã€‚ä¸‹é¢æˆ‘ä»¬å¼€å§‹ä»‹ç»å®ç°å±‚ dubbo-remoting-mina æ¨¡å—ï¼ŒUML å›¾å¦‚ä¸‹ï¼š é€šè¿‡ä¸Šé¢çš„ UML å›¾å¯ä»¥å¾ˆæ¸…æ™°çœ‹å‡ºå„ä¸ªç±»ä¹‹é—´çš„å…³ç³»ï¼Œå’Œ Netty4 å®ç°é€šä¿¡å‡ ä¹ä¸€è‡´ã€‚ä¸‹é¢æˆ‘ä»¬ä¾ç„¶æ ¹æ® UML å›¾çš„ä¾èµ–å…³ç³»é€ä¸ªåˆ†æã€‚ MinaTransporter123456789101112131415161718192021222324252627282930public class MinaTransporter implements Transporter &#123; public static final String NAME = \"mina\"; /** * ç»‘å®šä¸€ä¸ªæœåŠ¡å™¨ * * @param url æœåŠ¡å™¨åœ°å€ * @param handler é€šé“å¤„ç†å™¨ * @return * @throws RemotingException */ @Override public Server bind(URL url, ChannelHandler handler) throws RemotingException &#123; return new MinaServer(url, handler); &#125; /** * è¿æ¥æœåŠ¡å™¨ï¼Œçº§åˆ›å»ºä¸€ä¸ªå®¢æˆ·ç«¯ * * @param url æœåŠ¡å™¨åœ°å€ * @param handler é€šé“å¤„ç†å™¨ * @return * @throws RemotingException */ @Override public Client connect(URL url, ChannelHandler handler) throws RemotingException &#123; return new MinaClient(url, handler); &#125;&#125; MinaTransporter å®ç°äº† Transporter æ‰©å±•æ¥å£ï¼Œå…³äº Transporter æ‰©å±•æ¥å£å·²ç»åœ¨ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ä¸­è¿›è¡Œäº†ä»‹ç»ï¼Œé»˜è®¤æ‰©å±•å®ç°æ˜¯ netty å³ Netty3 å®ç°ã€‚bind() å’Œ connect() æ–¹æ³•åˆ†åˆ«ç”¨äºåˆ›å»º MinaServer å’Œ MinaClient å¯¹è±¡ã€‚ä¸€èˆ¬ Transport æ‰©å±•å®ç°ä¼šç”± Transport çš„é—¨é¢ Transports ç»Ÿä¸€å‘ä¸Šå±‚æä¾›ï¼Œè¿™ä¸ªä¸Šå±‚å°±æ˜¯ Exchange ä¿¡æ¯äº¤äº’å±‚ã€‚ä¸‹é¢æˆ‘ä»¬ç»§ç»­åˆ†æ MinaTransporter åˆ›å»ºçš„æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ã€‚ MinaServerå±æ€§12345678910111213public class MinaServer extends AbstractServer &#123; private static final Logger logger = LoggerFactory.getLogger(MinaServer.class); /** * ç”¨äºåŒå®¢æˆ·ç«¯å»ºç«‹è¿æ¥ */ private SocketAcceptor acceptor; public MinaServer(URL url, ChannelHandler handler) throws RemotingException &#123; super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME))); &#125;&#125; MinaServer ç»§æ‰¿äº† AbstractServer æŠ½è±¡æœåŠ¡ç±»ï¼Œæ˜¯ Mina æœåŠ¡å®ç°ç±»ã€‚MinaServer é€šè¿‡å±‚å±‚ç»§æ‰¿æ‹¥æœ‰äº†å¾ˆå¤šç±»çš„èŒèƒ½ï¼Œå¦‚ ç«¯ç‚¹ï¼ˆEndpointï¼‰ã€é€šé“å¤„ç†ï¼ˆChannelHandlerï¼‰ã€(æœåŠ¡ç«¯)Server ï¼Œå…¶ä¸­é—´æ¥å…³è”äº† ChannelHandlerï¼ˆAbstractPeerä¸­çš„å±æ€§ï¼‰å’Œ Codec2ï¼ˆAbstractEndpointä¸­çš„ï¼‰å¯¹è±¡ ã€‚å‰©ä¸‹çš„ä¸å†è¯´æ˜ï¼Œå’Œ Netty4 å®ç°ä¸€è‡´ã€‚ å¯åŠ¨æœåŠ¡æ–¹æ³• doOpen1234567891011121314@Override protected void doOpen() throws Throwable &#123; // set thread pool. acceptor = new SocketAcceptor(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS), Executors.newCachedThreadPool(new NamedThreadFactory(\"MinaServerWorker\", true))); // é…ç½®é¡¹ SocketAcceptorConfig cfg = acceptor.getDefaultConfig(); cfg.setThreadModel(ThreadModel.MANUAL); //ç¼–å†™è¿‡æ»¤å™¨é“¾ï¼Œé€šè¿‡è¿‡æ»¤å™¨æ‰§è¡Œç¼–è§£ç å™¨ acceptor.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new MinaCodecAdapter(getCodec(), getUrl(), this))); // ç»‘å®šç«¯å£ï¼Œå¹¶è®¾ç½® handler acceptor.bind(getBindAddress(), new MinaHandler(getUrl(), this)); &#125; å¯åŠ¨æœåŠ¡çš„æ–¹æ³•æ˜¯çˆ¶ç±»çš„ä¸€ä¸ªæ¨¡ç‰ˆæ–¹æ³•ï¼Œä»£ç å®ç°æ˜¯ Mina çš„æ ‡å‡†åŒ–æµç¨‹ã€‚ç®€å•æ¦‚æ‹¬ä¸‹ï¼š åˆ›å»º SocketAcceptor å¯¹è±¡ï¼ŒURL å¯¹è±¡ä»çˆ¶ç±» AbstractPeer ä¸­è·å–ã€‚ è®¾ç½® Mina æœåŠ¡çš„é…ç½®é¡¹ã€‚ è®¾ç½® Mina çš„è¿‡æ»¤å™¨ï¼Œåœ¨ Mina ä¸­ç¼–è§£ç å™¨æ˜¯é€šè¿‡è¿‡æ»¤å™¨èŒèƒ½å®ç°çš„ï¼ŒMina çš„è¿‡æ»¤å™¨å¯¹ Codec2 å®ç°è¿›è¡Œäº†å°è£…ã€‚ è®¾ç½®å¤„ç†ï¼Œç»‘å®šç«¯å£ï¼Œå¯åŠ¨æœåŠ¡ é™¤äº†æ ‡å‡†åŒ–æµç¨‹ä¸åŒå¤–ï¼Œå…¶å®ƒæ–¹é¢éƒ½å’Œ NettyServer ä¸€è‡´ï¼Œéƒ½éœ€è¦æŠŠ Codec2 ç¼–è§£ç å™¨å’Œé€šé“å¤„ç†å™¨ ChannelHandler å…³è”åˆ°æœåŠ¡ä¸Šã€‚ å…³é—­æœåŠ¡ doClose1234567891011@Override protected void doClose() throws Throwable &#123; try &#123; if (acceptor != null) &#123; // è§£ç»‘ç«¯å£ï¼Œå…³é—­æœåŠ¡ acceptor.unbind(getBindAddress()); &#125; &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; NettyServer å…³é—­æ—¶éœ€è¦è€ƒè™‘åˆ°å¤šä¸ªå¯¹è±¡ï¼Œå¦‚æœåŠ¡ Channelã€å®¢æˆ·ç«¯è¿æ¥åˆ°æœåŠ¡çš„Channelã€ä»¥åŠå¾ªç¯çº¿ç¨‹ç»„ã€‚ MinaServer åªéœ€è¦è€ƒè™‘å…³é—­ SocketAcceptor å¯¹è±¡å³å¯ã€‚ è·å–å®¢æˆ·ç«¯é€šé“1234567891011121314@Override public Collection&lt;Channel&gt; getChannels() &#123; // è·å–Mina è¿æ¥é›†åˆ Set&lt;IoSession&gt; sessions = acceptor.getManagedSessions(getBindAddress()); Collection&lt;Channel&gt; channels = new HashSet&lt;Channel&gt;(); for (IoSession session : sessions) &#123; // è¿æ¥å¤„äºè¿æ¥çŠ¶æ€ if (session.isConnected()) &#123; // è·å–Mina è¿æ¥å¯¹åº”çš„ Dubbo MinaChannel channels.add(MinaChannel.getOrAddChannel(session, getUrl(), this)); &#125; &#125; return channels; &#125; å’Œ NettyServer ç±»ä¼¼ï¼Œéƒ½éœ€è¦è·å–å¤„äºè¿æ¥çŠ¶æ€çš„é€šé“ï¼Œæœ€ç»ˆæ˜ å°„åˆ° Dubbo å±‚é¢çš„é€šé“ MinaChannelã€‚ æ˜¯å¦å¯åŠ¨æˆåŠŸ123456789/** * æœåŠ¡æ˜¯å¦å¯åŠ¨ * * @return */ @Override public boolean isBound() &#123; return acceptor.isManaged(getBindAddress()); &#125; è°ƒç”¨ Mina API åˆ¤æ–­æœåŠ¡æ˜¯å¦å¼€å¯ï¼Œå’Œ NettyServer ç±»ä¼¼ã€‚ MinaChannelMinaChannel ç»§æ‰¿äº† AbstractChannel æŠ½è±¡ç±»ï¼Œæ˜¯å¯¹ org.apache.mina.common.IoSession çš„è£…é¥°ï¼Œä½¿ç”¨äº†è£…é¥°è€…æ¨¡å¼ï¼Œä¸ IoSession æ˜¯ä¸€å¯¹ä¸€çš„å…³ç³»ï¼Œè¿™ä¸€ç‚¹å’Œ NettyChannel ä¸€è‡´ã€‚ å±æ€§1234567891011121314151617181920212223final class MinaChannel extends AbstractChannel &#123; private static final Logger logger = LoggerFactory.getLogger(MinaChannel.class); /** * IoSession å­˜å‚¨æ•°æ®çš„keyï¼Œvalue æ˜¯ MinaChannel å¯¹è±¡ */ private static final String CHANNEL_KEY = MinaChannel.class.getName() + \".CHANNEL\"; /** * å¯¹åº•å±‚è¿æ¥çš„å°è£…ï¼ˆæœåŠ¡å™¨ä¸å®¢æˆ·ç«¯çš„ç‰¹å®šè¿æ¥ï¼‰ */ private final IoSession session; // ç§æœ‰æ„é€ æ–¹æ³• private MinaChannel(IoSession session, URL url, ChannelHandler handler) &#123; super(url, handler); if (session == null) &#123; throw new IllegalArgumentException(\"mina session == null\"); &#125; this.session = session; &#125;&#125; MinaChannel å’Œ NettyChannel æœ‰æ‰€ä¸åŒï¼ŒMinaChannel å†…éƒ¨è£…é¥°çš„ Mina çš„è¿æ¥ IoSession ç›´æ¥å­˜å‚¨æ•°æ®ï¼Œå°†å¯¹åº”çš„ MinaChannel å­˜å‚¨åˆ° IoSession ä¸­ï¼Œè€Œ NettyChannel é‡‡ç”¨å•ç‹¬ä½¿ç”¨é›†åˆå¤„ç†çš„æ–¹å¼ã€‚åŒæ ·çš„ï¼Œè·å– MinaChannel åªèƒ½é€šè¿‡å†…éƒ¨æ–¹æ³•åˆ›å»ºã€‚ æ ¸å¿ƒæ–¹æ³•åˆ›å»º/è·å– MinaChannel1234567891011121314151617181920static MinaChannel getOrAddChannel(IoSession session, URL url, ChannelHandler handler) &#123; if (session == null) &#123; return null; &#125; // IoSession ä¸­å–å‡ºå¯¹åº”çš„ MinaChannel å¯¹è±¡ MinaChannel ret = (MinaChannel) session.getAttribute(CHANNEL_KEY); if (ret == null) &#123; // åˆ›å»º MinaChannel å¯¹è±¡ ret = new MinaChannel(session, url, handler); // åˆ¤æ–­è¿æ¥æ˜¯å¤„äºè¿æ¥ä¸­ if (session.isConnected()) &#123; MinaChannel old = (MinaChannel) session.setAttribute(CHANNEL_KEY, ret); if (old != null) &#123; session.setAttribute(CHANNEL_KEY, old); ret = old; &#125; &#125; &#125; return ret; &#125; å’Œ NettyChannel ç±»ä¼¼ï¼Œéƒ½æ˜¯ä½¿ç”¨NIOçš„è¿æ¥ä½œä¸ºæ˜ å°„çš„æ ‡è¯†ï¼ŒgetOrAddChannel() æ–¹æ³•ä¸ä»…åˆ›å»ºäº† MinaChannelï¼Œä¹Ÿè®¾ç½®äº† AbstractPeer ç±»ä¸­çš„ ChannelHandler å’Œ URL å±æ€§çš„å€¼ï¼Œè¿™æ„å‘³ç€ AbstractPeer å½“å‰å­ç±»å¯¹è±¡å…³è”äº†è¿™ä¸¤ä¸ªå±æ€§çš„å€¼ã€‚ å‘é€æ¶ˆæ¯è¯¥æ–¹æ³•æ˜¯ Endpoint æ¥å£ä¸­çš„æ–¹æ³•ï¼Œå¹¶é Channel æ¥å£ä¸­çš„æ–¹æ³•ï¼ŒChannelæ¥å£æ²¡æœ‰å‘é€æ¶ˆæ¯çš„æ–¹æ³•ã€‚å®ƒä¼šé€šè¿‡è£…é¥°çš„ Mina æ¡†æ¶çš„ IoSession å°†æ•°æ®å‘é€åˆ°å¯¹ç«¯ï¼Œå¹¶ä¸”æ”¯æŒç­‰å¾…å‘é€å®Œæˆã€‚ 123456789101112131415161718192021222324@Override public void send(Object message, boolean sent) throws RemotingException &#123; // æ£€æŸ¥è¿æ¥æ˜¯å¦å¯ç”¨ super.send(message, sent); boolean success = true; int timeout = 0; try &#123; // é€šè¿‡ IoSession å‘é€æ¶ˆæ¯åˆ°å¯¹ç«¯ WriteFuture future = session.write(message); // æ”¯æŒç­‰å¾…æ¶ˆæ¯å‘é€æˆåŠŸæˆ–è€…è¶…æ—¶ if (sent) &#123; timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT); success = future.join(timeout); &#125; &#125; catch (Throwable e) &#123; throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress() + \", cause: \" + e.getMessage(), e); &#125; if (!success) &#123; throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress() + \"in timeout(\" + timeout + \"ms) limit\"); &#125; &#125; æ“ä½œé™„åŠ å±æ€§12345678910111213141516171819@Override public boolean hasAttribute(String key) &#123; return session.containsAttribute(key); &#125; @Override public Object getAttribute(String key) &#123; return session.getAttribute(key); &#125; @Override public void setAttribute(String key, Object value) &#123; session.setAttribute(key, value); &#125; @Override public void removeAttribute(String key) &#123; session.removeAttribute(key); &#125; MinaChannel ä½¿ç”¨äº† IoSession ç›´æ¥æ“ä½œé™„åŠ å±æ€§ï¼Œè€Œ NettyChannel ç»´æŠ¤äº†ä¸€ä¸ªé›†åˆæ¥å­˜æ”¾é™„åŠ å±æ€§ã€‚ å…³é—­è¿æ¥12345678910111213141516171819202122232425@Override public void close() &#123; try &#123; // æ ‡è®°è¿æ¥å…³é—­ super.close(); &#125; catch (Exception e) &#123; logger.warn(e.getMessage(), e); &#125; try &#123; // ç§»é™¤å¤„äºæ–­å¼€è¿æ¥çš„è¿æ¥å¯¹åº”çš„ MinaChanenl removeChannelIfDisconnected(session); &#125; catch (Exception e) &#123; logger.warn(e.getMessage(), e); &#125; try &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"CLose mina channel \" + session); &#125; // å…³é—­ Mina è¿æ¥ session.close(); &#125; catch (Exception e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; å’Œ NettyChannel é€»è¾‘ä¸€è‡´ã€‚ æ¸…ç† MinaChannel123456static void removeChannelIfDisconnected(IoSession session) &#123; if (session != null &amp;&amp; !session.isConnected()) &#123; // ç›´æ¥ä½¿ç”¨ Mina API ç§»é™¤ session.removeAttribute(CHANNEL_KEY); &#125; &#125; è·å–åœ°å€123456789@Override public InetSocketAddress getLocalAddress() &#123; return (InetSocketAddress) session.getLocalAddress(); &#125; @Override public InetSocketAddress getRemoteAddress() &#123; return (InetSocketAddress) session.getRemoteAddress(); &#125; å’Œ NettyChannel ç±»ä¼¼ï¼Œéƒ½æ˜¯ä½¿ç”¨å„è‡ªNIOåº“API è·å–å¯¹åº”çš„åœ°å€ã€‚ ç¼–è§£ç é€šè¿‡å‰æ–‡çš„ UML å…³ç³»å›¾ä»¥åŠ MinaServer å¯åŠ¨æœåŠ¡æ–¹æ³•ï¼Œæˆ‘ä»¬ä¸éš¾çœ‹å‡º MinaCodecAdapter å……å½“é€‚é…å™¨è§’è‰²ï¼Œä¸¥æ ¼æ¥è¯´å±äºå¯¹è±¡é€‚é…å™¨æ¨¡å¼ï¼Œå³ å°† Dubbo çš„ Codec2 ç¼–è§£ç å™¨é€‚é…æˆ Mina å±‚é¢çš„ç¼–ç å™¨å’Œè§£ç å™¨ï¼ŒMina ä¼šæŠŠç¼–è§£ç å·¥ä½œå§”æ‰˜ç»™ Dubbo çš„ Codec2 ç¼–è§£ç å™¨å»å¤„ç†ã€‚ç›¸å…³å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š åœ¨ ç½‘ç»œä¼ è¾“å±‚ ä¸­å·²ç»è¯¦ç»†ä»‹ç»è¿‡äº† AbstractEndpoint æŠ½è±¡ç±»ï¼Œè¯¥æŠ½è±¡ç±»ä¸­çš„ codec å±æ€§æ­£æ˜¯ Codec2 ç±»å‹ï¼Œè¯¥å±æ€§åœ¨ AbstractEndpoint æ„é€ æ–¹æ³•ä¸­è¢«åˆå§‹åŒ–ï¼Œè€Œ MinaServer é—´æ¥ç»§æ‰¿äº† AbstractEndpoint æŠ½è±¡ç±»ï¼Œåœ¨åˆ›å»º MinaServer å¯¹è±¡æ—¶è¯¥ç¼–è§£ç å±æ€§ä¹Ÿè¿›è¡Œäº†åˆå§‹åŒ–ã€‚ å±æ€§12345678910111213141516171819202122232425262728293031323334353637383940414243final class MinaCodecAdapter implements ProtocolCodecFactory &#123; /** * Mina ç¼–ç å™¨ */ private final ProtocolEncoder encoder = new InternalEncoder(); /** * Mina è§£ç å™¨ */ private final ProtocolDecoder decoder = new InternalDecoder(); /** * å…³è”çš„ Dubbo Codec2 */ private final Codec2 codec; /** * url */ private final URL url; /** * å…³è”çš„ ChannelHandler */ private final ChannelHandler handler; private final int bufferSize; public MinaCodecAdapter(Codec2 codec, URL url, ChannelHandler handler) &#123; this.codec = codec; this.url = url; this.handler = handler; int b = url.getPositiveParameter(Constants.BUFFER_KEY, Constants.DEFAULT_BUFFER_SIZE); this.bufferSize = b &gt;= Constants.MIN_BUFFER_SIZE &amp;&amp; b &lt;= Constants.MAX_BUFFER_SIZE ? b : Constants.DEFAULT_BUFFER_SIZE; &#125; @Override public ProtocolEncoder getEncoder() &#123; return encoder; &#125; @Override public ProtocolDecoder getDecoder() &#123; return decoder; &#125;&#125; MinaCodecAdapter å’Œ NettyCodecAdapter æœ‰ä¸€ç‚¹å·®åˆ«ï¼Œå› ä¸ºå„è‡ªNIOåº“å®ç°ä¸åŒï¼ŒMinaCodecAdapter éœ€è¦å®ç° Mina çš„æ¥å£ ProtocolCodecFactory ã€‚ ç¼–ç å™¨å®ç°1234567891011121314151617181920212223/** * å®ç°Minaçš„ç¼–ç å™¨æ¥å£ ProtocolEncoder */ private class InternalEncoder implements ProtocolEncoder &#123; @Override public void dispose(IoSession session) throws Exception &#123; &#125; @Override public void encode(IoSession session, Object msg, ProtocolEncoderOutput out) throws Exception &#123; ChannelBuffer buffer = ChannelBuffers.dynamicBuffer(1024); MinaChannel channel = MinaChannel.getOrAddChannel(session, url, handler); try &#123; // ç¼–ç å§”æ‰˜ç»™ Codec2 å®ç°å»å®Œæˆ codec.encode(channel, buffer, msg); &#125; finally &#123; MinaChannel.removeChannelIfDisconnected(session); &#125; out.write(ByteBuffer.wrap(buffer.toByteBuffer())); out.flush(); &#125; &#125; è§£ç å™¨å®ç°1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * å®ç°Minaçš„è§£ç å™¨æ¥å£ ProtocolDecoder */ private class InternalDecoder implements ProtocolDecoder &#123; private ChannelBuffer buffer = ChannelBuffers.EMPTY_BUFFER; @Override public void decode(IoSession session, ByteBuffer in, ProtocolDecoderOutput out) throws Exception &#123; int readable = in.limit(); if (readable &lt;= 0) return; ChannelBuffer frame; if (buffer.readable()) &#123; if (buffer instanceof DynamicChannelBuffer) &#123; buffer.writeBytes(in.buf()); frame = buffer; &#125; else &#123; int size = buffer.readableBytes() + in.remaining(); frame = ChannelBuffers.dynamicBuffer(size &gt; bufferSize ? size : bufferSize); frame.writeBytes(buffer, buffer.readableBytes()); frame.writeBytes(in.buf()); &#125; &#125; else &#123; frame = ChannelBuffers.wrappedBuffer(in.buf()); &#125; Channel channel = MinaChannel.getOrAddChannel(session, url, handler); Object msg; int savedReadIndex; try &#123; do &#123; savedReadIndex = frame.readerIndex(); try &#123; // è§£ç å§”æ‰˜ç»™ Codec2 å®ç° msg = codec.decode(channel, frame); &#125; catch (Exception e) &#123; buffer = ChannelBuffers.EMPTY_BUFFER; throw e; &#125; if (msg == Codec2.DecodeResult.NEED_MORE_INPUT) &#123; frame.readerIndex(savedReadIndex); break; &#125; else &#123; if (savedReadIndex == frame.readerIndex()) &#123; buffer = ChannelBuffers.EMPTY_BUFFER; throw new Exception(\"Decode without read data.\"); &#125; if (msg != null) &#123; out.write(msg); &#125; &#125; &#125; while (frame.readable()); &#125; finally &#123; if (frame.readable()) &#123; frame.discardReadBytes(); buffer = frame; &#125; else &#123; buffer = ChannelBuffers.EMPTY_BUFFER; &#125; MinaChannel.removeChannelIfDisconnected(session); &#125; &#125; @Override public void dispose(IoSession session) throws Exception &#123; &#125; @Override public void finishDecode(IoSession session, ProtocolDecoderOutput out) throws Exception &#123; &#125; &#125; MinaHandlerMinaHandler ç»§æ‰¿äº† org.apache.mina.common.IoHandlerAdapter ï¼Œè¿™æ˜¯ Mina æä¾›çš„å¤„ç†è¯·æ±‚æˆ–äº‹ä»¶çš„å¤„ç†ç±»ã€‚ å±æ€§123456789101112131415161718public class MinaHandler extends IoHandlerAdapter &#123; private final URL url; // Dubbo ChannelHandlerã€‚MinaHandler ä¸­å‡ ä¹æ‰€æœ‰æ–¹æ³•éƒ½ä¼šè§¦å‘è¯¥å¯¹è±¡ã€‚ private final ChannelHandler handler; public MinaHandler(URL url, ChannelHandler handler) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; if (handler == null) &#123; throw new IllegalArgumentException(\"handler == null\"); &#125; this.url = url; this.handler = handler; &#125;&#125; è¯·æ±‚æˆ–äº‹ä»¶å¤„ç†æ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//--------- MinaHandler ä¸­ä»¥ä¸‹æ‰€æœ‰æ–¹æ³•éƒ½ä¼šè§¦å‘è£…é¥°çš„ ChannelHandler å¯¹è±¡ ------------/ /** * è¿æ¥æœåŠ¡ * * @param session å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨çš„é€šé“ * @throws Exception */ @Override public void sessionOpened(IoSession session) throws Exception &#123; MinaChannel channel = MinaChannel.getOrAddChannel(session, url, handler); try &#123; handler.connected(channel); &#125; finally &#123; MinaChannel.removeChannelIfDisconnected(session); &#125; &#125; /** * æ–­å¼€è¿æ¥ * * @param session å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨çš„é€šé“ * @throws Exception */ @Override public void sessionClosed(IoSession session) throws Exception &#123; MinaChannel channel = MinaChannel.getOrAddChannel(session, url, handler); try &#123; handler.disconnected(channel); &#125; finally &#123; MinaChannel.removeChannelIfDisconnected(session); &#125; &#125; /** * æ¥æ”¶æ¶ˆæ¯ * * @param session å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨çš„é€šé“ * @param message æ¶ˆæ¯ * @throws Exception */ @Override public void messageReceived(IoSession session, Object message) throws Exception &#123; MinaChannel channel = MinaChannel.getOrAddChannel(session, url, handler); try &#123; handler.received(channel, message); &#125; finally &#123; MinaChannel.removeChannelIfDisconnected(session); &#125; &#125; /** * å‘é€æ¶ˆæ¯ * * @param session å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨çš„é€šé“ * @param message æ¶ˆæ¯ * @throws Exception */ @Override public void messageSent(IoSession session, Object message) throws Exception &#123; MinaChannel channel = MinaChannel.getOrAddChannel(session, url, handler); try &#123; handler.sent(channel, message); &#125; finally &#123; MinaChannel.removeChannelIfDisconnected(session); &#125; &#125; /** * å¼‚å¸¸å¤„ç† * * @param session å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨çš„é€šé“ * @param cause * @throws Exception */ @Override public void exceptionCaught(IoSession session, Throwable cause) throws Exception &#123; MinaChannel channel = MinaChannel.getOrAddChannel(session, url, handler); try &#123; handler.caught(channel, cause); &#125; finally &#123; MinaChannel.removeChannelIfDisconnected(session); &#125; &#125; MinaServer &amp; MinaHandleråœ¨ MinaServer åˆ›å»º MinaHandler ä»£ç å¦‚ä¸‹ï¼š 123// ç»‘å®šç«¯å£ï¼Œå¹¶è®¾ç½® handler// MinaHandler æ„é€ æ–¹æ³•ç¬¬äºŒä¸ªå‚æ•°æ˜¯ MinaServer æœ¬èº«acceptor.bind(getBindAddress(), new MinaHandler(getUrl(), this)); ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è°ƒç”¨é—´æ¥çˆ¶ç±» AbstractPeer#getUrl() æ–¹æ³•è·å–ä¸Šå±‚ä¼ å…¥çš„ URLå¯¹è±¡ã€‚ç¬¬äºŒä¸ªå‚æ•°æ­£æ˜¯ MinaServer å¯¹è±¡æœ¬èº«ï¼Œé€šè¿‡ä¹‹å‰çš„ä»‹ç»ï¼Œæˆ‘ä»¬çŸ¥é“ MinaServer ç»§æ‰¿å…³ç³»ï¼Œå®ƒçš„çˆ¶ç±» AbstractPeer å®ç°äº† ChannelHandler æ¥å£ï¼Œå¹¶ä¸”å°†æ‰€æœ‰æ–¹æ³•éƒ½å§”æ‰˜ç»™äº†å…¶è£…é¥°çš„ ChannelHandler å¯¹è±¡ã€‚å› æ­¤ï¼ŒMinaHandler ä¸­çš„é€šé“æ–¹æ³•éƒ½æ˜¯äº¤ç»™ MinaServer å…³è”çš„ ChannelHandler å¯¹è±¡æœ¬èº«ã€‚ MinaClientMinaClient æ˜¯åŸºäº Mina å®ç°çš„å®¢æˆ·ç«¯ï¼Œä¸‹é¢æˆ‘ä»¬å¯¹å®ƒçš„å±æ€§ã€æ„é€ æ–¹æ³•ä»¥åŠåŸºæœ¬æ–¹æ³•è¿›è¡Œè¯¦ç»†è¯´æ˜ã€‚ å±æ€§1234567891011121314151617181920212223242526public class MinaClient extends AbstractClient &#123; private static final Logger logger = LoggerFactory.getLogger(MinaClient.class); /** * SocketConnector ç¼“å­˜ * key: URL ä¸² * value: SocketConnector å¯¹è±¡ */ private static final Map&lt;String, SocketConnector&gt; connectors = new ConcurrentHashMap&lt;String, SocketConnector&gt;(); /** * ç¼“å­˜ key */ private String connectorKey; /** * ç”¨äºè¿æ¥MinaæœåŠ¡ */ private SocketConnector connector; /** * å¯¹åº•å±‚è¿æ¥çš„å°è£…ï¼ˆæœåŠ¡å™¨ä¸å®¢æˆ·ç«¯çš„ç‰¹å®šè¿æ¥ï¼‰ */ private volatile IoSession session;&#125; æ„é€ æ–¹æ³•1234public MinaClient(final URL url, final ChannelHandler handler) throws RemotingException &#123; // wrapChannelHandleræ–¹æ³•ç”¨äºåŒ…è£…ChannelHandlerï¼Œå…¶ä¸­å®ç°äº† Dubbo çº¿ç¨‹æ¨¡å‹çš„åŠŸèƒ½ã€‚ super(url, wrapChannelHandler(url, handler)); &#125; å’Œ NettyClient æœ¬è´¨ä¸€æ‘¸ä¸€æ ·ï¼Œä¸å†è¯´æ˜ã€‚ å¯åŠ¨å®¢æˆ·ç«¯ doOpen1234567891011121314151617181920212223@Override protected void doOpen() throws Throwable &#123; // URL ä¸² connectorKey = getUrl().toFullString(); SocketConnector c = connectors.get(connectorKey); if (c != null) &#123; connector = c; &#125; else &#123; // set thread pool. connector = new SocketConnector(Constants.DEFAULT_IO_THREADS, Executors.newCachedThreadPool(new NamedThreadFactory(\"MinaClientWorker\", true))); // config SocketConnectorConfig cfg = (SocketConnectorConfig) connector.getDefaultConfig(); cfg.setThreadModel(ThreadModel.MANUAL); cfg.getSessionConfig().setTcpNoDelay(true); cfg.getSessionConfig().setKeepAlive(true); int timeout = getConnectTimeout(); cfg.setConnectTimeout(timeout &lt; 1000 ? 1 : timeout / 1000); // set codec. ç¼–è§£ç å™¨æ”¯æŒ connector.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new MinaCodecAdapter(getCodec(), getUrl(), this))); connectors.put(connectorKey, connector); &#125; &#125; è¿æ¥æœåŠ¡å™¨ doConnect12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Override protected void doConnect() throws Throwable &#123; // æ ¹æ®æœåŠ¡åœ°å€è¿æ¥æœåŠ¡ ConnectFuture future = connector.connect(getConnectAddress(), new MinaHandler(getUrl(), this)); long start = System.currentTimeMillis(); final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;(); final CountDownLatch finish = new CountDownLatch(1); // resolve future.awaitUninterruptibly() dead lock // æ·»åŠ ç›‘å¬å™¨ future.addListener(new IoFutureListener() &#123; @Override public void operationComplete(IoFuture future) &#123; try &#123; // æœåŠ¡å‡†å¤‡å¥½äº† if (future.isReady()) &#123; // è·å–è¿æ¥é€šé“ IoSession newSession = future.getSession(); try &#123; // Close old channel å¯¹æ—§çš„é€šé“å¤„ç† IoSession oldSession = MinaClient.this.session; // copy reference if (oldSession != null) &#123; try &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Close old mina channel \" + oldSession + \" on create new mina channel \" + newSession); &#125; oldSession.close(); &#125; finally &#123; MinaChannel.removeChannelIfDisconnected(oldSession); &#125; &#125; &#125; finally &#123; // å¦‚æœå…³é—­ if (MinaClient.this.isClosed()) &#123; try &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Close new mina channel \" + newSession + \", because the client closed.\"); &#125; newSession.close(); &#125; finally &#123; MinaClient.this.session = null; MinaChannel.removeChannelIfDisconnected(newSession); &#125; &#125; else &#123; MinaClient.this.session = newSession; &#125; &#125; &#125; &#125; catch (Exception e) &#123; exception.set(e); &#125; finally &#123; finish.countDown(); &#125; &#125; &#125;); try &#123; finish.await(getConnectTimeout(), TimeUnit.MILLISECONDS); &#125; catch (InterruptedException e) &#123; throw new RemotingException(this, \"client(url: \" + getUrl() + \") failed to connect to server \" + getRemoteAddress() + \" client-side timeout \" + getConnectTimeout() + \"ms (elapsed: \" + (System.currentTimeMillis() - start) + \"ms) from netty client \" + NetUtils.getLocalHost() + \" using dubbo version \" + Version.getVersion() + \", cause: \" + e.getMessage(), e); &#125; Throwable e = exception.get(); if (e != null) &#123; throw e; &#125; &#125; è¿æ¥æœåŠ¡æµç¨‹å’Œ NettyClient ä¸€è‡´ã€‚ æ–­å¼€è¿æ¥ doDisConnect123456789@Override protected void doDisConnect() throws Throwable &#123; try &#123; // ç›´æ¥ä½¿ç”¨ Mina API ç§»é™¤å…³é—­çš„é€šé“ MinaChannel.removeChannelIfDisconnected(session); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage()); &#125; &#125; æ–­å¼€è¿æ¥ä»…ä»…æ˜¯åœ¨å®¢æˆ·ç«¯è¿æ¥æœåŠ¡çš„é€šé“å¤„äºå…³é—­çŠ¶æ€æ—¶ï¼ŒæŠŠå¯¹åº”çš„é€šé“ç¼“å­˜æ¸…é™¤ã€‚ è·å–è¿æ¥åˆ°æœåŠ¡çš„é€šé“ getChannel12345678@Override protected Channel getChannel() &#123; IoSession s = session; if (s == null || !s.isConnected()) &#123; return null; &#125; return MinaChannel.getOrAddChannel(s, getUrl(), this); &#125; è·å–è¿æ¥åˆ°æœåŠ¡çš„é€šé“æ˜¯çˆ¶ç±»çš„æ¨¡ç‰ˆæ–¹æ³•ï¼Œç”¨äºè¿”å›å…·ä½“NIOçš„é€šé“å¯¹åº”çš„ Dubbo é€šé“ï¼Œè¿™é‡Œæ˜¯è¿”å›Minaçš„é€šé“å¯¹åº”çš„Dubbo å±‚é¢çš„MinaChanel ã€‚ å°ç»“æ— è®ºæ˜¯ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ï¼Œè¿˜æ˜¯ ç½‘ç»œä¼ è¾“å±‚ éƒ½æ˜¯ä¸ºå…·ä½“å®ç°æœåŠ¡çš„ï¼Œå…·ä½“å®ç°ä¾èµ–ä¸Šå±‚æŠ½è±¡ï¼Œåœ¨ Mina è¿™ä¸ª NIO æ¡†æ¶çš„å®ç°è§’åº¦æ¥çœ‹ä¾èµ–çš„ä¸Šå±‚ï¼ˆdubbo-remoting-apiï¼‰æ˜¯é€æ˜çš„å³é€šç”¨çš„é€»è¾‘æ¨¡ç‰ˆã€‚æ•´ä¸ª Transport å±‚ç›¸å…³çš„æ ¸å¿ƒç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾ï¼š è‡³æ­¤ï¼ŒDubbo æ¥å…¥ Mina å®ç°ç½‘ç»œé€šä¿¡å°±ä»‹ç»å®Œäº†ï¼Œå…¶å®è¿™ç¯‡æ–‡ç« æ˜¯å¯¹ Netty4ç½‘ç»œé€šä¿¡ çš„åˆ å‰ªç‰ˆï¼Œä¸ºä»€ä¹ˆæ¥å…¥Nettyåº“å’Œæ¥å…¥Minaåº“å®ç°èµ·æ¥çš„å·®å¼‚å¦‚æ­¤ä¹‹å°ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ä¸¤è€…çš„æµç¨‹åŸºæœ¬ä¸€è‡´ï¼Œå¦‚æœéè¦è¯´åŒºåˆ«é‚£å°±æ˜¯ä¸¤è€…çš„ API å’Œå®ç°æœºåˆ¶ä¸åŒã€‚è¿™å¾—ç›Šäº Dubbo çš„ä¼˜ç§€è®¾è®¡ï¼Œå®ƒæŠŠ NIOåº“çš„å…±æ€§å…¨éƒ½è¿›è¡Œäº†æŠ½è±¡ï¼Œè¿›è€Œå±è”½ä¸åŒ NIO åº“ä¹‹é—´çš„å·®å¼‚ï¼Œæ‰©å±•æ€§å¤§å¤§å¢å¼ºã€‚åŒ…æ‹¬æ²¡æœ‰ä»‹ç»åˆ°çš„ dubbo-remoting-grizzly æ¨¡å—ï¼Œå®ç°æ¨¡å¼ä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Mina","slug":"Mina","permalink":"https://gentryhuang.com/tags/Mina/"}]},{"title":"Dubboæºç åˆ†æ - Netty4ç½‘ç»œé€šä¿¡","slug":"rpc/Netty4å®ç°","date":"2020-05-29T16:00:00.000Z","updated":"2020-12-01T01:45:15.786Z","comments":false,"path":"posts/4468445c/","link":"","permalink":"https://gentryhuang.com/posts/4468445c/","excerpt":"","text":"å‰è¨€åœ¨ ç½‘ç»œä¼ è¾“å±‚ ä¸­å¯¹ Transport é€šç”¨å±‚æˆ–è€…è¯´æ˜¯æŠ½è±¡å±‚è¿›è¡Œäº†è¯¦ç»†åˆ†æã€‚æ¥ä¸‹æ¥ä¼šç»§ç»­åˆ†æ Transport å±‚çš„ NIOåº“å®ç°ï¼Œæœ¬ç¯‡æ–‡ç« å°†åˆ†æ Dubbo å¦‚ä½•å°† Neety4 æ¥å…¥å®ç°ã€‚ æ¦‚è¿°åœ¨ NIO åº“çš„é€‰å‹ä¸Šï¼Œæœ‰å¾ˆå¤šä¼˜ç§€çš„å¼€æºæ¡†æ¶ï¼Œå¦‚ Nettyã€Minaã€Grizzy ç­‰ï¼ŒDubbo çš„é€‰æ‹©æ˜¯åˆ†åˆ«å¯¹è¿™äº›æ¡†æ¶è¿›è¡Œé›†æˆã€‚å¯¹ä¸Šå±‚è¿›è¡ŒæŠ½è±¡ä»¥å±è”½ä¸åŒ NIO åº“çš„å·®å¼‚ï¼ŒæŠ½è±¡å¯¹åº”çš„æ¨¡å—æ˜¯ dubbo-remoting-apiï¼Œåœ¨ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ä¸­ä»‹ç»äº†æ ¸å¿ƒçš„æ¥å£å’Œç±»ã€‚é’ˆå¯¹æ¯ä¸€ä¸ª NIO æ¡†æ¶çš„æ¥å…¥ï¼ŒDubbo éƒ½æ„å»ºä¸€ä¸ªå•ç‹¬çš„æ¨¡å—ï¼Œè¯¥æ¨¡å—åªéœ€å®ç°æŠ½è±¡æ¨¡å— dubbo-remoting-api å³å¯ï¼Œç»“åˆ Dubbo SPI æœºåˆ¶å¯ä»¥çµæ´»åˆ‡æ¢åˆ°ä¸åŒçš„ NIO åº“ã€‚ä¸‹é¢æˆ‘ä»¬å¼€å§‹ä»‹ç»å®ç°å±‚ dubbo-remoting-netty4 æ¨¡å—ï¼Œä»£ç ç»“æ„å¦‚ä¸‹ï¼š ä¸Šé¢çš„ä»£ç ç»“æ„è¯ é‡Šäº† â€œéº»é›€è™½å°äº”è„ä¿±å…¨â€ï¼Œä½œä¸ºä¸€ä¸ªé€šä¿¡æ¡†æ¶è¯¥æœ‰çš„åŸºæœ¬å…ƒç´ éƒ½å…·å¤‡äº†ã€‚æ³¨æ„ï¼Œåœ¨å½“å‰åˆ†æçš„ Dubbo ç‰ˆæœ¬ä¸­é»˜è®¤ä½¿ç”¨çš„æ˜¯ Netty3 å®ç°ï¼Œè€ƒè™‘åˆ°ç°åœ¨ä¸»æµ Netty4 è€Œä¸” Dubbo æœ€æ–°ç‰ˆæœ¬å·²ç»é»˜è®¤åˆ‡æ¢æˆäº† Netty4 å®ç°ï¼Œå¦ä¸€æ–¹é¢ Netty3 æ¥å…¥å’Œ Netty4 åŸºæœ¬ä¸€è‡´ï¼Œå› æ­¤å°±ä¸å†åˆ†æ Netty3 å®ç°ã€‚ é€šè¿‡ä¸‹é¢çš„ UML å›¾ä¼šæ›´åŠ æ¸…æ™°çœ‹åˆ° Netty4 å®ç°ä¸­å„ä¸ªåŠŸèƒ½ç±»ä¹‹é—´çš„å…³è”å…³ç³»ã€‚ä¸‹é¢æˆ‘ä»¬å°±æ ¹æ® UML å›¾çš„ä¾èµ–å…³ç³»é€ä¸ªåˆ†æã€‚ NettyTransporter1234567891011121314151617181920212223242526272829303132public class NettyTransporter implements Transporter &#123; /** * æ‹“å±•å */ public static final String NAME = \"netty4\"; /** * ç»‘å®šä¸€ä¸ªæœåŠ¡å™¨ * * @param url æœåŠ¡å™¨åœ°å€ * @param listener é€šé“å¤„ç†å™¨ * @return server è¿”å›æœåŠ¡å™¨ * @throws RemotingException */ @Override public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123; return new NettyServer(url, listener); &#125; /** * è¿æ¥ä¸€ä¸ªæœåŠ¡å™¨ï¼Œå³åˆ›å»ºä¸€ä¸ªå®¢æˆ·ç«¯ * * @param url æœåŠ¡å™¨åœ°å€ * @param listener é€šé“å¤„ç†å™¨ * @return client å®¢æˆ·ç«¯ * @throws RemotingException */ @Override public Client connect(URL url, ChannelHandler listener) throws RemotingException &#123; return new NettyClient(url, listener); &#125;&#125; NettyTransporter å®ç°äº† Transporter æ‰©å±•æ¥å£ï¼Œå…³äº Transporter æ‰©å±•æ¥å£å·²ç»åœ¨ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ä¸­è¿›è¡Œäº†ä»‹ç»ï¼Œé»˜è®¤æ‰©å±•å®ç°æ˜¯ netty å³ Netty3 å®ç°ã€‚bind() å’Œ connect() æ–¹æ³•åˆ†åˆ«ç”¨äºåˆ›å»º NettyServer å’Œ NettyClient å¯¹è±¡ã€‚ä¸€èˆ¬ Transport æ‰©å±•å®ç°ä¼šç”± Transport çš„é—¨é¢ Transports ç»Ÿä¸€å‘ä¸Šå±‚æä¾›ï¼Œè¿™ä¸ªä¸Šå±‚å°±æ˜¯ Exchange ä¿¡æ¯äº¤äº’å±‚ã€‚ä¸‹é¢æˆ‘ä»¬ç»§ç»­åˆ†æ NettyTransporter åˆ›å»ºçš„æœåŠ¡å’Œå®¢æˆ·ç«¯ã€‚ NettyServerNettyServer æ˜¯åŸºäº Netty4 å®ç°çš„æœåŠ¡ï¼Œä¸‹é¢æˆ‘ä»¬å¯¹å®ƒçš„å±æ€§ã€æ„é€ æ–¹æ³•ä»¥åŠåŸºæœ¬æ–¹æ³•è¿›è¡Œè¯¦ç»†è¯´æ˜ã€‚ å±æ€§123456789101112131415161718192021222324252627282930public class NettyServer extends AbstractServer implements Server &#123; private static final Logger logger = LoggerFactory.getLogger(NettyServer.class); /** * é€šé“é›†åˆ,è¿™é‡Œæ˜¯è¿æ¥åˆ°æœåŠ¡å™¨çš„å®¢æˆ·ç«¯é€šé“é›†åˆ * key: ip:port * value: Dubbo çš„ Channel */ private Map&lt;String, Channel&gt; channels; /** * Netty æœåŠ¡ç«¯çš„å¼•å¯¼ç±» */ private ServerBootstrap bootstrap; /** * Netty çš„ Channel */ private io.netty.channel.Channel channel; /** * boss çº¿ç¨‹ç»„ */ private EventLoopGroup bossGroup; /** * worker çº¿ç¨‹ç»„ */ private EventLoopGroup workerGroup;&#125; NettyServer ç»§æ‰¿äº† AbstractServerï¼Œå¹¶å®ç°äº† Server æ¥å£ï¼Œæ˜¯ Netty æœåŠ¡å®ç°ç±»ã€‚NettyServer é€šè¿‡å±‚å±‚ç»§æ‰¿æ‹¥æœ‰äº†å¾ˆå¤šç±»çš„èŒèƒ½ï¼Œå¦‚ ç«¯ç‚¹ï¼ˆEndpointï¼‰ã€é€šé“å¤„ç†ï¼ˆChannelHandlerï¼‰ã€(æœåŠ¡ç«¯)Server ï¼Œå…¶ä¸­é—´æ¥å…³è”äº† ChannelHandlerï¼ˆAbstractPeerä¸­çš„å±æ€§ï¼‰å’Œ Codec2ï¼ˆAbstractEndpointä¸­çš„ï¼‰å¯¹è±¡ ã€‚ æ„é€ æ–¹æ³•1234567891011121314public class NettyServer extends AbstractServer implements Server &#123; /** * åˆ›å»º NettyServer æ—¶ï¼Œä¼šå¯¹ä¼ å…¥çš„ ChannelHandler è¿›è¡Œå±‚å±‚åŒ…è£…ã€‚ * å…¶ä¸­åœ¨åŒ…è£…è¿‡ç¨‹ä¸­ï¼Œ Dispatcheråˆ›å»ºçš„ChanglHandlerçš„è¿‡ç¨‹éƒ½è¦åˆ›å»ºä¸€ä¸ªçº¿ç¨‹æ± ï¼Œç„¶åä¿å­˜åˆ°Datasource ä¸­ã€‚ todo 2.7.7 å¯¹æ¬¡åšäº†ä¼˜åŒ– * * @param url * @param handler * @throws RemotingException */ public NettyServer(URL url, ChannelHandler handler) throws RemotingException &#123; // ChannelHandlers.wrapæ–¹æ³•ï¼Œç”¨æ¥åŒ…è£… ChannelHandlerï¼Œå®ç°Dubbo çº¿ç¨‹æ¨¡å‹çš„åŠŸèƒ½ã€‚ SERVER_THREAD_POOL_NAME -&gt; 'DubboServerHandler' super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME))); &#125;&#125; NettyServer çš„æ„é€ æ–¹æ³•ä¸»è¦ä¸¤ä¸ªå·¥ä½œï¼Œä½†è¿™ä¸¤ä¸ªå·¥ä½œä¿¡æ¯é‡éå¸¸å¤§ã€‚å¯¹ä¸Šå±‚ä¼ å…¥çš„ ChannelHandler è¿›è¡ŒåŒ…è£…ï¼Œè°ƒç”¨çˆ¶ç±» AbstractServer çš„æ„é€ æ–¹æ³•ã€‚åŒ…è£… ChannelHandler çš„æ–¹æ³•åœ¨ ç½‘ç»œä¼ è¾“å±‚ ä¸­å·²ç»è¯¦ç»†è¯´æ˜ï¼Œä¼šè‡ªåŠ¨ä¸ºä¼ å…¥çš„ ChannelHandler å¤–é¢åŒ…è£¹ä¸‰å±‚ ChannelHandlerï¼Œå³ MultiMessageHandler(HeartbeatHandler(çº¿ç¨‹æ¨¡å‹Handler(ä¼ å…¥çš„ChannelHandler))) ï¼Œå…¶ä¸­çº¿ç¨‹æ¨¡å‹Handleré»˜è®¤ä¸º AllChannelHandlerï¼Œçº¿ç¨‹æ¨¡å‹Handlerè¿›è¡Œåˆ›å»ºçš„æ—¶å€™ä¼šåˆå§‹åŒ–çº¿ç¨‹æ± å¹¶å­˜æ”¾åˆ° DataSource ä¸­ï¼ˆæ˜¯çˆ¶ç±» WrappedChannelHandler çš„èŒèƒ½ï¼‰ ã€‚ä¸‹é¢å¯¹è¿™ä¸¤ä»¶äº‹æ•´ä½“æ¦‚æ‹¬ï¼š å¯¹ä¼ å…¥çš„ ChannelHandler è¿›è¡ŒåŒ…è£…ï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªå¢å¼ºçš„ ChannelHandlerã€‚æ³¨æ„ï¼Œå®ƒä¸å†æ˜¯ä¼ å…¥è¿›æ¥çš„ ChannelHandler ã€‚ æ‰§è¡Œ super(URL,ChannelHandler) ï¼Œè°ƒç”¨çˆ¶ç±» AbstractServer çš„æ„é€ æ–¹æ³•ã€‚ å°†å¢å¼ºåçš„ ChannelHandler å’Œ ä¸Šå±‚ä¼ å…¥çš„ URL é€šè¿‡çˆ¶ç±»æ„é€ æ–¹æ³•å±‚å±‚å‘ä¸‹ä¼ é€’ï¼Œç›´åˆ° AbstractPeer æŠ½è±¡ç±»ï¼Œè¯¥ç±»å°† ChannelHandler å’Œ URL ä¿å­˜èµ·æ¥ã€‚ ç¬¬ 3 æ­¥å‘ä¸Šè°ƒç”¨çˆ¶ç±»æ„é€ æ–¹æ³•æ—¶ï¼Œæ‰§è¡Œåˆ° AbstractEndpoint æŠ½è±¡ç±»æ—¶ï¼Œä¼šé€šè¿‡ä¼ é€’çš„ URL è·å– Codec2 çš„æ‰©å±•å®ç°ç±»ä»¥åŠè¶…æ—¶æ—¶é—´å’Œè¿æ¥è¶…æ—¶æ—¶é—´ã€‚ æ‰§è¡Œåˆ° AbstractServer æ„é€ æ–¹æ³•æ—¶ï¼Œåˆ†åˆ«è·å–æœåŠ¡åœ°å€ã€ç»‘å®šåœ°å€ã€æœ€å¤§å¯æ¥å—è¿æ¥æ•°ã€ç©ºé—²è¶…æ—¶æ—¶é—´ä»¥åŠä» DataSource ä¸­è·å–å½“å‰æœåŠ¡ç«¯å£å¯¹åº”çš„çº¿ç¨‹æ± ã€‚ ç¬¬ 5 æ­¥è¿˜æœ‰æœ€é‡è¦çš„ä¸€ä¸ªè¿‡ç¨‹ï¼Œè°ƒç”¨æ¨¡ç‰ˆæ–¹æ³•å¯åŠ¨æœåŠ¡ï¼Œè€Œè¿™ä¸ªæ¨¡ç‰ˆæ–¹æ³•æ¯ä¸ªå­ç±»æœåŠ¡éƒ½ä¼šè¿›è¡Œå®ç°ï¼Œè¿™é‡Œå°±æ˜¯ NettyServer çš„ doOpen æ–¹æ³•ã€‚ NettyServer æ„é€ æ–¹æ³•ä¸­ ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME) æ–¹æ³•ç”¨äºè®¾ç½®çº¿ç¨‹ååˆ° URL å‚æ•°ä¸­ï¼Œè¯¥ä¸ªçº¿ç¨‹ååŒ…å« URL çš„åœ°å€ä¿¡æ¯ï¼Œä»£ç å¦‚ä¸‹ï¼š 12345678--- ExecutorUtil public static URL setThreadName(URL url, String defaultName) &#123; // ä»URLä¸­è·å– threadname çš„å€¼ä½œä¸ºçº¿ç¨‹åï¼Œæ²¡æœ‰å°±ä½¿ç”¨defaultName String name = url.getParameter(Constants.THREAD_NAME_KEY, defaultName); name = name + \"-\" + url.getAddress(); url = url.addParameter(Constants.THREAD_NAME_KEY, name); return url; &#125; å¯åŠ¨æœåŠ¡æ–¹æ³• doOpen12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758--- NettyServer /** * å¯åŠ¨æœåŠ¡å™¨ * * @throws Throwable */ @Override protected void doOpen() throws Throwable &#123; // åˆ›å»ºå¼•å¯¼ç±» bootstrap = new ServerBootstrap(); // åˆ†åˆ«åˆ›å»ºBossçº¿ç¨‹ç»„å’ŒWorkerçº¿ç¨‹ç»„ bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory(\"NettyServerBoss\", true)); workerGroup = new NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS), new DefaultThreadFactory(\"NettyServerWorker\", true)); // åˆ›å»ºNettyServerHandlerå¯¹è±¡ï¼Œæ³¨æ„ä¼ å…¥çš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯ NettyServer å¯¹è±¡æœ¬èº«ï¼Œå› ä¸ºNettyServeræ˜¯ChannelHanderçš„å­ç±»ã€‚ // ç”±äº NettyServerHandler ç»§æ‰¿äº† ChannelDuplexHandlerï¼Œå› æ­¤å®ƒæ˜¯ Netty å±‚é¢çš„ ChannelHanlderã€‚ final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this); // è·å–å½“å‰NettyServeråˆ›å»ºçš„æ‰€æœ‰Channel channels = nettyServerHandler.getChannels(); bootstrap // è®¾ç½®çº¿ç¨‹ç»„ .group(bossGroup, workerGroup) // æœåŠ¡ç«¯ä½¿ç”¨NioServerSocketChannel ä½œä¸ºä¼ è¾“é€šé“ .channel(NioServerSocketChannel.class) // é…ç½®å¯é€‰é¡¹ï¼ŒNetty ä¼˜åŒ–ç›¸å…³ .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE) .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE) .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) // è®¾ç½®å‡ºå…¥ç«™é€šé“å¤„ç†å™¨é“¾ .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; @Override protected void initChannel(NioSocketChannel ch) throws Exception &#123; // åˆ›å»ºç¼–è§£ç é€‚é…å™¨,NettyCodecAdapterä¸­ä¼šåˆ›å»ºDecoderå’ŒEncoder NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this); // ChannelPipeline ch.pipeline() //.addLast(\"logging\",new LoggingHandler(LogLevel.INFO)) // æ‰“å°æ—¥å¿—ï¼Œæ–¹ä¾¿debug // æ³¨å†Œè§£ç å™¨ .addLast(\"decoder\", adapter.getDecoder()) // æ³¨å†Œç¼–ç å™¨ .addLast(\"encoder\", adapter.getEncoder()) // æ³¨å†ŒNettyServerHandler .addLast(\"handler\", nettyServerHandler); &#125; &#125;); // æœåŠ¡å™¨ç»‘å®šæŒ‡å®šåœ°å€å’Œç«¯å£ ï¼Œå¯åŠ¨ Netty ChannelFuture channelFuture = bootstrap.bind(getBindAddress()); // ç­‰å¾…ç»‘å®šå®Œæˆ channelFuture.syncUninterruptibly(); // è·å–æœåŠ¡é€šé“ï¼Œå³ç”¨æ¥æ¥æ”¶å®¢æˆ·ç«¯è¿æ¥çš„ Channel channel = channelFuture.channel(); &#125; å¯åŠ¨æœåŠ¡çš„æ–¹æ³•æ˜¯çˆ¶ç±»çš„ä¸€ä¸ªæ¨¡ç‰ˆæ–¹æ³•ï¼Œè¯¥æ–¹æ³•çš„ä¿¡æ¯é‡å¾ˆå¤§ï¼Œä» Netty è§’åº¦çœ‹å°±æ˜¯ä½¿ç”¨çš„æ ‡å‡†åŒ–æµç¨‹å¹¶æ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«çš„åœ°æ–¹ï¼Œä½†æ˜¯ä» Dubbo çš„è§’åº¦çœ‹æ¶‰åŠå¾ˆå¤šæ ¸å¿ƒç»„ä»¶ã€‚ä¸‹é¢å¯¹ä¸»è¦çš„è¿‡ç¨‹è¿›è¡Œæ¦‚æ‹¬ï¼š åˆå§‹åŒ– ServerBootstrap ã€åˆ›å»º Boss çº¿ç¨‹ç»„å’Œ Worker çº¿ç¨‹ç»„ã€‚ åˆ›å»º Dubbo å±‚é¢çš„ NettyServerHandler å¯¹è±¡ï¼Œå› å…¶ç»§æ‰¿äº† ChannelDuplexHandler ç±»ï¼Œå› æ­¤å®ƒåˆå±äº Netty å±‚é¢çš„ ChannelHandlerï¼Œè¿™ç»™å‡ºäº†ä¸€ä¸ªéå¸¸é‡è¦çš„ä¿¡æ¯ï¼Œé‚£å°±æ˜¯è¯¥å¯¹è±¡æœ‰å¤„ç† Netty é€šé“æ¶ˆæ¯æˆ–äº‹ä»¶çš„èƒ½åŠ›ã€‚ è·å– NettyServerHandler ä¸­ç»´æŠ¤çš„ channels ç¼“å­˜é›†åˆï¼Œè¯¥é›†åˆæ˜¯ io.netty.channel.Channel.remoteAddress åˆ° Dubboå±‚é¢çš„ NettyChannel çš„æ˜ å°„ï¼Œè€Œ NettyChannel å†…éƒ¨å°è£…äº† Nettyçš„Channelï¼ŒNettyChannel å’Œ Nettyçš„Channel æ˜¯ä¸€ä¸€å¯¹åº”çš„å…³ç³»ã€‚ä»ä»£ç ä¸­ä¸éš¾çœ‹å‡º NettyServer å’Œ NettyServerHandler å…±ç”¨ä¸€ä¸ª channels ç¼“å­˜é›†åˆã€‚å½“æœ‰è¿æ¥åˆ›å»ºæ—¶ï¼Œå…ˆæ˜¯åˆ›å»ºè¯¥Nettyè¿æ¥å¯¹åº”çš„Dubboå±‚é¢çš„NettyChannelï¼ˆä¸å­˜åœ¨çš„æƒ…å†µä¸‹ï¼‰ï¼Œç„¶å channels å°±ä¼šæŠŠè¯¥NettyChannelç¼“å­˜èµ·æ¥ã€‚å½“æœ‰è¿æ¥æ–­å¼€æ—¶ï¼Œå°±æ ¹æ®å½“å‰Nettyè¿æ¥çš„ remoteAddress ä» channels ä¸­ç§»é™¤å¯¹åº”çš„NettyChannelã€‚ è®¾ç½®æœåŠ¡ä¾§ Channel ç±»å‹ä¸º NioServerSocketChannelï¼Œå¹¶è®¾ç½®ä¸€äº›å¯é€‰é¡¹ç”¨æ¥ä¼˜åŒ–Nettyã€‚ åˆ›å»º ChannelInitializer å¹¶æŒ‡å®šå¦‚ä½•åˆå§‹åŒ– Channel ä¸Šçš„ ChannelHandler ç­‰ä¸€ç³»åˆ— Netty ä½¿ç”¨çš„æ ‡å‡†åŒ–æµç¨‹ï¼Œå…¶ä¸­æ³¨å†Œäº†ç¼–è§£ç å™¨å’Œ NettyServerHandler å¯¹è±¡ã€‚ åœ¨ç¬¬ 5 æ­¥ä¸­ï¼Œä¼šåˆ†åˆ«åˆ›å»ºNettyçš„ç¼–ç å™¨å’Œè§£ç å™¨ï¼ŒNettyCodecAdapter åªæ˜¯ä¸€ä¸ªé€‚é…å¯¹è±¡ï¼Œå…¶ä¸¤ä¸ªå†…éƒ¨ç±»æ‰æ˜¯çœŸæ­£çš„ Netty çš„ç¼–è§£ç å™¨ã€‚ ä¸‹æ–‡ä¼šå¯¹è¯¥è¿‡ç¨‹æ¶‰åŠçš„æ¥å£åŠå®ç°ç±»åˆ†åˆ«è¯´æ˜ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ç»§ç»­åˆ†æ NettyServer ä¸­çš„æ–¹æ³•ï¼Œæ­¤åæˆ‘ä»¬è¦æ—¶åˆ»ç‰¢è®° NettyServer é€šè¿‡å±‚å±‚ç»§æ‰¿æ‹¥æœ‰äº†å¾ˆå¤šç±»çš„èŒèƒ½ã€‚ å…³é—­æœåŠ¡æ–¹æ³• doClose1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253--- NettyServer /** * å…³é—­æœåŠ¡å™¨ * * @throws Throwable */ @Override protected void doClose() throws Throwable &#123; try &#123; if (channel != null) &#123; // å…³é—­æœåŠ¡å™¨é€šé“ channel.close(); &#125; &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; // å…³é—­è¿æ¥åˆ°æœåŠ¡å™¨çš„å®¢æˆ·ç«¯é€šé“ try &#123; Collection&lt;com.alibaba.dubbo.remoting.Channel&gt; channels = getChannels(); if (channels != null &amp;&amp; channels.size() &gt; 0) &#123; // ä¾æ¬¡éå†è¿æ¥åˆ°æœåŠ¡å™¨çš„å®¢æˆ·ç«¯é€šé“ï¼Œç„¶åè¿›è¡Œå…³é—­æ“ä½œ for (com.alibaba.dubbo.remoting.Channel channel : channels) &#123; try &#123; channel.close(); &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; &#125; &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; // ä¼˜é›…å…³é—­çº¿ç¨‹ç»„ try &#123; if (bootstrap != null) &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; // æ¸…ç©ºè¿æ¥åˆ°æœåŠ¡å™¨çš„å®¢æˆ·ç«¯é€šé“ try &#123; if (channels != null) &#123; channels.clear(); &#125; &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; å…³é—­æœåŠ¡ä¸»è¦å·¥ä½œå¦‚ä¸‹ï¼š å…³é—­æœåŠ¡é€šé“ channel å…³é—­è¿æ¥åˆ°æœåŠ¡çš„å®¢æˆ·ç«¯é€šé“é›†åˆä»¬ å…³é—­çº¿ç¨‹ç»„ æ¸…ç©ºè¿æ¥åˆ°æœåŠ¡çš„å®¢æˆ·ç«¯é€šé“ç¼“å­˜ è·å¾—å®¢æˆ·ç«¯é€šé“é›†åˆ12345678910111213141516--- NettyServer @Override public Collection&lt;Channel&gt; getChannels() &#123; Collection&lt;Channel&gt; chs = new HashSet&lt;Channel&gt;(); for (Channel channel : this.channels.values()) &#123; // å·²è¿æ¥ï¼Œåˆ™åŠ å…¥ç»“æœé›† if (channel.isConnected()) &#123; chs.add(channel); // æœªè¿æ¥ï¼Œç§»é™¤ &#125; else &#123; channels.remove(NetUtils.toAddressString(channel.getRemoteAddress())); &#125; &#125; return chs; &#125; ä»¥ä¸Šä»£ç ç”¨äºè·å–è¿æ¥åˆ°æœåŠ¡çš„å®¢æˆ·ç«¯é€šé“é›†åˆï¼Œæ³¨æ„åªä¼šç­›é€‰ç›®å‰è¿æ¥åˆ°æœåŠ¡çš„é€šé“ã€‚ æ˜¯å¦å¯åŠ¨æˆåŠŸ1234@Overridepublic boolean isBound() &#123; return channel.isActive();&#125; è°ƒç”¨ Netty API åˆ¤æ–­æœåŠ¡é€šé“æ˜¯å¦å¼€å¯ã€‚ NettyChannelNettyChannel ç»§æ‰¿äº† AbstractChannelï¼Œæ˜¯å¯¹ io.netty.channel.Channel çš„è£…é¥°ï¼Œä½¿ç”¨äº†è£…é¥°è€…æ¨¡å¼ï¼Œä¸ io.netty.channel.Channel æ˜¯ä¸€å¯¹ä¸€çš„å…³ç³»ã€‚ å±æ€§123456789101112131415161718192021222324252627282930313233343536final class NettyChannel extends AbstractChannel &#123; private static final Logger logger = LoggerFactory.getLogger(NettyChannel.class); /** * Nettyçš„Channel åˆ° Dubboçš„Channel æ˜ å°„é›†åˆ * key: Netty çš„ Channel * value: NettyChannel */ private static final ConcurrentMap&lt;Channel, NettyChannel&gt; channelMap = new ConcurrentHashMap&lt;Channel, NettyChannel&gt;(); /** * Nettyçš„Channelï¼Œå’Œå½“å‰çš„ Dubbo Channelå¯¹è±¡ä¸€ä¸€å¯¹åº” */ private final Channel channel; /** * å½“å‰Channel ä¸­é™„åŠ å±æ€§é›†åˆ */ private final Map&lt;String, Object&gt; attributes = new ConcurrentHashMap&lt;String, Object&gt;(); /** * è£…é¥° Nettyçš„Channel * * @param channel Nettyçš„Channel * @param url URL * @param handler handler */ private NettyChannel(Channel channel, URL url, ChannelHandler handler) &#123; super(url, handler); if (channel == null) &#123; throw new IllegalArgumentException(\"netty channel == null;\"); &#125; this.channel = channel; &#125;&#125; NettyChannel ä¸­çš„å±æ€§å·²ç»è¯¦ç»†æ ‡æ³¨ï¼Œå…¶ä¸­å®ƒçš„æ„é€ æ–¹æ³•æ˜¯ç§æœ‰çš„ï¼Œè°ƒç”¨å…¥å£åªæœ‰ä¸€ä¸ªï¼Œæ˜¯è¯¥ç±»å†…éƒ¨æ–¹æ³• â€“ getOrAddChannel() ã€‚ æ ¸å¿ƒæ–¹æ³•åˆ›å»º NettyChannel1234567891011121314151617181920--- NettyChannel static NettyChannel getOrAddChannel(Channel ch, URL url, ChannelHandler handler) &#123; if (ch == null) &#123; return null; &#125; NettyChannel ret = channelMap.get(ch); if (ret == null) &#123; // åˆ›å»º NettyChannelï¼Œå°è£… Nettyçš„ Channel NettyChannel nettyChannel = new NettyChannel(ch, url, handler); // å¤„äºè¿æ¥ä¸­ if (ch.isActive()) &#123; // æ·»åŠ åˆ° é€šé“é›†åˆç¼“å­˜ä¸­ ret = channelMap.putIfAbsent(ch, nettyChannel); &#125; if (ret == null) &#123; ret = nettyChannel; &#125; &#125; return ret; &#125; ä¼˜å…ˆä»ç¼“å­˜ä¸­æ‰¾ï¼Œæ‰¾ä¸åˆ°åˆ™åˆ›å»º NettyChannel å¯¹è±¡ï¼ŒNettyChannel å¯¹è±¡å°è£…äº† io.netty.channel.Channel å¯¹è±¡ã€ä¼ å…¥çš„ ChannelHandler å’Œ URLï¼Œå¦‚æœå°è£…çš„ Netty é€šé“æ˜¯è¿æ¥çŠ¶æ€ï¼Œåˆ™åŠ å…¥ç¼“å­˜ã€‚éœ€è¦ç‰¹åˆ«è¯´æ˜çš„æ˜¯ï¼ŒNettyChannel ç»§æ‰¿äº† AbstractChannelï¼Œè€Œ AbstractChannel åˆç»§æ‰¿äº† AbstractPeer æŠ½è±¡ç±»ï¼Œåœ¨ ç½‘ç»œä¼ è¾“å±‚ ä¸­å·²ç»è¯¦ç»†ä»‹ç»è¿‡äº†AbstractPeer æŠ½è±¡ç±»ï¼Œå®ƒæ˜¯æ•´ä¸ª Remoting å±‚é“¾è·¯æœ€åº•å±‚ï¼Œä¸Šå±‚ä¼ å…¥çš„ ChannelHandler ä¼šæœ€ç»ˆä¿å­˜åœ¨è¯¥ç±»ä¸­ã€‚å› æ­¤ï¼ŒgetOrAddChannel() æ–¹æ³•ä¸ä»…åˆ›å»ºäº† NettyChannelï¼Œä¹Ÿè®¾ç½®äº† AbstractPeer ç±»ä¸­çš„ ChannelHandler å’Œ URL å±æ€§çš„å€¼ï¼Œè¿™æ„å‘³ç€ AbstractPeer å½“å‰å­ç±»å¯¹è±¡å…³è”äº†è¿™ä¸¤ä¸ªå±æ€§çš„å€¼ã€‚ å‘é€æ¶ˆæ¯è¯¥æ–¹æ³•æ˜¯ Endpoint æ¥å£ä¸­çš„æ–¹æ³•ï¼Œå¹¶é Channel æ¥å£ä¸­çš„æ–¹æ³•ï¼ŒChannelæ¥å£æ²¡æœ‰å‘é€æ¶ˆæ¯çš„æ–¹æ³•ã€‚å®ƒä¼šé€šè¿‡è£…é¥°çš„ Netty æ¡†æ¶ Channel å°†æ•°æ®å‘é€åˆ°å¯¹ç«¯ï¼Œå¹¶ä¸”æ”¯æŒç­‰å¾…å‘é€å®Œæˆã€‚ 12345678910111213141516171819202122232425262728293031323334--- NettyChannel @Override public void send(Object message, boolean sent) throws RemotingException &#123; // æ£€æŸ¥è¿æ¥æ˜¯å¦å¯ç”¨ super.send(message, sent); // æ˜¯å¦æ‰§è¡ŒæˆåŠŸã€‚ å¦‚æœä¸éœ€è¦ç­‰å¾…å‘é€æˆåŠŸï¼ˆsent = falseï¼‰ï¼Œé»˜è®¤å°±æ˜¯æˆåŠŸçŠ¶æ€ boolean success = true; int timeout = 0; try &#123; // ä½¿ç”¨Netty çš„ Channel å‘é€æ¶ˆæ¯ ChannelFuture future = channel.writeAndFlush(message); // ä¸ºtrueçš„è¯ï¼Œä¼šç­‰å¾…æ¶ˆæ¯å‘é€æˆåŠŸæˆ–è€…è¶…æ—¶ if (sent) &#123; timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT); success = future.await(timeout); &#125; // å‘ç”Ÿå¼‚å¸¸å°±æŠ›å‡º Throwable cause = future.cause(); if (cause != null) &#123; throw cause; &#125; &#125; catch (Throwable e) &#123; throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress() + \", cause: \" + e.getMessage(), e); &#125; // å‘é€å¤±è´¥ï¼ŒæŠ›å‡ºå¼‚å¸¸ if (!success) &#123; throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress() + \"in timeout(\" + timeout + \"ms) limit\"); &#125; &#125; æ“ä½œé€šé“é™„åŠ å±æ€§123456789101112131415161718192021222324--- NettyChannel @Override public boolean hasAttribute(String key) &#123; return attributes.containsKey(key); &#125; @Override public Object getAttribute(String key) &#123; return attributes.get(key); &#125; @Override public void setAttribute(String key, Object value) &#123; if (value == null) &#123; // The null value unallowed in the ConcurrentHashMap. attributes.remove(key); &#125; else &#123; attributes.put(key, value); &#125; &#125; @Override public void removeAttribute(String key) &#123; attributes.remove(key); &#125; å…³é—­é€šé“123456789101112131415161718192021222324252627282930313233--- NettyChannel @Override public void close() &#123; try &#123; // æ ‡è®°å…³é—­ ï¼Œè®¾ç½® com.alibaba.dubbo.remoting.transport.AbstractPeer.closed çš„å€¼ä¸º true super.close(); &#125; catch (Exception e) &#123; logger.warn(e.getMessage(), e); &#125; try &#123; // ç§»é™¤æ–­å¼€è¿æ¥çš„Channelå¯¹åº”çš„Dubbo NettyChannel removeChannelIfDisconnected(channel); &#125; catch (Exception e) &#123; logger.warn(e.getMessage(), e); &#125; try &#123; // æ¸…ç©ºå±æ€§ attributes attributes.clear(); &#125; catch (Exception e) &#123; logger.warn(e.getMessage(), e); &#125; try &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Close netty channel \" + channel); &#125; // å…³é—­Netty çš„ Channelï¼Œæ³¨æ„åœ¨å…³é—­å‰å¯¹ä¸€äº›å…¶å®ƒèµ„æºè¿›è¡Œæ¸…ç†å·¥ä½œã€‚ channel.close(); &#125; catch (Exception e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; æ¸…ç† NettyChannel ç¼“å­˜123456static void removeChannelIfDisconnected(Channel ch) &#123; // Nettyçš„Channel æœªè¿æ¥ if (ch != null &amp;&amp; !ch.isActive()) &#123; channelMap.remove(ch); &#125; &#125; è·å–åœ°å€12345678910111213141516171819/** * è·å–æœ¬æœºåœ°å€ - Endpoint æ¥å£ä¸­çš„æ–¹æ³• * * @return */ @Override public InetSocketAddress getLocalAddress() &#123; return (InetSocketAddress) channel.localAddress(); &#125; /** * è·å–è¿œç¨‹åœ°å€ - Channel æ¥å£ä¸­çš„æ–¹æ³• * * @return */ @Override public InetSocketAddress getRemoteAddress() &#123; return (InetSocketAddress) channel.remoteAddress(); &#125; ç¼–è§£ç é€šè¿‡å‰æ–‡çš„ UML å…³ç³»å›¾ä»¥åŠ NettyServer å¯åŠ¨æœåŠ¡æ–¹æ³•ï¼Œæˆ‘ä»¬ä¸éš¾çœ‹å‡º NettyCodecAdapter å……å½“é€‚é…å™¨è§’è‰²ï¼Œä¸¥æ ¼æ¥è¯´å±äºå¯¹è±¡é€‚é…å™¨æ¨¡å¼ï¼Œå³ å°† Dubbo çš„ Codec2 ç¼–è§£ç å™¨é€‚é…æˆ Netty å±‚é¢çš„ç¼–ç å™¨å’Œè§£ç å™¨ï¼ŒNetty ä¼šæŠŠç¼–è§£ç å·¥ä½œå§”æ‰˜ç»™ Dubbo çš„ Codec2 ç¼–è§£ç å™¨å»å¤„ç†ã€‚ç›¸å…³å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š åœ¨ ç½‘ç»œä¼ è¾“å±‚ ä¸­å·²ç»è¯¦ç»†ä»‹ç»è¿‡äº† AbstractEndpoint æŠ½è±¡ç±»ï¼Œè¯¥æŠ½è±¡ç±»ä¸­çš„ codec å±æ€§æ­£æ˜¯ Codec2 ç±»å‹ï¼Œè¯¥å±æ€§åœ¨ AbstractEndpoint æ„é€ æ–¹æ³•ä¸­è¢«åˆå§‹åŒ–ï¼Œè€Œ NettyServer é—´æ¥ç»§æ‰¿äº† AbstractEndpoint æŠ½è±¡ç±»ï¼Œåœ¨åˆ›å»º NettyServer å¯¹è±¡æ—¶è¯¥ç¼–è§£ç å±æ€§ä¹Ÿè¿›è¡Œäº†åˆå§‹åŒ–ã€‚ å±æ€§åŠæ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final class NettyCodecAdapter &#123; /** * Netty çš„ ç¼–ç å™¨ã€‚å†…éƒ¨å°è£…çš„Codec2 ï¼Œæ˜¯åœ¨ &#123;@link com.alibaba.dubbo.remoting.transport.AbstractEndpoint&#125; ä¸­åˆ›å»ºçš„ */ private final ChannelHandler encoder = new InternalEncoder(); /** * Netty çš„ è§£ç å™¨ã€‚å†…éƒ¨å°è£…çš„Codec2 ï¼Œæ˜¯åœ¨ &#123;@link com.alibaba.dubbo.remoting.transport.AbstractEndpoint&#125; ä¸­åˆ›å»ºçš„ */ private final ChannelHandler decoder = new InternalDecoder(); /** * Dubbo çš„ ç¼–è§£ç å™¨ */ private final Codec2 codec; /** * Dubbo URL */ private final URL url; /** * Dubbo çš„ ChannelHandler */ private final com.alibaba.dubbo.remoting.ChannelHandler handler; public NettyCodecAdapter(Codec2 codec, URL url, com.alibaba.dubbo.remoting.ChannelHandler handler) &#123; this.codec = codec; this.url = url; this.handler = handler; &#125; /** * è·å–ç¼–ç å™¨ * * @return */ public ChannelHandler getEncoder() &#123; return encoder; &#125; /** * è·å–è§£ç å™¨ * * @return */ public ChannelHandler getDecoder() &#123; return decoder; &#125;&#125; ç¼–ç å™¨å®ç°123456789101112131415161718192021222324252627282930--- NettyCodecAdapter /** * ç¼–ç å™¨ - MessageToByteEncoderï¼šç¼–ç å™¨æŠ½è±¡ç±» */ private class InternalEncoder extends MessageToByteEncoder &#123; /** * @param ctx ChannelHandler çš„ä¸Šä¸‹æ–‡ * @param msg msg * @param out ç¼“å†²åŒº * @throws Exception */ @Override protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception &#123; // åˆ›å»º NettyBackedChannelBuffer com.alibaba.dubbo.remoting.buffer.ChannelBuffer buffer = new NettyBackedChannelBuffer(out); // ä»å½“å‰ChannelHandlerContextä¸­è·å–å¯¹åº”çš„ Channel å¯¹è±¡ // Channel : pipeline : ChannelHandler : ChannelHandlerContext = 1:1:n:n Channel ch = ctx.channel(); // è·å– Netty é€šé“å¯¹åº”çš„ Dubbo Channel NettyChannel channel = NettyChannel.getOrAddChannel(ch, url, handler); try &#123; // ç¼–ç ï¼Œå°†è§£ç ä»»åŠ¡å§”æ‰˜ç»™ Codec2 å®ç°å»å®Œæˆ codec.encode(channel, buffer, msg); &#125; finally &#123; // ç§»é™¤ Nettyçš„Channelå…³è”çš„ç¼“å­˜ NettyChannel.removeChannelIfDisconnected(ch); &#125; &#125; &#125; è§£ç å™¨å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051--- NettyCodecAdapter /** * è§£ç å™¨ - ByteToMessageDecoderï¼š è§£ç å™¨æŠ½è±¡ç±» */ private class InternalDecoder extends ByteToMessageDecoder &#123; @Override protected void decode(ChannelHandlerContext ctx, ByteBuf input, List&lt;Object&gt; out) throws Exception &#123; // åˆ›å»ºDubbo å¯¹ Netty çš„ç¼“å­˜åŒºå°è£…çš„ NettyBackedChannelBuffer å¯¹è±¡ ChannelBuffer message = new NettyBackedChannelBuffer(input); // è·å– Netty é€šé“å¯¹åº”çš„ Dubbo Channel NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler); Object msg; int saveReaderIndex; try &#123; // å¾ªç¯è§£ææ•°æ®ï¼Œç›´åˆ°ç»“æŸ do &#123; // è®°å½•å½“å‰è¯»è¿›åº¦ saveReaderIndex = message.readerIndex(); try &#123; // å°†è§£ç ä»»åŠ¡å§”æ‰˜ç»™ Codec2 å®Œæˆ msg = codec.decode(channel, message); &#125; catch (IOException e) &#123; throw e; &#125; // éœ€è¦æ›´å¤šçš„è¾“å…¥ï¼Œå³æ¶ˆæ¯ä¸å®Œæ•´ï¼Œæ ‡è®°å›åŸæœ‰è¯»è¿›åº¦ï¼Œå¹¶ç»“æŸ if (msg == Codec2.DecodeResult.NEED_MORE_INPUT) &#123; message.readerIndex(saveReaderIndex); break; // è§£ç åˆ°æ¶ˆæ¯ï¼Œæ·»åŠ åˆ° outé›†åˆä¸­ï¼Œå³ å°†è¯»å–åˆ°çš„æ¶ˆæ¯ä¼ é€’ç»™åé¢çš„Handlerå¤„ç† &#125; else &#123; //is it possible to go here ? todo if (saveReaderIndex == message.readerIndex()) &#123; throw new IOException(\"Decode without read data.\"); &#125; if (msg != null) &#123; out.add(msg); &#125; &#125; &#125; while (message.readable()); &#125; finally &#123; // ç§»é™¤ Nettyçš„Channel å…³è”çš„ç¼“å­˜ NettyChannel.removeChannelIfDisconnected(ctx.channel()); &#125; &#125; &#125;&#125; NettyServerHandlerNettyServerHandler ç»§æ‰¿äº† io.netty.channel.ChannelDuplexHandler ï¼Œè¿™æ˜¯ Netty æä¾›çš„ä¸€ä¸ªåŒæ—¶å¤„ç†å…¥ç«™æ•°æ®å’Œå‡ºç«™æ•°æ®çš„ ChannelHandler ï¼Œä½œä¸º Netty4 çš„é€šé“å¤„ç†å™¨ã€‚ å±æ€§12345678910111213141516171819202122232425262728293031@io.netty.channel.ChannelHandler.Sharablepublic class NettyServerHandler extends ChannelDuplexHandler &#123; /** * Dubbo Channel é›†åˆ,å³è¿æ¥åˆ°å½“å‰æœåŠ¡çš„Dubbo Channelé›†åˆ * key: Netty é€šé“çš„ remoteAddress * value: Dubbo çš„ Channel */ private final Map&lt;String, Channel&gt; channels = new ConcurrentHashMap&lt;String, Channel&gt;(); /** * URL */ private final URL url; /** * Dubbo ChannelHandlerã€‚NettyServerHandler ä¸­å‡ ä¹æ‰€æœ‰æ–¹æ³•éƒ½ä¼šè§¦å‘è¯¥å¯¹è±¡ã€‚ */ private final ChannelHandler handler; public NettyServerHandler(URL url, ChannelHandler handler) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; if (handler == null) &#123; throw new IllegalArgumentException(\"handler == null\"); &#125; this.url = url; this.handler = handler; &#125;&#125; åœ¨ NettyServerHandler ä¸­æœ‰ channelsã€handler ä»¥åŠ url å±æ€§ã€‚ä¸‹é¢åˆ†åˆ«è¯´æ˜å¯¹åº”å±æ€§ï¼š channels å±æ€§ï¼šä¿å­˜å½“å‰ Server åˆ›å»ºçš„æ‰€æœ‰ Dubbo Channelï¼Œè¿æ¥åˆ›å»ºã€è¿æ¥æ–­å¼€éƒ½ä¼šæ“ä½œ channels é›†åˆè¿›è¡Œç›¸åº”çš„å¢åˆ ã€‚å…¶ä¸­ ServerHandler ä¹Ÿä¼šä½¿ç”¨è¯¥å±æ€§å€¼ã€‚ url å±æ€§ï¼š é€šè¿‡æ„é€ æ–¹æ³•ä¼ å…¥ã€‚ handlerå±æ€§ï¼šé€šé“å¤„ç†å™¨ï¼Œæ˜¯ NettyServer å¯¹è±¡ã€‚NettyServerHandler ä¸­å‡ ä¹æ‰€æœ‰æ–¹æ³•éƒ½ä¼šè§¦å‘è¯¥ ChannelHandler å¯¹è±¡ã€‚ é€šé“å¤„ç†æ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108--- NettyServerHandler //--------- NettyServerHandler ä¸­ä»¥ä¸‹æ‰€æœ‰æ–¹æ³•éƒ½ä¼šè§¦å‘è£…é¥°çš„ ChannelHandler å¯¹è±¡ ------------/ /** * è¿æ¥åˆ›å»ºè§¦å‘è¯¥æ–¹æ³• * * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; // äº¤ç»™ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å¤„ç† ctx.fireChannelActive(); // åˆ›å»ºDubbo çš„NettyChannel å¯¹è±¡ NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler); try &#123; // åŠ å…¥åˆ° è¿æ¥åˆ°æœåŠ¡çš„ Dubbo Channelé›†åˆ ä¸­ if (channel != null) &#123; channels.put(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()), channel); &#125; // äº¤ç»™ handler å¤„ç†ï¼Œå¤„ç†è¿æ¥äº‹ä»¶ handler.connected(channel); &#125; finally &#123; /** å¦‚æœå·²ç»æ–­å¼€ï¼Œå°±ç§»é™¤NettyChannelå¯¹è±¡ &#123;@link com.alibaba.dubbo.remoting.transport.netty4.NettyChannel.channelMap &#125;*/ NettyChannel.removeChannelIfDisconnected(ctx.channel()); &#125; &#125; /** * è¿æ¥æ–­å¼€è§¦å‘è¯¥æ–¹æ³• * * @param ctx * @throws Exception */ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler); try &#123; // ä»ç¼“å­˜ä¸­ç§»é™¤ Netty Channel å¯¹åº”çš„ Dubbo Channel channels.remove(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress())); // å°†æ–­å¼€è¿æ¥äº‹ä»¶äº¤ç»™ handlerå¤„ç† handler.disconnected(channel); &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(ctx.channel()); &#125; &#125; @Override public void disconnect(ChannelHandlerContext ctx, ChannelPromise future) throws Exception &#123; &#125; /** * è¯»å–æ•°æ® * * @param ctx * @param msg * @throws Exception */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler); try &#123; handler.received(channel, msg); &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(ctx.channel()); &#125; &#125; /** * å†™å…¥æ•°æ® * * @param ctx * @param msg * @param promise * @throws Exception */ @Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123; // å°†å‘é€çš„æ•°æ®ç»§ç»­å‘ä¸‹ä¼ é€’ super.write(ctx, msg, promise); NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler); try &#123; handler.sent(channel, msg); &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(ctx.channel()); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler); try &#123; handler.caught(channel, cause); &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(ctx.channel()); &#125; &#125; NettyServer &amp; NettyServerHandleråœ¨ NettyServer åˆ›å»º NettyServerHandler æ—¶ï¼Œä»£ç å¦‚ä¸‹ï¼š 123// åˆ›å»ºNettyServerHandlerå¯¹è±¡ï¼Œæ³¨æ„ä¼ å…¥çš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯ NettyServer å¯¹è±¡æœ¬èº«ï¼Œå› ä¸ºNettyServeræ˜¯ChannelHandlerçš„å­ç±»ã€‚// ç”±äº NettyServerHandler ç»§æ‰¿äº† ChannelDuplexHandlerï¼Œå› æ­¤å®ƒæ˜¯ Netty å±‚é¢çš„ ChannelHandlerã€‚final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this); ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è°ƒç”¨é—´æ¥çˆ¶ç±» AbstractPeer#getUrl() æ–¹æ³•è·å–ä¸Šå±‚ä¼ å…¥çš„ URLå¯¹è±¡ã€‚ç¬¬äºŒä¸ªå‚æ•°æ­£æ˜¯ NettyServer å¯¹è±¡æœ¬èº«ï¼Œé€šè¿‡ä¹‹å‰çš„ä»‹ç»ï¼Œæˆ‘ä»¬çŸ¥é“ NettyServer ç»§æ‰¿å…³ç³»ï¼Œå®ƒçš„çˆ¶ç±» AbstractPeer å®ç°äº† ChannelHandler æ¥å£ï¼Œå¹¶ä¸”å°†æ‰€æœ‰æ–¹æ³•éƒ½å§”æ‰˜ç»™äº†å…¶è£…é¥°çš„ ChannelHandler å¯¹è±¡ã€‚å› æ­¤ï¼ŒNettyServerHandler ä¸­çš„é€šé“æ–¹æ³•éƒ½æ˜¯äº¤ç»™ NettyServer å…³è”çš„ ChannelHandler å¯¹è±¡æœ¬èº«ã€‚ NettyServer ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ç”±ä¸Šå›¾å¯çŸ¥ï¼ŒDubbo æ¥å…¥ Netty4 è¿™ä¸ª NIO æ¡†æ¶æœåŠ¡å™¨éƒ¨åˆ†å…·ä½“å®ç°è¿˜æ˜¯å¾ˆç›´è§‚çš„ï¼Œå›¾ä¸­æœ‰å››ä¸ªå…ƒç´ ï¼šç«¯ç‚¹ï¼ˆNettyServerï¼‰ã€é€šé“ï¼ˆNettyChannelï¼‰ã€ç¼–ç å™¨ï¼ˆInternalEncoderï¼‰å’Œè§£ç å™¨ï¼ˆInternalDecoderï¼‰ã€é€šé“å¤„ç†å™¨ï¼ˆNettyServerHandlerï¼‰ã€‚ä» Transporter å±‚æ¥çœ‹ï¼ŒåŠŸèƒ½çš„ä¸åŒå…¶å®å°±æ˜¯æ³¨å†Œåœ¨ Channel ä¸Šçš„ ChannelHandler ä¸åŒï¼Œå¯¹äº Netty æ¥è¯´ç¼–è§£ç å™¨ä¹Ÿå±äºé€šé“å¤„ç†å™¨ï¼Œè€Œç«¯ç‚¹å’Œé€šé“è¿™ä¸¤ä¸ªå…ƒç´ æ˜¯å¿…é¡»å­˜åœ¨çš„ã€‚ è‡³æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° Dubbo é€šè¿‡è£…é¥°è€…æ¨¡å¼å±‚å±‚åŒ…è£… ChannelHandlerï¼Œä»è€Œä¸éœ€è¦å°†æ¯ä¸ª ChannelHandler éƒ½æŒ‚è½½åˆ° Pipeline ä¸­ï¼Œåœ¨ NettyServer ä»¥åŠä¸‹é¢ä»‹ç»çš„ NettyClient ä¸­æœ€å¤šæœ‰ 3 ä¸ª ChannelHandlerï¼Œåˆ†åˆ«æ˜¯ç¼–ç å™¨ã€è§£ç å™¨ä»¥åŠ NettyServerHandler(æˆ– NettyClientHandler)ã€‚ä¸ä»…æ˜¯ Netty å®ç°çš„ç½‘ç»œé€šä¿¡æ˜¯è¿™æ ·çš„ï¼ŒMina ç­‰å®ç°ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œè¿™åœ¨ä¸€å®šç¨‹åº¦ä¸Šé¿å…äº†ä½æ•ˆå’Œæµªè´¹èµ„æºã€‚ æœåŠ¡å°ç»“æ— è®ºæ˜¯ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ï¼Œè¿˜æ˜¯ ç½‘ç»œä¼ è¾“å±‚ éƒ½æ˜¯ä¸ºå…·ä½“å®ç°æœåŠ¡çš„ï¼Œå…·ä½“å®ç°ä¾èµ–ä¸Šå±‚æŠ½è±¡ï¼Œåœ¨ Netty4 è¿™ä¸ª NIO æ¡†æ¶çš„å®ç°è§’åº¦æ¥çœ‹ä¾èµ–çš„ä¸Šå±‚ï¼ˆdubbo-remoting-apiï¼‰æ˜¯é€æ˜çš„å³é€šç”¨çš„é€»è¾‘æ¨¡ç‰ˆã€‚æ•´ä¸ª Transport å±‚å’ŒæœåŠ¡ç›¸å…³çš„æ ¸å¿ƒç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾ï¼š è‡³æ­¤ï¼ŒDubbo æ¥å…¥ Netty4 çš„æœåŠ¡éƒ¨åˆ†å°±ä»‹ç»å®Œäº†ã€‚ä» AbstractPeer å¼€å§‹ä¸€è·¯ç»§æ‰¿ä¸‹æ¥ï¼ŒNettyServer æ‹¥æœ‰äº†å¤šä¸ªæ ¸å¿ƒç±»çš„èŒèƒ½ï¼Œå…³è”äº†ä¸¤ä¸ªæ ¸å¿ƒçš„å¯¹è±¡ï¼Œåˆ†åˆ«æ˜¯ ChannelHandler å¯¹è±¡ä»¥åŠ Codec2 å¯¹è±¡ï¼Œè¿™ä¸¤ä¸ªå¯¹è±¡éå¸¸é‡è¦ï¼Œåˆ°è¾¾æœåŠ¡åº•å±‚çš„æ‰€æœ‰ä»»åŠ¡ NettyServer æœ€ç»ˆéƒ½æ˜¯å§”æ‰˜ç»™è¿™ä¸¤ä¸ªå¯¹è±¡è¿›è¡Œå¤„ç†çš„ã€‚ç­‰ç­‰ï¼Œå¥½åƒæ¼äº†é€šé“è¿™ä¸ªæ ¸å¿ƒå¯¹è±¡ï¼Œå°½ç®¡å®ƒå¾ˆé‡è¦ï¼Œä½†æ˜¯å®ƒæ¯•ç«Ÿæ˜¯ä¸¤ä¸ªç«¯ç‚¹ä¹‹é—´çš„TCPè¿æ¥çš„æŠ½è±¡ï¼Œå¯¹äºä¸Šå±‚æ¥è¯´ä¸€èˆ¬æ˜¯éå¯æ§çš„ï¼ŒDubbo å±‚é¢çš„ Channel æœ€ç»ˆæ˜¯é€šå¯¹ Netty Channel çš„è£…é¥°æ¥å®Œæˆå·¥ä½œçš„ã€‚é€šè¿‡å‰é¢çš„ä»‹ç»ï¼Œæˆ‘ä»¬çŸ¥é“ NettyServer å…³è”çš„ ChannelHandler æ˜¯ä¸Šå±‚ä¼ å…¥å¹¶ç»è¿‡åŒ…è£…åçš„å¯¹è±¡ï¼ŒåŒ…è£…è¿‡ç¨‹ä¸­çš„åŠŸèƒ½æ€§å¯¹è±¡å¯ç”±ä¸Šå±‚é€šè¿‡é…ç½®è¿›è¡Œç®¡æ§çš„ï¼Œå¦‚çº¿ç¨‹æ¨¡å‹ä¸­çš„æ´¾å‘ç­–ç•¥å’Œçº¿ç¨‹æ± éƒ½æ˜¯å¯æŒ‡å®šçš„ã€‚NettyServer å…³è”çš„ Codec2 å¯¹è±¡æ˜¯æ ¹æ®ä¸Šå±‚ä¼ å…¥çš„ URL é€šè¿‡ Dubbo SPI æœºåˆ¶åˆå§‹åŒ–çš„ï¼Œè€Œ URL æ˜¯ Dubbo ä¸­çš„é…ç½®è½½ä½“ï¼ŒåŒæ ·æ˜¯ä¸Šå±‚å¯æ§çš„ã€‚æœ€åçš„ç»“è®ºæ˜¯ï¼Œä¸Šå±‚åªéœ€è¦æ ¹æ®ä¸šåŠ¡åœºæ™¯éœ€è¦ï¼Œå®ç° ChannelHandler å’Œ Codec2 è¿™ä¸¤ä¸ªæ‰©å±•æ¥å£å³å¯ã€‚ ä¸‹é¢æˆ‘ä»¬å¼€å§‹åˆ†æ Dubbo æ¥å…¥ Netty4 çš„å®¢æˆ·ç«¯éƒ¨åˆ†ã€‚è¿™éƒ¨åˆ†æ¶‰åŠçš„å¾ˆå¤šæ¥å£å’Œç±»éƒ½æ˜¯æœåŠ¡éƒ¨åˆ†ä»‹ç»è¿‡çš„ï¼Œåœ¨ä¸‹é¢ä»‹ç»çš„å®¢æˆ·ç«¯éƒ¨åˆ†å°±ä¸å†é‡å¤è¯´æ˜ã€‚ NettyClientNettyClient æ˜¯åŸºäº Netty4 å®ç°çš„å®¢æˆ·ç«¯ï¼Œä¸‹é¢æˆ‘ä»¬å¯¹å®ƒçš„å±æ€§ã€æ„é€ æ–¹æ³•ä»¥åŠåŸºæœ¬æ–¹æ³•è¿›è¡Œè¯¦ç»†è¯´æ˜ã€‚ å±æ€§12345678910111213141516171819public class NettyClient extends AbstractClient &#123; private static final Logger logger = LoggerFactory.getLogger(NettyClient.class); /** * çº¿ç¨‹ç»„ */ private static final NioEventLoopGroup nioEventLoopGroup = new NioEventLoopGroup(Constants.DEFAULT_IO_THREADS, new DefaultThreadFactory(\"NettyClientWorker\", true)); /** * å¼•å¯¼ç±» */ private Bootstrap bootstrap; /** * Netty çš„é€šé“ã€‚ä½¿ç”¨volatitle ä¿®é¥°ç¬¦ã€‚å› ä¸ºå®¢æˆ·ç«¯å¯èƒ½ä¼šå’ŒæœåŠ¡ç«¯æ–­å¼€è¿æ¥ï¼Œéœ€è¦ä¿è¯å¤šçº¿ç¨‹çš„å¯è§æ€§ */ private volatile Channel channel;&#125; NettyClient ç»§æ‰¿äº† AbstractClient æŠ½è±¡ç±»ï¼Œæ˜¯ Dubbo çš„ Netty å®¢æˆ·ç«¯å®ç°ç±»ã€‚Channel å±æ€§åªæœ‰ä¸€ä¸ªï¼Œæ˜¯å› ä¸ºä½œä¸ºå®¢æˆ·ç«¯åŒä¸€æ—¶é—´åªä¼šè¿æ¥ä¸€ä¸ªæœåŠ¡ã€‚å…¶å®ƒä¸¤ä¸ªå±æ€§æ˜¯ Netty å±‚ç›¸å…³ç±»ã€‚ æ„é€ æ–¹æ³•1234public NettyClient(final URL url, final ChannelHandler handler) throws RemotingException &#123; // wrapChannelHandleræ–¹æ³•ç”¨äºåŒ…è£…ChannelHandlerï¼Œå…¶ä¸­å®ç°äº† Dubbo çº¿ç¨‹æ¨¡å‹çš„åŠŸèƒ½ã€‚ super(url, wrapChannelHandler(url, handler)); &#125; NettyClient æ„é€ æ–¹æ³•æµç¨‹å’Œ NettyServer æ„é€ æ–¹æ³•æµç¨‹å¤§ä½“ä¸€è‡´ï¼ŒåŒºåˆ«åœ¨ NettyServer åˆå§‹åŒ–æœåŠ¡å™¨å¹¶å¯åŠ¨ï¼ŒNettyClient åˆå§‹åŒ–å®¢æˆ·ç«¯å¹¶è¿æ¥æœåŠ¡å™¨ï¼Œå…¶å®ƒæµç¨‹ä¸€æ‘¸ä¸€æ ·ï¼Œæ— è®ºæ˜¯æœåŠ¡ç«¯è¿˜æ˜¯å®¢æˆ·ç«¯ï¼Œéƒ½éœ€è¦é€šé“å¤„ç†å™¨ï¼Œéƒ½éœ€è¦ç¼–è§£ç å™¨ã€‚ä¸‹é¢å¯¹æ„é€ æ–¹æ³•æµç¨‹ç®€å•æ€»ç»“ï¼š å¯¹ä¼ å…¥çš„ ChannelHandler è¿›è¡ŒåŒ…è£…ï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªå¢å¼ºçš„ ChannelHandlerã€‚å¯¹ä¼ å…¥çš„ URL è¿›è¡Œçº¿ç¨‹æ± ç±»å‹å’Œçº¿ç¨‹åé…ç½®èµ‹å€¼ã€‚ è°ƒç”¨çˆ¶ç±» AbstractClient æ„é€ æ–¹æ³•åŠä¸Šå±‚çˆ¶ç±»æ–¹æ³•ï¼Œåˆå§‹åŒ–ç¼–è§£ç å™¨ Codec2ã€‚ ç¬¬ 2 æ­¥æ‰§è¡Œ AbstractClient æ„é€ æ–¹æ³•æ—¶ï¼Œæ ¹æ® URL å‚æ•°é…ç½®ä¾æ¬¡åˆå§‹åŒ–ï¼š å‘é€æ¶ˆæ¯æ—¶è¿æ¥æ–­å¼€æ˜¯å¦é‡è¿ url.send.reconnectï¼ˆé»˜è®¤falseï¼‰ å…³é—­è¶…æ—¶æ—¶é—´ url.shutdown.timeoutï¼ˆé»˜è®¤15minï¼‰ é‡è¿å‘Šè­¦é—´éš”æ—¶é—´å³é‡è¿næ¬¡å‘Šè­¦ä¸€æ¬¡ url.reconnect.waring.periodï¼ˆé»˜è®¤1800ï¼‰ è°ƒç”¨çˆ¶ç±»æ¨¡ç‰ˆæ–¹æ³• doOpen() å¯åŠ¨å®¢æˆ·ç«¯ï¼Œå¯åŠ¨è¿‡ç¨‹å‡ºç°å¼‚å¸¸åˆ™è°ƒç”¨çˆ¶ç±»çš„ close() æ–¹æ³•å¹¶æŠ›å‡ºå¼‚å¸¸ã€‚ è¿æ¥æœåŠ¡å™¨ï¼Œå…ˆå¯åŠ¨æ–­çº¿é‡è¿æœºåˆ¶å†è°ƒç”¨çˆ¶ç±»æ¨¡ç‰ˆæ–¹æ³• doConnect() æ–¹æ³•è¿›è¡Œè¿æ¥æœåŠ¡å™¨ï¼Œå…¶ä¸­æ–­çº¿é‡è¿æœºåˆ¶æ˜¯çˆ¶ç±»æ–¹æ³•ã€‚åŒæ ·çš„ï¼Œè¿æ¥æœåŠ¡å™¨å¤±è´¥åˆ™è°ƒç”¨çˆ¶ç±»çš„ close() æ–¹æ³•å¹¶æŠ›å‡ºå¼‚å¸¸ã€‚ ä» DataSource ä¸­è·å–å½“å‰å®¢æˆ·ç«¯å¯¹åº”çš„çº¿ç¨‹æ± ã€‚ NettyClient æ„é€ æ–¹æ³•ä¸­ wrapChannelHandler(url,handler) æ–¹æ³•ç”¨äºè®¾ç½®çº¿ç¨‹åå¹¶è®¾ç½®çº¿ç¨‹æ± ç±»å‹ï¼Œç›¸æ¯” NettyServer æ„é€ æ–¹æ³•å¤šäº†è®¾ç½®çº¿ç¨‹æ± ç±»å‹æ­¥éª¤ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456789--- AbstractClient protected static ChannelHandler wrapChannelHandler(URL url, ChannelHandler handler) &#123; // è®¾ç½®çº¿ç¨‹åï¼Œå³ URL.threadname é…ç½®å‚æ•°å€¼ï¼Œé»˜è®¤ä¸º 'DubboClientHandler' url = ExecutorUtil.setThreadName(url, CLIENT_THREAD_POOL_NAME); // è®¾ç½®ä½¿ç”¨çš„çº¿ç¨‹æ± ç±»å‹ï¼Œå³ URL.threadpool é…ç½®å‚æ•°å€¼ï¼Œé»˜è®¤å€¼ä¸º 'cached' url = url.addParameterIfAbsent(Constants.THREADPOOL_KEY, Constants.DEFAULT_CLIENT_THREADPOOL); // åŒ…è£…é€šé“å¤„ç†å™¨ return ChannelHandlers.wrap(handler, url); &#125; å¯åŠ¨å®¢æˆ·ç«¯ doOpen12345678910111213141516171819202122232425262728293031323334353637383940414243@Overrideprotected void doOpen() throws Throwable &#123; // åˆ›å»º NettyClientHandler å¯¹è±¡ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ NettyClient å¯¹è±¡æœ¬èº«ï¼Œå› ä¸º NettyClient æ˜¯ ChannelHanderçš„å®ç°ç±»ã€‚ final NettyClientHandler nettyClientHandler = new NettyClientHandler(getUrl(), this); // åˆ›å»º Netty å®¢æˆ·ç«¯å¼•å¯¼å¯¹è±¡ bootstrap = new Bootstrap(); bootstrap // è®¾ç½®å®ƒçš„çº¿ç¨‹ç»„ .group(nioEventLoopGroup) // è®¾ç½®å¯é€‰é¡¹ .option(ChannelOption.SO_KEEPALIVE, true) .option(ChannelOption.TCP_NODELAY, true) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) //.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout()) // è®¾ç½® å®¢æˆ·ç«¯å¯¹åº”çš„Channelç±»å‹ .channel(NioSocketChannel.class); // è®¾ç½®è¿æ¥è¶…æ—¶æ—¶é—´ï¼Œè¿™é‡Œä½¿ç”¨åˆ° AbstractEndpoint ä¸­çš„ connectTimeout å­—æ®µ if (getConnectTimeout() &lt; 3000) &#123; bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000); &#125; else &#123; bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getConnectTimeout()); &#125; // è®¾ç½®å¤„ç†å™¨æ‰§è¡Œé“¾ bootstrap.handler(new ChannelInitializer() &#123; @Override protected void initChannel(Channel ch) throws Exception &#123; // åˆ›å»º NettyCoderAdapter å¯¹è±¡ NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyClient.this); // è·å–Pipeline ch.pipeline() //.addLast(\"logging\",new LoggingHandler(LogLevel.INFO)) // è®¾ç½®æ—¥å¿—ï¼Œæ–¹ä¾¿è°ƒè¯• // æ³¨å†Œè§£ç å™¨ .addLast(\"decoder\", adapter.getDecoder()) // æ³¨å†Œç¼–ç å™¨ .addLast(\"encoder\", adapter.getEncoder()) // æ³¨å†Œå¤„ç†å™¨ .addLast(\"handler\", nettyClientHandler); &#125; &#125;);&#125; NettyClient çš„å¯åŠ¨å®¢æˆ·ç«¯æ–¹æ³•æ˜¯çˆ¶ç±»çš„ä¸€ä¸ªæ¨¡ç‰ˆæ–¹æ³•ï¼Œå’Œ NettyServer çš„å¯åŠ¨æœåŠ¡æ–¹æ³•ç±»ä¼¼ï¼Œä¸‹é¢ç®€å•æ¦‚æ‹¬ï¼š åˆ›å»º Dubbo å±‚é¢çš„ NettyClientHandler å¯¹è±¡ï¼Œå› å…¶ç»§æ‰¿äº† Netty ä¸­çš„ ChannelDuplexHandler ç±»ï¼Œå› æ­¤å®ƒåˆå±äº Netty å±‚é¢çš„ ChannelHandlerï¼Œç›´æ¥å‚ä¸ Netty é€šé“æ¶ˆæ¯æˆ–äº‹ä»¶çš„å¤„ç†ã€‚ åˆå§‹åŒ–å®¢æˆ·ç«¯å¼•å¯¼å¯¹è±¡ï¼Œè®¾ç½®å‚æ•°é¡¹ã€‚å…¶ä¸­ä¸éœ€è¦bossçº¿ç¨‹ç»„ï¼Œé€šé“ç±»å‹æ˜¯ NioSocketChannelï¼Œè¿æ¥è¶…æ—¶æ—¶é—´æ˜¯ä»çˆ¶ç±» AbstractEndpoint ä¸­è·å– ã€‚ åˆ›å»º ChannelInitializer åˆå§‹åŒ–å™¨ï¼ŒæŒ‡å®šå¦‚ä½•åˆå§‹åŒ– Channel ä¸Šçš„ ChannelHandler ç­‰ç³»åˆ— Netty ä½¿ç”¨çš„æ ‡å‡†åŒ–æµç¨‹ï¼Œè¿™é‡Œå°±æ˜¯æ³¨å†Œé€šé“å¤„ç†å™¨ï¼ˆåŒ…æ‹¬ç¼–è§£ç å™¨ï¼‰ã€‚ å®¢æˆ·ç«¯åˆå§‹åŒ–å®Œæ¯•åï¼Œè¿›å…¥è¿æ¥æœåŠ¡çš„æµç¨‹ã€‚ è¿æ¥æœåŠ¡å™¨ doConnect12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Overrideprotected void doConnect() throws Throwable &#123; // è®°å½•è¿æ¥å¼€å§‹æ—¶é—´ long start = System.currentTimeMillis(); // è¿æ¥æŒ‡å®šåœ°å€çš„æœåŠ¡ï¼Œåœ°å€ä» URL é…ç½®æ€»çº¿ä¸­è·å– ï¼ˆURLä»AbstractPeerä¸­å–ï¼‰ ChannelFuture future = bootstrap.connect(getConnectAddress()); try &#123; // ç­‰å¾…è¿æ¥æˆåŠŸæˆ–è€…è¶…æ—¶ boolean ret = future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS); // è¿æ¥æˆåŠŸ if (ret &amp;&amp; future.isSuccess()) &#123; // å–å‡ºè¿æ¥æœåŠ¡çš„é€šé“ Channel newChannel = future.channel(); try &#123; // å¦‚æœå·²ç»å­˜åœ¨è¿æ¥æœåŠ¡çš„é€šé“äº†ï¼Œå°±æŠŠè€çš„å…³é—­ï¼Œä½¿ç”¨æ–°çš„ Channel oldChannel = NettyClient.this.channel; if (oldChannel != null) &#123; try &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Close old netty channel \" + oldChannel + \" on create new netty channel \" + newChannel); &#125; // å…³é—­è€çš„é€šé“ oldChannel.close(); &#125; finally &#123; // ç§»é™¤è€çš„é€šé“å¯¹åº”çš„ç¼“å­˜ï¼ˆå³å¯¹åº”çš„ Dubbo çš„é€šé“ NettyChannelï¼‰ NettyChannel.removeChannelIfDisconnected(oldChannel); &#125; &#125; &#125; finally &#123; // è‹¥å®¢æˆ·ç«¯å…³é—­äº†ï¼Œåˆ™å…³é—­æ–°çš„è¿æ¥ if (NettyClient.this.isClosed()) &#123; try &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Close new netty channel \" + newChannel + \", because the client closed.\"); &#125; newChannel.close(); &#125; finally &#123; NettyClient.this.channel = null; NettyChannel.removeChannelIfDisconnected(newChannel); &#125; // æ›´æ–°è¿æ¥æœåŠ¡çš„é€šé“ &#125; else &#123; NettyClient.this.channel = newChannel; &#125; &#125; // è¿æ¥æœåŠ¡å‘ç”Ÿå¼‚å¸¸ï¼Œåˆ™æŠ›å‡º &#125; else if (future.cause() != null) &#123; throw new RemotingException(this, \"client(url: \" + getUrl() + \") failed to connect to server \" + getRemoteAddress() + \", error message is:\" + future.cause().getMessage(), future.cause()); // è¿æ¥è¶…æ—¶ï¼ŒæŠ›å‡ºRemotingExceptionå¼‚å¸¸ &#125; else &#123; throw new RemotingException(this, \"client(url: \" + getUrl() + \") failed to connect to server \" + getRemoteAddress() + \" client-side timeout \" + getConnectTimeout() + \"ms (elapsed: \" + (System.currentTimeMillis() - start) + \"ms) from netty client \" + NetUtils.getLocalHost() + \" using dubbo version \" + Version.getVersion()); &#125; &#125; finally &#123; // æ²¡æœ‰è¿æ¥ if (!isConnected()) &#123; //future.cancel(true); &#125; &#125;&#125; å®¢æˆ·ç«¯è¿æ¥æœåŠ¡ä¸»è¦åšäº†ä»¥ä¸‹å·¥ä½œï¼š è°ƒç”¨ Netty çš„ Bootstrap#connect(remoteAddress) æ–¹æ³•è¿æ¥æœåŠ¡å™¨ï¼Œè¿”å›è¿æ¥ç»“æœå¯¹è±¡ ChannelFuture ã€‚ è°ƒç”¨ Netty çš„ ChannelFuture#awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS) æ–¹æ³•ï¼Œç­‰å¾…è¿æ¥æˆåŠŸæˆ–è¶…æ—¶ã€‚ å¦‚æœè¿æ¥æœåŠ¡æˆåŠŸï¼Œå…ˆåˆ¤æ–­æ˜¯å¦å­˜åœ¨æ—§çš„è¿æ¥é€šé“ï¼Œæœ‰åˆ™å…³é—­æ—§çš„é€šé“å¹¶åˆ é™¤å¯¹åº”çš„é€šé“ç¼“å­˜ï¼Œå†åˆ¤æ–­å½“å‰å®¢æˆ·ç«¯æ˜¯å¦å…³é—­ï¼ˆé€šé“ã€çº¿ç¨‹æ± ç­‰èµ„æºï¼‰ï¼Œå…³é—­åˆ™æ–°çš„è¿æ¥ä½œåºŸå¹¶åˆ é™¤å¯¹åº”çš„é€šé“ç¼“å­˜ã€‚å‰ç½®æ£€æµ‹å®Œæˆåï¼Œæœ€åæ›´æ–°è¿æ¥æœåŠ¡çš„é€šé“ã€‚ è¿æ¥å¤±è´¥ï¼Œå¯èƒ½æ˜¯è¿æ¥æœåŠ¡å¼‚å¸¸ï¼Œä¹Ÿå¯èƒ½æ˜¯è¿æ¥è¶…æ—¶å¼‚å¸¸ã€‚ finally å—ä¸­çš„é€»è¾‘ï¼Œå½“æ²¡æœ‰è¿æ¥æ—¶ä»€ä¹ˆä¹Ÿä¸åšï¼Œå¯ä»¥çœ‹åˆ°å®˜æ–¹æŠŠå–æ¶ˆè¿æ¥ä»»åŠ¡æ–¹æ³•è°ƒç”¨æ³¨é‡Šäº†ï¼Œè¿™é‡Œåº”è¯¥æ˜¯å‰é¢åˆ¤æ–­å¤±è´¥çš„åˆ†æ”¯é€»è¾‘å·²ç»å¤„ç†è¿‡äº†ï¼Œæ²¡æœ‰è¿æ¥æ— éå°±æ˜¯è¿æ¥å¤±è´¥æˆ–è¶…æ—¶ã€‚ æ–­å¼€è¿æ¥ doDisConnect12345678@Overrideprotected void doDisConnect() throws Throwable &#123; try &#123; NettyChannel.removeChannelIfDisconnected(channel); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage()); &#125;&#125; æ–­å¼€è¿æ¥ä»…ä»…æ˜¯åœ¨å®¢æˆ·ç«¯è¿æ¥æœåŠ¡çš„é€šé“å…³é—­æ—¶ï¼ŒæŠŠå¯¹åº”çš„é€šé“ç¼“å­˜æ¸…é™¤ã€‚ è·å–è¿æ¥åˆ°æœåŠ¡çš„é€šé“ getChannel12345678@Override protected com.alibaba.dubbo.remoting.Channel getChannel() &#123; Channel c = channel; if (c == null || !c.isActive()) &#123; return null; &#125; return NettyChannel.getOrAddChannel(c, getUrl(), this); &#125; è·å–è¿æ¥åˆ°æœåŠ¡çš„é€šé“æ˜¯çˆ¶ç±»çš„æ¨¡ç‰ˆæ–¹æ³•ï¼Œç”¨äºè¿”å›å…·ä½“NIOçš„é€šé“å¯¹åº”çš„ Dubbo é€šé“ï¼Œè¿™é‡Œæ˜¯è¿”å›Nettyçš„Channelå¯¹åº”çš„Dubbo å±‚é¢çš„NettyChanel ã€‚ NettyClientHandlerNettyClientHandler çš„å®ç°å’Œ NettyServerHandler ç±»ä¼¼ï¼ŒåŒæ ·å®ç°äº† Netty çš„ ChannelDuplexHandlerã€‚NettyClientHandler ä¼šå°†æ‰€æœ‰æ–¹æ³•å§”æ‰˜ç»™ NettyClient å…³è”çš„ ChannelHandler å¯¹è±¡è¿›è¡Œå¤„ç†ã€‚ å±æ€§123456789101112131415161718192021222324252627282930@io.netty.channel.ChannelHandler.Sharablepublic class NettyClientHandler extends ChannelDuplexHandler &#123; /** * URL */ private final URL url; /** * ChannelHandlerï¼ŒNettyClient å¯¹è±¡ */ private final ChannelHandler handler; /** * æ„é€ æ–¹æ³• * * @param url url * @param handler NettyClient */ public NettyClientHandler(URL url, ChannelHandler handler) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; if (handler == null) &#123; throw new IllegalArgumentException(\"handler == null\"); &#125; this.url = url; this.handler = handler; &#125;&#125; åœ¨ NettyClientHandler ä¸­æœ‰ä¸¤ä¸ªå±æ€§ï¼Œurl å’Œ handler ã€‚å±æ€§è¯´æ˜å¦‚ä¸‹ï¼š url å±æ€§ï¼šé€šè¿‡æ„é€ æ–¹æ³•ä¼ å…¥ã€‚ handler å±æ€§ï¼šé€šé“å¤„ç†å™¨ï¼Œæ˜¯ NettyClient å¯¹è±¡ã€‚NettyClientHandler ä¸­å‡ ä¹æ‰€æœ‰æ–¹æ³•éƒ½ä¼šå§”æ‰˜ç»™è¯¥å¯¹è±¡å¤„ç†ã€‚ é€šé“å¤„ç†æ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * å¤„ç†è¿æ¥äº‹ä»¶ * &lt;p&gt; * è¯´æ˜ï¼šä¸åŒäºNettyServerHandlerçš„è¯¥æ–¹æ³•ä¼šæäº¤ç»™handlerå¤„ç†ï¼Œå®¢æˆ·ç«¯ä¸ä¼šè¢«è¿æ¥ï¼Œå› æ­¤æ— éœ€åšè¿æ¥å¤„ç†ã€‚ * * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; ctx.fireChannelActive(); &#125; /** * å¤„ç†æ–­å¼€è¿æ¥äº‹ä»¶ * &lt;p&gt; * è¯´æ˜ï¼š ä¸åŒäºNettyServerHandlerçš„è¯¥æ–¹æ³•ä¼šæäº¤ç»™handlerå¤„ç†ï¼Œå®¢æˆ·ç«¯æ— éœ€å¤„ç†æ–­å¼€è¿æ¥äº‹ä»¶ï¼Œå› æ­¤æ— éœ€åšè¿æ¥å¤„ç†ã€‚ * * @param ctx * @throws Exception */ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; ctx.fireChannelInactive(); &#125; //--------- ä»¥ä¸‹æ–­å¼€è¿æ¥ã€è¯»å–æ•°æ®ã€å†™æ•°æ®ä»¥åŠå¼‚å¸¸å¤„ç†ï¼Œéƒ½æ˜¯ç›´æ¥å§”æ‰˜ç»™ClientHandlerè£…é¥°çš„ChannelHandlerè¿›è¡Œå¤„ç†ï¼Œæ‰€éœ€çš„é€šé“æ˜¯ Nettyé€šé“å¯¹åº”Dubboé€šé“ --------------/ /** * æ–­å¼€è¿æ¥ * * @param ctx * @param future * @throws Exception */ @Override public void disconnect(ChannelHandlerContext ctx, ChannelPromise future) throws Exception &#123; NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler); try &#123; handler.disconnected(channel); &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(ctx.channel()); &#125; &#125; /** * è¯»å–æ¶ˆæ¯ * * @param ctx * @param msg * @throws Exception */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler); try &#123; handler.received(channel, msg); &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(ctx.channel()); &#125; &#125; /** * å†™æ•°æ® * * @param ctx * @param msg * @param promise * @throws Exception */ @Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123; super.write(ctx, msg, promise); NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler); try &#123; handler.sent(channel, msg); &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(ctx.channel()); &#125; &#125; /** * å¼‚å¸¸å¤„ç† * * @param ctx * @param cause * @throws Exception */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler); try &#123; handler.caught(channel, cause); &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(ctx.channel()); &#125; &#125; NettyClientHandler å¯¹ io.netty.channel.ChannelDuplexHandler é‡å†™çš„æ–¹æ³•ï¼Œåœ¨éœ€è¦å¤„ç†çš„æ—¶å€™éƒ½æ˜¯å§”æ‰˜ç»™ NettyClient å…³è”çš„ ChannelHandler å¯¹è±¡ï¼Œæ‰€éœ€é€šé“æ˜¯ Nettyé€šé“å¯¹åº”çš„ Dubbo é€šé“ï¼Œåœ¨å‰é¢çš„ NettyChannel ç±»ä¸­å·²ç»è¯´æ˜ï¼Œå®ƒæ˜¯å¯¹ Netty é€šé“çš„è£…é¥°ï¼Œå®é™…æ“ä½œè¿˜æ˜¯ç”± Netty é€šé“å¤„ç†ã€‚ NettyClient &amp; NettyClientHandlerNettyClient åˆ›å»º NettyClientHandler ä»£ç å¦‚ä¸‹ï¼š 12// åˆ›å»º Dubbo NettyClientHandler å¯¹è±¡ã€‚æ³¨æ„ä¼ å…¥çš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯ NettyClient å¯¹è±¡æœ¬èº«ï¼Œå› ä¸º NettyClient æ˜¯ChannelHanderçš„å®ç°ç±»ã€‚final NettyClientHandler nettyClientHandler = new NettyClientHandler(getUrl(), this); ç”±äºç»§æ‰¿å…³ç³»ï¼ŒNettyClient ç»§æ‰¿äº† AbstractPeer æŠ½è±¡ç±»ï¼Œè¯¥ç±»æ˜¯å°†æ•°æ®å…¨éƒ¨ç›´æ¥å§”æ‰˜ç»™è£…é¥°çš„ ChannelHandler å¯¹è±¡ï¼Œå› æ­¤ NettyClient åŒæ ·æ˜¯å°†æ•°æ®å§”æ‰˜ç»™å…¶å…³è”çš„ ChannelHandler å¯¹è±¡ã€‚ NettyClient ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ€»ç»“æœ¬ç¯‡æ–‡ç« é‡ç‚¹ä»‹ç»äº† Dubbo Transporter å±‚ä¸­åŸºäº Netty4 å®ç°çš„ Server å’Œ Client å®ç°ä»¥åŠç›¸å…³çš„æ ¸å¿ƒç±»ï¼Œå¦‚ NettyTransporter ã€ NettyChannel é€šé“ã€NettyServerHandler å’Œ NettyClientHandler é€šé“å¤„ç†å™¨ã€NettyCodecAdapter ç¼–è§£ç å™¨ï¼Œå®ƒä»¬éƒ½æ˜¯æœ€ä½å±‚çš„å®ç°ã€‚å‰é¢æ–‡ç« ä¹Ÿæåˆ°ï¼Œdubbo-remoting-api æ¨¡å—å¯¹äº dubbo-remoting-netty4 æ¨¡å—æ¥è¯´æ˜¯é€æ˜çš„å³é€šç”¨çš„é€»è¾‘æ¨¡ç‰ˆï¼Œå…¶ä¸­ NettyServer å’Œ NettyClient é€šè¿‡ç»§æ‰¿åŠå®ç°ï¼Œæ‹¥æœ‰äº† Endpointã€ChannelHandlerç­‰å¤šä¸ªæ¥å£çš„èŒèƒ½ï¼Œå…³è”äº† ChannelHandler å¯¹è±¡å’Œ Codec2 å¯¹è±¡ï¼Œå¹¶æœ€ç»ˆå°†æ•°æ®å§”æ‰˜ç»™è¿™ä¸¤ä¸ªå¯¹è±¡å»å¤„ç†ã€‚ä¸Šå±‚åªéœ€è¦æ ¹æ®ä¸šåŠ¡åœºæ™¯éœ€è¦ï¼Œé…ç½®åŠŸèƒ½å‚æ•°åˆ°é…ç½®æ€»çº¿ URL å¹¶å®ç° ChannelHandler å’Œ Codec2 è¿™ä¸¤ä¸ªæ‰©å±•æ¥å£å³å¯ï¼ŒCodec2 çš„å®ç°æ˜¯åœ¨ AbstractEndpoint æŠ½è±¡ç±»çš„æ„é€ æ–¹æ³•ä¸­æ ¹æ® Dubbo SPI è·å–çš„ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Netty","slug":"Netty","permalink":"https://gentryhuang.com/tags/Netty/"}]},{"title":"Dubboæºç åˆ†æ - ç½‘ç»œä¼ è¾“å±‚","slug":"rpc/Transportå±‚","date":"2020-05-22T16:00:00.000Z","updated":"2021-03-15T02:10:06.551Z","comments":false,"path":"posts/53cd7ee7/","link":"","permalink":"https://gentryhuang.com/posts/53cd7ee7/","excerpt":"","text":"å‰è¨€åœ¨ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ä¸­å¯¹ Remoting å±‚è¿›è¡Œäº†æ€»ä½“è¯´æ˜ï¼Œä¸‹é¢æˆ‘ä»¬å¼€å§‹è¯¦ç»†ä»‹ç» Remoting å±‚çš„ Transport ç½‘ç»œä¼ è¾“å±‚ã€‚æœ¬æ–‡ä¼šä» Transporter å±‚çš„ Serverã€Clientã€Channelã€ChannelHandlerã€Dispatcher ä»¥åŠ Codec2 ç­‰æ ¸å¿ƒæ¥å£å‡ºå‘ï¼Œåˆ†åˆ«ä»‹ç»è¿™äº›æ ¸å¿ƒæ¥å£çš„å®ç°ã€‚ æ¦‚è¿°æœ‰å¾ˆå¤šç½‘ç»œåº“å¯ä»¥å®ç°ç½‘ç»œä¼ è¾“çš„åŠŸèƒ½ï¼Œå¦‚ Nettyã€Minaã€Grizzlyç­‰ã€‚ä½†è¿™äº› NIO åº“å¯¹å¤–æ¥å£å’Œä½¿ç”¨æ–¹å¼ä¸ä¸€æ ·ï¼Œå¦‚æœä½¿ç”¨æ–¹ç›´æ¥ä½¿ç”¨ Netty æˆ–å…¶å®ƒé€šä¿¡ç»„ä»¶ï¼Œé‚£ä¹ˆå°±ä¾èµ–äº†å…·ä½“çš„NIOåº“å®ç°ï¼Œè€Œä¸æ˜¯ä¾èµ–ä¸€ä¸ªæœ‰ä¼ è¾“èƒ½åŠ›çš„æŠ½è±¡ï¼Œåç»­è¦åˆ‡æ¢å…¶å®ƒNIOåº“å®ç°çš„è¯å°±éœ€è¦ä¿®æ”¹ä¾èµ–å’Œæ¥å…¥çš„ç›¸å…³ä»£ç ï¼Œè¿™æ—¢å®¹æ˜“å‡ºé”™ä¹Ÿä¸ç¬¦åˆè®¾è®¡æ¨¡å¼ä¸­çš„å¼€æ”¾-å°é—­åŸåˆ™ã€‚å› æ­¤ï¼ŒDubbo Transporter å±‚å°±è¢«æŠ½è±¡å‡ºæ¥äº†ï¼Œå®ƒå±è”½äº†ä¸åŒçš„é€šä¿¡æ¡†æ¶çš„å¼‚åŒï¼Œå°è£…äº†ç»Ÿä¸€çš„å¯¹å¤–æ¥å£ã€‚æœ‰äº† Transporter å±‚ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ Dubbo SPI åŠ¨æ€åˆ‡æ¢å…·ä½“çš„ Transporter æ‰©å±•å®ç°ï¼Œä»è€Œåˆ‡æ¢åˆ°ä¸åŒçš„ Client å’Œ Server å®ç°ï¼Œè¾¾åˆ°åº•å±‚ NIO åº“åˆ‡æ¢çš„ç›®çš„ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒDubbo Transporter å±‚ä¸ç­‰äº Transport æ‰©å±•æ¥å£åŠå…¶å®ç°ï¼Œå®ƒæ˜¯å¯¹ç½‘ç»œä¼ è¾“å±‚çš„æŠ½è±¡å³åœ¨NIOåº“ä¹‹ä¸Šçš„æŠ½è±¡ï¼Œä»¥ Message ä¸ºä¸­å¿ƒï¼Œæ‰©å±•æ¥å£ä¸º Channel, Transporter, Client, Server, Codec, ChannelHandler, Dispatcher ç­‰ã€‚ Transport æŠ½è±¡å±‚ä»£ç ç»“æ„å¦‚ä¸‹ï¼š æ³¨æ„ï¼Œ Dubbo æ¥å…¥å…·ä½“ NIO åº“çš„ä»£ç æ•£è½åœ¨ dubbo-remoting-* å®ç°æ¨¡å—ä¸­ï¼Œä¼šåœ¨åé¢çš„æ–‡ç« ä¸­ä»‹ç»ã€‚ Transporter æ‰©å±•æ¥å£12345678910111213141516171819202122232425262728@SPI(\"netty\")public interface Transporter &#123; /** * åˆ›å»ºä¸€ä¸ªæœåŠ¡å™¨ï¼Œç›‘å¬æ¥è‡ªå®¢æˆ·ç«¯çš„è¯·æ±‚ã€‚æ ¹æ® 'server'ï¼Œ'transporter' ç¡®å®š Server æ‰©å±•å®ç° * * @param url æœåŠ¡å™¨åœ°å€ * @param handler é€šé“å¤„ç†å™¨ * @return server è¿”å›æœåŠ¡å™¨ * @throws RemotingException * @see com.alibaba.dubbo.remoting.Transporters#bind(URL, ChannelHandler...) */ @Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;) Server bind(URL url, ChannelHandler handler) throws RemotingException; /** * è¿æ¥æœåŠ¡å™¨ï¼Œå³åˆ›å»ºä¸€ä¸ªå®¢æˆ·ç«¯ã€‚æ ¹æ® 'client','transporter' ç¡®å®š Client æ‰©å±•å®ç° * * @param url æœåŠ¡å™¨åœ°å€ * @param handler é€šé“å¤„ç†å™¨ * @return client å®¢æˆ·ç«¯ * @throws RemotingException * @see com.alibaba.dubbo.remoting.Transporters#connect(URL, ChannelHandler...) */ @Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;) Client connect(URL url, ChannelHandler handler) throws RemotingException;&#125; Transporter æ˜¯åœ¨ Client å’Œ Server ä¹‹ä¸Šå°è£…çš„ç»Ÿä¸€çš„å¯¹å¤–æ¥å£ï¼Œé’ˆå¯¹æ¯ä¸ªæ”¯æŒçš„NIOåº“ï¼Œéƒ½æœ‰ä¸€ä¸ª Transporter æ¥å£å®ç°ï¼Œå®ƒä»¬æ˜¯ Dubbo æ¥å…¥å…·ä½“NIOåº“çš„å®ç°å…¥å£ï¼Œåœ¨å„ä¸ª dubbo-remoting-* å®ç°æ¨¡å—ä¸­ã€‚å¦‚ï¼ŒDubbo æ¥å…¥ Mina ç½‘ç»œé€šä¿¡åº“ï¼Œå°±ä¼šæœ‰å¯¹åº”çš„ dubbo-remoting-mina æ¨¡å—å¯¹æŠ½è±¡apiæ¨¡å—çš„å®ç°ï¼Œè¯¥æ¨¡å—æä¾›äº† Transporterã€Serverã€Clientã€Channelã€ChannelHandler ç­‰æ ¸å¿ƒæ¥å£çš„å®ç°ã€‚ è¿™äº› Transporter æ¥å£å®ç°è¿”å›çš„ Client å’Œ Server å…·ä½“å®ç°å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œå®ƒä»¬æ˜¯Dubbo æ¥å…¥çš„NIOåº“å¯¹åº”çš„ Serverå’ŒClientå®ç°ã€‚ å…·ä½“NIOåº“Serverçš„å®ç° å…·ä½“NIOåº“Clientçš„å®ç° åœ¨ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ä¸­å·²ç»ä»‹ç»è¿‡ Transporter æ¥å£ä»¥åŠè¯¥æ¥å£çš„é—¨é¢ç±» Transporters ï¼Œè¿™é‡Œä¸å†é‡å¤ä»‹ç»ã€‚å…³äºé€šä¿¡å…·ä½“å®ç°æ¨¡å—ä¼šåœ¨åé¢çš„æ–‡ç« ä¸­ä»‹ç»ï¼Œå®ƒä»¬ä¹Ÿæ˜¯ Transporter å±‚çš„ä¸€éƒ¨åˆ†ï¼Œæœ¬ç¯‡æ–‡ç« ç€é‡åˆ†æ Transport å±‚å…¬ç”¨ç»„ä»¶åŠæŠ½è±¡æ¦‚å¿µã€‚ AbstractPeer æŠ½è±¡ç±»123456789101112131415161718192021222324252627282930313233343536373839public abstract class AbstractPeer implements Endpoint, ChannelHandler &#123; /** * é€šé“å¤„ç†å™¨,AbstractPeer å¯¹ ChannelHandler æ¥å£çš„æ‰€æœ‰å®ç°ï¼Œéƒ½æ˜¯å§”æ‰˜ç»™äº†è¿™ä¸ª ChannelHandler å¯¹è±¡æ¥å¤„ç† */ private final ChannelHandler handler; /** * ç«¯ç‚¹è‡ªèº«çš„ URL ç±»å‹çš„å­—æ®µ */ private volatile URL url; /** * æ­£åœ¨å…³é—­ */ private volatile boolean closing; /** * å…³é—­å®Œæˆ */ private volatile boolean closed; /** * handler å±æ€§ï¼Œé€šé“å¤„ç†å™¨ï¼Œé€šè¿‡æ„é€ æ–¹æ³•ä¼ å…¥ã€‚ä½¿ç”¨ 'è£…é¥°è€…æ¨¡å¼' * * @param url * @param handler */ public AbstractPeer(URL url, ChannelHandler handler) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; if (handler == null) &#123; throw new IllegalArgumentException(\"handler == null\"); &#125; this.url = url; this.handler = handler; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; AbstractPeer è¿™ä¸ªæŠ½è±¡ç±»ï¼Œå®ƒåŒæ—¶å®ç°äº† Endpoint æ¥å£å’Œ ChannelHandler æ¥å£ï¼ŒAbstractPeer å¯¹ ChannelHandler æ¥å£çš„æ‰€æœ‰å®ç°éƒ½æ˜¯å§”æ‰˜ç»™ç»´æŠ¤çš„ ChannelHandler å±æ€§æ¥å¤„ç†ã€‚å¯¹ Endpoint æ¥å£çš„å®ç°ï¼ŒåŒ…æ‹¬å’ŒChannelæœ‰å…³çš„ï¼Œå¦‚å…³é—­Channelã€å¼€å§‹å…³é—­Channel(åšæ ‡è®°å…³é—­)ã€æ£€æŸ¥Channelæ˜¯å¦å…³é—­ï¼Œè¿™äº›éƒ½æ˜¯å¯¹å…¶ç»´æŠ¤çš„ closing å’Œ closed å±æ€§è¿›è¡Œæ“ä½œï¼›å‘é€æ¶ˆæ¯ send æ–¹æ³•çš„å®ç°äº¤ç»™å…¶å­ç±»å»å®Œæˆï¼›è·å–ç«¯ç‚¹è‡ªèº«çš„ URLï¼›è·å– ChannelHandlerã€‚éœ€è¦ç‰¹åˆ«è¯´æ˜çš„æ˜¯ï¼Œä¸Šå±‚çš„ ChannelHandler åœ¨é“¾è·¯çš„æœ€åº•å±‚ä¿å­˜çš„ä½ç½®å°±æ˜¯åœ¨ AbstractPeer è¿™ä¸ªæŠ½è±¡ç±»ä¸­ã€‚ AbstractPeer ä¹Ÿæ˜¯ AbstractChannelã€AbstractEndpoint æŠ½è±¡ç±»çš„çˆ¶ç±»ï¼Œç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾ï¼š çº¢æ¡†ä¸­çš„å®ç°ç±»æ˜¯ Dubbo æ¥å…¥çš„å…·ä½“NIOåº“å®ç°ç›¸å…³çš„ Serverã€Client å’Œ Channel å®ç°ç±»ï¼Œé€šè¿‡ç»§æ‰¿å…³ç³»ä»¥åŠå‰é¢çš„æè¿°ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ AbstractChannelã€AbstractServerã€AbstractClient éƒ½ä¼šå…³è”ä¸€ä¸ª ChannelHandler å¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡å¾ˆé‡è¦ï¼Œåé¢ä¼šæ…¢æ…¢æ­å¼€å®ƒçš„é¢çº±ã€‚ AbstractEndpoint æŠ½è±¡ç±»ä¸Šæ–‡ä¹Ÿæåˆ°äº†ï¼ŒAbstractEndpoint ç»§æ‰¿äº† AbstractPeer è¿™ä¸ªæŠ½è±¡ç±»ï¼Œå› ä¸ºç»§æ‰¿å…³ç³»å› æ­¤ä¹Ÿä¼šå…³è”ä¸€ä¸ª ChannelHandlerã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public abstract class AbstractEndpoint extends AbstractPeer implements Resetable &#123; private static final Logger logger = LoggerFactory.getLogger(AbstractEndpoint.class); /** * ç¼–è§£ç å™¨ */ private Codec2 codec; /** * è¶…æ—¶æ—¶é—´ */ private int timeout; /** * è¿æ¥è¶…æ—¶æ—¶é—´ (ç”¨äºå…·ä½“å­ç±»å®¢æˆ·ç«¯è¿æ¥è¶…æ—¶æ—¶é—´) */ private int connectTimeout; public AbstractEndpoint(URL url, ChannelHandler handler) &#123; // è°ƒç”¨çˆ¶ç±» AbstractPeer çš„æ„é€ æ–¹æ³• super(url, handler); // æ ¹æ®URLä¸­çš„ codec å‚æ•°å€¼ è·å–Codec2çš„å®ç°ç±» this.codec = getChannelCodec(url); // æ ¹æ® URL ä¸­çš„ timeout å‚æ•°ç¡®å®š timeout å­—æ®µçš„å€¼ï¼Œé»˜è®¤ 1000 this.timeout = url.getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT); // æ ¹æ®URLä¸­çš„connect.timeout å‚æ•°ç¡®å®šconnectTimeout å­—æ®µå€¼ï¼Œé»˜è®¤ 3000 this.connectTimeout = url.getPositiveParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT); &#125; /** * åŸºäºDubbo SPIæœºåˆ¶ï¼ŒåŠ è½½å¯¹åº”çš„Codecå®ç°å¯¹è±¡ï¼Œå¦‚ï¼šåœ¨DubboProtocolä¸­ä¼šè·å¾—DubboCodecå¯¹è±¡ * * @param url * @return */ protected static Codec2 getChannelCodec(URL url) &#123; String codecName = url.getParameter(Constants.CODEC_KEY, \"telnet\"); if (ExtensionLoader.getExtensionLoader(Codec2.class).hasExtension(codecName)) &#123; return ExtensionLoader.getExtensionLoader(Codec2.class).getExtension(codecName); &#125; else &#123; // æ³¨æ„ï¼š Codecæ¥å£å·²ç»åºŸå¼ƒäº† return new CodecAdapter(ExtensionLoader.getExtensionLoader(Codec.class).getExtension(codecName)); &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; é€šè¿‡ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹åˆ°ï¼ŒAbstractEndpoint ä¸­ç»´æŠ¤äº†ä¸€ä¸ªç¼–è§£ç å¯¹è±¡ Codec2 ï¼Œè¯¥å¯¹è±¡æ˜¯åœ¨ AbstractEndpoint æ„é€ æ–¹æ³•ä¸­æ ¹æ®ä¼ å…¥çš„URLå®Œæˆåˆå§‹åŒ–ï¼Œè¿™ä¸ªéå¸¸é‡è¦ã€‚é™¤äº†ç»´æŠ¤ Codec2 ç¼–è§£ç å¯¹è±¡å¤–ï¼Œè¿˜ç»´æŠ¤äº†è¶…æ—¶æ—¶é—´ï¼ˆtimeoutï¼‰å’Œè¿æ¥è¶…æ—¶æ—¶é—´ï¼ˆconnectTimeoutï¼‰ï¼Œå®ƒä»¬ä¹Ÿæ˜¯åœ¨æ„é€ æ–¹æ³•ä¸­æ ¹æ®ä¼ å…¥çš„URLè¿›è¡Œåˆå§‹åŒ–çš„ã€‚ æ­¤å¤–ï¼ŒAbstractEndpoint è¿˜å®ç°äº† Resetable æ¥å£ç”¨æ¥æ”¯æŒé‡ç½® AbstractEndpoint ä¸­ç»´æŠ¤çš„ä¸‰ä¸ªå±æ€§ï¼Œä»£ç å®ç°å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940--- AbstractEndpoint /** * é‡ç½®å±æ€§, å³ä½¿ç”¨æ–°çš„ url é‡ç½® codecã€timeoutã€connectTimeout å±æ€§ * * @param url */ @Override public void reset(URL url) &#123; if (isClosed()) &#123; throw new IllegalStateException(\"Failed to reset parameters \" + url + \", cause: Channel closed. channel: \" + getLocalAddress()); &#125; try &#123; if (url.hasParameter(Constants.TIMEOUT_KEY)) &#123; int t = url.getParameter(Constants.TIMEOUT_KEY, 0); if (t &gt; 0) &#123; this.timeout = t; &#125; &#125; &#125; catch (Throwable t) &#123; logger.error(t.getMessage(), t); &#125; try &#123; if (url.hasParameter(Constants.CONNECT_TIMEOUT_KEY)) &#123; int t = url.getParameter(Constants.CONNECT_TIMEOUT_KEY, 0); if (t &gt; 0) &#123; this.connectTimeout = t; &#125; &#125; &#125; catch (Throwable t) &#123; logger.error(t.getMessage(), t); &#125; try &#123; if (url.hasParameter(Constants.CODEC_KEY)) &#123; this.codec = getChannelCodec(url); &#125; &#125; catch (Throwable t) &#123; logger.error(t.getMessage(), t); &#125; &#125; æŠ½è±¡çš„æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯ç”±ä¸Šé¢çš„ç»§æ‰¿å…³ç³»å›¾å¯çŸ¥ï¼ŒAbstractServer å’Œ AbstractClient éƒ½ç»§æ‰¿è‡ª AbstractEndpoint æŠ½è±¡ç±»ï¼Œä¸‹é¢æˆ‘ä»¬å…ˆæ¥åˆ†æ AbstractServer è¿™ä¸ªæŠ½è±¡æœåŠ¡çš„å®ç°ã€‚ AbstractServerå±æ€§1234567891011121314151617181920212223242526public abstract class AbstractServer extends AbstractEndpoint implements Server &#123; protected static final String SERVER_THREAD_POOL_NAME = \"DubboServerHandler\"; private static final Logger logger = LoggerFactory.getLogger(AbstractServer.class); /** * å½“å‰Serverå…³è”çš„çº¿ç¨‹æ± ï¼Œæ˜¯ä» DataStore ä¸­å–çš„ */ ExecutorService executor; /** * å½“å‰Serveræœ¬åœ°åœ°å€ */ private InetSocketAddress localAddress; /** * ç»‘å®šåœ°å€ ï¼ˆé»˜è®¤å€¼ä¸ localAddress ä¸€è‡´ï¼‰ */ private InetSocketAddress bindAddress; /** * æœåŠ¡å™¨æœ€å¤§å¯æ¥å—è¿æ¥æ•° */ private int accepts; /** * ç©ºé—²è¶…æ—¶æ—¶é—´ */ private int idleTimeout = 600; //600 seconds &#125; AbstractServer åœ¨ç»§æ‰¿ AbstractEndpoint çš„åŒæ—¶ï¼Œè¿˜å®ç°äº† Server æ¥å£ï¼Œæ˜¯æœåŠ¡æŠ½è±¡ç±»ï¼Œé‡ç‚¹å®ç°äº†æœåŠ¡çš„å…¬ç”¨é€»è¾‘ï¼ŒServer æ¥å£åœ¨ åœ¨ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ä¸­å·²ç»ä»‹ç»ï¼Œå…¶ä¸­çš„å±æ€§å·²ç»åœ¨ä»£ç ä¸­è¯¦ç»†æ ‡æ³¨ã€‚ä¸‹é¢æˆ‘ä»¬æ¥ç€çœ‹å®ƒçš„æ„é€ æ–¹æ³•ï¼Œä¸Šè¿°çš„å±æ€§å­—æ®µéƒ½æ˜¯åœ¨æ„é€ æ–¹æ³•ä¸­è¿›è¡Œåˆå§‹åŒ–çš„ã€‚ æ„é€ æ–¹æ³•123456789101112131415161718192021222324252627282930313233343536--- AbstractServer public AbstractServer(URL url, ChannelHandler handler) throws RemotingException &#123; // è°ƒç”¨çˆ¶ç±»æ„é€ æ–¹æ³• super(url, handler); // æœåŠ¡åœ°å€: æœ¬æœºåœ°å€ å¦‚ï¼š-&gt; /192.168.0.100:20880 localAddress = getUrl().toInetSocketAddress(); // è·å–ipå’Œç«¯å£ String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost()); int bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort()); if (url.getParameter(Constants.ANYHOST_KEY, false) || NetUtils.isInvalidLocalHost(bindIp)) &#123; // è®¾ç½®ip ä¸º 0.0.0.0 bindIp = NetUtils.ANYHOST; &#125; // ç»‘å®šåœ°å€ å¦‚ï¼š /0.0.0.0:20880 bindAddress = new InetSocketAddress(bindIp, bindPort); // è·å–æœ€å¤§å¯æ¥å—è¿æ¥æ•° this.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS); // ç©ºé—²è¶…æ—¶æ—¶é—´ this.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT); try &#123; // è°ƒç”¨æ¨¡ç‰ˆæ–¹æ³• doOpen å¯åŠ¨æœåŠ¡ doOpen(); if (logger.isInfoEnabled()) &#123; logger.info(\"Start \" + getClass().getSimpleName() + \" bind \" + getBindAddress() + \", export \" + getLocalAddress()); &#125; &#125; catch (Throwable t) &#123; throw new RemotingException(url.toInetSocketAddress(), null, \"Failed to bind \" + getClass().getSimpleName() + \" on \" + getLocalAddress() + \", cause: \" + t.getMessage(), t); &#125; /** ä»DataStoreä¸­è·å¾—çº¿ç¨‹æ±  ,æ¥æº &#123;@link com.alibaba.dubbo.remoting.transport.dispatcher.WrappedChannelHandler.WrappedChannelHandler&#125;*/ DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension(); executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort())); &#125; æ„é€ æ–¹æ³•ä¼šæ ¹æ®ä¼ å…¥çš„URLåˆå§‹åŒ– AbstractServer ä¸­çš„å±æ€§ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºäº†å…¶å­ç±»çš„åˆå§‹åŒ–åšå‡†å¤‡ï¼Œå…¶ä¸­åœ¨æ„é€ æ–¹æ³•ä¸­è°ƒç”¨äº†ä¸€ä¸ªæ¨¡ç‰ˆæ–¹æ³• doOpenï¼Œè¿™ä¸ªæ–¹æ³•å°±æ˜¯åˆå§‹åŒ–å…¶å­ç±»çš„å…³é”®å…¥å£ï¼Œå³å¯åŠ¨å…·ä½“çš„NIOæœåŠ¡ï¼Œä¸‹ç¯‡æ–‡ç« åˆ†æå…·ä½“NIOåº“æ˜¯å¦‚ä½•æ¥å…¥çš„å°±ä¼šæ¸…æ™°äº†ã€‚å½“å‰Serverå…³è”çš„çº¿ç¨‹æ±  executor æ˜¯ä» DataStore ä¸­å–çš„ï¼Œä¸‹æ–‡ä¼šå¯¹ DataStore è¿›è¡Œä»‹ç»å¹¶è¯´æ˜çº¿ç¨‹æ± çš„æ¥æºã€‚ æ¨¡ç‰ˆæ–¹æ³•ç”¨äºå­ç±»å®ç°ï¼Œå®ŒæˆæœåŠ¡çš„å¼€å¯å’Œå…³é—­å·¥ä½œã€‚ 123protected abstract void doOpen() throws Throwable;protected abstract void doClose() throws Throwable; å‘é€æ¶ˆæ¯å‘é€æ¶ˆæ¯æ–¹æ³•æ˜¯å¯¹ Endpoint æ¥å£çš„å®ç° 1234567891011121314151617181920--- AbstractServer /** * å‘é€æ¶ˆæ¯ * * @param message * @param sent true: ä¼šç­‰å¾…æ¶ˆæ¯å‘å‡ºï¼Œæ¶ˆæ¯å‘é€å¤±è´¥ä¼šæŠ›å‡ºå¼‚å¸¸ï¼› false: ä¸ç­‰å¾…æ¶ˆæ¯å‘å‡ºï¼Œå°†æ¶ˆæ¯æ”¾å…¥IOé˜Ÿåˆ—ï¼Œå³å¯è¿”å› * @throws RemotingException */ @Override public void send(Object message, boolean sent) throws RemotingException &#123; // è·å–è¿æ¥ä¸ŠæœåŠ¡å™¨çš„é€šé“åˆ—è¡¨ ã€å®¢æˆ·ç«¯åˆ—è¡¨ã€‘ Collection&lt;Channel&gt; channels = getChannels(); // ç¾¤å‘æ¶ˆæ¯ for (Channel channel : channels) &#123; // å¦‚æœæ˜¯å·²ç»è¿æ¥çš„å°±å‘é€ if (channel.isConnected()) &#123; channel.send(message, sent); &#125; &#125; &#125; å®¢æˆ·ç«¯è¯·æ±‚è¿æ¥ç”¨äºå®¢æˆ·ç«¯è¿æ¥å½“å‰æœåŠ¡ï¼Œæ˜¯å¯¹çˆ¶ç±» AbstractPeer æ–¹æ³•çš„é‡å†™ï¼Œå¯¹ ChannelHandler çš„å®ç°ï¼ŒAbstractPeer ä¸­çš„å®ç°å¾ˆç®€å•ï¼Œåªæ˜¯åˆ¤æ–­æœåŠ¡æ˜¯å¦å…³é—­ï¼Œå…³é—­å°±ä¸ä¼šå¤„ç†å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚ï¼Œæ²¡æœ‰å…³é—­åˆ™ä¼šæŠŠè¿æ¥è¯·æ±‚äº¤ç»™ç»´æŠ¤çš„ ChannelHandler å¤„ç†ã€‚ 1234567891011121314151617181920212223242526--- AbstractServer @Override public void connected(Channel ch) throws RemotingException &#123; // If the server has entered the shutdown process, reject any new connection // è°ƒç”¨çˆ¶ç±»AbstractPeer ä¸­çš„æ–¹æ³•ï¼Œåˆ¤è¯»å½“å‰è¿™ä¸ª Server ç«¯æ˜¯å¦æ­£åœ¨å…³é—­æˆ–å…³é—­äº†ã€‚å¦‚æœä¸æ˜¯å¯åŠ¨çŠ¶æ€åˆ™ç›´æ¥å…³é—­æ–°å»ºçš„ Client è¿æ¥ã€‚ if (this.isClosing() || this.isClosed()) &#123; logger.warn(\"Close new channel \" + ch + \", cause: server is closing or has been closed. For example, receive a new connect request while in shutdown process.\"); ch.close(); return; &#125; //1 è¶…è¿‡ä¸Šé™ï¼Œå…³é—­æ–°çš„è¿æ¥ //1.1 è·å–è¿æ¥ä¸ŠæœåŠ¡å™¨çš„é€šé“åˆ—è¡¨ ã€å®¢æˆ·ç«¯åˆ—è¡¨ã€‘ Collection&lt;Channel&gt; channels = getChannels(); //1.2 åˆ¤æ–­æœåŠ¡å™¨ä¸Šè¿æ¥æ•°æ˜¯å¦è¶…è¿‡ä¸Šé™ if (accepts &gt; 0 &amp;&amp; channels.size() &gt; accepts) &#123; logger.error(\"Close channel \" + ch + \", cause: The server \" + ch.getLocalAddress() + \" connections greater than max config \" + accepts); // æœåŠ¡å™¨ä¸Šçš„è¿æ¥æ•°è¶…è¿‡ä¸Šä¸Šé™çš„è¯ï¼Œå°±å…³é—­æ–°çš„è¿æ¥ ch.close(); return; &#125; // å¤„ç†è¿æ¥äº‹ä»¶ï¼ŒAbstractPeer ä¸­çš„æ–¹æ³•ï¼Œæœ¬è´¨è¿˜æ˜¯å§”æ‰˜å†…éƒ¨è£…é¥°çš„ ChannelHandler æ¥å¤„ç† super.connected(ch); &#125; å®¢æˆ·ç«¯æ–­å¼€è¿æ¥ç”¨äºå®¢æˆ·ç«¯æ–­å¼€è¿æ¥å½“å‰æœåŠ¡ï¼Œæ˜¯å¯¹çˆ¶ç±» AbstractPeer æ–¹æ³•çš„é‡å†™ï¼Œå¯¹ ChannelHandler çš„å®ç°ï¼ŒAbstractPeer ä¸­çš„å®ç°å¾ˆç®€å•ï¼Œç›´æ¥æŠŠæ–­å¼€è¿æ¥è¯·æ±‚äº¤ç»™è£…é¥°çš„ ChannelHandler å¤„ç†ã€‚ 12345678910--- AbstractServer @Override public void disconnected(Channel ch) throws RemotingException &#123; Collection&lt;Channel&gt; channels = getChannels(); if (channels.isEmpty()) &#123; logger.warn(\"All clients has discontected from \" + ch.getLocalAddress() + \". You can graceful shutdown now.\"); &#125; // å¤„ç†æ–­å¼€è¿æ¥è¯·æ±‚ super.disconnected(ch); &#125; æœåŠ¡å…³é—­1234567891011121314151617181920@Override public void close() &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Close \" + getClass().getSimpleName() + \" bind \" + getBindAddress() + \", export \" + getLocalAddress()); &#125; // å…³é—­å…³è”çš„çº¿ç¨‹æ±  ExecutorUtil.shutdownNow(executor, 100); try &#123; // æ ‡è®°å…³é—­ super.close(); &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; try &#123; // å­ç±»å…³é—­åŠ¨ä½œ doClose(); &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; è¿˜æœ‰ä¸€äº›ä¸æ˜¯å¾ˆé‡è¦çš„å…¶å®ƒæ–¹æ³•å°±ä¸åˆ†æäº†ï¼Œä¸‹é¢ç»§ç»­åˆ†ææŠ½è±¡å®¢æˆ·ç«¯å®ç°ã€‚ AbstractClientAbstractClient åŒæ ·ç»§æ‰¿äº† AbstractEndpoint æŠ½è±¡ç±»ï¼Œå¹¶ä¸”å®ç°äº† Client æ¥å£ï¼Œæ˜¯å®¢æˆ·ç«¯çš„æŠ½è±¡ç±»ï¼Œå®ç°äº†å…¬ç”¨çš„é€»è¾‘ã€‚Client æ¥å£åœ¨ åœ¨ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ä¸­å·²ç»ä»‹ç»è¿‡ï¼Œå°±ä¸å†é‡å¤è¯´æ˜ã€‚ å±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public abstract class AbstractClient extends AbstractEndpoint implements Client &#123; private static final Logger logger = LoggerFactory.getLogger(AbstractClient.class); /** * è¿æ¥çº¿ç¨‹æ± å */ protected static final String CLIENT_THREAD_POOL_NAME = \"DubboClientHandler\"; /** * è¿æ¥çº¿ç¨‹æ± id */ private static final AtomicInteger CLIENT_THREAD_POOL_ID = new AtomicInteger(); /** * é‡è¿å®šæ—¶ä»»åŠ¡æ‰§è¡Œå™¨ï¼Œåœ¨å®¢æˆ·ç«¯è¿æ¥æœåŠ¡ç«¯æ—¶ï¼Œä¼šåˆ›å»ºåå°ä»»åŠ¡ï¼Œå®šæ—¶æ£€æŸ¥è¿æ¥ï¼Œè‹¥æ–­å¼€ä¼šè¿›è¡Œé‡æ–°è¿ */ private static final ScheduledThreadPoolExecutor reconnectExecutorService = new ScheduledThreadPoolExecutor(2, new NamedThreadFactory(\"DubboClientReconnectTimer\", true)); /** * è¿æ¥é”ï¼Œç”¨äºå®ç°å‘èµ·è¿æ¥å’Œæ–­å¼€è¿æ¥äº’æ–¥ï¼Œé¿å…å¹¶å‘ã€‚ */ private final Lock connectLock = new ReentrantLock(); /** * å‘é€æ¶ˆæ¯æ—¶ï¼Œè‹¥æ–­å¼€ï¼Œæ˜¯å¦é‡è¿ */ private final boolean send_reconnect; /** * é‡è¿æ¬¡æ•° */ private final AtomicInteger reconnect_count = new AtomicInteger(0); /** * é‡è¿æ—¶ï¼Œæ˜¯å¦å·²ç»æ‰“å°è¿‡é”™è¯¯æ—¥å¿—ã€‚é»˜è®¤æ²¡æœ‰æ‰“å°è¿‡ */ private final AtomicBoolean reconnect_error_log_flag = new AtomicBoolean(false); /** * é‡è¿warningçš„é—´éš”ï¼Œwarningå¤šå°‘æ¬¡ä¹‹åwarningä¸€æ¬¡ */ private final int reconnect_warning_period; /** * å…³é—­è¶…æ—¶æ—¶é—´ */ private final long shutdown_timeout; /** * å½“å‰å®¢æˆ·ç«¯å¯¹åº”çš„çº¿ç¨‹æ±  * åœ¨è°ƒç”¨ &#123;@link #wrapChannelHandler(URL, ChannelHandler)&#125; æ—¶ï¼Œä¼šè°ƒç”¨ &#123;@link com.alibaba.dubbo.remoting.transport.dispatcher.WrappedChannelHandler&#125; åˆ›å»º */ protected volatile ExecutorService executor; /** * é‡è¿æ‰§è¡Œä»»åŠ¡ Future */ private volatile ScheduledFuture&lt;?&gt; reconnectExecutorFuture = null; /** * æœ€åæˆåŠŸè¿æ¥æ—¶é—´ */ private long lastConnectedTime = System.currentTimeMillis();&#125; AbstractClient ä¸­çš„ç›¸å…³å±æ€§å·²ç»è¯¦ç»†æ ‡æ³¨ï¼Œå› ä¸ºæ˜¯å®¢æˆ·ç«¯ï¼Œä¼šæ¶‰åŠåˆ°é‡è¿æœåŠ¡çš„æƒ…å†µï¼Œå±æ€§ç›¸å¯¹æ¯”æœåŠ¡ç«¯è¦å¤šäº›ï¼Œä½†æ˜¯è¿™äº›å±æ€§éƒ½æ˜¯å¾ˆæœ‰ç”¨çš„ ã€‚ æ„é€ æ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455--- AbstractClient public AbstractClient(URL url, ChannelHandler handler) throws RemotingException &#123; super(url, handler); // ä»URLä¸­ï¼Œè·å¾—é‡è¿ç›¸å…³é…ç½®ï¼Œå³ send.reconnect é…ç½®å±æ€§ send_reconnect = url.getParameter(Constants.SEND_RECONNECT_KEY, false); // ä»URLä¸­è·å¾—å…³é—­è¶…æ—¶æ—¶é—´ å³ shutdown.timeout é…ç½®å±æ€§ shutdown_timeout = url.getParameter(Constants.SHUTDOWN_TIMEOUT_KEY, Constants.DEFAULT_SHUTDOWN_TIMEOUT); // The default reconnection interval is 2s, 1800 means warning interval is 1 hour. reconnect_warning_period = url.getParameter(\"reconnect.waring.period\", 1800); // åˆå§‹åŒ–å®¢æˆ·ç«¯ try &#123; doOpen(); &#125; catch (Throwable t) &#123; // åˆå§‹åŒ–å¤±è´¥ï¼Œåˆ™å…³é—­ï¼Œå¹¶æŠ›å‡ºå¼‚å¸¸ close(); throw new RemotingException(url.toInetSocketAddress(), null, \"Failed to start \" + getClass().getSimpleName() + \" \" + NetUtils.getLocalAddress() + \" connect to the server \" + getRemoteAddress() + \", cause: \" + t.getMessage(), t); &#125; // è¿æ¥æœåŠ¡å™¨ try &#123; connect(); if (logger.isInfoEnabled()) &#123; logger.info(\"Start \" + getClass().getSimpleName() + \" \" + NetUtils.getLocalAddress() + \" connect to the server \" + getRemoteAddress()); &#125; &#125; catch (RemotingException t) &#123; // å¦‚æœè¿æ¥å¤±è´¥ï¼Œå¹¶ä¸”é…ç½®äº†å¯åŠ¨æ£€æŸ¥ï¼Œåˆ™è¿›è¡Œå¯¹åº”çš„é€»è¾‘ if (url.getParameter(Constants.CHECK_KEY, true)) &#123; // å…³é—­è¿æ¥ close(); throw t; &#125; else &#123; logger.warn(\"Failed to start \" + getClass().getSimpleName() + \" \" + NetUtils.getLocalAddress() + \" connect to the server \" + getRemoteAddress() + \" (check == false, ignore and retry later!), cause: \" + t.getMessage(), t); &#125; &#125; catch (Throwable t) &#123; close(); throw new RemotingException(url.toInetSocketAddress(), null, \"Failed to start \" + getClass().getSimpleName() + \" \" + NetUtils.getLocalAddress() + \" connect to the server \" + getRemoteAddress() + \", cause: \" + t.getMessage(), t); &#125; // ä»DataStoreä¸­è·å¾—çº¿ç¨‹æ± ï¼Œè¿™é‡Œçš„çº¿ç¨‹æ± å°±æ˜¯çº¿ç¨‹æ¨¡å‹ä¸­çš„æ¶‰åŠçš„çº¿ç¨‹æ±  /** * &#123;@link WrappedChannelHandler#WrappedChannelHandler(com.alibaba.dubbo.remoting.ChannelHandler, com.alibaba.dubbo.common.URL)&#125; */ executor = (ExecutorService) ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension().get(Constants.CONSUMER_SIDE, Integer.toString(url.getPort())); ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension().remove(Constants.CONSUMER_SIDE, Integer.toString(url.getPort())); &#125; æ„é€ æ–¹æ³•ä¸­ä¸ä»…åˆå§‹åŒ–äº†å±æ€§ï¼Œè¿˜è°ƒç”¨äº†æ¨¡ç‰ˆæ–¹æ³•ï¼Œç”¨äºå®Œæˆå­ç±»çš„åˆå§‹åŒ–å·¥ä½œï¼Œå³å®Œæˆå®¢æˆ·ç«¯çš„åˆå§‹åŒ–å¹¶è¿æ¥ä¸ŠæœåŠ¡ã€‚å…·ä½“çš„å®¢æˆ·ç«¯å®ç°åŒæ ·åœ¨åé¢çš„æ–‡ç« ä¸­è¯´æ˜ã€‚ æ¨¡ç‰ˆæ–¹æ³•12345678910111213141516171819202122232425262728293031323334--- AbstractClient /** * Open client. * * @throws Throwable */ protected abstract void doOpen() throws Throwable; /** * Close client. * * @throws Throwable */ protected abstract void doClose() throws Throwable; /** * Connect to server. * * @throws Throwable */ protected abstract void doConnect() throws Throwable; /** * disConnect to server. * * @throws Throwable */ protected abstract void doDisConnect() throws Throwable; /** * Get the connected channel. * * @return channel */ protected abstract Channel getChannel(); ä¸ AbstractServer ç±»ä¼¼ï¼ŒAbstractClient å®šä¹‰äº† doOpen()ã€doClose()ã€doConnect()ã€ doDisConnect() å’Œ getChannel() æŠ½è±¡æ–¹æ³•ç»™å­ç±»å®ç°ä»¥å®Œæˆç‰¹å®šçš„åŠŸèƒ½ã€‚å…¶ä¸­ doClose() æ–¹æ³•åœ¨ Netty å®ç°ä¸­æ˜¯ä¸ªç©ºæ–¹æ³•ã€‚ è¿æ¥æœåŠ¡çš„é€šç”¨é€»è¾‘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051--- AbstractClient/** * è¿æ¥æœåŠ¡å™¨ * * @throws RemotingException */ protected void connect() throws RemotingException &#123; // è·å¾—é” connectLock.lock(); try &#123; // åˆ¤æ–­è¿æ¥çŠ¶æ€ï¼Œè‹¥å·²ç»è¿æ¥å°±ä¸é‡å¤è¿æ¥ã€‚ if (isConnected()) &#123; return; &#125; // åˆå§‹åŒ–é‡è¿çº¿ç¨‹ ã€æ–­çº¿é‡è¿æœºåˆ¶ã€‘ initConnectStatusCheckCommand(); // æ‰§è¡Œè¿æ¥ doConnect(); // æ˜¯å¦å·²ç»è¿æ¥ï¼Œå¦‚è¿‡è¿æ¥å¤±è´¥åˆ™æŠ›å‡ºå¼‚å¸¸ if (!isConnected()) &#123; throw new RemotingException(this, \"Failed connect to server \" + getRemoteAddress() + \" from \" + getClass().getSimpleName() + \" \" + NetUtils.getLocalHost() + \" using dubbo version \" + Version.getVersion() + \", cause: Connect wait timeout: \" + getConnectTimeout() + \"ms.\"); // è¿æ¥æˆåŠŸï¼Œæ‰“å°æ—¥å¿— &#125; else &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Successed connect to server \" + getRemoteAddress() + \" from \" + getClass().getSimpleName() + \" \" + NetUtils.getLocalHost() + \" using dubbo version \" + Version.getVersion() + \", channel is \" + this.getChannel()); &#125; &#125; // è®¾ç½®é‡è¿æ¬¡æ•°å½’é›¶ reconnect_count.set(0); // è®¾ç½®æœªæ‰“å°è¿‡é‡è¿é”™è¯¯æ—¥å¿— reconnect_error_log_flag.set(false); &#125; catch (RemotingException e) &#123; throw e; &#125; catch (Throwable e) &#123; throw new RemotingException(this, \"Failed connect to server \" + getRemoteAddress() + \" from \" + getClass().getSimpleName() + \" \" + NetUtils.getLocalHost() + \" using dubbo version \" + Version.getVersion() + \", cause: \" + e.getMessage(), e); &#125; finally &#123; // é‡Šæ”¾é” connectLock.unlock(); &#125; &#125; è¿æ¥æœåŠ¡é€šç”¨é€»è¾‘ä¸»è¦åšäº†ä»¥ä¸‹å·¥ä½œï¼š è·å¾—é”ï¼Œç”¨äºå®ç°åœ¨è¿æ¥å’Œæ–­å¼€è¿æ¥åŒæ—¶æ“ä½œæ—¶ï¼Œé€šè¿‡åŠ é”ä»¥é˜²æ­¢å¹¶å‘é—®é¢˜ã€‚ åˆ¤æ–­æ˜¯å¦è¿æ¥ï¼Œå¦‚æœè¿æ¥äº†å°±æ— éœ€å†è¿æ¥ï¼Œæ˜¯å¦è¿æ¥é€»è¾‘æ˜¯å¯¹Channelæ¥å£æ–¹æ³•çš„å®ç°ã€‚1234567891011121314--- AbstractClient /** * Dubboçš„Channel æ¥å£ä¸­çš„æ–¹æ³•ã€‚æ–¹æ³•å†…éƒ¨è°ƒç”¨çš„æ˜¯Channelå¯¹è±¡ * * @return */ @Override public boolean isConnected() &#123; Channel channel = getChannel(); if (channel == null) &#123; return false; &#125; return channel.isConnected(); &#125; å¼€å¯æ–­çº¿é‡è¿æœºåˆ¶ï¼Œå³åˆå§‹åŒ–é‡è¿çº¿ç¨‹ï¼Œå®šæ—¶æ£€æŸ¥è¿æ¥çŠ¶æ€ã€‚ è°ƒç”¨å…·ä½“å®¢æˆ·ç«¯å®ç°çš„è¿æ¥æœåŠ¡çš„æ–¹æ³•å»è¿æ¥å¯¹åº”çš„æœåŠ¡ã€‚ è¿æ¥å¤±è´¥æŠ›å‡ºå¼‚å¸¸ï¼Œè¿æ¥æˆåŠŸåˆ™æ‰“å°æ—¥å¿—å¹¶å½’é›¶é‡è¿æ¬¡æ•°ã€‚ æ–­çº¿é‡è¿æœºåˆ¶1234567891011121314151617181920212223242526272829303132333435363738394041424344454647--- AbstractClient /** * åˆå§‹åŒ–é‡è¿çº¿ç¨‹ ã€ä»¥ä¸€å®šé¢‘ç‡å°è¯•é‡è¿ä»»åŠ¡ã€‘ */ private synchronized void initConnectStatusCheckCommand() &#123; // è·å¾—é‡è¿é¢‘ç‡ ã€æ³¨æ„ï¼šé»˜è®¤æ˜¯å¼€å¯çš„ï¼Œ2000æ¯«ç§’ã€‘ int reconnect = getReconnectParam(getUrl()); // è‹¥å¼€å¯é‡è¿åŠŸèƒ½ï¼Œåˆ›å»ºé‡è¿çº¿ç¨‹ if (reconnect &gt; 0 &amp;&amp; (reconnectExecutorFuture == null || reconnectExecutorFuture.isCancelled())) &#123; // åˆ›å»ºé‡è¿ä»»åŠ¡ä½“ Runnable connectStatusCheckCommand = new Runnable() &#123; @Override public void run() &#123; try &#123; // åˆ¤æ–­æ˜¯å¦è¿æ¥ï¼Œæœªè¿æ¥å°±é‡è¿ if (!isConnected()) &#123; connect(); // å·²è¿æ¥åˆ™è®°å½•æœ€åè¿æ¥æ—¶é—´ï¼ˆç¡®ä¿æ˜¯è¿æ¥çŠ¶æ€çš„æ—¶é—´ï¼‰ &#125; else &#123; lastConnectedTime = System.currentTimeMillis(); &#125; &#125; catch (Throwable t) &#123; // ç¬¦åˆæ¡ä»¶æ—¶ï¼Œæ‰“å°é”™è¯¯æˆ–å‘Šè­¦æ—¥å¿—ã€‚ å¦‚æœä¸åŠ èŠ‚åˆ¶æ‰“å°æ—¥å¿—ï¼Œå¾ˆå®¹æ˜“æ‰“å‡ºæ»¡å±æ—¥å¿—ï¼Œä¸¥é‡çš„å¯èƒ½é€ æˆJVMå´©æºƒ // è¶…è¿‡ä¸€å®šæ—¶é—´æœªè¿æ¥ä¸Šï¼Œæ‰æ‰“å°å¼‚å¸¸æ—¥å¿—ã€‚å¹¶ä¸”ï¼Œä»…æ‰“å°ä¸€æ¬¡ã€‚é»˜è®¤15åˆ†é’Ÿ String errorMsg = \"client reconnect to \" + getUrl().getAddress() + \" find error . url: \" + getUrl(); // wait registry sync provider list if (System.currentTimeMillis() - lastConnectedTime &gt; shutdown_timeout) &#123; if (!reconnect_error_log_flag.get()) &#123; reconnect_error_log_flag.set(true); logger.error(errorMsg, t); return; &#125; &#125; // æŒ‰ç…§ä¸€å®šçš„é‡è¿æ¬¡æ•°ï¼Œæ‰“å°å‘Šè­¦æ—¥å¿— if (reconnect_count.getAndIncrement() % reconnect_warning_period == 0) &#123; logger.warn(errorMsg, t); &#125; &#125; &#125; &#125;; // å‘èµ·é‡è¿å®šæ—¶ä»»åŠ¡ï¼Œå®šæ—¶æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¿ [é»˜è®¤ä¸¤ç§’æ£€æŸ¥ä¸€æ¬¡] reconnectExecutorFuture = reconnectExecutorService.scheduleWithFixedDelay(connectStatusCheckCommand, reconnect, reconnect, TimeUnit.MILLISECONDS); &#125; &#125; æ–­çº¿é‡è¿æœºåˆ¶å°±æ˜¯åœ¨å®¢æˆ·ç«¯è¿æ¥æœåŠ¡ç«¯æ—¶ï¼Œä¼šåˆ›å»ºåå°ä»»åŠ¡ï¼Œå®šæ—¶æ£€æŸ¥è¿æ¥ï¼Œè‹¥æ–­å¼€ä¼šè¿›è¡Œé‡è¿ã€‚ å‘é€æ¶ˆæ¯1234567891011121314151617181920212223--- AbstractClient /** * å‘é€æ¶ˆæ¯ * * @param message * @param sent true: ä¼šç­‰å¾…æ¶ˆæ¯å‘å‡ºï¼Œæ¶ˆæ¯å‘é€å¤±è´¥ä¼šæŠ›å‡ºå¼‚å¸¸ï¼› false: ä¸ç­‰å¾…æ¶ˆæ¯å‘å‡ºï¼Œå°†æ¶ˆæ¯æ”¾å…¥IOé˜Ÿåˆ—ï¼Œå³å¯è¿”å› * @throws RemotingException */ @Override public void send(Object message, boolean sent) throws RemotingException &#123; // æœªè¿æ¥æ—¶ï¼Œå¹¶ä¸”å¼€å¯äº†å‘é€æ¶ˆæ¯æ–­å¼€é‡è¿åŠŸèƒ½ï¼Œåˆ™å…ˆå‘èµ·è¿æ¥ if (send_reconnect &amp;&amp; !isConnected()) &#123; connect(); &#125; // è·å–é€šé“ï¼Œå¦‚ NettyChannel å®ä¾‹ï¼Œè¯¥å®ä¾‹å†…éƒ¨channelå®ä¾‹å°±æ˜¯ NioClientSocketChannelã€‚ Channel channel = getChannel(); //TODO Can the value returned by getChannel() be null? need improvement. if (channel == null || !channel.isConnected()) &#123; throw new RemotingException(this, \"message can not send, because channel is closed . url:\" + getUrl()); &#125; // å‘é€æ¶ˆæ¯ channel.send(message, sent); &#125; å®¢æˆ·ç«¯è¿æ¥æœåŠ¡æ—¶åªä¼šæœ‰å¯¹åº”çš„ä¸€ä¸ª Channel é€šé“ï¼Œå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯æ—¶ä½¿ç”¨çš„æ˜¯ Dubbo æ¥å…¥å…·ä½“NIOåº“çš„ Channel å®ä¾‹ï¼Œå¦‚ NettyChannel å®ä¾‹ï¼Œå®ƒå†…éƒ¨å°è£…çš„ Channel å®ä¾‹æ˜¯ Netty çš„é€šé“å®ä¾‹ NioClientSocketChannel ã€‚è¿™ä¸ªåœ¨åé¢çš„æ–‡ç« ä¸­è¯¦ç»†è¯´æ˜ã€‚ æ–­å¼€è¿æ¥è¯¥æ–¹æ³•ç›®å‰ç”¨åœ¨ reconnect() é‡è¿æ–¹æ³•å’Œ close() å…³é—­æ–¹æ³•ä¸­ã€‚ 12345678910111213141516171819202122232425public void disconnect() &#123; // åŠ é” connectLock.lock(); try &#123; // 1 å…³é—­æ–­çº¿é‡è¿ä»»åŠ¡ destroyConnectStatusCheckCommand(); try &#123; // 2 å…³é—­è¿æ¥æœåŠ¡çš„é€šé“ Channel channel = getChannel(); if (channel != null) &#123; channel.close(); &#125; &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; try &#123; // 3 æ¸…é™¤é€šé“ç¼“å­˜(Dubbo å±‚é¢çš„ Channelï¼Œè¯¥Channel å†…éƒ¨å°è£…äº†NIOåº“çš„Channelï¼Œå®ƒä»¬æ˜¯ä¸€å¯¹ä¸€å…³ç³») doDisConnect(); &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; finally &#123; connectLock.unlock(); &#125; &#125; é‡è¿å…ˆæ–­å¼€è¿æ¥ï¼Œåœ¨è¿›è¡Œè¿æ¥ã€‚ 1234567@Overridepublic void reconnect() throws RemotingException &#123; // 1 å…ˆæ–­å¼€è¿æ¥ disconnect(); // 2 è¿æ¥ connect();&#125; å…³é—­12345678910111213141516171819202122232425262728293031@Override public void close() &#123; try &#123; // 1 å…³é—­çº¿ç¨‹æ±  if (executor != null) &#123; ExecutorUtil.shutdownNow(executor, 100); &#125; &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; try &#123; // 2 æ ‡è®°é€šé“å…³é—­å®Œæˆ super.close(); &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; try &#123; // 3 æ–­å¼€è¿æ¥ disconnect(); &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; try &#123; //4 æ‰§è¡Œå…³é—­ doClose(); &#125; catch (Throwable e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; è¶…æ—¶å…³é—­å¯¹çº¿ç¨‹æ± è¶…æ—¶å…³é—­ 12345@Override public void close(int timeout) &#123; ExecutorUtil.gracefulShutdown(executor, timeout); close(); &#125; æŠ½è±¡é€šé“ AbstractChannelAbstractChannel åŒæ ·ç»§æ‰¿äº† AbstractPeer è¿™ä¸ªæŠ½è±¡ç±»ï¼ŒåŒæ—¶è¿˜å®ç°äº† Channel æ¥å£ã€‚AbstractChannel å®ç°éå¸¸ç®€å•ï¼Œåªæ˜¯åœ¨ send() æ–¹æ³•ä¸­æ£€æµ‹äº†åº•å±‚è¿æ¥çš„çŠ¶æ€ï¼Œæ²¡æœ‰å®ç°å…·ä½“çš„å‘é€æ¶ˆæ¯çš„é€»è¾‘ã€‚æ³¨æ„ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ Dubbo å±‚é¢çš„ Channel å’Œ å…·ä½“NIOåº“çš„é€šé“æ˜¯ä¸€å¯¹ä¸€çš„å…³ç³»ï¼Œå‰è€…ä¼šå¯¹åè€…è¿›è¡Œè£…é¥°ï¼Œå‰è€…çš„åŠŸèƒ½æœ¬è´¨ä¸Šæ˜¯åè€…çš„èŒèƒ½ã€‚ 1234567891011121314151617181920public abstract class AbstractChannel extends AbstractPeer implements Channel &#123; // å…³è”äº† ChannelHandler public AbstractChannel(URL url, ChannelHandler handler) &#123; super(url, handler); &#125; /** * å‘é€æ¶ˆæ¯ï¼Œåœ¨è¿™é‡Œåªåšåº•å±‚è¿æ¥çŠ¶æ€æ£€æŸ¥ï¼Œæ²¡æœ‰å®ç°å…·ä½“çš„å‘é€æ¶ˆæ¯çš„é€»è¾‘ï¼Œå…·ä½“çš„å‘é€é€»è¾‘ç”±å­ç±»å®ç° * @param message * @param sent true: ä¼šç­‰å¾…æ¶ˆæ¯å‘å‡ºï¼Œæ¶ˆæ¯å‘é€å¤±è´¥ä¼šæŠ›å‡ºå¼‚å¸¸ï¼› false: ä¸ç­‰å¾…æ¶ˆæ¯å‘å‡ºï¼Œå°†æ¶ˆæ¯æ”¾å…¥IOé˜Ÿåˆ—ï¼Œå³å¯è¿”å› * @throws RemotingException */ @Override public void send(Object message, boolean sent) throws RemotingException &#123; if (isClosed()) &#123; throw new RemotingException(this, \"Failed to send message \" + (message == null ? \"\" : message.getClass().getName()) + \":\" + message + \", cause: Channel closed. channel: \" + getLocalAddress() + \" -&gt; \" + getRemoteAddress()); &#125; &#125;&#125; ç»§æ‰¿å…³ç³»å›¾å¦‚ä¸‹ï¼š å„å­ç±»å®ç°ä¼šå¯¹ send æ–¹æ³•è¿›è¡Œé‡å†™ã€‚ ChannelHandlerå‰æ–‡ä»‹ç»çš„ AbstractEndpointã€AbstractChannel éƒ½æ˜¯é€šè¿‡å¯¹ AbstractPeer ç»§æ‰¿é—´æ¥å®ç°äº† ChannelHandler æ¥å£å¹¶å…³è”äº† ChannelHandler å¯¹è±¡ï¼Œä»…ä»…æ˜¯å¯¹ ChannelHandler çš„è£…é¥°ï¼Œæ–¹æ³•éƒ½æ˜¯å§”æ‰˜ç»™åº•å±‚å…³è”çš„è¿™ä¸ª ChannelHandler å¯¹è±¡ã€‚ä¸‹é¢æˆ‘ä»¬å¯¹ Transporter å±‚ç›¸å…³çš„ ChannelHandler è¿›è¡Œè¯¦ç»†åˆ†æã€‚ç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ChannelHandlerAdapterChannelHandlerAdapter æ˜¯ ChannelHandler çš„ä¸€ä¸ªç©ºå®ç°ï¼ŒTelnetHandlerAdapter ç»§æ‰¿äº†å®ƒå¹¶å®ç°äº† TelnetHandler æ¥å£ï¼Œç”¨äºæ”¯æŒ Dubbo å‘½ä»¤è¡Œçš„æœåŠ¡æ²»ç†ã€‚å…³äº Telnet çš„å®ç°ï¼Œä¼šåœ¨åé¢å•ç‹¬è¿›è¡Œä»‹ç»ï¼Œè¿™é‡Œå°±ä¸å±•å¼€è¯´æ˜äº†ã€‚ 1234567891011121314151617181920212223242526/** * ChannelHandlerAdapter. å®ç°ChannelHandleræ¥å£ï¼Œé€šé“å¤„ç†å™¨é€‚é…å™¨ï¼Œæ¯ä¸ªæ–¹æ³•éƒ½æ˜¯ç©ºå®ç°ã€‚å­ç±»å¯æ ¹æ®å…·ä½“åœºæ™¯é€‰æ‹©æ€§å®ç°æ‰€éœ€æ–¹æ³•ã€‚ */public class ChannelHandlerAdapter implements ChannelHandler &#123; @Override public void connected(Channel channel) throws RemotingException &#123; &#125; @Override public void disconnected(Channel channel) throws RemotingException &#123; &#125; @Override public void sent(Channel channel, Object message) throws RemotingException &#123; &#125; @Override public void received(Channel channel, Object message) throws RemotingException &#123; &#125; @Override public void caught(Channel channel, Throwable exception) throws RemotingException &#123; &#125;&#125; ChannelHandlerDispatcheråœ¨å‰é¢çš„æ–‡ç« ä¸­æœ‰æåˆ°è¿‡ ChannelHandlerDispatcherï¼Œå®ƒç»´æŠ¤äº†ä¸€ä¸ª CopyOnWriteArraySet é›†åˆï¼Œè´Ÿè´£å°†å¤šä¸ª ChannelHandler å¯¹è±¡èšåˆæˆä¸€ä¸ª ChannelHandler å¯¹è±¡ã€‚ 123456789101112131415161718192021222324public class ChannelHandlerDispatcher implements ChannelHandler &#123; private static final Logger logger = LoggerFactory.getLogger(ChannelHandlerDispatcher.class); /** * é€šé“å¤„ç†å™¨é›†åˆ */ private final Collection&lt;ChannelHandler&gt; channelHandlers = new CopyOnWriteArraySet&lt;ChannelHandler&gt;(); public ChannelHandlerDispatcher() &#123; &#125; public ChannelHandlerDispatcher(ChannelHandler... handlers) &#123; this(handlers == null ? null : Arrays.asList(handlers)); &#125; public ChannelHandlerDispatcher(Collection&lt;ChannelHandler&gt; handlers) &#123; if (handlers != null &amp;&amp; !handlers.isEmpty()) &#123; this.channelHandlers.addAll(handlers); &#125; &#125; // çœç•¥å¯¹ ChannelHandler æ¥å£æ–¹æ³•çš„å®ç°&#125; ChannelHandlerDispatcher å®ç°äº† ChannelHandler æ¥å£ä¸­çš„æ‰€æœ‰æ–¹æ³•ï¼Œæ¯ä¸ªæ–¹æ³•éƒ½æ˜¯å¾ªç¯é€šé“é›†åˆè°ƒç”¨ç›¸åº”çš„æ–¹æ³•ã€‚ ChannelHandlerDelegateå®ç° ChannelHandler æ¥å£ï¼Œé€šé“å¤„ç†å™¨è£…é¥°è€…æ¥å£ï¼Œå³æ˜¯å¯¹å…¶å®ƒ ChannelHandler è¿›è¡Œè£…é¥°çš„æ¥å£ï¼Œè¿™ä¸ªæ¥å£éå¸¸é‡è¦ã€‚ 12345678public interface ChannelHandlerDelegate extends ChannelHandler &#123; /** * è·å–è£…é¥°çš„ChannelHandler * * @return */ ChannelHandler getHandler();&#125; ChannelHandlerDelegate æœ‰ä¸‰ä¸ªç›´æ¥çš„å®ç°ç±»ï¼Œåˆ†åˆ«æ˜¯ AbstractChannelHandlerDelegateã€WrappedChannelHandler å’Œ HeaderExchangeHandler ï¼Œå®ƒä»¬å°±æ˜¯å¯¹å…¶å®ƒ ChannelHandler çš„è£…é¥°ã€‚å…¶ä¸­ HeaderExchangeHandler æ˜¯ Exchange å±‚æ¶‰åŠçš„å¯¹è±¡ï¼Œæˆ‘ä»¬å…ˆä¸è®¨è®ºã€‚æˆ‘ä»¬å…ˆæ¥åˆ†æ AbstractChannelHandlerDelegate ç»§æ‰¿ä½“ç³»ã€‚ AbstractChannelHandlerDelegate123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class AbstractChannelHandlerDelegate implements ChannelHandlerDelegate &#123; // è£…é¥°çš„ ChannelHandler protected ChannelHandler handler; protected AbstractChannelHandlerDelegate(ChannelHandler handler) &#123; Assert.notNull(handler, \"handler == null\"); this.handler = handler; &#125; @Override public ChannelHandler getHandler() &#123; if (handler instanceof ChannelHandlerDelegate) &#123; return ((ChannelHandlerDelegate) handler).getHandler(); &#125; return handler; &#125; @Override public void connected(Channel channel) throws RemotingException &#123; handler.connected(channel); &#125; @Override public void disconnected(Channel channel) throws RemotingException &#123; handler.disconnected(channel); &#125; @Override public void sent(Channel channel, Object message) throws RemotingException &#123; handler.sent(channel, message); &#125; @Override public void received(Channel channel, Object message) throws RemotingException &#123; handler.received(channel, message); &#125; @Override public void caught(Channel channel, Throwable exception) throws RemotingException &#123; handler.caught(channel, exception); &#125;&#125; å®ç° ChannelHandlerDelegate æ¥å£ï¼Œåœ¨æ¯ä¸ªå®ç°çš„æ–¹æ³•é‡Œéƒ½æ˜¯ç›´æ¥è°ƒç”¨è¢«è£…é¥°çš„ ChannelHandler å¯¹è±¡å¯¹åº”çš„æ–¹æ³•ï¼Œæ²¡æœ‰å…¶å®ƒé€»è¾‘ã€‚å®ƒçš„ä¸‰ä¸ªå­ç±»éƒ½æ˜¯åœ¨è¢«è£…é¥°çš„ ChannelHandler çš„åŸºç¡€ä¸Šæ·»åŠ äº†ä¸€äº›å¢å¼ºçš„åŠŸèƒ½ï¼Œä½¿ç”¨çš„æ˜¯è£…é¥°è€…æ¨¡å¼ã€‚å› ä¸º HeartbeatHandler å±äº Exchange å±‚çš„ ChannelHandler ï¼Œåœ¨åˆ†æ Exchange å±‚æ—¶å†è¿›è¡Œåˆ†æï¼Œè¿™é‡Œä¸å†å±•å¼€è¯´æ˜ã€‚ DecodeHandler123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class DecodeHandler extends AbstractChannelHandlerDelegate &#123; private static final Logger log = LoggerFactory.getLogger(DecodeHandler.class); public DecodeHandler(ChannelHandler handler) &#123; super(handler); &#125; /** * è¦†å†™äº† received(channel,message)æ–¹æ³• * * @param channel * @param message RpcInvocation æˆ– RpcResult * @throws RemotingException * @see com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec#decodeBody(com.alibaba.dubbo.remoting.Channel, java.io.InputStream, byte[]) */ @Override public void received(Channel channel, Object message) throws RemotingException &#123; // å½“æ¶ˆæ¯æ˜¯ Decodeable ç±»å‹æ—¶ è¿›è¡Œè§£ç  if (message instanceof Decodeable) &#123; decode(message); &#125; // å½“æ¶ˆæ¯æ˜¯Requestç±»å‹æ—¶ï¼Œå¯¹ data å­—æ®µè¿›è¡Œè§£ç  if (message instanceof Request) &#123; decode(((Request) message).getData()); &#125; // å½“æ¶ˆæ¯æ˜¯Responseç±»å‹æ—¶ï¼Œå¯¹ result å­—æ®µè¿›è¡Œè§£ç  if (message instanceof Response) &#123; decode(((Response) message).getResult()); &#125; // è§£ç åï¼Œè°ƒç”¨ChannelHandler#received(channel,message)æ–¹æ³•ï¼Œå°†æ¶ˆæ¯äº¤ç»™å§”æ‰˜çš„handlerç»§ç»­å¤„ç† handler.received(channel, message); &#125; /** * è§£ææ¶ˆæ¯ * * @param message */ private void decode(Object message) &#123; /** * Decodeable æ¥å£ç›®å‰æœ‰ä¸¤ä¸ªå®ç°ç±»ï¼š * 1 DecodeableRpcInvocation * 2 DecodeableRpcResult */ if (message != null &amp;&amp; message instanceof Decodeable) &#123; try &#123; // è§£ææ¶ˆæ¯ ((Decodeable) message).decode(); if (log.isDebugEnabled()) &#123; log.debug(\"Decode decodeable message \" + message.getClass().getName()); &#125; &#125; catch (Throwable e) &#123; if (log.isWarnEnabled()) &#123; log.warn(\"Call Decodeable.decode failed: \" + e.getMessage(), e); &#125; &#125; // ~ end of catch &#125; // ~ end of if &#125; // ~ end of method decode&#125; DecodeHandler æ˜¯ä¸€ä¸ªè§£ç å¤„ç†å™¨ï¼Œä¸“é—¨ç”¨äºå¤„ç† Decodeable ç±»å‹æ¶ˆæ¯çš„ ChannelHandlerå®ç°ç±»ï¼Œå› æ­¤è¯¥å®ç°ç±»åªé‡å†™äº† received() æ¥æ”¶æ¶ˆæ¯çš„æ–¹æ³•ï¼Œå®ƒçš„ä½œç”¨å’Œå«ä¹‰å¦‚ä¸‹ï¼š è¯·æ±‚è§£ç å¯åœ¨IOçº¿ç¨‹ä¸Šæ‰§è¡Œï¼Œä¹Ÿå¯åœ¨çº¿ç¨‹æ± ä¸­æ‰§è¡Œï¼Œå–å†³äºé…ç½®ã€‚DecodeHandler å­˜åœ¨çš„æ„ä¹‰å°±æ˜¯ä¿è¯è¯·æ±‚ä½“æˆ–å“åº”ä½“å¯åœ¨çº¿ç¨‹æ± ä¸­è¢«è§£ç ã€‚ åœ¨Codec2è§£ç å™¨å®ç°ä¸­ï¼Œå¦‚æœè¯·æ±‚ä½“å’Œå“åº”ç»“æœéœ€è¦åœ¨çº¿ç¨‹æ± ä¸­è¿›è¡Œè§£ç ï¼Œé‚£ä¹ˆå°±ä¸è¿›è¡Œç›´æ¥è§£ç ï¼Œè€Œæ˜¯æŠŠè§£ç ä»»åŠ¡æœ€ç»ˆäº¤ç»™çº¿ç¨‹æ± æ¥å¤„ç†ï¼Œæœ€åç”± DecodeHandleræ¥å¤„ç†ï¼Œå› ä¸º DecodeHandler ä¹Ÿå‚ä¸äº†å¯¹ä¸Šå±‚ ChannelHandler çš„åŒ…è£…ã€‚ å®ç°äº† Decodeable æ¥å£çš„ç±»éƒ½ä¼šæä¾›äº†ä¸€ä¸ª decode() æ–¹æ³•å®ç°å¯¹è‡ªèº«çš„è§£ç ï¼ŒDecodeHandler.received() æ–¹æ³•å°±æ˜¯é€šè¿‡è¯¥æ–¹æ³•å¾—åˆ°è§£ç åçš„æ¶ˆæ¯ï¼Œç„¶åä¼ é€’ç»™åº•å±‚çš„ ChannelHandler å¯¹è±¡ç»§ç»­å¤„ç†ã€‚ MultiMessageHandler1234567891011121314151617181920212223242526272829public class MultiMessageHandler extends AbstractChannelHandlerDelegate &#123; public MultiMessageHandler(ChannelHandler handler) &#123; super(handler); &#125; /** * è¦†å†™äº† receivedæ–¹æ³• * * @param channel * @param message * @throws RemotingException */ @SuppressWarnings(\"unchecked\") @Override public void received(Channel channel, Object message) throws RemotingException &#123; // æ¶ˆæ¯ç±»å‹æ˜¯MultiMessageï¼Œå³å¤šæ¶ˆæ¯ if (message instanceof MultiMessage) &#123; MultiMessage list = (MultiMessage) message; // å¾ªç¯æäº¤ç»™handlerå¤„ç† for (Object obj : list) &#123; handler.received(channel, obj); &#125; // å¦‚æœæ˜¯å•æ¶ˆæ¯æ—¶ï¼Œç›´æ¥æäº¤ç»™handlerå¤„ç† &#125; else &#123; handler.received(channel, message); &#125; &#125;&#125; MultiMessageHandler æ˜¯ä¸“é—¨å¤„ç† MultiMessage ç±»å‹æ¶ˆæ¯çš„ ChannelHandler å®ç°ç±»ã€‚MultiMessage æ˜¯ Exchange å±‚çš„ä¸€ç§æ¶ˆæ¯ç±»å‹ï¼Œå®ƒå…¶ä¸­å°è£…äº†å¤šä¸ªæ¶ˆæ¯ã€‚åœ¨ MultiMessageHandler æ”¶åˆ° MultiMessage æ¶ˆæ¯çš„æ—¶å€™ï¼Œreceived() æ–¹æ³•ä¼šéå†å…¶ä¸­çš„æ‰€æœ‰æ¶ˆæ¯ï¼Œå¹¶äº¤ç»™åº•å±‚çš„ ChannelHandler å¯¹è±¡è¿›è¡Œå¤„ç†ã€‚ è‡³æ­¤ï¼ŒTransport å±‚çš„ AbstractChannelHandlerDelegate ç»§æ‰¿ä½“ç³»åˆ†æå®Œæ¯•ã€‚ä¸‹é¢æˆ‘ä»¬ç»§ç»­çœ‹ ChannelHandlerDelegate çš„å¦ä¸€æ¡ç»§æ‰¿ä½“ç³»åˆ†æ”¯ã€‚ WrappedChannelHandlerWrappedChannelHandler ä¹Ÿå®ç°äº† ChannelHandlerDelegate æ¥å£ï¼Œä¹Ÿæ˜¯å¯¹å…¶å®ƒ ChannelHandler è£…é¥°çš„ç±»ã€‚WrappedChannelHandler åœ¨ ChannelHandler æ¥å£æ–¹æ³•å®ç°ä¸Šå’Œ AbstractChannelHandlerDelegate åŸºæœ¬ä¸€è‡´ï¼Œé‚£ä¸ºä»€ä¹ˆåˆè¦æä¸€ä¸ªæ–°çš„ç»§æ‰¿ä½“ç³»è€Œä¸æ˜¯ç›´æ¥ç»§æ‰¿ AbstractChannelHandlerDelegate å‘¢ï¼Ÿå› ä¸º WrappedChannelHandler ç»§æ‰¿ä½“ç³»ä¸ä»…æ˜¯å¯¹å…¶å®ƒ ChannelHandler çš„è£…é¥°è€Œä¸”è¿˜å†³å®šäº† Dubbo çš„çº¿ç¨‹æ¨¡å‹ï¼Œæœ‰å…³ Dubbo ä¸­çš„çº¿ç¨‹æ± ä¼šå•ç‹¬åˆ†æï¼Œè¿™é‡Œå…ˆä¸å±•å¼€è¯´æ˜ã€‚WrappedChannelHandler å…³è”ä½“ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä»ä¸Šå›¾å¯çŸ¥ï¼Œæ¯ä¸ª WrappedChannelHandler çš„å­ç±»éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ Dispatcher å®ç°ç±»ï¼Œè¿™äº›å®ç°ç±»å°±æ˜¯ç”¨æ¥åˆ›å»º WrappedChannelHandler çš„å­ç±»ä»¬ã€‚ Dispatcher æ¥å£å·²ç»åœ¨ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ä¸­å·²ç»ä»‹ç»è¿‡ï¼Œå®ƒä¸»è¦æ”¯æŒäº† Dubbo çš„çº¿ç¨‹æ¨¡å‹ï¼Œé€šè¿‡å®ƒçš„å®ç°ç±»å¯ä»¥åˆ›å»ºä¸åŒçš„ ChannelHandler æ¥å†³å®šæ¶ˆæ¯æ˜¯äº¤ç»™çº¿ç¨‹æ± å¤„ç†è¿˜æ˜¯IOçº¿ç¨‹å¤„ç†ã€‚ WrappedChannelHandler å®ç°äº† ChannelHandlerDelegate æ¥å£ï¼Œå…¶å­ç±»å®ç°äº†æ¶ˆæ¯æ´¾å‘åŠŸèƒ½ï¼Œå³å†³å®šäº† Dubbo ä»¥å“ªç§çº¿ç¨‹æ¨¡å‹å¤„ç†æ”¶åˆ°çš„äº‹ä»¶å’Œæ¶ˆæ¯ã€‚æ¯ä¸ªå­ç±»éƒ½ç”±å¯¹åº”çš„Dispatcher å®ç°ç±»åˆ›å»ºã€‚ å±æ€§ 12345678910111213141516171819202122public class WrappedChannelHandler implements ChannelHandlerDelegate &#123; protected static final Logger logger = LoggerFactory.getLogger(WrappedChannelHandler.class); /** * å…±äº«çº¿ç¨‹æ±  */ protected static final ExecutorService SHARED_EXECUTOR = Executors.newCachedThreadPool(new NamedThreadFactory(\"DubboSharedHandler\", true)); /** * å½“å‰ç«¯ç‚¹å…³è”çš„çº¿ç¨‹æ±  */ protected final ExecutorService executor; /** * è¢«è£…é¥°çš„é€šé“å¤„ç†å™¨ */ protected final ChannelHandler handler; /** * URL */ protected final URL url;&#125; WrappedChannelHandler ä¸­æœ‰å››ä¸ªæ ¸å¿ƒçš„å±æ€§ï¼Œå› ä¸ºæ˜¯å¯¹ ChannelHandler çš„è£…é¥°ï¼Œå› æ­¤ ChannelHandler æ˜¯å¿…é¡»çš„ã€‚éœ€è¦è¯´æ˜çš„æ˜¯å…±äº«çº¿ç¨‹æ± å’Œå½“å‰ç«¯ç‚¹å…³è”çš„çº¿ç¨‹æ± ï¼Œå…±äº«çº¿ç¨‹æ± å¯¹æ¯ä¸ªå­ç±»å…¬ç”¨ï¼Œå½“å‰ç«¯ç‚¹å…³è”çš„çº¿ç¨‹æ± å±äºæ¯ä¸ªå­ç±»å¯¹è±¡ç‹¬æœ‰ï¼Œå®ƒæ˜¯åœ¨æ„é€ æ–¹æ³•ä¸­åˆå§‹åŒ–çš„ã€‚ æ„é€ æ–¹æ³• 123456789101112131415161718192021222324--- WrappedChannelHandler public WrappedChannelHandler(ChannelHandler handler, URL url) &#123; // èµ‹å€¼ this.handler = handler; this.url = url; // åŸºäºSPIæœºåˆ¶åˆ›å»ºçº¿ç¨‹æ±  executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool.class).getAdaptiveExtension().getExecutor(url); // é»˜è®¤æ˜¯ ExecutorService çš„åç§° String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY; // å¦‚æœæ˜¯æ¶ˆè´¹ç«¯ï¼Œåˆ™ componentKey ä¸º 'consumer' if (Constants.CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(Constants.SIDE_KEY))) &#123; componentKey = Constants.CONSUMER_SIDE; &#125; // åŸºäºSPIæœºåˆ¶åˆ›å»ºçº¿ç¨‹æ± å­˜å‚¨å¯¹è±¡ DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension(); // æ·»åŠ çº¿ç¨‹æ± åˆ° DataStoreä¸­ dataStore.put(componentKey, Integer.toString(url.getPort()), executor); &#125; é€šè¿‡ WrappedChannelHandler çš„æ„é€ æ–¹æ³•å¯çŸ¥ï¼Œæ¯ä¸ªå­ç±»å¯¹è±¡éƒ½ä¼šåˆ›å»ºä¸€ä¸ªçº¿ç¨‹æ± å¹¶æ·»åŠ åˆ° DataStore ç¼“å­˜èµ·æ¥ï¼Œæˆ‘ä»¬ä¸Šé¢ä»‹ç»çš„ AbstractClient å’Œ AbstractServer æ˜¯ä» DataStore è·å¾—çº¿ç¨‹æ± çš„ï¼Œè€Œæ•°æ®æ¥æºæ­£æ˜¯è¿™é‡Œã€‚å…³äºçº¿ç¨‹æ± çš„ä»‹ç»ï¼Œä¼šåœ¨åé¢çš„æ–‡ç« ä¸­è¯¦ç»†åˆ†æï¼Œè¿™é‡Œå…ˆä¸å±•å¼€è¯´æ˜ã€‚ DataSource æ ¸å¿ƒå°±æ˜¯ä¸€ä¸ª Map ç»“æ„ç¼“å­˜ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142// SimpleDataStore æ˜¯ DataStore å”¯ä¸€æ‰©å±•å®ç°public class SimpleDataStore implements DataStore &#123; /** * key1: ExecutorService çš„åç§° æˆ– 'consumer' * key2: port * value: ExecutorService */ private ConcurrentMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt; data = new ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt;(); @Override public Map&lt;String, Object&gt; get(String componentName) &#123; ConcurrentMap&lt;String, Object&gt; value = data.get(componentName); if (value == null) return new HashMap&lt;String, Object&gt;(); return new HashMap&lt;String, Object&gt;(value); &#125; @Override public Object get(String componentName, String key) &#123; if (!data.containsKey(componentName)) &#123; return null; &#125; return data.get(componentName).get(key); &#125; @Override public void put(String componentName, String key, Object value) &#123; Map&lt;String, Object&gt; componentData = data.get(componentName); if (null == componentData) &#123; data.putIfAbsent(componentName, new ConcurrentHashMap&lt;String, Object&gt;()); componentData = data.get(componentName); &#125; componentData.put(key, value); &#125; @Override public void remove(String componentName, String key) &#123; if (!data.containsKey(componentName)) &#123; return; &#125; data.get(componentName).remove(key); &#125;&#125; è·å–çº¿ç¨‹æ±  è·å–çº¿ç¨‹æ± ï¼Œä¾›å­ç±»ä½¿ç”¨è°ƒç”¨ã€‚ 1234567891011121314--- WrappedChannelHandler/** * è·å–å½“å‰ç«¯ç‚¹å…³è”çš„å…¬å…±çº¿ç¨‹æ± ï¼Œéƒ¨åˆ†å­ç±»ä¼šä½¿ç”¨ * * @return */ public ExecutorService getExecutorService() &#123; ExecutorService cexecutor = executor; // å½“å‰ç«¯ç‚¹å…³è”çš„çº¿ç¨‹æ± ä¸ºç©ºæˆ–å…³é—­å°±ä½¿ç”¨å…±äº«çš„ if (cexecutor == null || cexecutor.isShutdown()) &#123; cexecutor = SHARED_EXECUTOR; &#125; return cexecutor; &#125; WrappedChannelHandler å®ç° ChannelHandler æ¥å£çš„æ–¹æ³•éƒ½æ˜¯ç›´æ¥è°ƒç”¨è£…é¥°çš„ ChannelHandler å¯¹åº”çš„æ–¹æ³•ï¼Œå°±ä¸å†è¿›è¡Œåˆ†æã€‚ çº¿ç¨‹æ¨¡å‹å¦‚æœäº‹ä»¶å¤„ç†çš„é€»è¾‘èƒ½è¿…é€Ÿå®Œæˆï¼Œå¹¶ä¸”ä¸ä¼šå‘èµ·æ–°çš„ IO è¯·æ±‚ï¼Œæ¯”å¦‚åªæ˜¯åœ¨å†…å­˜ä¸­è®°ä¸ªæ ‡è¯†ï¼Œåˆ™ç›´æ¥åœ¨ IO çº¿ç¨‹ä¸Šå¤„ç†æ›´å¿«ï¼Œå› ä¸ºå‡å°‘äº†çº¿ç¨‹æ± è°ƒåº¦ã€‚ä½†å¦‚æœäº‹ä»¶å¤„ç†é€»è¾‘è¾ƒæ…¢ï¼Œæˆ–è€…éœ€è¦å‘èµ·æ–°çš„ IO è¯·æ±‚ï¼Œæ¯”å¦‚éœ€è¦æŸ¥è¯¢æ•°æ®åº“ï¼Œåˆ™å¿…é¡»æ´¾å‘åˆ°çº¿ç¨‹æ± ï¼Œå¦åˆ™ IO çº¿ç¨‹é˜»å¡ï¼Œå°†å¯¼è‡´ä¸èƒ½æ¥æ”¶å…¶å®ƒè¯·æ±‚ã€‚å› æ­¤ï¼Œéœ€è¦é€šè¿‡ä¸åŒçš„æ´¾å‘ç­–ç•¥å’Œä¸åŒçš„çº¿ç¨‹æ± é…ç½®çš„ç»„åˆæ¥åº”å¯¹ä¸åŒçš„åœºæ™¯: 1&lt;dubbo:protocol name=\"dubbo\" dispatcher=\"all\" threadpool=\"fixed\" threads=\"100\" /&gt; Dubbo çš„çº¿ç¨‹æ¨¡å‹éœ€è¦å…·æœ‰çº¿ç¨‹æ´¾å‘èƒ½åŠ›çš„ ChannelHandler å’Œ å®šåˆ¶åŒ–çš„çº¿ç¨‹æ± æ¥æ”¯æ’‘ã€‚Dispatcher çš„èŒè´£å°±æ˜¯ç”¨æ¥åˆ›å»ºå…·æœ‰çº¿ç¨‹æ´¾å‘èƒ½åŠ›çš„ ChannelHandlerï¼Œå…¶æœ¬èº«å¹¶ä¸å…·å¤‡çº¿ç¨‹æ´¾å‘èƒ½åŠ›ã€‚å…³äº Dispatcher åœ¨ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ä¸­å·²ç»ä»‹ç»ï¼Œè¿™é‡Œä¸å†é‡å¤è¯´æ˜ã€‚ Dispatcher æ´¾å‘ç­–ç•¥ï¼š all: æ‰€æœ‰æ¶ˆæ¯éƒ½æ´¾å‘åˆ°çº¿ç¨‹æ± ï¼ŒåŒ…æ‹¬è¯·æ±‚ï¼Œå“åº”ï¼Œè¿æ¥äº‹ä»¶ï¼Œæ–­å¼€äº‹ä»¶ï¼Œå¿ƒè·³ç­‰ã€‚ direct: æ‰€æœ‰æ¶ˆæ¯éƒ½ä¸æ´¾å‘åˆ°çº¿ç¨‹æ± ï¼Œå…¨éƒ¨åœ¨ IO çº¿ç¨‹ä¸Šç›´æ¥æ‰§è¡Œã€‚ message: åªæœ‰è¯·æ±‚å“åº”æ¶ˆæ¯æ´¾å‘åˆ°çº¿ç¨‹æ± ï¼Œå…¶å®ƒè¿æ¥æ–­å¼€äº‹ä»¶ï¼Œå¿ƒè·³ç­‰æ¶ˆæ¯ï¼Œç›´æ¥åœ¨ IO çº¿ç¨‹ä¸Šæ‰§è¡Œã€‚ execution: åªæœ‰è¯·æ±‚æ¶ˆæ¯æ´¾å‘åˆ°çº¿ç¨‹æ± ï¼Œä¸å«å“åº”ï¼Œå“åº”å’Œå…¶å®ƒè¿æ¥æ–­å¼€äº‹ä»¶ï¼Œå¿ƒè·³ç­‰æ¶ˆæ¯ï¼Œç›´æ¥åœ¨ IO çº¿ç¨‹ä¸Šæ‰§è¡Œã€‚ connection: åœ¨ IO çº¿ç¨‹ä¸Šï¼Œå°†è¿æ¥æ–­å¼€äº‹ä»¶æ”¾å…¥é˜Ÿåˆ—ï¼Œæœ‰åºé€ä¸ªæ‰§è¡Œï¼Œå…¶å®ƒæ¶ˆæ¯æ´¾å‘åˆ°çº¿ç¨‹æ± ã€‚ å…³äºçº¿ç¨‹æ± éƒ¨åˆ†åœ¨åé¢çš„æ–‡ç« ä¸­è¯¦ç»†è¯´æ˜ï¼Œå…ˆä¸åœ¨è¿™é‡Œå±•å¼€ä»‹ç»ã€‚ Dispatcher å®ç°ç±»ç”¨æ¥åˆ›å»º WrappedChannelHandler çš„å­ç±»å¯¹è±¡ï¼Œæ¯ä¸ªå­ç±»å¯¹è±¡ä»£è¡¨ä¸åŒçš„æ´¾å‘ç­–ç•¥ï¼ŒåŒæ—¶å­ç±»å¯¹è±¡åœ¨åˆ›å»ºçš„æ—¶å€™ä¼šåˆå§‹åŒ–ä¸€ä¸ªçº¿ç¨‹æ± ã€‚ä¸‹é¢æˆ‘ä»¬æ¥åˆ†æ Dispatcher æ‰©å±•å®ç°å’Œå¯¹åº”çš„ WrappedChannelHandler çš„å­ç±»ã€‚ AllDispatcher &amp; AllChannelHandlerAllDispatcher ç”¨æ¥åˆ›å»º AllChannelHandler å¯¹è±¡ï¼Œä»£ç å¦‚ä¸‹ï¼š 12345678910111213public class AllDispatcher implements Dispatcher &#123; public static final String NAME = \"all\"; /** * åˆ›å»º AllChannelHandler å¯¹è±¡ * @param handler * @param url * @return */ @Override public ChannelHandler dispatch(ChannelHandler handler, URL url) &#123; return new AllChannelHandler(handler, url); &#125;&#125; AllChannelHandler å®ç° WrappedChannelHandler æŠ½è±¡ç±»ï¼Œæ‰€æœ‰æ¶ˆæ¯éƒ½æ´¾å‘åˆ°çº¿ç¨‹æ± ï¼ŒåŒ…æ‹¬è¯·æ±‚ï¼Œå“åº”ï¼Œè¿æ¥äº‹ä»¶ï¼Œæ–­å¼€äº‹ä»¶ï¼Œå¿ƒè·³ç­‰ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class AllChannelHandler extends WrappedChannelHandler &#123; // æ„é€ æ–¹æ³•è°ƒç”¨çˆ¶ç±»æ–¹æ³•ï¼Œåˆ›å»ºç‹¬äº«çš„çº¿ç¨‹æ±  public AllChannelHandler(ChannelHandler handler, URL url) &#123; super(handler, url); &#125; /** * å¤„ç†è¿æ¥äº‹ä»¶ * * @param channel * @throws RemotingException */ @Override public void connected(Channel channel) throws RemotingException &#123; // è·å–çº¿ç¨‹æ±  ExecutorService cexecutor = getExecutorService(); try &#123; // å°†CONNECTED äº‹ä»¶çš„å¤„ç†å°è£…æˆChannelEventRunnableæäº¤åˆ°çº¿ç¨‹æ± ä¸­æ‰§è¡Œ cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CONNECTED)); &#125; catch (Throwable t) &#123; throw new ExecutionException(\"connect event\", channel, getClass() + \" error when process connected event .\", t); &#125; &#125; /** * å¤„ç†æ–­å¼€è¿æ¥äº‹ä»¶ * * @param channel * @throws RemotingException */ @Override public void disconnected(Channel channel) throws RemotingException &#123; // è·å–çº¿ç¨‹æ±  ExecutorService cexecutor = getExecutorService(); try &#123; // åˆ›å»ºChannelEventRunnableå¯¹è±¡ï¼Œç”¨äºå°†æ–­å¼€è¿æ¥äº‹ä»¶ä»»åŠ¡æ´¾å‘åˆ°çº¿ç¨‹æ± æ‰§è¡Œ cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED)); &#125; catch (Throwable t) &#123; throw new ExecutionException(\"disconnect event\", channel, getClass() + \" error when process disconnected event .\", t); &#125; &#125; /** * æ¥æ”¶åˆ°çš„æ‰€æœ‰æ¶ˆæ¯éƒ½æ´¾å‘åˆ°çº¿ç¨‹æ± ã€‚æ³¨æ„è¿™é‡Œçš„message å¯èƒ½æ˜¯ Requestä¹Ÿå¯èƒ½æ˜¯ Responseã€‚ * æµç¨‹å¤§æ¦‚æ˜¯ï¼šæ¶ˆæ¯å…ˆç”±IOçº¿ç¨‹ï¼ˆNetty ä¸­çš„EventLoopGroup ï¼‰ä»äºŒè¿›åˆ¶æµä¸­è§£ç å‡ºæ¥ï¼Œç„¶åæ‰§è¡Œåˆ°è¯¥æ–¹æ³•ä¼šæŠŠè¯·æ±‚æäº¤ç»™çº¿ç¨‹æ± å¤„ç†ï¼Œå¤„ç†å®Œåè°ƒç”¨send æ–¹æ³•ç”¨äºå‘å¯¹ç«¯å†™å›ç»“æœã€‚ * * @param channel * @param message * @throws RemotingException */ @Override public void received(Channel channel, Object message) throws RemotingException &#123; ExecutorService cexecutor = getExecutorService(); try &#123; // å°†è¯·æ±‚/å“åº”æ¶ˆæ¯æ´¾å‘åˆ°çº¿ç¨‹æ± ä¸­å¤„ç†ï¼ŒChannelEventRunnableå¯¹è±¡ä½œä¸ºä»»åŠ¡ä½“ cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message)); &#125; catch (Throwable t) &#123; // å¦‚æœæ˜¯è¯·æ±‚æ¶ˆæ¯ï¼Œå¹¶ä¸”å‡ºç°äº†çº¿ç¨‹æ± æ»¡äº†çš„å¼‚å¸¸ if (message instanceof Request &amp;&amp; t instanceof RejectedExecutionException) &#123; Request request = (Request) message; // å¦‚æœé€šä¿¡æ–¹å¼ä¸ºåŒå‘é€šä¿¡ï¼Œå°†é”™è¯¯ä¿¡æ¯å°è£…åˆ°Response ä¸­ï¼Œå¹¶è¿”å›ç»™æœåŠ¡æ¶ˆè´¹æ–¹ã€‚é˜²æ­¢æ¶ˆè´¹ç«¯ç­‰å¾…è¶…æ—¶ if (request.isTwoWay()) &#123; String msg = \"Server side(\" + url.getIp() + \",\" + url.getPort() + \") threadpool is exhausted ,detail msg:\" + t.getMessage(); Response response = new Response(request.getId(), request.getVersion()); response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR); response.setErrorMessage(msg); // è¿”å›åŒ…å«é”™è¯¯ä¿¡æ¯çš„ Response å¯¹è±¡ channel.send(response); return; &#125; &#125; throw new ExecutionException(message, channel, getClass() + \" error when process received event .\", t); &#125; &#125; /** * å¤„ç†å¼‚å¸¸ä¿¡æ¯ * * @param channel * @param exception * @throws RemotingException */ @Override public void caught(Channel channel, Throwable exception) throws RemotingException &#123; ExecutorService cexecutor = getExecutorService(); try &#123; cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception)); &#125; catch (Throwable t) &#123; throw new ExecutionException(\"caught event\", channel, getClass() + \" error when process caught event .\", t); &#125; &#125;&#125; AllChannelHandler é‡å†™äº† WrappedChannelHandler ä¸­é™¤äº†å‘é€æ¶ˆæ¯çš„ sent() æ–¹æ³•ä¹‹å¤–çš„å…¶å®ƒæ–¹æ³•ï¼Œæ‰§è¡Œåº•å±‚çš„ ChannelHandler çš„é€»è¾‘éƒ½äº¤ç»™çº¿ç¨‹æ± å¤„ç†ï¼Œè¯·æ±‚æ‰§è¡Œå®Œæ¯•åå‘é€æ¶ˆæ¯ AllChannelHandler ä¼šç›´æ¥åœ¨ IO çº¿ç¨‹ä¸­è¿›è¡Œå¤„ç†ã€‚ ExecutionDispatcher &amp; AllChannelHandlerExecutionDispatcher ç”¨æ¥åˆ›å»º ExecutionChannelHandler å¯¹è±¡ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456789101112131415public class ExecutionDispatcher implements Dispatcher &#123; public static final String NAME = \"execution\"; /** * åˆ›å»º ExecutionChannelHandler å¯¹è±¡ * * @param handler é€šé“å¤„ç† * @param url url * @return */ @Override public ChannelHandler dispatch(ChannelHandler handler, URL url) &#123; return new ExecutionChannelHandler(handler, url); &#125;&#125; ExecutionChannelHandler å®ç° WrappedChannelHandler æŠ½è±¡ç±»ï¼Œåªä¼šå°†è¯·æ±‚æ¶ˆæ¯æ´¾å‘åˆ°çº¿ç¨‹æ± è¿›è¡Œå¤„ç†ã€‚å¯¹äºå“åº”æ¶ˆæ¯ä»¥åŠå…¶ä»–ç½‘ç»œäº‹ä»¶ï¼ˆä¾‹å¦‚ï¼Œè¿æ¥å»ºç«‹äº‹ä»¶ã€è¿æ¥æ–­å¼€äº‹ä»¶ã€å¿ƒè·³æ¶ˆæ¯ç­‰ï¼‰ï¼ŒExecutionChannelHandler ä¼šç›´æ¥åœ¨ IO çº¿ç¨‹ä¸­è¿›è¡Œå¤„ç†ï¼Œä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334public class ExecutionChannelHandler extends WrappedChannelHandler &#123; // æ„é€ æ–¹æ³•è°ƒç”¨çˆ¶ç±»æ–¹æ³•ï¼Œåˆ›å»ºç‹¬äº«çš„çº¿ç¨‹æ±  public ExecutionChannelHandler(ChannelHandler handler, URL url) &#123; super(handler, url); &#125; @Override public void received(Channel channel, Object message) throws RemotingException &#123; ExecutorService cexecutor = getExecutorService(); // è¯·æ±‚æ¶ˆæ¯ if (message instanceof Request) &#123; try &#123; cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message)); &#125; catch (Throwable t) &#123; if (t instanceof RejectedExecutionException) &#123; Request request = (Request) message; if (request.isTwoWay()) &#123; String msg = \"Server side(\" + url.getIp() + \",\" + url.getPort() + \") thread pool is exhausted, detail msg:\" + t.getMessage(); Response response = new Response(request.getId(), request.getVersion()); response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR); response.setErrorMessage(msg); channel.send(response); return; &#125; &#125; throw new ExecutionException(message, channel, getClass() + \" error when process received event.\", t); &#125; &#125; else &#123; // ç›´æ¥äº¤ç»™è£…é¥°çš„ ChannelHandler å¤„ç† handler.received(channel, message); &#125; &#125;&#125; ç”±ä¸Šé¢ä»£ç å¯çŸ¥ï¼ŒExecutionChannelHandler åªé‡å†™äº† received() æ–¹æ³•å¹¶ä¸”åªå¤„ç†è¯·æ±‚æ¶ˆæ¯ï¼Œå…¶å®ƒæ–¹æ³•çš„è°ƒç”¨ç›´æ¥è°ƒç”¨çˆ¶ç±»çš„ï¼Œæ˜¯ç›´æ¥åœ¨ IO çº¿ç¨‹ä¸­è¿›è¡Œå¤„ç†ã€‚ DirectDispatcher &amp; DirectChannelHandlerdirect ç±»å‹ï¼Œæ‰€æœ‰æ¶ˆæ¯éƒ½ä¸æ´¾å‘åˆ°çº¿ç¨‹æ± ï¼Œå…¨éƒ¨åœ¨ IO çº¿ç¨‹ä¸Šç›´æ¥æ‰§è¡Œï¼Œç›¸å…³ä»£ç å¦‚ä¸‹ï¼š 12345678public class DirectDispatcher implements Dispatcher &#123; public static final String NAME = \"direct\"; @Override public ChannelHandler dispatch(ChannelHandler handler, URL url) &#123; return handler; &#125;&#125; MessageOnlyDispatcher &amp; MessageOnlyChannelHandlerMessageOnlyDispatcher ç”¨æ¥åˆ›å»º MessageOnlyChannelHandler å¯¹è±¡ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456789101112131415public class MessageOnlyDispatcher implements Dispatcher &#123; public static final String NAME = \"message\"; /** * åˆ›å»º MessageOnlyChannelHandler * @param handler é€šé“å¤„ç† * @param url url * @return */ @Override public ChannelHandler dispatch(ChannelHandler handler, URL url) &#123; return new MessageOnlyChannelHandler(handler, url); &#125;&#125; MessageOnlyChannelHandler å®ç° WrappedChannelHandler æŠ½è±¡ç±»ï¼Œä¼šå°†æ‰€æœ‰æ”¶åˆ°çš„æ¶ˆæ¯ï¼ˆè¯·æ±‚/å“åº”ï¼‰æäº¤åˆ°çº¿ç¨‹æ± å¤„ç†ï¼Œå…¶ä»–ç½‘ç»œäº‹ä»¶ï¼ˆè¿æ¥æ–­å¼€äº‹ä»¶ï¼Œå¿ƒè·³ç­‰æ¶ˆæ¯ï¼‰åˆ™æ˜¯ç”± IO çº¿ç¨‹ç›´æ¥å¤„ç†ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324public class MessageOnlyChannelHandler extends WrappedChannelHandler &#123; // æ„é€ æ–¹æ³•è°ƒç”¨çˆ¶ç±»æ–¹æ³•ï¼Œåˆ›å»ºç‹¬äº«çš„çº¿ç¨‹æ±  public MessageOnlyChannelHandler(ChannelHandler handler, URL url) &#123; super(handler, url); &#125; /** * å¤„ç†è¯»å–åˆ°çš„æ•°æ® * * @param channel * @param message request/response * @throws RemotingException */ @Override public void received(Channel channel, Object message) throws RemotingException &#123; ExecutorService cexecutor = getExecutorService(); try &#123; cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message)); &#125; catch (Throwable t) &#123; throw new ExecutionException(message, channel, getClass() + \" error when process received event .\", t); &#125; &#125;&#125; ç”±ä¸Šé¢ä»£ç å¯çŸ¥ï¼ŒExecutionChannelHandler åªé‡å†™äº† received() æ–¹æ³•ï¼Œå…¶å®ƒæ–¹æ³•çš„è°ƒç”¨æ˜¯ç›´æ¥è°ƒç”¨çˆ¶ç±»çš„æ–¹æ³•ï¼Œç›´æ¥åœ¨ IO çº¿ç¨‹ä¸­è¿›è¡Œå¤„ç†ã€‚ ConnectionOrderedDispatcher &amp; ConnectionOrderedChannelHandlerConnectionOrderedDispatcher ç”¨æ¥åˆ›å»º ConnectionOrderedChannelHandler å¯¹è±¡ï¼Œä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516public class ConnectionOrderedDispatcher implements Dispatcher &#123; public static final String NAME = \"connection\"; /** * åˆ›å»º ConnectionOrderedChannelHandler å¯¹è±¡ * * @param handler é€šé“å¤„ç† * @param url url * @return */ @Override public ChannelHandler dispatch(ChannelHandler handler, URL url) &#123; return new ConnectionOrderedChannelHandler(handler, url); &#125;&#125; ConnectionOrderedChannelHandler å®ç° WrappedChannelHandler æŠ½è±¡ç±»ï¼Œä¼šå°†æ”¶åˆ°çš„æ¶ˆæ¯äº¤ç»™çº¿ç¨‹æ± è¿›è¡Œå¤„ç†ï¼Œå¯¹äºè¿æ¥å»ºç«‹ä»¥åŠæ–­å¼€äº‹ä»¶æ˜¯é€šè¿‡ IO çº¿ç¨‹å°†è¿æ¥ã€æ–­å¼€äº‹ä»¶äº¤ç»™ connectionExecutor çº¿ç¨‹æ± æ’é˜Ÿå¤„ç†çš„ï¼Œä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class ConnectionOrderedChannelHandler extends WrappedChannelHandler &#123; /** * å¤„ç†è¿æ¥å»ºç«‹å’Œæ–­å¼€äº‹ä»¶çš„çº¿ç¨‹æ± ï¼Œçº¿ç¨‹æ± çº¿ç¨‹æ•°åªæœ‰ä¸€ä¸ªï¼Œå› æ­¤ä»»åŠ¡å¤šçš„æƒ…å†µä¼šå…ˆå †ç§¯åˆ°é˜»å¡é˜Ÿåˆ—è¿›è¡Œæ’é˜Ÿï¼Œæœ‰åºæ‰§è¡Œ */ protected final ThreadPoolExecutor connectionExecutor; /** * çº¿ç¨‹æ± é˜»å¡é˜Ÿåˆ—å‘Šè­¦é˜ˆå€¼ */ private final int queuewarninglimit; public ConnectionOrderedChannelHandler(ChannelHandler handler, URL url) &#123; // è°ƒç”¨çˆ¶ç±»æ„é€ æ–¹æ³•ï¼Œåˆ›å»ºç‹¬äº«çš„çº¿ç¨‹æ±  super(handler, url); // ä» 'threadname' é…ç½®é¡¹è·å–çº¿ç¨‹æ± åï¼Œé»˜è®¤ä¸º Dubbo String threadName = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME); // è¯¥çº¿ç¨‹æ± åªæœ‰ä¸€ä¸ªçº¿ç¨‹ï¼Œå¹¶ä¸”é˜»å¡é˜Ÿåˆ—çš„é•¿åº¦ä¹Ÿæ˜¯å›ºå®šçš„ï¼Œç”±é…ç½®å‚æ•°å†³å®š connectionExecutor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(url.getPositiveParameter(Constants.CONNECT_QUEUE_CAPACITY, Integer.MAX_VALUE)), new NamedThreadFactory(threadName, true), new AbortPolicyWithReport(threadName, url) ); // ä» 'connect.queue.warning.size' é…ç½®é¡¹è·å–çº¿ç¨‹æ± é˜»å¡é˜Ÿåˆ—å‘Šè­¦é˜ˆå€¼ï¼Œé»˜è®¤å¤§å°ä¸º 1000 queuewarninglimit = url.getParameter(Constants.CONNECT_QUEUE_WARNING_SIZE, Constants.DEFAULT_CONNECT_QUEUE_WARNING_SIZE); &#125; @Override public void connected(Channel channel) throws RemotingException &#123; try &#123; checkQueueLength(); connectionExecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CONNECTED)); &#125; catch (Throwable t) &#123; throw new ExecutionException(\"connect event\", channel, getClass() + \" error when process connected event .\", t); &#125; &#125; @Override public void disconnected(Channel channel) throws RemotingException &#123; try &#123; checkQueueLength(); connectionExecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED)); &#125; catch (Throwable t) &#123; throw new ExecutionException(\"disconnected event\", channel, getClass() + \" error when process disconnected event .\", t); &#125; &#125; @Override public void received(Channel channel, Object message) throws RemotingException &#123; ExecutorService cexecutor = getExecutorService(); try &#123; cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message)); &#125; catch (Throwable t) &#123; //fix, reject exception can not be sent to consumer because thread pool is full, resulting in consumers waiting till timeout. if (message instanceof Request &amp;&amp; t instanceof RejectedExecutionException) &#123; Request request = (Request) message; if (request.isTwoWay()) &#123; String msg = \"Server side(\" + url.getIp() + \",\" + url.getPort() + \") threadpool is exhausted ,detail msg:\" + t.getMessage(); Response response = new Response(request.getId(), request.getVersion()); response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR); response.setErrorMessage(msg); channel.send(response); return; &#125; &#125; throw new ExecutionException(message, channel, getClass() + \" error when process received event .\", t); &#125; &#125; @Override public void caught(Channel channel, Throwable exception) throws RemotingException &#123; ExecutorService cexecutor = getExecutorService(); try &#123; cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception)); &#125; catch (Throwable t) &#123; throw new ExecutionException(\"caught event\", channel, getClass() + \" error when process caught event .\", t); &#125; &#125; // æ£€æŸ¥é˜ˆå€¼ private void checkQueueLength() &#123; // æ’é˜Ÿä»»åŠ¡è¶…è¿‡é˜ˆå€¼æ‰“å°å‘Šè­¦æ—¥å¿— if (connectionExecutor.getQueue().size() &gt; queuewarninglimit) &#123; logger.warn(new IllegalThreadStateException(\"connectionordered channel handler `queue size: \" + connectionExecutor.getQueue().size() + \" exceed the warning limit number :\" + queuewarninglimit)); &#125; &#125;&#125; å’Œ AllChannelHandler ä¸€æ ·ï¼Œå‘é€æ¶ˆæ¯ç”± ConnectionOrderedChannelHandler ç›´æ¥åœ¨ IO çº¿ç¨‹ä¸­è¿›è¡Œå¤„ç†ï¼ŒåŒºåˆ«åœ¨äºåè€…çš„è¿æ¥å»ºç«‹ã€æ–­å¼€äº‹ä»¶ä¸æ˜¯é€šè¿‡çˆ¶ç±»ä¸­åˆ›å»ºçš„çº¿ç¨‹æ± å¤„ç†ï¼Œè€Œæ˜¯åˆ›å»ºäº†ä¸€ä¸ªæ’é˜Ÿçº¿ç¨‹æ± ã€‚ä¹‹æ‰€ä»¥å«å®ƒæ’é˜Ÿçº¿ç¨‹æ± ï¼Œæ˜¯è¯¥çº¿ç¨‹æ± åªæœ‰ä¸€ä¸ªçº¿ç¨‹ï¼Œå¹¶ä¸”ä½¿ç”¨çš„é˜»å¡é˜Ÿåˆ—æ˜¯æœ‰åºçš„ã€‚ ChannelEventRunnable çº¿ç¨‹æ´¾å‘ä»»åŠ¡ä½“å®ç°Runnableæ¥å£ï¼Œè¯¥ä»»åŠ¡ä½“è¢«ä¸åŒçš„çº¿ç¨‹æ´¾å‘æœºåˆ¶ä½¿ç”¨ã€‚ å±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ChannelEventRunnable implements Runnable &#123; private static final Logger logger = LoggerFactory.getLogger(ChannelEventRunnable.class); /** * è£…é¥°çš„é€šé“å¤„ç†å™¨ï¼Œä¼šåœ¨çº¿ç¨‹æ± ä¸­å¤„ç†æ¶ˆæ¯ */ private final ChannelHandler handler; /** * é€šé“ */ private final Channel channel; /** * é€šé“çŠ¶æ€ */ private final ChannelState state; /** * æ¶ˆæ¯ï¼ˆå¯èƒ½ä¸ºç©ºï¼Œå¦‚è¿æ¥æ–­å¼€äº‹ä»¶ï¼‰ */ private final Object message; /** * å¤„ç†å¼‚å¸¸æ—¶ï¼Œæ•è·çš„å¼‚å¸¸ */ private final Throwable exception; public ChannelEventRunnable(Channel channel, ChannelHandler handler, ChannelState state) &#123; this(channel, handler, state, null); &#125; public ChannelEventRunnable(Channel channel, ChannelHandler handler, ChannelState state, Object message) &#123; this(channel, handler, state, message, null); &#125; public ChannelEventRunnable(Channel channel, ChannelHandler handler, ChannelState state, Throwable t) &#123; this(channel, handler, state, null, t); &#125; public ChannelEventRunnable(Channel channel, ChannelHandler handler, ChannelState state, Object message, Throwable exception) &#123; this.channel = channel; this.handler = handler; this.state = state; this.message = message; this.exception = exception; &#125;&#125; ChannelEventRunnable ä¸­çš„å±æ€§éƒ½æ˜¯ç”±çº¿ç¨‹æ´¾å‘ç›¸å…³çš„ ChannelHandler ä¼ å…¥çš„ï¼Œä¸åŒçš„æ´¾å‘ç­–ç•¥ä¼ å…¥çš„å±æ€§ä¸åŒï¼Œé€šè¿‡ä¸åŒçš„æ„é€ æ–¹æ³•ä¹Ÿå¯ä»¥çœ‹å‡ºã€‚ ä»»åŠ¡ä½“12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class ChannelEventRunnable implements Runnable &#123; @Override public void run() &#123; // æ£€æµ‹é€šé“çŠ¶æ€ï¼Œå¦‚æœæ˜¯è¯·æ±‚æˆ–å“åº”æ¶ˆæ¯ï¼Œ é‚£ä¹ˆstate = RECEIVED if (state == ChannelState.RECEIVED) &#123; try &#123; // å°† channel å’Œ message ä¼ é€’ç»™ ChannelHandler å¯¹è±¡ç”¨äºåç»­çš„è°ƒç”¨ã€‚ handler.received(channel, message); &#125; catch (Exception e) &#123; logger.warn(\"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel + \", message is \" + message, e); &#125; // å…¶å®ƒé€šé“çŠ¶æ€ &#125; else &#123; switch (state) &#123; // è¿æ¥äº‹ä»¶ case CONNECTED: try &#123; handler.connected(channel); &#125; catch (Exception e) &#123; logger.warn(\"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel, e); &#125; break; // æ–­å¼€è¿æ¥äº‹ä»¶ case DISCONNECTED: try &#123; handler.disconnected(channel); &#125; catch (Exception e) &#123; logger.warn(\"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel, e); &#125; break; // å‘é€æ¶ˆæ¯ case SENT: try &#123; handler.sent(channel, message); &#125; catch (Exception e) &#123; logger.warn(\"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel + \", message is \" + message, e); &#125; // å¼‚å¸¸å¤„ç† case CAUGHT: try &#123; handler.caught(channel, exception); &#125; catch (Exception e) &#123; logger.warn(\"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel + \", message is: \" + message + \", exception is \" + exception, e); &#125; break; default: logger.warn(\"unknown state: \" + state + \", message is \" + message); &#125; &#125; &#125; /** * é€šé“çŠ¶æ€ */ public enum ChannelState &#123; /** * CONNECTED - è¿æ¥ */ CONNECTED, /** * DISCONNECTED - æ–­å¼€è¿æ¥ */ DISCONNECTED, /** * SENT - å‘é€æ¶ˆæ¯ */ SENT, /** * RECEIVED - æ¥æ”¶è¯·æ±‚/å“åº”æ¶ˆæ¯ */ RECEIVED, /** * CAUGHT - å¼‚å¸¸ */ CAUGHT &#125;&#125; è¯¥ä»»åŠ¡ä½“åŠŸèƒ½å’Œä½œç”¨å¦‚ä¸‹ï¼š 1 è¯·æ±‚å’Œå“åº”æ¶ˆæ¯å‡ºç°é¢‘ç‡æ¯”å…¶ä»–ç±»å‹æ¶ˆæ¯é«˜ï¼Œå› æ­¤è¿™é‡Œå¯¹æ¶ˆæ¯ç±»å‹è¿›è¡Œäº†é’ˆå¯¹æ€§åˆ¤æ–­ï¼Œä¾¿äºæå‰å¤„ç†ã€‚2 ChannelEventRunnable ä»…æ˜¯ä¸€ä¸ªä¸­è½¬ç«™ï¼Œå®ƒçš„ run æ–¹æ³•ä¸­å¹¶ä¸åŒ…å«å…·ä½“çš„è°ƒç”¨é€»è¾‘ï¼Œåªæ˜¯åˆ¤æ–­å¯¹åº”çš„é€šé“çŠ¶æ€ï¼Œç„¶åå°†å‚æ•°ä¼ ç»™è£…é¥°çš„ ChannelHandler å¯¹è±¡è¿›è¡Œé’ˆå¯¹æ€§å¤„ç†ã€‚ è‡³æ­¤ï¼ŒChannelHandlerDelegate çš„å¦ä¸€æ¡ç»§æ‰¿ä½“ç³»åˆ†æå®Œæ¯•ï¼ŒTransport å±‚çš„ä¸»è¦ ChannelHandler åˆ†æåˆ°æ­¤ç»“æŸã€‚ ChannelHandlersChannelHandler çš„å·¥å…·ç±»ï¼Œä¸»è¦æ˜¯å¯¹ä¼ å…¥çš„ ChannelHandler è¿›è¡Œå±‚å±‚åŒ…è£…ï¼Œå…·ä½“æ€ä¹ˆåŒ…è£…çš„æˆ‘ä»¬çœ‹ä¸‹é¢çš„ä»£ç ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839public class ChannelHandlers &#123; /** * å•ä¾‹ */ private static ChannelHandlers INSTANCE = new ChannelHandlers(); protected ChannelHandlers() &#123; &#125; /** * åŒ…è£… * * @param handler * @param url * @return */ public static ChannelHandler wrap(ChannelHandler handler, URL url) &#123; return ChannelHandlers.getInstance().wrapInternal(handler, url); &#125; protected static ChannelHandlers getInstance() &#123; return INSTANCE; &#125; /** * æ— è®ºæ˜¯Clientè¿˜æ˜¯Serverï¼Œåœ¨æ„é€ æ–¹æ³•ä¸­éƒ½ä¼šå°†ä¼ å…¥çš„ChannelHandlerè¿›è¡ŒåŒ…è£…ï¼Œä¸ºè¯¥ ChannelHandler å¢åŠ äº† Dubbo æ¶ˆæ¯æ´¾å‘ã€å¿ƒè·³å¤„ç†ä»¥åŠå¤šæ¶ˆæ¯å¤„ç†çš„åŠŸèƒ½ã€‚ * @param handler * @param url * @return */ protected ChannelHandler wrapInternal(ChannelHandler handler, URL url) &#123; return new MultiMessageHandler( // å¤šæ¶ˆæ¯å¤„ç† new HeartbeatHandler( // å¿ƒè·³å¤„ç† ExtensionLoader.getExtensionLoader(Dispatcher.class) .getAdaptiveExtension() .dispatch(handler, url) // è¿”å›çš„æ˜¯ä¸€ä¸ª ChannelHandlerDelegate ç±»å‹çš„å¯¹è±¡ï¼Œé»˜è®¤æ˜¯ AllChannelHandlerï¼Œç¡®å®šäº†å…·ä½“çš„çº¿ç¨‹æ¨¡å‹ ) ); &#125;&#125; å¾ˆå®¹æ˜“å‘ç°ï¼ŒåŒ…è£…å™¨å…¶å®å°±æ˜¯å‰æ–‡ä»‹ç»çš„ ChannelHandlerDelegate ç±»å‹çš„ ChannelHandlerã€‚è¯¥åŒ…è£…é€»è¾‘æ— è®ºåœ¨ Client ç«¯è¿˜æ˜¯ Server ç«¯éƒ½ä¼šä½¿ç”¨ï¼Œä¹Ÿå°±æ„å‘³ç€ä¸Šå±‚ä¼ å…¥çš„ ChannelHandler ä¼šå¢åŠ å¾ˆå¤šçš„é€»è¾‘ï¼Œå³æ”¯æŒå¤šæ¶ˆæ¯å¤„ç†ã€å¿ƒè·³å¤„ç†ä»¥åŠæ”¯æŒ Dubbo çº¿ç¨‹æ¨¡å‹æœºåˆ¶ã€‚æˆ‘ä»¬åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­è¿˜ä¼šå†æ¬¡ä»‹ç»ï¼Œè¿™é‡Œå…ˆä»¥ netty4 å®ç°çš„ç½‘ç»œé€šä¿¡ç®€å•è¯´æ˜ã€‚ NettyServer123456public class NettyServer extends AbstractServer implements Server &#123; public NettyServer(URL url, ChannelHandler handler) throws RemotingException &#123; // ChannelHandlers.wrapæ–¹æ³•ï¼Œç”¨æ¥åŒ…è£… ChannelHandlerï¼Œå®ç°Dubbo çº¿ç¨‹æ¨¡å‹ç­‰åŠŸèƒ½ super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME))); &#125;&#125; NettyClient123456public class NettyClient extends AbstractClient &#123; public NettyClient(final URL url, final ChannelHandler handler) throws RemotingException &#123; // wrapChannelHandleræ–¹æ³•ï¼Œç”¨æ¥åŒ…è£… ChannelHandlerï¼Œå®ç°Dubbo çº¿ç¨‹æ¨¡å‹ç­‰åŠŸèƒ½ super(url, wrapChannelHandler(url, handler)); &#125;&#125; ç¼–è§£ç å…³äº Codec2 æ‰©å±•æ¥å£å·²ç»åœ¨ è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ ä¸­è¿›è¡Œäº†ä»‹ç»ï¼Œä¸‹é¢ä»‹ç»åœ¨ Transport å±‚ç›¸å…³çš„å®ç°å’Œæ‰©å±•ã€‚ ç¼–è§£ç å·¥å…·ç±» CodecSupport1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class CodecSupport &#123; private static final Logger logger = LoggerFactory.getLogger(CodecSupport.class); /** * åºåˆ—åŒ–å¯¹è±¡é›†åˆ * key: åºåˆ—åŒ–ç±»å‹ç¼–å· &#123;@link Serialization#getContentTypeId()&#125; * value: åºåˆ—åŒ–å¯¹è±¡ï¼Œå¦‚ï¼š Hessian2Serialization */ private static Map&lt;Byte, Serialization&gt; ID_SERIALIZATION_MAP = new HashMap&lt;Byte, Serialization&gt;(); /** * åºåˆ—åŒ–åé›†åˆ * key: åºåˆ—åŒ–ç±»å‹ç¼–å· &#123;@link Serialization#getContentTypeId()&#125; * value: åºåˆ—åŒ–æ‹“å±•åï¼Œå¦‚ï¼šhessian2 */ private static Map&lt;Byte, String&gt; ID_SERIALIZATIONNAME_MAP = new HashMap&lt;Byte, String&gt;(); static &#123; // åŸºäº Dubbo SPIï¼Œè·å– Serialization çš„æ‰©å±•ååˆ—è¡¨ Set&lt;String&gt; supportedExtensions = ExtensionLoader.getExtensionLoader(Serialization.class).getSupportedExtensions(); for (String name : supportedExtensions) &#123; // æ ¹æ®æ‰©å±•åè·å–å¯¹åº”çš„æ‰©å±•å®ç° Serialization serialization = ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(name); // å†…å®¹ç±»å‹ç¼–å· byte idByte = serialization.getContentTypeId(); if (ID_SERIALIZATION_MAP.containsKey(idByte)) &#123; logger.error(\"Serialization extension \" + serialization.getClass().getName() + \" has duplicate id to Serialization extension \" + ID_SERIALIZATION_MAP.get(idByte).getClass().getName() + \", ignore this Serialization extension\"); continue; &#125; // ä»¥å†…å®¹ç¼–å·ä½œä¸º key,åˆ†åˆ«ç¼“å­˜åºåˆ—åŒ–æ‰©å±•å®ç°å’Œæ‰©å±•å®ç°å ID_SERIALIZATION_MAP.put(idByte, serialization); ID_SERIALIZATIONNAME_MAP.put(idByte, name); &#125; &#125; private CodecSupport() &#123; &#125; /** * ä»ç¼“å­˜ä¸­ï¼Œæ ¹æ®åºåˆ—åŒ–å·æŸ¥æ‰¾Serializationå¯¹è±¡ * * @param id * @return */ public static Serialization getSerializationById(Byte id) &#123; return ID_SERIALIZATION_MAP.get(id); &#125; /** * é€šè¿‡URLæ ¹æ®SPIæœºåˆ¶æŸ¥æ‰¾Serializationå¯¹è±¡ï¼Œé»˜è®¤ä½¿ç”¨ hessian2 * * @param url * @return */ public static Serialization getSerialization(URL url) &#123; return ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(url.getParameter(Constants.SERIALIZATION_KEY, Constants.DEFAULT_REMOTING_SERIALIZATION)); &#125; /** * æŸ¥æ‰¾Serializationå¯¹è±¡ * * @param url * @param id * @return * @throws IOException */ public static Serialization getSerialization(URL url, Byte id) throws IOException &#123; Serialization serialization = getSerializationById(id); // åºåˆ—åŒ–æ‰©å±•å String serializationName = url.getParameter(Constants.SERIALIZATION_KEY, Constants.DEFAULT_REMOTING_SERIALIZATION); // å‡ºäºå®‰å…¨çš„ç›®çš„ï¼Œé’ˆå¯¹ JDK ç±»å‹çš„åºåˆ—åŒ–æ–¹å¼ï¼Œæ£€æŸ¥è¿æ¥åˆ°æœåŠ¡å™¨çš„ URL å’Œå®é™…ä¼ è¾“çš„æ•°æ®åè®®æ˜¯å¦ä¸€è‡´ã€‚ if (serialization == null || ((id == 3 || id == 7 || id == 4) &amp;&amp; !(serializationName.equals(ID_SERIALIZATIONNAME_MAP.get(id))))) &#123; throw new IOException(\"Unexpected serialization id:\" + id + \" received from network, please check if the peer send the right id.\"); &#125; return serialization; &#125; /** * è·å–ååºåˆ—åŒ–å¯¹åº”çš„ ObjectInput * * @param url * @param is * @param proto * @return * @throws IOException */ public static ObjectInput deserialize(URL url, InputStream is, byte proto) throws IOException &#123; Serialization s = getSerialization(url, proto); return s.deserialize(url, is); &#125;&#125; ä¸Šé¢ä»£ç å·²ç»è¯¦ç»†æ³¨é‡Šï¼Œæ•´ä¸ªé€»è¾‘åˆ†ä¸ºä¸¤ç‚¹ï¼ŒDubbo åº”ç”¨å¯åŠ¨æ—¶ç¼“å­˜åºåˆ—åŒ–å¹¶æä¾›è·å–åºåˆ—åŒ–çš„æ–¹æ³•ã€‚ å…³äºåºåˆ—åŒ–åœ¨ä¹‹å‰çš„æ–‡ç« ä¸­å·²ç»è¯¦ç»†ä»‹ç»è¿‡ï¼Œè¿™é‡Œå°±ä¸å†é‡å¤è¯´æ˜ã€‚ ç¼–è§£ç é€‚é…å™¨123456789101112131415161718192021222324252627282930313233343536373839public class CodecAdapter implements Codec2 &#123; /** * è¢«é€‚é…çš„å¯¹è±¡ */ private Codec codec; /** * é€šè¿‡æ„é€ æ–¹æ³•è®¾ç½®è¢«é€‚é…çš„å¯¹è±¡ * * @param codec */ public CodecAdapter(Codec codec) &#123; Assert.notNull(codec, \"codec == null\"); this.codec = codec; &#125; @Override public void encode(Channel channel, ChannelBuffer buffer, Object message) throws IOException &#123; UnsafeByteArrayOutputStream os = new UnsafeByteArrayOutputStream(1024); codec.encode(channel, os, message); buffer.writeBytes(os.toByteArray()); &#125; @Override public Object decode(Channel channel, ChannelBuffer buffer) throws IOException &#123; byte[] bytes = new byte[buffer.readableBytes()]; int savedReaderIndex = buffer.readerIndex(); buffer.readBytes(bytes); UnsafeByteArrayInputStream is = new UnsafeByteArrayInputStream(bytes); Object result = codec.decode(channel, is); buffer.readerIndex(savedReaderIndex + is.position()); return result == Codec.NEED_MORE_INPUT ? DecodeResult.NEED_MORE_INPUT : result; &#125; public Codec getCodec() &#123; return codec; &#125;&#125; CodecAdapter ä½¿ç”¨å¯¹è±¡é€‚é…æ¨¡å¼å®Œæˆå¯¹ Codec ç±»å‹çš„é€‚é…å·¥ä½œï¼Œå³å°† Codec é€‚é…æˆ Codec2 ã€‚å…³äºé€‚é…å™¨æ¨¡å¼å¯ä»¥å‚è€ƒ é€‚é…å™¨æ¨¡å¼ ã€‚ ç¼–è§£ç ç»§æ‰¿å…³ç³»ç¼–è§£ç  Codec2 çš„ç»§æ‰¿å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ç»§æ‰¿å…³ç³»ä¸­åŒ…å«äº†å„å±‚çš„ç¼–è§£ç å®ç°ï¼Œæœ¬ç¯‡æ–‡ç« åªä»‹ç» Transport å±‚ç›¸å…³çš„å®ç°ï¼Œå…¶å®ƒå±‚ç›¸å…³çš„å®ç°ä¼šåœ¨å¯¹åº”çš„å±‚è¿›è¡Œä»‹ç»ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒExchange å±‚çš„ç¼–è§£ç å®ç°ä¾èµ–äº† Transport å±‚çš„ç¼–è§£ç å®ç°ï¼ŒProtocol å±‚åˆä¾èµ–äº† Exchange å±‚çš„ç¼–è§£ç å®ç°ã€‚å¯ä»¥å‘ç°ï¼Œç¼–è§£ç å™¨çš„å®ç°é€šè¿‡ç»§æ‰¿çš„æ–¹å¼ä»¥è·å¾—æ›´å¤šçš„åŠŸèƒ½ï¼Œæ¯ä¸ªç¼–ç å™¨å®ç°ç±»ç¼–è§£ç æ¶ˆæ¯çš„é€»è¾‘éƒ½ä¸ä¸€æ ·ã€‚ AbstractCodec1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public abstract class AbstractCodec implements Codec2 &#123; private static final Logger logger = LoggerFactory.getLogger(AbstractCodec.class); /** * é™æ€æ–¹æ³•ï¼Œæ ¡éªŒæ¶ˆæ¯é•¿åº¦ * * @param channel * @param size * @throws IOException */ protected static void checkPayload(Channel channel, long size) throws IOException &#123; // 8M int payload = Constants.DEFAULT_PAYLOAD; if (channel != null &amp;&amp; channel.getUrl() != null) &#123; // è·å–é…ç½®å…è®¸æœ€å¤§çš„æ¶ˆæ¯å¤§å°ï¼Œé»˜è®¤ ä¸º 8 * 1024 * 1024; 8M payload = channel.getUrl().getParameter(Constants.PAYLOAD_KEY, Constants.DEFAULT_PAYLOAD); &#125; // è¶…è¿‡å…è®¸æœ€å¤§çš„æ¶ˆæ¯å¤§å°ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ if (payload &gt; 0 &amp;&amp; size &gt; payload) &#123; ExceedPayloadLimitException e = new ExceedPayloadLimitException(\"Data length too large: \" + size + \", max payload: \" + payload + \", channel: \" + channel); logger.error(e); throw e; &#125; &#125; /** * è·å¾—Serializationå¯¹è±¡ * * @param channel * @return */ protected Serialization getSerialization(Channel channel) &#123; return CodecSupport.getSerialization(channel.getUrl()); &#125; /** * æ˜¯å¦ä¸ºå®¢æˆ·ç«¯çš„é€šé“ * * @param channel * @return */ protected boolean isClientSide(Channel channel) &#123; String side = (String) channel.getAttribute(Constants.SIDE_KEY); if (\"client\".equals(side)) &#123; return true; &#125; else if (\"server\".equals(side)) &#123; return false; &#125; else &#123; InetSocketAddress address = channel.getRemoteAddress(); URL url = channel.getUrl(); boolean client = url.getPort() == address.getPort() &amp;&amp; NetUtils.filterLocalHost(url.getIp()).equals( NetUtils.filterLocalHost(address.getAddress() .getHostAddress())); channel.setAttribute(Constants.SIDE_KEY, client ? \"client\" : \"server\"); return client; &#125; &#125; /** * æ˜¯å¦ä¸ºæœåŠ¡ç«¯çš„é€šé“ * * @param channel * @return */ protected boolean isServerSide(Channel channel) &#123; return !isClientSide(channel); &#125;&#125; æ˜¯ Codec2 çš„æŠ½è±¡å®ç°ï¼Œæä¾›äº†å…¬ç”¨çš„ä¸€äº›æ–¹æ³•ï¼Œå¦‚æ ¡éªŒæ¶ˆæ¯é•¿åº¦æ˜¯å¦è¶…è¿‡é˜ˆå€¼ï¼Œæ ¹æ®URLè·å– Serialization æ‰©å±•å®ç°ï¼Œåˆ¤æ–­å½“å‰é€šé“å±äºå®¢æˆ·ç«¯ä¾§è¿˜æ˜¯æœåŠ¡ç«¯ä¾§ã€‚ TransportCodecTransportCodec çš„é€»è¾‘ç®€å•ã€ç²—æš´ï¼Œä½¿ç”¨ Serialize å¯¹æ‰€æœ‰æ¶ˆæ¯ç›´æ¥åºåˆ—åŒ–æˆ–è€…ååºåˆ—åŒ–ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TransportCodec extends AbstractCodec &#123; @Override public void encode(Channel channel, ChannelBuffer buffer, Object message) throws IOException &#123; // å¯¹ ChannelBuffer è¿›è¡Œè£…é¥°è·å¾— Dubbo è¾“å‡ºæµ OutputStream output = new ChannelBufferOutputStream(buffer); // è·å¾—ç”¨äºåºåˆ—åŒ–çš„ObjectOutputå¯¹è±¡ ObjectOutput objectOutput = getSerialization(channel).serialize(channel.getUrl(), output); // å°†æ¶ˆæ¯å†™å…¥ ObjectOutput encodeData(channel, objectOutput, message); objectOutput.flushBuffer(); // é‡Šæ”¾ï¼Œkryo çš„ KryoObjectInput å’Œ KryoObjectOutput å®ç°äº† Cleanable æ¥å£ï¼Œéœ€è¦é‡Šæ”¾èµ„æºã€‚ if (objectOutput instanceof Cleanable) &#123; ((Cleanable) objectOutput).cleanup(); &#125; &#125; @Override public Object decode(Channel channel, ChannelBuffer buffer) throws IOException &#123; // å¯¹ ChannelBuffer è¿›è¡Œè£…é¥°è·å¾— Dubbo è¾“å…¥æµ InputStream input = new ChannelBufferInputStream(buffer); // è·å¾—ç”¨äºååºåˆ—çš„ ObjectInput å¯¹è±¡ ObjectInput objectInput = getSerialization(channel).deserialize(channel.getUrl(), input); // ä» ObjectInput è¯»å–æ¶ˆæ¯å¹¶ååºåˆ—åŒ–ä¸º å¯¹è±¡ Object object = decodeData(channel, objectInput); if (objectInput instanceof Cleanable) &#123; ((Cleanable) objectInput).cleanup(); &#125; return object; &#125; protected void encodeData(Channel channel, ObjectOutput output, Object message) throws IOException &#123; encodeData(output, message); &#125; protected Object decodeData(Channel channel, ObjectInput input) throws IOException &#123; return decodeData(input); &#125; protected void encodeData(ObjectOutput output, Object message) throws IOException &#123; output.writeObject(message); &#125; protected Object decodeData(ObjectInput input) throws IOException &#123; try &#123; return input.readObject(); &#125; catch (ClassNotFoundException e) &#123; throw new IOException(\"ClassNotFoundException: \" + StringUtils.toString(e)); &#125; &#125;&#125; å°ç»“æœ¬ç¯‡æ–‡ç« ç®€å•ä»‹ç»äº† Transport å±‚åŠå…¶å¿…è¦æ€§ï¼Œç„¶åä»ç«¯ç‚¹æŠ½è±¡ç±» AbstractPeerã€AbstractEndpointï¼Œè¯­ä¹‰ç«¯ç‚¹æŠ½è±¡ç±» AbstractServerã€AbstractServerï¼ŒæŠ½è±¡é€šé“ AbstractChannel ä»¥åŠ é€šé“å…³è”çš„ ChannelHandler å¤šæ–¹é¢ä»‹ç»äº† Transport å±‚çš„å®ç°ï¼Œæœ€åä»‹ç»äº†ç¼–è§£ç çš„ç»§æ‰¿ä½“ç³»ã€‚ä¸éš¾å‘ç°ï¼Œä½œä¸ºåº•å±‚çš„ Transportï¼Œæ”¯æŒäº†æ¶ˆæ¯/äº‹ä»¶å‘é€ã€å¤„ç†ã€å“åº”ä»¥åŠç¼–è§£ç ï¼Œæ¶‰åŠçš„æ¥å£å’Œç±»åœ¨åŠŸèƒ½å±‚é¢ä¸Šå·²ç»æ˜¯ä¸€ä¸ªé—­ç¯äº†ã€‚åé¢ä¸¤ç¯‡æ–‡ç« ä¼šå¯¹æœ¬ç¯‡æ–‡ç« çš„æŠ½è±¡è¿›è¡Œå…·ä½“åŒ–ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - Bufferç¼“å†²åŒº","slug":"rpc/Bufferç¼“å†²åŒº","date":"2020-05-17T16:00:00.000Z","updated":"2020-11-21T08:23:29.506Z","comments":false,"path":"posts/e79185fb/","link":"","permalink":"https://gentryhuang.com/posts/e79185fb/","excerpt":"","text":"å‰è¨€æœ¬ç¯‡æ–‡ç« ç»§ç»­è¯´æ˜ Remoting å±‚ä¸­çš„ buffer åŒ…ç›¸å…³æŠ½è±¡åŠå®ç°ã€‚åœ¨åºåˆ—åŒ–å±‚ä¸­è™½ç„¶ä¸ä¼šç›´æ¥å’Œ Buffer ç¼“å†²åŒºäº¤äº’ï¼Œä½†æ˜¯åºåˆ—åŒ–å’Œååºåˆ—åŒ–æ–¹æ³•æ‰€éœ€çš„å‚æ•°åº•å±‚ä¸€èˆ¬éƒ½æ˜¯ Buffer ç¼“å†²åŒºã€‚ æ¦‚è¿°ç¼“å†²åŒºåœ¨NIOæ¡†æ¶ä¸­æ˜¯ä¸€ä¸ªå¿…è¦çš„è§’è‰²ï¼Œåœ¨å„ä¸ª NIO æ¡†æ¶ä¸­éƒ½æœ‰è‡ªå·±çš„ç¼“å†²åŒºå®ç°ã€‚å¦‚ï¼ŒJava NIO çš„ ByteBufferã€Mina çš„ IoBuffer ä»¥åŠ Netty4 çš„ ByteBufç­‰ã€‚Dubbo æŠ½è±¡å‡ºäº† ChannelBuffer æ¥å£ç”¨äºå¯¹åº•å±‚ NIO æ¡†æ¶çš„ç¼“å†²åŒºè¿›è¡Œç»Ÿä¸€ã€‚ç›¸å…³çš„ UML å›¾å¦‚ä¸‹ï¼š Dubbo ä¸ä»…æŠ½è±¡å‡ºäº† ChannelBuffer æ¥å£ï¼Œè¿˜æŠ½è±¡å‡ºäº†å¯¹åº”çš„å·¥å‚ ChannelBufferFactoryã€‚ ChannelBuffer æ¥å£ChannelBuffer æ¥å£çš„è®¾è®¡ä¸ Netty çš„ ByteBuf è®¾è®¡åŸºæœ¬ä¸€è‡´ï¼Œä¹Ÿå®šä¹‰äº† readerIndex å’Œ writeIndex æŒ‡é’ˆã€‚ ä¸‹é¢å¯¹æ–¹æ³•å¤§è‡´å½’ç±»è¯´æ˜ï¼š getBytes()ã€setBytes() æ–¹æ³•ï¼šè¯»/å†™å½“å‰ ChannelBufferï¼Œä½†æ˜¯ä¸ä¼šä¿®æ”¹ readerIndex å’Œ writerIndex æŒ‡é’ˆçš„ä½ç½®ã€‚ readBytes() ã€writeBytes() æ–¹æ³•ï¼šè¯»/å†™å½“å‰ ChannelBufferï¼ŒreadBytes() æ–¹æ³•ä¼šä» readerIndex æŒ‡é’ˆå¼€å§‹è¯»å–æ•°æ®ï¼Œå¹¶ç§»åŠ¨ readerIndex æŒ‡é’ˆï¼›writeBytes() æ–¹æ³•ä¼šä» writerIndex æŒ‡é’ˆä½ç½®å¼€å§‹å†™å…¥æ•°æ®ï¼Œå¹¶ç§»åŠ¨ writerIndex æŒ‡é’ˆã€‚ markReaderIndex()ã€markWriterIndex() æ–¹æ³•ï¼šåˆ†åˆ«è®°å½•å½“å‰ readerIndex æŒ‡é’ˆå’Œ writerIndex æŒ‡é’ˆçš„ä½ç½®ï¼Œä¸€èˆ¬ä¼šå’Œ resetReaderIndex()ã€resetWriterIndex() æ–¹æ³•é…åˆä½¿ç”¨ï¼ŒresetReaderIndex() æ–¹æ³•ç”¨äºå°† readerIndex æŒ‡é’ˆé‡ç½®åˆ°è¢« markedReaderIndex() æ–¹æ³•æ ‡è®°æ—¶çš„ä½ç½®ï¼ŒresetwriterIndex() æ–¹æ³•åŒç†ã€‚ capacity()ã€clear()ã€copy() ç­‰è¾…åŠ©æ–¹æ³•ç”¨æ¥è·å– ChannelBuffer å®¹é‡ä»¥åŠå®ç°æ¸…ç†ã€æ‹·è´æ•°æ®çš„åŠŸèƒ½ã€‚ factory() æ–¹æ³•ï¼šæ˜¯ Dubbo ç‹¬æœ‰çš„æ–¹æ³•ï¼Œè¯¥æ–¹æ³•è¿”å›åˆ›å»º ChannelBuffer çš„å·¥å‚å¯¹è±¡ã€‚ AbstractChannelBufferå®ç°äº† ChannelBuffer æ¥å£çš„å¤§éƒ¨åˆ†æ–¹æ³•ï¼Œä½†æ˜¯åœ¨ AbstractChannelBuffer å®ç°çš„æ–¹æ³•éƒ½æ˜¯é‡è½½çš„æ–¹æ³•ï¼Œå…·ä½“åŠŸèƒ½çš„æ–¹æ³•éœ€è¦å­ç±»å®ç°ã€‚ AbstractChannelBuffer ä¸»è¦ç»´æŠ¤äº†å››ä¸ªæ ¸å¿ƒå±æ€§ï¼š 1234567891011121314151617181920public abstract class AbstractChannelBuffer implements ChannelBuffer &#123; /** * è¯»å–ä½ç½® */ private int readerIndex; /** * å†™å…¥ä½ç½® */ private int writerIndex; /** * æ ‡è®°çš„è¯»å–ä½ç½® */ private int markedReaderIndex; /** * æ ‡è®°çš„å†™å…¥ä½ç½® */ private int markedWriterIndex;&#125; readerIndexï¼šé€šè¿‡ readBytes() æ–¹æ³•åŠå…¶é‡è½½è¯»å–æ•°æ®æ—¶ï¼Œä¼šåç§»è¯¥æŒ‡é’ˆã€‚ writerIndexï¼šé€šè¿‡ writeBytes() æ–¹æ³•åŠå…¶é‡è½½å†™å…¥æ•°æ®çš„æ—¶å€™ï¼Œä¼šåç§»è¯¥æŒ‡é’ˆã€‚ markedReaderIndexï¼šå®ç°è®°å½• readerIndex æŒ‡é’ˆä»¥åŠç”¨äºå›æ»š readerIndex æŒ‡é’ˆçš„åŠŸèƒ½ã€‚ markedWriterIndexï¼šå®ç°è®°å½• writerIndex æŒ‡é’ˆä»¥åŠç”¨äºå›æ»š writerIndex æŒ‡é’ˆçš„åŠŸèƒ½ã€‚ å…¶ä¸­ï¼ŒAbstractChannelBuffer ä¸­è¿˜å®šä¹‰äº†ç”¨äºåŠ¨æ€æ‰©å®¹çš„ ensureWritableBytes æ–¹æ³•ï¼Œç›®å‰åªæœ‰ DynamicChannelBuffer ã€NettyBackedChannelBufferï¼ˆDubbo çš„ Netty3 å’Œ Netty4 ChannelBufferå®ç°ï¼‰å®ç°ã€‚ éœ€è¦æ³¨æ„ï¼ŒAbstractChannelBuffer ä¸­ readBytes() å’Œ writeBytes() æ–¹æ³•çš„å„ä¸ªé‡è½½æœ€ç»ˆä¼šé€šè¿‡ getBytes() æ–¹æ³•å’Œ setBytes() æ–¹æ³•å®ç°æ•°æ®çš„è¯»å†™ï¼Œè¿™äº›æ–¹æ³•éœ€è¦åœ¨ AbstractChannelBuffer çš„å­ç±»ä¸­å®ç°ã€‚ä¸‹é¢ä»¥è¯»å†™ä¸€ä¸ª byte æ•°ç»„ä¸ºä¾‹è¿›è¡Œè¯´æ˜ï¼Œå…¶å®ƒéƒ½ç±»ä¼¼ã€‚ 1234567891011121314151617181920--- AbstractChannelBuffer // ä» buffer ä¸­è¯»å–é•¿åº¦ä¸º length çš„å­—èŠ‚æ”¾åˆ° dstå­—èŠ‚æ•°ç»„ä¸­ @Override public void readBytes(byte[] dst, int dstIndex, int length) &#123; // æ£€æµ‹è¯»å–å­—èŠ‚é•¿åº¦æ˜¯å¦è¶…è¿‡å¯è¯»é•¿åº¦ï¼Œè¶…è¿‡åˆ™æŠ›å‡ºå¼‚å¸¸ checkReadableBytes(length); // å°†readerIndexä¹‹åçš„lengthä¸ªå­—èŠ‚æ•°è¯»å–åˆ°dstæ•°ç»„ä¸­ï¼Œä» dstæ•°ç»„çš„ dstIndex ä½ç½®å¼€å§‹ï¼Œé•¿åº¦ä¸º length getBytes(readerIndex, dst, dstIndex, length); // å°†readerIndexåç§»lengthä¸ªå­—èŠ‚ readerIndex += length; &#125; // å°† src å­—èŠ‚æ•°ç»„ä¸­ [scrIndex-scrIndex+leng] èŒƒå›´æ•°æ®å†™å…¥åˆ° buffer ä¸­ @Override public void writeBytes(byte[] src, int srcIndex, int length) &#123; setBytes(writerIndex, src, srcIndex, length); // å°†writerIndex åç§» lengthä¸ªå­—èŠ‚ writerIndex += length; &#125; ä¸‹é¢ç®€å•ä½¿ç”¨å›¾ç¤ºè¯´æ˜ ChannelBuffer ä¸­çš„å››ä¸ªæ ¸å¿ƒå±æ€§å’Œå®¹é‡ï¼Œå›¾ç‰‡æ¥æº åˆå§‹çŠ¶æ€ å†™å…¥ 5 ä¸ªå­—èŠ‚å è¯»å– 3 ä¸ªå­—èŠ‚å ChannelBufferFactory12345678910111213141516171819202122232425public interface ChannelBufferFactory &#123; /** * è·å–æŒ‡å®šå®¹é‡çš„ ChannelBuffer * @param capacity * @return */ ChannelBuffer getBuffer(int capacity); /** * è·å–æŒ‡å®šåç§»é‡çš„æ•°æ®çš„ ChannelBuffer * @param array * @param offset * @param length * @return */ ChannelBuffer getBuffer(byte[] array, int offset, int length); /** * æ ¹æ® java.nio.ByteBuffer æ•°æ®è·å–ChannelBuffer * @param nioBuffer * @return */ ChannelBuffer getBuffer(ByteBuffer nioBuffer);&#125; ChannelBuffer å·¥å‚ DirectChannelBufferFactory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class DirectChannelBufferFactory implements ChannelBufferFactory &#123; /** * å•ä¾‹ */ private static final DirectChannelBufferFactory INSTANCE = new DirectChannelBufferFactory(); public DirectChannelBufferFactory() &#123; super(); &#125; public static ChannelBufferFactory getInstance() &#123; return INSTANCE; &#125; @Override public ChannelBuffer getBuffer(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException(\"capacity: \" + capacity); &#125; if (capacity == 0) &#123; return ChannelBuffers.EMPTY_BUFFER; &#125; // ä½¿ç”¨ ChannelBuffers å·¥å…·ç±»åˆ›å»º ByteBufferBackedChannelBuffer return ChannelBuffers.directBuffer(capacity); &#125; @Override public ChannelBuffer getBuffer(byte[] array, int offset, int length) &#123; if (array == null) &#123; throw new NullPointerException(\"array\"); &#125; if (offset &lt; 0) &#123; throw new IndexOutOfBoundsException(\"offset: \" + offset); &#125; if (length == 0) &#123; return ChannelBuffers.EMPTY_BUFFER; &#125; if (offset + length &gt; array.length) &#123; throw new IndexOutOfBoundsException(\"length: \" + length); &#125; // è°ƒç”¨ getBuffer æ–¹æ³•ï¼Œä½¿ç”¨ ChannelBuffers å·¥å…·ç±»åˆ›å»º ByteBufferBackedChannelBuffer ChannelBuffer buf = getBuffer(length); // å‘ buf ä¸­å†™å…¥æ•°æ® buf.writeBytes(array, offset, length); return buf; &#125; @Override public ChannelBuffer getBuffer(ByteBuffer nioBuffer) &#123; if (!nioBuffer.isReadOnly() &amp;&amp; nioBuffer.isDirect()) &#123; return ChannelBuffers.wrappedBuffer(nioBuffer); &#125; // è°ƒç”¨ getBuffer æ–¹æ³•ï¼Œä½¿ç”¨ ChannelBuffers å·¥å…·ç±»åˆ›å»º ByteBufferBackedChannelBuffer ChannelBuffer buf = getBuffer(nioBuffer.remaining()); int pos = nioBuffer.position(); // å‘bufä¸­å†™å…¥æ•°æ® buf.writeBytes(nioBuffer); nioBuffer.position(pos); return buf; &#125;&#125; å®ç° ChannelBufferFactory æ¥å£ï¼Œåˆ›å»º ByteBufferBackedChannelBuffer çš„å·¥å‚ç±»ã€‚ HeapChannelBufferFactory12345678910111213141516171819202122232425262728293031323334353637383940public class HeapChannelBufferFactory implements ChannelBufferFactory &#123; /** * å•ä¾‹ */ private static final HeapChannelBufferFactory INSTANCE = new HeapChannelBufferFactory(); public HeapChannelBufferFactory() &#123; super(); &#125; public static ChannelBufferFactory getInstance() &#123; return INSTANCE; &#125; //----------- é€šè¿‡ ChannelBuffers å·¥å…·ç±»åˆ›å»º HeapChannelBuffer å¯¹è±¡ ------/ @Override public ChannelBuffer getBuffer(int capacity) &#123; return ChannelBuffers.buffer(capacity); &#125; @Override public ChannelBuffer getBuffer(byte[] array, int offset, int length) &#123; return ChannelBuffers.wrappedBuffer(array, offset, length); &#125; @Override public ChannelBuffer getBuffer(ByteBuffer nioBuffer) &#123; if (nioBuffer.hasArray()) &#123; return ChannelBuffers.wrappedBuffer(nioBuffer); &#125; ChannelBuffer buf = getBuffer(nioBuffer.remaining()); int pos = nioBuffer.position(); buf.writeBytes(nioBuffer); nioBuffer.position(pos); return buf; &#125;&#125; å®ç° ChannelBufferFactory æ¥å£ï¼Œåˆ›å»º HeapChannelBufferFactory çš„å·¥å‚ã€‚ NettyBackedChannelBufferFactory12345678910111213141516171819202122232425262728293031323334353637public class NettyBackedChannelBufferFactory implements ChannelBufferFactory &#123; /** * å•ä¾‹ */ private static final NettyBackedChannelBufferFactory INSTANCE = new NettyBackedChannelBufferFactory(); public static ChannelBufferFactory getInstance() &#123; return INSTANCE; &#125; @Override public ChannelBuffer getBuffer(int capacity) &#123; // ä½¿ç”¨ Netty çš„ ChannelBuffers æ–¹æ³•åˆ›å»º org.jboss.netty.buffer.ChannelBuffer return new NettyBackedChannelBuffer(ChannelBuffers.dynamicBuffer(capacity)); &#125; @Override public ChannelBuffer getBuffer(byte[] array, int offset, int length) &#123; // åˆ›å»º Netty3 ChannelBuffer å¯¹è±¡ org.jboss.netty.buffer.ChannelBuffer buffer = ChannelBuffers.dynamicBuffer(length); // å†™å…¥æ•°æ® buffer.writeBytes(array, offset, length); // åˆ›å»º NettyBackedChannelBuffer å¯¹è±¡ return new NettyBackedChannelBuffer(buffer); &#125; @Override public ChannelBuffer getBuffer(ByteBuffer nioBuffer) &#123; // 1 ä½¿ç”¨ Netty çš„ ChannelBuffers æ–¹æ³•åˆ›å»º org.jboss.netty.buffer.ChannelBuffer // 2 åˆ›å»º NettyBackedChannelBuffer return new NettyBackedChannelBuffer(ChannelBuffers.wrappedBuffer(nioBuffer)); &#125;&#125; å®ç° ChannelBufferFactory æ¥å£ï¼Œåˆ›å»º NettyBackedChannelBuffer çš„å·¥å‚ã€‚ç›®å‰ Dubbo æ¡†æ¶ä¸­ï¼ŒNetty3 é€šä¿¡æ¡†æ¶åœ¨ä½¿ç”¨è¿™ä¸ªå·¥å‚ï¼ŒNetty4 ä¸å†ä½¿ç”¨å·¥å‚ã€‚ ChannelBuffers123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153import java.nio.ByteBuffer;/** * Buffer å·¥å…·ç±»ï¼Œæä¾›åˆ›å»ºï¼Œæ¯”è¾ƒ ChannelBuffer ç­‰å…¬ç”¨æ–¹æ³• */public final class ChannelBuffers &#123; public static final ChannelBuffer EMPTY_BUFFER = new HeapChannelBuffer(0); private ChannelBuffers() &#123; &#125; //------------------------------ åˆ›å»º DynamicChannelBuffer å¯¹è±¡ -------------------------/ public static ChannelBuffer dynamicBuffer() &#123; // é»˜è®¤å¤§å°ä¸º 256 return dynamicBuffer(256); &#125; public static ChannelBuffer dynamicBuffer(int capacity) &#123; return new DynamicChannelBuffer(capacity); &#125; public static ChannelBuffer dynamicBuffer(int capacity, ChannelBufferFactory factory) &#123; return new DynamicChannelBuffer(capacity, factory); &#125; //----------------------------- åˆ›å»º HeapChannelBuffer å¯¹è±¡ -----------------------------/ public static ChannelBuffer buffer(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException(\"capacity can not be negative\"); &#125; if (capacity == 0) &#123; return EMPTY_BUFFER; &#125; return new HeapChannelBuffer(capacity); &#125; public static ChannelBuffer wrappedBuffer(byte[] array, int offset, int length) &#123; if (array == null) &#123; throw new NullPointerException(\"array == null\"); &#125; byte[] dest = new byte[length]; System.arraycopy(array, offset, dest, 0, length); return wrappedBuffer(dest); &#125; public static ChannelBuffer wrappedBuffer(byte[] array) &#123; if (array == null) &#123; throw new NullPointerException(\"array == null\"); &#125; if (array.length == 0) &#123; return EMPTY_BUFFER; &#125; return new HeapChannelBuffer(array); &#125; public static ChannelBuffer wrappedBuffer(ByteBuffer buffer) &#123; if (!buffer.hasRemaining()) &#123; return EMPTY_BUFFER; &#125; // ByteBuffer ä¸­çš„å­—èŠ‚æ•°ç»„æ˜¯å¦å¯è®¿é—®ï¼Œå¯è®¿é—®å°±åˆ›å»º HeapChannelBuffer if (buffer.hasArray()) &#123; return wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.remaining()); // ä¸å¯è®¿é—®å°± åˆ›å»º ByteBufferBackedChannelBuffer &#125; else &#123; return new ByteBufferBackedChannelBuffer(buffer); &#125; &#125; //--------------------------- åˆ›å»º ByteBufferBackedChannelBuffer å¯¹è±¡ ------------------------/ public static ChannelBuffer directBuffer(int capacity) &#123; if (capacity == 0) &#123; return EMPTY_BUFFER; &#125; ChannelBuffer buffer = new ByteBufferBackedChannelBuffer(ByteBuffer.allocateDirect(capacity)); buffer.clear(); return buffer; &#125; /** * ç”¨äºæ¯”è¾ƒä¸¤ä¸ª ChannelBuffer æ˜¯å¦ç›¸åŒã€‚ * æ³¨æ„è¯¥æ–¹æ³•ä¸èƒ½å®Œå…¨ç¡®å®šä¸¤ä¸ª ChannelBuffer æ˜¯å¦ç›¸ç­‰ï¼Œä½†æ˜¯å¯ä»¥å¿«é€Ÿç¡®å®šä¸¤ä¸ª ChannelBuffer ä¸ç›¸åŒã€‚ * * @param bufferA * @param bufferB * @return */ public static boolean equals(ChannelBuffer bufferA, ChannelBuffer bufferB) &#123; // æ¯”è¾ƒä¸¤ä¸ªChannelBufferçš„å¯è¯»å­—èŠ‚æ•° final int aLen = bufferA.readableBytes(); if (aLen != bufferB.readableBytes()) &#123; return false; &#125; // aLen &amp; 0111ï¼Œæœ€å¤§ä¸º 7 final int byteCount = aLen &amp; 7; // è·å–è¯»å–ç´¢å¼• int aIndex = bufferA.readerIndex(); int bIndex = bufferB.readerIndex(); // æœ€å¤šæ¯”è¾ƒå‰ 7 ä¸ªå­—èŠ‚ for (int i = byteCount; i &gt; 0; i--) &#123; if (bufferA.getByte(aIndex) != bufferB.getByte(bIndex)) &#123; return false; &#125; aIndex++; bIndex++; &#125; return true; &#125; /** * ç”¨äºæ¯”è¾ƒä¸¤ä¸ª ChannelBuffer çš„å¤§å°ï¼Œæ–¹æ³•ä¸­ä¼šé€ä¸ªæ¯”è¾ƒä¸¤ä¸ª ChannelBuffer ä¸­çš„å…¨éƒ¨å¯è¯»å­—èŠ‚ * * @param bufferA * @param bufferB * @return */ public static int compare(ChannelBuffer bufferA, ChannelBuffer bufferB) &#123; final int aLen = bufferA.readableBytes(); final int bLen = bufferB.readableBytes(); final int minLength = Math.min(aLen, bLen); int aIndex = bufferA.readerIndex(); int bIndex = bufferB.readerIndex(); for (int i = minLength; i &gt; 0; i--) &#123; byte va = bufferA.getByte(aIndex); byte vb = bufferB.getByte(bIndex); if (va &gt; vb) &#123; return 1; &#125; else if (va &lt; vb) &#123; return -1; &#125; aIndex++; bIndex++; &#125; return aLen - bLen; &#125;&#125; ChannelBuffers ç”¨æ¥åˆ›å»º ChannelBuffer å’Œ æ¯”è¾ƒ ChannelBuffer ã€‚åˆ›å»ºçš„ ChannelBuffer åŒ…æ‹¬ DynamicChannelBufferã€HeapChannelBufferã€ByteBufferBackedChannelBufferï¼Œä¸åŒ…æ‹¬ NettyBackedChannelBufferï¼ŒNetty 3 çš„ NettyBackedChannelBuffer å¯ç”±å·¥å‚åˆ›å»ºï¼ŒNetty 4 çš„ NettyBackedChannelBuffer æ²¡æœ‰å·¥å‚ï¼Œåœ¨ Dubbo ä¸­ç›´æ¥ä½¿ç”¨æ„é€ æ–¹æ³•åˆ›å»ºã€‚ Buffer å®ç°ç±»å‰é¢ä»‹ç»äº† ChannelBuffer æ¥å£ä»¥åŠå¯¹åº”çš„å·¥å‚ï¼Œå¹¶å¯¹ ChannelBuffers å·¥å…·ç±»è¿›è¡Œäº†ä»‹ç»ï¼Œä¸‹é¢æˆ‘ä»¬æ¥åˆ†æ ChannelBuffer çš„å…·ä½“å®ç°ç±»ã€‚ ByteBufferBackedChannelBuffer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ByteBufferBackedChannelBuffer extends AbstractChannelBuffer &#123; /** * åŸºäº nio çš„ Buffer å®ç°ç±» */ private final ByteBuffer buffer; /** * å®¹é‡ */ private final int capacity; public ByteBufferBackedChannelBuffer(ByteBuffer buffer) &#123; if (buffer == null) &#123; throw new NullPointerException(\"buffer\"); &#125; this.buffer = buffer.slice(); // è®¾ç½®å®¹é‡ capacity = buffer.remaining(); // è®¾ç½® writerIndex writerIndex(capacity); &#125; public ByteBufferBackedChannelBuffer(ByteBufferBackedChannelBuffer buffer) &#123; this.buffer = buffer.buffer; // è®¾ç½®å®¹é‡ capacity = buffer.capacity; // è®¾ç½® writerIndex,readerIndex setIndex(buffer.readerIndex(), buffer.writerIndex()); &#125; /** * åˆ›å»º ChannelBuf å·¥å‚ * @return */ @Override public ChannelBufferFactory factory() &#123; if (buffer.isDirect()) &#123; return DirectChannelBufferFactory.getInstance(); &#125; else &#123; return HeapChannelBufferFactory.getInstance(); &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; ByteBufferBackedChannelBuffer ç»§æ‰¿äº† AbstractChannelBufferï¼Œ æ˜¯åŸºäº Java NIO ä¸­ ByteBuffer çš„ ChannelBuffer å®ç°ç±»ã€‚å…¶ä¸­çš„æ–¹æ³•åŸºæœ¬éƒ½æ˜¯åŸºäº Java NIO çš„ ByteBuffer çš„ API å®ç°çš„ã€‚ä»¥ getBytes() æ–¹æ³•å’Œ setBytes() æ–¹æ³•çš„ä¸€ä¸ªé‡è½½ä¸ºä¾‹ï¼Œè¿›è¡Œè¯´æ˜ï¼š 123456789101112131415161718192021--- ByteBufferBackedChannelBuffer @Override public void getBytes(int index, byte[] dst, int dstIndex, int length) &#123; // ByteBuffer çš„ API ByteBuffer data = buffer.duplicate(); try &#123; data.limit(index + length).position(index); &#125; catch (IllegalArgumentException e) &#123; throw new IndexOutOfBoundsException(); &#125; data.get(dst, dstIndex, length); &#125; @Override public void setBytes(int index, byte[] src, int srcIndex, int length) &#123; // ByteBuffer çš„ API ByteBuffer data = buffer.duplicate(); data.limit(index + length).position(index); data.put(src, srcIndex, length); &#125; ByteBufferBackedChannelBuffer å¯¹åº”çš„ ChannelBufferFactory å®ç°æœ‰ä¸¤ä¸ªï¼ŒDirectChannelBufferFactory å’Œ HeapChannelBufferFactory ã€‚DirectChannelBufferFactory ä¸»è¦ç”¨æ¥åˆ›å»º ByteBufferBackedChannelBuffer å¯¹è±¡çš„ï¼Œå…œåº•æ—¶æ‰ä¼šåˆ›å»º HeapChannelBufferï¼›HeapChannelBufferFactory å…œåº•æ—¶ä¼šåˆ›å»º ByteBufferBackedChannelBuffer å¯¹è±¡ã€‚ HeapChannelBuffer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class HeapChannelBuffer extends AbstractChannelBuffer &#123; /** * å­—èŠ‚æ•°ç»„ * * The underlying heap byte array that this buffer is wrapping. */ protected final byte[] array; /** * Creates a new heap buffer with a newly allocated byte array. * * @param length the length of the new byte array */ public HeapChannelBuffer(int length) &#123; this(new byte[length], 0, 0); &#125; /** * Creates a new heap buffer with an existing byte array. * * @param array the byte array to wrap */ public HeapChannelBuffer(byte[] array) &#123; this(array, 0, array.length); &#125; /** * Creates a new heap buffer with an existing byte array. * * @param array the byte array to wrap * @param readerIndex the initial reader index of this buffer * @param writerIndex the initial writer index of this buffer */ protected HeapChannelBuffer(byte[] array, int readerIndex, int writerIndex) &#123; if (array == null) &#123; throw new NullPointerException(\"array\"); &#125; this.array = array; // è®¾ç½® readerIndex å’Œ writerIndex setIndex(readerIndex, writerIndex); &#125; /** * åˆ›å»º HeapChannelBufferFactory å·¥å‚ * * @return */ @Override public ChannelBufferFactory factory() &#123; return HeapChannelBufferFactory.getInstance(); &#125; // $&#123;çœç•¥å…¶å®ƒæ–¹æ³•&#125;&#125; HeapChannelBuffer æ˜¯åŸºäºå­—èŠ‚æ•°ç»„çš„ ChannelBuffer å®ç°ç±»ï¼Œæ•°æ®çš„å­˜å‚¨éƒ½æ˜¯æ”¾åœ¨ array å­—èŠ‚æ•°ç»„ä¸­ã€‚è¯»å–å’Œå†™å…¥éƒ½æ˜¯è°ƒç”¨ System.arraycopy() æ–¹æ³•å®Œæˆæ“ä½œçš„ã€‚ 12345678--- HeapChannelBufferpublic void setBytes(int index, byte[] src, int srcIndex, int length) &#123; System.arraycopy(src, srcIndex, array, index, length);&#125;public void getBytes(int index, byte[] dst, int dstIndex, int length) &#123; System.arraycopy(array, index, dst, dstIndex, length);&#125; HeapChannelBuffer å¯¹åº”çš„ ChannelBufferFactory å®ç°æ˜¯ HeapChannelBufferFactoryï¼Œå‰é¢å·²ç»ä»‹ç»è¿‡ï¼Œå†…éƒ¨æ˜¯ä½¿ç”¨ ChannelBuffers å·¥å…·ç±»æ¥å®Œæˆåˆ›å»ºä»»åŠ¡ã€‚ DynamicChannelBuffer12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class DynamicChannelBuffer extends AbstractChannelBuffer &#123; /** * ChannelBuffer å·¥å‚ï¼Œç”¨äºåˆ›å»º ChannelBuffer */ private final ChannelBufferFactory factory; /** * è¢«ä¿®é¥°çš„ ChannelBufferï¼Œé»˜è®¤ä¸º HeapChannelBufferã€‚ */ private ChannelBuffer buffer; /** * é»˜è®¤ HeapChannelBufferFactory * * @param estimatedLength */ public DynamicChannelBuffer(int estimatedLength) &#123; this(estimatedLength, HeapChannelBufferFactory.getInstance()); &#125; /** * æ ¹æ®ä¼ å…¥çš„ factory åˆ›å»º ChannelBuffer * @param estimatedLength * @param factory */ public DynamicChannelBuffer(int estimatedLength, ChannelBufferFactory factory) &#123; if (estimatedLength &lt; 0) &#123; throw new IllegalArgumentException(\"estimatedLength: \" + estimatedLength); &#125; if (factory == null) &#123; throw new NullPointerException(\"factory\"); &#125; // è®¾ç½® factory this.factory = factory; // åˆ›å»º buffer buffer = factory.getBuffer(estimatedLength); &#125; @Override public ChannelBufferFactory factory() &#123; return factory; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; DynamicChannelBuffer æ˜¯å…¶ä»– ChannelBuffer çš„è£…é¥°å™¨ï¼Œå¹¶ä¸”å¯ä»¥ä¸ºå…¶ä»– ChannelBuffer åŠ¨æ€æ‰©å±•å®¹é‡ã€‚æ‰©å®¹æ—¶æœºæ˜¯ï¼Œåœ¨æ¯æ¬¡å†™å…¥æ•°æ®ä¹‹å‰ï¼Œéƒ½éœ€è¦è°ƒç”¨è¯¥æ–¹æ³•ç¡®å®šå½“å‰å¯ç”¨ç©ºé—´æ˜¯å¦è¶³å¤Ÿï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨ DynamicChannelBuffer ä¸­è°ƒç”¨çš„ä½ç½®ï¼š DynamicChannelBuffer çš„ ensureWritableBytes æ–¹æ³•ä¼šæ£€æŸ¥åº•å±‚ ChannelBuffer å¯¹è±¡çš„ç©ºé—´æ˜¯å¦éœ€è¦æ‰©å®¹ï¼Œå¦‚æœç©ºé—´ä¸è¶³åˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„ ChannelBufferï¼ˆç©ºé—´æ‰©å¤§ä¸ºåŸæ¥çš„ä¸¤å€ï¼‰ï¼Œç„¶åå°†åŸæ¥ ChannelBuffer ä¸­çš„æ•°æ®æ‹·è´åˆ°æ–° ChannelBuffer ä¸­ï¼Œæœ€åå°† buffer å­—æ®µæŒ‡å‘æ–° ChannelBuffer å¯¹è±¡ä»¥å®Œæˆæ•´ä¸ªæ‰©å®¹æ“ä½œã€‚æ–¹æ³•å…·ä½“é€»è¾‘å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435--- DynamicChannelBuffer @Override public void ensureWritableBytes(int minWritableBytes) &#123; // å‰©ä½™ç©ºé—´å……è¶³ if (minWritableBytes &lt;= writableBytes()) &#123; return; &#125; int newCapacity; // åˆ¤æ–­å½“å‰ ChannelBuffer å®¹é‡å¤§å°æ˜¯å¦ä¸º 0 if (capacity() == 0) &#123; newCapacity = 1; &#125; else &#123; // è·å– ChannelBuffer å®¹é‡å¤§å° newCapacity = capacity(); &#125; // è®¡ç®—é¢„è®¡å®¹é‡å¤§å° int minNewCapacity = writerIndex() + minWritableBytes; // å¦‚æœé¢„è®¡å®¹é‡å¤§äºå½“å‰ ChannelBuffer çš„å®¹é‡å¤§å°ï¼Œåˆ™è¿›è¡Œ 2 å€å®¹é‡æ‰©å®¹ while (newCapacity &lt; minNewCapacity) &#123; newCapacity &lt;&lt;= 1; &#125; // é€šè¿‡å·¥å‚åˆ›å»ºå®¹é‡å¤§å°ä¸º newCapacity çš„ ChannelBuffer ChannelBuffer newBuffer = factory().getBuffer(newCapacity); // å°†åŸæ¥ChannelBuffer ä¸­çš„æ•°æ®æ‹·è´åˆ°æ–°çš„ ChannelBuffer ä¸­ newBuffer.writeBytes(buffer, 0, writerIndex()); // å°† buffer å­—æ®µæŒ‡å‘æ–° ChannelBuffer å¯¹è±¡ buffer = newBuffer; &#125; NettyBackedChannelBufferNettyBackedChannelBuffer æ˜¯åŸºäº Netty ä¸­ ByteBuf çš„ ChannelBuffer å®ç°ç±»ï¼Œå› ä¸º Netty ä¸­çš„ ByteBuf å†…éƒ¨ç»´æŠ¤äº† readerIndex ã€writerIndex ã€ markedReaderIndex ã€markedWriterIndex æŒ‡é’ˆï¼Œå› æ­¤è¯¥å®ç°ç±»æ²¡æœ‰ç»§æ‰¿ AbstractChannelBuffer æŠ½è±¡ç±»ï¼Œè€Œæ˜¯ç›´æ¥å®ç°äº† ChannelBuffer æ¥å£ã€‚NettyBackedChannelBuffer æ“ä½œç¼“å­˜åŒºçš„ä»»åŠ¡éƒ½æ˜¯å§”æ‰˜ç»™ Netty çš„ ByteBuf æ¥å®Œæˆã€‚ ä¸‹é¢æ˜¯ Dubbo çš„ Netty 4 æ¨¡å—ç¼“å†²åŒºæ„é€ æ–¹æ³•ã€‚ 12345678910111213141516171819202122public class NettyBackedChannelBuffer implements ChannelBuffer &#123; /** * Netty çš„ ByteBuf - å­—èŠ‚æ•°å®¹å™¨ */ private ByteBuf buffer; public NettyBackedChannelBuffer(ByteBuf buffer) &#123; Assert.notNull(buffer, \"buffer == null\"); this.buffer = buffer; &#125; @Override public ChannelBufferFactory factory() &#123; return null; &#125; // ---------------------------- è¯¥ç±»çš„å®ç°æ–¹æ³•éƒ½æ˜¯ç›´æ¥è°ƒç”¨ Netty çš„ ByteBuf å¯¹åº”çš„æ–¹æ³• -----------------------/ // $&#123;çœç•¥å…¶å®ƒæ–¹æ³•&#125;&#125; æ³¨æ„ï¼Œè¯¥å®ç°ç±»æ— éœ€å·¥å‚åˆ›å»ºï¼Œå› æ­¤ factory() æ–¹æ³•è¿”å›ä¸º null ã€‚å¯¹äº Netty 3 æ¨¡å—ï¼Œæ˜¯æœ‰å¯¹åº”çš„å·¥å‚çš„ã€‚ JDK Stream å’Œ ChannelBufferDubbo æ¡†æ¶çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–æ˜¯åŸºäº JDK çš„ InputStream å’Œ OutputStream ã€‚ 1234567891011121314151617181920212223242526--- Serialization /** * create serializer * &lt;p&gt; * åˆ›å»ºObjectOutputå¯¹è±¡ï¼Œå®ç°åºåˆ—åŒ–åŠŸèƒ½ï¼Œåºåˆ—åŒ–è¾“å‡ºåˆ° OutputStream * * @param url URL * @param output è¾“å‡ºæµ * @return serializer * @throws IOException */ @Adaptive ObjectOutput serialize(URL url, OutputStream output) throws IOException; /** * create deserializer * &lt;p&gt; * åˆ›å»º ObjectInput å¯¹è±¡ï¼Œå®ç°ååºåˆ—åŒ–ï¼Œä» InputStream ååºåˆ—åŒ– * * @param url URL * @param input è¾“å…¥æµ * @return deserializer * @throws IOException */ @Adaptive ObjectInput deserialize(URL url, InputStream input) throws IOException; ç›´æ¥ä½¿ç”¨ JDK Stream è™½ç„¶å¯è¡Œï¼Œä½†æ˜¯æ•ˆç‡ä¸Šæœ‰å¾…æå‡ã€‚å› æ­¤ï¼Œåœ¨ ChannelBuffer åŸºç¡€ä¸Šï¼ŒDubbo æä¾›äº†ä¸€å¥—è¾“å…¥è¾“å‡ºæµï¼Œå¯¹ ChannelBufer è¿›è¡Œè£…é¥°ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ChannelBufferInputStream12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * å®ç° InputStream æ¥å£ */public class ChannelBufferInputStream extends InputStream &#123; /** * Buffer */ private final ChannelBuffer buffer; /** * å¼€å§‹ä½ç½® */ private final int startIndex; /** * ç»“æŸä½ç½® */ private final int endIndex; public ChannelBufferInputStream(ChannelBuffer buffer) &#123; this(buffer, buffer.readableBytes()); &#125; public ChannelBufferInputStream(ChannelBuffer buffer, int length) &#123; if (buffer == null) &#123; throw new NullPointerException(\"buffer\"); &#125; if (length &lt; 0) &#123; throw new IllegalArgumentException(\"length: \" + length); &#125; if (length &gt; buffer.readableBytes()) &#123; throw new IndexOutOfBoundsException(); &#125; // è®¾ç½® ChannelBuffer this.buffer = buffer; // è®¾ç½® å¼€å§‹ä½ç½® ä¸º ChannelBuffer çš„è¯»å–ç´¢å¼•ä½ç½® startIndex = buffer.readerIndex(); // è®¾ç½® ç»“æŸä½ç½® endIndex = startIndex + length; // æ ‡è®° è¯»å–ç´¢å¼•ä½ç½® buffer.markReaderIndex(); &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; ChannelBufferInputStream åº•å±‚è£…é¥°äº†ä¸€ä¸ª ChannelBufferï¼Œå…¶å®ç° InputStream æ¥å£çš„ readXxx() æ–¹æ³•éƒ½æ˜¯ä»è£…é¥°çš„ ChannelBuffer ä¸­è¯»å–æ•°æ®ã€‚ChannelBufferInputStream ä¸­è¿˜ç»´æŠ¤äº†ä¸€ä¸ª startIndex å’Œä¸€ä¸ª endIndex å±æ€§ï¼Œç”¨æ¥è®°å½•è¯»å–æ•°æ®çš„èµ·æ­¢ä½ç½®ã€‚ ChannelBufferOutputStream1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class ChannelBufferOutputStream extends OutputStream &#123; /** * è¢«è£…é¥°çš„ ChannelBuffer */ private final ChannelBuffer buffer; /** * å¼€å§‹ä½ç½® */ private final int startIndex; public ChannelBufferOutputStream(ChannelBuffer buffer) &#123; if (buffer == null) &#123; throw new NullPointerException(\"buffer\"); &#125; // è®¾ç½® ChannelBuffer this.buffer = buffer; // è®¾ç½® å¼€å§‹ä½ç½® ä¸º ChannelBuffer çš„å†™å…¥ç´¢å¼•ä½ç½® startIndex = buffer.writerIndex(); &#125; /** * è·å–è£…é¥°çš„ ChannelBuffer * * @return */ public ChannelBuffer buffer() &#123; return buffer; &#125; /** * è·å–å†™å…¥å­—èŠ‚æ•° * * @return */ public int writtenBytes() &#123; return buffer.writerIndex() - startIndex; &#125; //------------ å†™å…¥æ•°æ®éƒ½æ˜¯å§”æ‰˜ç»™è¢«è£…é¥°çš„ ChannelBuffer -------------/ @Override public void write(byte[] b, int off, int len) throws IOException &#123; if (len == 0) &#123; return; &#125; buffer.writeBytes(b, off, len); &#125; @Override public void write(byte[] b) throws IOException &#123; buffer.writeBytes(b); &#125; @Override public void write(int b) throws IOException &#123; buffer.writeByte((byte) b); &#125;&#125; ChannelBufferOutputStream åº•å±‚è£…é¥°äº†ä¸€ä¸ª ChannelBufferï¼Œå…¶å®ç° OutputStream æ¥å£çš„ writeXxx() æ–¹æ³•éƒ½å‘è¢«è£…é¥°çš„ ChannelBuffer ä¸­å†™å…¥æ•°æ®ã€‚ChannelBufferInputStream ä¸­è¿˜ç»´æŠ¤äº†ä¸€ä¸ª startIndex å±æ€§ï¼Œç”¨æ¥è®°å½•æœ€åˆçš„å†™å…¥æ•°æ®çš„ä½ç½®ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« ä»‹ç»äº† Remoting å±‚ä¸­çš„ buffer åŒ…ç›¸å…³æŠ½è±¡åŠå®ç°ã€‚å…ˆæ˜¯ä»‹ç» ChannelBuffer è¿™ä¸€ç¼“å†²åŒºæŠ½è±¡æ¥å£ï¼Œå¹¶è¯´æ˜äº†å…¶æ ¸å¿ƒæ–¹æ³•å’Œå±æ€§ä»¥åŠå·¥ä½œåŸç†ã€‚æ¥ç€ä»‹ç»äº†å…¶å·¥å‚å’Œå®ç°ç±»ï¼Œå¹¶è¯´æ˜äº†æ¯ä¸ªå®ç°ç±»çš„ç‰¹ç‚¹ã€‚æœ€ååˆ†æäº† ChannelBuffer å’Œ JDK çš„ InputStream/OutputStream çš„è”ç³»ï¼Œç»“åˆ Dubbo ä¸­çš„åºåˆ—åŒ–å±‚è¿›è¡Œäº†è¯´æ˜ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ","slug":"rpc/è¿œç¨‹é€šä¿¡æ¨¡å—æ€»è§ˆ","date":"2020-05-09T16:00:00.000Z","updated":"2020-12-17T01:33:48.593Z","comments":false,"path":"posts/95ab077/","link":"","permalink":"https://gentryhuang.com/posts/95ab077/","excerpt":"","text":"å‰è¨€å‰é¢çš„å‡ ç¯‡æ–‡ç« å¯¹ Dubbo çš„ Serialize å±‚è¿›è¡Œäº†ä»‹ç»ï¼Œå®ƒå±äº Remoting å±‚çš„ä¸€éƒ¨åˆ†ï¼Œç›¸æ¯”è¾ƒåŒå±äº Remoting å±‚çš„ Transport å±‚ å’Œ Exchange å±‚ï¼ŒSerialize å±‚åœ¨å•ç‹¬çš„ä¸€ä¸ªæ¨¡å—ä¸­ï¼ŒTransport å±‚ å’Œ Exchange å±‚åœ¨ dubbo-remoting æ¨¡å—ä¸­ï¼Œ æ¥ä¸‹æ¥æˆ‘ä»¬å¯¹è¯¥æ¨¡å—è¿›è¡Œæ€»ä½“è¯´æ˜ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œæ•´ä¸ª Remoting å±‚å®ç°æ˜¯ Dubbo åè®®çš„å®ç°ï¼Œå¦‚æœé€‰æ‹© RMI åè®®ï¼Œé‚£æ•´ä¸ª Remoting å±‚éƒ½ä¸ä¼šç”¨ä¸Šã€‚ æ¦‚è¿°dubbo-remoting æ¨¡å—æä¾›äº†å¤šç§å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯é€šä¿¡çš„åŠŸèƒ½ï¼Œè¯¥æ¨¡å—å†…éƒ¨å¯ä»¥å†åˆ’åˆ†ä¸º Transport ä¼ è¾“å±‚å’Œ Exchange ä¿¡æ¯äº¤æ¢å±‚ï¼ŒTransport å±‚åªè´Ÿè´£å•å‘æ¶ˆæ¯ä¼ è¾“ï¼Œæ˜¯å¯¹ Mina, Netty ç­‰ç½‘ç»œä¼ è¾“ç»„ä»¶çš„æŠ½è±¡ï¼Œå®ƒä¹Ÿå¯ä»¥æ‰©å±• UDP ä¼ è¾“ï¼Œè€Œ Exchange å±‚æ˜¯åœ¨ä¼ è¾“å±‚ä¹‹ä¸Šå°è£…äº† Request-Response è¯­ä¹‰ã€‚ dubbo-remoting æ¨¡å—ç»“æ„å¦‚ä¸‹ï¼š Dubbo æ¡†æ¶å¹¶æ²¡æœ‰è‡ªå·±å®ç°ä¸€å¥—å®Œæ•´çš„ç½‘ç»œåº“ï¼Œè€Œæ˜¯ä½¿ç”¨ç¬¬ä¸‰æ–¹å¼€æºç½‘ç»œåº“ã€‚dubbo-remoting-api å­æ¨¡å—ä¸­å®šä¹‰äº†è¿œç¨‹é€šä¿¡çš„æŠ½è±¡æ¦‚å¿µï¼Œå…·ä½“é€šä¿¡åŠŸèƒ½éœ€è¦ dubbo-remoting-* æ¨¡å—æ¥å®ç°ï¼Œå®ƒä»¬ä¾èµ–ç¬¬ä¸‰æ–¹ NIO åº“å®ç° dubbo-remoting-api æ¨¡å—ã€‚å¦‚ dubbo-remoting-netty æ¨¡å—ä¾èµ– Netty 3 å®ç° Dubbo çš„è¿œç¨‹é€šä¿¡ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œdubbo-remoting-zookeeper æ¨¡å—æ˜¯å®ç°æ³¨å†Œä¸­å¿ƒåŠŸèƒ½çš„æ¨¡å—ã€‚ è¿œç¨‹é€šä¿¡çš„æŠ½è±¡dubbo-remoting-api æ¨¡å—æ˜¯å¯¹è¿œç¨‹é€šä¿¡çš„æŠ½è±¡ï¼Œç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸‹é¢å¯¹å„ä¸ªåŒ…è¿›è¡Œç®€å•è¯´æ˜ï¼š buffer åŒ…å®šä¹‰äº†ç¼“å†²åŒºç›¸å…³çš„æ¥å£ã€æŠ½è±¡ç±»ä»¥åŠå®ç°ã€‚ç¼“å­˜åŒºå¯¹äºé€šä¿¡æ¡†æ¶æ˜¯ä¸€ä¸ªä¸å¯æˆ–ç¼ºçš„åŠŸèƒ½ï¼Œå‡ ä¹æ¯ä¸ªé€šä¿¡æ¡†æ¶éƒ½æœ‰è‡ªå·±çš„ç¼“å­˜åŒºå®ç°ã€‚Dubbo ä¸­çš„è¯¥åŒ…æ˜¯å¯¹å„ä¸ªé€šä¿¡æ¡†æ¶çš„ç¼“å­˜åŒºè¿›è¡Œäº†ç»Ÿä¸€çš„æŠ½è±¡ï¼ŒåŒæ—¶å®ç°äº†ä¸€äº›åŸºç¡€èƒ½åŠ›ã€‚ exchange åŒ…å»ºç«‹Request-Responseæ¨¡å‹ï¼Œå°è£…è¯·æ±‚å“åº”æ¨¡å¼ï¼Œä»¥ Request, Response ä¸ºä¸­å¿ƒã€‚ telnet åŒ…Dubbo æ”¯æŒé€šè¿‡ telnet å‘½ä»¤è¿›è¡ŒæœåŠ¡æ²»ç†ã€‚ transport åŒ…å°†ç½‘ç»œä¼ è¾“æŠ½è±¡ä¸ºç»Ÿä¸€æ¥å£ï¼Œå±è”½äº†ä¸åŒç½‘ç»œåº“çš„å·®å¼‚ï¼Œåªè´Ÿè´£æŠ½è±¡å•å‘æ¶ˆæ¯çš„ä¼ è¾“ï¼Œä»¥ Message ä¸ºä¸­å¿ƒã€‚å³è¯·æ±‚æ¶ˆæ¯ç”± Client ç«¯å‘å‡ºï¼ŒServer ç«¯æ¥æ”¶ï¼›å“åº”æ¶ˆæ¯ç”± Server ç«¯å‘å‡ºï¼ŒClientç«¯æ¥æ”¶ã€‚ å…¶å®ƒæ¥å£é¡¶å±‚æ¥å£æ”¾åˆ°äº† remoting åŒ…ä¸‹ï¼Œè¿™äº›æ¥å£æ˜¯ Dubbo Remoting çš„æ ¸å¿ƒæ¥å£ã€‚ è¿œç¨‹é€šä¿¡æŠ½è±¡ç›¸å…³UMLå›¾å¦‚ä¸‹ï¼š ç«¯ç‚¹ Endpoint12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public interface Endpoint &#123; /** * å…³è”çš„ URL ä¿¡æ¯ * * @return url */ URL getUrl(); /** * åº•å±‚ Channel å…³è”çš„ ChannelHandler * * @return channel handler */ ChannelHandler getChannelHandler(); /** * è·å–æœ¬åœ°åœ°å€ * * @return local address. */ InetSocketAddress getLocalAddress(); /** * å‘é€æ¶ˆæ¯ * * @param message * @throws RemotingException */ void send(Object message) throws RemotingException; /** * å‘é€æ¶ˆæ¯ * * @param message * @param sent true: ä¼šç­‰å¾…æ¶ˆæ¯å‘å‡ºï¼Œæ¶ˆæ¯å‘é€å¤±è´¥ä¼šæŠ›å‡ºå¼‚å¸¸ï¼› false: ä¸ç­‰å¾…æ¶ˆæ¯å‘å‡ºï¼Œå°†æ¶ˆæ¯æ”¾å…¥IOé˜Ÿåˆ—ï¼Œå³å¯è¿”å› */ void send(Object message, boolean sent) throws RemotingException; /** * å…³é—­åº•å±‚Channel */ void close(); /** * ä¼˜é›…å…³é—­åº•å±‚Channel */ void close(int timeout); /** * å¼€å§‹å…³é—­ */ void startClose(); /** * æ£€æµ‹åº•å±‚Channelæ˜¯å¦å·²ç»å…³é—­ * * @return closed */ boolean isClosed();&#125; Dubbo ä¸­æŠ½è±¡äº†ç«¯ç‚¹ï¼ˆEndpoint)çš„æ¦‚å¿µï¼Œé€šè¿‡ ip + port èƒ½å¤Ÿå”¯ä¸€ç¡®å®šä¸€ä¸ªç«¯ç‚¹ï¼Œä¸¤ä¸ªç«¯ç‚¹ä¹‹é—´å¯ä»¥å»ºç«‹ TCP è¿æ¥ï¼Œç”¨äºåŒå‘ä¼ è¾“æ•°æ®ã€‚Dubbo å°† Endpoint ä¹‹é—´çš„ TCP è¿æ¥æŠ½è±¡ä¸ºé€šé“ï¼ˆChannelï¼‰ï¼Œå°†å‘èµ·è¯·æ±‚çš„ Endpoint æŠ½è±¡ä¸ºå®¢æˆ·ç«¯ï¼ˆClientï¼‰ï¼Œå°†æ¥æ”¶è¯·æ±‚çš„ Endpoint æŠ½è±¡ä¸ºæœåŠ¡ç«¯ï¼ˆServerï¼‰ã€‚æœ¬è´¨ä¸Š Client å’Œ Server éƒ½æ˜¯ä¸€ä¸ªç«¯ç‚¹ã€‚ é€šé“ Channel12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public interface Channel extends Endpoint &#123; /** * è·å–è¿œç¨‹åœ°å€ (æ³¨æ„ï¼Œçˆ¶ç±»ä¸­æ˜¯è·å–æœ¬åœ°åœ°å€) * * @return remote address. */ InetSocketAddress getRemoteAddress(); /** * æ˜¯å¦å·²ç»é“¾æ¥ * * @return connected */ boolean isConnected(); //------------- Channel ä¸­å±æ€§ç›¸å…³æ¥å£ï¼Œå¯ä»¥å¯¹Channel ä¸­å±æ€§è¿›è¡Œæ“ä½œ -----------------/ /** * has attribute. * * @param key key. * @return has or has not. */ boolean hasAttribute(String key); /** * get attribute. * * @param key key. * @return value. */ Object getAttribute(String key); /** * set attribute. * * @param key key. * @param value value. */ void setAttribute(String key, Object value); /** * remove attribute. * * @param key key. */ void removeAttribute(String key);&#125; Channel æ˜¯å¯¹ä¸¤ä¸ª Endpoint è¿æ¥çš„æŠ½è±¡ï¼Œæ¶ˆæ¯å‘é€ç«¯ä¼šå¾€ Channel å†™å…¥æ¶ˆæ¯ï¼Œè€Œæ¥æ”¶ç«¯ä¼šä» Channel è¯»å–æ¶ˆæ¯ã€‚ Channel æ¥å£ç»§æ‰¿äº† Endpoint æ¥å£ï¼Œä¹Ÿå…·å¤‡å¼€å…³ Channel ä»¥åŠå‘é€æ•°æ®çš„èƒ½åŠ›ã€‚æ­¤å¤–ï¼ŒChannel æ”¯æŒé™„åŠ é”®å€¼å¯¹å±æ€§ã€‚Dubbo çš„ Channel å’Œ Netty ä¸­çš„ Channel ä¸€è‡´ï¼Œæ˜¯é€šä¿¡çš„è½½ä½“ï¼ŒDubbo çš„ Channel çš„å·¥ä½œæœ€ç»ˆæ˜¯è¦å§”æ‰˜ç»™åº•å±‚ NIO è¿æ¥å®Œæˆï¼Œå¦‚ Netty çš„ Channel æ¥å®Œæˆçš„ ã€‚ é€šé“å¤„ç†å™¨ ChannelHandler1234567891011121314151617181920212223242526272829303132333435363738394041@SPIpublic interface ChannelHandler &#123; /** * å¤„ç† Channel çš„è¿æ¥å»ºç«‹äº‹ä»¶ - Channel å·²ç»è¢«åˆ›å»º * * @param channel channel. */ void connected(Channel channel) throws RemotingException; /** * å¤„ç† Channel çš„è¿æ¥æ–­å¼€äº‹ä»¶ - Channel å·²ç»è¢«æ–­å¼€ * * @param channel channel. */ void disconnected(Channel channel) throws RemotingException; /** * å¤„ç†å‘é€çš„æ•°æ® - æ¶ˆæ¯è¢«å‘é€ * * @param channel channel. * @param message message. */ void sent(Channel channel, Object message) throws RemotingException; /** * å¤„ç†è¯»å–åˆ°çš„æ•°æ® - æ¶ˆæ¯è¢«æ¥æ”¶ * * @param channel channel. * @param message message. */ void received(Channel channel, Object message) throws RemotingException; /** * å¤„ç†æ•è·åˆ°çš„å¼‚å¸¸ * * @param channel channel. * @param exception exception. */ void caught(Channel channel, Throwable exception) throws RemotingException;&#125; ChannelHandler æ˜¯æ³¨å†Œåœ¨ Channel ä¸Šçš„æ¶ˆæ¯å¤„ç†å™¨ï¼Œå’Œ Netty çš„ ChannelHandler ä¸€è‡´ï¼Œè´Ÿè´£ Channel ä¸­çš„é€»è¾‘å¤„ç†ï¼Œå¦‚è¿æ¥ã€æ–­å¼€ã€å‘é€æ¶ˆæ¯ã€æ”¶åˆ°æ¶ˆæ¯å’Œå‡ºç°å¼‚å¸¸ç­‰ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼ŒChannelHandler è¢« @SPIæ³¨è§£æ ‡æ³¨ï¼Œè¡¨ç¤ºæ˜¯ä¸€ä¸ª Dubbo æ‰©å±•ç‚¹ã€‚ChannelHandler ä¸­å®šä¹‰äº† 5 ä¸ªæ–¹æ³•ï¼Œå¯¹åº”ç€å®ƒçš„ 5 ç§çŠ¶æ€ï¼š connected - Channel å·²ç»è¢«åˆ›å»º disconnected - Channel å·²ç»è¢«æ–­å¼€ sent - æ¶ˆæ¯è¢«å‘é€ received - æ¶ˆæ¯è¢«æ¥æ”¶ caught - æ•è·åˆ°å¼‚å¸¸ Dubbo ä¸­æä¾›äº†å¤§é‡çš„ ChannelHandler å»æ‰¿è½½ç‰¹æ€§å’Œæ‰©å±•ï¼Œè¿™äº› Handler æœ€ç»ˆä¼šå’Œåº•å±‚é€šä¿¡æ¡†æ¶è¿›è¡Œå…³è”ï¼Œå¦‚ Nettyã€Mina ç­‰ã€‚ä¸€æ¬¡å®Œæ•´çš„ RPC è°ƒç”¨è´¯ç©¿äº†ä¸€ç³»åˆ—çš„ ChannelHandlerï¼Œå¦‚æœç›´æ¥æŒ‚è½½åˆ° Netty è¿™æ ·çš„åº•å±‚é€šä¿¡æ¡†æ¶ï¼Œå› ä¸ºæ•´ä¸ªè°ƒç”¨é“¾è·¯æ¯”è¾ƒé•¿ï¼Œéœ€è¦è§¦å‘å¤§é‡é“¾å¼æŸ¥æ‰¾å’Œäº‹ä»¶ï¼Œä¸ä»…æ•ˆç‡ä½è€Œä¸”æ¶ˆè€—èµ„æºã€‚å› æ­¤ï¼ŒDubbo æ¡†æ¶å†…éƒ¨ä½¿ç”¨äº†å¤§é‡çš„ ChannelHandler ç»„æˆé“¾å¼ç»“æ„ï¼ˆç±»ä¼¼è¿‡æ»¤å™¨Filteré“¾ï¼‰ï¼Œæ ¹æ® ChannelHandler çš„ç‰¹æ€§ä¾æ¬¡å¤„ç†å…·ä½“çš„é€»è¾‘ï¼ŒDubbo è¿™ç§å°†å¤šä¸ª ChannelHandler èšåˆæˆä¸€ä¸ª ChannelHandler ä½¿ç”¨çš„æ˜¯è£…é¥°è€…æ¨¡å¼ï¼Œåœ¨åé¢çš„å…·ä½“å®ç°ä¸­å¯ä»¥çœ‹åˆ°å¤§é‡è£…é¥°è€…æ¨¡å¼çš„ä½¿ç”¨ã€‚ è¯­ä¹‰ç«¯ç‚¹Dubbo ä¸­æŠ½è±¡äº†ç«¯ç‚¹ Endpoint çš„æ¦‚å¿µï¼Œå°†å‘èµ·è¯·æ±‚çš„ Endpoint æŠ½è±¡ä¸ºå®¢æˆ·ç«¯ï¼ˆClientï¼‰ï¼Œå°†æ¥æ”¶è¯·æ±‚çš„ Endpoint æŠ½è±¡ä¸ºæœåŠ¡ç«¯ï¼ˆServerï¼‰ï¼ŒClient å’Œ Server æœ¬èº«éƒ½æ˜¯ Endpointï¼Œåªä¸è¿‡åœ¨è¯­ä¹‰ä¸ŠåŒºåˆ†äº†è¯·æ±‚å’Œå“åº”çš„èŒè´£ï¼Œä¸¤è€…éƒ½å…·å¤‡å‘é€æ¶ˆæ¯çš„èƒ½åŠ›ï¼Œæ‰€ä»¥éƒ½ç»§æ‰¿äº† Endpoint æ¥å£ã€‚UML å›¾å¦‚ä¸‹ï¼š å®¢æˆ·ç«¯ Client1234567891011121314151617public interface Client extends Endpoint, Channel, Resetable &#123; /** * é‡è¿ * * @throws RemotingException */ void reconnect() throws RemotingException; /** * é‡ç½® * * @param parameters */ @Deprecated void reset(com.alibaba.dubbo.common.Parameters parameters);&#125; æœåŠ¡ç«¯ Server123456789101112131415161718192021222324252627282930313233public interface Server extends Endpoint, Resetable &#123; /** * æ˜¯å¦ç»‘å®šæœ¬åœ°ç«¯å£ï¼Œå³æ˜¯å¦å¯åŠ¨æˆåŠŸï¼Œå¯è¿æ¥ã€æ¥æ”¶æ¶ˆæ¯ * * @return bound */ boolean isBound(); /** * è·å–è¿æ¥ä¸ŠæœåŠ¡çš„é€šé“åˆ—è¡¨ã€‚ å¤šä¸ªClient å¯ä»¥è¿æ¥åŒä¸€ä¸ªServer * * @return channels */ Collection&lt;Channel&gt; getChannels(); /** * æ ¹æ®åœ°å€è·å–è¿æ¥ä¸ŠæœåŠ¡çš„é€šé“ * * @param remoteAddress * @return channel */ Channel getChannel(InetSocketAddress remoteAddress); /** * é‡ç½®ï¼Œå·²åºŸå¼ƒ * * @param parameters */ @Deprecated void reset(com.alibaba.dubbo.common.Parameters parameters);&#125; Client å’Œ Server çš„ä¸»è¦åŒºåˆ«æ˜¯ Client åªèƒ½å…³è”ä¸€ä¸ª Channelï¼Œè€Œ Server å¯ä»¥æ¥æ”¶å¤šä¸ª Client å‘èµ·çš„ Channel è¿æ¥ã€‚ ç½‘ç»œä¼ è¾“ Transporterç”±è¿œç¨‹é€šä¿¡æŠ½è±¡ç›¸å…³UMLå›¾å¯çŸ¥ï¼Œç½‘ç»œä¼ è¾“ Transporter æ˜¯åœ¨ Client å’Œ Server ä¹‹ä¸Šå°è£…çš„æ¥å£ã€‚ 12345678910111213141516171819202122232425262728@SPI(\"netty\")public interface Transporter &#123; /** * åˆ›å»ºä¸€ä¸ªæœåŠ¡å™¨ã€‚æ ¹æ® 'server'ï¼Œ'transporter' ç¡®å®š Server æ‰©å±•å®ç° * * @param url æœåŠ¡å™¨åœ°å€ * @param handler é€šé“å¤„ç†å™¨ * @return server è¿”å›æœåŠ¡å™¨ * @throws RemotingException * @see com.alibaba.dubbo.remoting.Transporters#bind(URL, ChannelHandler...) */ @Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;) Server bind(URL url, ChannelHandler handler) throws RemotingException; /** * è¿æ¥æœåŠ¡å™¨ï¼Œå³åˆ›å»ºä¸€ä¸ªå®¢æˆ·ç«¯ã€‚æ ¹æ® 'client','transporter' ç¡®å®š Client æ‰©å±•å®ç° * * @param url æœåŠ¡å™¨åœ°å€ * @param handler é€šé“å¤„ç†å™¨ * @return client å®¢æˆ·ç«¯ * @throws RemotingException * @see com.alibaba.dubbo.remoting.Transporters#connect(URL, ChannelHandler...) */ @Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;) Client connect(URL url, ChannelHandler handler) throws RemotingException;&#125; Transporter æ¥å£ä¸Šæ ‡æ³¨ @SPI æ³¨è§£ï¼Œè¡¨ç¤ºå®ƒæ˜¯ä¸€ä¸ªæ‰©å±•ç‚¹ï¼Œé»˜è®¤æ‰©å±•åä¸º netty ï¼Œbind æ–¹æ³• å’Œ connect æ–¹æ³• éƒ½ä½¿ç”¨ @Adaptive æ³¨è§£æ ‡æ³¨ï¼Œè¡¨ç¤ºä¼šç”Ÿæˆè‡ªé€‚åº”æ‰©å±•å®ç°ã€‚ ç½‘ç»œä¼ è¾“é—¨é¢ Transporters1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class Transporters &#123; static &#123; // check duplicate jar package Version.checkDuplicate(Transporters.class); Version.checkDuplicate(RemotingException.class); &#125; private Transporters() &#123; &#125; /** * é™æ€æ–¹æ³•ï¼Œåˆ›å»ºä¸€ä¸ªæœåŠ¡å™¨ * * @param url * @param handler * @return * @throws RemotingException */ public static Server bind(String url, ChannelHandler... handler) throws RemotingException &#123; return bind(URL.valueOf(url), handler); &#125; public static Server bind(URL url, ChannelHandler... handlers) throws RemotingException &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; if (handlers == null || handlers.length == 0) &#123; throw new IllegalArgumentException(\"handlers == null\"); &#125; // åˆ›å»ºhandler ChannelHandler handler; if (handlers.length == 1) &#123; handler = handlers[0]; &#125; else &#123; // å¦‚æœhandlers å…ƒç´ æ•°é‡å¤§äº1ï¼Œåˆ™åˆ›å»ºåˆ†å‘å™¨ ChannelHandlerDispatcherã€åˆ†å‘å™¨ä¼šå¾ªç¯è°ƒç”¨handlersã€‘ handler = new ChannelHandlerDispatcher(handlers); &#125; // è·å–è‡ªé€‚åº” Transporter å®ä¾‹ï¼Œç”±å…·ä½“çš„Transporter æ¥åˆ›å»ºServer ã€‚é»˜è®¤æ˜¯NettyTransporteråˆ›å»ºNettyServer return getTransporter().bind(url, handler); &#125; /** * é™æ€æ–¹æ³•ï¼Œè¿æ¥æœåŠ¡å™¨ï¼Œå³åˆ›å»ºä¸€ä¸ªå®¢æˆ·ç«¯ * * @param url * @param handler * @return * @throws RemotingException */ public static Client connect(String url, ChannelHandler... handler) throws RemotingException &#123; return connect(URL.valueOf(url), handler); &#125; public static Client connect(URL url, ChannelHandler... handlers) throws RemotingException &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; ChannelHandler handler; // æ²¡æœ‰ä¼ å…¥é€šé“å¤„ç†å™¨ ChannelHandlerï¼Œåˆ™ä¼šåˆ›å»ºChannelHandlerAdapter ä½œä¸ºé€šé“å¤„ç†å™¨ if (handlers == null || handlers.length == 0) &#123; handler = new ChannelHandlerAdapter(); &#125; else if (handlers.length == 1) &#123; handler = handlers[0]; &#125; else &#123; // ä¼ å…¥å¤šä¸ª ChanenlHandlerï¼Œåˆ™ä¼šåˆ›å»ºåˆ†å‘å™¨ ChannelHandlerDispatcherã€åˆ†å‘å™¨ä¼šå¾ªç¯è°ƒç”¨handlersã€‘ handler = new ChannelHandlerDispatcher(handlers); &#125; //è·å–è‡ªé€‚åº” Transporter å®ä¾‹ï¼Œç”±å…·ä½“çš„Transporter æ¥åˆ›å»º Client ã€‚é»˜è®¤æ˜¯NettyTransporteråˆ›å»º NettyClient return getTransporter().connect(url, handler); &#125; /** * è·å–è‡ªé€‚åº” Transporter å®ä¾‹ * * @return */ public static Transporter getTransporter() &#123; return ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension(); &#125;&#125; Transporters æ˜¯ä¸€ä¸ªé—¨é¢ç±»ï¼Œå…¶ä¸­å°è£…äº†é€šè¿‡ Dubbo SPI è·å– Transporter å¯¹è±¡ã€ChannelHandler çš„å¤„ç†ã€æœåŠ¡å™¨ Sever çš„åˆ›å»ºä»¥åŠå®¢æˆ·ç«¯ Client çš„åˆ›å»ºã€‚å±äºå¤–è§‚æ¨¡å¼ã€‚ ç¼–è§£ç å™¨Codec2ç›¸æ¯”è¾ƒCodecçš„å˜åŒ–æ˜¯ï¼Œå°†OutputStreamå’ŒInputStreamï¼Œæ›¿æ¢æˆäº†ChannelBufferï¼Œæ›´å¥½çš„ä»¥ ChannelBuffer ä¸ºæ ¸å¿ƒï¼Œä¸å…¶ä»–æ¡†æ¶æ•´åˆã€‚ Codec212345678910111213141516171819202122232425262728293031323334353637383940@SPIpublic interface Codec2 &#123; /** * ç¼–ç  * * @param channel é€šé“ * @param buffer Buffer * @param message æ¶ˆæ¯ * @throws IOException */ @Adaptive(&#123;Constants.CODEC_KEY&#125;) void encode(Channel channel, ChannelBuffer buffer, Object message) throws IOException; /** * è§£ç  * * @param channel é€šé“ * @param buffer Buffer * @return æ¶ˆæ¯ * @throws IOException */ @Adaptive(&#123;Constants.CODEC_KEY&#125;) Object decode(Channel channel, ChannelBuffer buffer) throws IOException; /** * è§£ç è¿‡ç¨‹ä¸­ï¼Œéœ€è¦è§£å†³TCPæ‹†åŒ…ï¼Œç²˜åŒ…çš„åœºæ™¯ã€‚è§£ç ç»“æœå¦‚ä¸‹ï¼š */ enum DecodeResult &#123; /** * éœ€è¦æ›´å¤šè¾“å…¥ */ NEED_MORE_INPUT, /** * å¿½ç•¥ä¸€äº›è¾“å…¥ */ SKIP_SOME_INPUT &#125;&#125; Codec123456789101112131415161718192021222324252627282930313233@Deprecated@SPIpublic interface Codec &#123; /** * Need more input poison. * * @see #decode(Channel, InputStream) */ Object NEED_MORE_INPUT = new Object(); /** * Encode message. * * @param channel channel. * @param output output stream. * @param message message. */ @Adaptive(&#123;Constants.CODEC_KEY&#125;) void encode(Channel channel, OutputStream output, Object message) throws IOException; /** * Decode message. * * @param channel channel. * @param input input stream. * @return message or &lt;code&gt;NEED_MORE_INPUT&lt;/code&gt; poison. * @see #NEED_MORE_INPUT */ @Adaptive(&#123;Constants.CODEC_KEY&#125;) Object decode(Channel channel, InputStream input) throws IOException;&#125; Codec æ˜¯è€çš„ç¼–è§£ç å™¨æ¥å£ï¼Œç›®å‰å·²ç»è¢«Codec2å–ä»£ï¼Œå¯ä»¥é€šè¿‡CodecAdapterå°†Codecé€‚é…æˆCodec2ã€‚ å¯è§£ç æ¥å£ Decodeable12345678public interface Decodeable &#123; /** * è§£ç æ¥å£ * * @throws Exception */ public void decode() throws Exception;&#125; è¯¥æ¥å£åœ¨æ¶ˆæ¯è§£ç çš„è¿‡ç¨‹ä¸­æ‰®æ¼”é‡è¦è§’è‰²ï¼Œæ˜¯å¯¹ Dubbo åè®®ä¸‹çš„è¯·æ±‚å’Œå“åº”æ¶ˆæ¯ä½“è§£ç çš„æ”¯æŒã€‚åœ¨åé¢çš„æ–‡ç« ä¸­ä¼šè¯¦ç»†è¯´æ˜å…¶ä½œç”¨ã€‚ æ´¾å‘å™¨ Dispatcher1234567891011121314151617181920212223242526272829303132/** * ChannelHandlerWrapper (SPI, Singleton, ThreadSafe) * &lt;span&gt;è¯´æ˜ï¼š&lt;/span&gt; * 1 è°ƒåº¦å™¨æ¥å£ï¼Œè¢« @SPI(AllDispatcher.NAME)æ³¨è§£æ ‡æ³¨ï¼Œæ˜¯Dubbo çš„æ‹“å±•ç‚¹ï¼Œé»˜è®¤æ‰©å±•åä¸º 'all' * 2 å¦‚æœäº‹ä»¶å¤„ç†çš„é€»è¾‘èƒ½è¿…é€Ÿå®Œæˆï¼Œå¹¶ä¸”ä¸ä¼šå‘èµ·æ–°çš„ IO è¯·æ±‚ï¼Œæ¯”å¦‚åªæ˜¯åœ¨å†…å­˜ä¸­è®°ä¸ªæ ‡è¯†ï¼Œåˆ™ç›´æ¥åœ¨ IO çº¿ç¨‹ä¸Šå¤„ç†æ›´å¿«ï¼Œå› ä¸ºå‡å°‘äº†çº¿ç¨‹æ± è°ƒåº¦ã€‚ * å¦‚æœäº‹ä»¶å¤„ç†é€»è¾‘è¾ƒæ…¢ï¼Œæˆ–è€…éœ€è¦å‘èµ·æ–°çš„ IO è¯·æ±‚ï¼Œæ¯”å¦‚éœ€è¦æŸ¥è¯¢æ•°æ®åº“ï¼Œåˆ™å¿…é¡»æ´¾å‘åˆ°çº¿ç¨‹æ± ï¼Œå¦åˆ™ IO çº¿ç¨‹é˜»å¡ï¼Œå°†å¯¼è‡´ä¸èƒ½æ¥æ”¶å…¶å®ƒè¯·æ±‚ã€‚ * 3 é€šè¿‡ä¸åŒçš„æ´¾å‘ç­–ç•¥å’Œä¸åŒçš„çº¿ç¨‹æ± é…ç½®çš„ç»„åˆæ¥åº”å¯¹ä¸åŒçš„åœºæ™¯ã€‚æ³¨æ„ï¼Œæ´¾å‘ç­–ç•¥å’Œçº¿ç¨‹æ± çš„è”ç³» * * &lt;span&gt;åœ¨dubbo ä¸­ï¼Œæœ‰å¤šç§Dispatcherçš„å®ç°&lt;/span&gt; * &lt;ul&gt; * &lt;li&gt;all: æ‰€æœ‰æ¶ˆæ¯éƒ½æ´¾å‘åˆ°çº¿ç¨‹æ± ï¼ŒåŒ…æ‹¬è¯·æ±‚ï¼Œå“åº”ï¼Œè¿æ¥äº‹ä»¶ï¼Œæ–­å¼€äº‹ä»¶ï¼Œå¿ƒè·³ç­‰&lt;/li&gt; * &lt;li&gt;direct: æ‰€æœ‰æ¶ˆæ¯éƒ½ä¸æ´¾å‘åˆ°çº¿ç¨‹æ± ï¼Œå…¨éƒ¨åœ¨IOçº¿ç¨‹ä¸Šç›´æ¥æ‰§è¡Œ&lt;/li&gt; * &lt;li&gt;message: åªæœ‰è¯·æ±‚/å“åº”æ¶ˆæ¯æ´¾å‘åˆ°çº¿ç¨‹æ± ï¼Œå…¶ä»–çš„æ¶ˆæ¯ç›´æ¥åœ¨IOçº¿ç¨‹ä¸Šæ‰§è¡Œ&lt;/li&gt; * &lt;li&gt;execution: åªæœ‰è¯·æ±‚æ¶ˆæ¯æ´¾å‘åˆ°çº¿ç¨‹æ± ï¼Œå…¶ä»–çš„æ¶ˆæ¯ç›´æ¥åœ¨IOçº¿ç¨‹ä¸Šæ‰§è¡Œ&lt;/li&gt; * &lt;li&gt;connection: åœ¨IOçº¿ç¨‹ä¸Šï¼Œå°†è¿æ¥/æ–­å¼€äº‹ä»¶æ”¾å…¥é˜Ÿåˆ—ï¼Œæœ‰åºé€ä¸ªæ‰§è¡Œã€‚å…¶ä»–æ¶ˆæ¯æ´¾å‘åˆ°çº¿ç¨‹æ± &lt;/li&gt; * &lt;/ul&gt; * æ³¨æ„ï¼šæ¯ä¸ªDispatcherå®ç°ç±»ï¼Œéƒ½å¯¹åº”ä¸€ä¸ªChannelHandlerå®ç°ç±»ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œä½¿ç”¨AllDispatcherè°ƒåº¦ */@SPI(AllDispatcher.NAME)public interface Dispatcher &#123; /** * æ´¾å‘æ¶ˆæ¯åˆ°çº¿ç¨‹æ± å¤„ç†è¿˜æ˜¯IOçº¿ç¨‹ç›´æ¥å¤„ç† * * @param handler é€šé“å¤„ç† * @param url url * @return channel handler */ @Adaptive(&#123;Constants.DISPATCHER_KEY, \"dispather\", \"channel.handler\"&#125;) ChannelHandler dispatch(ChannelHandler handler, URL url);&#125; Dispatcher ä¸»è¦æ”¯æŒäº† Dubbo çš„çº¿ç¨‹æ¨¡å‹ï¼Œå¯ä»¥åˆ›å»ºä¸åŒçš„ ChannelHandler æ¥å†³å®šæ¶ˆæ¯æ˜¯äº¤ç»™çº¿ç¨‹æ± å¤„ç†è¿˜æ˜¯IOçº¿ç¨‹å¤„ç†ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨ä¸åŒçš„åœºæ™¯ä¸­é€‰æ‹©ä¸åŒçš„æ´¾å‘ç­–ç•¥å®ç°æ¶ˆæ¯æˆ–è€…äº‹ä»¶çš„å¤„ç†ã€‚ å¼‚å¸¸ç±» å°ç»“æœ¬ç¯‡æ–‡ç« ä¸»è¦ä»‹ç»äº† dubbo-remoting-api ä¸­æ ¸å¿ƒæ¥å£ä»¥åŠç±»ï¼Œé‡ç‚¹ä»‹ç»äº† ç«¯ç‚¹ Endpointã€é€šé“ Channelã€é€šé“å¤„ç†å™¨ ChannelHandler ã€ä»¥åŠç¼–è§£ç å™¨ ã€‚åœ¨è¯­ä¹‰ä¸Šå°†ç«¯ç‚¹ Endpoint åŒºåˆ†ä¸º Client å’Œ Serverã€‚æ¥ç€åˆä»‹ç»äº† Server å’Œ Client ä¹‹ä¸Šçš„ ç½‘ç»œä¼ è¾“å±‚Transporter ä»¥åŠå…¶é—¨é¢ç±» Transporters ã€‚ æ€»ç»“èµ·æ¥ï¼Œä¸Šå±‚ä½¿ç”¨æ–¹é€šè¿‡ Transporters é—¨é¢è·å–å…·ä½“çš„ Transporter å®ç°ï¼Œç„¶åé€šè¿‡è¯¥ Transporter åˆ›å»ºç›¸åº”çš„ Server å’Œ Client å®ç°ï¼Œæ¥ç€ Client å’Œ Server ä¹‹é—´å»ºç«‹è¿æ¥å³é€šé“ Channelï¼Œå¹¶ä½¿ç”¨ ChannelHandler å¤„ç† Channelç›¸å…³äº‹ä»¶å’Œæ¶ˆæ¯ï¼Œè¿™ä¸ªè¿‡ç¨‹è¿˜ä¼šæ¶‰åŠåˆ°ç¼–è§£ç çš„å¤„ç†ï¼ŒCodec2 æ­£æ˜¯ç”¨æ¥è§£å†³ç¼–è§£ç é—®é¢˜çš„ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œä¸Šå±‚æŒ‡çš„å…¶å®å°±æ˜¯ä¿¡æ¯äº¤äº’å±‚ Exchange ï¼Œæˆ‘ä»¬ä¼šåœ¨ä¹‹åçš„æ–‡ç« ä¸­ä»‹ç»ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - FSTåºåˆ—åŒ–","slug":"rpc/fståºåˆ—åŒ–","date":"2020-05-04T16:00:00.000Z","updated":"2020-11-07T16:20:28.343Z","comments":false,"path":"posts/cfaae53/","link":"","permalink":"https://gentryhuang.com/posts/cfaae53/","excerpt":"","text":"æ¦‚è¿°åœ¨ åºåˆ—åŒ–æ€»è§ˆ ä¸­ä»‹ç»äº† Dubbo åºåˆ—åŒ–æŠ½è±¡APIç›¸å…³æ¥å£ï¼Œæœ¬ç¯‡æ–‡ç« å°†ä»‹ç» Dubbo çš„ FST åºåˆ—åŒ–å®ç°ã€‚ ç›¸å…³çš„ä»£ç ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š FST å·¥å‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class FstFactory &#123; /** * å•ä¾‹ */ private static final FstFactory factory = new FstFactory(); /** * FST é…ç½®å¯¹è±¡ */ private final FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration(); /** * é™æ€æ–¹æ³•ï¼Œè·å–FSTé»˜è®¤å·¥å‚ * * @return */ public static FstFactory getDefaultFactory() &#123; return factory; &#125; public FstFactory() &#123; // å°†è¦åºåˆ—åŒ–ä¼˜åŒ–çš„ç±» æ³¨å†Œåˆ° FSTConfiguration é…ç½®å¯¹è±¡ä¸­ for (Class clazz : SerializableClassRegistry.getRegisteredClasses()) &#123; conf.registerClass(clazz); &#125; &#125; /** * è·å¾— FSTObjectOutput å¯¹è±¡ï¼Œè¢« FstObjectOutput è°ƒç”¨ * * @param outputStream * @return */ public FSTObjectOutput getObjectOutput(OutputStream outputStream) &#123; return conf.getObjectOutput(outputStream); &#125; /** * è·å¾— FSTObjectInput å¯¹è±¡ï¼Œè¢« FstObjectInput è°ƒç”¨ * * @param inputStream * @return */ public FSTObjectInput getObjectInput(InputStream inputStream) &#123; return conf.getObjectInput(inputStream); &#125;&#125; å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒFST å·¥å‚çš„æ„é€ æ–¹æ³•ä¸­ä¼šå°† SerializableClassRegistry æ³¨å†Œè¡¨ä¸­çš„å¾…åºåˆ—åŒ–ä¼˜åŒ–ç±»ï¼Œæ³¨å†Œåˆ° FSTConfiguration ä¸­ã€‚ FstSerialization1234567891011121314151617181920212223242526public class FstSerialization implements Serialization &#123; @Override public byte getContentTypeId() &#123; return 9; &#125; /** * å†…å®¹ç±»å‹ * @return */ @Override public String getContentType() &#123; return \"x-application/fst\"; &#125; @Override public ObjectOutput serialize(URL url, OutputStream out) throws IOException &#123; return new FstObjectOutput(out); &#125; @Override public ObjectInput deserialize(URL url, InputStream is) throws IOException &#123; return new FstObjectInput(is); &#125;&#125; å®ç° Serialization æ¥å£ï¼ŒFST åºåˆ—åŒ–å®ç°ç±»ï¼Œå°†åºåˆ—åŒ–ä»»åŠ¡äº¤ç»™ FstObjectOutput å¯¹è±¡å®Œæˆï¼Œå°†ååºåˆ—åŒ–ä»»åŠ¡äº¤ç»™ FstObjectInput å¯¹è±¡å®Œæˆã€‚ FstObjectOutputFstObjectOutput å®ç°åºåˆ—åŒ–æŠ½è±¡APIæ¨¡å—çš„ ObjectOutput æ¥å£ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class FstObjectOutput implements ObjectOutput &#123; private FSTObjectOutput output; public FstObjectOutput(OutputStream outputStream) &#123; // é€šè¿‡å·¥å‚åˆ›å»º FSTObjectOutput å¯¹è±¡ output = FstFactory.getDefaultFactory().getObjectOutput(outputStream); &#125; //--------------------- åºåˆ—åŒ–æ–¹æ³•ç›´æ¥å§”æ‰˜ç»™ FSTObjectOutput å¯¹åº”çš„æ–¹æ³• ---------- / @Override public void writeBool(boolean v) throws IOException &#123; output.writeBoolean(v); &#125; @Override public void writeByte(byte v) throws IOException &#123; output.writeByte(v); &#125; @Override public void writeShort(short v) throws IOException &#123; output.writeShort(v); &#125; @Override public void writeInt(int v) throws IOException &#123; output.writeInt(v); &#125; @Override public void writeLong(long v) throws IOException &#123; output.writeLong(v); &#125; @Override public void writeFloat(float v) throws IOException &#123; output.writeFloat(v); &#125; @Override public void writeDouble(double v) throws IOException &#123; output.writeDouble(v); &#125; @Override public void writeBytes(byte[] v) throws IOException &#123; if (v == null) &#123; output.writeInt(-1); &#125; else &#123; writeBytes(v, 0, v.length); &#125; &#125; @Override public void writeBytes(byte[] v, int off, int len) throws IOException &#123; if (v == null) &#123; output.writeInt(-1); &#125; else &#123; output.writeInt(len); output.write(v, off, len); &#125; &#125; @Override public void writeUTF(String v) throws IOException &#123; output.writeUTF(v); &#125; @Override public void writeObject(Object v) throws IOException &#123; output.writeObject(v); &#125; @Override public void flushBuffer() throws IOException &#123; output.flush(); &#125;&#125; FstObjectOutput ä¸­çš„åºåˆ—åŒ–æ–¹æ³•ç›´æ¥å§”æ‰˜ç»™ FSTObjectOutput ä¸­å¯¹åº”çš„æ–¹æ³•ã€‚ FstObjectInputFstObjectInput å®ç°åºåˆ—åŒ–æŠ½è±¡APIæ¨¡å—çš„ ObjectInput æ¥å£ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class FstObjectInput implements ObjectInput &#123; private FSTObjectInput input; public FstObjectInput(InputStream inputStream) &#123; input = FstFactory.getDefaultFactory().getObjectInput(inputStream); &#125; // ----------- æ‰€æœ‰çš„å®ç°æ–¹æ³•å§”æ‰˜ç»™ FSTObjectInput å¯¹åº”çš„æ–¹æ³• ---------------/ @Override public boolean readBool() throws IOException &#123; return input.readBoolean(); &#125; @Override public byte readByte() throws IOException &#123; return input.readByte(); &#125; @Override public short readShort() throws IOException &#123; return input.readShort(); &#125; @Override public int readInt() throws IOException &#123; return input.readInt(); &#125; @Override public long readLong() throws IOException &#123; return input.readLong(); &#125; @Override public float readFloat() throws IOException &#123; return input.readFloat(); &#125; @Override public double readDouble() throws IOException &#123; return input.readDouble(); &#125; @Override public String readUTF() throws IOException &#123; return input.readUTF(); &#125; @Override public Object readObject() throws IOException, ClassNotFoundException &#123; return input.readObject(); &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T readObject(Class&lt;T&gt; clazz) throws IOException, ClassNotFoundException &#123; try &#123; return (T) input.readObject(clazz); &#125; catch (Exception e) &#123; throw new IOException(e); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T readObject(Class&lt;T&gt; clazz, Type type) throws IOException, ClassNotFoundException &#123; try &#123; return (T) input.readObject(clazz); &#125; catch (Exception e) &#123; throw new IOException(e); &#125; &#125; @Override public byte[] readBytes() throws IOException &#123; int len = input.readInt(); if (len &lt; 0) &#123; return null; &#125; else if (len == 0) &#123; return new byte[]&#123;&#125;; &#125; else &#123; byte[] b = new byte[len]; input.readFully(b); return b; &#125; &#125;&#125; æ¯ä¸ªå®ç°æ–¹æ³•ï¼Œç›´æ¥å§”æ‰˜ç»™ FSTObjectInput å¯¹åº”çš„æ–¹æ³•ã€‚ å°ç»“Dubbo çš„ FST åºåˆ—åŒ–æ–¹å¼ç‰¹æ®Šç‚¹åœ¨äºå¯ä»¥æŒ‡å®šè¦åºåˆ—åŒ–ä¼˜åŒ–çš„ç±»ï¼Œç„¶æ³¨å†Œåˆ° FSTConfiguration é…ç½®å¯¹è±¡ä¸­ï¼Œç”¨ä»¥å‘æŒ¥å‡º FST çš„é«˜æ€§èƒ½ã€‚å…¶ä¸­ Kryo åºåˆ—åŒ–æ–¹å¼å’Œ FST ç±»ä¼¼ã€‚å…¶å®ƒæ²¡æœ‰åˆ†æåˆ°çš„åºåˆ—åŒ–æ–¹å¼å¥—è·¯éƒ½æ˜¯ä¸€æ ·çš„ã€‚Dubbo çš„åºåˆ—åŒ–åˆ°æ­¤ç»“æŸã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - Hessianåºåˆ—åŒ–","slug":"rpc/hessianåºåˆ—åŒ–","date":"2020-05-03T16:00:00.000Z","updated":"2020-11-07T16:00:54.930Z","comments":false,"path":"posts/4fd38523/","link":"","permalink":"https://gentryhuang.com/posts/4fd38523/","excerpt":"","text":"æ¦‚è¿°åœ¨ åºåˆ—åŒ–æ€»è§ˆ ä¸­ä»‹ç»äº† Dubbo åºåˆ—åŒ–æŠ½è±¡APIç›¸å…³æ¥å£ï¼Œæœ¬ç¯‡æ–‡ç« å°†ä»‹ç» Dubbo çš„ Hessian åºåˆ—åŒ–å®ç°ï¼Œå®ƒæ˜¯ Dubbo çš„é»˜è®¤åºåˆ—åŒ–å®ç°ã€‚ ç›¸å…³çš„ä»£ç ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š Hessian æœ‰è‡ªå·±çš„åºåˆ—åŒ–å®ç°ï¼ŒDubbo å¯¹ Hessian2 è¿›è¡Œäº†æ”¹è¿›ï¼Œå½¢æˆäº†ä¸€å¥—è‡ªå·±çš„åºåˆ—åŒ–æ–¹å¼ã€‚ Hessian2Serialization123456789101112131415161718192021222324public class Hessian2Serialization implements Serialization &#123; public static final byte ID = 2; @Override public byte getContentTypeId() &#123; return ID; &#125; @Override public String getContentType() &#123; return \"x-application/hessian2\"; &#125; @Override public ObjectOutput serialize(URL url, OutputStream out) throws IOException &#123; return new Hessian2ObjectOutput(out); &#125; @Override public ObjectInput deserialize(URL url, InputStream is) throws IOException &#123; return new Hessian2ObjectInput(is); &#125;&#125; Hessian2Serialization å®ç°å¹¶æ²¡æœ‰ä»€ä¹ˆä¸åŒï¼ŒåŒæ ·æ˜¯ä½¿ç”¨ serialize æ–¹æ³•åˆ›å»º ObjectOutput å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ç±»å‹ä¸º Hessian2ObjectOutputï¼Œè´Ÿè´£åºåˆ—åŒ–å·¥ä½œã€‚ä½¿ç”¨ deserialize æ–¹æ³•åˆ›å»º ObjectInput å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ç±»å‹ä¸º Hessian2ObjectInputï¼Œè´Ÿè´£ååºåˆ—åŒ–å·¥ä½œã€‚ Hessian2ObjectOutputHessian2ObjectOutput å®ç°äº†æŠ½è±¡APIæ¨¡å—ä¸­çš„ ObjectOutput æ¥å£ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Hessian2ObjectOutput implements ObjectOutput &#123; private final Hessian2Output mH2o; public Hessian2ObjectOutput(OutputStream os) &#123; // åˆ›å»º Hessian2Output å¯¹è±¡ mH2o = new Hessian2Output(os); // è®¾ç½®å¯¹åº”çš„å·¥å‚ mH2o.setSerializerFactory(Hessian2SerializerFactory.SERIALIZER_FACTORY); &#125; //---------------- æœ€ç»ˆåºåˆ—åŒ–ä»»åŠ¡éƒ½å§”æ‰˜ç»™ Hessian2Output å¯¹è±¡æ¥å®Œæˆ ------------/ @Override public void writeBool(boolean v) throws IOException &#123; mH2o.writeBoolean(v); &#125; @Override public void writeByte(byte v) throws IOException &#123; mH2o.writeInt(v); &#125; @Override public void writeShort(short v) throws IOException &#123; mH2o.writeInt(v); &#125; @Override public void writeInt(int v) throws IOException &#123; mH2o.writeInt(v); &#125; @Override public void writeLong(long v) throws IOException &#123; mH2o.writeLong(v); &#125; @Override public void writeFloat(float v) throws IOException &#123; mH2o.writeDouble(v); &#125; @Override public void writeDouble(double v) throws IOException &#123; mH2o.writeDouble(v); &#125; @Override public void writeBytes(byte[] b) throws IOException &#123; mH2o.writeBytes(b); &#125; @Override public void writeBytes(byte[] b, int off, int len) throws IOException &#123; mH2o.writeBytes(b, off, len); &#125; @Override public void writeUTF(String v) throws IOException &#123; mH2o.writeString(v); &#125; @Override public void writeObject(Object obj) throws IOException &#123; mH2o.writeObject(obj); &#125; @Override public void flushBuffer() throws IOException &#123; mH2o.flushBuffer(); &#125;&#125; Hessian2ObjectOutput ä¸­å°è£…ä¸€ä¸ª Hessian2Output å¯¹è±¡ï¼Œç”±ä¸Šé¢ä»£ç å¯çŸ¥ï¼ŒHessian2Output å¯¹ java.io.OutputStream è¿›è¡Œäº†å°è£…ï¼Œå¹¶ä¸”åºåˆ—åŒ–å„ç±»æ•°æ®çš„æ–¹æ³•éƒ½ä¼šå§”æ‰˜ç»™ Hessian2Output å¯¹è±¡çš„ç›¸åº”æ–¹æ³•å®Œæˆã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¯¹äºåŸºæœ¬ç±»å‹æ•°æ®çš„åºåˆ—åŒ–ï¼ŒHessian2Output ä½¿ç”¨å­—èŠ‚æ•°ç»„æ¥å¤„ç†çš„ã€‚ 12345678910111213141516171819202122232425262728293031public class Hessian2Output extends AbstractHessianOutput implements Hessian2Constants &#123; public final static int SIZE = 4096; // å­—èŠ‚æ•°ç»„ private final byte[] _buffer = new byte[SIZE]; // the output stream/ protected OutputStream _os; // map of references private IdentityIntMap _refs = new IdentityIntMap(); private boolean _isCloseStreamOnClose; // map of classes private HashMap _classRefs; // map of types private HashMap _typeRefs; private int _offset; private boolean _isStreaming; /** * Creates a new Hessian output stream, initialized with an * underlying output stream. * * @param os the underlying output stream. */ public Hessian2Output(OutputStream os) &#123; _os = os; &#125; // ... çœç•¥å…¶å®ƒä»£ç &#125; Hessian2ObjectInputHessian2ObjectInput å®ç°äº†æŠ½è±¡APIæ¨¡å—ä¸­çš„ ObjectInput æ¥å£ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Hessian2ObjectInput implements ObjectInput &#123; private final Hessian2Input mH2i; public Hessian2ObjectInput(InputStream is) &#123; // åˆ›å»º Hessian2Input å¯¹è±¡ mH2i = new Hessian2Input(is); // è®¾ç½®åºåˆ—åŒ–å·¥å‚ mH2i.setSerializerFactory(Hessian2SerializerFactory.SERIALIZER_FACTORY); &#125; @Override public boolean readBool() throws IOException &#123; return mH2i.readBoolean(); &#125; @Override public byte readByte() throws IOException &#123; return (byte) mH2i.readInt(); &#125; @Override public short readShort() throws IOException &#123; return (short) mH2i.readInt(); &#125; @Override public int readInt() throws IOException &#123; return mH2i.readInt(); &#125; @Override public long readLong() throws IOException &#123; return mH2i.readLong(); &#125; @Override public float readFloat() throws IOException &#123; return (float) mH2i.readDouble(); &#125; @Override public double readDouble() throws IOException &#123; return mH2i.readDouble(); &#125; @Override public byte[] readBytes() throws IOException &#123; return mH2i.readBytes(); &#125; @Override public String readUTF() throws IOException &#123; return mH2i.readString(); &#125; @Override public Object readObject() throws IOException &#123; return mH2i.readObject(); &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T readObject(Class&lt;T&gt; cls) throws IOException, ClassNotFoundException &#123; return (T) mH2i.readObject(cls); &#125; @Override public &lt;T&gt; T readObject(Class&lt;T&gt; cls, Type type) throws IOException, ClassNotFoundException &#123; return readObject(cls); &#125;&#125; Hessian2ObjectInput ä¸­å°è£…ä¸€ä¸ª Hessian2Input å¯¹è±¡ï¼Œç”±ä¸Šé¢ä»£ç å¯çŸ¥ï¼ŒHessian2Input å¯¹ java.io.InputStream è¿›è¡Œäº†å°è£…ï¼Œå¹¶ä¸”å°†æ‰€æœ‰ååºåˆ—åŒ–çš„å®ç°éƒ½å§”æ‰˜ç»™ Hessian2Input å¯¹è±¡ã€‚åŒæ ·çš„ï¼ŒHessian2Input å¯¹åŸºæœ¬æ•°æ®ç±»å‹çš„æ•°æ®è¿›è¡Œååºåˆ—åŒ–æ˜¯è¯»å–å­—èŠ‚æ•°ç»„å†…å®¹ã€‚ å°ç»“Dubbo çš„ Hessian åºåˆ—åŒ–ä¹Ÿæ˜¯åŒæ ·çš„å¥—è·¯ï¼ŒHessian2Serialization è¦è¿›è¡Œåºåˆ—åŒ–æ“ä½œå°±æŠŠä»»åŠ¡äº¤ç»™åˆ›å»ºçš„ Hessian2ObjectOutput å¯¹è±¡å»å®Œæˆï¼Œè¦è¿›è¡Œååºåˆ—åŒ–æ“ä½œå°±æŠŠä»»åŠ¡äº¤ç»™ Hessian2ObjectInput å¯¹è±¡å»å®Œæˆã€‚åªä¸è¿‡ï¼ŒHessian2ObjectOutput å’Œ Hessian2ObjectInput åˆä¼šæŠŠä»»åŠ¡å§”æ‰˜ç»™ Hessianç±»çš„Hessian2Outputå¯¹è±¡å’ŒHessian2Inputå¯¹è±¡å»å®Œæˆã€‚ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­åˆ†æ Dubbo çš„ FST åºåˆ—åŒ–å®ç°ï¼Œå®ƒä»£è¡¨äº†ä¸€ç§ç±»å‹ï¼Œæ”¯æŒå°†é‚£äº›éœ€è¦è¢«åºåˆ—åŒ–çš„ç±»æ³¨å†Œåˆ°dubboç³»ç»Ÿä¸­ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - JDKåºåˆ—åŒ–","slug":"rpc/JDKåºåˆ—åŒ–","date":"2020-05-02T16:00:00.000Z","updated":"2021-01-04T10:57:13.531Z","comments":false,"path":"posts/5898e8ff/","link":"","permalink":"https://gentryhuang.com/posts/5898e8ff/","excerpt":"","text":"æ¦‚è¿°åœ¨ åºåˆ—åŒ–æ€»è§ˆ ä¸­ä»‹ç»äº† Dubbo åºåˆ—åŒ–æŠ½è±¡APIç›¸å…³æ¥å£ï¼Œæœ¬ç¯‡æ–‡ç« å°†ä»‹ç»JDKçš„åºåˆ—åŒ–å®ç°ã€‚ ç›¸å…³çš„ä»£ç ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š JDK åºåˆ—åŒ–æ˜¯åŸºäºJavaåŸç”Ÿçš„åºåˆ—åŒ–å®ç°ï¼Œä»ä¸åŒçš„æ–¹é¢è€ƒè™‘ï¼Œå…·ä½“æœ‰ä¸‰ç§å®ç°æ–¹å¼ï¼š java=com.alibaba.dubbo.common.serialize.java.JavaSerializationcompactedjava=com.alibaba.dubbo.common.serialize.java.CompactedJavaSerializationnativejava=com.alibaba.dubbo.common.serialize.nativejava.NativeJavaSerialization NativeJavaSerialization æ˜¯åŸç”Ÿçš„ Java åºåˆ—åŒ–çš„å®ç°æ–¹å¼ã€‚CompactedJavaSerialization æ˜¯åœ¨åŸç”Ÿçš„ Java åºåˆ—åŒ–çš„åŸºç¡€ä¸Šåšäº†å‹ç¼©ï¼Œå®ç°äº†è‡ªå®šä¹‰çš„ç±»æè¿°ç¬¦çš„å†™å…¥å’Œè¯»å–ï¼Œåœ¨åºåˆ—åŒ–æ—¶åªéœ€å†™å…¥ç±»åè€Œä¸æ˜¯å®Œæ•´çš„ç±»ä¿¡æ¯ï¼Œå¯ä»¥æœ‰æ•ˆå‹ç¼©ä½“ç§¯ã€‚JavaSerialization æ˜¯å¯¹åŸç”Ÿ Java åºåˆ—åŒ–å’Œå‹ç¼©çš„ç»„åˆå®ç°ï¼Œå¹¶ä¸”æ”¯æŒå¯¹ç©ºå­—ç¬¦ä¸²åŠç©ºå¯¹è±¡çš„å¤„ç†ã€‚ä¸‰è€…çš„UMLå›¾å¦‚ä¸‹ï¼š Java åŸç”Ÿåºåˆ—åŒ–NativeJavaSerialization123456789101112131415161718192021222324public class NativeJavaSerialization implements Serialization &#123; public static final String NAME = \"nativejava\"; @Override public byte getContentTypeId() &#123; return 7; &#125; @Override public String getContentType() &#123; return \"x-application/nativejava\"; &#125; @Override public ObjectOutput serialize(URL url, OutputStream output) throws IOException &#123; return new NativeJavaObjectOutput(output); &#125; @Override public ObjectInput deserialize(URL url, InputStream input) throws IOException &#123; return new NativeJavaObjectInput(input); &#125;&#125; åŸºäºåŸç”Ÿçš„Javaåºåˆ—åŒ–å®ç°ï¼Œå³ä½¿ç”¨ java.io.ObjectOutputSteam è¿›è¡Œåºåˆ—åŒ–ï¼Œä½¿ç”¨ java.io.ObjectInputStream è¿›è¡Œååºåˆ—åŒ–ã€‚åœ¨ NativeJavaObjectOutput å’Œ NativeJavaObjectInput ä¼šåˆ†åˆ«å¯¹ä¼ å…¥çš„æµè¿›è¡ŒåŒ…è£…ã€‚ NativeJavaObjectOutputNativeJavaObjectOutput å®ç°äº†æŠ½è±¡APIæ¨¡å—ä¸­çš„ ObjectOutput æ¥å£ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class NativeJavaObjectOutput implements ObjectOutput &#123; /** * javaåŸç”Ÿçš„ è¾“å‡ºæµå¯¹è±¡ */ private final ObjectOutputStream outputStream; public NativeJavaObjectOutput(OutputStream os) throws IOException &#123; this(new ObjectOutputStream(os)); &#125; protected NativeJavaObjectOutput(ObjectOutputStream out) &#123; Assert.notNull(out, \"output == null\"); this.outputStream = out; &#125; protected ObjectOutputStream getObjectOutputStream() &#123; return outputStream; &#125; @Override public void writeObject(Object obj) throws IOException &#123; outputStream.writeObject(obj); &#125; @Override public void writeBool(boolean v) throws IOException &#123; outputStream.writeBoolean(v); &#125; @Override public void writeByte(byte v) throws IOException &#123; outputStream.writeByte(v); &#125; @Override public void writeShort(short v) throws IOException &#123; outputStream.writeShort(v); &#125; @Override public void writeInt(int v) throws IOException &#123; outputStream.writeInt(v); &#125; @Override public void writeLong(long v) throws IOException &#123; outputStream.writeLong(v); &#125; @Override public void writeFloat(float v) throws IOException &#123; outputStream.writeFloat(v); &#125; @Override public void writeDouble(double v) throws IOException &#123; outputStream.writeDouble(v); &#125; @Override public void writeUTF(String v) throws IOException &#123; outputStream.writeUTF(v); &#125; @Override public void writeBytes(byte[] v) throws IOException &#123; if (v == null) &#123; outputStream.writeInt(-1); &#125; else &#123; writeBytes(v, 0, v.length); &#125; &#125; @Override public void writeBytes(byte[] v, int off, int len) throws IOException &#123; if (v == null) &#123; outputStream.writeInt(-1); &#125; else &#123; outputStream.writeInt(len); outputStream.write(v, off, len); &#125; &#125; @Override public void flushBuffer() throws IOException &#123; outputStream.flush(); &#125;&#125; Java åŸç”Ÿçš„åºåˆ—åŒ–ï¼Œæ— è®ºæ˜¯åŸºæœ¬æ•°æ®ç±»å‹è¿˜æ˜¯å¼•ç”¨æ•°æ®ç±»å‹ï¼Œè¿›è¡Œåºåˆ—åŒ–æ—¶éƒ½ç›´æ¥ä½¿ç”¨ java.io.ObjectOutputStream APIæ¥å®Œæˆã€‚ NativeJavaObjectInputNativeJavaObjectInput å®ç°äº†æŠ½è±¡APIæ¨¡å—ä¸­çš„ ObjectInputæ¥å£ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class NativeJavaObjectInput implements ObjectInput &#123; /** * JavaåŸç”Ÿçš„ ObjectInputStream è¾“å…¥æµ */ private final ObjectInputStream inputStream; public NativeJavaObjectInput(InputStream is) throws IOException &#123; this(new ObjectInputStream(is)); &#125; protected NativeJavaObjectInput(ObjectInputStream is) &#123; Assert.notNull(is, \"input == null\"); inputStream = is; &#125; protected ObjectInputStream getObjectInputStream() &#123; return inputStream; &#125; @Override public Object readObject() throws IOException, ClassNotFoundException &#123; return inputStream.readObject(); &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T readObject(Class&lt;T&gt; cls) throws IOException, ClassNotFoundException &#123; return (T) readObject(); &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T readObject(Class&lt;T&gt; cls, Type type) throws IOException, ClassNotFoundException &#123; return (T) readObject(); &#125; @Override public boolean readBool() throws IOException &#123; return inputStream.readBoolean(); &#125; @Override public byte readByte() throws IOException &#123; return inputStream.readByte(); &#125; @Override public short readShort() throws IOException &#123; return inputStream.readShort(); &#125; @Override public int readInt() throws IOException &#123; return inputStream.readInt(); &#125; @Override public long readLong() throws IOException &#123; return inputStream.readLong(); &#125; @Override public float readFloat() throws IOException &#123; return inputStream.readFloat(); &#125; @Override public double readDouble() throws IOException &#123; return inputStream.readDouble(); &#125; @Override public String readUTF() throws IOException &#123; return inputStream.readUTF(); &#125; @Override public byte[] readBytes() throws IOException &#123; int len = inputStream.readInt(); if (len &lt; 0) &#123; return null; &#125; else if (len == 0) &#123; return new byte[]&#123;&#125;; &#125; else &#123; byte[] result = new byte[len]; inputStream.readFully(result); return result; &#125; &#125;&#125; Java åŸç”Ÿçš„ååºåˆ—åŒ–ï¼Œæ— è®ºæ˜¯åŸºæœ¬æ•°æ®ç±»å‹è¿˜æ˜¯å¼•ç”¨æ•°æ®ç±»å‹ï¼Œè¿›è¡Œååºåˆ—åŒ–æ—¶éƒ½ç›´æ¥ä½¿ç”¨ java.io.ObjectInputStream APIæ¥å®Œæˆã€‚ å‹ç¼©èƒ½åŠ›çš„åºåˆ—åŒ–CompactedJava123456789101112131415161718192021222324252627282930public class CompactedJavaSerialization implements Serialization &#123; @Override public byte getContentTypeId() &#123; return 4; &#125; @Override public String getContentType() &#123; return \"x-application/compactedjava\"; &#125; /** * åœ¨åˆ›å»º JavaObjectOutput æ—¶ï¼Œæ ¹æ® compact = true æ—¶ï¼Œä½¿ç”¨ CompactedObjectOutputStream è¾“å‡ºæµ * * @param url URL * @param out * @return * @throws IOException */ @Override public ObjectOutput serialize(URL url, OutputStream out) throws IOException &#123; return new JavaObjectOutput(out, true); &#125; @Override public ObjectInput deserialize(URL url, InputStream is) throws IOException &#123; return new JavaObjectInput(is, true); &#125;&#125; åœ¨åŸç”Ÿçš„ Java åºåˆ—åŒ–çš„åŸºç¡€ä¸Šåšäº†å‹ç¼©ï¼Œå®ç°äº†è‡ªå®šä¹‰çš„ç±»æè¿°ç¬¦çš„å†™å…¥å’Œè¯»å–ï¼Œåœ¨åºåˆ—åŒ–æ—¶åªéœ€å†™å…¥ç±»åè€Œä¸æ˜¯å®Œæ•´çš„ç±»ä¿¡æ¯ï¼Œå¯ä»¥æœ‰æ•ˆå‹ç¼©ä½“ç§¯ã€‚åŠŸèƒ½ç”± CompactedObjectOutputStream å’Œ CompactedObjectInputStream å®ç°ã€‚ CompactedObjectOutputStream1234567891011121314151617public class CompactedObjectOutputStream extends ObjectOutputStream &#123; public CompactedObjectOutputStream(OutputStream out) throws IOException &#123; super(out); &#125; @Override protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException &#123; Class&lt;?&gt; clazz = desc.forClass(); if (clazz.isPrimitive() || clazz.isArray()) &#123; write(0); super.writeClassDescriptor(desc); &#125; else &#123; write(1); writeUTF(desc.getName()); &#125; &#125;&#125; ç»§æ‰¿äº† ObjectOutputStream ç±»ï¼Œé‡å†™äº† writeClassDescriptor æ–¹æ³•ï¼Œå®ç°äº†å¯¹ ClassDescriptor çš„å†™å…¥ã€‚ CompactedObjectInputStream1234567891011121314151617181920212223242526272829303132public class CompactedObjectInputStream extends ObjectInputStream &#123; private ClassLoader mClassLoader; public CompactedObjectInputStream(InputStream in) throws IOException &#123; this(in, Thread.currentThread().getContextClassLoader()); &#125; public CompactedObjectInputStream(InputStream in, ClassLoader cl) throws IOException &#123; super(in); mClassLoader = cl == null ? ClassHelper.getClassLoader() : cl; &#125; @Override protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException &#123; int type = read(); if (type &lt; 0) throw new EOFException(); switch (type) &#123; case 0: return super.readClassDescriptor(); case 1: Class&lt;?&gt; clazz = loadClass(readUTF()); return ObjectStreamClass.lookup(clazz); default: throw new StreamCorruptedException(\"Unexpected class descriptor type: \" + type); &#125; &#125; private Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException &#123; return mClassLoader.loadClass(className); &#125;&#125; ç»§æ‰¿äº† ObjectInputStream ç±»ï¼Œé‡å†™äº† readClassDescriptor æ–¹æ³•ï¼Œå®ç°äº†å¯¹ ClassDescriptor è¯»å–ã€‚ ç»„åˆåŸç”Ÿå’Œå‹ç¼©åºåˆ—åŒ–JavaSerialization12345678910111213141516171819202122public class JavaSerialization implements Serialization &#123; @Override public byte getContentTypeId() &#123; return 3; &#125; @Override public String getContentType() &#123; return \"x-application/java\"; &#125; @Override public ObjectOutput serialize(URL url, OutputStream out) throws IOException &#123; return new JavaObjectOutput(out); &#125; @Override public ObjectInput deserialize(URL url, InputStream is) throws IOException &#123; return new JavaObjectInput(is); &#125;&#125; JavaObjectOutputJavaObjectOutput ç»§æ‰¿äº† Java åŸç”Ÿåºåˆ—åŒ–çš„ NativeJavaObjectOutput ç±»ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class JavaObjectOutput extends NativeJavaObjectOutput &#123; public JavaObjectOutput(OutputStream os) throws IOException &#123; super(new ObjectOutputStream(os)); &#125; /** * æ³¨æ„ compact ä¸ºtrueçš„æƒ…å†µ &#123;@link CompactedJavaSerialization#serialize(URL, OutputStream)&#125; * @param os * @param compact * @throws IOException */ public JavaObjectOutput(OutputStream os, boolean compact) throws IOException &#123; super(compact ? new CompactedObjectOutputStream(os) : new ObjectOutputStream(os)); &#125; /** * å¯¹ç©ºå­—ç¬¦ä¸²çš„å¤„ç† * * @param v * @throws IOException */ @Override public void writeUTF(String v) throws IOException &#123; if (v == null) &#123; getObjectOutputStream().writeInt(-1); &#125; else &#123; getObjectOutputStream().writeInt(v.length()); getObjectOutputStream().writeUTF(v); &#125; &#125; /** * å¯¹ç©ºå¯¹è±¡çš„å¤„ç† * * @param obj * @throws IOException */ @Override public void writeObject(Object obj) throws IOException &#123; if (obj == null) &#123; getObjectOutputStream().writeByte(0); &#125; else &#123; getObjectOutputStream().writeByte(1); getObjectOutputStream().writeObject(obj); &#125; &#125; @Override public void flushBuffer() throws IOException &#123; getObjectOutputStream().flush(); &#125;&#125; JavaObjectOutput æ„é€ æ–¹æ³•å¯ä»¥æ ¹æ® compact å‚æ•°åˆ›å»ºä¸åŒçš„å®ç°åºåˆ—åŒ–åŠŸèƒ½å¯¹è±¡ã€‚ JavaObjectInputJavaObjectInput ç»§æ‰¿äº† Java åŸç”Ÿåºåˆ—åŒ–çš„ NativeJavaObjectInput ç±»ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class JavaObjectInput extends NativeJavaObjectInput &#123; public final static int MAX_BYTE_ARRAY_LENGTH = 8 * 1024 * 1024; public JavaObjectInput(InputStream is) throws IOException &#123; super(new ObjectInputStream(is)); &#125; public JavaObjectInput(InputStream is, boolean compacted) throws IOException &#123; super(compacted ? new CompactedObjectInputStream(is) : new ObjectInputStream(is)); &#125; @Override public byte[] readBytes() throws IOException &#123; int len = getObjectInputStream().readInt(); if (len &lt; 0) return null; if (len == 0) return new byte[0]; if (len &gt; MAX_BYTE_ARRAY_LENGTH) throw new IOException(\"Byte array length too large. \" + len); byte[] b = new byte[len]; getObjectInputStream().readFully(b); return b; &#125; @Override public String readUTF() throws IOException &#123; int len = getObjectInputStream().readInt(); if (len &lt; 0) return null; return getObjectInputStream().readUTF(); &#125; @Override public Object readObject() throws IOException, ClassNotFoundException &#123; byte b = getObjectInputStream().readByte(); if (b == 0) return null; return getObjectInputStream().readObject(); &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T readObject(Class&lt;T&gt; cls) throws IOException, ClassNotFoundException &#123; return (T) readObject(); &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T readObject(Class&lt;T&gt; cls, Type type) throws IOException, ClassNotFoundException &#123; return (T) readObject(); &#125;&#125; JavaObjectOutput æ„é€ æ–¹æ³•å¯ä»¥æ ¹æ® compact å‚æ•°åˆ›å»ºä¸åŒçš„å®ç°ååºåˆ—åŒ–åŠŸèƒ½å¯¹è±¡ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« åŠ å•ä»‹ç»äº† Dubbo åŸç”Ÿçš„ Java åºåˆ—åŒ–å®ç°æ–¹å¼ï¼Œå³ç›´æ¥ä½¿ç”¨ java.io.ObjectOutputSteam è¿›è¡Œåºåˆ—åŒ–ï¼Œä½¿ç”¨ java.io.ObjectInputStream è¿›è¡Œååºåˆ—åŒ–ï¼Œå¹¶æ²¡æœ‰è¿›è¡Œè¿‡å¤šçš„å…¶å®ƒå¤„ç†ï¼Œä¸ä¾èµ–å…¶å®ƒç»„ä»¶ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - åºåˆ—åŒ–æ€»è§ˆ","slug":"rpc/åºåˆ—åŒ–æ€»è§ˆ","date":"2020-05-02T16:00:00.000Z","updated":"2020-12-17T08:41:03.156Z","comments":false,"path":"posts/16132b67/","link":"","permalink":"https://gentryhuang.com/posts/16132b67/","excerpt":"","text":"å‰è¨€Dubbo çš„æœåŠ¡æš´éœ²ã€æœåŠ¡å¼•ç”¨ä»¥åŠæœåŠ¡è°ƒç”¨é™¤äº†éœ€è¦ä¹‹å‰ä»‹ç»çš„é…ç½®ã€ä»£ç†ã€æ³¨å†Œä¸­å¿ƒï¼Œè¿˜éœ€è¦åè®®ã€ç½‘ç»œé€šä¿¡ã€é›†ç¾¤å®¹é”™ã€åºåˆ—åŒ–ç­‰ã€‚å› æ­¤ï¼Œä»æœ¬æ–‡å¼€å§‹ä¼šç”±åº•å‘ä¸Šåˆ†æ Dubbo æ¶æ„ä¸­çš„æ¨¡å—ã€‚ æ¦‚è¿°RPCæ¡†æ¶éœ€è¦ç½‘ç»œé€šä¿¡å®ç°ä¿¡æ¯çš„å‘é€å’Œæ¥æ”¶ï¼Œæ—¢ç„¶æ˜¯ç½‘ç»œé€šä¿¡å°±ä¸€å®šä¼šä½¿ç”¨åˆ°åºåˆ—åŒ–å’Œååºåˆ—åŒ–æŠ€æœ¯ã€‚Dubbo å¯¹åºåˆ—åŒ–çš„å®šä¹‰æ˜¯ï¼Œå°†å¯¹è±¡ï¼ˆåŸºæœ¬æ•°æ®ç±»å‹å’Œå¼•ç”¨ç±»å‹ï¼‰è½¬æˆå­—èŠ‚æµç”¨äºç½‘ç»œä¼ è¾“ï¼›ä»¥åŠå°†å­—èŠ‚æµè½¬ä¸ºå¯¹è±¡ï¼ˆåŸºæœ¬æ•°æ®ç±»å‹å’Œå¼•ç”¨ç±»å‹ï¼‰ï¼Œç”¨äºåœ¨æ”¶åˆ°å­—èŠ‚æµæ•°æ®åè¿›è¡Œè¿˜åŸã€‚åºåˆ—åŒ–å¯¹äºè¿œç¨‹è°ƒç”¨çš„å“åº”é€Ÿåº¦ã€ååé‡ã€ç½‘ç»œå¸¦å®½æ¶ˆè€—ç­‰åŒæ ·ä¹Ÿèµ·ç€è‡³å…³é‡è¦çš„ä½œç”¨ï¼Œæ˜¯æå‡åˆ†å¸ƒå¼ç³»ç»Ÿæ€§èƒ½çš„æœ€å…³é”®å› ç´ ä¹‹ä¸€ã€‚ æèµ·åºåˆ—åŒ–å°±ä¸å¾—ä¸æåˆ°åè®®è¿™ä¸ªæ¦‚å¿µï¼Œä¸¤è€…æ˜¯ä¸åŒçš„ä¸œè¥¿ï¼Œå®ƒä»¬ä¹‹é—´å±äºç»„åˆå…³ç³»ï¼Œåè®®éœ€è¦ç”¨åˆ°åºåˆ—åŒ–æŠ€æœ¯ï¼Œè€Œåºåˆ—åŒ–æŠ€æœ¯å¯ä»¥æœåŠ¡äºä¸åŒçš„åè®®ã€‚åºåˆ—åŒ–å±‚åœ¨ Dubbo çš„æ¶æ„å›¾ä¸­çš„ä½ç½®å¦‚ä¸‹ï¼Œå®ƒå¤„äºæœ€ä½å±‚ï¼Œå±äº Remoting å±‚çš„ä¸€éƒ¨åˆ†ã€‚åœ¨ Dubbo ä¸­è¿˜æœ‰ä¸€ä¸ªå’Œåºåˆ—åŒ–ç›¸å…³çš„æ‰©å±•æ¥å£ Codec2ï¼Œæ˜¯åŸºäºåºåˆ—åŒ–ä¹‹ä¸Šå°è£…çš„ç»„ä»¶ï¼Œä¸»è¦ç”¨äºå®ç°å¯¹æ•°æ®çš„ç¼–ç å’Œè§£ç ï¼Œå³è§£å†³ç²˜åŒ…å’Œæ‹†åŒ…ç­‰é—®é¢˜ï¼Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–åŠŸèƒ½æ˜¯ä½¿ç”¨åºåˆ—åŒ–å±‚æ¥å®Œæˆçš„ã€‚ Dubbo ä¸ºäº†æ”¯æŒå¤šç§åºåˆ—åŒ–ç®—æ³•ï¼Œå•ç‹¬æŠ½è±¡äº† Serialize å±‚ï¼Œå¯¹åº”çš„æ¨¡å—ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š Dubbo åºåˆ—åŒ–æŠ½è±¡ APIdubbo-serialization-api æ¨¡å—ä¸­å®šä¹‰äº† Dubbo åºåˆ—åŒ–å±‚çš„æ ¸å¿ƒæ¥å£ä»¥åŠç±»ï¼Œå…³ç³»å¦‚ä¸‹ï¼š Serialization æ¥å£12345678910111213141516171819202122232425262728293031323334353637383940414243@SPI(\"hessian2\")public interface Serialization &#123; /** * åºåˆ—åŒ–ç±»å‹ç¼–å· * * @return content type id */ byte getContentTypeId(); /** * è·å¾—åºåˆ—åŒ–å¯¹åº”çš„ç±»å‹ï¼Œæ¯ä¸€ç§åºåˆ—åŒ–ç®—æ³•éƒ½å¯¹åº”ä¸€ä¸ªç±»å‹ * * @return content type */ String getContentType(); /** * create serializer * &lt;p&gt; * åˆ›å»ºObjectOutputå¯¹è±¡ï¼Œå®ç°åºåˆ—åŒ–åŠŸèƒ½ï¼Œåºåˆ—åŒ–è¾“å‡ºåˆ° OutputStream * * @param url URL * @param output è¾“å‡ºæµ * @return serializer * @throws IOException */ @Adaptive ObjectOutput serialize(URL url, OutputStream output) throws IOException; /** * create deserializer * &lt;p&gt; * åˆ›å»º ObjectInput å¯¹è±¡ï¼Œå®ç°ååºåˆ—åŒ–ï¼Œä» InputStream ååºåˆ—åŒ– * * @param url URL * @param input è¾“å…¥æµ * @return deserializer * @throws IOException */ @Adaptive ObjectInput deserialize(URL url, InputStream input) throws IOException;&#125; Serialization æ¥å£æ˜¯ä¸€ä¸ªæ‰©å±•ç‚¹ï¼Œé»˜è®¤æ‰©å±•å®ç°æ˜¯ Hessian2Serialization ã€‚å®ƒæ˜¯åºåˆ—åŒ–æœ€æ ¸å¿ƒçš„æ¥å£ï¼Œserializeæ–¹æ³•ç”¨æ¥åˆ›å»ºå®ç°åºåˆ—åŒ–åŠŸèƒ½çš„ ObjectOutput å¯¹è±¡ï¼Œdeserializeæ–¹æ³•ç”¨æ¥åˆ›å»ºå®ç°ååºåˆ—åŒ–åŠŸèƒ½çš„ ObjectInputã€‚ä¸åŒçš„ Serialization æ‰©å±•å®ç°å¯¹åº”ä¸åŒçš„ ObjectOutput å’Œ ObjectInput å¯¹è±¡ï¼Œä½†æ˜¯æœ¬è´¨ä¸Šéƒ½æ˜¯å¯¹ JDKçš„ OutputStream å’Œ InputStream ç±»çš„å°è£…æˆ–æ”¹é€ ï¼ŒDubbo ä¸­ä¸€èˆ¬ä½¿ç”¨å¯¹ ChannelBuffer è£…é¥°çš„æµå¯¹è±¡ã€‚ä¸åŒçš„ Serialization æ‰©å±•å®ç°ä¼šæœ‰æ‰€å·®å¼‚ï¼Œé™¤äº†æ•ˆç‡å¤–è¿˜ä½“ç°åœ¨APIä¸Šï¼Œå¯¹äºå¼•ç”¨ç±»å‹çš„åºåˆ—åŒ–ä¸€èˆ¬æœ€åº•å±‚éƒ½æ˜¯ä½¿ç”¨JDKçš„OutputStream å’Œ InputStreamçš„APIï¼Œä¸Šå±‚å› ä¸åŒç‰¹æ€§çš„ Serialization ä¼šæœ‰ä¸åŒï¼Œå¯¹äºåŸºæœ¬ç±»å‹æ•°æ®çš„åºåˆ—åŒ–æœ‰çš„ Serialization ä¼šä½¿ç”¨è‡ªèº«ç»´æŠ¤çš„å­—èŠ‚æ•°ç»„æ¥å®ç°ï¼Œæœ‰çš„ç›´æ¥ä½¿ç”¨ä¼ å…¥çš„ Stream æµå®ç°ã€‚ Serialization çš„åºåˆ—åŒ–ï¼ˆserializeï¼‰å’Œååºåˆ—åŒ–ï¼ˆdeserializeï¼‰æ–¹æ³•çš„ Stream å‚æ•°ï¼Œåœ¨ä½¿ç”¨çš„æ—¶å€™ä¸€èˆ¬éƒ½æ˜¯ Dubbo è‡ªå®šä¹‰çš„ Stream å¯¹è±¡ï¼Œè¯¥å¯¹è±¡æ˜¯å¯¹ Dubbo ä¸­çš„ ChannelBuffer çš„å°è£…ï¼Œç”¨ä»¥æé«˜æ•ˆç‡å’Œæ€§èƒ½ã€‚å…³äº Dubbo çš„ ChannelBuffer æˆ‘ä»¬ä¼šåœ¨åé¢çš„æ–‡ç« ä¸­è¿›è¡Œè¯´æ˜ï¼Œä¸‹é¢æ˜¯ Dubbo ç›¸å…³ Stream : Dubbo æä¾›äº†å¤šä¸ª Serialization å®ç° ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š DataOutput æ¥å£12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public interface DataOutput &#123; /** * Write boolean. * * @param v value. * @throws IOException */ void writeBool(boolean v) throws IOException; /** * Write byte. * * @param v value. * @throws IOException */ void writeByte(byte v) throws IOException; /** * Write short. * * @param v value. * @throws IOException */ void writeShort(short v) throws IOException; /** * Write integer. * * @param v value. * @throws IOException */ void writeInt(int v) throws IOException; /** * Write long. * * @param v value. * @throws IOException */ void writeLong(long v) throws IOException; /** * Write float. * * @param v value. * @throws IOException */ void writeFloat(float v) throws IOException; /** * Write double. * * @param v value. * @throws IOException */ void writeDouble(double v) throws IOException; /** * Write string. * * @param v value. * @throws IOException */ void writeUTF(String v) throws IOException; /** * Write byte array. * * @param v value. * @throws IOException */ void writeBytes(byte[] v) throws IOException; /** * Write byte array. * * @param v value. * @param off offset. * @param len length. * @throws IOException */ void writeBytes(byte[] v, int off, int len) throws IOException; /** * Flush buffer. * * @throws IOException */ void flushBuffer() throws IOException;&#125; DataOutput æ¥å£ä¸­å®šä¹‰äº†ç”¨äºåºåˆ—åŒ– Java ä¸­å„ç§åŸºæœ¬æ•°æ®ç±»å‹çš„æ–¹æ³•ã€‚ ObjectOutput æ¥å£12345678public interface ObjectOutput extends DataOutput &#123; /** * write object. * * @param obj object. */ void writeObject(Object obj) throws IOException;&#125; ç»§æ‰¿ DataOutput æ¥å£ï¼Œåœ¨DataOutput çš„åŸºç¡€ä¸Šå¢åŠ åºåˆ—åŒ–å¯¹è±¡çš„èƒ½åŠ›ã€‚ InputStream æ¥å£1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public interface DataInput &#123; /** * Read boolean. * * @return boolean. * @throws IOException */ boolean readBool() throws IOException; /** * Read byte. * * @return byte value. * @throws IOException */ byte readByte() throws IOException; /** * Read short integer. * * @return short. * @throws IOException */ short readShort() throws IOException; /** * Read integer. * * @return integer. * @throws IOException */ int readInt() throws IOException; /** * Read long. * * @return long. * @throws IOException */ long readLong() throws IOException; /** * Read float. * * @return float. * @throws IOException */ float readFloat() throws IOException; /** * Read double. * * @return double. * @throws IOException */ double readDouble() throws IOException; /** * Read UTF-8 string. * * @return string. * @throws IOException */ String readUTF() throws IOException; /** * Read byte array. * * @return byte array. * @throws IOException */ byte[] readBytes() throws IOException;&#125; InputStream æ¥å£ä¸­å®šä¹‰äº†ååºåˆ—åŒ– Java ä¸­å„ç§åŒ–åŸºæœ¬ç±»å‹çš„æ•°æ®ã€‚ ObjectInput æ¥å£12345678910111213141516171819202122232425public interface ObjectInput extends DataInput &#123; /** * read object. * * @return object. */ Object readObject() throws IOException, ClassNotFoundException; /** * read object. * * @param cls object type. * @return object. */ &lt;T&gt; T readObject(Class&lt;T&gt; cls) throws IOException, ClassNotFoundException; /** * read object. * * @param cls object type. * @return object. */ &lt;T&gt; T readObject(Class&lt;T&gt; cls, Type type) throws IOException, ClassNotFoundException;&#125; ç»§æ‰¿ DataInput æ¥å£ï¼Œåœ¨DataInput çš„åŸºç¡€ä¸Šå¢åŠ äº†ååºåˆ—åŒ–å¯¹è±¡çš„èƒ½åŠ›ã€‚ Cleanable123public interface Cleanable &#123; void cleanup();&#125; å®Œæˆåºåˆ—åŒ–æˆ–ååºåˆ—åŒ–éœ€è¦åšæ¸…ç†å·¥ä½œï¼Œé€šè¿‡å®ç°è¯¥æ¥å£é‡Šæ”¾èµ„æºï¼Œç›®å‰ Kryo å®ç°ã€‚ åºåˆ—åŒ–ä¼˜åŒ–å™¨SerializationOptimizer æ¥å£12345678910111213/** * ä½¿ç”¨æ–‡ä»¶ä¹Ÿæ˜¯ä¸€ä¸ªé€‰æ‹©ï¼Œè¿™ä¸ªç±»å¯ä»¥æ›¿æ¢ä¸ºé…ç½®æ–‡ä»¶ä¸­çš„å†…å®¹ï¼Œä½†æ˜¯ç±»çš„æ–¹å¼æ›´å®¹æ˜“ç¼–å†™ * This class can be replaced with the contents in config file, but for now I think the class is easier to write */public interface SerializationOptimizer &#123; /** * è¿”å›éœ€è¦ä½¿ç”¨ä¼˜åŒ–çš„ç±»çš„é›†åˆ * * @return */ Collection&lt;Class&gt; getSerializableClasses();&#125; åœ¨Kryoã€FST åºåˆ—åŒ–å®ç°ä¸­ï¼Œæ”¯æŒé…ç½®éœ€è¦ä¼˜åŒ–çš„ç±»ã€‚å¯ä»¥å®ç°è‡ªå®šä¹‰çš„SerializationOptimizerå®ç°ï¼Œé…ç½®éœ€è¦ä¼˜åŒ–çš„ç±»ï¼Œè®©Kryoå’ŒFSTå®Œå…¨å‘æŒ¥å‡ºé«˜æ€§èƒ½ã€‚åºåˆ—åŒ–ä¼˜åŒ–å™¨å¦‚ä¸‹ï¼š 12345678910111213public class SerializationOptimizerImpl implements SerializationOptimizer &#123; public Collection&lt;Class&gt; getSerializableClasses() &#123; List&lt;Class&gt; classes = new LinkedList&lt;Class&gt;(); classes.add(BidRequest.class); classes.add(BidResponse.class); classes.add(Device.class); classes.add(Geo.class); classes.add(Impression.class); classes.add(SeatBid.class); return classes; &#125;&#125; Dubbo å·²ç»è‡ªåŠ¨å°† JDK ä¸­å¸¸ç”¨çš„ç±»è¿›è¡Œäº†æ³¨å†Œï¼Œä¸è¦é‡å¤æ³¨å†Œï¼Œå³ä½¿é‡å¤æ³¨å†Œä¹Ÿæ²¡åˆä»»ä½•å½±å“ã€‚ç”±äºæ³¨å†Œè¢«åºåˆ—åŒ–çš„ç±»ä»…ä»…æ˜¯å‡ºäºæ€§èƒ½ä¼˜åŒ–çš„ç›®çš„ï¼Œæ‰€ä»¥å³ä½¿å¿˜è®°æ³¨å†ŒæŸäº›ç±»ä¹Ÿæ²¡æœ‰å…³ç³»ã€‚äº‹å®ä¸Šï¼Œå³ä½¿ä¸æ³¨å†Œä»»ä½•ç±»ï¼ŒKryoå’ŒFSTçš„æ€§èƒ½ä¾ç„¶æ™®éä¼˜äºhessianå’Œdubboåºåˆ—åŒ–ã€‚ åºåˆ—åŒ–ç±»çš„æ³¨å†Œè¡¨123456789101112131415161718192021222324public abstract class SerializableClassRegistry &#123; /** * è¦åºåˆ—åŒ–ä¼˜åŒ–çš„ç±»çš„æ³¨å†Œè¡¨ */ private static final Set&lt;Class&gt; registrations = new LinkedHashSet&lt;Class&gt;(); /** * only supposed to be called at startup time * åœ¨ &#123;@link SerializationOptimizer#getSerializableClasses()&#125; æ–¹æ³•è·å¾—çš„ç±»é›†åˆï¼Œä¼šæ³¨å†Œåˆ°è¿™é‡Œã€‚ */ public static void registerClass(Class clazz) &#123; registrations.add(clazz); &#125; /** * è·å¾—åºåˆ—åŒ–ä¼˜åŒ–ç±»é›†åˆã€‚åœ¨ Kryo,FSTä¸­è°ƒç”¨è¯¥æ–¹æ³•ä¼šè·å¾—éœ€è¦ä¼˜åŒ–çš„ç±»çš„é›†åˆ * * @return */ public static Set&lt;Class&gt; getRegisteredClasses() &#123; return registrations; &#125;&#125; éœ€è¦åºåˆ—åŒ–ä¼˜åŒ–çš„ç±»éƒ½ä¼šæ³¨å†Œåˆ°è¯¥ç±»ä¸­è¿›è¡Œç¼“å­˜ã€‚ åºåˆ—åŒ–ä¼˜åŒ–å™¨çš„ä½¿ç”¨1234567891011121314151617181920212223242526272829303132333435363738394041424344--- DubboProtocolprivate void optimizeSerialization(URL url) throws RpcException &#123; // è·å¾— optimizer åºåˆ—åŒ–ä¼˜åŒ–å™¨ é…ç½®é¡¹ String className = url.getParameter(Constants.OPTIMIZER_KEY, \"\"); // å¦‚æœç³»ç»Ÿä¸­æ²¡æœ‰åºåˆ—åŒ–ä¼˜åŒ–å™¨å°±ç›´æ¥è¿”å› if (StringUtils.isEmpty(className) || optimizers.contains(className)) &#123; return; &#125; logger.info(\"Optimizing the serialization process for Kryo, FST, etc...\"); try &#123; // æ ¹æ® åºåˆ—åŒ–ä¼˜åŒ–å™¨å åŠ è½½ SerializationOptimizer å®ç°ç±» Class clazz = Thread.currentThread().getContextClassLoader().loadClass(className); // æ˜¯å¦æ˜¯SerializationOptimizerçš„å­ if (!SerializationOptimizer.class.isAssignableFrom(clazz)) &#123; throw new RpcException(\"The serialization optimizer \" + className + \" isn't an instance of \" + SerializationOptimizer.class.getName()); &#125; // åå°„åˆ›å»º SerializationOptimizer å¯¹è±¡ SerializationOptimizer optimizer = (SerializationOptimizer) clazz.newInstance(); // æ²¡æœ‰è¦ä¼˜åŒ–çš„ç±»ç›´æ¥è¿”å› if (optimizer.getSerializableClasses() == null) &#123; return; &#125; // å°†è¦ä¼˜åŒ–çš„ç±»æ³¨å†Œåˆ° SerializableClassRegistry æ³¨å†Œè¡¨ä¸­ for (Class c : optimizer.getSerializableClasses()) &#123; SerializableClassRegistry.registerClass(c); &#125; // å°† åºåˆ—åŒ–ä¼˜åŒ–å™¨å®ç°ç±»å åŠ å…¥åˆ°ç¼“å­˜ä¸­ optimizers.add(className); &#125; catch (ClassNotFoundException e) &#123; throw new RpcException(\"Cannot find the serialization optimizer class: \" + className, e); &#125; catch (InstantiationException e) &#123; throw new RpcException(\"Cannot instantiate the serialization optimizer class: \" + className, e); &#125; catch (IllegalAccessException e) &#123; throw new RpcException(\"Cannot instantiate the serialization optimizer class: \" + className, e); &#125; &#125; å°ç»“æœ¬ç¯‡æ–‡ç« ä¸»è¦ä»‹ç»äº†åºåˆ—åŒ–å±‚çš„æŠ½è±¡APIï¼Œåºåˆ—åŒ–å®ç°å…·ä½“çš„èŒèƒ½æ˜¯ç”±å…¶ serialize æ–¹æ³•åˆ›å»ºçš„ObjectOutputå’Œ deserialize æ–¹æ³•åˆ›å»ºçš„ObjectInputæ¥å®Œæˆçš„ï¼Œè€Œè¿™ä¸¤ä¸ªå¯¹è±¡åˆæ˜¯å¯¹ OutputStream å’Œ InputStream çš„å°è£…ã€‚è¿˜ä»‹ç»äº†åºåˆ—åŒ–ä¼˜åŒ–å™¨ï¼Œå®ƒæ˜¯ç”¨æ¥æ”¯æŒåºåˆ—åŒ–å®ç°å¯¹æŒ‡å®šçš„åºåˆ—åŒ–ç±»è¿›è¡Œåºåˆ—åŒ–ä¼˜åŒ–å¤„ç†ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - åŠ¨æ€ä»£ç†æœ¬åœ°å­˜æ ¹","slug":"rpc/åŠ¨æ€ä»£ç†æœ¬åœ°å­˜æ ¹","date":"2020-05-01T16:00:00.000Z","updated":"2020-10-01T15:06:29.662Z","comments":false,"path":"posts/1663a5dc/","link":"","permalink":"https://gentryhuang.com/posts/1663a5dc/","excerpt":"","text":"å‰è¨€åœ¨ åŠ¨æ€ä»£ç†æ€»è§ˆ ä¸­å·²ç»ä»‹ç»äº†æŠ½è±¡å±‚åŠä½¿ç”¨æ–¹å¼ï¼Œæœ¬ç¯‡æ–‡ç« ä»‹ç»åŠ¨æ€ä»£ç†Wrapper StubProxyFactoryWrapper ã€‚ Wrapper ç±»åœ¨ Dubbo SPI ä¸­å·²ç»è¯¦ç»†ä»‹ç»äº†ä»€ä¹ˆæ˜¯ Wrapper ç±»ä»¥åŠ Wrapper ç±»çš„ä½œç”¨å’Œç”¨æ³•ã€‚StubProxyFactoryWrapper ä¼šåœ¨ ProxyFactory å®ç°æ‰§è¡Œå‰å…ˆæ‰§è¡Œã€‚ å±æ€§12345678910111213141516171819202122232425public class StubProxyFactoryWrapper implements ProxyFactory &#123; private static final Logger LOGGER = LoggerFactory.getLogger(StubProxyFactoryWrapper.class); /** * ProxyFactory$Adaptive å¯¹è±¡ */ private final ProxyFactory proxyFactory; /** * Protocol$Adaptive å¯¹è±¡ */ private Protocol protocol; /** * StubProxyFactoryWrapper åŸºäº Dubbo SPI Wrapper æœºåˆ¶ï¼Œæ ¹æ®URLé…ç½®ï¼Œä½¿ç”¨å…·ä½“çš„å®ç°ã€JavassistProxyFactory/JdkProxyFactoryã€‘ * * @param proxyFactory */ public StubProxyFactoryWrapper(ProxyFactory proxyFactory) &#123; this.proxyFactory = proxyFactory; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; StubProxyFactoryWrapper æ˜¯ ProxyFactory çš„ Wrapper ç±»ï¼ŒåŒæ—¶å®ƒåˆæ˜¯å®ç° Dubbo åŠ¨æ€ä»£ç†æœ¬åœ°å­˜æ ¹çš„ç±»ï¼Œæˆ‘ä»¬ç»§ç»­å¾€ä¸‹çœ‹ã€‚ åŠ¨æ€ä»£ç†æœ¬åœ°å­˜æ ¹è·å–ä»£ç†123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class StubProxyFactoryWrapper implements ProxyFactory &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; @Override @SuppressWarnings(&#123;\"unchecked\", \"rawtypes\"&#125;) public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException &#123; // è·å–ä»£ç†å¯¹è±¡ã€ä½¿ç”¨JavassistProxyFactory/JdkProxyFactoryã€‘ T proxy = proxyFactory.getProxy(invoker); // éæ³›åŒ– ã€æ³›åŒ–ä¸æ”¯æŒä½¿ç”¨æœ¬åœ°å­˜æ ¹ã€‘ if (GenericService.class != invoker.getInterface()) &#123; // è·å¾— `stub` é…ç½®é¡¹ ï¼Œæ³¨æ„ï¼Œlocal é…ç½®é¡¹ï¼Œå’Œ stub é…ç½®é¡¹æ˜¯ç­‰ä»·çš„ï¼Œç›®å‰ä½¿ç”¨ stub è€Œä¸ä½¿ç”¨ local ã€‚ String stub = invoker.getUrl().getParameter(Constants.STUB_KEY, invoker.getUrl().getParameter(Constants.LOCAL_KEY)); // æœåŠ¡å¼•ç”¨æœ‰é…ç½®æœ¬åœ°å­˜æ ¹ if (ConfigUtils.isNotEmpty(stub)) &#123; Class&lt;?&gt; serviceType = invoker.getInterface(); // `stub = true` çš„æ—¶ï¼Œä½¿ç”¨ æ¥å£ + `Stub` ä½œä¸ºå­˜æ ¹ç±»çš„ç±»å if (ConfigUtils.isDefault(stub)) &#123; if (invoker.getUrl().hasParameter(Constants.STUB_KEY)) &#123; stub = serviceType.getName() + \"Stub\"; &#125; else &#123; stub = serviceType.getName() + \"Local\"; &#125; &#125; try &#123; // åå°„è·å–æœ¬åœ°å­˜æ ¹ç±» Class&lt;?&gt; stubClass = ReflectUtils.forName(stub); // æœ¬åœ°å­˜æ ¹ç±»å¿…é¡»æ˜¯å®ç°æœåŠ¡æ¥å£ if (!serviceType.isAssignableFrom(stubClass)) &#123; throw new IllegalStateException(\"The stub implementation class \" + stubClass.getName() + \" not implement interface \" + serviceType.getName()); &#125; try &#123; // åå°„è·å– Stub çš„æœ‰å‚æ„é€ æ–¹æ³•ï¼Œå‚æ•°ç±»å‹æ˜¯æœåŠ¡ç±»å‹ Constructor&lt;?&gt; constructor = ReflectUtils.findConstructor(stubClass, serviceType); // åå°„åˆ›å»ºæœ¬åœ°å¯¹è±¡ï¼Œæ„é€ å‚æ•°éœ€è¦æ˜¯æœåŠ¡æ¥å£ç±»å‹å¯¹è±¡ proxy = (T) constructor.newInstance(new Object[]&#123;proxy&#125;); //è®¾ç½®äº† Stub å‚æ•°å›è°ƒå°±éœ€è¦æš´éœ² Stub æœåŠ¡ URL url = invoker.getUrl(); if (url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT)) &#123; url = url.addParameter(Constants.STUB_EVENT_METHODS_KEY, StringUtils.join(Wrapper.getWrapper(proxy.getClass()).getDeclaredMethodNames(), \",\")); url = url.addParameter(Constants.IS_SERVER_KEY, Boolean.FALSE.toString()); try &#123; // æš´éœ² Stub æœåŠ¡ export(proxy, (Class) invoker.getInterface(), url); &#125; catch (Exception e) &#123; LOGGER.error(\"export a stub service error.\", e); &#125; &#125; &#125; catch (NoSuchMethodException e) &#123; throw new IllegalStateException(\"No such constructor \\\"public \" + stubClass.getSimpleName() + \"(\" + serviceType.getName() + \")\\\" in stub implementation class \" + stubClass.getName(), e); &#125; &#125; catch (Throwable t) &#123; LOGGER.error(\"Failed to create stub implementation class \" + stub + \" in consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", cause: \" + t.getMessage(), t); // ignore &#125; &#125; &#125; return proxy; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; è·å– Invoker12345678910111213141516171819202122public class StubProxyFactoryWrapper implements ProxyFactory &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; /** * * * @param proxy æœåŠ¡å¯¹è±¡ * @param type æœåŠ¡æ¥å£ * @param url URL * @param &lt;T&gt; * @return * @throws RpcException */ @Override public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException &#123; return proxyFactory.getInvoker(proxy, type, url); &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; æ³¨æ„ï¼ŒæœåŠ¡æä¾›æ–¹ä¸æ”¯æŒ Stub æœ¬åœ°å­˜æ ¹ï¼Œå³ä½¿ &lt;dubbo:service /&gt; æœ‰ stub é…ç½®é¡¹ï¼Œå®é™…æ˜¯ä¸èµ·ä½œç”¨çš„ã€‚ å°ç»“StubProxyFactoryWrapper åŠŸèƒ½æ¯”è¾ƒç®€å•ï¼ŒåŸºæœ¬æµç¨‹å¦‚ä¸‹ï¼š","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - JDKåŠ¨æ€ä»£ç†","slug":"rpc/JdkåŠ¨æ€ä»£ç†","date":"2020-04-30T16:00:00.000Z","updated":"2021-01-04T10:57:09.740Z","comments":false,"path":"posts/faa2b4a3/","link":"","permalink":"https://gentryhuang.com/posts/faa2b4a3/","excerpt":"","text":"å‰è¨€åœ¨ åŠ¨æ€ä»£ç†æ€»è§ˆ ä¸­å·²ç»ä»‹ç»äº†æŠ½è±¡å±‚ï¼Œæœ¬ç¯‡æ–‡ç« ä»‹ç» JdkProxyFactory ã€‚ é…ç½®æ–¹å¼12&lt;dubbo:reference proxy=\"jdk\" /&gt;&lt;dubbo:service proxy=\"jdk\" /&gt; JDK ä»£ç†å·¥å‚12345678910111213141516171819202122232425262728293031323334353637383940414243public class JdkProxyFactory extends AbstractProxyFactory &#123; /** * * @param invoker invoker * @param interfaces æœåŠ¡å®ç°çš„æ¥å£ * @param &lt;T&gt; * @return */ @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123; return (T) Proxy.newProxyInstance( Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker) ); &#125; /** * * @param proxy æœåŠ¡å¯¹è±¡ * @param type æœåŠ¡æ¥å£ * @param url URL * @param &lt;T&gt; * @return */ @Override public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123; return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123; @Override protected Object doInvoke(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments) throws Throwable &#123; // è°ƒç”¨ Class#getMethod(String name, Class&lt;?&gt;... parameterTypes) æ–¹æ³•ï¼Œåå°„è·å¾—æ–¹æ³•ã€‚ Method method = proxy.getClass().getMethod(methodName, parameterTypes); // è°ƒç”¨ Method#invoke(proxy, arguments) æ–¹æ³•ï¼Œæ‰§è¡Œæ–¹æ³• return method.invoke(proxy, arguments); &#125; &#125;; &#125;&#125; è·å–ä»£ç†å¯¹è±¡JDK è·å–ä»£ç†çš„æ–¹å¼å¾ˆç®€å•ï¼Œä¸ä¾èµ–ä¸‰æ–¹ä¾èµ–ï¼Œç›´æ¥ä½¿ç”¨ JDK çš„åŠ¨æ€ä»£ç†ä¸ºæœåŠ¡æ¥å£åˆ›å»ºä¸€ä¸ªä»£ç†å¯¹è±¡ï¼Œå…¶ä¸­ InvokerInvocationHandler åŒ JavassistProxyFactory ã€‚ è·å– InvokerJDK è·å– Invoker åŒæ ·æ˜¯åˆ›å»º AbstractProxyInvoker çš„åŒ¿åå¯¹è±¡ï¼Œä¸è¿‡åœ¨ doInvoke æ–¹æ³•ä¸­æ˜¯ç›´æ¥é€šè¿‡åå°„æ‹¿åˆ°å®ç°ç±»çš„Methodå¯¹è±¡ï¼Œç„¶åæ‰§è¡Œå¯¹åº”çš„æ–¹æ³•ï¼Œéå¸¸æ¸…çˆ½ã€‚ å°ç»“Dubbo ä½¿ç”¨ JDK å®ç°åŠ¨æ€éå¸¸ç®€å•ï¼Œå¹¶ä¸”ä¸éœ€è¦ä¾èµ–ä¸‰ä¸ªä¾èµ–ï¼Œç›´æ¥ä¸€ä¸ªåå°„å°±è§£å†³äº†æ‰€æœ‰é—®é¢˜ï¼Œå°±æ˜¯æ€§èƒ½ä¸Šæœ‰æ‰€ä¸è¶³ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - JavassiståŠ¨æ€ä»£ç†","slug":"rpc/JavassiståŠ¨æ€ä»£ç†","date":"2020-04-29T16:00:00.000Z","updated":"2020-10-01T14:05:11.294Z","comments":false,"path":"posts/c2df2fc6/","link":"","permalink":"https://gentryhuang.com/posts/c2df2fc6/","excerpt":"","text":"å‰è¨€åœ¨ åŠ¨æ€ä»£ç†æ€»è§ˆ ä¸­å·²ç»è¯¦ç»†ä»‹ç»äº†æŠ½è±¡å±‚ï¼Œæœ¬ç¯‡æ–‡ç« ä»‹ç» JavassistProxyFactory ã€‚ é…ç½®æ–¹å¼12&lt;dubbo:reference proxy=\"javassist\" /&gt;&lt;dubbo:service proxy=\"javassist\" /&gt; æ³¨æ„ï¼Œé»˜è®¤æƒ…å†µå°±æ˜¯ javassistã€‚ JavassistProxyFactoryå®ç° AbstractProxyFactory æŠ½è±¡ç±»ï¼ŒåŸºäº Javassist ä»£ç†å·¥å‚å®ç°ç±»ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041public class JavassistProxyFactory extends AbstractProxyFactory &#123; /** * * @param invoker invoker * @param interfaces æœåŠ¡å®ç°çš„æ¥å£(åŒ…æ‹¬ EchoService) * @param &lt;T&gt; * @return */ @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123; return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker)); &#125; /** * * @param proxy Serviceå¯¹è±¡ * @param type Serviceæ¥å£ç±»å‹ * @param url Serviceå¯¹åº”çš„Dubbo URL * @param &lt;T&gt; * @return */ @Override public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123; // è·å–æœåŠ¡ç±»çš„åŒ…è£…å¯¹è±¡ï¼Œæ³¨æ„ Wrapperç±»ä¸èƒ½æ­£ç¡®å¤„ç†ç±»ååŒ…å«$çš„ç±» final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') &lt; 0 ? proxy.getClass() : type); return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123; @Override protected Object doInvoke(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments) throws Throwable &#123; // è°ƒç”¨ Wrapper çš„ invokeMethod æ–¹æ³•ï¼ŒinvokeMethod æœ€ç»ˆä¼šè°ƒç”¨ç›®æ ‡æ–¹æ³• return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments); &#125; &#125;; &#125;&#125; JavassistProxyFactory ä»£ç†å·¥å‚æœ‰ä¸¤ä¸ªæ–¹æ³•ï¼Œé€šè¿‡æ–¹æ³•åå¾ˆå®¹æ˜“çœ‹å‡ºä¸€ä¸ªæ˜¯è·å–ä»£ç†å¯¹è±¡çš„ï¼Œå¦ä¸€ä¸ªæ˜¯è·å– Invoker çš„ï¼Œå‰è€…ä¸€èˆ¬æ˜¯åœ¨å¼•ç”¨æœåŠ¡çš„è¿‡ç¨‹ä¼šè°ƒç”¨è¯¥æ–¹æ³•ï¼Œåè€…æ˜¯åœ¨æš´éœ²æœåŠ¡æ—¶ä¼šè°ƒç”¨ã€‚æˆ‘ä»¬ä¸‹é¢åˆ†åˆ«åˆ†æè¿™ä¸¤ä¸ªæ–¹æ³•ã€‚ è·å–ä»£ç† Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker)) ä¸Šé¢è¿™æ®µä»£ç ä¿¡æ¯é‡è¿˜æ˜¯å¾ˆå¤§çš„ï¼Œæ€»ä½“ä¸Šåšäº†ä¸‰ä»¶äº‹ï¼š Proxy.getProxy(interfaces) ç”¨äºæ„å»ºæœåŠ¡æ¥å£ä»£ç†ç±»å¹¶æ”¾å…¥å†…å­˜ï¼Œæ¥ç€è·å– Proxy çš„å­ç±»å¹¶åˆ›å»ºå¯¹è±¡ï¼Œ è°ƒç”¨å­ç±»å¯¹è±¡çš„ newInstance æ–¹æ³•åˆ›å»ºæœåŠ¡æ¥å£çš„ä»£ç†ç±»çš„å®ä¾‹ï¼Œéœ€è¦ InvokerInvocationHandler åŸºäº Invoker åˆ›å»º InvocationHandler å¯¹è±¡ å…¶ä¸­ 1ã€2 ä¸¤æ­¥æ“ä½œçš„åŸç†åœ¨åŠ¨æ€ä»£ç†æ€»è§ˆå·²ç»ä»‹ç»è¿‡äº†ï¼Œä¸‹é¢æˆ‘ä»¬ä¸»è¦åˆ†æç¬¬ 3 æ­¥å®ç°çš„åŸç†ã€‚ å®ç° InvocationHandler1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.alibaba.dubbo.rpc.proxy;import com.alibaba.dubbo.rpc.Invoker;import com.alibaba.dubbo.rpc.RpcInvocation;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * InvokerInvocationHandlerï¼Œå®ç°äº†JDKçš„InvocationHandler */public class InvokerInvocationHandler implements InvocationHandler &#123; /** * Invokerå¯¹è±¡ï¼Œç”¨äº #invokeæ–¹æ³•è°ƒç”¨ */ private final Invoker&lt;?&gt; invoker; public InvokerInvocationHandler(Invoker&lt;?&gt; handler) &#123; this.invoker = handler; &#125; /** * ä»£ç†å¯¹è±¡ã€Proxyåˆ›å»ºçš„ã€‘å‘å‡ºè¯·æ±‚ï¼Œä¼šæ‰§è¡Œåˆ°è¿™é‡Œã€‚ * * @param proxy ä»£ç†å¯¹è±¡ * @param method æ–¹æ³• * @param args å‚æ•° * @return * @throws Throwable * @see com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory#getProxy(com.alibaba.dubbo.rpc.Invoker, java.lang.Class[]) */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); // å¤„ç†wait(),notify()ç­‰æ–¹æ³•ï¼Œç›´æ¥è¿›è¡Œåå°„è°ƒç”¨ Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(invoker, args); &#125; // åŸºç¡€æ–¹æ³•ï¼Œä¸ä½¿ç”¨RPCè°ƒç”¨ if (\"toString\".equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123; return invoker.toString(); &#125; if (\"hashCode\".equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123; return invoker.hashCode(); &#125; if (\"equals\".equals(methodName) &amp;&amp; parameterTypes.length == 1) &#123; return invoker.equals(args[0]); &#125; // RPC è°ƒç”¨ return invoker.invoke(new RpcInvocation(method, args)).recreate(); &#125;&#125; åœ¨ç¬¬ 2 æ­¥ä¸­ï¼ŒæœåŠ¡æ¥å£ä»£ç†å¯¹è±¡æ‰€éœ€è¦çš„æ˜¯ Jdk çš„ InvocationHandlerï¼Œæˆ‘ä»¬å†æŠŠç”Ÿæˆçš„ä»£ç†æ‹¿è¿‡æ¥ä¾¿äºå¯¹æ¯”åˆ†æã€‚ 12345678910111213141516171819202122232425262728293031323334353637// å®˜æ–¹DemoæœåŠ¡æ¥å£package com.alibaba.dubbo.common.bytecode;import com.alibaba.dubbo.demo.DemoService;import com.alibaba.dubbo.rpc.service.EchoService;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class proxy0 implements EchoService, DemoService &#123; public static Method[] methods; private InvocationHandler handler; // æœåŠ¡æ¥å£æ–¹æ³•ï¼Œç”±ä»£ç†ç±»æ¥æ‰§è¡Œ public String sayHello(String paramString) &#123; Object[] arrayOfObject = new Object[1]; arrayOfObject[0] = paramString; // proxy.method =&gt; InvocationHandler.invoke Object localObject = this.handler.invoke(this, methods[0], arrayOfObject); return (String) localObject; &#125; // å›å£°æ¢æµ‹æ–¹æ³• public Object $echo(Object paramObject) &#123; Object[] arrayOfObject = new Object[1]; arrayOfObject[0] = paramObject; Object localObject = this.handler.invoke(this, methods[1], arrayOfObject); return (Object) localObject; &#125; public proxy0() &#123; &#125; // æœ‰å‚æ•°æ„é€ æ–¹æ³• public proxy0(InvocationHandler paramInvocationHandler) &#123; this.handler = paramInvocationHandler; &#125;&#125; é€šè¿‡ä»¥ä¸Šä»£ç æˆ‘ä»¬å¾ˆå®¹æ˜“æ€»ç»“å‡ºè°ƒç”¨å…³ç³»ï¼š client -&gt; proxy.method -&gt; InvocationHandler.invoke -&gt; Invoker.invoke ä¸€èˆ¬æ¶ˆè´¹è€…åœ¨è°ƒç”¨æœåŠ¡çš„æ—¶å€™ï¼Œä¼šå…ˆè·å–æœåŠ¡æ¥å£ä»£ç†å¯¹è±¡ï¼Œä»£ç†å¯¹è±¡ï¼ˆProxy ç”Ÿæˆçš„ï¼‰å‘èµ·æœåŠ¡è°ƒç”¨ä¼šç»è¿‡ Jdk çš„ InvocationHandler è¿›è¡Œè·¯ç”±ï¼Œå¦‚æœå±äºè¿œç¨‹è°ƒç”¨ï¼Œåˆ™æ‰§è¡Œ Invoker#invoke æ–¹æ³•è¿›è¡Œè¿œç¨‹è°ƒç”¨ã€‚ è·å– Invoker Wrapper.getWrapper(proxy.getClass().getName().indexOf(â€˜$â€™) &lt; 0 ? proxy.getClass() : type);return new AbstractProxyInvoker(proxy, type, url) è·å– Invoker åšäº† 2 ä¸ªå·¥ä½œï¼š 1 è·å–æœåŠ¡ç±»çš„åŒ…è£…ç±» Wrapper2 åˆ›å»º AbstractProxyInvoker åŒ¿åå¯¹è±¡ å…¶ä¸­ç¬¬ 1 æ­¥åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­å·²ç»è¯¦ç»†è¯´æ˜ï¼Œä¸‹é¢æˆ‘ä»¬åˆ†æä¸‹ AbstractProxyInvoker ã€‚ AbstractProxyInvokeråœ¨ä»‹ç» AbstractProxyInvoker å‰æˆ‘ä»¬å…ˆçœ‹ Invoker æ¥å£ï¼Œå®ƒæ˜¯ Dubbo ä¸­å¾ˆé‡è¦çš„æ¨¡å‹ã€‚ 1234567891011121314151617181920212223242526/** * Invoker. (API/SPI, Prototype, ThreadSafe) * * @see com.alibaba.dubbo.rpc.Protocol#refer(Class, com.alibaba.dubbo.common.URL) * @see com.alibaba.dubbo.rpc.InvokerListener * @see com.alibaba.dubbo.rpc.protocol.AbstractInvoker */public interface Invoker&lt;T&gt; extends Node &#123; /** * è·å–æœåŠ¡æ¥å£ * * @return service interface. */ Class&lt;T&gt; getInterface(); /** * RPC è°ƒç”¨ * * @param invocation * @return result * @throws RpcException */ Result invoke(Invocation invocation) throws RpcException;&#125; Invoker æ¥å£å¾ˆç®€å•ï¼Œå®ƒå°±æœ‰ä¸¤ä¸ªæ–¹æ³•ï¼Œè·å–æœåŠ¡æ¥å£å’Œè¿›è¡ŒRPCè°ƒç”¨ã€‚å®ƒçš„å®ç°ç±»å¾ˆå¤šï¼Œå…ˆä¸å±•å¼€è¯´æ˜é‡åˆ°äº†å†åˆ†æã€‚è¿™é‡Œæˆ‘ä»¬åˆ†æ AbstractProxyInvoker ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public abstract class AbstractProxyInvoker&lt;T&gt; implements Invoker&lt;T&gt; &#123; /** * ä»£ç†çš„å¯¹è±¡ï¼Œä¸€èˆ¬æ˜¯æœåŠ¡æ¥å£çš„å®ç°å¯¹è±¡ */ private final T proxy; /** * æœåŠ¡æ¥å£ */ private final Class&lt;T&gt; type; /** * URLå¯¹è±¡ï¼Œä¸€èˆ¬æ˜¯æš´éœ²æœåŠ¡çš„URLå¯¹è±¡ */ private final URL url; public AbstractProxyInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123; if (proxy == null) &#123; throw new IllegalArgumentException(\"proxy == null\"); &#125; if (type == null) &#123; throw new IllegalArgumentException(\"interface == null\"); &#125; if (!type.isInstance(proxy)) &#123; throw new IllegalArgumentException(proxy.getClass().getName() + \" not implement interface \" + type); &#125; this.proxy = proxy; this.type = type; this.url = url; &#125; @Override public Class&lt;T&gt; getInterface() &#123; return type; &#125; @Override public URL getUrl() &#123; return url; &#125; @Override public boolean isAvailable() &#123; return true; &#125; /** * é”€æ¯ * è¯´æ˜ï¼šåœ¨é€šè¿‡JavassistProxyFactoryå·¥å‚åˆ›å»ºInvokeræ—¶ï¼Œå°±æ˜¯åˆ›å»ºäº†AbstractProxyInvokeræŠ½è±¡åŒ¿åå¯¹è±¡ */ @Override public void destroy() &#123; &#125; /** * ä¸»è¦é€»è¾‘åœ¨doInvokeæ¨¡ç‰ˆæ–¹æ³•ä¸­å®ç° * * @param invocation * @return * @throws RpcException */ @Override public Result invoke(Invocation invocation) throws RpcException &#123; try &#123; // è°ƒç”¨ doInvoke æ‰§è¡Œåç»­çš„è°ƒç”¨ï¼Œå¹¶å°†è°ƒç”¨ç»“æœå°è£…åˆ° RpcResult ä¸­ return new RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments())); &#125; catch (InvocationTargetException e) &#123; // å‘ç”ŸInvocationTargetException å¼‚å¸¸ï¼Œåˆ›å»ºRpcResultå¯¹è±¡åŒ…è£… return new RpcResult(e.getTargetException()); &#125; catch (Throwable e) &#123; throw new RpcException(\"Failed to invoke remote proxy method \" + invocation.getMethodName() + \" to \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; /** * ç”±å…·ä½“å­ç±»è¦†å†™ ã€é»˜è®¤æƒ…å†µä½¿ç”¨ JavassistProxyFactory åˆ›å»ºçš„ä¸€ä¸ªåŒ¿åç±»å¯¹è±¡ã€‘ * * @param proxy æœåŠ¡å®ä¾‹ * @param methodName æ–¹æ³•å * @param parameterTypes æ–¹æ³•å‚æ•°ç±»å‹æ•°ç»„ * @param arguments æ–¹æ³•å‚æ•°æ•°ç»„ * @return è°ƒç”¨ç»“æœ * @throws Throwable å‘ç”Ÿå¼‚å¸¸ */ protected abstract Object doInvoke(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments) throws Throwable; @Override public String toString() &#123; return getInterface() + \" -&gt; \" + (getUrl() == null ? \" \" : getUrl().toString()); &#125;&#125; æœåŠ¡æš´éœ²çš„æ—¶å€™ä¼šåˆ›å»ºè¯¥ç±»çš„åŒ¿åå¯¹è±¡ä½œä¸º Invokerï¼Œè¯¥ Invoker å°è£…äº†æœåŠ¡å¯¹è±¡åŠæœåŠ¡ç›¸å…³ä¿¡æ¯ï¼ˆå¦‚æœåŠ¡æ¥å£ã€æœåŠ¡URLç­‰ï¼‰ï¼Œç»è¿‡å±‚å±‚åŒ…è£…æœ€ç»ˆæˆä¸º Exporter å¯¹è±¡ï¼Œæ›´è¯¦ç»†çš„æµç¨‹ä¼šåœ¨æœåŠ¡æš´éœ²ç« èŠ‚è¯¦ç»†è¯´æ˜ã€‚ ç»“åˆ getInvoker æ–¹æ³•æ•´ä½“è¯´æ˜ Invoker åˆ›å»ºä¸è°ƒç”¨çš„è¿‡ç¨‹ï¼Œå¿½ç•¥å®¹é”™ã€è·¯ç”±ç­‰ç»†èŠ‚ï¼š ä¸ºæœåŠ¡ç±»æ„å»º Wrapper çš„å®ç°ç±»ï¼Œè¯¥å®ç°ç±»æ‹¥æœ‰æœåŠ¡ç±»çš„å±æ€§ã€æ–¹æ³•ç­‰ä¿¡æ¯ï¼Œå…¶ä¸­ invokeMethod æ–¹æ³•ä¼šä¸ºæœåŠ¡æ–¹æ³•åšæ–¹æ³•åå’Œæ–¹æ³•å‚æ•°åŒ¹é…ï¼Œç„¶ååˆ›å»ºå®ç°ç±»çš„å¯¹è±¡ åˆ›å»º AbstractProxyInvoker åŒ¿åå¯¹è±¡ï¼Œå…¶ä¸­å®ç°çš„ doInvoke æ–¹æ³•ä¼šè°ƒç”¨ Wrapper å®ç°ç±»å¯¹è±¡çš„ invokeMethod æ–¹æ³• ä¸€ä¸ªæœåŠ¡å¯¹åº”ä¸€ä¸ª Wrapper æ¶ˆè´¹æ–¹åœ¨è°ƒç”¨Invoker.invoke æ—¶ï¼Œä¼šå…ˆè§¦å‘ doInvoke æ–¹æ³•ï¼Œ Wrapperçš„å®ç°çš„invokeMethodæ–¹æ³•åšäº†ä¸€æ¬¡è½¬å‘ï¼Œç„¶åæ‰ä¼šçœŸæ­£è°ƒç”¨Invokerï¼ˆAbstractProxyInvokerï¼‰ä¸­çš„æœåŠ¡å¯¹è±¡çš„æ–¹æ³•ï¼ˆInvokerå°è£…äº†æœåŠ¡å¯¹è±¡refï¼‰ å°ç»“JavassistProxyFactory åœ¨åˆ›å»ºæœåŠ¡ä»£ç†å¯¹è±¡å’Œ Invoker çš„è¿‡ç¨‹ï¼Œéƒ½ä½¿ç”¨äº†å­—èŠ‚ç æŠ€æœ¯ï¼Œå°½å¯èƒ½åœ°è§„é¿åå°„æ“ä½œã€‚ä¸‹ä¸€ç¯‡åˆ†æ Jdk çš„åŠ¨æ€ä»£ç†å®ç°ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Javassist","slug":"Javassist","permalink":"https://gentryhuang.com/tags/Javassist/"}]},{"title":"Dubboæºç åˆ†æ - åŠ¨æ€ä»£ç†æ€»è§ˆ","slug":"rpc/DubboåŠ¨æ€ä»£ç†æ€»è§ˆ","date":"2020-04-27T16:00:00.000Z","updated":"2021-01-04T10:57:24.177Z","comments":false,"path":"posts/1d1e42a8/","link":"","permalink":"https://gentryhuang.com/posts/1d1e42a8/","excerpt":"","text":"å‰è¨€å‰é¢çš„ä¸€ç³»åˆ—æ–‡ç« ä¸»è¦æ¢è®¨äº† æ¡†æ¶è®¾è®¡ ä¸­çš„ä¸šåŠ¡å±‚ï¼ˆserviceï¼‰ã€é…ç½®å±‚ï¼ˆconfigï¼‰ä»¥åŠæ³¨å†Œä¸­å¿ƒå±‚ï¼ˆregistryï¼‰ã€‚è™½ç„¶ä»£ç†å±‚ï¼ˆproxyï¼‰ä½äºé…ç½®å±‚å’Œæ³¨å†Œä¸­å¿ƒå±‚ä¹‹é—´ï¼Œä½†æ˜¯å®ƒæ˜¯ä¸šåŠ¡å±‚è¿æ¥ Dubbo å†…éƒ¨çš„æ¡¥æ¢ï¼Œå› ä¸ºä¸šåŠ¡å±‚æ— æ³•ç›´æ¥ä½¿ç”¨ Dubbo å†…éƒ¨æ¦‚å¿µã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä»£ç†å±‚å…·ä½“å®ç°ä½äº dubbo-rpc-apiæ¨¡å—ä¸­ã€‚ æœåŠ¡æš´éœ²æ—¶ï¼Œéœ€è¦é€šè¿‡ä»£ç†å±‚å°†ä¸šåŠ¡æ¥å£å®ç°å¯¹è±¡è½¬ä¸º Invoker ã€‚æœåŠ¡å¼•ç”¨æ—¶ï¼Œéœ€è¦é€šè¿‡ä»£ç†å±‚å°†ä¸šåŠ¡æ¥å£å®ç°å¯¹è±¡çš„ Invoker è½¬ä¸º Dubbo çš„ Proxy ã€‚å…·ä½“è¿‡ç¨‹ä¸‹é¢ä¼šè¯¦ç»†è¯´æ˜ã€‚ æ¦‚è¿°Dubbo æ”¯æŒ Javassist å’Œ JDK çš„æ–¹å¼ç”Ÿæˆä»£ç†ï¼Œé»˜è®¤ä½¿ç”¨ Javassist ç”Ÿæˆä»£ç†ï¼Œé…ç½®æ–¹å¼ï¼š 12&lt;dubbo:service proxy=\"xxx\"/&gt;&lt;dubbo:reference proxy=\"xxx\"/&gt; Dubbo ä»£ç†ç›¸å…³çš„ UML å›¾å¦‚ä¸‹ï¼š ç°åœ¨çœ‹è¿™ä¸ª UML å›¾å¯èƒ½ä¼šä¸ç†è§£ï¼Œç­‰åˆ†æå®Œåå†å›æ¥çœ‹å°±å¾ˆæ¸…æ™°äº†ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œåˆ†æçš„è¿‡ç¨‹ä¸­ä¼šæ¶‰åŠåˆ° Invoker æ¨¡å‹ï¼Œå¯ä»¥ç®€å•ç†è§£æˆä¸€ä¸ªçœŸå®çš„æœåŠ¡å¯¹è±¡ï¼Œå®ƒæ˜¯ Dubbo æ¡†æ¶å®ä½“åŸŸï¼Œæ‰€æœ‰æ¨¡å‹éƒ½ä¼šå‘å®ƒé æ‹¢ï¼Œå¯å‘å®ƒå‘èµ· invoke è°ƒç”¨ã€‚ ä»£ç†å·¥å‚ ProxyFactory1234567891011121314151617181920212223242526272829303132333435363738394041/** * ProxyFactory. (API/SPI, Singleton, ThreadSafe) */@SPI(\"javassist\")public interface ProxyFactory &#123; /** * åˆ›å»ºä»£ç†å¯¹è±¡ï¼ˆä¸ºInvokerå¯¹è±¡åˆ›å»ºä»£ç†å¯¹è±¡ï¼‰ï¼Œåœ¨å¼•ç”¨æœåŠ¡çš„è¿‡ç¨‹ä¼šè°ƒç”¨è¯¥æ–¹æ³•ã€‚ * &lt;p&gt; * create proxy. * * @param invoker æ¶ˆè´¹è€…å¯¹æä¾›è€…è°ƒç”¨çš„Invoker * @return proxy ä»£ç†å¯¹è±¡ */ @Adaptive(&#123;Constants.PROXY_KEY&#125;) &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException; /** * create proxy. * * @param invoker * @return proxy */ @Adaptive(&#123;Constants.PROXY_KEY&#125;) &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, boolean generic) throws RpcException; /** * åˆ›å»ºInvokerï¼ˆå°†ä»£ç†å¯¹è±¡åå‘å°è£…æˆInvokerå¯¹è±¡ï¼‰ï¼Œåœ¨æš´éœ²æœåŠ¡æ—¶ä¼šè°ƒç”¨ã€‚ * &lt;p&gt; * create invoker. * * @param &lt;T&gt; * @param proxy Serviceå¯¹è±¡ * @param type Serviceæ¥å£ç±»å‹ * @param url Serviceå¯¹åº”çš„Dubbo URL * @return invoker */ @Adaptive(&#123;Constants.PROXY_KEY&#125;) &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException;&#125; ä»£ç†å·¥å‚æ¥å£æ˜¯ä¸ªæ‰©å±•ç‚¹ï¼Œç”¨äºè·å–ä»£ç†å¯¹è±¡å’ŒInvokerï¼Œé»˜è®¤æ‰©å±•å®ç°æ˜¯ javassistï¼Œå®ƒçš„ä¸‰ä¸ªæ–¹æ³•éƒ½æ ‡æ³¨æœ‰ @Adaptive({Constants.PROXY_KEY}) æ³¨è§£ä¿¡æ¯ï¼Œè¡¨æ˜ä¼šè‡ªåŠ¨ç”Ÿæˆè‡ªé€‚åº”æ‰©å±•å®ç°ï¼Œå…³äºè‡ªé€‚åº”æ‰©å±•åœ¨ä¹‹å‰çš„æ–‡ç« ä¸­å·²ç»è¯¦ç»†ä»‹ç»è¿‡äº†ã€‚ä»£ç†å·¥å‚çš„æ‰©å±•ç‚¹é…ç½®å¦‚ä¸‹ï¼š 123stub&#x3D;com.alibaba.dubbo.rpc.proxy.wrapper.StubProxyFactoryWrapperjdk&#x3D;com.alibaba.dubbo.rpc.proxy.jdk.JdkProxyFactoryjavassist&#x3D;com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory ä»£ç†å·¥å‚æŠ½è±¡å®ç°ç±»12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public abstract class AbstractProxyFactory implements ProxyFactory &#123; /** * * @param invoker æ¶ˆè´¹è€…å¯¹æä¾›è€…è°ƒç”¨çš„Invoker * @param &lt;T&gt; * @return * @throws RpcException */ @Override public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException &#123; // è°ƒç”¨é‡è½½æ–¹æ³•è·å–ä»£ç†å¯¹è±¡ return getProxy(invoker, false); &#125; /** * * æ³¨æ„ï¼šè¿™é‡Œä¼šåœ¨åŸæœ‰Invokerå…³è”çš„æ¥å£ä¹‹ä¸Šå¢åŠ EchoServiceæ¥å£ï¼Œä½œç”¨æ˜¯å›å£°æµ‹è¯•ï¼Œæ¯ä¸ªæœåŠ¡éƒ½ä¼šè‡ªåŠ¨å®ç°EchoServiceæ¥å£ã€‚ * å¦‚æœè¦ä½¿ç”¨å›å£°æµ‹è¯•ï¼Œåªéœ€è¦å°†ä»»æ„æœåŠ¡å¼•ç”¨å¼ºåˆ¶è½¬å‹ä¸ºEchoServiceå³å¯ä½¿ç”¨ã€‚ * * @param invoker invoker * @param generic æ˜¯å¦æ³›åŒ– * @param &lt;T&gt; * @return * @throws RpcException */ @Override public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, boolean generic) throws RpcException &#123; // è®°å½•è¦ä»£ç†çš„æ¥å£ Class&lt;?&gt;[] interfaces = null; // ä»Invokerçš„URLä¸­è·å–æ¥å£åˆ—è¡¨ String config = invoker.getUrl().getParameter(\"interfaces\"); if (config != null &amp;&amp; config.length() &gt; 0) &#123; // åˆ‡åˆ†æ¥å£åˆ—è¡¨ String[] types = Constants.COMMA_SPLIT_PATTERN.split(config); if (types != null &amp;&amp; types.length &gt; 0) &#123; interfaces = new Class&lt;?&gt;[types.length + 2]; // è®¾ç½®æœåŠ¡æ¥å£ç±»å’ŒEchoService.class åˆ° interfaces ä¸­ï¼Œè¿™é‡Œå°±æ˜¯å¢åŠ EchoServiceæ¥å£çš„å…¥å£ï¼Œè®©æœåŠ¡å®ç°å®ƒã€‚ interfaces[0] = invoker.getInterface(); // å›å£°æµ‹è¯•æ¥å£ interfaces[1] = EchoService.class; for (int i = 0; i &lt; types.length; i++) &#123; // åŠ è½½æ¥å£ç±» interfaces[i + 1] = ReflectUtils.forName(types[i]); &#125; &#125; &#125; // å¦‚æœinterfacesä¸ºç©ºï¼Œå¢åŠ EchoServiceæ¥å£ï¼Œç”¨äºå›å£°æµ‹è¯• if (interfaces == null) &#123; interfaces = new Class&lt;?&gt;[]&#123;invoker.getInterface(), EchoService.class&#125;; &#125; // ä¸ºhttpå’Œhessian åè®®æä¾›æ³›åŒ–è°ƒç”¨æ”¯æŒ if (!invoker.getInterface().equals(GenericService.class) &amp;&amp; generic) &#123; int len = interfaces.length; Class&lt;?&gt;[] temp = interfaces; // åˆ›å»ºæ–°çš„interfacesæ•°ç»„ interfaces = new Class&lt;?&gt;[len + 1]; System.arraycopy(temp, 0, interfaces, 0, len); // è®¾ç½®GenericService.class åˆ°æ•°ç»„ä¸­ interfaces[len] = GenericService.class; &#125; // è°ƒç”¨é‡è½½æ–¹æ³• return getProxy(invoker, interfaces); &#125; /** * å­ç±»éœ€è¦å®ç°çœŸæ­£è·å–Proxyå¯¹è±¡çš„é€»è¾‘ * * @param invoker * @param types * @param &lt;T&gt; * @return */ public abstract &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] types);&#125; è¯¥æŠ½è±¡ç±»ä¸»è¦ä¸ºæœåŠ¡è‡ªåŠ¨å¢åŠ ä¸€ä¸ªå®ç°æ¥å£ EchoServiceï¼Œç”¨äºå›å£°æµ‹è¯•ï¼Œè·å–ä»£ç†çš„å·¥ä½œäº¤ç»™äº†å…·ä½“å­ç±»æ¥å®Œæˆã€‚æˆ‘ä»¬å‰é¢ä¹Ÿè¯´äº†å­ç±»æœ‰ä¸¤ä¸ªï¼Œå…·ä½“è·å–å“ªä¸€ä¸ªå¯ä»¥é€šè¿‡é…ç½®å†³å®šï¼Œæ²¡æœ‰é…ç½®é»˜è®¤ä½¿ç”¨ JavassistProxyFactory ã€‚ Proxyè¯¥ç±»ä½äº dubbo-common æ¨¡å—ä¸‹ï¼Œæ˜¯ Dubbo æ¡†æ¶è‡ªå®šä¹‰çš„ç±»ï¼Œç”¨äºæ„å»º Proxy çš„å®ç°ç±»åŠåˆ›å»ºå…¶å¯¹è±¡ï¼Œä¸ºä»€è¯´æ˜¯æ„å»º Proxy çš„å®ç°ç±»å‘¢ï¼Ÿå› ä¸º Proxy æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œå®ƒçš„ getProxy æ–¹æ³•åˆ©ç”¨ Javassist API æ„å»º Proxy çš„å­ç±»å¹¶é€šè¿‡åå°„åˆ›å»ºå…¶å¯¹è±¡ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361package com.alibaba.dubbo.common.bytecode;/** * Proxy. */public abstract class Proxy &#123; /** * é»˜è®¤çš„ InvocationHandler å¯¹è±¡ï¼Œè¿”å› null */ public static final InvocationHandler RETURN_NULL_INVOKER = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) &#123; return null; &#125; &#125;; /** * é»˜è®¤çš„ InvocationHandler å¯¹è±¡ï¼Œç›´æ¥æŠ›å‡ºå¼‚å¸¸ */ public static final InvocationHandler THROW_UNSUPPORTED_INVOKER = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) &#123; throw new UnsupportedOperationException(\"Method [\" + ReflectUtils.getName(method) + \"] unimplemented.\"); &#125; &#125;; /** * åŸå­å¯¹è±¡ */ private static final AtomicLong PROXY_CLASS_COUNTER = new AtomicLong(0); /** * Proxyç±»æ‰€åœ¨çš„åŒ…å */ private static final String PACKAGE_NAME = Proxy.class.getPackage().getName(); /** * Proxy å®ä¾‹çš„ç¼“å­˜ * key1: Classloader * key2: æœåŠ¡å®ç°çš„æ¥å£ä¸² * value: */ private static final Map&lt;ClassLoader, Map&lt;String, Object&gt;&gt; ProxyCacheMap = new WeakHashMap&lt;ClassLoader, Map&lt;String, Object&gt;&gt;(); private static final Object PendingGenerationMarker = new Object(); protected Proxy() &#123; &#125; /** * Get proxy. * * @param ics interface class array. * @return Proxy instance. */ public static Proxy getProxy(Class&lt;?&gt;... ics) &#123; return getProxy(ClassHelper.getClassLoader(Proxy.class), ics); &#125; /** * @param cl ç±»åŠ è½½å™¨ * @param ics æœåŠ¡å®ç°çš„æ¥å£æ•°ç»„ * @return Proxy æ¥å£ä»£ç†å¯¹è±¡ */ public static Proxy getProxy(ClassLoader cl, Class&lt;?&gt;... ics) &#123; //----------------------------------- 1 æ ¡éªŒã€è®¿é—®ç¼“å­˜ã€å¹¶å‘æ§åˆ¶ ------------------------------/ if (ics.length &gt; 65535) &#123; throw new IllegalArgumentException(\"interface limit exceeded\"); &#125; StringBuilder sb = new StringBuilder(); // éå†æ¥å£åˆ—è¡¨ for (int i = 0; i &lt; ics.length; i++) &#123; String itf = ics[i].getName(); // æ£€æµ‹ç±»å‹æ˜¯å¦ä¸ºæ¥å£ if (!ics[i].isInterface()) &#123; throw new RuntimeException(itf + \" is not a interface.\"); &#125; Class&lt;?&gt; tmp = null; try &#123; // åå°„è·å–æ¥å£å¯¹åº”çš„Class tmp = Class.forName(itf, false, cl); &#125; catch (ClassNotFoundException e) &#123; &#125; // æ£€æµ‹æ¥å£æ˜¯å¦ç›¸åŒï¼Œè¿™é‡Œtmpæœ‰å¯èƒ½ä¸ºç©º if (tmp != ics[i]) &#123; throw new IllegalArgumentException(ics[i] + \" is not visible from class loader\"); &#125; // æ‹¼æ¥æ¥å£å…¨é™å®šæ€§åï¼Œåˆ†éš”ç¬¦ä¸º `;` sb.append(itf).append(';'); &#125; // ä½¿ç”¨æ‹¼æ¥åçš„æ¥å£åä½œä¸º key String key = sb.toString(); // get cache by class loader. Map&lt;String, Object&gt; cache; synchronized (ProxyCacheMap) &#123; // cl ç±»åŠ è½½å™¨æ˜¯å¦æœ‰å¯¹åº”çš„å€¼ï¼Œæ²¡æœ‰åˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„å€¼ cache = ProxyCacheMap.get(cl); if (cache == null) &#123; cache = new HashMap&lt;String, Object&gt;(); ProxyCacheMap.put(cl, cache); &#125; &#125; Proxy proxy = null; synchronized (cache) &#123; do &#123; // ä»ç¼“å­˜ä¸­è·å– key å¯¹åº”çš„å€¼ï¼Œå¯èƒ½æ˜¯æ ‡å¿—æœª Object value = cache.get(key); if (value instanceof Reference&lt;?&gt;) &#123; proxy = (Proxy) ((Reference&lt;?&gt;) value).get(); if (proxy != null) &#123; return proxy; &#125; &#125; // å¤šçº¿ç¨‹æ§åˆ¶ï¼Œä¿è¯åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è¿›è¡Œåç»­æ“ä½œï¼Œå³å¦‚æœå·²ç»æ˜¯æ ‡å¿—ä½è¯´æ˜å·²ç»æœ‰çº¿ç¨‹åœ¨è·å–äº†ï¼Œå½“å‰çº¿ç¨‹è¦ç­‰å¾… if (value == PendingGenerationMarker) &#123; try &#123; // çº¿ç¨‹è¦ç­‰å¾… cache.wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; else &#123; // è®¾ç½®æ ‡å¿—ä½åˆ°ç¼“å­˜ä¸­ï¼Œå¹¶è·³å‡ºwhileå¾ªç¯è¿›è¡Œåç»­æ“ä½œ cache.put(key, PendingGenerationMarker); break; &#125; &#125; while (true); &#125; long id = PROXY_CLASS_COUNTER.getAndIncrement(); String pkg = null; // ç”¨äºä¸ºæœåŠ¡æ¥å£ç”Ÿæˆä»£ç†ç±» ClassGenerator ccp = null; // ä¸º org.apache.dubbo.common.bytecode.Proxy æŠ½è±¡ç±»ç”Ÿæˆå­ç±»ï¼Œä¸»è¦æ˜¯å®ç° Proxy ç±»çš„æŠ½è±¡æ–¹æ³• ClassGenerator ccm = null; try &#123; //----------------------------------------- 2 æ„å»ºæ¥å£ä»£ç†ç±» -----------------------------------------/ // åˆ›å»º javassist å·¥å…·å¯¹è±¡ ï¼ˆClassGeneratorå¯¹ javassistè¿›è¡Œäº†å°è£…ï¼‰ ccp = ClassGenerator.newInstance(cl); Set&lt;String&gt; worked = new HashSet&lt;String&gt;(); List&lt;Method&gt; methods = new ArrayList&lt;Method&gt;(); // éå† æœåŠ¡å®ç°çš„æ¥å£æ•°ç»„ for (int i = 0; i &lt; ics.length; i++) &#123; // æ£€æµ‹æ¥å£è®¿é—®çº§åˆ«æ˜¯å¦ä¸ºprotectedæˆ–private if (!Modifier.isPublic(ics[i].getModifiers())) &#123; // è·å–æ¥å£åŒ…å String npkg = ics[i].getPackage().getName(); if (pkg == null) &#123; pkg = npkg; &#125; else &#123; if (!pkg.equals(npkg)) &#123; // épublic çº§åˆ«çš„æ¥å£å¿…é¡»åœ¨åŒä¸€ä¸ªåŒ…ä¸‹ï¼Œå¦åˆ™æŠ¥é”™ throw new IllegalArgumentException(\"non-public interfaces from different packages\"); &#125; &#125; &#125; // æ·»åŠ æ¥å£åˆ° ClassGenerator å·¥å…·ç±»çš„å±æ€§ä¸­ ccp.addInterface(ics[i]); // éå†æ¥å£æ–¹æ³• for (Method method : ics[i].getMethods()) &#123; // è·å–æ–¹æ³•ç­¾å String desc = ReflectUtils.getDesc(method); // å¦‚æœå·²ç»åŒ…å«åœ¨workedä¸­ï¼Œåˆ™å¿½ç•¥ã€‚å¯èƒ½ä¼šå‡ºç°ï¼ŒAæ¥å£å’ŒBæ¥å£ä¸­åŒ…å«ä¸€ä¸ªå®Œå…¨ç›¸åŒçš„æ–¹æ³• if (worked.contains(desc)) &#123; continue; &#125; worked.add(desc); int ix = methods.size(); // è·å–æ–¹æ³•è¿”å›å€¼ç±»å‹ Class&lt;?&gt; rt = method.getReturnType(); // è·å–å‚æ•°åˆ—è¡¨ Class&lt;?&gt;[] pts = method.getParameterTypes(); // ç”Ÿæˆ Object[] args = new Object[1...N] StringBuilder code = new StringBuilder(\"Object[] args = new Object[\").append(pts.length).append(\"];\"); for (int j = 0; j &lt; pts.length; j++) &#123; code.append(\" args[\").append(j).append(\"] = ($w)$\").append(j + 1).append(\";\"); &#125; // ç”ŸæˆInvokerHandleræ¥å£çš„invoker æ–¹æ³•è°ƒç”¨è¯­å¥ï¼Œå¦‚ï¼š Object ret = handler.invoke(this,methods[1...N],args); code.append(\" Object ret = handler.invoke(this, methods[\" + ix + \"], args);\"); // è¿”å›å€¼ä¸ä¸ºvoid if (!Void.TYPE.equals(rt)) &#123; // ç”Ÿæˆè¿”å›è¯­å¥ï¼Œå½¢å¦‚ return (java.lang.String) ret; code.append(\" return \").append(asArgument(rt, \"ret\")).append(\";\"); &#125; methods.add(method); // æ·»åŠ æ–¹æ³•åã€è®¿é—®æ§åˆ¶ç¬¦ã€å‚æ•°åˆ—è¡¨ã€æ–¹æ³•ä»£ç ç­‰ä¿¡æ¯åˆ° ClassGenerator ä¸­ ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString()); &#125; &#125; if (pkg == null) &#123; pkg = PACKAGE_NAME; &#125; // æ‹¼æ¥æ¥å£ä»£ç†ç±»åç§°ï¼špkg + \".proxy\" + idï¼Œæ¯”å¦‚ org.apache.dubbo.proxy0 String pcn = pkg + \".proxy\" + id; ccp.setClassName(pcn); // å£°æ˜æ–¹æ³•æ•°ç»„ ccp.addField(\"public static java.lang.reflect.Method[] methods;\"); // å£°æ˜ private java.lang.reflect.InvocationHandler handler; ccp.addField(\"private \" + InvocationHandler.class.getName() + \" handler;\"); /** * ä¸ºæ¥å£ä»£ç†ç±»æ·»åŠ å¸¦æœ‰ InvocationHandler å‚æ•°çš„æ„é€ æ–¹æ³•ï¼Œæ¯”å¦‚ï¼š * porxy0(java.lang.reflect.InvocationHandler arg0) &#123; * handler=$1; * &#125; */ ccp.addConstructor(Modifier.PUBLIC, new Class&lt;?&gt;[]&#123;InvocationHandler.class&#125;, new Class&lt;?&gt;[0], \"handler=$1;\"); // ä¸ºæ¥å£ä»£ç†ç±»æ·»åŠ é»˜è®¤æ„é€ æ–¹æ³•ï¼Œå¦‚ï¼š public proxy0() &#123;&#125; ccp.addDefaultConstructor(); // ç”Ÿæˆæ¥å£ä»£ç†ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸‹é¢æ„å»ºå¹¶åˆ›å»ºçš„ Proxy çš„å­ç±»å¯¹è±¡ä¼šè°ƒç”¨å®ƒçš„ newInstance æ–¹æ³•ï¼Œè¿›è€Œåˆ›å»ºæ¥å£ä»£ç†å¯¹è±¡ Class&lt;?&gt; clazz = ccp.toClass(); clazz.getField(\"methods\").set(null, methods.toArray(new Method[0])); //----------------------------------------- 3 æ„å»º ProxyæŠ½è±¡ç±»çš„å­ç±»å¹¶åˆ›å»ºå¯¹è±¡ -----------------------------------------/ // æ„å»ºProxyå­ç±»åç§°ï¼Œæ¯”å¦‚ï¼šProxy1 String fcn = Proxy.class.getName() + id; // åˆ›å»º javassist å·¥å…·å¯¹è±¡ ï¼ˆClassGeneratorå¯¹ javassistè¿›è¡Œäº†å°è£…ï¼‰ ccm = ClassGenerator.newInstance(cl); // ç±»å ccm.setClassName(fcn); // é»˜è®¤æ„é€ æ–¹æ³• ccm.addDefaultConstructor(); // è®¾ç½®çˆ¶ç±» Proxy ccm.setSuperClass(Proxy.class); /** * ä¸º Proxy çš„æŠ½è±¡æ–¹æ³• newInstance ç”Ÿæˆå®ç°ä»£ç ï¼Œè¿™é‡Œä¼šè°ƒç”¨å‰é¢ç”Ÿæˆçš„æ¥å£ä»£ç†ç±»çš„æœ‰å‚æ„é€ æ–¹æ³•ã€‚å½¢å¦‚ï¼š * public Object newInstance(java.lang.reflect.InvocationHandler h) &#123; * return new com.alibaba.demo.proxy0($1); * &#125; */ ccm.addMethod(\"public Object newInstance(\" + InvocationHandler.class.getName() + \" h)&#123; return new \" + pcn + \"($1); &#125;\"); // ç”ŸæˆProxyå®ç°ç±» Class&lt;?&gt; pc = ccm.toClass(); /** * é€šè¿‡åå°„åˆ›å»ºProxyå­ç±»çš„å¯¹è±¡ */ proxy = (Proxy) pc.newInstance(); &#125; catch (RuntimeException e) &#123; throw e; &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage(), e); &#125; finally &#123; // release ClassGenerator if (ccp != null) &#123; // é‡Šæ”¾èµ„æº ccp.release(); &#125; if (ccm != null) &#123; ccm.release(); &#125; synchronized (cache) &#123; if (proxy == null) &#123; cache.remove(key); &#125; else &#123; // ç¼“å­˜ï¼Œæ³¨æ„å¼±å¼•ç”¨ cache.put(key, new WeakReference&lt;Proxy&gt;(proxy)); &#125; // å”¤é†’å…¶ä»–ç­‰å¾…çº¿ç¨‹ cache.notifyAll(); &#125; &#125; return proxy; &#125; /** * ç”Ÿæˆè¿”å›è¯­å¥ * * @param cl * @param name * @return */ private static String asArgument(Class&lt;?&gt; cl, String name) &#123; if (cl.isPrimitive()) &#123; if (Boolean.TYPE == cl) &#123; return name + \"==null?false:((Boolean)\" + name + \").booleanValue()\"; &#125; if (Byte.TYPE == cl) &#123; return name + \"==null?(byte)0:((Byte)\" + name + \").byteValue()\"; &#125; if (Character.TYPE == cl) &#123; return name + \"==null?(char)0:((Character)\" + name + \").charValue()\"; &#125; if (Double.TYPE == cl) &#123; return name + \"==null?(double)0:((Double)\" + name + \").doubleValue()\"; &#125; if (Float.TYPE == cl) &#123; return name + \"==null?(float)0:((Float)\" + name + \").floatValue()\"; &#125; if (Integer.TYPE == cl) &#123; return name + \"==null?(int)0:((Integer)\" + name + \").intValue()\"; &#125; if (Long.TYPE == cl) &#123; return name + \"==null?(long)0:((Long)\" + name + \").longValue()\"; &#125; if (Short.TYPE == cl) &#123; return name + \"==null?(short)0:((Short)\" + name + \").shortValue()\"; &#125; throw new RuntimeException(name + \" is unknown primitive type.\"); &#125; return \"(\" + ReflectUtils.getName(cl) + \")\" + name; &#125; /** * get instance with default handler. * * @return instance. */ public Object newInstance() &#123; return newInstance(THROW_UNSUPPORTED_INVOKER); &#125; /** * get instance with special handler. * * @return instance. */ abstract public Object newInstance(InvocationHandler handler);&#125; Proxy ç±»æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œå…¶é€»è¾‘æ“ä½œä¸»è¦æ˜¯ä½¿ç”¨ Javassist API ï¼Œå·²å‚è€ƒå®˜æ–¹æ–‡æ¡£è¿›è¡Œè¯¦ç»†æ³¨é‡Šã€‚è¯¥ç±»ä¸»è¦åšäº†ä¸¤ä»¶äº‹ï¼Œä¹Ÿå³æ„å»ºäº†ä¸¤ä¸ªç±»ï¼š 1 ä¸ºæœåŠ¡æ¥å£åˆ›å»ºä»£ç†ç±»ï¼Œè¿™ä¸ªä»£ç†ç±»æ„å»ºå®Œæˆåå…ˆæ”¾å…¥å†…å­˜ä¸­2 æ„å»º Proxy çš„å®ç°ç±»å¹¶åˆ›å»ºè¯¥å®ç°ç±»çš„å¯¹è±¡ï¼Œåˆ›å»ºçš„æœåŠ¡æ¥å£ä»£ç†ç±»çš„åˆå§‹åŒ–å°±æ˜¯åœ¨ Proxy å®ç°ç±»çš„ newInstance æ–¹æ³•ä¸­è¿›è¡Œçš„ æœåŠ¡æ¥å£ä»£ç†ç±» 12345678910111213141516171819202122232425262728293031323334353637// å®˜æ–¹DemoæœåŠ¡æ¥å£ç”Ÿæˆçš„ä»£ç†ç±»package com.alibaba.dubbo.common.bytecode;import com.alibaba.dubbo.demo.DemoService;import com.alibaba.dubbo.rpc.service.EchoService;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class proxy0 implements EchoService, DemoService &#123; public static Method[] methods; private InvocationHandler handler; // æœåŠ¡æ¥å£æ–¹æ³•ï¼Œç”±ä»£ç†ç±»æ¥æ‰§è¡Œ public String sayHello(String paramString) &#123; Object[] arrayOfObject = new Object[1]; arrayOfObject[0] = paramString; // proxy.method =&gt; InvocationHandler.invoke ã€è¿™é‡Œæ˜¯è°ƒç”¨ç›®æ ‡æ–¹æ³•çš„å…¥å£ï¼Œå³é€šè¿‡ InvocationHandler.invoke() æ–¹æ³•è°ƒç”¨ç›®æ ‡æ–¹æ³• ã€‘ Object localObject = this.handler.invoke(this, methods[0], arrayOfObject); return (String) localObject; &#125; // å›å£°æ¢æµ‹æ–¹æ³• public Object $echo(Object paramObject) &#123; Object[] arrayOfObject = new Object[1]; arrayOfObject[0] = paramObject; Object localObject = this.handler.invoke(this, methods[1], arrayOfObject); return (Object) localObject; &#125; public proxy0() &#123; &#125; // æœ‰å‚æ•°æ„é€ æ–¹æ³• public proxy0(InvocationHandler paramInvocationHandler) &#123; this.handler = paramInvocationHandler; &#125;&#125; Proxy çš„å­ç±» 1234567891011package com.alibaba.dubbo.common.bytecode;import java.lang.reflect.InvocationHandler;public class Proxy0 extends Proxy &#123; // å®ç° Proxy çš„æŠ½è±¡æ–¹æ³• public Object newInstance(InvocationHandler paramInvocationHandler) &#123; // åˆ›å»ºæœåŠ¡æ¥å£çš„ä»£ç†å¯¹è±¡ï¼Œæ„é€ å‚æ•°ä¸º InvocationHandler return new proxy0(paramInvocationHandler); &#125;&#125; æ³¨æ„ï¼šProxy å®ä¾‹å¯¹è±¡å’ŒæœåŠ¡æ²¡æœ‰ç›´æ¥å…³ç³»çš„ï¼ŒProxy å®ä¾‹å¯¹è±¡æ˜¯ç”¨æ¥åˆ›å»ºæœåŠ¡çš„ä»£ç†å¯¹è±¡çš„ã€‚åœ¨ä¸‹ä¸€ç¯‡æ–‡ç«  JavassiståŠ¨æ€ä»£ç† ä¸­ä¼šä½¿ç”¨åˆ°Proxyå®ä¾‹å¯¹è±¡ï¼Œè¿™é‡Œå…ˆåˆ†æå…¶ç”ŸæˆåŸç†åŠå…¶ä½œç”¨ã€‚ Wrapperè¯¥ç±»ä½äº dubbo-common æ¨¡å—ä¸‹ï¼Œæ˜¯ Dubbo æ¡†æ¶è‡ªå®šä¹‰çš„ç±»ï¼Œç”¨äºåŒ…è£¹ç›®æ ‡ç±»ï¼Œä»¥é¿å…åå°„è°ƒç”¨æé«˜æ€§èƒ½ã€‚WrapperåŒæ ·æ˜¯åŸºäº Javassit API è¿›è¡Œä»£ç ç”Ÿæˆã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572package com.alibaba.dubbo.common.bytecode;public abstract class Wrapper &#123; /** * Wrapperç¼“å­˜å¯¹è±¡ * key: Wrapper åŒ…è£…çš„ç±» * value: Wrapperå¯¹è±¡ */ private static final Map&lt;Class&lt;?&gt;, Wrapper&gt; WRAPPER_MAP = new ConcurrentHashMap&lt;Class&lt;?&gt;, Wrapper&gt;(); /** * String[] */ private static final String[] EMPTY_STRING_ARRAY = new String[0]; /** * Object ä¸­çš„éƒ¨åˆ†æ–¹æ³• */ private static final String[] OBJECT_METHODS = new String[]&#123;\"getClass\", \"hashCode\", \"toString\", \"equals\"&#125;; /** * åˆ›å»ºåŒ¿åå¯¹è±¡ï¼Œè¿™ä¸ªä»…ä»…é’ˆå¯¹ç›®æ ‡ç±»æ˜¯Object çš„æƒ…å†µ */ private static final Wrapper OBJECT_WRAPPER = new Wrapper() &#123; @Override public String[] getMethodNames() &#123; return OBJECT_METHODS; &#125; @Override public String[] getDeclaredMethodNames() &#123; return OBJECT_METHODS; &#125; @Override public String[] getPropertyNames() &#123; return EMPTY_STRING_ARRAY; &#125; @Override public Class&lt;?&gt; getPropertyType(String pn) &#123; return null; &#125; @Override public Object getPropertyValue(Object instance, String pn) throws NoSuchPropertyException &#123; throw new NoSuchPropertyException(\"Property [\" + pn + \"] not found.\"); &#125; @Override public void setPropertyValue(Object instance, String pn, Object pv) throws NoSuchPropertyException &#123; throw new NoSuchPropertyException(\"Property [\" + pn + \"] not found.\"); &#125; @Override public boolean hasProperty(String name) &#123; return false; &#125; @Override public Object invokeMethod(Object instance, String mn, Class&lt;?&gt;[] types, Object[] args) throws NoSuchMethodException &#123; if (\"getClass\".equals(mn)) &#123; return instance.getClass(); &#125; if (\"hashCode\".equals(mn)) &#123; return instance.hashCode(); &#125; if (\"toString\".equals(mn)) &#123; return instance.toString(); &#125; if (\"equals\".equals(mn)) &#123; if (args.length == 1) &#123; return instance.equals(args[0]); &#125; throw new IllegalArgumentException(\"Invoke method [\" + mn + \"] argument number error.\"); &#125; throw new NoSuchMethodException(\"Method [\" + mn + \"] not found.\"); &#125; &#125;; private static AtomicLong WRAPPER_CLASS_COUNTER = new AtomicLong(0); /** * å…³é”®ä¸€ç‚¹ï¼š å®ç°çš„invokeMethodæ–¹æ³•å°è£…äº†ä¼ å…¥çš„Classçš„æ–¹æ³• * * @param c Class instance. * @return Wrapper instance(not null). */ public static Wrapper getWrapper(Class&lt;?&gt; c) &#123; // can not wrapper on dynamic class. /** * 1 ClassGeneratoræ˜¯ç±»ç”Ÿæˆå™¨ï¼ŒåŸºäºJavassistå®ç°ã€‚ * 2 åˆ¤æ–­æ˜¯å¦ç»§æ‰¿ClassGenerator.DC.classï¼Œå¦‚æœæ˜¯å°±æ‹¿åˆ°çˆ¶ç±»ï¼Œé¿å…é‡å¤åŒ…è£… */ while (ClassGenerator.isDynamicClass(c)) &#123; c = c.getSuperclass(); &#125; // å¦‚æœæ˜¯Object.classå°±ç›´æ¥è¿”å›åˆ›å»ºçš„åŒ¿åWrapper if (c == Object.class) &#123; return OBJECT_WRAPPER; &#125; // ä»ç¼“å­˜ä¸­è·å¾—Wrapper Wrapper ret = WRAPPER_MAP.get(c); if (ret == null) &#123; // ç¼“å­˜æœªå‘½ä¸­ï¼Œåˆ›å»ºWrapper ret = makeWrapper(c); // å†™å…¥ç¼“å­˜ WRAPPER_MAP.put(c, ret); &#125; return ret; &#125; /** * åˆ›å»ºWrapper * * @param c * @return */ private static Wrapper makeWrapper(Class&lt;?&gt; c) &#123; // -------------------------------------------------- 1 ç»„è£…ã€åˆ›å»ºWrapperå®ä¾‹çš„å‡†å¤‡å·¥ä½œ ----------------------------------------------------/ // æ£€æµ‹ c æ˜¯å¦ä¸ºåŸºæœ¬ç±»å‹ï¼Œè‹¥æ˜¯åˆ™æŠ›å‡ºå¼‚å¸¸ if (c.isPrimitive()) &#123; throw new IllegalArgumentException(\"Can not create wrapper for primitive type: \" + c); &#125; // ç±»å String name = c.getName(); // ç±»åŠ è½½å™¨ ClassLoader cl = ClassHelper.getClassLoader(c); /** * c1 ç”¨äºå­˜å‚¨ setPropertyValue æ–¹æ³•ä»£ç  */ StringBuilder c1 = new StringBuilder(\"public void setPropertyValue(Object o, String n, Object v)&#123; \"); /** * c2 ç”¨äºå­˜å‚¨getPropertyValue æ–¹æ³•ä»£ç  */ StringBuilder c2 = new StringBuilder(\"public Object getPropertyValue(Object o, String n)&#123; \"); /** * c3 ç”¨äºå­˜å‚¨ invokeMethod æ–¹æ³•ä»£ç  */ StringBuilder c3 = new StringBuilder(\"public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws \" + InvocationTargetException.class.getName() + \"&#123; \"); /** * æ·»åŠ æ¯ä¸ªæ–¹æ³•çš„è¢«è°ƒç”¨å¯¹è±¡çš„ç±»å‹è½¬æ¢çš„ä»£ç ã€‚å³ç”Ÿæˆç±»å‹è½¬æ¢ä»£ç åŠå¼‚å¸¸æ•æ‰ä»£ç ï¼Œå¦‚ï¼š DemoService w; try &#123; w = ((DemoServcie) $1); &#125;&#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125; */ c1.append(name).append(\" w; try&#123; w = ((\").append(name).append(\")$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;\"); c2.append(name).append(\" w; try&#123; w = ((\").append(name).append(\")$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;\"); c3.append(name).append(\" w; try&#123; w = ((\").append(name).append(\")$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;\"); /** * pts ç”¨äºå­˜å‚¨æˆå‘˜å˜é‡åå’Œç±»å‹ */ Map&lt;String, Class&lt;?&gt;&gt; pts = new HashMap&lt;String, Class&lt;?&gt;&gt;(); // &lt;property name, property types&gt; /** * ms ç”¨äºå­˜å‚¨æ–¹æ³•ç­¾å åŠ Method å®ä¾‹ */ Map&lt;String, Method&gt; ms = new LinkedHashMap&lt;String, Method&gt;(); // &lt;method desc, Method instance&gt; /** * mns ä¸ºæ–¹æ³•ååˆ—è¡¨ */ List&lt;String&gt; mns = new ArrayList&lt;String&gt;(); // method names. /** * dmns ç”¨äºå­˜å‚¨å®šä¹‰åœ¨å½“å‰ç±»ä¸­çš„æ–¹æ³•çš„åç§° */ List&lt;String&gt; dmns = new ArrayList&lt;String&gt;(); // declaring method names. // -------------------------------------------------- 2 è§£æç›®æ ‡ç±»çš„å±æ€§ ----------------------------------------------------/ // è·å–public è®¿é—®çº§åˆ«çš„å­—æ®µï¼Œå¹¶ä¸ºæ‰€æœ‰å­—æ®µç”Ÿæˆæ¡ä»¶åˆ¤æ–­è¯­å¥ for (Field f : c.getFields()) &#123; String fn = f.getName(); Class&lt;?&gt; ft = f.getType(); // å¿½ç•¥å…³é”®å­— static æˆ– transient ä¿®é¥°çš„å˜é‡ if (Modifier.isStatic(f.getModifiers()) || Modifier.isTransient(f.getModifiers())) &#123; continue; &#125; // ç”Ÿæˆæ¡ä»¶åˆ¤æ–­åŠèµ‹å€¼è¯­å¥ï¼Œå¦‚ï¼šif($2.equals(\"name\"))&#123;w.name = (java.lang.String)$3;return;&#125; c1.append(\" if( $2.equals(\\\"\").append(fn).append(\"\\\") )&#123; w.\").append(fn).append(\"=\").append(arg(ft, \"$3\")).append(\"; return; &#125;\"); // ç”Ÿæˆæ¡ä»¶åˆ¤æ–­åŠè¿”å›è¯­å¥ï¼Œå¦‚: if($2.equals(\"name\"))&#123;return ($w)w.name;&#125; c2.append(\" if( $2.equals(\\\"\").append(fn).append(\"\\\") )&#123; return ($w)w.\").append(fn).append(\"; &#125;\"); // å­˜å‚¨ &lt;å­—æ®µåï¼Œå­—æ®µç±»å‹&gt; èµ‹å€¼å¯¹åˆ°ptsä¸­ pts.put(fn, ft); &#125; // -------------------------------------------------- 3 è§£æç›®æ ‡ç±»çš„æ–¹æ³• ---------------------------------------------------/ // è·å–ç›®æ ‡ç±»ä¸­çš„æ–¹æ³•åˆ—è¡¨ Method[] methods = c.getMethods(); // get all public method. // æ£€æµ‹ç›®æ ‡ç±»ä¸­æ˜¯å¦åŒ…å«åœ¨å½“å‰ç±»ä¸­å£°æ˜çš„æ–¹æ³• boolean hasMethod = hasMethods(methods); if (hasMethod) &#123; c3.append(\" try&#123;\"); &#125; for (Method m : methods) &#123; // å¿½ç•¥Ojbect ä¸­å®šä¹‰çš„æ–¹æ³• if (m.getDeclaringClass() == Object.class) &#123; continue; &#125; String mn = m.getName(); // ç”Ÿæˆæ–¹æ³•ååˆ¤æ–­è¯­å¥ï¼Œå¦‚ï¼šif ( \"sayHello\".equals( $2 ) c3.append(\" if( \\\"\").append(mn).append(\"\\\".equals( $2 ) \"); int len = m.getParameterTypes().length; // ç”Ÿæˆè¿è¡Œæ—¶ä¼ å…¥å‚æ•°çš„æ•°é‡ä¸æ–¹æ³•çš„å‚æ•°åˆ—è¡¨é•¿åº¦åˆ¤è¯»è¯­å¥ï¼Œå¦‚ï¼š&amp;&amp; $3.length == 2 c3.append(\" &amp;&amp; \").append(\" $3.length == \").append(len); // è‹¥ç›¸åŒæ–¹æ³•åå­˜åœ¨å¤šä¸ªï¼Œå¢åŠ å‚æ•°ç±»å‹æ•°ç»„çš„æ¯”è¾ƒåˆ¤æ–­ boolean override = false; for (Method m2 : methods) &#123; // æ£€æµ‹æ–¹æ³•æ˜¯å¦å­˜åœ¨é‡è½½æƒ…å†µï¼Œæ¡ä»¶ä¸ºï¼šæ–¹æ³•å¯¹è±¡ä¸åŒ &amp;&amp; æ–¹æ³•åç›¸åŒ if (m != m2 &amp;&amp; m.getName().equals(m2.getName())) &#123; override = true; break; &#125; &#125; /** * å¯¹é‡è½½æ–¹æ³•è¿›è¡Œå¤„ç†ï¼Œè€ƒè™‘ä¸‹é¢çš„æ–¹æ³•ï¼š * 1 void sayHello(Integer,String) * 2 void sayHello(Integer,Integer) * æ–¹æ³•åç›¸åŒï¼Œå‚æ•°åˆ—è¡¨é•¿åº¦ä¹Ÿç›¸åŒï¼Œå› æ­¤ä¸èƒ½ä»…é€šè¿‡ä¸Šé¢ä¸¤ä¸ªæ¡ä»¶åˆ¤æ–­ä¸¤ä¸ªæ–¹æ³•æ˜¯å¦ç›¸ç­‰ï¼Œéœ€è¦è¿›ä¸€æ­¥åˆ¤æ–­æ–¹æ³•çš„å‚æ•°ç±»å‹ */ if (override) &#123; if (len &gt; 0) &#123; for (int l = 0; l &lt; len; l++) &#123; /** * &amp;&amp; $3[0].getName().equals(\"java.lang.Integer\") &amp;&amp; $3[1].getName().equals(\"java.lang.String\") */ c3.append(\" &amp;&amp; \").append(\" $3[\").append(l).append(\"].getName().equals(\\\"\") .append(m.getParameterTypes()[l].getName()).append(\"\\\")\"); &#125; &#125; &#125; /** * æ·»åŠ  )&#123;,å®Œæˆæ–¹æ³•åˆ¤æ–­è¯­å¥ï¼Œæ­¤æ—¶ç”Ÿæˆçš„æ–¹æ³•å¯èƒ½å¦‚ä¸‹ï¼š * if(\"sayHello\".equals($2) &amp;&amp; $3.length == 2 &amp;&amp; $3[0].getName().equals(\"java.lang.Integer\") &amp;&amp; $3[1].getName().equals(\"java.lang.String\") */ c3.append(\" ) &#123; \"); // æ ¹æ®è¿”å›å€¼ç±»å‹ç”Ÿæˆç›®æ ‡æ–¹æ³•è°ƒç”¨è¯­å¥ if (m.getReturnType() == Void.TYPE) &#123; // w.sayHello((java.lang.Integer)$4[0],(java.lang.String)$4[1]); return null; c3.append(\" w.\").append(mn).append('(').append(args(m.getParameterTypes(), \"$4\")).append(\");\").append(\" return null;\"); &#125; else &#123; // return w.sayHello((java.lang.Integer)$4[0],(java.lang.String)$4[1]) c3.append(\" return ($w)w.\").append(mn).append('(').append(args(m.getParameterTypes(), \"$4\")).append(\");\"); &#125; /** * æ·»åŠ  &#125; ï¼Œç›®æ ‡æ–¹æ³•è°ƒç”¨è¯­å¥ç”Ÿæˆå®Œæ¯•ï¼Œå¦‚ä¸‹ï¼š * * if(\"sayHello\".equals($2) &amp;&amp; $3.length == 2 &amp;&amp; $3[0].getName().equals(\"java.lang.Integer\") &amp;&amp; $3[1].getName().equals(\"java.lang.String\") * w.sayHello((java.lang.Integer)$4[0],(java.lang.String)$4[1]); return null; * return null; * &#125; */ c3.append(\" &#125;\"); // æ·»åŠ æ–¹æ³•ååˆ°mnsé›†åˆä¸­ mns.add(mn); // æ£€æµ‹å½“å‰æ–¹æ³•æ˜¯å¦åœ¨cä¸­è¢«å£°æ˜ if (m.getDeclaringClass() == c) &#123; // è‹¥æ˜¯ï¼Œåˆ™å°†å½“å‰æ–¹æ³•åæ·»åŠ åˆ°dmnsä¸­ dmns.add(mn); &#125; ms.put(ReflectUtils.getDesc(m), m); &#125; // å¦‚æœæœ‰æ–¹æ³•ï¼Œå°±æ·»åŠ  invokeMethod(o,n,p,v) çš„ catch çš„ä»£ç  if (hasMethod) &#123; // æ·»åŠ å¼‚å¸¸æ•è·è¯­å¥ c3.append(\" &#125; catch(Throwable e) &#123; \"); c3.append(\" throw new java.lang.reflect.InvocationTargetException(e); \"); c3.append(\" &#125;\"); &#125; // æ·»åŠ  invokeMethod(o,n,p,v) çš„æœªåŒ¹é…åˆ°æ–¹æ³•çš„ä»£ç ã€‚å³æ·»åŠ NoSuchMethodException å¼‚å¸¸æŠ›å‡ºä»£ç  c3.append(\" throw new \" + NoSuchMethodException.class.getName() + \"(\\\"Not found method \\\\\\\"\\\"+$2+\\\"\\\\\\\" in class \" + c.getName() + \".\\\"); &#125;\"); //----------------------------------------------4 è§£æç›®æ ‡ç±»å±æ€§æ“ä½œæ–¹æ³•ï¼Œsetter/getter ----------------------------------------------------------/ // å¾ªç¯ setting/getting æ–¹æ³•ï¼Œæ·»åŠ æ¯ä¸ªå±æ€§çš„è®¾ç½®å’Œè·å¾—åˆ†åˆ«åˆ° `#setPropertyValue(o, n, v)` å’Œ `#getPropertyValue(o, n)` çš„ä»£ç  Matcher matcher; // å¤„ç†get/setæ–¹æ³• for (Map.Entry&lt;String, Method&gt; entry : ms.entrySet()) &#123; String md = entry.getKey(); Method method = entry.getValue(); // åŒ¹é…ä»¥getå¼€å¤´çš„æ–¹æ³• if ((matcher = ReflectUtils.GETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) &#123; // è·å–å±æ€§å String pn = propertyName(matcher.group(1)); // ç”Ÿæˆå±æ€§åˆ¤æ–­ä»¥åŠè¿”å›è¯­å¥ï¼Œç¤ºä¾‹å¦‚ï¼š if($2.equals(\"name\")) &#123; return ($w).w.getName()&#125; c2.append(\" if( $2.equals(\\\"\").append(pn).append(\"\\\") )&#123; return ($w)w.\").append(method.getName()).append(\"(); &#125;\"); pts.put(pn, method.getReturnType()); // åŒ¹é…ä»¥is/has/can å¼€å¤´çš„æ–¹æ³• &#125; else if ((matcher = ReflectUtils.IS_HAS_CAN_METHOD_DESC_PATTERN.matcher(md)).matches()) &#123; String pn = propertyName(matcher.group(1)); // ç”Ÿæˆå±æ€§åˆ¤æ–­ä»¥åŠ è¿”å›è¯­å¥ï¼Œå¦‚ï¼š if($2.equals(\"dream\"))&#123;return ($w)w.hasDream();&#125; c2.append(\" if( $2.equals(\\\"\").append(pn).append(\"\\\") )&#123; return ($w)w.\").append(method.getName()).append(\"(); &#125;\"); pts.put(pn, method.getReturnType()); // åŒ¹é…ä»¥set å¼€å¤´çš„æ–¹æ³• &#125; else if ((matcher = ReflectUtils.SETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) &#123; Class&lt;?&gt; pt = method.getParameterTypes()[0]; String pn = propertyName(matcher.group(1)); // ç”Ÿæˆå±æ€§åˆ¤æ–­ä»¥åŠsetter è°ƒç”¨è¯­å¥ï¼Œå¦‚ï¼š if($2.equals(\"name\"))&#123;w.setName(java.lang.String)$3);return;&#125; c1.append(\" if( $2.equals(\\\"\").append(pn).append(\"\\\") )&#123; w.\").append(method.getName()).append(\"(\").append(arg(pt, \"$3\")).append(\"); return; &#125;\"); pts.put(pn, pt); &#125; &#125; // æ·»åŠ  NoSuchPropertyException å¼‚å¸¸æŠ›å‡ºè¯­å¥ c1.append(\" throw new \" + NoSuchPropertyException.class.getName() + \"(\\\"Not found property \\\\\\\"\\\"+$2+\\\"\\\\\\\" filed or setter method in class \" + c.getName() + \".\\\"); &#125;\"); c2.append(\" throw new \" + NoSuchPropertyException.class.getName() + \"(\\\"Not found property \\\\\\\"\\\"+$2+\\\"\\\\\\\" filed or setter method in class \" + c.getName() + \".\\\"); &#125;\"); //--------------------------------------------------- 5 ä¸ºä¸Šé¢ç”Ÿæˆçš„ä»£ç æ„å»º Class ç±»å¹¶ç»„ã€å°„åˆ›å»º Wrapper å®ä¾‹ ---------------------------------------------------/ // make class long id = WRAPPER_CLASS_COUNTER.getAndIncrement(); // åˆ›å»ºç±»ç”Ÿæˆå™¨ ClassGenerator cc = ClassGenerator.newInstance(cl); // è®¾ç½®ç±»å cc.setClassName((Modifier.isPublic(c.getModifiers()) ? Wrapper.class.getName() : c.getName() + \"$sw\") + id); // è®¾ç½®çˆ¶ç±»ä¸º Wrapper.class cc.setSuperClass(Wrapper.class); // æ·»åŠ é»˜è®¤æ„é€ æ–¹æ³• cc.addDefaultConstructor(); // æ·»åŠ é™æ€å±æ€§ `pns` çš„ä»£ç  cc.addField(\"public static String[] pns;\"); // property name array. // æ·»åŠ é™æ€å±æ€§ `pts` çš„ä»£ç  cc.addField(\"public static \" + Map.class.getName() + \" pts;\"); // property type map. // æ·»åŠ é™æ€å±æ€§ `mns` çš„ä»£ç  cc.addField(\"public static String[] mns;\"); // all method name array. // æ·»åŠ é™æ€å±æ€§ `dmns` çš„ä»£ç  cc.addField(\"public static String[] dmns;\"); // declared method name array. // æ·»åŠ é™æ€å±æ€§ `mts` çš„ä»£ç ã€‚æ¯ä¸ªæ–¹æ³•çš„å‚æ•°æ•°ç»„ã€‚ for (int i = 0, len = ms.size(); i &lt; len; i++) &#123; cc.addField(\"public static Class[] mts\" + i + \";\"); &#125; // ======= æ·»åŠ æŠ½è±¡æ–¹æ³•çš„å®ç°ï¼Œåˆ° `cc` ä¸­ // æ·»åŠ  `#getPropertyNames()` çš„ä»£ç åˆ° `cc` cc.addMethod(\"public String[] getPropertyNames()&#123; return pns; &#125;\"); // æ·»åŠ  `#hasProperty(n)` çš„ä»£ç åˆ° `cc` cc.addMethod(\"public boolean hasProperty(String n)&#123; return pts.containsKey($1); &#125;\"); // æ·»åŠ  `#getPropertyType(n)` çš„ä»£ç åˆ° `cc` cc.addMethod(\"public Class getPropertyType(String n)&#123; return (Class)pts.get($1); &#125;\"); // æ·»åŠ  `#getMethodNames()` çš„ä»£ç åˆ° `cc` cc.addMethod(\"public String[] getMethodNames()&#123; return mns; &#125;\"); // æ·»åŠ  `#getDeclaredMethodNames()` çš„ä»£ç åˆ° `cc` cc.addMethod(\"public String[] getDeclaredMethodNames()&#123; return dmns; &#125;\"); // æ·»åŠ  `#setPropertyValue(o, n, v)` çš„ä»£ç åˆ° `cc` cc.addMethod(c1.toString()); // æ·»åŠ  `#getPropertyValue(o, n)` çš„ä»£ç åˆ° `cc` cc.addMethod(c2.toString()); // æ·»åŠ  `#invokeMethod(o, n, p, v)` çš„ä»£ç åˆ° `cc` cc.addMethod(c3.toString()); try &#123; // ç”Ÿæˆç±»ï¼Œé€šè¿‡javassistæ„å»º Class&lt;?&gt; wc = cc.toClass(); // åå°„ï¼Œè®¾ç½®é™æ€å˜é‡çš„å€¼ wc.getField(\"pts\").set(null, pts); wc.getField(\"pns\").set(null, pts.keySet().toArray(new String[0])); wc.getField(\"mns\").set(null, mns.toArray(new String[0])); wc.getField(\"dmns\").set(null, dmns.toArray(new String[0])); int ix = 0; for (Method m : ms.values()) &#123; wc.getField(\"mts\" + ix++).set(null, m.getParameterTypes()); &#125; // é€šè¿‡åå°„åˆ›å»ºå¯¹è±¡ åˆ›å»ºWrapper å®ä¾‹ return (Wrapper) wc.newInstance(); &#125; catch (RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; throw new RuntimeException(e.getMessage(), e); &#125; finally &#123; // é‡Šæ”¾èµ„æº cc.release(); ms.clear(); mns.clear(); dmns.clear(); &#125; &#125; // æ–¹æ³•è¿”å›è¯­å¥ private static String arg(Class&lt;?&gt; cl, String name) &#123; if (cl.isPrimitive()) &#123; if (cl == Boolean.TYPE) &#123; return \"((Boolean)\" + name + \").booleanValue()\"; &#125; if (cl == Byte.TYPE) &#123; return \"((Byte)\" + name + \").byteValue()\"; &#125; if (cl == Character.TYPE) &#123; return \"((Character)\" + name + \").charValue()\"; &#125; if (cl == Double.TYPE) &#123; return \"((Number)\" + name + \").doubleValue()\"; &#125; if (cl == Float.TYPE) &#123; return \"((Number)\" + name + \").floatValue()\"; &#125; if (cl == Integer.TYPE) &#123; return \"((Number)\" + name + \").intValue()\"; &#125; if (cl == Long.TYPE) &#123; return \"((Number)\" + name + \").longValue()\"; &#125; if (cl == Short.TYPE) &#123; return \"((Number)\" + name + \").shortValue()\"; &#125; throw new RuntimeException(\"Unknown primitive type: \" + cl.getName()); &#125; return \"(\" + ReflectUtils.getName(cl) + \")\" + name; &#125; private static String args(Class&lt;?&gt;[] cs, String name) &#123; int len = cs.length; if (len == 0) &#123; return \"\"; &#125; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; len; i++) &#123; if (i &gt; 0) &#123; sb.append(','); &#125; sb.append(arg(cs[i], name + \"[\" + i + \"]\")); &#125; return sb.toString(); &#125; private static String propertyName(String pn) &#123; return pn.length() == 1 || Character.isLowerCase(pn.charAt(1)) ? Character.toLowerCase(pn.charAt(0)) + pn.substring(1) : pn; &#125; // æ˜¯å¦æ˜¯æœ‰æ•ˆçš„æ–¹æ³• private static boolean hasMethods(Method[] methods) &#123; if (methods == null || methods.length == 0) &#123; return false; &#125; for (Method m : methods) &#123; // æœ‰ä¸€ä¸ªä¸æ˜¯Objectä¸­å®šä¹‰çš„æ–¹æ³•å°±è¯´æ˜ç¬¦åˆæ¡ä»¶ if (m.getDeclaringClass() != Object.class) &#123; return true; &#125; &#125; return false; &#125; /** * get property name array. * * @return property name array. */ abstract public String[] getPropertyNames(); /** * get property type. * * @param pn property name. * @return Property type or nul. */ abstract public Class&lt;?&gt; getPropertyType(String pn); /** * has property. * * @param name property name. * @return has or has not. */ abstract public boolean hasProperty(String name); /** * get property value. * * @param instance instance. * @param pn property name. * @return value. */ abstract public Object getPropertyValue(Object instance, String pn) throws NoSuchPropertyException, IllegalArgumentException; /** * set property value. * * @param instance instance. * @param pn property name. * @param pv property value. */ abstract public void setPropertyValue(Object instance, String pn, Object pv) throws NoSuchPropertyException, IllegalArgumentException; /** * get property value. * * @param instance instance. * @param pns property name array. * @return value array. */ public Object[] getPropertyValues(Object instance, String[] pns) throws NoSuchPropertyException, IllegalArgumentException &#123; Object[] ret = new Object[pns.length]; for (int i = 0; i &lt; ret.length; i++) &#123; ret[i] = getPropertyValue(instance, pns[i]); &#125; return ret; &#125; /** * set property value. * * @param instance instance. * @param pns property name array. * @param pvs property value array. */ public void setPropertyValues(Object instance, String[] pns, Object[] pvs) throws NoSuchPropertyException, IllegalArgumentException &#123; if (pns.length != pvs.length) &#123; throw new IllegalArgumentException(\"pns.length != pvs.length\"); &#125; for (int i = 0; i &lt; pns.length; i++) &#123; setPropertyValue(instance, pns[i], pvs[i]); &#125; &#125; /** * get method name array. * * @return method name array. */ abstract public String[] getMethodNames(); /** * get method name array. * * @return method name array. */ abstract public String[] getDeclaredMethodNames(); /** * has method. * * @param name method name. * @return has or has not. */ public boolean hasMethod(String name) &#123; for (String mn : getMethodNames()) &#123; if (mn.equals(name)) &#123; return true; &#125; &#125; return false; &#125; /** * æŠ½è±¡æ–¹æ³•ï¼ŒDubboåœ¨è¿è¡Œæ—¶ä¼šé€šè¿‡ Javassist æ¡†æ¶ ä¸º Wrapperç”Ÿæˆå®ç°ç±»ï¼Œå¹¶å®ç°è¯¥æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¼šæ ¹æ®è°ƒç”¨ä¿¡æ¯è°ƒç”¨å…·ä½“çš„æœåŠ¡ * * @param instance è¢«è°ƒç”¨çš„å¯¹è±¡ * @param mn æ–¹æ³•å * @param types å‚æ•°ç±»å‹æ•°ç»„ * @param args å‚æ•°æ•°ç»„ * @return è¿”å›å€¼ */ abstract public Object invokeMethod(Object instance, String mn, Class&lt;?&gt;[] types, Object[] args) throws NoSuchMethodException, InvocationTargetException;&#125; Wrapper ç±»çš„ä»£ç å¾ˆå¤šï¼Œä½†æ˜¯å°±åšä¸€ä»¶äº‹ï¼Œå¯¹æ–¹æ³•è°ƒç”¨çš„åŒ…è£…ï¼Œä¸ºä»€ä¹ˆèƒ½åŒ…è£…ï¼Ÿ ä¸ºä»€ä¹ˆè¦åŒ…è£…ï¼Ÿæ€ä¹ˆæ‰§è¡Œç›®æ ‡å¯¹è±¡æ–¹æ³•ï¼Ÿ 1 Wrapper æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œä»…å¯é€šè¿‡ getWrapper(Class) æ–¹æ³•åˆ›å»ºå­ç±»ç„¶ååå°„åˆ›å»ºå¯¹è±¡ã€‚åœ¨åˆ›å»º Wrapper å­ç±»çš„è¿‡ç¨‹ä¸­ï¼Œå­ç±»ä»£ç ç”Ÿæˆé€»è¾‘ä¼šå¯¹ getWrapper æ–¹æ³•ä¼ å…¥çš„ Class è¿›è¡Œè§£æï¼Œæ‹¿åˆ°å…¶æ–¹æ³•ï¼Œç±»æˆå‘˜å˜é‡ç­‰ä¿¡æ¯ï¼Œä»¥åŠç”Ÿæˆ invokeMethod æ–¹æ³•ä»£ç ç­‰ã€‚2 åŒ…è£…çš„ç›®çš„æ˜¯é¿å…åå°„è°ƒç”¨ï¼Œæé«˜æ€§èƒ½ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåˆ›å»º Wrapper å®ä¾‹è¿˜æ˜¯è¦é€šè¿‡åå°„çš„ã€‚3 åŒ…è£…åï¼Œåªéœ€æŠŠåŒ…è£…ç±»çš„å¯¹è±¡ã€æ–¹æ³•åŠå‚æ•°ä¼ å…¥invokeMethodæ–¹æ³•ä¸­ï¼Œæ— éœ€é€šè¿‡åå°„å°±èƒ½åŒ¹é…åˆ°æ–¹æ³•å¹¶æ‰§è¡Œ å¯ä»¥å‘ç° Wrapper é€»è¾‘çš„å¥—è·¯å’Œ Proxy å·®ä¸å¤šï¼Œéƒ½æ˜¯é€šè¿‡ Javassist API ç”Ÿæˆç±»å¹¶åå°„åˆ›å»ºå¯¹è±¡ã€‚ä»¥ Dubbo çš„å®˜æ–¹DemoæœåŠ¡æ¥å£ä¸ºä¾‹ï¼Œç”Ÿæˆçš„ Wrapper å®ç°ç±»æ•´ç†åå¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.alibaba.dubbo.common.bytecode;public class Wrapper0 extends Wrapper &#123; public static String[] pns; public static java.util.Map pts; public static String[] mns;, public static String[] dmns; public static Class[] mts0; public Wrapper0() &#123; &#125; public String[] getPropertyNames() &#123; return pns; &#125; public boolean hasProperty(String n) &#123; return pts.containsKey($1); &#125; public Class getPropertyType(String n) &#123; return (Class) pts.get($1); &#125; public String[] getMethodNames() &#123; return mns; &#125; public String[] getDeclaredMethodNames() &#123; return dmns; &#125; public void setPropertyValue(Object o, String n, Object v) &#123; com.alibaba.dubbo.demo.DemoService w; try &#123; w = ((com.alibaba.dubbo.demo.DemoService) $1); &#125; catch (Throwable e) &#123; throw new IllegalArgumentException(e); &#125; throw new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(\"Not found property \\\"\" + $2 + \"\\\" filed or setter method in class com.alibaba.dubbo.demo.DemoService.\"); &#125; public Object getPropertyValue(Object o, String n) &#123; com.alibaba.dubbo.demo.DemoService w; try &#123; w = ((com.alibaba.dubbo.demo.DemoService) $1); &#125; catch (Throwable e) &#123; throw new IllegalArgumentException(e); &#125; throw new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(\"Not found property \\\"\" + $2 + \"\\\" filed or setter method in class com.alibaba.dubbo.demo.DemoService.\"); &#125; /** * * @param o ç›®æ ‡ç±»å¯¹è±¡ * @param n æ–¹å * @param p å‚æ•°ç±»å‹ * @param v å‚æ•°å€¼ * @return * @throws java.lang.reflect.InvocationTargetException */ public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException &#123; com.alibaba.dubbo.demo.DemoService w; try &#123; w = ((com.alibaba.dubbo.demo.DemoService) $1); &#125; catch (Throwable e) &#123; throw new IllegalArgumentException(e); &#125; try &#123; if (\"sayHello\".equals($2) &amp;&amp; $3.length == 1) &#123; return ($w) w.sayHello((java.lang.String) $4[0]); &#125; &#125; catch (Throwable e) &#123; throw new java.lang.reflect.InvocationTargetException(e); &#125; throw new com.alibaba.dubbo.common.bytecode.NoSuchMethodException(\"Not found method \\\"\" + $2 + \"\\\" in class com.alibaba.dubbo.demo.DemoService.\"); &#125;&#125; å°ç»“æœ¬ç¯‡æ–‡ç« ä¸»è¦åˆ†æäº† Dubbo åŠ¨æ€ä»£ç†çš„æŠ½è±¡å±‚ï¼Œå…·ä½“çš„å®ç°æ˜¯é€šè¿‡ Dubbo SPI æ¥å†³ç­–çš„ã€‚æ­¤å¤–ï¼Œé‡ç‚¹ä»‹ç»äº† Proxy å’Œ Wrapper è¿™ä¸¤ä¸ªç±»ï¼ŒProxy ç±»ç”¨æ¥åˆ›å»ºæœåŠ¡æ¥å£ä»£ç†ç±»çš„å®ä¾‹ï¼ŒWrapper ç±»æ˜¯å¯¹æœåŠ¡ç±»è¿›è¡Œæ‹†è§£ã€åŒ…è£…ï¼Œå¯¹æœåŠ¡æ–¹æ³•è¿›è¡Œæ˜ å°„å¤„ç†ï¼Œé¿å…åå°„è°ƒç”¨ã€‚ æœåŠ¡æ¶ˆè´¹è€…ä½¿ç”¨Proxyåˆ›å»ºçš„æœåŠ¡ä»£ç†å¯¹è±¡å±è”½äº†ç½‘ç»œé€šä¿¡ç­‰ç»†èŠ‚ï¼ŒæœåŠ¡æä¾›è€…ä½¿ç”¨Wrapperå°†ä¸ªæ€§åŒ–çš„æœåŠ¡æ¥å£å®ç°ç»Ÿä¸€è½¬æˆInvokerï¼Œ Proxy å’Œ Wrapper å®ç°äº† Dubbo å†…éƒ¨å’Œä¸šåŠ¡æ¥å£ä¹‹é—´çš„æ— ç¼è½¬æ¢ã€‚åœ¨ä¹‹åçš„æœåŠ¡æš´éœ²ã€æœåŠ¡å¼•ç”¨ä»¥åŠæœåŠ¡è°ƒç”¨ç¯èŠ‚ä¸­å¯ä»¥çœ‹åˆ°å®ƒä»¬çš„å¿…è¦æ€§ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Javassist","slug":"Javassist","permalink":"https://gentryhuang.com/tags/Javassist/"}]},{"title":"Dubboæºç åˆ†æ - Redisæ³¨å†Œä¸­å¿ƒ","slug":"rpc/æ³¨å†Œä¸­å¿ƒä¹‹Redis","date":"2020-04-25T16:00:00.000Z","updated":"2020-10-13T11:46:23.954Z","comments":false,"path":"posts/b2453481/","link":"","permalink":"https://gentryhuang.com/posts/b2453481/","excerpt":"","text":"å‰è¨€åœ¨ æ³¨å†Œä¸­å¿ƒæ€»è§ˆ ä¸­ä»‹ç»äº† Dubbo çš„æ³¨å†Œä¸­å¿ƒæŠ½è±¡å±‚ï¼ŒåŒ…æ‹¬æ³¨å†Œä¸­å¿ƒåŠå…¶å·¥å‚ã€‚æœ¬ç¯‡æ–‡ç« å°†ä»‹ç» Dubbo çš„ Redis æ³¨å†Œä¸­å¿ƒåŠå…¶å·¥å‚ã€‚ UML å›¾ä¸­çš„ RedisRegistry ç±»ä¸­å®ç°äº† Redis ä½œä¸ºæ³¨å†Œä¸­å¿ƒçš„é€»è¾‘ï¼Œå…¶ä¸­ Redis çš„å®¢æˆ·ç«¯ä½¿ç”¨çš„æ˜¯ Jedis ã€‚ Dubbo ä¸­çš„ Redis æ³¨å†Œä¸­å¿ƒ Redis æ³¨å†Œä¸­å¿ƒä¹Ÿæ²¿ç”¨äº† Dubbo æŠ½è±¡çš„ Rootã€Serviceã€Typeã€URL å››å±‚ç»“æ„ã€‚åœ¨ Redis ä¸­æ•°æ®éƒ½æ˜¯ä»¥é”®å€¼å¯¹çš„å½¢å¼ä¿å­˜çš„ï¼Œå¹¶ä¸èƒ½åƒ Zookeeper ä¸€æ ·ç›´æ¥å®ç°æ ‘å½¢ç›®å½•ç»“æ„ã€‚å› æ­¤ï¼ŒRedis ä½¿ç”¨äº† key/Map ç»“æ„å­˜å‚¨æ•°æ®ï¼š ä¸»keyï¼šRootã€Serviceã€Type ç»„åˆæˆçš„å€¼ï¼Œå³æœåŠ¡åå’Œç±»å‹ï¼Œå¯¹åº”å›¾ä¸­ /dubbo/com.foo.BarService/providersä¸»keyçš„å€¼Mapä¸­çš„keyï¼šURLä¸²ï¼Œå¯¹åº”å›¾ä¸­ dubbo://10.20.153.10:123/barService=13658â€¦ä¸»keyçš„å€¼Mapä¸­çš„value: è¿‡æœŸæ—¶é—´ Zookeeper æ˜¯åŸºäºç›‘å¬å™¨æ¥æ„ŸçŸ¥æ•°æ®çš„å˜åŒ–ï¼Œè€Œ Redis ä½¿ç”¨åŸºäº Publish/Subscribe äº‹ä»¶é€šçŸ¥æ•°æ®å˜æ›´ï¼š é€šè¿‡äº‹ä»¶çš„å€¼åŒºåˆ†äº‹ä»¶æ¶ˆæ¯ç±»å‹ï¼šregister,unregisteræ™®é€šæ¶ˆè´¹è€…è®¢é˜…æŒ‡å®šçš„æœåŠ¡æä¾›è€…çš„Keyï¼Œåªä¼šæ”¶åˆ°æŒ‡å®šæœåŠ¡çš„ register,unregister äº‹ä»¶ç›‘æ§ä¸­å¿ƒè®¢é˜… /dubbo/*ï¼Œä¼šæ”¶åˆ°æ‰€æœ‰æœåŠ¡çš„æ‰€æœ‰å˜æ›´äº‹ä»¶ æ³¨æ„äº‹é¡¹ï¼š å½“å‰ Dubbo ç‰ˆæœ¬çš„ Redisæ³¨å†Œä¸­å¿ƒåªä¼šå‘é€ä¸¤ç§äº‹ä»¶ï¼Œåˆ†åˆ«å¯¹åº”æœåŠ¡æä¾›è€…ã€æœåŠ¡æ¶ˆè´¹è€…ã€åŠ¨æ€é…ç½®ã€è·¯ç”±é…ç½®çš„æ³¨å†Œä¸åæ³¨å†Œï¼Œå‘é€è¿™ä¸¤ä¸ªäº‹ä»¶çš„é€šé“Channelæ˜¯ç”±æœåŠ¡æ¥å£å†³å®šçš„ã€‚ æœåŠ¡å®ä¾‹çš„å¯åŠ¨æˆ–å…³é—­ï¼Œä¼šå†™å…¥æˆ–åˆ é™¤å¯¹åº”çš„æ•°æ®ï¼Œå¹¶é€šè¿‡é€šé“å‘å¸ƒå¯¹åº”çš„ registerï¼Œunregister äº‹ä»¶æ¶ˆæ¯ï¼Œä»è€Œä¿è¯å®æ—¶æ€§ã€‚ å¦‚æœä½¿ç”¨ç›‘æ§ä¸­å¿ƒï¼ˆä¼šè®¢é˜…/dubbo/*ï¼‰,Redis æ³¨å†Œä¸­å¿ƒä¼šå®šæ—¶è°ƒåº¦è§¦å‘æ¸…ç†é€»è¾‘ï¼Œä¿è¯æœªæ­£å¸¸å…³é—­çš„æœåŠ¡å®ä¾‹çš„ URL çš„åˆ é™¤ï¼Œå¹¶å‘èµ·å¯¹åº”çš„ unregister äº‹ä»¶æ¶ˆæ¯ï¼Œä»è€Œä¿è¯æ•°æ®çš„æœ€ç»ˆä¸€è‡´æ€§ã€‚ ä¸ä½¿ç”¨ Redis çš„è‡ªåŠ¨è¿‡æœŸæœºåˆ¶ï¼Œè€Œæ˜¯é€šè¿‡ç›‘æ§ä¸­å¿ƒå®ç°è¿‡æœŸæœºåˆ¶ï¼Œå› ä¸º Redis çš„keyè‡ªåŠ¨è¿‡æœŸä¸å­˜åœ¨ç›¸åº”çš„äº‹ä»¶æ¶ˆæ¯é€šçŸ¥ã€‚ é€‰é¡¹ å¯é€šè¿‡ &lt;dubbo:registry group=â€dubboâ€ /&gt; è®¾ç½® redis ä¸­ key çš„å‰ç¼€ï¼Œç¼ºçœä¸º dubboã€‚ å¯é€šè¿‡ &lt;dubbo:registry cluster=â€replicateâ€ /&gt; è®¾ç½® redis é›†ç¾¤ç­–ç•¥ï¼Œç¼ºçœä¸º failoverã€‚failover: åªå†™å…¥å’Œè¯»å–ä»»æ„ä¸€å°ï¼Œå¤±è´¥æ—¶é‡è¯•å¦ä¸€å°ï¼Œéœ€è¦æœåŠ¡å™¨ç«¯è‡ªè¡Œé…ç½®æ•°æ®åŒæ­¥ï¼Œreplicate: åœ¨å®¢æˆ·ç«¯åŒæ—¶å†™å…¥æ‰€æœ‰æœåŠ¡å™¨ï¼Œåªè¯»å–å•å°ï¼ŒæœåŠ¡å™¨ç«¯ä¸éœ€è¦åŒæ­¥ï¼Œæ³¨å†Œä¸­å¿ƒé›†ç¾¤å¢å¤§ï¼Œæ€§èƒ½å‹åŠ›ä¹Ÿä¼šæ›´å¤§ã€‚ æµç¨‹è¯´æ˜è®¢é˜…ä¸é€šçŸ¥æ˜¯æ³¨å†Œä¸­å¿ƒéå¸¸é‡è¦çš„åŠŸèƒ½ï¼Œä½¿ç”¨ Redis ä½œä¸ºæ³¨å†Œä¸­å¿ƒï¼Œå…¶è®¢é˜…ä¸é€šçŸ¥å®ç°æ–¹å¼ä¸ Zookeeper ä¸åŒã€‚Redis è®¢é˜…é€šçŸ¥æœºåˆ¶ä½¿ç”¨çš„æ˜¯ è¿‡æœŸæœºåˆ¶ å’Œ Publish/Subscribe æœºåˆ¶ã€‚ æœåŠ¡æä¾›è€…å¯åŠ¨æœåŠ¡æä¾›è€…å¯åŠ¨æ—¶ï¼Œé¦–å…ˆä¼šåœ¨ Redis ä¸­åˆ›å»ºçº¦å®šçš„k-vé”®å€¼å¯¹ï¼Œç„¶ååœ¨é€šé“ï¼ˆRoot + Service + Typeï¼‰ä¸­å‘å¸ƒä¸€æ¡ register äº‹ä»¶æ¶ˆæ¯ã€‚æ¥ç€æœåŠ¡æä¾›è€…ä¼šè®¢é˜…åŠ¨æ€é…ç½®ä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯åœ¨è®¢é˜…URLä¸­è®¾ç½® category=configurators ã€‚ä½†æ˜¯éœ€è¦è¯´æ˜çš„æ˜¯ï¼ŒRedis çš„è®¢é˜…å®ç°æ–¹å¼ä¸åŒ Zookeeper ï¼ŒZookeeper å¯ä»¥ç›´æ¥æ³¨å†Œå­èŠ‚ç‚¹ç›‘å¬å™¨ç›´æ¥ç›‘å¬ .../configurators ä¸‹çš„å­èŠ‚ç‚¹å˜åŒ–ï¼Œå¹¶ä¸”é¦–æ¬¡è®¢é˜…å°±å¯ä»¥è¿”å›å…¨é‡æ•°æ®ã€‚è€Œ Redis æ¯æ¬¡è®¢é˜…å¹¶æ²¡æœ‰è®¢é˜…è¯¦ç»†çš„Channelï¼Œå¦‚ /dubbo/com.foo.BarService/configuratorsï¼Œè€Œæ˜¯ç»Ÿä¸€è®¢é˜… Root + Service + *ï¼Œå¦‚ Channel:/dubbo/com.alibaba.dubbo.demo.DemoService/* ,è¿™æ ·ä¸€æ¥ä»»ä½•åªè¦æ˜¯ Root + Service åŒ¹é…åˆ°çš„é€šé“æœ‰æ¶ˆæ¯éƒ½å¯ä»¥è¢«è®¢é˜…é€šçŸ¥å¯¹è±¡æ„ŸçŸ¥åˆ°ã€‚é™¤æ­¤ä»¥å¤–ï¼Œä½¿ç”¨ Redis ä½œä¸ºæ³¨å†Œä¸­å¿ƒè¿›è¡Œé¦–æ¬¡è®¢é˜…çš„æ—¶å€™ï¼Œå½“å‰è®¢é˜…URLçš„ Root + Service æ²¡æœ‰å¯¹åº”çš„é€šçŸ¥å™¨æ—¶ä¼šä¸ºå…¶åˆ›å»ºé€šçŸ¥å™¨ï¼Œè¿™ä¸ªé€šçŸ¥å™¨å°±æ˜¯ç”¨æ¥è®¢é˜…é€šé“çš„ï¼Œ ç”±äº Redis æ²¡æœ‰åƒ Zookeeper é‚£æ ·ç»‘å®šç›‘å¬å™¨ï¼Œå› æ­¤é¦–æ¬¡è®¢é˜…éœ€è¦ä¸»åŠ¨ä½¿ç”¨ Redis å®¢æˆ·ç«¯è·å– Root + Service ä¸‹çš„æ‰€æœ‰åˆ†ç±»å³ Typeï¼Œç„¶åå†æ ¹æ®æ¯ä¸ªå…·ä½“çš„åˆ†ç±»è·å–å…¶å¯¹åº”çš„ URL åˆ—è¡¨ï¼Œæœ€åå°±æ˜¯ Dubbo çš„é€šçŸ¥é€»è¾‘äº†ã€‚ æœåŠ¡æ¶ˆè´¹è€…å¯åŠ¨æœåŠ¡æ¶ˆè´¹è€…å¯åŠ¨çš„æµç¨‹å’ŒæœåŠ¡æä¾›è€…å‡ ä¹ä¸€è‡´ï¼Œä¸åŒçš„æ˜¯ï¼Œåœ¨ Redis ä¸­åˆ›å»ºçš„k-vé˜Ÿæ˜¯æ¶ˆè´¹è€…çš„ï¼Œæ¶ˆè´¹è€…è®¢é˜…çš„ä¿¡æ¯é™¤äº†åŠ¨æ€é…ç½®ä¿¡æ¯ï¼Œè¿˜åŒ…æ‹¬æœåŠ¡æä¾›è€…ä¿¡æ¯å’Œè·¯ç”±ä¿¡æ¯ã€‚ ç›‘æ§ä¸­å¿ƒå¯åŠ¨ç›‘æ§ä¸­å¿ƒ(dubbo-admin)å¯åŠ¨çš„æ—¶å€™åªä¼šè¿›è¡Œè®¢é˜…ï¼Œè€Œä¸”è®¢é˜…çš„æ˜¯æ‰€æœ‰æœåŠ¡ä¿¡æ¯ï¼Œå³è®¢é˜…çš„é€šé“ä¸º /dubbo/*ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒä¼šè®¢é˜…æ‰€æœ‰æœåŠ¡çš„ providersã€consumersã€configuratorså’Œroutersã€‚é€šè¿‡ç›‘æ§ä¸­å¿ƒè¿›è¡ŒæœåŠ¡æ²»ç†æ—¶ï¼Œå¦‚ è®¾ç½®é…ç½®å‚æ•°ã€è®¾ç½®è·¯ç”±è§„åˆ™ã€è°ƒæ•´æƒé‡ã€è®¾ç½®é»‘ç™½åå•ç­‰æ‰ä¼šæ¶‰åŠæ³¨å†Œä¸åæ³¨å†Œæ“ä½œã€‚å½“è®¢é˜…çš„é€šé“æœ‰æ•°æ®å˜åŠ¨æ—¶ï¼Œå°±ä¼šè§¦å‘å›è°ƒæ“ä½œã€‚ æºç åˆ†æRedisRegistryFactory12345678910111213public class RedisRegistryFactory extends AbstractRegistryFactory &#123; /** * * @param url æ³¨å†Œä¸­å¿ƒåœ°å€ * @return */ @Override protected Registry createRegistry(URL url) &#123; // åˆ›å»º RedisRegistry å¯¹è±¡ return new RedisRegistry(url); &#125;&#125; RedisRegistry å·¥å‚æ¯”è¾ƒç®€å•ï¼Œæ²¡æœ‰å…¶å®ƒé€»è¾‘ï¼Œä»…ä»…åˆ›å»ºäº†ä¸€ä¸ª RedisRegistry å¯¹è±¡ã€‚ RedisRegistryå±æ€§1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class RedisRegistry extends FailbackRegistry &#123; private static final Logger logger = LoggerFactory.getLogger(RedisRegistry.class); /** * é»˜è®¤ç«¯å£ */ private static final int DEFAULT_REDIS_PORT = 6379; /** * é»˜è®¤redisçš„keyçš„æ ¹æ®èŠ‚ç‚¹ */ private final static String DEFAULT_ROOT = \"dubbo\"; /** * Redis Key å»¶æ—¶è¿‡æœŸæ‰§è¡Œå™¨ */ private final ScheduledExecutorService expireExecutor = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"DubboRegistryExpireTimer\", true)); /** * Redis Key å»¶æ—¶è¿‡æœŸä»»åŠ¡çš„Future */ private final ScheduledFuture&lt;?&gt; expireFuture; /** * Redis æ ¹èŠ‚ç‚¹ */ private final String root; /** * JedisPool é›†åˆ * key: ip:port * value: JedisPool */ private final Map&lt;String, JedisPool&gt; jedisPools = new ConcurrentHashMap&lt;String, JedisPool&gt;(); /** * é€šçŸ¥å™¨é›†åˆï¼Œç”¨äºRedis Publish/Subscribeæœºåˆ¶ä¸­çš„è®¢é˜…ï¼Œæœ¬è´¨æ˜¯è°ƒç”¨ Jedisçš„psubscribeæ–¹æ³•è¿›è¡Œè®¢é˜…é€šé“ * key: Root + Service,ä¾‹å¦‚ï¼š /dubbo/com.alibaba.dubbo.demo.DemoService * value: é€šçŸ¥å™¨ */ private final ConcurrentMap&lt;String, Notifier&gt; notifiers = new ConcurrentHashMap&lt;String, Notifier&gt;(); /** * é‡è¿å‘¨æœŸï¼Œå•ä½ï¼šæ¯«ç§’ * è®¢é˜…å‘ç”ŸRedisè¿æ¥å¼‚å¸¸æ—¶ï¼ŒNotifier sleepï¼Œç­‰å¾…é‡è¿ */ private final int reconnectPeriod; /** * è¿‡æœŸå‘¨æœŸï¼Œå•ä½ï¼šæ¯«ç§’ */ private final int expirePeriod; /** * æ˜¯å¦ä½¿ç”¨äº†ç›‘æ§ä¸­å¿ƒï¼Œä½¿ç”¨äº†ç›‘æ§ä¸­å¿ƒè¯¥å±æ€§ä¼šè¢«è®¾ç½® true * ç”¨äºåˆ¤æ–­è„æ•°æ®ï¼Œè„æ•°æ®ç”±ç›‘æ§ä¸­å¿ƒåˆ é™¤&#123;@link #clean(Jedis)&#125; */ private volatile boolean admin = false; /** * æ˜¯å¦å¤åˆ¶æ¨¡å¼ï¼Œç¼ºçœæ˜¯failover */ private boolean replicate; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; æ„é€ æ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class RedisRegistry extends FailbackRegistry &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; public RedisRegistry(URL url) &#123; super(url); if (url.isAnyHost()) &#123; throw new IllegalStateException(\"registry address == null\"); &#125; // åˆ›å»º GenericObjectPoolConfig å¯¹è±¡ GenericObjectPoolConfig config = new GenericObjectPoolConfig(); // è¿æ¥ä»poolä¸­è·å–ï¼Œä½¿ç”¨å‰ä¼šè¢«éªŒè¯ï¼Œé€šè¿‡pingå‘½ä»¤æ£€æµ‹ config.setTestOnBorrow(url.getParameter(\"test.on.borrow\", true)); // è¿æ¥åœ¨è¢«å½’è¿˜ç»™poolå‰ï¼Œä¼šéªŒè¯è¿æ¥çš„æœ‰æ•ˆæ€§ï¼Œé€šè¿‡pingå‘½ä»¤æ¥æ£€æµ‹ config.setTestOnReturn(url.getParameter(\"test.on.return\", false)); // æ‰“å¼€ç©ºé—²è¿æ¥å­˜æ´»å’Œå›æ”¶ï¼Œå‘¨æœŸæ€§æ£€æµ‹ config.setTestWhileIdle(url.getParameter(\"test.while.idle\", false)); // poolä¸­æœ€å¤§çš„ç©ºé—²è¿æ¥æ•°ï¼›è¾¾åˆ°åpoolä¼šå¼€å§‹å›æ”¶ç©ºé—²è¿æ¥ï¼Œç›´åˆ°ç©ºé—²è¿æ¥æ•°è¾¾åˆ°Mindleä¸ªæ•°ã€‚ ä¸»è¦é¿å…ç©ºè¿æ¥å ç”¨ï¼Œèµ„æºæµªè´¹ if (url.getParameter(\"max.idle\", 0) &gt; 0) &#123; config.setMaxIdle(url.getParameter(\"max.idle\", 0)); &#125; // poolä¸­ä¿æŒæœ€å°çš„ç©ºé—²å¯ç”¨è¿æ¥æ•°ï¼Œè¿™éƒ¨åˆ†ä¸è¢«å›æ”¶ã€‚å¯é˜²æ­¢æµé‡å¢é‡æ—¶ï¼Œè¿æ¥åˆ›å»ºä¸åŠæ—¶ if (url.getParameter(\"min.idle\", 0) &gt; 0) &#123; config.setMinIdle(url.getParameter(\"min.idle\", 0)); &#125; // poolå¯åˆ†é…çš„è¿æ¥æ•° if (url.getParameter(\"max.active\", 0) &gt; 0) &#123; config.setMaxTotal(url.getParameter(\"max.active\", 0)); &#125; // å½“å‰poolå¯å¹¶å‘çš„æœ€å¤§è¿æ¥æ•° if (url.getParameter(\"max.total\", 0) &gt; 0) &#123; config.setMaxTotal(url.getParameter(\"max.total\", 0)); &#125; // è·å–è¿æ¥çš„æœ€å¤§ç­‰å¾…æ—¶é—´ if (url.getParameter(\"max.wait\", url.getParameter(\"timeout\", 0)) &gt; 0) &#123; config.setMaxWaitMillis(url.getParameter(\"max.wait\", url.getParameter(\"timeout\", 0))); &#125; if (url.getParameter(\"num.tests.per.eviction.run\", 0) &gt; 0) &#123; config.setNumTestsPerEvictionRun(url.getParameter(\"num.tests.per.eviction.run\", 0)); &#125; if (url.getParameter(\"time.between.eviction.runs.millis\", 0) &gt; 0) &#123; config.setTimeBetweenEvictionRunsMillis(url.getParameter(\"time.between.eviction.runs.millis\", 0)); &#125; if (url.getParameter(\"min.evictable.idle.time.millis\", 0) &gt; 0) &#123; config.setMinEvictableIdleTimeMillis(url.getParameter(\"min.evictable.idle.time.millis\", 0)); &#125; // æ˜¯å¦å¤åˆ¶æ¨¡å¼ String cluster = url.getParameter(\"cluster\", \"failover\"); if (!\"failover\".equals(cluster) &amp;&amp; !\"replicate\".equals(cluster)) &#123; throw new IllegalArgumentException(\"Unsupported redis cluster: \" + cluster + \". The redis cluster only supported failover or replicate.\"); &#125; replicate = \"replicate\".equals(cluster); // è§£æ List&lt;String&gt; addresses = new ArrayList&lt;String&gt;(); addresses.add(url.getAddress()); // ULRä¸­è®¾ç½®äº†ä»åº“åœ°å€ String[] backups = url.getParameter(Constants.BACKUP_KEY, new String[0]); if (backups != null &amp;&amp; backups.length &gt; 0) &#123; addresses.addAll(Arrays.asList(backups)); &#125; // åˆ›å»ºJedisPoolå¯¹è±¡ for (String address : addresses) &#123; int i = address.indexOf(':'); String host; int port; if (i &gt; 0) &#123; host = address.substring(0, i); port = Integer.parseInt(address.substring(i + 1)); &#125; else &#123; host = address; port = DEFAULT_REDIS_PORT; &#125; this.jedisPools.put(address, new JedisPool(config, host, port, url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT), StringUtils.isEmpty(url.getPassword()) ? null : url.getPassword(), url.getParameter(\"db.index\", 0))); &#125; // è§£æé‡è¿å‘¨æœŸ this.reconnectPeriod = url.getParameter(Constants.REGISTRY_RECONNECT_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RECONNECT_PERIOD); // è·å¾—Redis æ ¹èŠ‚ç‚¹ String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT); if (!group.startsWith(Constants.PATH_SEPARATOR)) &#123; group = Constants.PATH_SEPARATOR + group; &#125; if (!group.endsWith(Constants.PATH_SEPARATOR)) &#123; group = group + Constants.PATH_SEPARATOR; &#125; this.root = group; // è§£æä¼šè¯è¿‡æœŸæ—¶é—´ this.expirePeriod = url.getParameter(Constants.SESSION_TIMEOUT_KEY, Constants.DEFAULT_SESSION_TIMEOUT); // åˆ›å»ºå®ç°Redis Key è¿‡æœŸæœºåˆ¶çš„ä»»åŠ¡ this.expireFuture = expireExecutor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; try &#123; // å»¶æ—¶è¿‡æœŸæ—¶é—´ deferExpired(); &#125; catch (Throwable t) &#123; // Defensive fault tolerance logger.error(\"Unexpected exception occur at defer expire time, cause: \" + t.getMessage(), t); &#125; &#125; &#125;, expirePeriod / 2, expirePeriod / 2, TimeUnit.MILLISECONDS); &#125;// $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; RedisRegistry æ„é€ æ–¹æ³•åšäº†ä¸¤ä»¶äº‹ï¼Œåˆå§‹åŒ– JedisPool å’Œ åˆ›å»º Redis keyçš„å»¶è¿Ÿè¿‡æœŸçš„ä»»åŠ¡ã€‚åˆå§‹åŒ– JedisPool æ²¡æœ‰ä»€ä¹ˆå¥½è¯´çš„ï¼Œä¸»è¦æ˜¯è®¾ç½®ä¸€äº›å‚æ•°ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹ deferExpired æ–¹æ³•æ˜¯æ€ä¹ˆåšåˆ°å»¶æ—¶keyè¿‡æœŸçš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * è¢«Keyè¿‡æœŸæœºåˆ¶æ‰§è¡Œå™¨expireExecutorå®šæ—¶è°ƒç”¨ï¼Œç”¨æ¥å»¶æ—¶è¿‡æœŸæ—¶é—´. */ private void deferExpired() &#123; for (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123; JedisPool jedisPool = entry.getValue(); try &#123; Jedis jedis = jedisPool.getResource(); try &#123; // å¾ªç¯å·²æ³¨å†Œçš„URLé›†åˆ for (URL url : new HashSet&lt;URL&gt;(getRegistered())) &#123; // æ˜¯å¦æ˜¯åŠ¨æ€èŠ‚ç‚¹ï¼Œåªæœ‰åŠ¨æ€èŠ‚ç‚¹éœ€è¦å»¶é•¿è¿‡æœŸæ—¶é—´ if (url.getParameter(Constants.DYNAMIC_KEY, true)) &#123; // è·å¾—åˆ†ç±»è·¯å¾„ï¼Œå¦‚ï¼š/dubbo/com.foo.BarService/providers String key = toCategoryPath(url); /** * 1 å†™å…¥Redis Mapä¸­ï¼Œæ›´æ–°è¿‡æœŸæ—¶é—´ * 2 æ³¨æ„ï¼Œå¦‚æœè¿‡æœŸæ—¶é—´æ›´æ–°çš„æ—¶å€™è¿”å›å€¼ä¸º1ï¼Œè¯´æ˜keyå·²ç»è¢«åˆ é™¤äº†ï¼Œè¿™æ¬¡ç®—é‡æ–°å‘å¸ƒï¼Œå› æ­¤éœ€è¦åœ¨é€šé“key ä¸­å‘å¸ƒ register äº‹ä»¶æ¶ˆæ¯ */ if (jedis.hset(key, url.toFullString(), String.valueOf(System.currentTimeMillis() + expirePeriod)) == 1) &#123; // å‘å¸ƒ register äº‹ä»¶ jedis.publish(key, Constants.REGISTER); &#125; &#125; &#125; // å¦‚æœæ˜¯ç›‘æ§ä¸­å¿ƒï¼ˆadmin = trueï¼‰ï¼Œå°±è´Ÿè´£åˆ é™¤è¿‡æœŸè„æ•°æ®ã€‚adminé»˜è®¤ä¸ºfalse,å¯èƒ½ä¿®æ”¹çš„åœ°æ–¹åœ¨ doSubscribe æ–¹æ³•ä¸­ if (admin) &#123; clean(jedis); &#125; // å¦‚æœRedisé›†ç¾¤ç­–ç•¥ä¸º failoverï¼Œåˆ™æ“ä½œä¸€å°Rediså³å¯ã€‚ if (!replicate) &#123; break;// If the server side has synchronized data, just write a single machine &#125; &#125; finally &#123; jedis.close(); &#125; &#125; catch (Throwable t) &#123; logger.warn(\"Failed to write provider heartbeat to redis registry. registry: \" + entry.getKey() + \", cause: \" + t.getMessage(), t); &#125; &#125; &#125; æœåŠ¡çš„ key å†™å…¥Redis åï¼Œéœ€è¦å‘¨æœŸæ€§åœ°åˆ·æ–°keyè¿‡æœŸæ—¶é—´ï¼ŒRedisRegistry æ„é€ æ–¹æ³•ä¸­å¯åŠ¨äº†ä¸€ä¸ªå®šæ—¶è°ƒåº¦çº¿ç¨‹æ± ï¼Œä¸æ–­è°ƒç”¨è¯¥æ–¹æ³•å»¶ç»­keyçš„è¿‡æœŸæ—¶é—´ã€‚å‰é¢ä¹Ÿè¯´æ˜äº†ï¼ŒRedis çš„keyè‡ªåŠ¨è¿‡æœŸä¸å­˜åœ¨ç›¸åº”çš„äº‹ä»¶é€šçŸ¥ï¼ˆè®¢é˜…è€…æ— æ³•æ„ŸçŸ¥åˆ°keyå·²ç»ä¸å­˜åœ¨ï¼‰ï¼Œå¦‚æœæä¾›è€…å®•æœºè€Œéä¸»åŠ¨ä¸‹çº¿ï¼Œåˆ™ä¼šé€ æˆæ²¡æœ‰å‘å¸ƒ unregister äº‹ä»¶ï¼Œè¿™æ—¶è®¢é˜…æ–¹æ˜¯ä¸çŸ¥é“æœåŠ¡å·²ç»ä¸‹çº¿çš„ï¼Œæ­¤å¤–ï¼ŒRedis çš„ publish/subscribe å¹¶ä¸æ˜¯ç»å¯¹å¯é çš„ï¼Œå¦‚æœ Redis çš„é›†ç¾¤ç­–ç•¥è®¾ç½®ä¸º failover æ¨¡å¼ï¼Œæ¶ˆè´¹è€…è®¢é˜…äº†ä»èŠ‚ç‚¹ï¼ŒæŸä¸€æ—¶åˆ»ä¸»èŠ‚ç‚¹è¿˜æ²¡æœ‰å®Œæˆæ•°æ®åŒæ­¥ç»™ä»èŠ‚ç‚¹å°±å®•æœºäº†ï¼Œé‚£ä¹ˆæ¶ˆè´¹è€…ä¹Ÿæ˜¯ä¸çŸ¥é“æœåŠ¡å·²ç»ä¸‹çº¿çš„ã€‚å› æ­¤ï¼Œå¦‚æœä½¿ç”¨ Redis ä½œä¸ºæ³¨å†Œä¸­å¿ƒï¼Œä¼šä¾èµ–æœåŠ¡æ²»ç†ä¸­å¿ƒï¼Œä½¿ç”¨äº†æœåŠ¡æ²»ç†ä¸­å¿ƒï¼ŒRedis æ³¨å†Œä¸­å¿ƒå°±ä¼šå®šæ—¶è§¦å‘æ¸…ç†é€»è¾‘ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸‹ Redis æ³¨å†Œä¸­å¿ƒæ¸…ç†è„æ•°æ®çš„é€»è¾‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142/** * ç›‘æ§ä¸­å¿ƒè´Ÿè´£æ¸…ç†è¿‡æœŸè„æ•°æ® * * @param jedis */ private void clean(Jedis jedis) &#123; // è·å¾—æ‰€æœ‰çš„ Root + Service + Type Set&lt;String&gt; keys = jedis.keys(root + Constants.ANY_VALUE); if (keys != null &amp;&amp; !keys.isEmpty()) &#123; for (String key : keys) &#123; // è·å¾—åˆ†ç±»ä¸‹çš„Map,key-&gt;URL,value-&gt;è¿‡æœŸæ—¶é—´ Map&lt;String, String&gt; values = jedis.hgetAll(key); if (values != null &amp;&amp; values.size() &gt; 0) &#123; boolean delete = false; long now = System.currentTimeMillis(); for (Map.Entry&lt;String, String&gt; entry : values.entrySet()) &#123; // è·å–URL URL url = URL.valueOf(entry.getKey()); // åŠ¨æ€èŠ‚ç‚¹ if (url.getParameter(Constants.DYNAMIC_KEY, true)) &#123; // è·å–URLå¯¹åº”çš„è¿‡æœŸæ—¶é—´ long expire = Long.parseLong(entry.getValue()); // å·²ç»è¿‡æœŸ if (expire &lt; now) &#123; jedis.hdel(key, entry.getKey()); delete = true; if (logger.isWarnEnabled()) &#123; logger.warn(\"Delete expired key: \" + key + \" -&gt; value: \" + entry.getKey() + \", expire: \" + new Date(expire) + \", now: \" + new Date(now)); &#125; &#125; &#125; &#125; // è‹¥å‘ç”Ÿåˆ é™¤è¡Œä¸ºï¼Œè¯´æ˜å­˜åœ¨URLè¿‡æœŸäº†ï¼Œéœ€è¦å‘keyé€šé“å‘å¸ƒ `unregister`äº‹ä»¶ if (delete) &#123; jedis.publish(key, Constants.UNREGISTER); &#125; &#125; &#125; &#125; &#125; clean æ–¹æ³•ä¸»è¦åšäº†ä¸¤ä»¶äº‹ï¼ŒæŠŠè¿‡æœŸçš„keyåˆ é™¤å¹¶åœ¨é€šé“keyä¸­å‘å¸ƒ unregister äº‹ä»¶ï¼Œä¿è¯äº†æœªæ­£å¸¸ä¸‹çº¿çš„æœåŠ¡ä¿¡æ¯çš„åˆ é™¤ï¼Œä»è€Œä¿è¯æ•°æ®çš„æœ€ç»ˆä¸€è‡´æ€§ã€‚ä½†è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜æ²¡æœ‰è§£å†³ï¼Œå¦‚æœ Redis çš„é›†ç¾¤ç­–ç•¥è®¾ç½®ä¸º failover æ¨¡å¼ï¼Œæ¶ˆè´¹è€…è®¢é˜…äº†ä»èŠ‚ç‚¹ï¼ŒæŸä¸€æ—¶åˆ»æä¾›è€…ä¸‹çº¿äº†ï¼Œä¸»èŠ‚ç‚¹è¿˜æ²¡æœ‰å®Œæˆæ•°æ®åŒæ­¥ç»™ä»èŠ‚ç‚¹å°±å®•æœºäº†ï¼Œé‚£ä¹ˆæ¶ˆè´¹è€…ä¹Ÿæ˜¯ä¸çŸ¥é“æœåŠ¡å·²ç»ä¸‹çº¿çš„ï¼Œé‚£è¿™æ ·æƒ…å†µæ€ä¹ˆè§£å†³å‘¢ï¼Ÿé—®é¢˜å…ˆæŠ›å‡ºæ¥ã€‚ æ³¨å†Œ1234567891011121314151617181920212223242526272829303132333435363738394041@Override public void doRegister(URL url) &#123; // è·å–åˆ†ç±»è·¯å¾„ Root + Service + Type String key = toCategoryPath(url); // è·å¾—URLå­—ç¬¦ä¸²ä½œä¸ºValue String value = url.toFullString(); // è®¡ç®—è¿‡æœŸæ—¶é—´ï¼Œè¿™ä¼šä½œä¸ºRedis Mapçš„å€¼ String expire = String.valueOf(System.currentTimeMillis() + expirePeriod); boolean success = false; RpcException exception = null; // å‘Redisæ³¨å†Œ for (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123; JedisPool jedisPool = entry.getValue(); try &#123; Jedis jedis = jedisPool.getResource(); try &#123; // å†™å…¥Redis hash ä¸­ï¼Œæ³¨æ„ï¼Œè¿‡æœŸæ—¶é—´æ˜¯ä½œä¸ºMapçš„å€¼ã€‚ jedis.hset(key, value, expire); // å‘å¸ƒRedis æ³¨å†Œäº‹ä»¶ã€‚ keyä¸ºé€šé“ï¼Œ Constants.REGISTER-&gt;registerä¸ºäº‹ä»¶æ¶ˆæ¯ï¼Œè®¢é˜…è¯¥é€šé“çš„å°±ä¼šå®æ—¶ä»Redisè¯»å–æœ€æ–°æ¶ˆæ¯ jedis.publish(key, Constants.REGISTER); success = true; // å¦‚æœéreplicateæ¨¡å¼ï¼Œåªéœ€è¦å†™å…¥å•å°æœºå™¨ï¼Œç»“æŸå¾ªç¯ã€‚å¦åˆ™ï¼Œå°±ç»§ç»­å¾ªç¯ï¼Œå‘æ‰€æœ‰çš„Rediså†™å…¥ if (!replicate) &#123; break; &#125; &#125; finally &#123; jedis.close(); &#125; &#125; catch (Throwable t) &#123; exception = new RpcException(\"Failed to register service to redis registry. registry: \" + entry.getKey() + \", service: \" + url + \", cause: \" + t.getMessage(), t); &#125; &#125; // å¤„ç†å¼‚å¸¸ if (exception != null) &#123; if (success) &#123; logger.warn(exception.getMessage(), exception); &#125; else &#123; throw exception; &#125; &#125; &#125; æ³¨å†Œæ–¹æ³•ä¸»è¦åšäº†ä¸¤ä»¶äº‹ï¼ŒæŠŠä¿¡æ¯å†™åˆ° Redis ä¸­ï¼Œç„¶åå‘å¸ƒæ³¨å†Œäº‹ä»¶ã€‚è¿™é‡Œæ³¨å†Œä¸ä»…æ˜¯æœåŠ¡æä¾›è€…å’Œæ¶ˆè´¹è€…ï¼Œè¿˜å¯èƒ½æ˜¯åŠ¨æ€é…ç½®ï¼Œè·¯ç”±è§„åˆ™ç­‰ã€‚ åæ³¨å†Œ1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic void doUnregister(URL url) &#123; // è·å–åˆ†ç±»è·¯å¾„ Root + Service + Type String key = toCategoryPath(url); // è·å¾—URLå­—ç¬¦ä¸²ä½œä¸ºValue String value = url.toFullString(); RpcException exception = null; boolean success = false; for (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123; JedisPool jedisPool = entry.getValue(); try &#123; Jedis jedis = jedisPool.getResource(); try &#123; // åˆ é™¤ Redis Map å»º jedis.hdel(key, value); // å‘å¸ƒRedis å–æ¶ˆæ³¨å†Œäº‹ä»¶ keyä¸ºé€šé“ ï¼Œ Constants.UNREGISTER-&gt;unregister ä¸ºäº‹ä»¶æ¶ˆæ¯ jedis.publish(key, Constants.UNREGISTER); success = true; // å¦‚æœéreplicateæ¨¡å¼ï¼Œåªéœ€æ“ä½œå•å°æœºå™¨ï¼Œå› æ­¤ç»“æŸå¾ªç¯ã€‚å¦åˆ™ï¼Œå°±ç»§ç»­å¾ªç¯ï¼Œå‘æ‰€æœ‰çš„Rediså†™å…¥ if (!replicate) &#123; break; // If the server side has synchronized data, just write a single machine &#125; &#125; finally &#123; jedis.close(); &#125; &#125; catch (Throwable t) &#123; exception = new RpcException(\"Failed to unregister service to redis registry. registry: \" + entry.getKey() + \", service: \" + url + \", cause: \" + t.getMessage(), t); &#125; &#125; if (exception != null) &#123; if (success) &#123; logger.warn(exception.getMessage(), exception); &#125; else &#123; throw exception; &#125; &#125;&#125; åæ³¨å†Œä¸»è¦ä¹Ÿåšäº†ä¸¤ä»¶äº‹ï¼Œä»Redis ä¸­åˆ é™¤æ•°æ®ï¼Œç„¶åå‘å¸ƒ unregister ä¸ºäº‹ä»¶ã€‚å½“æœåŠ¡æ¶ˆè´¹è€…æˆ–æœåŠ¡æä¾›è€…å…³é—­æ—¶ï¼Œä¼šè°ƒç”¨è¯¥æ–¹æ³•ï¼Œå–æ¶ˆæ³¨å†Œï¼Œå› ä¸ºæ­£å¸¸æƒ…å†µä¸‹ï¼Œæ— éœ€ä½¿ç”¨ç›‘æ§ä¸­å¿ƒåšè„æ•°æ®åˆ é™¤çš„å·¥ä½œã€‚åŒæ ·ï¼Œè¿™é‡Œåæ³¨å†Œä¸ä»…æ˜¯æœåŠ¡æä¾›è€…å’Œæ¶ˆè´¹è€…ï¼Œè¿˜å¯èƒ½æ˜¯åŠ¨æ€é…ç½®ï¼Œè·¯ç”±è§„åˆ™ç­‰ã€‚ è®¢é˜…1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Overridepublic void doSubscribe(final URL url, final NotifyListener listener) &#123; // è·å¾—æœåŠ¡è·¯å¾„ Root + Service å¦‚ï¼š /dubbo/com.alibaba.dubbo.demo.DemoService String service = toServicePath(url); // è·å¾—æœåŠ¡è·¯å¾„å¯¹åº”çš„é€šçŸ¥å™¨ Notifier å¯¹è±¡,ä¸å­˜åœ¨å¯¹åº”çš„é€šçŸ¥å™¨ï¼Œåˆ™åˆ›å»ºNotifierå¯¹è±¡ Notifier notifier = notifiers.get(service); if (notifier == null) &#123; /** * åˆ›å»ºæœåŠ¡è·¯å¾„å¯¹åº”çš„é€šçŸ¥å™¨Notifierå¯¹è±¡ï¼Œå³åŸºäº Root + Service å¼€å¯è®¢é˜…çº¿ç¨‹ï¼Œå¦‚æœæœåŠ¡å¾ˆå¤šï¼Œå°±æ„å‘³ç€æœ‰å¾ˆå¤šæ­¤ç±»çº¿ç¨‹ï¼Œåˆ›å»ºçº¿ç¨‹æ˜¯æ¶ˆè€—èµ„æºçš„ï¼Œè€Œä¸”è¿˜æ˜¯é‚£ç§é˜»å¡ä¸é‡Šæ”¾çš„ã€‚ * è¯´æ˜ï¼š * zkæ˜¯ç›´æ¥è°ƒç”¨å®¢æˆ·ç«¯APIç»‘å®šç›‘å¬å™¨å®ç°è®¢é˜…ï¼Œredisæ˜¯ä½¿ç”¨å¤šä¸ªç‹¬ç«‹çš„è®¢é˜…çº¿ç¨‹ï¼Œä½¿ç”¨pub/subæœºåˆ¶è¿›è¡Œå¤„ç†ï¼Œå› ä¸ºredisçš„pub/subæ˜¯åŸºäºchannelè¿›è¡Œçš„é•¿è¿æ¥é€šä¿¡ï¼Œå› æ­¤æ¯ä¸ªæœåŠ¡åªèƒ½ä½¿ç”¨å•ç‹¬çš„çº¿ç¨‹ã€‚ */ Notifier newNotifier = new Notifier(service); notifiers.putIfAbsent(service, newNotifier); notifier = notifiers.get(service); // ä¿è¯å¹¶å‘çš„æƒ…å†µä¸‹ï¼Œæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå¯åŠ¨ if (notifier == newNotifier) &#123; // å¯åŠ¨çº¿ç¨‹ï¼ˆè®¢é˜…äº†é€šé“ï¼Œæœ‰æ¶ˆæ¯å‘å¸ƒå°±ä¼šè¢«é€šçŸ¥è®¢é˜…å¯¹è±¡æ”¶åˆ°ï¼Œç„¶åè¿›è¡Œåç»­çš„é€šçŸ¥å¤„ç†ï¼‰ï¼Œéœ€è¦æ³¨æ„ï¼šJedisçš„è®¢é˜…æ˜¯é˜»å¡çš„ï¼Œå› æ­¤éœ€è¦å¼€å¯çº¿ç¨‹ï¼Œä¸ç„¶ä¸»çº¿ç¨‹ä¼šé˜»å¡ã€‚ notifier.start(); &#125; &#125; boolean success = false; RpcException exception = null; // å¾ªç¯ jedisPools,ä»…ä»ä¸€ä¸ªRedisè·å–æ•°æ®ï¼Œç„¶åè¿›è¡Œé€šçŸ¥ï¼Œç›´åˆ°æˆåŠŸ for (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123; JedisPool jedisPool = entry.getValue(); try &#123; Jedis jedis = jedisPool.getResource(); try &#123; // å¤„ç† Root + * çš„è®¢é˜…ï¼Œä¸€èˆ¬æ˜¯ç›‘å¬ä¸­å¿ƒçš„è®¢é˜… if (service.endsWith(Constants.ANY_VALUE)) &#123; // æ ‡è®°admin = true,ç›‘æ§ä¸­å¿ƒæ‰ä¼šæ¸…ç†è„æ•°æ® admin = true; // è°ƒç”¨Jedis#keys(pattern)æ–¹æ³•æ ¹æ®`/dubbo/*` é€šé…ç¬¦è·å¾—åˆ†ç±»å±‚é›†åˆã€‚å§‹ç»ˆè®°ä½ Redis ä½œä¸ºæ³¨å†Œä¸­å¿ƒæ—¶ï¼Œkeyæ˜¯åˆ†ç±»ï¼Œå¦‚ï¼š /dubbo/com.alibaba.dubbo.demo.DemoService/providers Set&lt;String&gt; keys = jedis.keys(service); if (keys != null &amp;&amp; !keys.isEmpty()) &#123; // key: Root + Service value: Root + Service + Type Map&lt;String, Set&lt;String&gt;&gt; serviceKeys = new HashMap&lt;String, Set&lt;String&gt;&gt;(); for (String key : keys) &#123; // è·å–Root + Serviceï¼Œå¦‚ï¼š/dubbo/com.alibaba.dubbo.demo.DemoService String serviceKey = toServicePath(key); Set&lt;String&gt; sk = serviceKeys.get(serviceKey); if (sk == null) &#123; sk = new HashSet&lt;String&gt;(); serviceKeys.put(serviceKey, sk); &#125; sk.add(key); &#125; // å¾ªç¯serviceKeys for (Set&lt;String&gt; sk : serviceKeys.values()) &#123; // é€šçŸ¥ç›‘å¬å™¨ doNotify(jedis, sk, url, Arrays.asList(listener)); &#125; &#125; // å¤„ç†æŒ‡å®š Root + Service çš„è®¢é˜… &#125; else &#123; /** * 1 è°ƒç”¨Jedis#keys(pattern)æ–¹æ³•ï¼Œè·å¾—æ‰€æœ‰åˆ†ç±»ï¼Œä¾‹å¦‚ï¼š/dubbo/com.alibaba.dubbo.demo.DemoService/providers * 2 é€šçŸ¥ç›‘å¬å™¨ */ doNotify(jedis, jedis.keys(service + Constants.PATH_SEPARATOR + Constants.ANY_VALUE), url, Arrays.asList(listener)); &#125; // æ ‡è®°æˆåŠŸ success = true; // Just read one server's data break; &#125; finally &#123; jedis.close(); &#125; &#125; catch (Throwable t) &#123; // Try the next server exception = new RpcException(\"Failed to subscribe service from redis registry. registry: \" + entry.getKey() + \", service: \" + url + \", cause: \" + t.getMessage(), t); &#125; &#125; // å¤„ç†å¼‚å¸¸ if (exception != null) &#123; if (success) &#123; logger.warn(exception.getMessage(), exception); &#125; else &#123; throw exception; &#125; &#125;&#125; æœåŠ¡æä¾›è€…ã€æœåŠ¡æ¶ˆè´¹è€…ã€å’ŒæœåŠ¡æ²»ç†ä¸­å¿ƒéƒ½ä¼šä½¿ç”¨æ³¨å†Œä¸­å¿ƒçš„è®¢é˜…åŠŸèƒ½ã€‚åœ¨è®¢é˜…æ—¶ï¼Œå¦‚æœæ˜¯é¦–æ¬¡è®¢é˜…ï¼Œåˆ™ä¼šå…ˆåˆ›å»ºä¸€ä¸ª Notifier é€šçŸ¥å™¨ï¼Œå®ƒæ˜¯ä¸€ä¸ªçº¿ç¨‹ç±»ï¼Œä»¥å¼‚æ­¥æ–¹å¼è¿›è¡Œé€šé“çš„è®¢é˜…ã€‚åœ¨å¯åŠ¨é€šçŸ¥å™¨çš„åŒæ—¶ï¼Œä¸»çº¿ç¨‹ä¼šç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œå…¨é‡æ‹‰å–æ³¨å†Œä¸­å¿ƒä¸Šå’Œæœ¬æ¬¡è®¢é˜…ç›¸å…³çš„æ•°æ®ä¿¡æ¯ã€‚åç»­æ³¨å†Œä¸­å¿ƒä¸Šçš„ä¿¡æ¯å˜æ›´åˆ™é€šè¿‡é€šçŸ¥å™¨è®¢é˜…çš„é€šé“æ¥å®ç°ï¼Œå‘ç”Ÿå˜æ›´è®¢é˜…å™¨ä¼šæ”¶åˆ°ã€‚æ­¤å¤–ï¼Œè¿™é‡Œæœ‰ä¸¤ä¸ªåˆ†æ”¯ï¼Œç¬¬ä¸€ä¸ªæ˜¯å¤„ç†ç›‘æ§ä¸­å¿ƒçš„è®¢é˜…å³ Root + *ï¼Œç¬¬äºŒä¸ªæ˜¯å¤„ç†æŒ‡å®šRoot + Service + * çš„è®¢é˜…ï¼Œå¦‚æœæ˜¯ç›‘æ§ä¸­å¿ƒçš„è®¢é˜…ä¼šå¼€å¯è„æ•°æ®çš„æ¸…ç†ä»»åŠ¡ã€‚æœ‰äº†è®¢é˜…ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹é€šçŸ¥å™¨çš„å®ç°ã€‚ Notifier é€šçŸ¥å™¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public class RedisRegistry extends FailbackRegistry &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; /** * é€šçŸ¥å™¨ç±»ï¼Œæ˜¯ä¸€ä¸ªçº¿ç¨‹å¯¹è±¡ */ private class Notifier extends Thread &#123; /** * æœåŠ¡å Root + Service */ private final String service; /** * éœ€è¦å¿½ç•¥è¿æ¥çš„æ¬¡æ•° */ private final AtomicInteger connectSkip = new AtomicInteger(); /** * å·²ç»å¿½ç•¥è¿æ¥çš„æ¬¡æ•° */ private final AtomicInteger connectSkiped = new AtomicInteger(); /** * éšæœºå¯¹è±¡ */ private final Random random = new Random(); /** * Jedis */ private volatile Jedis jedis; /** * æ˜¯å¦é¦–æ¬¡ */ private volatile boolean first = true; /** * æ˜¯å¦è¿è¡Œä¸­ */ private volatile boolean running = true; /** * è¿æ¥æ¬¡æ•°éšæœºæ•° */ private volatile int connectRandom; public Notifier(String service) &#123; super.setDaemon(true); super.setName(\"DubboRedisSubscribe\"); this.service = service; &#125; /** * é‡ç½®å¿½ç•¥è¿æ¥çš„ä¿¡æ¯ */ private void resetSkip() &#123; // é‡ç½®éœ€è¦å¿½ç•¥è¿æ¥çš„æ¬¡æ•° connectSkip.set(0); // é‡ç½®å·²å¿½ç•¥æ¬¡æ•°å’Œéšæœºæ•° connectSkiped.set(0); connectRandom = 0; &#125; /** * åˆ¤æ–­æ˜¯å¦å¿½ç•¥æœ¬æ¬¡å¯¹Redisçš„è¿æ¥ * åŸåˆ™æ˜¯ï¼šè¿æ¥å¤±è´¥çš„æ¬¡æ•°è¶Šå¤šï¼Œæ¯ä¸€è½®åŠ å¤§éœ€è¦å¿½ç•¥çš„æ€»æ¬¡æ•° * * @return */ private boolean isSkip() &#123; // è·å¾—éœ€è¦å¿½ç•¥çš„è¿æ¥æ•°ï¼Œå¦‚æœè¶…è¿‡10ï¼Œåˆ™åŠ ä¸Šä¸€ä¸ª10ä»¥å†…çš„éšæœºæ•° int skip = connectSkip.get(); // Growth of skipping times if (skip &gt;= 10) &#123; // If the number of skipping times increases by more than 10, take the random number if (connectRandom == 0) &#123; connectRandom = random.nextInt(10); &#125; skip = 10 + connectRandom; &#125; // è‡ªå¢å¿½ç•¥æ¬¡æ•°ï¼Œè‹¥å¿½ç•¥æ¬¡æ•°ä¸å¤Ÿï¼Œåˆ™ç»§ç»­å¿½ç•¥ if (connectSkiped.getAndIncrement() &lt; skip) &#123; // Check the number of skipping times return true; &#125; // å¢åŠ éœ€è¦å¿½ç•¥çš„æ¬¡æ•° connectSkip.incrementAndGet(); // é‡ç½®å·²å¿½ç•¥æ¬¡æ•°å’Œéšæœºæ•° connectSkiped.set(0); connectRandom = 0; return false; &#125; @Override public void run() &#123; // è¿™é‡Œçš„å¾ªç¯å¤„ç†æ˜¯ä¸ºäº†é¿å…ç½‘ç»œç­‰å¼‚å¸¸çš„å‘ç”Ÿï¼Œä¾¿äºé‡æ–°å°è¯•è¿æ¥redis è®¢é˜…channel while (running) &#123; try &#123; // æ˜¯å¦è·³è¿‡æœ¬æ¬¡Redisè¿æ¥ todo if (!isSkip()) &#123; try &#123; // å¾ªç¯è¿æ¥æ±  for (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123; JedisPool jedisPool = entry.getValue(); try &#123; jedis = jedisPool.getResource(); try &#123; // å¦‚æœæ˜¯ç›‘æ§ä¸­å¿ƒçš„è®¢é˜… if (service.endsWith(Constants.ANY_VALUE)) &#123; if (!first) &#123; first = false; // è·å–åˆ†ç±»é›†åˆ Set&lt;String&gt; keys = jedis.keys(service); if (keys != null &amp;&amp; !keys.isEmpty()) &#123; for (String s : keys) &#123; doNotify(jedis, s); &#125; &#125; // ç”±äºè¿æ¥è¿‡ç¨‹å…è®¸ä¸€å®šé‡çš„å¤±è´¥ï¼Œè°ƒç”¨è¯¥æ–¹æ³•é‡ç½®è®¡æ•°å™¨ resetSkip(); &#125; // è®¢é˜…ç»™å®šæ¨¡å¼çš„é€šé“ï¼Œå½“è®¢é˜…çš„é€šé“æœ‰å‘å¸ƒæ¶ˆæ¯æ—¶ï¼ŒNotifySubå¯¹è±¡çš„å›è°ƒæ–¹æ³•å°±èƒ½æ¥æ”¶åˆ°ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè®¢é˜…æ–¹æ³•æ˜¯é˜»å¡çš„ã€‚ jedis.psubscribe(new NotifySub(jedisPool), service); // blocking // æœåŠ¡æä¾›è€…æˆ–è€…æ¶ˆè´¹è€… &#125; else &#123; if (!first) &#123; first = false; doNotify(jedis, service); // ç”±äºè¿æ¥è¿‡ç¨‹å…è®¸ä¸€å®šé‡çš„å¤±è´¥ï¼Œè°ƒç”¨è¯¥æ–¹æ³•é‡ç½®è®¡æ•°å™¨ resetSkip(); &#125; jedis.psubscribe(new NotifySub(jedisPool), service + Constants.PATH_SEPARATOR + Constants.ANY_VALUE); // blocking &#125; break; &#125; finally &#123; jedis.close(); &#125; &#125; catch (Throwable t) &#123; // Retry another server logger.warn(\"Failed to subscribe service from redis registry. registry: \" + entry.getKey() + \", cause: \" + t.getMessage(), t); // If you only have a single redis, you need to take a rest to avoid overtaking a lot of CPU resources sleep(reconnectPeriod); &#125; &#125; &#125; catch (Throwable t) &#123; logger.error(t.getMessage(), t); sleep(reconnectPeriod); &#125; &#125; &#125; catch (Throwable t) &#123; logger.error(t.getMessage(), t); &#125; &#125; &#125; /** * åœæ­¢ Notifierï¼Œå…³é—­redisè®¢é˜…ç›¸å…³å·¥ä½œçš„å…³é”®ã€‚å®ƒæ˜¯é€šè¿‡è®¾ç½®åœæ­¢å¾ªç¯æ ‡è¯†ï¼Œä»¥åŠå…³é—­redisè¿æ¥å®ç°çš„ã€‚ */ public void shutdown() &#123; try &#123; // è®¾ç½®åœæ­¢æ ‡è¯† running = false; // æ–­å¼€redisè¿æ¥ï¼Œå®ƒè¿˜ä¼šåœæ­¢psubscribeçš„è°ƒç”¨ï¼Œä»è€Œé—´æ¥ä¸­æ­¢è®¢é˜… jedis.disconnect(); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; é€šçŸ¥å™¨æ˜¯ä¸€ä¸ªçº¿ç¨‹ï¼Œå®ƒæ˜¯ RedisRegistryçš„å†…éƒ¨ç±»ï¼Œæ¯ä¸€ä¸ªæœåŠ¡ï¼ˆRoot + Serviceï¼‰å¯¹åº”ä¸€ä¸ªé€šçŸ¥å™¨ï¼Œå¦‚æœå­˜åœ¨å¤§é‡è®¢é˜…è¯·æ±‚å¹¶ä¸”è®¢é˜…URLéƒ½ä¸æ˜¯åŒä¸€ä¸ªæœåŠ¡ï¼Œé‚£ä¹ˆå°±è¦åˆ›å»ºå¤§é‡çš„çº¿ç¨‹ã€‚ä¸ä»…å¦‚æ­¤ï¼Œç”±é€šçŸ¥å™¨ç±»è¿˜å¯ä»¥å‘ç°å…¶ä»»åŠ¡æ–¹æ³•ä¸­è°ƒç”¨äº†è®¢é˜…æ–¹æ³• jedis.psubscribe ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯é˜»å¡çš„ã€‚å› æ­¤ï¼Œä½¿ç”¨ Redis æ³¨å†Œä¸­å¿ƒè¦è€ƒè™‘çº¿ç¨‹èµ„æºã€‚ç›®å‰ä¸ºæ­¢ï¼ŒRedis çš„å‘å¸ƒæˆ‘ä»¬å·²ç»çŸ¥é“äº†ï¼Œä¸»è¦åœ¨æ³¨å†Œå’Œåæ³¨å†Œçš„æ–¹æ³•ä¸­ï¼Œå¦‚æœä½¿ç”¨äº†ç›‘æ§ä¸­å¿ƒï¼Œè¿˜ä¼šåœ¨è„æ•°æ®æ¸…ç†æ–¹æ³•ä¸­ã€‚è®¢é˜…æ¥æ”¶å¯¹è±¡ä¾ç„¶æ²¡æœ‰å‡ºç°ï¼Œè¯·æ³¨æ„ï¼Œé€šçŸ¥å™¨å¹¶éæ˜¯è®¢é˜…å™¨ï¼Œä½†æ˜¯é€šçŸ¥å™¨åˆ›å»ºäº†è®¢é˜…å™¨ NotifySubï¼Œæˆ‘ä»¬ç»§ç»­è·Ÿè¿›è¯¥ç±»ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class RedisRegistry extends FailbackRegistry &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; /** * RedisRegistry çš„å†…éƒ¨ç±»ï¼Œç»§æ‰¿ redis.clients.jedis.JedisPubSub æŠ½è±¡ç±»ï¼Œå®ƒæ˜¯ä¸ªé€šçŸ¥è®¢é˜…å®ç°ç±» */ private class NotifySub extends JedisPubSub &#123; private final JedisPool jedisPool; public NotifySub(JedisPool jedisPool) &#123; this.jedisPool = jedisPool; &#125; /** * è®¢é˜…åçš„é€šçŸ¥å›è°ƒæ–¹æ³• * * @param key è®¢é˜…çš„keyï¼Œä¸€èˆ¬ä¸ºç±»ç›®ï¼Œå¦‚ï¼š/dubbo/com.alibaba.dubbo.demo.DemoService/providers * @param msg äº‹ä»¶æ¶ˆæ¯ */ @Override public void onMessage(String key, String msg) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"redis event: \" + key + \" = \" + msg); &#125; // æ”¶åˆ°register/unregisteräº‹ä»¶ï¼Œè°ƒç”¨#doNotifyæ–¹æ³•ï¼Œç»„è£…ç›®æ ‡URLç„¶åé€šçŸ¥ç›‘å¬å™¨ï¼Œä»è€Œå®ç°å®æ—¶æ›´æ–° if (msg.equals(Constants.REGISTER) || msg.equals(Constants.UNREGISTER)) &#123; try &#123; Jedis jedis = jedisPool.getResource(); try &#123; // è¿›è¡Œé€šçŸ¥ï¼Œè¿™é‡Œä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„é€šçŸ¥ doNotify(jedis, key); &#125; finally &#123; jedis.close(); &#125; &#125; catch (Throwable t) &#123; // TODO Notification failure does not restore mechanism guarantee logger.error(t.getMessage(), t); &#125; &#125; &#125; @Override public void onPMessage(String pattern, String key, String msg) &#123; onMessage(key, msg); &#125; @Override public void onSubscribe(String key, int num) &#123; &#125; @Override public void onPSubscribe(String pattern, int num) &#123; &#125; @Override public void onUnsubscribe(String key, int num) &#123; &#125; @Override public void onPUnsubscribe(String pattern, int num) &#123; &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; NotifySub ç»§æ‰¿ redis.clients.jedis.JedisPubSub æŠ½è±¡ç±»ï¼Œè¿™æ ·å®ƒå°±å…·æœ‰äº†è®¢é˜…çš„åŠŸèƒ½ï¼Œå®ƒä¹Ÿæ˜¯ RedisRegistry çš„å†…éƒ¨ç±»ã€‚å½“ jedis.psubscribe(JedisPubSub,channel) è®¢é˜…äº†é€šé“ï¼ˆæ”¯æŒé€šé…ç¬¦ï¼‰åï¼Œä¸€æ—¦è¯¥é€šé“æœ‰äº‹ä»¶æ¶ˆæ¯å‘å¸ƒ NotifySub çš„é€šçŸ¥å›è°ƒæ–¹æ³•å°±ä¼šè°ƒç”¨ï¼Œå°±èƒ½æ‹¿åˆ°å…·ä½“çš„é€šé“å’Œåœ¨é€šé“ä¸­å‘å¸ƒçš„äº‹ä»¶æ¶ˆæ¯ã€‚è‡³æ­¤ï¼Œ Redis æ³¨å†Œä¸­å¿ƒçš„ä¸¤å¤§æ ¸å¿ƒè§’è‰²å°±æœ‰äº†ï¼Œä¸‹é¢æˆ‘ä»¬ç®€å•æ¢³ç†ä¸‹æ•´ä¸ªè¿‡ç¨‹ã€‚ æœåŠ¡æä¾›è€…ã€æ¶ˆè´¹è€…åœ¨å¯åŠ¨è¿‡ç¨‹ä¼šè¿›è¡ŒæœåŠ¡çš„æ³¨å†Œå’Œè®¢é˜… 1 æ³¨å†Œçš„è¿‡ç¨‹ä¼šå…ˆæŠŠæœåŠ¡ä¿¡æ¯å†™å…¥åˆ°Redisä¸­ï¼Œå¹¶ä¸”é€šè¿‡åˆ†ç±»è·¯å¾„ â€˜Root + Service + Typeâ€™ è¿™ä¸ªé€šé“å‘å¸ƒæ³¨å†Œäº‹ä»¶æ¶ˆæ¯ register2 è®¢é˜…çš„è¿‡ç¨‹ä¼šå…ˆåˆ›å»ºä¸€ä¸ªé€šçŸ¥å™¨çº¿ç¨‹å¹¶å¯åŠ¨ï¼Œè¿™ä¸ªé€šçŸ¥å™¨çº¿ç¨‹ä¼šè®¢é˜…æœåŠ¡è·¯å¾„ â€˜Root + Service + *â€™ è¿™ä¸ªé€šé“ï¼Œè®¢é˜…åå°±åç­‰è¯¥é€šé“çš„äº‹ä»¶æ¶ˆæ¯ï¼ŒNotifySub å¯¹è±¡å°±æ˜¯ç”¨æ¥æ¥æ”¶é€šé“æ¶ˆæ¯çš„ã€‚ç„¶åä¼šä¸»åŠ¨ä»Redisæ³¨å†Œä¸­å¿ƒæ‹‰å– æœåŠ¡è·¯å¾„ â€˜Root + Service + *â€™ ä¸‹çš„æ‰€æœ‰åˆ†ç±»ã€‚ æœ‰æœåŠ¡ä¸‹çº¿ä¼šè¿›è¡Œåæ³¨å†Œ 1 åæ³¨å†Œä¼šå…ˆæŠŠæœåŠ¡ä¿¡æ¯ä»Redisä¸­åˆ é™¤ï¼Œå¹¶ä¸”é€šè¿‡åˆ†ç±»è·¯å¾„ â€˜Root + Service + Typeâ€™ è¿™ä¸ªé€šé“å‘å¸ƒåæ³¨å†Œäº‹ä»¶æ¶ˆæ¯ unregister2 å¦‚æœé€šçŸ¥å·²ç»è¢«è®¢é˜…ï¼Œé‚£ä¹ˆNotifySubå°±ä¼šæ¥æ”¶é€šé“å‘æ¥çš„ åæ³¨å†Œäº‹ä»¶æ¶ˆæ¯ unregister ç›‘æ§ä¸­å¿ƒå¯åŠ¨ä¼šè®¢é˜…æ‰€æœ‰æœåŠ¡ è®¢é˜…çš„è¿‡ç¨‹ä¼šå…ˆåˆ›å»ºä¸€ä¸ªé€šçŸ¥å™¨çº¿ç¨‹å¹¶å¯åŠ¨ï¼Œè¿™ä¸ªé€šçŸ¥å™¨çº¿ç¨‹ä¼šè®¢é˜…æœåŠ¡è·¯å¾„ â€˜Root + *â€™ è¿™ä¸ªé€šé“ï¼Œè®¢é˜…åå°±åç­‰è¯¥é€šé“çš„äº‹ä»¶æ¶ˆæ¯ã€‚ç„¶åä¼šä»Redisæ³¨å†Œä¸­å¿ƒæ‹‰å–æ‰€æœ‰æ•°æ®å¹¶åˆ†ç±»å­˜å‚¨åœ¨ç¼“å­˜ä¸­ ç›‘æ§ä¸­å¿ƒè¿›è¡ŒæœåŠ¡æ²»ç† æœåŠ¡æ²»ç†æ¶‰åŠåˆ°æ³¨å†Œå’Œåæ³¨å†Œï¼Œå¦‚ï¼šåˆ›å»ºæä¾›è€…ã€è®¾ç½®åŠ¨æ€é…ç½®ã€è®¾ç½®è·¯ç”±è§„åˆ™ç­‰ï¼Œéƒ½ä¼šå‘å¯¹åº”çš„é€šé“å‘é€æ¶ˆæ¯ã€‚è¿™äº›éƒ½ä¼šè§¦å‘ NotifySub é€šçŸ¥å›è°ƒ ä»¥ä¸Šåˆ†æä¸»è¦æ˜¯é’ˆå¯¹ æ³¨å†Œï¼ˆåæ³¨å†Œï¼‰å’Œè®¢é˜…çš„åˆ†æï¼Œæˆ‘ä»¬è¿˜å°‘äº†ä¸€æ­¥é€šçŸ¥ï¼Œå‰æ–‡è®¢é˜…çš„è¿‡ç¨‹ä¼šè°ƒç”¨é€šçŸ¥æ–¹æ³•ï¼Œä¸‹é¢æˆ‘ä»¬å°±æ¥åˆ†æ Redis æ³¨å†Œä¸­å¿ƒçš„é€šçŸ¥æ˜¯æ€ä¹ˆåšçš„ã€‚ é€šçŸ¥éœ€è¦è¯´æ˜çš„æ˜¯ï¼ŒZookeeper ç”±äºå¯ä»¥æ³¨å†Œç›‘å¬å™¨è¿›è€Œç›´æ¥æ‹¿åˆ°è®¢é˜…å…³æ³¨çš„å…¨é‡æ•°æ®ï¼Œä½†æ˜¯ Redis è®¢é˜…åå¾—åˆ°çš„é€šçŸ¥ç»“æœå¹¶ä¸æ˜¯è®¢é˜…å…³æ³¨çš„æ•°æ®è€Œæ˜¯å¤§Keyï¼Œéœ€è¦å¤šåšä¸€æ­¥æŸ¥è¯¢å¤§Keyå¯¹åº”çš„ç›®æ ‡URLé›†åˆï¼Œå³ ä½¿ç”¨ doNotify æ–¹æ³•å°† Redis ä¸­çš„æ•°æ®æ¥å…¥åˆ°åº”ç”¨ä¸­ï¼Œç„¶åå›è°ƒç›‘å¬å™¨çš„æ–¹æ³•å®Œæˆé€šçŸ¥ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 /** * @param jedis * @param key åˆ†ç±»ï¼ŒNotifySubè·å–åˆ°çš„ï¼Œä¾‹å¦‚ï¼š /dubbo/com.alibaba.dubbo.demo.DemoService/providers */ private void doNotify(Jedis jedis, String key) &#123; // è°ƒç”¨getSubscribed()æ–¹æ³•ï¼Œè·å¾—æ‰€æœ‰ è®¢é˜… URL çš„ç›‘å¬å™¨é›†åˆ for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed()).entrySet()) &#123; doNotify(jedis, Arrays.asList(key), entry.getKey(), new HashSet&lt;NotifyListener&gt;(entry.getValue())); &#125; &#125;/** * @param jedis Jedis * @param keys åˆ†ç±»æ•°ç»„ ï¼Œå¦‚ /dubbo/com.alibaba.dubbo.demo.DemoService/providers ï¼ˆé¦–æ¬¡ä¼šæ‹‰å–æŸä¸ªServiceå±‚ä¸‹çš„æ‰€æœ‰åˆ†ç±»ï¼‰ * @param url è®¢é˜…URL * @param listeners è®¢é˜…URLå¯¹åº”çš„ç›‘å¬å™¨é›†åˆ */ private void doNotify(Jedis jedis, Collection&lt;String&gt; keys, URL url, Collection&lt;NotifyListener&gt; listeners) &#123; if (keys == null || keys.isEmpty() || listeners == null || listeners.isEmpty()) &#123; return; &#125; // å½“å‰æ—¶é—´ long now = System.currentTimeMillis(); // ç›®æ ‡URLé›†åˆ List&lt;URL&gt; result = new ArrayList&lt;URL&gt;(); /** * è·å¾—è®¢é˜…URLçš„åˆ†ç±»ï¼Œä¸åŒçš„è§’è‰²å…³æ³¨ä¸åŒçš„åˆ†ç±»æ•°æ®ã€zookeeperä¹Ÿæ˜¯å¦‚æ­¤ã€‘ * 1 æœåŠ¡æä¾›è€…ï¼Œå…³æ³¨configurators * 2 æœåŠ¡æ¶ˆè´¹è€…ï¼Œå…³æ³¨providers,configurators.routers * 3 ç›‘æ§ä¸­å¿ƒå…³æ³¨æ‰€æœ‰ */ List&lt;String&gt; categories = Arrays.asList(url.getParameter(Constants.CATEGORY_KEY, new String[0])); // è®¢é˜…URLæ˜ å°„çš„æœåŠ¡æ¥å£å ï¼ŒRoot + Service String consumerService = url.getServiceInterface(); // å¾ªç¯åˆ†ç±»æ•°ç»„ï¼Œå¦‚ï¼š /dubbo/com.alibaba.dubbo.demo.DemoService/providers for (String key : keys) &#123; if (!Constants.ANY_VALUE.equals(consumerService)) &#123; // è·å–åˆ†ç±»å¯¹åº”çš„æœåŠ¡æ¥å£å ï¼ŒRoot + Service String prvoiderService = toServiceName(key); // åˆ†ç¦»å¯¹åº”çš„æœåŠ¡æ¥å£åæ˜¯å¦åŒ¹é…è®¢é˜…URLæ˜ å°„çš„æœåŠ¡æ¥å£å,ä¸åŒ¹é…ç›´æ¥è¿”å›ï¼Œè¯´æ˜ä¸æ˜¯è®¢é˜…URlå…³æ³¨çš„åˆ†ç±» if (!prvoiderService.equals(consumerService)) &#123; continue; &#125; &#125; // å¦‚æœè®¢é˜…URLä¸å…³æ³¨è¯¥åˆ†ç±»ï¼Œåˆ™ç›´æ¥è¿”å› String category = toCategoryName(key); if (!categories.contains(Constants.ANY_VALUE) &amp;&amp; !categories.contains(category)) &#123; continue; &#125; List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); // è·å¾—åˆ†ç±»ä¸‹æ‰€æœ‰URLæ•°ç»„ï¼Œå¦‚ï¼š /dubbo/com.alibaba.dubbo.demo.DemoService/providers ä¸‹çš„æ‰€æœ‰æä¾›è€…URLåŠå…¶è¿‡æœŸæ—¶é—´ Map&lt;String, String&gt; values = jedis.hgetAll(key); if (values != null &amp;&amp; values.size() &gt; 0) &#123; for (Map.Entry&lt;String, String&gt; entry : values.entrySet()) &#123; URL u = URL.valueOf(entry.getKey()); // è¿‡æ»¤æ‰å·²è¿‡æœŸçš„åŠ¨æ€èŠ‚ç‚¹ [åŠ¨æ€èŠ‚ç‚¹æ‰å¯èƒ½ä¼šå˜åŒ–ï¼ŒæŠŠåŠ¨æ€èŠ‚ç‚¹æ”¶é›†èµ·æ¥ï¼Œå»å’ŒåŸæ¥çš„èŠ‚ç‚¹å¯¹æ¯”ï¼Œçœ‹æ˜¯å¦æœ‰å˜åŒ–ï¼Œæœ‰å˜åŒ–å°±éœ€è¦åšäº›æ“ä½œï¼Œå¦‚ æœåŠ¡é‡æ–°æš´éœ²] if (!u.getParameter(Constants.DYNAMIC_KEY, true) || Long.parseLong(entry.getValue()) &gt;= now) &#123; if (UrlUtils.isMatch(url, u)) &#123; urls.add(u); &#125; &#125; &#125; &#125; // è‹¥ä¸å­˜åœ¨åŒ¹é…ï¼Œåˆ™åˆ›å»º `empty://` çš„ URL if (urls.isEmpty()) &#123; urls.add(url.setProtocol(Constants.EMPTY_PROTOCOL) .setAddress(Constants.ANYHOST_VALUE) .setPath(toServiceName(key)) .addParameter(Constants.CATEGORY_KEY, category)); &#125; result.addAll(urls); if (logger.isInfoEnabled()) &#123; logger.info(\"redis notify: \" + key + \" = \" + urls); &#125; &#125; if (result == null || result.isEmpty()) &#123; return; &#125; // å›è°ƒçˆ¶ç±»çš„notifyæ–¹æ³•ï¼Œè¿›è¡Œé€šçŸ¥ï¼Œè¿™é‡Œæ‰æ˜¯çœŸæ­£é€šçŸ¥ç›‘å¬å™¨çš„å…¥å£ã€‚æ¥ä¸‹æ¥çš„æµç¨‹å’Œ Zookeeper ä¸€è‡´ for (NotifyListener listener : listeners) &#123; notify(url, listener, result); &#125; &#125; è¯¥æ–¹æ³•éœ€è¦æ³¨æ„ä¸€ä¸ªç‚¹ï¼Œåˆ†ç±»ä¸ä¸€å®šèƒ½å¤ŸåŒ¹é…ä¸Šè®¢é˜…URLï¼Œå› æ­¤éœ€è¦è¿‡æ»¤ã€‚é€ æˆåŸå› å°±ä¸€ä¸ªï¼ŒRedis æ˜¯ä½¿ç”¨Root + Service è·å–åˆ†ç±»çš„ï¼Œä¸»åŠ¨è·å–å’Œè®¢é˜…éƒ½æ˜¯è¿™æ ·ã€‚è¯¥æ–¹æ³•çœ‹ç€é€»è¾‘ä¸å°‘ï¼Œä¸è¿‡ä¸»è¦åšäº†ä¸‰ä¸ªå·¥ä½œï¼š æ ¹æ®è®¢é˜…URLé€‰å‡ºåŒ¹é…çš„åˆ†ç±»ï¼Œå› ä¸º Redis æ˜¯æ ¹æ®è®¢é˜…URLçš„Root + Service è·å–å…¶ä¸‹çš„æ‰€æœ‰åˆ†ç±»ï¼Œä½†æ˜¯è®¢é˜…URLä¸­ä¹Ÿè®¸æ²¡æœ‰æŒ‡å®šé‚£ä¹ˆå¤šï¼Œå°±æ˜¯è®¢é˜…URLçš„categoryå‚æ•°çš„å€¼ã€‚ é€‰å‡ºåŒ¹é…çš„åˆ†ç±»åï¼Œè·å–åˆ†ç±»ä¸‹çš„URLé›†åˆï¼Œç„¶åç­›é€‰å‡ºæ²¡æœ‰è¿‡æœŸçš„URLã€‚å¦‚æœæ²¡æœ‰é¢„æœŸçš„URLï¼Œå°±åˆ›å»ºä¸€ä¸ª empty://â€¦ å›è°ƒNotifyListenerï¼Œè¿›è¡Œé€šçŸ¥ã€‚å¦‚ æœåŠ¡é‡æ–°æš´éœ²ï¼ŒæœåŠ¡ç›®å½•æ›´æ–°ç­‰ è‡³æ­¤ï¼ŒRedis æ³¨å†Œä¸­å¿ƒçš„ æ³¨å†Œï¼ˆåæ³¨å†Œï¼‰ã€è®¢é˜…ã€é€šçŸ¥åˆ†æå®Œæ¯•ï¼Œå€¼å¾—ä¸€è¯´çš„æ˜¯ Redis çš„å–æ¶ˆè®¢é˜…ä»€ä¹ˆéƒ½æ²¡æœ‰åšæ˜¯ä¸ªç©ºæ–¹æ³•ï¼Œåœ¨ZookeeperRegistryçš„è¯¥æ–¹æ³•ä¸­ï¼Œæ˜¯ç§»é™¤äº†å¯¹åº”çš„ç›‘å¬å™¨ï¼Œè¿™é‡Œç†è®ºä¸Š Redis åº”è¯¥è§£é™¤è®¢é˜…ï¼Œä¸è¿‡ Redis æŠŠè¿™ä¸ªæ”¶å°¾æ“ä½œæ”¾åˆ°äº† destroy æ–¹æ³•ä¸­äº†ï¼Œæˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹è¿™ä¸ªæ”¶å°¾æ–¹æ³•ã€‚ destroy123456789101112131415161718192021222324252627282930@Overridepublic void destroy() &#123; // çˆ¶ç±»å…³é—­ super.destroy(); try &#123; // å–æ¶ˆå®šæ—¶ä»»åŠ¡ï¼Œè¿‡æœŸæ—¶é—´ä¸ä¼šæ›´æ–° expireFuture.cancel(true); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; try &#123; // å…³é—­é€šçŸ¥å™¨ï¼Œä¾æ¬¡è°ƒç”¨ shutdownæ–¹æ³•ï¼Œåœæ­¢è®¢é˜…å·¥ä½œã€‚ for (Notifier notifier : notifiers.values()) &#123; notifier.shutdown(); &#125; &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; // å…³é—­è¿æ¥æ±  for (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123; JedisPool jedisPool = entry.getValue(); try &#123; jedisPool.destroy(); &#125; catch (Throwable t) &#123; logger.warn(\"Failed to destroy the redis registry client. registry: \" + entry.getKey() + \", cause: \" + t.getMessage(), t); &#125; &#125; // æœ€åä¼˜é›…å…³é—­è¿‡æœŸæ‰«æå®šæ—¶ä»»åŠ¡çº¿ç¨‹æ± ï¼Œå³ shutdown()..awaitTermination()çš„åº”ç”¨ã€‚ ExecutorUtil.gracefulShutdown(expireExecutor, expirePeriod);&#125; é”€æ¯æ–¹æ³•ä¸»è¦åšäº†ä»¥ä¸‹å·¥ä½œï¼š è°ƒç”¨çˆ¶ç±»FailbackRegistryçš„ destroy æ–¹æ³• å–æ¶ˆå»¶æ—¶keyè¿‡æœŸçš„ä»»åŠ¡ å…³é—­é€šçŸ¥å™¨çº¿ç¨‹ï¼Œåœæ­¢è®¢é˜…å·¥ä½œ å…³é—­JedisPoolï¼Œé‡Šæ”¾èµ„æº å°ç»“Redis ä½œä¸ºæ³¨å†Œä¸­å¿ƒä¸ Zookeeper ä½œä¸ºæ³¨å†Œçš„å‰ç½®æ“ä½œéƒ½æ˜¯ä¸€æ ·çš„ï¼Œå…¶æ ¸å¿ƒæ˜¯åŸºäº Redis çš„ Publish/Subscribe ã€‚å’Œ Zookeeper ç›¸æ¯”è¾ƒï¼ŒRedis åŠŸèƒ½å®ç°ä¼šç›¸å¯¹ç¹çä¸€äº›ï¼Œå¹¶ä¸”å…¶å¯é æ€§ä¾èµ–äº Redis æœ¬èº«çš„å¯é æ€§ï¼Œç›¸æ¯”è¾ƒ Redis ä¸€èˆ¬æ›´å¸¸ç”¨ Zookeeper ã€‚Redis ä½œä¸ºæ³¨å†Œä¸­å¿ƒçš„åŸç†è¿˜æ˜¯éå¸¸å€¼å¾—å­¦ä¹ çš„ï¼Œæ¯•ç«Ÿ Redis é‚£ä¹ˆæµè¡Œã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Redis","slug":"Redis","permalink":"https://gentryhuang.com/tags/Redis/"}]},{"title":"Dubboæºç åˆ†æ - Zookeeperå®¢æˆ·ç«¯","slug":"rpc/æ³¨å†Œä¸­å¿ƒä¹‹Zookeeperå®¢æˆ·ç«¯","date":"2020-04-19T16:00:00.000Z","updated":"2020-10-25T04:00:29.344Z","comments":false,"path":"posts/817d6a19/","link":"","permalink":"https://gentryhuang.com/posts/817d6a19/","excerpt":"","text":"å‰è¨€åœ¨ Dubboæºç åˆ†æ - Zookeeperæ³¨å†Œä¸­å¿ƒ ä¸­ä»‹ç»çš„æ˜¯ Dubbo çš„ Zookeeper æ³¨å†Œä¸­å¿ƒå®ç°ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰æ¶‰åŠåˆ° Zookeeper å®¢æˆ·ç«¯çš„æ“ä½œï¼Œä¸‹é¢æˆ‘ä»¬ä»‹ç» Zookeeper åœ¨ Dubbo æ¡†æ¶ä¸­å…·ä½“å®ç°ã€‚ æ¦‚è¿° ä¸Šå›¾çš„ UML æè¿°äº† Dubbo å°è£…çš„ Zookeeper æ³¨å†Œä¸­å¿ƒå’Œ Zookeeper ç›¸å…³å®ç°çš„å…³ç³»ã€‚ Dubbo å¯¹ Zookeeper å®¢æˆ·ç«¯çš„å°è£…æ˜¯åœ¨ dubbo-remoting-zookeeper æ¨¡å—ä¸­ï¼Œè¯¥æ¨¡å—å¯¹ Zookeeper å®¢æˆ·ç«¯æ¥å£è¿›è¡Œäº†æŠ½è±¡ã€‚åœ¨ Zookeeperæ³¨å†Œä¸­å¿ƒ ä¸­ä¹Ÿæåˆ° dubbo-remoting-zookeeper æ¨¡å—æ˜¯ dubbo-remoting æ¨¡å—çš„å­æ¨¡å—ï¼Œä½†å®ƒå¹¶ä¸ä¾èµ– dubbo-remoting ä¸­çš„å…¶ä»–æ¨¡å—ï¼Œæ˜¯ç›¸å¯¹ç‹¬ç«‹çš„ã€‚ ç›®å‰æ”¯æŒ ZkClient å’Œ Curator ä¸¤ç§ Zookeeper å®¢æˆ·ç«¯å®ç°ï¼š Curator å®ç° 1&lt;dubbo:registry ... client=\"curator\" /&gt; ZkClient å®ç° 1&lt;dubbo:registry ... client=\"zkclient\" /&gt; æ³¨æ„: åœ¨2.7.xçš„ç‰ˆæœ¬ä¸­å·²ç»ç§»é™¤äº†zkclientçš„å®ç°,å¦‚æœè¦ä½¿ç”¨zkclientå®¢æˆ·ç«¯,éœ€è¦æ˜¾ç¤ºé…ç½®ã€‚ä¸‹é¢åˆ†æä¸Šå›¾çš„ UML ä¸­æ¶‰åŠçš„æ¥å£å’Œå®ç°ç±»ã€‚ æ— è®ºæœåŠ¡æä¾›è€…è¿˜æ˜¯æ¶ˆè´¹è€…ï¼Œæˆ–è€…æœåŠ¡æ²»ç†ä¸­å¿ƒï¼Œä»»ä½•ä¸€ä¸ªèŠ‚ç‚¹è¿æ¥åˆ° Zookeeper æ³¨å†Œä¸­å¿ƒéƒ½éœ€è¦ä½¿ç”¨ä¸€ä¸ªå®¢æˆ·ç«¯ã€‚ä» Zookeeper æ¶æ„çš„è§’åº¦æ¥çœ‹ï¼Œä½¿ç”¨ Dubbo çš„ä¸šåŠ¡èŠ‚ç‚¹ä¹Ÿåªæ˜¯ä¸€ä¸ª Zookeeper å®¢æˆ·ç«¯ã€‚ ZookeeperTransporter12345678910111213@SPI(\"curator\")public interface ZookeeperTransporter &#123; /** * åˆ›å»º ZookeeperClient å¯¹è±¡ã€‚è¯¥æ–¹æ³•è¢« @Adaptive æ³¨è§£ä¿®é¥°ï¼Œå¯é€šè¿‡ URL å‚æ•°ä¸­çš„ client æˆ– transporter å‚æ•°è¦†ç›– @SPI æ³¨è§£æŒ‡å®šçš„é»˜è®¤æ‰©å±•å * * @param url æ³¨å†Œä¸­å¿ƒåœ°å€ * @return ZookeeperClient å¯¹è±¡ */ @Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;) ZookeeperClient connect(URL url);&#125; è¯¥æ¥å£æ˜¯ Dubbo çš„æ‰©å±•ç‚¹ï¼Œæ˜¯ Zookeeper å®¢æˆ·ç«¯å·¥å‚ï¼Œå°±æ˜¯ç”¨æ¥åˆ›å»º ZookeeperClient å¯¹è±¡çš„ã€‚ é»˜è®¤æ˜¯ä½¿ç”¨ CuratorZookeeperTransporter åˆ›å»º ZookeeperClient ï¼Œåé¢ä¼šè¯¦ç»†åˆ†æ ZookeeperClient ç»§æ‰¿ä½“ç³»ã€‚ä¸‹å›¾æ˜¯ä¸¤è€… UML å…³ç³»å›¾ï¼š StateListener123456789101112131415161718192021public interface StateListener &#123; /** * å·²æ–­å¼€ */ int DISCONNECTED = 0; /** * å·²è¿æ¥ */ int CONNECTED = 1; /** * å·²é‡è¿ */ int RECONNECTED = 2; /** * çŠ¶æ€å˜æ›´å›è°ƒæ–¹æ³• * * @param connected çŠ¶æ€ */ void stateChanged(int connected);&#125; è¯¥æ¥å£ä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„ç›‘å¬å™¨ï¼Œå®ƒçš„å®ç°æ˜¯ä¸€ä¸ªåŒ¿åå†…éƒ¨ç±»ï¼Œåœ¨ ZookeeperRegistry çš„æ„é€ æ–¹æ³•ä¸­ï¼Œä½œä¸º ZookeeperClient çš„çŠ¶æ€å˜åŒ–ï¼ˆä¼šè¯ï¼‰çš„å›è°ƒï¼Œå…·ä½“è°ƒç”¨å…¥å£æ˜¯ AbstractZookeeperClient#stateChanged(int) ï¼Œä¸»è¦è´Ÿè´£ç›‘å¬ Dubbo ä¸ Zookeeper é›†ç¾¤çš„è¿æ¥çŠ¶æ€ã€‚ 12345678910111213141516171819202122public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) &#123; // åˆ›å»º Zookeeper å®¢æˆ·ç«¯ï¼Œé»˜è®¤ä¸º CuratorZookeeperTransporterï¼Œç”±SPIç¡®å®šå…·ä½“çš„å®ä¾‹ã€‚åˆ›å»ºå¥½Zookeeperå®¢æˆ·ç«¯ï¼Œæ„å‘³ç€æ³¨å†Œä¸­å¿ƒçš„åˆ›å»ºå®Œæˆã€ZookeeperæœåŠ¡ç«¯å¿…éœ€å…ˆå¯åŠ¨ï¼ŒDubboåº”ç”¨ä½œä¸ºZookeeperçš„å®¢æˆ·ç«¯è¿›è¡Œè¿æ¥ï¼Œç„¶åæ“ä½œZookeeperã€‘ zkClient = zookeeperTransporter.connect(url); /** * æ·»åŠ  StateListener çŠ¶æ€ç›‘å¬å™¨ï¼Œè¯¥ç›‘å¬å™¨åœ¨é‡è¿æ—¶ï¼Œè°ƒç”¨æ¢å¤æ–¹æ³• recover()ï¼Œé‡æ–°å‘èµ·æ³¨å†Œå’Œè®¢é˜…ã€å°†ä¹‹å‰å·²ç»æ³¨å†Œå’Œè®¢é˜…çš„æ•°æ®è¿›è¡Œé‡è¯•ã€‘ * æ³¨æ„ï¼š * StateListener ä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„ç›‘å¬å™¨ï¼Œè¿™é‡Œå°±æ˜¯åˆ›å»ºäº†ä¸€ä¸ªåŒ¿åå¯¹è±¡ï¼Œå…¶ä¸­çš„ #stateChanged æ–¹æ³•è§¦å‘éœ€è¦ä¸»åŠ¨è°ƒç”¨è¯¥åŒ¿åå¯¹è±¡çš„è¯¥æ–¹æ³• &#123;@link AbstractZookeeperClient#stateChanged(int)&#125; */ zkClient.addStateListener(new StateListener() &#123; @Override public void stateChanged(int state) &#123; if (state == RECONNECTED) &#123; try &#123; recover(); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; &#125; &#125;); &#125; ChildListener1234567891011public interface ChildListener &#123; /** * å­èŠ‚ç‚¹å‘ç”Ÿå˜åŒ–çš„å›è°ƒ * * @param path èŠ‚ç‚¹ * @param children æœ€æ–°çš„å­èŠ‚ç‚¹åˆ—è¡¨ */ void childChanged(String path, List&lt;String&gt; children);&#125; è¯¥æ¥å£åªæ˜¯ä¸€ä¸ªæ™®é€šçš„æ¥å£ï¼Œå…·ä½“å®ç°æ˜¯ä¸€ä¸ªåŒ¿åå†…éƒ¨ç±»ï¼Œä¸»è¦ç›‘å¬æŸä¸ª ZNode èŠ‚ç‚¹ä¸‹çš„å­èŠ‚ç‚¹å˜åŒ–ã€‚å…¥å£åœ¨ ZookeeperRegistry å®ç°ç±»çš„ doSubscribe æ–¹æ³•ä¸­ï¼Œè¯¥æ¥å£çš„å¯¹è±¡æœ€ç»ˆä¼šç”¨äº Zookeeper å®¢æˆ·ç«¯çš„æŸä¸ªèŠ‚ç‚¹ä¸‹å­èŠ‚ç‚¹å˜åŒ–çš„å›è°ƒæ–¹æ³•ä¸­ï¼Œä¸‹é¢æˆ‘ä»¬å†åˆ†æä¸¤ç§å®¢æˆ·ç«¯çš„ä¸åŒå®ç°ã€‚ ZookeeperClient123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public interface ZookeeperClient &#123; /** * åˆ›å»ºèŠ‚ç‚¹ * * @param path èŠ‚ç‚¹è·¯å¾„ * @param ephemeral æ˜¯å¦ä¸´æ—¶èŠ‚ç‚¹ */ void create(String path, boolean ephemeral); /** * åˆ é™¤èŠ‚ç‚¹ * * @param path èŠ‚ç‚¹è·¯å¾„ */ void delete(String path); /** * è·å–æŒ‡å®šèŠ‚ç‚¹çš„å­èŠ‚ç‚¹é›†åˆ * @param path * @return */ List&lt;String&gt; getChildren(String path); /** * æ·»åŠ  ChildListener * * @param path èŠ‚ç‚¹è·¯å¾„ * @param listener ç›‘å¬å™¨ * @return å­èŠ‚ç‚¹åˆ—è¡¨ */ List&lt;String&gt; addChildListener(String path, ChildListener listener); /** * ç§»é™¤ ChildListener * * @param path èŠ‚ç‚¹è·¯å¾„ * @param listener ç›‘å¬å™¨ */ void removeChildListener(String path, ChildListener listener); /** * æ·»åŠ  StateListener * * @param listener ç›‘å¬å™¨ */ void addStateListener(StateListener listener); /** * ç§»é™¤ StateListener * * @param listener ç›‘å¬å™¨ */ void removeStateListener(StateListener listener); /** * @return æ˜¯å¦è¿æ¥ */ boolean isConnected(); /** * å…³é—­ */ void close(); /** * @return è·å¾—æ³¨å†Œä¸­å¿ƒ URL */ URL getUrl();&#125; ZookeeperClient æ¥å£æ˜¯ Dubbo å¯¹ Zookeeper å®¢æˆ·ç«¯æ¥å£çš„æŠ½è±¡ï¼Œå®šä¹‰äº†ä¸€ç³»åˆ—çš„æ“ä½œæ–¹æ³•ï¼Œéƒ½æ˜¯ç”¨æ¥å’Œ Zookeeper è¿›è¡Œäº¤äº’çš„ï¼Œå®ƒçš„å…·ä½“å­ç±»ä¸­å°è£…äº† Zookeeper çš„å®¢æˆ·ç«¯å¯¹è±¡ã€‚ AbstractZookeeperClientZookeeperClient æ¥å£çš„æŠ½è±¡ç±»ï¼Œä¸»è¦å®ç°äº†é€šç”¨çš„é€»è¾‘ï¼Œå¦‚ï¼Œåˆ›å»ºèŠ‚ç‚¹ï¼Œç®¡ç† ZookeeperClient å¯¹è±¡æ·»åŠ çš„ç›‘å¬å™¨ï¼Œç®¡ç† ZookeeperClient çš„è¿è¡ŒçŠ¶æ€ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940/** * å®ç° ZookeeperClient æ¥å£ï¼ŒZookeeper å®¢æˆ·ç«¯æŠ½è±¡ç±»ï¼Œå®ç°é€šç”¨çš„é€»è¾‘ã€‚ * * @param &lt;TargetChildListener&gt; æ³›å‹ */public abstract class AbstractZookeeperClient&lt;TargetChildListener&gt; implements ZookeeperClient &#123; protected static final Logger logger = LoggerFactory.getLogger(AbstractZookeeperClient.class); /** * æ³¨å†Œä¸­å¿ƒ URL */ private final URL url; /** * StateListener çŠ¶æ€ç›‘å¬å™¨é›†åˆ */ private final Set&lt;StateListener&gt; stateListeners = new CopyOnWriteArraySet&lt;StateListener&gt;(); /** * ChildListener é›†åˆ * &lt;p&gt; * key1ï¼šèŠ‚ç‚¹è·¯å¾„ * key2ï¼šChildListener å¯¹è±¡ * value ï¼šç›‘å¬å™¨å…·ä½“å¯¹è±¡ï¼Œä¸åŒ Zookeeper å®¢æˆ·ç«¯ï¼Œå®ç°ä¼šä¸åŒã€‚CuratorZookeeperClientçš„æ˜¯CuratorWatcher;ZkclientZookeeperClient çš„æ˜¯ IZkChildListener */ private final ConcurrentMap&lt;String, ConcurrentMap&lt;ChildListener, TargetChildListener&gt;&gt; childListeners = new ConcurrentHashMap&lt;String, ConcurrentMap&lt;ChildListener, TargetChildListener&gt;&gt;(); /** * æ˜¯å¦å…³é—­ */ private volatile boolean closed = false; public AbstractZookeeperClient(URL url) &#123; this.url = url; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; è¯¥æŠ½è±¡ç±»ä¸­çš„å±æ€§ä¸»è¦å››ä¸ªï¼ŒstateListeners å’Œ childListeners å±æ€§ç”¨äºåˆ†åˆ«ç®¡ç† StateListener å’Œ ChildListener ç›‘å¬å™¨ã€‚å…¶ä¸­ stateListeners å±æ€§æ˜¯å½“ Zookeeperçš„çŠ¶æ€å˜åŒ–æ—¶è¦é€šçŸ¥çš„å¯¹è±¡ï¼ŒchildListeners å±æ€§æ¯”è¾ƒå…³é”®ï¼Œæ˜¯èŠ‚ç‚¹è·¯å¾„åˆ°å…¶å­èŠ‚ç‚¹ç›‘å¬å™¨çš„æ˜ å°„ã€‚ create åˆ›å»ºèŠ‚ç‚¹1234567891011121314151617181920212223242526272829public abstract class AbstractZookeeperClient&lt;TargetChildListener&gt; implements ZookeeperClient &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; @Override public void create(String path, boolean ephemeral) &#123; if (!ephemeral) &#123; // å¦‚æœè¦åˆ›å»ºçš„èŠ‚ç‚¹ç±»å‹éä¸´æ—¶èŠ‚ç‚¹ï¼Œé‚£ä¹ˆè¿™é‡Œè¦æ£€æµ‹èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ã€‚ä¸´æ—¶èŠ‚ç‚¹æœ‰åºå·ï¼Œä¸éœ€è¦è€ƒè™‘è¦†ç›–é—®é¢˜ if (checkExists(path)) &#123; return; &#125; &#125; int i = path.lastIndexOf('/'); if (i &gt; 0) &#123; // é€’å½’åˆ›å»ºä¸Šä¸€çº§è·¯å¾„ create(path.substring(0, i), false); &#125; // æ ¹æ® ephemeral çš„å€¼åˆ›å»ºä¸´æ—¶æˆ–æŒä¹…èŠ‚ç‚¹ if (ephemeral) &#123; createEphemeral(path); &#125; else &#123; createPersistent(path); &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; StateListener æ“ä½œæ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546public abstract class AbstractZookeeperClient&lt;TargetChildListener&gt; implements ZookeeperClient &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * åŠ å…¥ StateListener åˆ°ç¼“å­˜ * * @param listener StateListener */ @Override public void addStateListener(StateListener listener) &#123; stateListeners.add(listener); &#125; /** * ç§»é™¤ç¼“å­˜ä¸­çš„ StateListener * * @param listener ç›‘å¬å™¨ */ @Override public void removeStateListener(StateListener listener) &#123; stateListeners.remove(listener); &#125; /** * è·å–ç¼“å­˜ä¸­çš„ StateListener * @return */ public Set&lt;StateListener&gt; getSessionListeners() &#123; return stateListeners; &#125; /** * éå†StateListener æ•°ç»„ï¼Œå›è°ƒ * * @param state çŠ¶æ€ */ protected void stateChanged(int state) &#123; for (StateListener sessionListener : getSessionListeners()) &#123; sessionListener.stateChanged(state); &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; StateListener æ“ä½œæ–¹æ³•å¾ˆç®€å•ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ addStateListener å’Œ stateChanged æ–¹æ³•ï¼Œå‰è€…æ˜¯åœ¨ ZookeeperRegistry æ„é€ æ–¹æ³•ä¸­è¢«è°ƒç”¨ï¼Œå‰æ–‡å·²ç»è¯´æ˜ã€‚åè€…æ˜¯å½“ Zookeeper å®¢æˆ·ç«¯çš„ä¼šè¯å˜åŒ–æ—¶ä¼šä¸»åŠ¨è°ƒç”¨ï¼Œä¸‹æ–‡ä¼šè¯´æ˜ã€‚ addChildListener123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class AbstractZookeeperClient&lt;TargetChildListener&gt; implements ZookeeperClient &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * * @param path è®¢é˜…url æ˜ å°„çš„ç›®å½•ï¼Œå¦‚ .../providers * @param listener è®¢é˜…url æ˜ å°„çš„ç›®å½•ä¸‹å­èŠ‚ç‚¹å˜åŒ–æ—¶æ‰§è¡Œå›è°ƒçš„å¯¹è±¡ */ @Override public List&lt;String&gt; addChildListener(String path, final ChildListener listener) &#123; // 1 è·å–/åˆ›å»ºï¼šConcurrentMap&lt;categorypath, ConcurrentMap&lt;ZookeeperRegistryçš„å†…éƒ¨ç±»ChildListenerå®ä¾‹, TargetChildListener&gt;&gt; childListenersï¼Œè¿™é‡Œä¸»è¦æ˜¯åˆ›å»ºTargetChildListener ConcurrentMap&lt;ChildListener, TargetChildListener&gt; listeners = childListeners.get(path); if (listeners == null) &#123; childListeners.putIfAbsent(path, new ConcurrentHashMap&lt;ChildListener, TargetChildListener&gt;()); listeners = childListeners.get(path); &#125; // è·å¾—æ˜¯å¦å·²ç»æœ‰è¯¥ç›‘å¬å™¨ TargetChildListener targetListener = listeners.get(listener); // zkç›‘å¬å™¨å¯¹è±¡ä¸å­˜åœ¨ï¼Œè¿›è¡Œåˆ›å»º if (targetListener == null) &#123; /** * 1 åˆ›å»ºä¸€ä¸ªç›‘å¬pathä¸‹å­èŠ‚ç‚¹çš„watcherã€CuratorZookeeperClientå®ç°ã€‘æˆ– IZkChildListener ã€ZkclientZookeeperClientå®ç°ã€‘ * 2 å½“pathä¸‹æœ‰å­èŠ‚ç‚¹å˜åŒ–æ—¶ï¼Œè°ƒç”¨listenerï¼ˆå³ä¼ å…¥çš„ZookeeperRegistryçš„å†…éƒ¨ç±»ChildListenerå®ä¾‹çš„childChanged(String parentPath, List&lt;String&gt; currentChilds)æ–¹æ³•ï¼‰ */ listeners.putIfAbsent(listener, createTargetChildListener(path, listener)); targetListener = listeners.get(listener); &#125; // å‘ Zookeeper ï¼ŒçœŸæ­£å‘èµ·è®¢é˜…ï¼Œå³ä¸º pathæ·»åŠ TargetChildListenerç›‘å¬å™¨å®ä¾‹ return addTargetChildListener(path, targetListener); &#125; /** * æŠ½è±¡æ–¹æ³•ï¼Œåˆ›å»ºçœŸæ­£çš„ ChildListener å¯¹è±¡ã€‚å› ä¸ºï¼Œæ¯ä¸ª Zookeeper çš„åº“ï¼Œå®ç°ä¸åŒã€‚ * * @param path * @param listener * @return */ protected abstract TargetChildListener createTargetChildListener(String path, ChildListener listener); /** * å‘ Zookeeper ï¼ŒçœŸæ­£å‘èµ·è®¢é˜… * * @param path * @param listener * @return */ protected abstract List&lt;String&gt; addTargetChildListener(String path, TargetChildListener listener); /** * å‘ Zookeeper ï¼ŒçœŸæ­£å‘èµ·å–æ¶ˆè®¢é˜… * * @param path * @param listener */ protected abstract void removeTargetChildListener(String path, TargetChildListener listener); // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; è¿™é‡Œçš„ createTargetChildListener(path, listener) æ–¹æ³•å’Œ addTargetChildListener(path, targetListener) æ–¹æ³•éƒ½æ˜¯æŠ½è±¡æ–¹æ³•ï¼Œç”± AbstractZookeeperClient çš„å­ç±»å®ç°ï¼ŒTargetChildListener æ˜¯ AbstractZookeeperClient ä¸­æ ‡è®°çš„ä¸€ä¸ªæ³›å‹ã€‚å› ä¸º ZookeeperClient å®ç°å¯èƒ½ä¾èµ–ä¸åŒçš„ Zookeeper å®¢æˆ·ç«¯ç»„ä»¶ï¼Œä¸åŒçš„ Zookeeper å®¢æˆ·ç«¯ç»„ä»¶çš„ç›‘å¬å™¨å®ç°æ˜¯ä¸åŒçš„ï¼Œè€Œæ•´ä¸ª dubbo-remoting-zookeeper æ¨¡å—è¿›è¡Œäº†æŠ½è±¡ï¼Œå¯¹å¤–æš´éœ²çš„ç›‘å¬å™¨æ˜¯ç»Ÿä¸€çš„ï¼Œä½¿ç”¨æ³›å‹è¿›è¡Œäº†è½¬æ¢ï¼ŒåŸåˆ™ä¸ŠæŠ½è±¡ä¸€ä¸ªæ¥å£ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚è¯¥æ–¹æ³•çš„æ ¸å¿ƒå°±æ˜¯ä¸ºè®¢é˜… URL æ˜ å°„çš„èŠ‚ç‚¹ç»‘å®šä¸€ä¸ªå­èŠ‚ç‚¹ç›‘å¬å™¨ï¼Œå­èŠ‚ç‚¹å‘ç”Ÿå˜åŒ–æ—¶ä¼šè¢«å­èŠ‚ç‚¹ç›‘å¬å™¨æ•æ‰åˆ°ï¼Œç„¶åå°†å˜åŒ–çš„æ•°æ®ä¿¡æ¯é€šè¿‡ ChildListener åŒ¿åå¯¹è±¡çš„æ–¹æ³•ä¼ é€’å‡ºå»ï¼Œä¸‹é¢ä¼šç»“åˆå…·ä½“çš„ Zookeeper å®¢æˆ·ç«¯è¯´æ˜ã€‚ removeChildListener12345678910111213141516171819public abstract class AbstractZookeeperClient&lt;TargetChildListener&gt; implements ZookeeperClient &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; @Override public void removeChildListener(String path, ChildListener listener) &#123; ConcurrentMap&lt;ChildListener, TargetChildListener&gt; listeners = childListeners.get(path); if (listeners != null) &#123; TargetChildListener targetListener = listeners.remove(listener); if (targetListener != null) &#123; // å‘ Zookeeper ï¼ŒçœŸæ­£å‘èµ·å–æ¶ˆè®¢é˜… removeTargetChildListener(path, targetListener); &#125; &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; è¯¥æ–¹æ³•ç”¨äºè§£é™¤ path ç›®å½•çš„å­èŠ‚ç‚¹å˜åŒ–ç›‘å¬å™¨ã€‚ ç›®å½•çš„å­èŠ‚ç‚¹å˜åŒ–ç›‘å¬å™¨æ“ä½œ123456789101112131415161718192021222324252627282930313233public abstract class AbstractZookeeperClient&lt;TargetChildListener&gt; implements ZookeeperClient &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * æŠ½è±¡æ–¹æ³•ï¼Œåˆ›å»ºçœŸæ­£çš„ ChildListener å¯¹è±¡ã€‚å› ä¸ºï¼Œæ¯ä¸ª Zookeeper çš„åº“ï¼Œå®ç°ä¸åŒã€‚ * * @param path * @param listener * @return */ protected abstract TargetChildListener createTargetChildListener(String path, ChildListener listener); /** * å‘ Zookeeper ï¼ŒçœŸæ­£å‘èµ·è®¢é˜… * * @param path * @param listener * @return */ protected abstract List&lt;String&gt; addTargetChildListener(String path, TargetChildListener listener); /** * å‘ Zookeeper ï¼ŒçœŸæ­£å‘èµ·å–æ¶ˆè®¢é˜… * * @param path * @param listener */ protected abstract void removeTargetChildListener(String path, TargetChildListener listener); // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; ä¸Šé¢ä¸‰ä¸ªæ–¹æ³•æ˜¯ç”¨æ¥å¯¹ path ç›®å½•ä¸‹çš„å­èŠ‚ç‚¹çš„ç›‘å¬å™¨è¿›è¡Œæ“ä½œçš„ï¼Œå…·ä½“é€»è¾‘äº¤ç»™å­ç±»å®ç°ã€‚ä¸‹é¢æˆ‘ä»¬è¯¦ç»†åˆ†æ AbstractZookeeperClient çš„ä¸¤ä¸ªå…·ä½“å®ç°ç±»ã€‚ CuratorZookeeperClientå±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class CuratorZookeeperClient extends AbstractZookeeperClient&lt;CuratorWatcher&gt; &#123; /** * Zookeeper çš„ Curator å®¢æˆ·ç«¯å¯¹è±¡ */ private final CuratorFramework client; /** * CuratorZookeeperClient æ„é€ æ–¹æ³•ä¸»è¦ç”¨äºåˆ›å»ºå’Œå¯åŠ¨ CuratorFramework å®ä¾‹ * * @param url */ public CuratorZookeeperClient(URL url) &#123; super(url); try &#123; // åˆ›å»º CuratorFramework æ„é€ å™¨ CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder() // è¿æ¥åœ°å€ .connectString(url.getBackupAddress()) // é‡è¯•ç­–ç•¥: é‡è¯•æ¬¡æ•°ï¼š1ï¼Œæ¯æ¬¡é‡è¯•é—´éš”ï¼š 1000 ms .retryPolicy(new RetryNTimes(1, 1000)) // è¿æ¥è¶…æ—¶æ—¶é—´ .connectionTimeoutMs(5000); String authority = url.getAuthority(); if (authority != null &amp;&amp; authority.length() &gt; 0) &#123; builder = builder.authorization(\"digest\", authority.getBytes()); &#125; // æ„å»º CuratorFramework å®ä¾‹ client = builder.build(); // æ·»åŠ è¿æ¥ç›‘å¬å™¨ã€‚åœ¨è¿æ¥çŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè°ƒç”¨#stateChange(state)æ–¹æ³•ï¼Œè¿›è¡ŒStateListenerçš„å›è°ƒ client.getConnectionStateListenable().addListener(new ConnectionStateListener() &#123; /** * åœ¨è¿æ¥çŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè°ƒç”¨ #stateChange(state) æ–¹æ³•ï¼Œè¿›è¡Œ StateListener çš„å›è°ƒã€‚ * @param client * @param state */ @Override public void stateChanged(CuratorFramework client, ConnectionState state) &#123; if (state == ConnectionState.LOST) &#123; CuratorZookeeperClient.this.stateChanged(StateListener.DISCONNECTED); &#125; else if (state == ConnectionState.CONNECTED) &#123; CuratorZookeeperClient.this.stateChanged(StateListener.CONNECTED); &#125; else if (state == ConnectionState.RECONNECTED) &#123; CuratorZookeeperClient.this.stateChanged(StateListener.RECONNECTED); &#125; &#125; &#125;); // å¯åŠ¨å®¢æˆ·ç«¯ (å½“è¿æ¥ä¸ä¸ŠzkæœåŠ¡æ—¶ï¼Œé»˜è®¤å°†ä¸€ç›´é‡è¯•) client.start(); &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; ä» CuratorZookeeperClient çš„å±æ€§ä¸­ï¼Œå¯ä»¥å¾—åˆ°ä¸Šæ–‡ä¸­çš„ä¸€ä¸ªç­”æ¡ˆï¼ŒstateChanged æ–¹æ³•è°ƒç”¨çš„å…¥å£ï¼ŒCuratorZookeeperClient æ„é€ æ–¹æ³•æ‰§è¡Œå®Œæ¯•ï¼ŒZookeeper çš„ Curator å®¢æˆ·ç«¯è¿æ¥åˆ›å»ºå®Œæ¯•ã€‚ æ“ä½œèŠ‚ç‚¹æ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class CuratorZookeeperClient extends AbstractZookeeperClient&lt;CuratorWatcher&gt; &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * åˆ›å»º path æŒä¹…èŠ‚ç‚¹ * * @param path */ @Override public void createPersistent(String path) &#123; try &#123; client.create().forPath(path); &#125; catch (NodeExistsException e) &#123; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; /** * åˆ›å»º path ä¸´æ—¶èŠ‚ç‚¹ * * @param path */ @Override public void createEphemeral(String path) &#123; try &#123; client.create().withMode(CreateMode.EPHEMERAL).forPath(path); &#125; catch (NodeExistsException e) &#123; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; /** * åˆ é™¤ path èŠ‚ç‚¹ * * @param path èŠ‚ç‚¹è·¯å¾„ */ @Override public void delete(String path) &#123; try &#123; client.delete().forPath(path); &#125; catch (NoNodeException e) &#123; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; /** * è·å– path èŠ‚ç‚¹ä¸‹çš„å­èŠ‚ç‚¹åˆ—è¡¨ * * @param path * @return */ @Override public List&lt;String&gt; getChildren(String path) &#123; try &#123; return client.getChildren().forPath(path); &#125; catch (NoNodeException e) &#123; return null; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; /** * æ£€æŸ¥ path èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ * * @param path * @return */ @Override public boolean checkExists(String path) &#123; try &#123; if (client.checkExists().forPath(path) != null) &#123; return true; &#125; &#125; catch (Exception e) &#123; &#125; return false; &#125; /** * è¿æ¥æ˜¯å¦å·²ç»å…³é—­ * * @return */ @Override public boolean isConnected() &#123; return client.getZookeeperClient().isConnected(); &#125; /** * å…³é—­è¿æ¥ */ @Override public void doClose() &#123; client.close(); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; CuratorZookeeperClient ä¸­çš„æ“ä½œèŠ‚ç‚¹çš„æ–¹æ³•å¾ˆç®€å•ï¼Œç›´æ¥è°ƒç”¨ Curator çš„ API å³å¯ã€‚ å­èŠ‚ç‚¹ç›‘å¬å™¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class CuratorZookeeperClient extends AbstractZookeeperClient&lt;CuratorWatcher&gt; &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * åˆ›å»ºä¸€ä¸ªç›‘å¬pathå­èŠ‚ç‚¹çš„watcher æ³¨æ„ï¼šè¿™é‡Œåªæ˜¯åˆ›å»ºä¸€ä¸ªCuratorWatcherç›‘å¬å™¨ï¼Œå¹¶æ²¡æœ‰å¯¹èŠ‚ç‚¹è¿›è¡Œç»‘å®š * * @param path * @param listener * @return */ @Override public CuratorWatcher createTargetChildListener(String path, ChildListener listener) &#123; return new CuratorWatcherImpl(listener); &#125; /** * ä¸ºpathèŠ‚ç‚¹ç»‘å®šCuratorWatcherç›‘å¬å™¨ï¼Œå¹¶è¿”å›pathçš„å­è·¯å¾„åˆ—è¡¨ * * @param path * @param listener * @return */ @Override public List&lt;String&gt; addTargetChildListener(String path, CuratorWatcher listener) &#123; try &#123; return client.getChildren().usingWatcher(listener).forPath(path); &#125; catch (NoNodeException e) &#123; return null; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; /** * ç§»é™¤ç›‘å¬å™¨ * * @param path * @param listener */ @Override public void removeTargetChildListener(String path, CuratorWatcher listener) &#123; ((CuratorWatcherImpl) listener).unwatch(); &#125; /** * å®ç°CuratorWatcheræ¥å£ï¼Œå®ç°ç›‘å¬å™¨åŠŸèƒ½ã€‚CuratorWatcherImpl å°±æ˜¯ CuratorZookeeperClient å®ç° AbstractZookeeperClient æ—¶æŒ‡å®šçš„æ³›å‹ç±» */ private class CuratorWatcherImpl implements CuratorWatcher &#123; /** * ChildListener åŒ¿åå¯¹è±¡ */ private volatile ChildListener listener; public CuratorWatcherImpl(ChildListener listener) &#123; this.listener = listener; &#125; public void unwatch() &#123; this.listener = null; &#125; /** * 1 å½“pathèŠ‚ç‚¹ä¸‹çš„å­èŠ‚ç‚¹å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œä¼šé¦–å…ˆè°ƒç”¨TargetChildListenerçš„process(WatchedEvent event)æ–¹æ³•ï¼Œ * 2 åœ¨è¯¥æ–¹æ³•ä¸­åˆä¼šè°ƒç”¨ChildListenerå®ä¾‹çš„childChanged(String parentPath, List&lt;String&gt; currentChilds)æ–¹æ³• * 3 é…ç½®ä¿¡æ¯è¿˜æ˜¯é€šè¿‡å®¢æˆ·ç«¯æ‹‰å– * @param event * @throws Exception */ @Override public void process(WatchedEvent event) throws Exception &#123; if (listener != null) &#123; String path = event.getPath() == null ? \"\" : event.getPath(); // ä¸»åŠ¨è°ƒç”¨ChildListener åŒ¿åå¯¹è±¡çš„æ–¹æ³• listener.childChanged(path, // if path is null, curator using watcher will throw NullPointerException. // if client connect or disconnect to server, zookeeper will queue // watched event(Watcher.Event.EventType.None, .., path = null). StringUtils.isNotEmpty(path) ? client.getChildren().usingWatcher(this).forPath(path) // é‡æ–°å‘èµ·è¿æ¥ï¼Œå¹¶ä¼ å…¥æœ€æ–°çš„å­èŠ‚ç‚¹åˆ—è¡¨ : Collections.&lt;String&gt;emptyList()); &#125; &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; å­èŠ‚ç‚¹ç›‘å¬å™¨ï¼Œæ ¸å¿ƒæ˜¯å®ç° CuratorWatcher æ¥å£ï¼Œå®ç°ç›‘å¬å™¨åŠŸèƒ½ï¼ŒCuratorWatcherImpl å°±æ˜¯ CuratorZookeeperClient å®ç° AbstractZookeeperClient æ—¶æŒ‡å®šçš„æ³›å‹ç±»ã€‚å½“ç›‘å¬çš„èŠ‚ç‚¹ä¸‹çš„å­èŠ‚ç‚¹å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä¼šåœ¨ç›‘å¬å™¨çš„å›è°ƒæ–¹æ³•ä¸­ä¸»åŠ¨è°ƒç”¨ ChildListener åŒ¿åå¯¹è±¡çš„ childChanged æ–¹æ³•ï¼Œè¿™æ˜¯ Dubbo ä¸­è®¢é˜…çš„æ ¸å¿ƒç‚¹ã€‚ ZkclientZookeeperClientZkclientZookeeperClient å¹¶æ²¡æœ‰ç›´æ¥å°è£… ZkClient å¯¹è±¡ï¼Œè€Œæ˜¯é€šè¿‡ ZkClientWrapper å°è£…äº† ZkClient å¯¹è±¡ï¼Œæˆ‘ä»¬å…ˆæ¥åˆ†æ ZkClientWrapperã€‚ ZkClientWrapper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177public class ZkClientWrapper &#123; Logger logger = LoggerFactory.getLogger(ZkClientWrapper.class); /** * è¶…æ—¶æ—¶é—´ */ private long timeout; /** * Zookeeper çš„ ZkClient å®¢æˆ·ç«¯ */ private ZkClient client; /** * çŠ¶æ€ */ private volatile KeeperState state; /** * FutureTask */ private ListenableFutureTask&lt;ZkClient&gt; listenableFutureTask; /** * æ˜¯å¦å¼€å§‹ */ private volatile boolean started = false; /** * @param serverAddr Zookeeper æœåŠ¡ç«¯åœ°å€ * @param timeout è¶…æ—¶æ—¶é—´ */ public ZkClientWrapper(final String serverAddr, long timeout) &#123; this.timeout = timeout; listenableFutureTask = ListenableFutureTask.create(new Callable&lt;ZkClient&gt;() &#123; /** * é€šè¿‡å›è°ƒåˆ›å»º Zookeeper çš„ ZkClient å®¢æˆ·ç«¯ * @return * @throws Exception */ @Override public ZkClient call() throws Exception &#123; return new ZkClient(serverAddr, Integer.MAX_VALUE); &#125; &#125;); &#125; /** * åˆ›å»ºZ ookeeper çš„ ZkClient å®¢æˆ·ç«¯ */ public void start() &#123; if (!started) &#123; Thread connectThread = new Thread(listenableFutureTask); connectThread.setName(\"DubboZkclientConnector\"); connectThread.setDaemon(true); connectThread.start(); try &#123; client = listenableFutureTask.get(timeout, TimeUnit.MILLISECONDS); &#125; catch (Throwable t) &#123; logger.error(\"Timeout! zookeeper server can not be connected in : \" + timeout + \"ms!\", t); &#125; started = true; &#125; else &#123; logger.warn(\"Zkclient has already been started!\"); &#125; &#125; /** * è®¾ç½®å®¢æˆ·ç«¯ç›‘å¬å™¨ * * @param listener */ public void addListener(final IZkStateListener listener) &#123; listenableFutureTask.addListener(new Runnable() &#123; @Override public void run() &#123; try &#123; client = listenableFutureTask.get(); client.subscribeStateChanges(listener); &#125; catch (InterruptedException e) &#123; logger.warn(Thread.currentThread().getName() + \" was interrupted unexpectedly, which may cause unpredictable exception!\"); &#125; catch (ExecutionException e) &#123; logger.error(\"Got an exception when trying to create zkclient instance, can not connect to zookeeper server, please check!\", e); &#125; &#125; &#125;); &#125; /** * ZkClient æ˜¯å¦å¤„ç†è¿æ¥çŠ¶æ€ * * @return */ public boolean isConnected() &#123; return client != null &amp;&amp; state == KeeperState.SyncConnected; &#125; /** * ä½¿ç”¨ ZkClient AIP åˆ›å»ºæŒä¹…èŠ‚ç‚¹ * * @param path */ public void createPersistent(String path) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); client.createPersistent(path, true); &#125; /** * ä½¿ç”¨ ZkClient AIP åˆ›å»ºä¸´æ—¶èŠ‚ç‚¹ * * @param path */ public void createEphemeral(String path) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); client.createEphemeral(path); &#125; /** * ä½¿ç”¨ ZkClient AIP åˆ é™¤èŠ‚ç‚¹ * * @param path */ public void delete(String path) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); client.delete(path); &#125; /** * ä½¿ç”¨ ZkClient AIP è·å– path èŠ‚ç‚¹ä¸‹çš„å­èŠ‚ç‚¹åˆ—è¡¨ * * @param path * @return */ public List&lt;String&gt; getChildren(String path) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); return client.getChildren(path); &#125; /** * ä½¿ç”¨ ZkClient AIP åˆ¤æ–­æ˜¯å¦å­˜åœ¨ path èŠ‚ç‚¹ * * @param path * @return */ public boolean exists(String path) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); return client.exists(path); &#125; /** * æ–­å¼€ Zookeeper è¿æ¥ */ public void close() &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); client.close(); &#125; /** * ä¸º path èŠ‚ç‚¹ç»‘å®šå…¶å­èŠ‚ç‚¹çš„ç›‘å¬å™¨ï¼Œç”¨äºç›‘å¬ path èŠ‚ç‚¹ä¸‹å­èŠ‚ç‚¹çš„å˜åŒ– * * @param path * @param listener * @return */ public List&lt;String&gt; subscribeChildChanges(String path, final IZkChildListener listener) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); return client.subscribeChildChanges(path, listener); &#125; /** * åˆ é™¤ path èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ç›‘å¬å™¨ * * @param path * @param listener */ public void unsubscribeChildChanges(String path, IZkChildListener listener) &#123; Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\")); client.unsubscribeChildChanges(path, listener); &#125;&#125; ZkClientWrapper ç”¨æ¥åˆ›å»º Zookeeper çš„ ZkClient å®¢æˆ·ç«¯ï¼Œå¹¶è°ƒç”¨ ZkClient API æ“ä½œèŠ‚ç‚¹ä»¥åŠç»‘å®šç›‘å¬å™¨ï¼Œä»£ç å·²ç»è¯¦ç»†æ³¨é‡Šã€‚ä¸‹é¢æˆ‘ä»¬ç»§ç»­çœ‹ ZkclientZookeeperClient å®ç°ç±»ã€‚ å±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ZkclientZookeeperClient extends AbstractZookeeperClient&lt;IZkChildListener&gt; &#123; /** * å°è£…äº† Zookeeper çš„ ZkClient å¯¹è±¡ */ private final ZkClientWrapper client; /** * çŠ¶æ€å¯¹è±¡ */ private volatile KeeperState state = KeeperState.SyncConnected; /** * ZkclientZookeeperClient æ„é€ æ–¹æ³•ä¸»è¦ç”¨äºåˆ›å»ºå’Œå¯åŠ¨ ZkClient å®ä¾‹ * * @param url */ public ZkclientZookeeperClient(URL url) &#123; super(url); // åˆ›å»º ZkClientWrapper ã€åŒ…è£…äº†ZkClient,å®ç°ç›‘å¬ã€‘ client = new ZkClientWrapper(url.getBackupAddress(), 30000); // æ·»åŠ ç›‘å¬å™¨åˆ° ZkClient å¯¹è±¡ client.addListener(new IZkStateListener() &#123; /** * å¤„ç†çŠ¶æ€å˜åŒ– * @param state * @throws Exception */ @Override public void handleStateChanged(KeeperState state) throws Exception &#123; ZkclientZookeeperClient.this.state = state; /** * çŠ¶æ€å˜æ›´è¿›è¡Œå›è°ƒ &#123;@link StateListener#stateChanged(int)&#125; */ if (state == KeeperState.Disconnected) &#123; stateChanged(StateListener.DISCONNECTED); &#125; else if (state == KeeperState.SyncConnected) &#123; stateChanged(StateListener.CONNECTED); &#125; &#125; /** * å¤„ç†æ–°ä¼šè¯ ï¼ˆå¤„ç†å¤±è´¥é‡è¿ï¼‰ï¼Œæœ€ç»ˆä¼šå›è°ƒ&#123;@link StateListener#stateChanged(int)&#125; * @throws Exception */ @Override public void handleNewSession() throws Exception &#123; stateChanged(StateListener.RECONNECTED); &#125; &#125;); // åˆ›å»ºå®¢æˆ·ç«¯ client.start(); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; client å±æ€§å¯¹åº”çš„ ZkClientWrapper ä¸­å°è£…äº† ZkClient å®¢æˆ·ç«¯å¯¹è±¡ï¼Œæ„é€ æ–¹æ³•ä¸»è¦åšäº†ä¸¤ä»¶äº‹ï¼Œåˆ›å»º ZkClient å¹¶ä¸ºå…¶ç»‘å®šçŠ¶æ€ç›‘å¬å™¨ã€‚ æ“ä½œèŠ‚ç‚¹æ–¹æ³•1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ZkclientZookeeperClient extends AbstractZookeeperClient&lt;IZkChildListener&gt; &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * è°ƒç”¨ ZkClientWrapper çš„ createPersistent æ–¹æ³•ï¼Œä»¥ä¸‹åŒç† * * @param path */ @Override public void createPersistent(String path) &#123; try &#123; client.createPersistent(path); &#125; catch (ZkNodeExistsException e) &#123; &#125; &#125; @Override public void createEphemeral(String path) &#123; try &#123; client.createEphemeral(path); &#125; catch (ZkNodeExistsException e) &#123; &#125; &#125; @Override public void delete(String path) &#123; try &#123; client.delete(path); &#125; catch (ZkNoNodeException e) &#123; &#125; &#125; @Override public List&lt;String&gt; getChildren(String path) &#123; try &#123; return client.getChildren(path); &#125; catch (ZkNoNodeException e) &#123; return null; &#125; &#125; @Override public boolean checkExists(String path) &#123; try &#123; return client.exists(path); &#125; catch (Throwable t) &#123; &#125; return false; &#125; @Override public boolean isConnected() &#123; return state == KeeperState.SyncConnected; &#125; @Override public void doClose() &#123; client.close(); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; å­èŠ‚ç‚¹ç›‘å¬å™¨12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ZkclientZookeeperClient extends AbstractZookeeperClient&lt;IZkChildListener&gt; &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * åˆ›å»ºèŠ‚ç‚¹ç›‘å¬å™¨ * * @param path * @param listener * @return */ @Override public IZkChildListener createTargetChildListener(String path, final ChildListener listener) &#123; return new IZkChildListener() &#123; /** * ç›‘å¬çš„å­èŠ‚ç‚¹å‘ç”Ÿå˜åŒ–ä¼šå›è°ƒè¯¥æ–¹æ³•ï¼Œæ–¹æ³•ä¸»åŠ¨è°ƒç”¨ ChildListenerçš„åŒ¿åå¯¹è±¡çš„æ–¹æ³• * @param parentPath çˆ¶èŠ‚ç‚¹ * @param currentChilds å­èŠ‚ç‚¹åˆ—è¡¨ * @throws Exception */ @Override public void handleChildChange(String parentPath, List&lt;String&gt; currentChilds) throws Exception &#123; listener.childChanged(parentPath, currentChilds); &#125; &#125;; &#125; /** * ä¸º path èŠ‚ç‚¹ç»‘å®šå­èŠ‚ç‚¹ç›‘å¬å™¨ * * @param path * @param listener pathçš„å­èŠ‚ç‚¹ç›‘å¬å™¨ * @return */ @Override public List&lt;String&gt; addTargetChildListener(String path, final IZkChildListener listener) &#123; return client.subscribeChildChanges(path, listener); &#125; /** * ç§»é™¤ path èŠ‚ç‚¹ç»‘å®šçš„å­èŠ‚ç‚¹ç›‘å¬å™¨ * * @param path * @param listener pathçš„å­èŠ‚ç‚¹ç›‘å¬å™¨ */ @Override public void removeTargetChildListener(String path, IZkChildListener listener) &#123; client.unsubscribeChildChanges(path, listener); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; å®ç°ä¸Šå’Œ Curator å®¢æˆ·ç«¯æœ‰æ‰€å·®åˆ«ï¼Œä½†æœ¬è´¨ä¸Šæ˜¯ç›¸åŒçš„ã€‚ å°ç»“è‡³æ­¤ï¼Œdubbo-remoting-zookeeper æ¨¡å—çš„æ ¸å¿ƒå®ç°å°±ä»‹ç»å®Œäº†ï¼Œè¯¥æ¨¡å—ä½œä¸º Dubbo ä¸ Zookeeper äº¤äº’çš„åŸºç¡€ï¼Œä¸ä»…æ”¯æ’‘äº†åŸºäº Zookeeper çš„æ³¨å†Œä¸­å¿ƒçš„å®ç°ï¼Œè¿˜æ”¯æ’‘äº†åŸºäº Zookeeper çš„æœåŠ¡å‘ç°çš„å®ç°ã€‚Dubbo ä¸­çš„ Zookeeper å®¢æˆ·ç«¯ä¸»è¦ä¸¤éƒ¨åˆ†æ“ä½œï¼ŒèŠ‚ç‚¹çš„æ“ä½œå’ŒèŠ‚ç‚¹ç›‘å¬å™¨çš„æ“ä½œï¼ŒèŠ‚ç‚¹çš„æ“ä½œä¸»è¦æ˜¯æ³¨å†ŒæœåŠ¡çš„å…ƒæ•°æ®ä¿¡æ¯ï¼ŒèŠ‚ç‚¹ç›‘å¬å™¨çš„æ“ä½œä¸»è¦æ˜¯ç”¨äºè®¢é˜…é€šçŸ¥ï¼Œè®¢é˜…é€šçŸ¥ä¾èµ–æœåŠ¡èŠ‚ç‚¹çš„å…ƒæ•°æ®å˜åŒ–ä¿¡æ¯ï¼Œè¿™æ­£æ˜¯ç›‘å¬å™¨æ¥å®Œæˆçš„ã€‚","categories":[],"tags":[]},{"title":"Dubboæºç åˆ†æ - Zookeeperæ³¨å†Œä¸­å¿ƒ","slug":"rpc/æ³¨å†Œä¸­å¿ƒä¹‹Zookeeper","date":"2020-04-16T16:00:00.000Z","updated":"2020-11-14T03:14:54.716Z","comments":false,"path":"posts/f70c2f2e/","link":"","permalink":"https://gentryhuang.com/posts/f70c2f2e/","excerpt":"","text":"å‰è¨€æ³¨å†Œä¸­å¿ƒæ€»è§ˆ ä¸­ä»‹ç»äº† Dubbo çš„æ³¨å†Œä¸­å¿ƒæŠ½è±¡å±‚ï¼ŒåŒ…æ‹¬æ³¨å†Œä¸­å¿ƒåŠå…¶å·¥å‚ã€‚æœ¬ç¯‡æ–‡ç« å°†ä»‹ç» Dubbo çš„ Zookeeper æ³¨å†Œä¸­å¿ƒåŠå…¶å·¥å‚ã€‚ UML å›¾ä¸­ ZookeeperRegistryFactory ä¸­æœ‰ä¸ª ZookeeperTransporter å±æ€§ï¼Œè¯¥å±æ€§å°±æ˜¯åˆ›å»º Zookeeper å®¢æˆ·ç«¯çš„å…³é”®å¯¹è±¡ï¼Œä¸‹ä¸€ç¯‡æ–‡ç« ä¼šè¯¦ç»†ä»‹ç» Dubbo å¯¹ Zookeeper å®¢æˆ·ç«¯çš„å°è£…ã€‚ Dubbo ä¸­çš„ Zookeeper æ³¨å†Œä¸­å¿ƒZookeeper æ˜¯ Apache Hadoop çš„å­é¡¹ç›®ï¼Œæ˜¯ä¸€ä¸ªæ ‘å‹çš„ç›®å½•æœåŠ¡ï¼Œæ”¯æŒå˜æ›´æ¨é€ï¼Œé€‚åˆä½œä¸º Dubbo æœåŠ¡çš„æ³¨å†Œä¸­å¿ƒï¼Œå·¥ä¸šå¼ºåº¦è¾ƒé«˜ï¼Œå¯ç”¨äºç”Ÿäº§ç¯å¢ƒï¼Œå¹¶æ¨èä½¿ç”¨ã€‚ä¸‹å›¾æ˜¯ Dubbo ä½¿ç”¨ Zookeeper ä½œä¸ºæ³¨å†Œä¸­å¿ƒçš„å…ƒæ•°æ®ä¿¡æ¯ï¼š Dubbo ä¸­çš„ Zookeeper æ³¨å†Œä¸­å¿ƒè¯´æ˜ Zookeeper æ˜¯æ ‘å½¢ç»“æ„çš„æ³¨å†Œä¸­å¿ƒï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„ç±»å‹åˆ†ä¸ºæŒä¹…èŠ‚ç‚¹ã€æŒä¹…é¡ºåºèŠ‚ç‚¹ã€ä¸´æ—¶èŠ‚ç‚¹å’Œä¸´æ—¶é¡ºåºèŠ‚ç‚¹ã€‚ 1234æŒä¹…èŠ‚ç‚¹ï¼šæœåŠ¡æ³¨å†Œåä¿è¯èŠ‚ç‚¹ä¸ä¼šä¸¢å¤±ï¼Œæ³¨å†Œä¸­å¿ƒé‡å¯ä¹Ÿä¼šå­˜åœ¨ã€‚æŒä¹…é¡ºåºèŠ‚ç‚¹ï¼šåœ¨æŒä¹…èŠ‚ç‚¹ç‰¹æ€§çš„åŸºç¡€ä¸Šå¢åŠ äº†èŠ‚ç‚¹å…ˆåé¡ºåºçš„ç‰¹ç‚¹ã€‚ä¸´æ—¶èŠ‚ç‚¹ï¼šèŠ‚ç‚¹æ³¨å†Œåï¼Œå¦‚æœå®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯çš„è¿æ¥æ–­å¼€æˆ–ä¼šè¯è¶…æ—¶ï¼ŒèŠ‚ç‚¹ä¼šè‡ªåŠ¨è¢«åˆ é™¤ã€‚ä¸´æ—¶é¡ºåºèŠ‚ç‚¹ï¼šåœ¨ä¸´æ—¶èŠ‚ç‚¹ç‰¹æ€§çš„åŸºç¡€ä¸Šå¢åŠ äº†èŠ‚ç‚¹å…ˆåå±æ€§çš„ç‰¹ç‚¹ã€‚ Dubbo ä½¿ç”¨ Zookeeper ä½œä¸ºæ³¨å†Œä¸­å¿ƒæ—¶ï¼Œåªä¼šåˆ›å»ºæŒä¹…èŠ‚ç‚¹å’Œä¸´æ—¶èŠ‚ç‚¹ï¼Œä¸å…³å¿ƒèŠ‚ç‚¹çš„é¡ºåºã€‚ èŠ‚ç‚¹è·¯å¾„è¯´æ˜ Root å±‚ï¼šZookeeperçš„æ ¹ç›®å½•ï¼Œé»˜è®¤æ˜¯ dubbo ï¼Œä¹Ÿå¯ä»¥è¿›è¡Œè®¾ç½®ã€‚å¯¹åº”å›¾ä¸­çš„dubboã€‚ Service å±‚ï¼šæœåŠ¡æ¥å£çš„å…¨è·¯å¾„åï¼Œå¯¹åº”å›¾ä¸­çš„ com.foo.BarService ã€‚ Type å±‚ï¼šç›®å½•ï¼Œå¯¹äº Dubbo è€Œè¨€å°±æ˜¯åˆ†ç±»ï¼Œç›®å‰ Dubbo æœ‰å››ä¸ªåˆ†ç±»ï¼ŒæœåŠ¡æä¾›è€…åˆ—è¡¨ï¼ˆprovidersï¼‰ã€æœåŠ¡æ¶ˆè´¹è€…åˆ—è¡¨ï¼ˆconsumersï¼‰ã€è·¯ç”±è§„åˆ™åˆ—è¡¨ï¼ˆroutersï¼‰å’Œ é…ç½®è§„åˆ™åˆ—è¡¨(configurators) URL å±‚ï¼šDubbo çš„ URLï¼Œå¯ä»¥æ˜¯æœåŠ¡æä¾›è€… URLã€æœåŠ¡æ¶ˆè´¹è€… URLã€è·¯ç”±è§„åˆ™ URLã€ä»¥åŠé…ç½®è§„åˆ™ URLï¼Œå…·ä½“å“ªç±»ï¼Œçœ‹åœ¨å“ªä¸ª Type å±‚ä¸‹ã€‚ æ³¨æ„ï¼ŒURL å±‚çš„å…ƒæ•°æ®ä¿¡æ¯æ˜¯ä¸´æ—¶èŠ‚ç‚¹ï¼Œå…¶ä¸Šå±‚çš„èŠ‚ç‚¹æ˜¯æŒä¹…èŠ‚ç‚¹ã€‚ æ ‘å½¢ç»“æ„çš„å…³ç³» 123456&#x2F;dubbo +-- service +-- providers +-- consumers +-- routers +-- configurators æ ‘çš„æ ¹èŠ‚ç‚¹é»˜è®¤æ˜¯dubboï¼Œä¸‹é¢æœ‰å¤šä¸ªæœåŠ¡æ¥å£ï¼Œæ ¹èŠ‚ç‚¹å¯ä»¥æ‰‹åŠ¨è®¾ç½®ã€‚ æœåŠ¡æ¥å£ä¸‹åŒ…å«å››ç§å­ç›®å½•ï¼Œåˆ†åˆ«æ˜¯ providersã€consumersã€routersã€configuratorsï¼Œè¿™äº›è·¯å¾„æ˜¯æŒä¹…èŠ‚ç‚¹ã€‚ æœåŠ¡æä¾›è€…ç›®å½•[/dubbo/service/providers]ä¸‹é¢åŒ…å«çš„æ¥å£æœ‰å¤šä¸ªæœåŠ¡æä¾›è€…URLå…ƒæ•°æ®ä¿¡æ¯ æœåŠ¡æ¶ˆè´¹è€…ç›®å½•[/dubbo/service/consumers]ä¸‹é¢åŒ…å«çš„æ¥å£æœ‰å¤šä¸ªæ¶ˆè´¹è€…URLå…ƒæ•°æ®ä¿¡æ¯ è·¯ç”±è§„åˆ™ç›®å½•[/dubbo/service/routers]ä¸‹é¢åŒ…å«å¤šä¸ªç”¨äºæ¶ˆè´¹è€…è·¯ç”±ç­–ç•¥URLå…ƒæ•°æ®ä¿¡æ¯ åŠ¨æ€é…ç½®ç›®å½•[/dubbo/service/configurators]ä¸‹é¢åŒ…å«å¤šä¸ªç”¨äºæœåŠ¡æä¾›è€…åŠ¨æ€é…ç½®URLå…ƒæ•°æ®ä¿¡æ¯ åœ¨ Dubbo æ¡†æ¶å¯åŠ¨å¯åŠ¨æ—¶ï¼Œä¼šæ ¹æ®ç”¨æˆ·é…ç½®çš„æœåŠ¡ï¼Œåœ¨ Zookeeper æ³¨å†Œä¸­å¿ƒä¸­åˆ›å»º4ä¸ªç›®å½•ï¼Œè¿™é‡Œè¯´çš„ Dubbo æ¡†æ¶å¯åŠ¨åŒ…æ‹¬æä¾›è€…å’Œæ¶ˆè´¹è€…å¯åŠ¨ã€‚ æµç¨‹ç®€å•è¯´æ˜ï¼š æœåŠ¡æä¾›è€…å¯åŠ¨æ—¶: å‘ /dubbo/com.foo.BarService/providers ç›®å½•ä¸‹å†™å…¥è‡ªå·±çš„ URL åœ°å€ æœåŠ¡æ¶ˆè´¹è€…å¯åŠ¨æ—¶: è®¢é˜… /dubbo/com.foo.BarService/providers ç›®å½•ä¸‹çš„æä¾›è€… URL åœ°å€ã€‚å¹¶å‘ /dubbo/com.foo.BarService/consumers ç›®å½•ä¸‹å†™å…¥è‡ªå·±çš„ URL åœ°å€ ç›‘æ§ä¸­å¿ƒå¯åŠ¨æ—¶: è®¢é˜… /dubbo/com.foo.BarService ç›®å½•ä¸‹çš„æ‰€æœ‰æä¾›è€…å’Œæ¶ˆè´¹è€… URL åœ°å€ æ³¨æ„: ä¸Šé¢æè¿°çš„å¹¶ä¸æ˜¯å®Œæ•´çš„æµç¨‹ï¼Œåªæ˜¯æ ¹æ®å›¾è¿›è¡Œç®€å•è¯´æ˜ï¼Œæ¯”å¦‚ï¼ŒæœåŠ¡æä¾›è€…ä¸ä»…å†™å…¥äº†è‡ªå·±çš„ URL åœ°å€ï¼Œè¿˜è®¢é˜…äº† configurators ç›®å½•ä¸‹çš„ URL åœ°å€ï¼Œæ¶ˆè´¹è€…é™¤äº†è®¢é˜… providers ç›®å½•ä¸‹çš„ URL åœ°å€ï¼Œè¿˜è®¢é˜…äº† routers å’Œ configurators ç›®å½•ä¸‹çš„ URL åœ°å€ã€‚ åœ¨ Dubbo æ¡†æ¶è¿›è¡ŒæœåŠ¡è°ƒç”¨æ—¶ï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡æœåŠ¡æ²»ç†å¹³å°åœ¨è¿è¡Œæ—¶æ”¹å˜æœåŠ¡å‚æ•°ï¼ŒæœåŠ¡ç«¯ä¼šé€šè¿‡è®¢é˜…æœºåˆ¶å†³å®šæ˜¯å¦éœ€è¦é‡æ–°æš´éœ²æœåŠ¡ï¼Œæ¶ˆè´¹ç«¯é€šè¿‡è®¢é˜…æœºåˆ¶å†³å®šæ˜¯å¦æ›´æ–°æœåŠ¡ç›®å½•ç­‰ã€‚ æ”¯æŒä½†ä¸é™äºä»¥ä¸‹åŠŸèƒ½ï¼š å½“æä¾›è€…å‡ºç°æ–­ç”µç­‰å¼‚å¸¸åœæœºæ—¶ï¼Œæ³¨å†Œä¸­å¿ƒèƒ½è‡ªåŠ¨åˆ é™¤æä¾›è€…ä¿¡æ¯ å½“æ³¨å†Œä¸­å¿ƒé‡å¯æ—¶ï¼Œèƒ½è‡ªåŠ¨æ¢å¤æ³¨å†Œæ•°æ®ï¼Œä»¥åŠè®¢é˜…è¯·æ±‚ å½“ä¼šè¯è¿‡æœŸæ—¶ï¼Œèƒ½è‡ªåŠ¨æ¢å¤æ³¨å†Œæ•°æ®ï¼Œä»¥åŠè®¢é˜…è¯·æ±‚ å½“è®¾ç½® &lt;dubbo:registry check=â€falseâ€ /&gt; æ—¶ï¼Œè®°å½•å¤±è´¥æ³¨å†Œå’Œè®¢é˜…è¯·æ±‚ï¼Œåå°å®šæ—¶é‡è¯• å¯é€šè¿‡ &lt;dubbo:registry username=â€adminâ€ password=â€1234â€ /&gt; è®¾ç½® zookeeper ç™»å½•ä¿¡æ¯ å¯é€šè¿‡ &lt;dubbo:registry group=â€dubboâ€ /&gt; è®¾ç½® zookeeper çš„æ ¹èŠ‚ç‚¹ï¼Œä¸é…ç½®å°†ä½¿ç”¨é»˜è®¤çš„æ ¹èŠ‚ç‚¹ã€‚ æ”¯æŒ * å·é€šé…ç¬¦ &lt;dubbo:reference group=â€*â€ version=â€*â€ /&gt;ï¼Œå¯è®¢é˜…æœåŠ¡çš„æ‰€æœ‰åˆ†ç»„å’Œæ‰€æœ‰ç‰ˆæœ¬çš„æä¾›è€… ZookeeperRegistryFactoryå®ç° AbstractRegistryFactory æŠ½è±¡ç±»ï¼Œè¯¥æŠ½è±¡ç±»ä»…ä»…æ˜¯æä¾›äº†ç¼“å­˜ Registry å¯¹è±¡çš„åŠŸèƒ½ï¼Œå…·ä½“åˆ›å»ºé€»è¾‘äº¤ç»™å­ç±»å®Œæˆï¼Œè¿™é‡Œæ˜¯ ZookeeperRegistry çš„å·¥å‚ã€‚ 12345678910111213141516171819202122public class ZookeeperRegistryFactory extends AbstractRegistryFactory &#123; /** * zookeeperTransporter ç”± SPI åœ¨è¿è¡Œæ—¶æ³¨å…¥ï¼Œç±»å‹ä¸º ZookeeperTransporter$Adaptiveã€‚ æ˜¯Zookeeperçš„å®¢æˆ·ç«¯å·¥å‚ */ private ZookeeperTransporter zookeeperTransporter; /** * è®¾ç½®Zookeeperå®¢æˆ·ç«¯ å·¥å‚ï¼Œè¯¥æ–¹æ³•é€šè¿‡Dubbo IOC æ³¨å…¥ * * @param zookeeperTransporter */ public void setZookeeperTransporter(ZookeeperTransporter zookeeperTransporter) &#123; this.zookeeperTransporter = zookeeperTransporter; &#125; @Override public Registry createRegistry(URL url) &#123; // åˆ›å»º ZookeeperRegistry return new ZookeeperRegistry(url, zookeeperTransporter); &#125;&#125; ZookeeperRegistryFactory å°±æ˜¯ç”¨æ¥åˆ›å»º ZookeeperRegistry å¯¹è±¡çš„ï¼Œè€Œ ZookeeperRegistry å¯¹è±¡éœ€è¦ä¾èµ–åˆ›å»º Zookeeper å®¢æˆ·ç«¯çš„ ZookeeperTransporter å¯¹è±¡ï¼Œè¯¥å¯¹è±¡æ˜¯é€šè¿‡ Dubbo IOC æ³¨å…¥çš„ï¼Œè¯¦ç»†å¯å‚è€ƒ Dubbo SPI ã€‚ZookeeperTransporter æ‰€åœ¨çš„æ¨¡å—æ˜¯ dubbo-remoting-zookeeper ï¼Œå®ƒè™½ç„¶æ˜¯ dubbo-remoting æ¨¡å—çš„å­æ¨¡å—ï¼Œä½†å®ƒå¹¶ä¸ä¾èµ– dubbo-remoting ä¸­çš„å…¶å®ƒæ¨¡å—ï¼Œæ˜¯ç›¸å¯¹ç‹¬ç«‹çš„ï¼Œæˆ‘ä»¬åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ä»‹ç»å®ƒã€‚ ä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹ ZookeeperRegistry çš„å®ç°ã€‚ ZookeeperRegistryè¯¥ç±»ç»§æ‰¿æŠ½è±¡ç±» FailbackRegistry ï¼Œå…·æœ‰é‡è¯•åŠŸèƒ½ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * ZookeeperRegistry */public class ZookeeperRegistry extends FailbackRegistry &#123; private final static Logger logger = LoggerFactory.getLogger(ZookeeperRegistry.class); /** * Zookeeper é»˜è®¤ç«¯å£ */ private final static int DEFAULT_ZOOKEEPER_PORT = 2181; /** * Dubbo å…ƒæ•°æ®å†™å…¥Zookeeperä¸Šçš„æ ¹èŠ‚ç‚¹ï¼Œé»˜è®¤å€¼æ˜¯ dubbo */ private final static String DEFAULT_ROOT = \"dubbo\"; /** * Zookeeper æ ¹èŠ‚ç‚¹ */ private final String root; /** * Service æ¥å£å…¨åé›†åˆã€‚è¯¥å±æ€§é€‚åˆç”¨äºç›‘æ§ä¸­å¿ƒï¼Œè®¢é˜…æ•´ä¸ªServiceå±‚ï¼Œå› ä¸ºServiceå±‚æ˜¯åŠ¨æ€çš„ */ private final Set&lt;String&gt; anyServices = new ConcurrentHashSet&lt;String&gt;(); /** * ç›‘å¬å™¨é›†åˆï¼Œå»ºç«‹NotifyListenerå’ŒChildListenerçš„æ˜ å°„å…³ç³»ï¼Œk1ä¸ºè®¢é˜…URL,k2ä¸ºç›‘å¬å™¨,valueä¸ºChildListenerã€çœŸæ­£èµ·ä½œç”¨çš„å¯¹è±¡ã€‘ */ private final ConcurrentMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt; zkListeners = new ConcurrentHashMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt;(); /** * Zookeeper å®¢æˆ·ç«¯ */ private final ZookeeperClient zkClient; public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) &#123; super(url); if (url.isAnyHost()) &#123; throw new IllegalStateException(\"registry address == null\"); &#125; // è·å–ç»„åï¼Œé»˜è®¤ä¸º 'dubbo'ï¼Œurl.parameters.group å‚æ•°å€¼ï¼Œå³Zookeeperçš„æ ¹èŠ‚ç‚¹ String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT); if (!group.startsWith(Constants.PATH_SEPARATOR)) &#123; // è®¢æ­£è·¯å¾„ï¼š group = \"/\" + group; group = Constants.PATH_SEPARATOR + group; &#125; // ç¡®å®šæ ¹è·¯å¾„ï¼Œä»¥ç»„åä½œä¸ºæ ¹è·¯å¾„ this.root = group; // åˆ›å»º Zookeeper å®¢æˆ·ç«¯ï¼Œé»˜è®¤ä¸º CuratorZookeeperTransporterï¼Œç”±SPIç¡®å®šå…·ä½“çš„å®ä¾‹ã€‚åˆ›å»ºå¥½Zookeeperå®¢æˆ·ç«¯ï¼Œæ„å‘³ç€æ³¨å†Œä¸­å¿ƒçš„åˆ›å»ºå®Œæˆã€ZookeeperæœåŠ¡ç«¯å¿…éœ€å…ˆå¯åŠ¨ï¼ŒDubboåº”ç”¨ä½œä¸ºZookeeperçš„å®¢æˆ·ç«¯è¿›è¡Œè¿æ¥ï¼Œç„¶åæ“ä½œZookeeperã€‘ zkClient = zookeeperTransporter.connect(url); /** * æ·»åŠ  StateListener çŠ¶æ€ç›‘å¬å™¨ï¼Œè¯¥ç›‘å¬å™¨åœ¨é‡è¿æ—¶ï¼Œè°ƒç”¨æ¢å¤æ–¹æ³• recover()ï¼Œé‡æ–°å‘èµ·æ³¨å†Œå’Œè®¢é˜…ã€å°†ä¹‹å‰å·²ç»æ³¨å†Œå’Œè®¢é˜…çš„æ•°æ®è¿›è¡Œé‡è¯•ã€‘ * æ³¨æ„ï¼š * StateListener ä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„ç›‘å¬å™¨ï¼Œè¿™é‡Œå°±æ˜¯åˆ›å»ºäº†ä¸€ä¸ªåŒ¿åå¯¹è±¡ï¼Œå…¶ä¸­çš„ #stateChanged æ–¹æ³•è§¦å‘éœ€è¦ä¸»åŠ¨è°ƒç”¨è¯¥åŒ¿åå¯¹è±¡çš„è¯¥æ–¹æ³• &#123;@link AbstractZookeeperClient#stateChanged(int)&#125; */ zkClient.addStateListener(new StateListener() &#123; @Override public void stateChanged(int state) &#123; if (state == RECONNECTED) &#123; try &#123; recover(); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; &#125; &#125;); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; åœ¨ ZookeeperRegistry çš„æ„é€ æ–¹æ³•ä¸­ï¼Œä¼šé€šè¿‡ ZookeeperTransporter åˆ›å»º ZookeeperClient å®ä¾‹å¹¶è¿æ¥åˆ° Zookeeper é›†ç¾¤ï¼ŒåŒæ—¶è¿˜ä¼šæ·»åŠ ä¸€ä¸ªè¿æ¥çŠ¶æ€çš„ç›‘å¬å™¨ã€‚åœ¨è¯¥ç›‘å¬å™¨ä¸­ä¸»è¦å…³æ³¨RECONNECTED çŠ¶æ€ï¼Œåœ¨å½“å‰ Dubbo èŠ‚ç‚¹äº Zookeeper çš„è¿æ¥æ¢å¤æ—¶ï¼Œä¼šé‡æ–°è¿›è¡Œæ³¨å†Œï¼Œè®¢é˜…æ“ä½œï¼Œé˜²æ­¢æ•°æ®ä¸¢å¤±ã€‚ doRegister æ³¨å†Œ12345678910111213141516171819202122232425262728/** * ZookeeperRegistry */public class ZookeeperRegistry extends FailbackRegistry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * è°ƒç”¨Zookeeperå®¢æˆ·ç«¯åˆ›å»ºæœåŠ¡èŠ‚ç‚¹ * * @param url */ @Override protected void doRegister(URL url) &#123; try &#123; /** * 1 é€šè¿‡ Zookeeper å®¢æˆ·ç«¯åˆ›å»ºèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹è·¯å¾„ç”± toUrlPath æ–¹æ³•ç”Ÿæˆï¼Œè·¯å¾„æ ¼å¼å¦‚ä¸‹: /$&#123;group&#125;/$&#123;serviceInterface&#125;/$&#123;Type&#125;/$&#123;url&#125; * æ¯”å¦‚ï¼š /dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F127.0.0.1...... * 2 url.parameters.dynamic ,æ˜¯å¦åŠ¨æ€æ•°æ®ã€‚è‹¥ä¸ºfalseï¼Œè¯¥æ•°æ®ä¸ºæŒä¹…æ•°æ®ï¼Œå½“æ³¨å†Œæ–¹é€€å‡ºæ—¶ï¼Œæ•°æ®ä»ç„¶ä¿å­˜åœ¨æ³¨å†Œä¸­å¿ƒ */ zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true)); &#125; catch (Throwable e) &#123; throw new RpcException(\"Failed to register \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; è¯¥æ–¹æ³•æ˜¯å®ç°äº†å…¶çˆ¶ç±» FailbackRegistry çš„æ¨¡ç‰ˆæ–¹æ³•ï¼Œä½¿ç”¨ Zookeeper å®¢æˆ·ç«¯è¿›è¡ŒèŠ‚ç‚¹çš„åˆ›å»ºã€‚æœåŠ¡æä¾›è€…å’Œæ¶ˆè´¹è€…éƒ½éœ€è¦æŠŠè‡ªå·±æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒï¼ŒæœåŠ¡æä¾›è€…çš„æ³¨å†Œæ˜¯ä¸ºäº†è®©æ¶ˆè´¹è€…å‘ç°è‡ªå·±ä»è€Œå‘èµ·è¿œç¨‹è°ƒç”¨ã€‚ä¹Ÿè®©æ²»ç†ä¸­å¿ƒæ„ŸçŸ¥æœ‰æ–°çš„æœåŠ¡æä¾›è€…ä¸Šçº¿ã€‚æ¶ˆè´¹è€…çš„å‘å¸ƒæ˜¯ä¸ºäº†è®©æœåŠ¡æ²»ç†ä¸­å¿ƒå‘ç°è‡ªå·±ã€‚ doUnregister å–æ¶ˆæ³¨å†Œ12345678910111213141516171819202122/** * ZookeeperRegistry */public class ZookeeperRegistry extends FailbackRegistry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * å–æ¶ˆæ³¨å†Œï¼Œåˆ é™¤èŠ‚ç‚¹ * * @param url */ @Override protected void doUnregister(URL url) &#123; try &#123; zkClient.delete(toUrlPath(url)); &#125; catch (Throwable e) &#123; throw new RpcException(\"Failed to unregister \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; è¯¥æ–¹æ³•æ˜¯å®ç°äº†å…¶çˆ¶ç±» FailbackRegistry çš„æ¨¡ç‰ˆæ–¹æ³•ï¼Œä½¿ç”¨ Zookeeper å®¢æˆ·ç«¯è¿›è¡ŒèŠ‚ç‚¹çš„åˆ é™¤ã€‚ doSubscribe è®¢é˜…è®¢é˜…é€šå¸¸æœ‰ pull å’Œ push ä¸¤ç§æ–¹å¼ï¼Œä¸€ç§æ˜¯å®¢æˆ·ç«¯å®šæ—¶è½®è¯¢æ³¨å†Œä¸­å¿ƒæ‹‰å–é…ç½®ï¼Œå¦ä¸€ç§æ˜¯æ³¨å†Œä¸­å¿ƒä¸»åŠ¨æ¨é€æ•°æ®ç»™å®¢æˆ·ç«¯ã€‚ç›®å‰ Dubbo é‡‡ç”¨çš„æ˜¯ ç¬¬ä¸€æ¬¡å¯åŠ¨æ‹‰å–æ–¹å¼ï¼Œåç»­æ¥æ”¶äº‹ä»¶é‡æ–°æ‹‰å–æ•°æ®ã€‚åœ¨æœåŠ¡æš´éœ²æ—¶ï¼ŒæœåŠ¡æä¾›è€…ä¼šè®¢é˜… configurators ç”¨äºç›‘å¬åŠ¨æ€é…ç½®ã€‚åœ¨æ¶ˆè´¹ç«¯å¯åŠ¨æ—¶ï¼Œæ¶ˆè´¹è€…ä¼šè®¢é˜… providers,routers å’Œ configurators è¿™ä¸‰ä¸ªç›®å½•ï¼Œç”¨äºåˆ†åˆ«ç›‘å¬æœåŠ¡æä¾›è€…ã€è·¯ç”±è§„åˆ™å’ŒåŠ¨æ€é…ç½®ã€‚Zookeeper æ³¨å†Œä¸­å¿ƒé‡‡ç”¨çš„æ˜¯ äº‹ä»¶é€šçŸ¥ + å®¢æˆ·ç«¯æ‹‰å– çš„æ–¹å¼ï¼Œç¬¬ä¸€æ¬¡è®¢é˜…æ—¶ä¼šæŠŠå¯¹åº”ç›®å½•ä¸‹çš„å…¨é‡æ•°æ®éƒ½æ‹‰å–è¿‡æ¥ï¼ˆå®¢æˆ·ç«¯æ‹‰å–ï¼‰ï¼Œå¹¶åœ¨è®¢é˜…çš„èŠ‚ç‚¹ä¸Šæ³¨å†Œç›‘å¬å™¨ç›‘å¬å…¶å­èŠ‚ç‚¹çš„å˜åŒ–ã€‚å®¢æˆ·ç«¯ä¸æ³¨å†Œä¸­å¿ƒä¹‹é—´ä¿æŒ TCP é•¿è¿æ¥ï¼Œåç»­æ¯ä¸ªè®¢é˜…èŠ‚ç‚¹æœ‰ä»»ä½•æ•°æ®å˜åŒ–ï¼ˆå­èŠ‚ç‚¹å˜åŒ–ä¹Ÿå±äºè¯¥èŠ‚ç‚¹å˜åŒ–ï¼Œå…·ä½“å¯å‚æ•°ZKå®¢æˆ·ç«¯APIï¼‰æ—¶ï¼Œæ³¨å†Œä¸­å¿ƒä¼šæ ¹æ®ç›‘å¬å™¨çš„å›è°ƒä¸»åŠ¨é€šçŸ¥å®¢æˆ·ç«¯ï¼ˆäº‹ä»¶é€šçŸ¥ï¼‰ï¼Œå®¢æˆ·ç«¯æ¥åˆ°é€šçŸ¥åï¼Œä¼šæŠŠå¯¹åº”èŠ‚ç‚¹ä¸‹çš„å…¨é‡æ•°æ®éƒ½æ‹‰å–è¿‡æ¥ï¼ˆå®¢æˆ·ç«¯æ‹‰å–ï¼‰ï¼Œå³å­èŠ‚ç‚¹å˜åŒ–æ—¶ç›‘å¬å™¨æ•æ‰åˆ°äº‹ä»¶åä¼šå›è°ƒå®ƒçš„æ–¹æ³•ï¼Œè¯¥å›è°ƒæ–¹æ³•ä¼šè°ƒç”¨childChangedæ–¹æ³•ï¼Œè€ŒchildChangedæ–¹æ³•ä¼šæŠŠå¯¹åº”èŠ‚ç‚¹ä¸‹çš„å…¨é‡æ•°æ®éƒ½æ‹‰å–è¿‡æ¥ï¼ˆå®¢æˆ·ç«¯æ‹‰å–ï¼‰ã€‚éœ€è¦è¯´æ˜çš„ï¼ŒZookeeper ç›‘å¬å™¨è¢«è§¦å‘æ—¶ï¼Œç”± Zookeeper é›†ç¾¤ä¸»åŠ¨å°†æ›´æ–°æ¨é€ç»™ Zookeeper å®¢æˆ·ç«¯ï¼Œè€Œä¸éœ€è¦å®¢æˆ·ç«¯è½®è¯¢ã€‚ Dubbo åº”ç”¨ä½œä¸ºä¸€ä¸ª Zookeeper å®¢æˆ·ç«¯ï¼Œå½“ç›‘å¬çš„èŠ‚ç‚¹å‘ç”Ÿå˜åŒ–æ—¶ Zookeeper é›†ç¾¤ä¼šä¸»åŠ¨æŠŠå¯¹åº”èŠ‚ç‚¹ä¸‹çš„æ›´æ–°æ¨é€ç»™ Zookeeper å®¢æˆ·ç«¯ä¹Ÿå°±æ˜¯ Dubbo åº”ç”¨ï¼Œè¿™ä¸ªè¿‡ç¨‹æ˜¯æ³¨å†Œä¸­å¿ƒä¸»åŠ¨æ¨çš„ï¼Œä½† Dubbo æ˜¯å°†è¿™ä¸ªæ›´æ–°é€šè¿‡è‡ªå·±å†…éƒ¨çš„æ–¹æ³• childChanged ä¼ é€’å‡ºå»çš„ï¼Œè¿™ä¸ªè¿‡ç¨‹å±äºå®¢æˆ·ç«¯æ‹‰å–ã€‚è¿™æ ·æˆ‘ä»¬å°±æ˜ç™½äº†ï¼Œåœ¨ Dubbo ä½¿ç”¨ Zookeeper ä½œä¸ºæ³¨å†Œä¸­å¿ƒæ—¶ï¼Œè·å–é…ç½®ä¿¡æ¯æ€»ä½“æ¥è¯´é‡‡ç”¨çš„éƒ½æ˜¯å®¢æˆ·ç«¯æ‹‰å–çš„æ–¹å¼ï¼Œåœ¨æ³¨å†Œç›‘å¬å™¨åçš„æƒ…å†µæ˜¯æ›´æ–°çš„æ•°æ®ä¼šè¢« Zookeeper é›†ç¾¤ä¸»åŠ¨æ¨é€è¿‡æ¥ï¼Œç„¶ååœ¨ Zookeeper ç›‘å¬çš„å›è°ƒæ–¹æ³•ä¸­ Dubbo è°ƒç”¨å†…éƒ¨æ–¹æ³•æŠŠæ•°æ®ä¼ é€’å‡ºå»ï¼Œè¿™ä¸€å®šæ„ä¹‰ä¸Šæ˜¯æ‹‰å–çš„æ–¹å¼ã€‚ è®¢é˜…æœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯æœåŠ¡æ²»ç†ä¸­å¿ƒä¼šå¤„ç†æ‰€æœ‰Serviceå±‚è®¢é˜…ï¼ŒServiceè¢«è®¾ç½®æˆç»Ÿé…ç¬¦ï¼Œå¦ä¸€ç§æ˜¯æŸä¸€ä¸ªServiceå±‚çš„è®¢é˜…ã€‚è®¢é˜…çš„æ ¸å¿ƒæ˜¯é€šè¿‡ ZookeeperClient åœ¨æŒ‡å®šçš„è·¯å¾„ä¸Šï¼ˆcategoryèŠ‚ç‚¹ï¼‰æ·»åŠ  ChildListener ç›‘å¬å™¨ï¼Œå½“è®¢é˜…çš„èŠ‚ç‚¹å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä¼šé€šè¿‡ ChildListener ç›‘å¬å™¨è§¦å‘ notify æ–¹æ³•ï¼Œè¿›è€Œè§¦å‘ NotifyListener ç›‘å¬å™¨ã€‚ æœåŠ¡æ²»ç†ä¸­å¿ƒè®¢é˜…æœåŠ¡æ²»ç†ä¸­å¿ƒè®¢é˜…æœ€ç»ˆçš„å¤„ç†è¿˜æ˜¯ä¼šèµ°æŸä¸ªServiceå±‚çš„è®¢é˜…é€»è¾‘ã€‚è¿™ä¸ªåˆ†æ”¯çš„å¤„ç†é€»è¾‘æ˜¯åœ¨æ ¹èŠ‚ç‚¹ä¸Šæ·»åŠ ä¸€ä¸ª ChildListener ç›‘å¬å™¨ï¼Œå½“ Service å±‚çš„èŠ‚ç‚¹å˜åŒ–æ—¶ï¼Œä¼šè§¦å‘è¿™ä¸ª ChildListenerã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class ZookeeperRegistry extends FailbackRegistry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; @Override protected void doSubscribe(final URL url, final NotifyListener listener) &#123; try &#123; // ----------------- è®¢é˜…æ‰€æœ‰Serviceå±‚çš„èŠ‚ç‚¹ï¼Œä¾‹å¦‚ç›‘æ§ä¸­å¿ƒçš„è®¢é˜… ---------------------/ if (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; // service å±‚æ˜¯ * // æ ¹æ®èŠ‚ç‚¹ String root = toRootPath(); // è·çš„è®¢é˜…çš„url å¯¹åº”çš„ç›‘å¬å™¨é›†åˆ ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url); // ä¸å­˜åœ¨ï¼Œè¿›è¡Œåˆ›å»º if (listeners == null) &#123; zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;()); listeners = zkListeners.get(url); &#125; ChildListener zkListener = listeners.get(listener); // ä¸å­˜åœ¨ChildListener å¯¹è±¡ï¼Œè¿›è¡Œåˆ›å»ºChildListenerå¯¹è±¡ if (zkListener == null) &#123; listeners.putIfAbsent(listener, new ChildListener() &#123; /** * èŠ‚ç‚¹å˜åŒ–å›è°ƒï¼Œæ ¹èŠ‚ç‚¹ä¸‹çš„å­èŠ‚ç‚¹æœ‰å˜åŒ–å°±å›è°ƒã€‚ * @param parentPath æ ¹èŠ‚ç‚¹ * @param currentChilds æ ¹èŠ‚ç‚¹ä¸‹çš„ service å±‚èŠ‚ç‚¹åˆ—è¡¨ */ @Override public void childChanged(String parentPath, List&lt;String&gt; currentChilds) &#123; // éå†å­èŠ‚ç‚¹åˆ—è¡¨ for (String child : currentChilds) &#123; // è§£ç  child = URL.decode(child); // å¦‚æœå­˜åœ¨å­èŠ‚ç‚¹è¿˜æœªè¢«è®¢é˜…ï¼Œåˆ™è¯´æ˜æ˜¯æ–°çš„èŠ‚ç‚¹ï¼Œåˆ™å‘èµ·è¯¥Serviceå±‚çš„è®¢é˜…ï¼Œèµ°å¦ä¸€ä¸ªåˆ†æ”¯ if (!anyServices.contains(child)) &#123; // è®°å½•è¯¥èŠ‚ç‚¹å·²ç»è®¢é˜…è¿‡ anyServices.add(child); // å¤„ç†å…·ä½“ service å±‚è®¢é˜… subscribe(url.setPath(child).addParameters(Constants.INTERFACE_KEY, child, Constants.CHECK_KEY, String.valueOf(false)), listener); &#125; &#125; &#125; &#125;); zkListener = listeners.get(listener); &#125; // åˆ›å»ºService èŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹ä¸ºæŒä¹…åŒ–èŠ‚ç‚¹ zkClient.create(root, false); // å‘Zookeeper serviceèŠ‚ç‚¹å‘èµ·è®¢é˜… List&lt;String&gt; services = zkClient.addChildListener(root, zkListener); // é¦–æ¬¡è®¢é˜…æ—¶ï¼Œè¦å¤„ç†å½“å‰å·²æœ‰çš„ Service å±‚çš„è®¢é˜…ï¼Œè°ƒç”¨subscribe(url,listener)ï¼Œå³èµ°å¦ä¸€ä¸ªåˆ†æ”¯ if (services != null &amp;&amp; !services.isEmpty()) &#123; for (String service : services) &#123; service = URL.decode(service); anyServices.add(service); subscribe(url.setPath(service).addParameters(Constants.INTERFACE_KEY, service, Constants.CHECK_KEY, String.valueOf(false)), listener); &#125; &#125; &#125; else &#123; // $&#123;æŸä¸ªService å±‚è®¢é˜…&#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; &#125; è¯¥åˆ†æ”¯æ˜¯è®¢é˜…æ ¹èŠ‚ç‚¹ä¸‹çš„æ‰€æœ‰Serviceå±‚æ•°æ®ï¼Œå½“Serviceå±‚å‘ç”Ÿå˜æ›´æ—¶ï¼Œè‹¥å˜æ›´çš„æœ‰æ–°å¢Serviceæ¥å£ï¼Œå³æ–°å¢æœåŠ¡ï¼Œåˆ™è°ƒç”¨subscribe(url,listener)æ–¹æ³•å‘èµ·è®¢é˜…ï¼Œèµ°å¤„ç†æŒ‡å®šServiceå±‚èŠ‚ç‚¹çš„é€»è¾‘ã€‚ è®¢é˜…æŒ‡å®šServiceå±‚èŠ‚ç‚¹è¯¥æ–¹æ³•ä¼šæ ¹æ®è®¢é˜… URL ä¸­çš„ category å±æ€§è·å–å…³æ³¨çš„ category èŠ‚ç‚¹é›†åˆï¼Œç„¶ååœ¨æ¯ä¸ª category èŠ‚ç‚¹ä¸Šæ·»åŠ  ChildListener ç›‘å¬å™¨ã€‚é¦–æ¬¡è®¢é˜…æˆ–ç›‘å¬çš„ category èŠ‚ç‚¹æ•°æ®å‘ç”Ÿå˜åŒ–ï¼Œä¼šæ‹‰å–è¯¥ç±»åˆ«ä¸‹çš„å­èŠ‚ç‚¹çš„æ•°æ®è¿›è¡Œé€šçŸ¥ã€‚ å¦‚æœæ˜¯providersç±»åˆ«çš„æ•°æ®ï¼Œåˆ™è®¢é˜…æ–¹ï¼ˆä¸€èˆ¬æ˜¯æ¶ˆè´¹è€…ï¼‰ä¼šæ›´æ–°æœ¬åœ°çš„æœåŠ¡ç›®å½•ã€‚ å¦‚æœæ˜¯routersç±»åˆ«çš„æ•°æ®ï¼Œåˆ™è®¢é˜…æ–¹ä¼šæ›´æ–°æœ¬åœ°è·¯ç”±è§„åˆ™åˆ—è¡¨ã€‚ å¦‚æœæ˜¯configuratorsç±»åˆ«çš„æ•°æ®ï¼Œåˆ™è®¢é˜…æ–¹ä¼šæ›´æ–°æˆ–è¦†ç›–æœ¬åœ°åŠ¨æ€å‚æ•°åˆ—è¡¨ã€‚ å¦‚æœæ˜¯consumersç±»åˆ«çš„æ•°æ®ï¼Œåˆ™æœåŠ¡æ²»ç†ä¸­å¿ƒä¼šæ›´æ–°ç¼“å­˜ä¸­çš„æ•°æ®ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class ZookeeperRegistry extends FailbackRegistry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; @Override protected void doSubscribe(final URL url, final NotifyListener listener) &#123; try &#123; //----------------- è®¢é˜…æ‰€æœ‰Serviceå±‚çš„èŠ‚ç‚¹ï¼Œä¾‹å¦‚ç›‘æ§ä¸­å¿ƒçš„è®¢é˜… ------------------------/ if (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; // service å±‚æ˜¯ * // $&#123;æ‰€æœ‰Service å±‚è®¢é˜…&#125; &#125; else &#123; /** * ConcurrentMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt; zkListeners * 1 æ ¹æ®urlè·å–ConcurrentMap&lt;NotifyListener, ChildListener&gt;ï¼Œæ²¡æœ‰å°±åˆ›å»º * 2 æ ¹æ®listenerä»ConcurrentMap&lt;NotifyListener, ChildListener&gt;è·å–ChildListenerï¼Œæ²¡æœ‰å°±åˆ›å»º * 3 åˆ›å»ºpathæŒä¹…åŒ–èŠ‚ç‚¹ * 4 åˆ›å»ºpathå­èŠ‚ç‚¹ç›‘å¬å™¨ */ // å­èŠ‚ç‚¹æ•°æ®æ•°ç»„ List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); // å¾ªç¯åˆ†ç±»æ•°ç»„ï¼Œå…¶ä¸­ï¼Œè°ƒç”¨toCategoriesPath(url)æ–¹æ³•ï¼Œè§£æè®¢é˜…urlè·å¾—åˆ†ç±»æ•°ç»„ï¼Œå³è¦è®¢é˜…çš„pathï¼Œå¦‚ï¼š/dubbo/com.alibaba.dubbo.demo.DemoService/configurators for (String path : toCategoriesPath(url)) &#123; // è·å¾—åˆ†ç±»è·¯å¾„ï¼ˆç”±è®¢é˜…çš„urlå¾—åˆ°çš„ï¼‰ å¯¹åº”çš„ç›‘å¬å™¨æ˜ å°„ ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url); // ä¸å­˜åœ¨ï¼Œè¿›è¡Œåˆ›å»º if (listeners == null) &#123; zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;()); listeners = zkListeners.get(url); &#125; /** * 1 è·å¾—listener(NotifyListener)å¯¹åº”çš„ChildListenerå¯¹è±¡ï¼Œæ²¡æœ‰å°±ä¼šåˆ›å»ºï¼Œä¸€ä¸ªNotifyListenerå…³è”ä¸€ä¸ªChildListenerã€‚ * æ³¨æ„ï¼š * ChildListenerçš„childChangedæ–¹æ³•å®é™…ä¸Šå°±æ˜¯å½“parentPath[å³toCategoriesPathæ–¹æ³•å¤„ç†åçš„path]ä¸‹çš„currentChildså‘ç”Ÿå˜åŒ–æ—¶å›è°ƒçš„æ–¹æ³•ï¼Œè¯¥æ–¹æ³•å†…éƒ¨åˆä¼šå›è°ƒNotifyListener#notifyæ–¹æ³• */ ChildListener zkListener = listeners.get(listener); if (zkListener == null) &#123; listeners.putIfAbsent(listener, new ChildListener() &#123; @Override public void childChanged(String parentPath, List&lt;String&gt; currentChilds) &#123; // å˜æ›´æ—¶ï¼Œè°ƒç”¨ notityæ–¹æ³•ï¼Œå›è°ƒ NotifyListener ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds)); &#125; &#125;); zkListener = listeners.get(listener); &#125; // åˆ›å»º Type èŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹ä¸ºæŒä¹…èŠ‚ç‚¹ï¼Œå¦‚ï¼š /dubbo/com.alibaba.dubbo.demo.DemoService/configuratorsã€‚ä¸ºäº†ç¡®ä¿è¯¥pathåœ¨Zookeeper ä¸Šå­˜åœ¨ zkClient.create(path, false); /** * å‘Zookeeper pathèŠ‚ç‚¹å‘èµ·è®¢é˜…ï¼Œå¹¶è¿”å›è¯¥èŠ‚ç‚¹ä¸‹çš„å­è·¯å¾„ */ List&lt;String&gt; children = zkClient.addChildListener(path, zkListener); // æ·»åŠ åˆ°urls ä¸­ if (children != null) &#123; urls.addAll(toUrlsWithEmpty(url, path, children)); &#125; &#125; /** * é¦–æ¬¡è®¢é˜…ä¼šä¸»åŠ¨è°ƒç”¨NofityListener#notify(url,listener,currentChilds)æ–¹æ³•ï¼Œæ‰§è¡ŒNotifyListenerçš„é€»è¾‘ */ notify(url, listener, urls); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; &#125; è®¢é˜…æ—¶æ¶‰åŠåˆ°çš„ç»‘å®šç›‘å¬å™¨ä»¥åŠ ChildListener åŒ¿åå¯¹è±¡æ–¹æ³•å›è°ƒï¼Œä¼šåœ¨ä¸‹ä¸€ç« èŠ‚ Zookeeper å®¢æˆ·ç«¯è¯¦ç»†è¯´æ˜ã€‚è®¢é˜…çš„æ ¸å¿ƒæ˜¯ä¸ºæŒ‡å®šçš„ç±»ç›®ç»‘å®šç›‘å¬å™¨ï¼Œè¯¥ç›‘å¬å™¨ç”¨äºç›‘å¬ç±»ç›®ä¸‹çš„å­èŠ‚ç‚¹å˜åŒ–ï¼Œå‘ç”Ÿå˜åŒ–åˆ™ä¼šè°ƒç”¨ ChildListener åŒ¿åå¯¹è±¡æ–¹æ³•ï¼Œä¼ é€’ç±»ç›®ä¸‹å˜æ›´åçš„å­èŠ‚ç‚¹åˆ—è¡¨ï¼Œæœ‰äº†è¿™ä¸ªæ–°çš„å­èŠ‚ç‚¹åˆ—è¡¨ï¼Œå°±å¯ä»¥æ ¹æ®éœ€è¦è¿›è¡ŒæœåŠ¡çš„é‡æ–°æš´éœ²ã€æœåŠ¡ç›®å½•é‡æ–°ç”Ÿæˆç­‰ã€‚ doUnsubscribe å–æ¶ˆè®¢é˜…1234567891011121314151617181920212223242526272829303132/** * ZookeeperRegistry */public class ZookeeperRegistry extends FailbackRegistry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * çœŸæ­£å–æ¶ˆè®¢é˜…çš„é€»è¾‘ï¼Œåˆ é™¤å¯¹åº”çš„ç›‘å¬å™¨ * * @param url * @param listener */ @Override protected void doUnsubscribe(URL url, NotifyListener listener) &#123; ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url); if (listeners != null) &#123; ChildListener zkListener = listeners.get(listener); if (zkListener != null) &#123; if (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; String root = toRootPath(); zkClient.removeChildListener(root, zkListener); &#125; else &#123; for (String path : toCategoriesPath(url)) &#123; zkClient.removeChildListener(path, zkListener); &#125; &#125; &#125; &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; è¯¥æ–¹æ³•æ˜¯å®ç°äº†å…¶çˆ¶ç±» FailbackRegistry çš„æ¨¡ç‰ˆæ–¹æ³•ï¼Œä½¿ç”¨ Zookeeper å®¢æˆ·ç«¯åˆ é™¤è®¢é˜… URL å¯¹åº”çš„ç›‘å¬å™¨ï¼Œè¾¾åˆ°ä¸å†ç›‘å¬è¯¥pathçš„ç›®çš„ã€‚ è®¢é˜…æ—¶è¾…åŠ©æ–¹æ³• è·å–Rootå±‚è·¯å¾„123456789101112131415161718192021/** * è·å¾—æ ¹ç›®å½• * root * * @return */ private String toRootDir() &#123; if (root.equals(Constants.PATH_SEPARATOR)) &#123; return root; &#125; return root + Constants.PATH_SEPARATOR; &#125; /** * Root * * @return æ ¹è·¯å¾„ */ private String toRootPath() &#123; return root; &#125; è·å–Serviceå±‚è·¯å¾„12345678910111213/** * è·å¾—æœåŠ¡è·¯å¾„ ï¼Œ Root + service * * @param url * @return */ private String toServicePath(URL url) &#123; String name = url.getServiceInterface(); if (Constants.ANY_VALUE.equals(name)) &#123; return toRootPath(); &#125; return toRootDir() + URL.encode(name); &#125; è·å¾—åˆ†ç±»è·¯å¾„123456789/** * è·å¾—åˆ†ç±»è·¯å¾„ å¦‚ï¼š åˆ° providers/consumers/routes/configurations çš„è·¯å¾„ * * @param url URL * @return åˆ†ç±»è·¯å¾„ */private String toCategoryPath(URL url) &#123; return toServicePath(url) + Constants.PATH_SEPARATOR + url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);&#125; è·å¾—URLè·¯å¾„12345678910111213/** * è·å¾—URL è·¯å¾„ï¼Œå³ è¦æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒä¸Šçš„å®Œæ•´è·¯å¾„ * &lt;p&gt; * Root + Service + Type + URL * &lt;p&gt; * è¢« &#123;@link #doRegister(URL)&#125; å’Œ &#123;@link #doUnregister(URL)&#125; è°ƒç”¨ * * @param url URL * @return è·¯å¾„ */ private String toUrlPath(URL url) &#123; return toCategoryPath(url) + Constants.PATH_SEPARATOR + URL.encode(url.toFullString()); &#125; URLåŒ¹é…1234567891011121314151617181920212223242526272829303132/** * è·å¾—providers ä¸­ï¼Œå’Œconsumer åŒ¹é…çš„URLæ•°ç»„ * * @param consumer è®¢é˜…URL å¦‚ï¼šprovider://10.1.22.101:20880/com.alibaba.dubbo.demo.DemoService?key=value&amp;... * @param providers è®¢é˜…URLæ˜ å°„çš„è·¯å¾„çš„å­è·¯å¾„é›†åˆ * @return åŒ¹é…çš„URLæ•°ç»„ */ private List&lt;URL&gt; toUrlsWithoutEmpty(URL consumer, List&lt;String&gt; providers) &#123; List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); // éå†æ‰€æœ‰çš„æœåŠ¡åˆ—è¡¨ if (providers != null &amp;&amp; !providers.isEmpty()) &#123; // éå†å­è·¯å¾„ for (String provider : providers) &#123; // è§£ç  provider = URL.decode(provider); // æ˜¯URLçš„è·¯å¾„æ‰ä¼šå¤„ç† if (provider.contains(\"://\")) &#123; // å°†å­—ç¬¦ä¸²è½¬ä¸ºURL URL url = URL.valueOf(provider); // å­è·¯å¾„URLæ˜¯å¦åŒ¹é…è®¢é˜…URLï¼Œä»¥å…³é”®å±æ€§è¿›è¡ŒåŒ¹é…ï¼Œå¦‚æœåŠ¡æ¥å£åã€ç±»ç›®ã€æœåŠ¡groupã€æœåŠ¡versionç­‰ if (UrlUtils.isMatch(consumer, url)) &#123; urls.add(url); &#125; &#125; &#125; &#125; return urls; &#125; Dubbo å®¢æˆ·ç«¯æ ¹æ®æœ¬åœ° URL é…ç½®ï¼ˆå¼•ç”¨é…ç½®ä¿¡æ¯ï¼‰çš„æ¥å£ã€åˆ†ç±»ã€åˆ†ç»„å’Œç‰ˆæœ¬åšè¿‡æ»¤ï¼Œé€šè¿‡ä¸Šè¿°æ–¹æ³•å¯¹æœåŠ¡åˆ—è¡¨è¿›è¡Œè¿‡æ»¤ï¼Œå¾—åˆ°ç¬¦åˆæ¡ä»¶çš„æœåŠ¡ã€‚ ç­›é€‰URL12345678910111213141516171819202122232425/** * 1 ä»providersä¸­ç­›é€‰å’ŒconsumeråŒ¹é…çš„URLé›†åˆ * 2 å¦‚æœURLé›†åˆä¸ä¸ºç©ºï¼Œç›´æ¥è¿”å›è¿™ä¸ªé›†åˆ * 3 å¦‚æœURLé›†åˆä¸ºç©ºï¼Œé¦–å…ˆä»pathä¸­è·å–categoryçš„å€¼ï¼Œç„¶åå°†consumerçš„åè®®æ¢æˆemptyå¹¶æ·»åŠ å‚æ•°category=pathä¸­çš„categoryçš„å€¼ã€‚ * å½¢å¼ï¼š'empty://' çš„URLè¿”å›ï¼Œé€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œå¯ä»¥å¤„ç†ç±»ä¼¼æœåŠ¡æä¾›è€…ä¸ºç©ºçš„æƒ…å†µ * * @param consumer è®¢é˜…URL å¦‚ï¼šprovider://10.1.22.101:20880/com.alibaba.dubbo.demo.DemoService?key=value&amp;... * @param path è®¢é˜…URLæ˜ å°„çš„è·¯å¾„ å¦‚ï¼š/dubbo/com.alibaba.dubbo.demo.DemoService/configurators * @param providers è®¢é˜…URLæ˜ å°„çš„è·¯å¾„çš„å­è·¯å¾„é›†åˆ * @return */ private List&lt;URL&gt; toUrlsWithEmpty(URL consumer, String path, List&lt;String&gt; providers) &#123; // ä»providersä¸­ç­›é€‰å’Œconsumer åŒ¹é…çš„URLæ•°ç»„ List&lt;URL&gt; urls = toUrlsWithoutEmpty(consumer, providers); // å¦‚æœä¸å­˜åœ¨åŒ¹é…çš„ï¼Œåˆ™åˆ›å»º 'empty://' çš„URLè¿”å› if (urls == null || urls.isEmpty()) &#123; int i = path.lastIndexOf('/'); String category = i &lt; 0 ? path : path.substring(i + 1); URL empty = consumer.setProtocol(Constants.EMPTY_PROTOCOL).addParameter(Constants.CATEGORY_KEY, category); urls.add(empty); &#125; return urls; &#125; è·å¾—Typeå±‚è·¯å¾„1234567891011121314151617181920212223242526272829303132333435/** * è·å¾—åˆ†ç±»è·¯å¾„æ•°ç»„ * Root + Service + Type * * @param url è®¢é˜…URL * @return åˆ†ç±»è·¯å¾„æ•°ç»„ */ private String[] toCategoriesPath(URL url) &#123; String[] categories; // å¦‚æœcategoryçš„å€¼ä¸º * ï¼Œè¡¨ç¤ºåˆ†åˆ«è®¢é˜…ï¼šproviders,consumers,routers,configurators if (Constants.ANY_VALUE.equals(url.getParameter(Constants.CATEGORY_KEY))) &#123; categories = new String[]&#123; Constants.PROVIDERS_CATEGORY, Constants.CONSUMERS_CATEGORY, Constants.ROUTERS_CATEGORY, Constants.CONFIGURATORS_CATEGORY &#125;; &#125; else &#123; // å¦‚æœcategoryçš„å€¼ä¸ä¸º * ï¼Œå°±å–å‡º categoryçš„å€¼ï¼Œå¦‚æœæ²¡æœ‰å€¼ï¼Œå°±æŠŠprovidersä½œä¸ºé»˜è®¤å€¼ã€‚æ³¨æ„ï¼Œå½“categoryçš„å€¼ä¸ä¸ºç©ºæ—¶ä¼šä½¿ç”¨ ',' åˆ†å‰²categoryçš„å€¼ï¼Œä¸ºæ•°ç»„ categories = url.getParameter(Constants.CATEGORY_KEY, new String[]&#123;Constants.DEFAULT_CATEGORY&#125;); &#125; // è·å¾—åˆ†ç±»è·¯å¾„æ•°ç»„ String[] paths = new String[categories.length]; for (int i = 0; i &lt; categories.length; i++) &#123; // æ„å»ºåˆ†ç±»è·¯å¾„ paths[i] = toServicePath(url) + Constants.PATH_SEPARATOR + categories[i]; &#125; return paths; &#125; é”€æ¯æ–¹æ³•12345678910111213141516171819/** * ZookeeperRegistry */public class ZookeeperRegistry extends FailbackRegistry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; @Override public void destroy() &#123; super.destroy(); try &#123; // å…³é—­ Zookeeper å®¢æˆ·ç«¯è¿æ¥ zkClient.close(); &#125; catch (Exception e) &#123; logger.warn(\"Failed to close zookeeper client \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; é‡å†™äº†çˆ¶ç±» FailbackRegistry çš„é”€æ¯æ–¹æ³•ï¼Œä½¿ç”¨ Zookeeper å®¢æˆ·ç«¯å…³é—­ä¼šè¯ï¼Œè¯¥æ–¹æ³•ä¼šå…ˆè°ƒç”¨çˆ¶ç±»çš„é”€æ¯æ–¹æ³•ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« ä¸»è¦ä»‹ç»äº† Dubbo å°è£…çš„ ZookeeperRegistryï¼Œè¯¥æ³¨å†Œä¸­å¿ƒç±»å°†å…·ä½“æ“ä½œä»»åŠ¡äº¤ç»™å†…éƒ¨å°è£…çš„ Zookeeper å®¢æˆ·ç«¯å»å®Œæˆï¼Œè‡ªå·±æœ¬èº«åªæ˜¯å¤„ç† Zookeeper å®¢æˆ·ç«¯æ“ä½œå‰çš„é€»è¾‘ï¼Œå¦‚è°ƒç”¨çˆ¶ç±»æ–¹æ³•ã€è§£æURLçš„æ‰€å±ç±»ç›®ç­‰ï¼Œå…¶ä¸­åˆ›å»º Zookeeper å®¢æˆ·ç«¯çš„ç›´æ¥å…¥å£å°±åœ¨è¯¥ç±»çš„æ„é€ æ–¹æ³•ä¸­ã€‚æ­¤å¤–ï¼Œè¯¥ç±»ä¸­çš„ä¸€äº›æ–¹æ³•æ²¡æœ‰åˆ†æåˆ°ï¼Œå®ƒä»¬å’Œè®¢é˜…ä¸é€šçŸ¥ç›¸å…³ï¼Œä¼šå’Œè®¢é˜…é€šçŸ¥ä¸€èµ·åˆ†æã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://gentryhuang.com/tags/Zookeeper/"}]},{"title":"Dubboæºç åˆ†æ - æ³¨å†Œä¸­å¿ƒæ€»è§ˆ","slug":"rpc/æ³¨å†Œä¸­å¿ƒæ€»è§ˆ","date":"2020-04-12T16:00:00.000Z","updated":"2020-10-25T02:22:09.273Z","comments":false,"path":"posts/dafcd048/","link":"","permalink":"https://gentryhuang.com/posts/dafcd048/","excerpt":"","text":"å‰è¨€åœ¨ Dubbo ä½“ç³»ä¸­ï¼Œæ³¨å†Œä¸­å¿ƒæ˜¯æ ¸å¿ƒç»„ä»¶ä¹‹ä¸€ã€‚Dubbo æœ¬èº«æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼çš„ RPC æ¡†æ¶ï¼Œä¾èµ–äº Dubbo çš„åº”ç”¨éƒ½æ˜¯å•ç‹¬éƒ¨ç½²çš„ï¼Œä¸ºäº†è®©å„ä¸ªåº”ç”¨èƒ½å¤Ÿå®æ—¶è·å–å½¼æ­¤çš„ä¿¡æ¯ï¼Œå°±éœ€è¦ä¾èµ–ä¸€ä¸ªä¸€è‡´æ€§çš„æœåŠ¡æ³¨å†Œå’Œå‘ç°ç»„ä»¶ã€‚Dubbo é€šè¿‡æ³¨å†Œä¸­å¿ƒå®ç°äº†åˆ†å¸ƒå¼ç¯å¢ƒä¸­å„æœåŠ¡ä¹‹é—´çš„æ³¨å†Œä¸å‘ç°ï¼Œæ˜¯å„ä¸ªåˆ†å¸ƒå¼èŠ‚ç‚¹ä¹‹é—´çš„çº½å¸¦ã€‚ä¸»è¦ä½œç”¨å¦‚ä¸‹ï¼š åŠ¨æ€åŠ å…¥ã€‚æœåŠ¡æä¾›æ–¹é€šè¿‡æ³¨å†Œä¸­å¿ƒè®°å½•è‡ªå·±çš„ä¿¡æ¯å¹¶åŠ¨æ€åœ°æŠŠè‡ªå·±æš´éœ²ç»™å…¶ä»–æ¶ˆè´¹è€…ã€‚ åŠ¨æ€å‘ç°ã€‚ä¸€ä¸ªæ¶ˆè´¹è€…å¯ä»¥åŠ¨æ€åœ°æ„ŸçŸ¥æ–°çš„é…ç½®ã€è·¯ç”±è§„åˆ™ã€æ–°çš„æœåŠ¡ï¼Œæ— éœ€é‡æ–°å¯åŠ¨æœåŠ¡ã€‚ä¸€ä¸ªæœåŠ¡æä¾›è€…å¯ä»¥åŠ¨æ€åœ°æ„ŸçŸ¥é…ç½®çš„å˜åŒ–æ— éœ€å¯åŠ¨æœåŠ¡ã€‚ åŠ¨æ€è°ƒæ•´ã€‚æ³¨å†Œä¸­å¿ƒæ”¯æŒå‚æ•°çš„åŠ¨æ€è°ƒæ•´ï¼Œæ–°å‚æ•°è‡ªåŠ¨æ›´æ–°åˆ°ç›¸å…³æœåŠ¡èŠ‚ç‚¹ã€‚ Registry åªæ˜¯ Consumer å’Œ Provider æ„ŸçŸ¥å½¼æ­¤çŠ¶æ€å˜åŒ–å’Œé…ç½®æ”¹å˜ï¼ˆå¼ºè°ƒæœåŠ¡æ²»ç†ï¼‰çš„ä¸€ç§é€”å¾„ï¼Œå®é™…é€šè®¯äº¤äº’è¿‡ç¨‹æ˜¯ç›´æ¥è¿›è¡Œçš„ï¼Œå¯¹äº Registry æ¥è¯´æ˜¯é€æ˜æ— æ„ŸçŸ¥çš„ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œæˆ‘ä»¬æ‰€è¯´çš„æ³¨å†Œä¸­å¿ƒå…¶å®æ˜¯æŒ‡åº”ç”¨ä¸­çš„æ³¨å†Œä¸­å¿ƒå®¢æˆ·ç«¯ï¼ŒçœŸæ­£çš„æ³¨å†Œä¸­å¿ƒæœåŠ¡æ˜¯ç‹¬ç«‹éƒ¨ç½²çš„è¿›ç¨‹æˆ–è¿›ç¨‹ç»„æˆçš„é›†ç¾¤ï¼Œå¦‚ Zookeeper é›†ç¾¤ã€Redis é›†ç¾¤ã€‚å¯¹äºæ³¨å†Œä¸­å¿ƒè€Œè¨€ï¼ŒProvider å’Œ Consumer ä»…æ˜¯ä¸€ä¸ª URLã€‚ å·¥ä½œæµç¨‹ æœåŠ¡æä¾›è€…å¯åŠ¨æ—¶ï¼Œä¼šå‘æ³¨å†Œä¸­å¿ƒå†™å…¥è‡ªå·±çš„å…ƒæ•°æ®ä¿¡æ¯ï¼Œå¹¶è®¢é˜…é…ç½®å…ƒæ•°æ®ä¿¡æ¯ã€‚ æ¶ˆè´¹è€…å¯åŠ¨æ—¶ï¼Œä¹Ÿä¼šå‘æ³¨å†Œä¸­å¿ƒå†™å…¥è‡ªå·±çš„å…ƒæ•°æ®ä¿¡æ¯ï¼Œå¹¶è®¢é˜…æœåŠ¡æä¾›è€…ã€è·¯ç”±ä¼šé…ç½®å…ƒæ•°æ®ä¿¡æ¯ã€‚ æœåŠ¡æ²»ç†ä¸­å¿ƒ(dubbo-admin)å¯åŠ¨æ—¶ï¼Œä¼šåŒæ—¶è®¢é˜…æ‰€æœ‰æœåŠ¡æä¾›è€…ã€æœåŠ¡æ¶ˆè´¹è€…ã€è·¯ç”±å’Œé…ç½®å…ƒæ•°æ®ä¿¡æ¯ã€‚ æœåŠ¡æä¾›è€…ä¸‹çº¿æˆ–æ–°çš„æœåŠ¡æä¾›è€…åŠ å…¥æ—¶ï¼Œæ³¨å†Œä¸­å¿ƒæœåŠ¡æä¾›è€…ç›®å½•ä¼šå‘ç”Ÿå˜åŒ–ï¼Œå˜åŒ–ä¿¡æ¯ä¼šåŠ¨æ€é€šçŸ¥ç»™æ¶ˆè´¹è€…ã€æœåŠ¡æ²»ç†ä¸­å¿ƒã€‚ æ¶ˆè´¹æ–¹å‘èµ·æœåŠ¡è°ƒç”¨æ—¶ï¼Œä¼šå¼‚æ­¥å°†è°ƒç”¨ã€ç»Ÿè®¡ä¿¡æ¯ç­‰ä¸ŠæŠ¥ç»™ç›‘æ§ä¸­å¿ƒã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒDubbo ä¸­çš„æ³¨å†Œä¸­å¿ƒæ€»ä½“æµç¨‹ç›¸åŒï¼Œæ¡†æ¶å¯¹æµç¨‹è¿›è¡Œäº†æŠ½è±¡ï¼Œé‡‡ç”¨æŠ½è±¡å·¥å‚å’Œæ¨¡ç‰ˆæ–¹æ³•æ¨¡å¼ï¼Œä¸»è¦åŒºåˆ«æ˜¯ä¸åŒçš„æ³¨å†Œä¸­å¿ƒæœ‰ä¸åŒçš„å…·ä½“å®ç°ï¼Œå…¶æ•°æ®ç»“æ„ä¹Ÿä¸ç›¸åŒã€‚ æ³¨å†Œä¸­å¿ƒåœ¨ Dubbo æ¶æ„ä¸­çš„ä½ç½®ä¸ºä¸‹å›¾çš„ Registryï¼Œå…¶ä¸­çº¢æ¡†ä¸­çš„æ˜¯æˆ‘ä»¬æ¥ä¸‹æ¥å‡ ç¯‡æ–‡ç« ç€é‡åˆ†æçš„å†…å®¹ã€‚ æ³¨å†Œä¸­å¿ƒæŠ½è±¡APIDubboæœåŠ¡æš´éœ²ã€æœåŠ¡å¼•ç”¨ä»¥åŠæœåŠ¡è°ƒç”¨ç­‰å‡ ä¹éƒ½ä¼šä½¿ç”¨åˆ°æ³¨å†Œä¸­å¿ƒï¼Œè¿™ç¯‡æ–‡ç« å¯¹Dubbo çš„æ³¨å†Œä¸­å¿ƒæŠ½è±¡APIè¿›è¡Œè¯´æ˜ã€‚ ä¸Šå›¾æ˜¯Dubboçš„æ³¨å†Œä¸­å¿ƒæŠ½è±¡APIä»£ç ç»“æ„å›¾ï¼Œçº¢æ¡†ä¸­çš„ä»£ç éƒ½æ˜¯æŠ½è±¡APIçš„åŸºç¡€ä»£ç ï¼Œé»„æ¡†æ˜¯å…·ä½“çš„æ³¨å†Œä¸­å¿ƒæŠ½è±¡APIã€‚ æ³¨å†Œä¸­å¿ƒæ ¸å¿ƒæŠ½è±¡APIçš„UML UMLå›¾éå¸¸æ¸…æ¥šï¼Œæ³¨å†Œä¸­å¿ƒæ ¸å¿ƒæŠ½è±¡APIä¸­ä¸»è¦æœ‰ä¸‰ä¸ªè§’è‰²ï¼Œæ³¨å†Œä¸­å¿ƒã€æ³¨å†Œä¸­å¿ƒå·¥å‚ã€æ³¨å†Œä¸­å¿ƒçš„ç›‘å¬å™¨ã€‚å®ƒä»¬ä¹‹é—´é‡‡ç”¨ç»§æ‰¿ã€ç»„åˆã€ä»¥åŠå·¥å‚çš„æ–¹å¼è”ç³»åœ¨ä¸€èµ·ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯è¯¥å›¾ä¸­çš„ ZookeeperRegistry æ³¨å†Œä¸­å¿ƒå®ç°æ²¡æœ‰æ¶‰åŠåˆ°å…·ä½“çš„å®¢æˆ·ç«¯ï¼Œå…³äº Dubbo çš„ Zookeeper å®¢æˆ·ç«¯ä¼šå•ç‹¬å†™ä¸€ç¯‡æ–‡ç« è¿›è¡Œè¯¦ç»†è¯´æ˜ã€‚ä»UMLå›¾å¯ä»¥çœ‹å‡ºå½“å‰ Dubbo ç‰ˆæœ¬æ”¯æŒå››ç§æ³¨å†Œä¸­å¿ƒçš„å®ç°ã€‚Zookeeper æ˜¯å®˜æ–¹æ¨èçš„æ³¨å†Œä¸­å¿ƒï¼Œåœ¨ç”Ÿäº§ç¯å¢ƒä¸­æœ‰è¿‡å®é™…ä½¿ç”¨ã€‚Redis æ³¨å†Œä¸­å¿ƒå¹¶æ²¡æœ‰ç»è¿‡é•¿æ—¶é—´è¿è¡Œçš„å¯é æ€§éªŒè¯ï¼Œå…¶ç¨³å®šæ€§ä¾èµ– Redis æœ¬èº«ã€‚Simple æ³¨å†Œä¸­å¿ƒæ˜¯ä¸€ä¸ªç®€å•çš„åŸºäºå†…å­˜çš„æ³¨å†Œä¸­å¿ƒå®ç°ï¼Œå®ƒæœ¬èº«å°±æ˜¯ä¸€ä¸ªæ ‡å‡†çš„PRCæœåŠ¡ï¼Œä¸æ”¯æŒé›†ç¾¤ã€‚Multicast æ¨¡å—åˆ™ä¸éœ€è¦å¯åŠ¨ä»»ä½•æ³¨å†Œä¸­å¿ƒï¼Œåªè¦é€šè¿‡å¹¿æ’­åœ°å€ï¼Œå°±å¯ä»¥äº’ç›¸å‘ç°ï¼Œä¸æ¨èç”Ÿäº§ç¯å¢ƒä½¿ç”¨ã€‚ä¸‹é¢åˆ†åˆ«ä»‹ç»è¯¥UMLå›¾ä¸­æ¶‰åŠåˆ°çš„ç»„ä»¶ã€‚ Node12345678910111213141516171819202122public interface Node &#123; /** * è·å–å½“å‰èŠ‚ç‚¹çš„ URL * * @return url. */ URL getUrl(); /** * æ£€æµ‹å½“å‰èŠ‚ç‚¹æ˜¯å¦å¯ç”¨ * * @return available. */ boolean isAvailable(); /** * é”€æ¯å½“å‰èŠ‚ç‚¹ï¼Œé‡Šæ”¾èµ„æº */ void destroy();&#125; éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œåœ¨ Dubbo ä¸­ï¼Œä¸€èˆ¬ä½¿ç”¨ Node è¿™ä¸ªæ¥å£æ¥æŠ½è±¡èŠ‚ç‚¹çš„æ¦‚å¿µã€‚Node ä¸ä»…å¯ä»¥è¡¨ç¤º Provider å’Œ ConsumerèŠ‚ç‚¹ï¼Œè¿˜å¯ä»¥è¡¨ç¤ºæ³¨å†Œä¸­å¿ƒèŠ‚ç‚¹ã€‚Node æ¥å£æ˜¯ä¸€ä¸ªé¡¶çº§æ¥å£ï¼ŒDubbo ä¸­çš„æ ¸å¿ƒç»„ä»¶å‡ ä¹éƒ½ç»§æ‰¿è¯¥æ¥å£ï¼Œåªå°è£…äº†ä¸‰ä¸ªå’ŒèŠ‚ç‚¹ç›¸å…³çš„æ–¹æ³•ã€‚ RegistryService12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public interface RegistryService &#123; /** * æ³¨å†Œæ•°æ®ï¼Œå¦‚ï¼šæä¾›è€…åœ°å€ï¼Œæ¶ˆè´¹è€…åœ°å€ï¼Œè·¯ç”±è§„åˆ™ï¼Œè¦†ç›–è§„åˆ™ç­‰æ•°æ® * * @param url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin */ void register(URL url); /** * å–æ¶ˆæ³¨å†Œæ•°æ® * * @param url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin */ void unregister(URL url); /** * - è®¢é˜…ç¬¦åˆæ¡ä»¶çš„å·²æ³¨å†Œæ•°æ®ï¼Œå½“è®¢é˜…çš„æ•°æ®å‘ç”Ÿæ”¹å˜æ—¶ï¼Œæ³¨å†Œä¸­å¿ƒä¼šä¸»åŠ¨é€šçŸ¥ listener å¯¹è±¡ï¼ŒNotifyListener æ¥å£ä¸­å®šä¹‰çš„ notify æ–¹æ³•å°±æ˜¯ç”¨æ¥æ¥æ”¶é€šçŸ¥çš„ã€‚ * - åœ¨ URLçš„category å±æ€§ä¸Šï¼Œè¡¨ç¤ºè®¢é˜…çš„æ•°æ®åˆ†ç±»ã€‚ç›®å‰æœ‰å››ç§ç±»å‹ï¼š * 1 consumers æœåŠ¡æ¶ˆè´¹è€…åˆ—è¡¨ * 2 providers æœåŠ¡æä¾›è€…åˆ—è¡¨ * 3 routers è·¯ç”±è§„åˆ™åˆ—è¡¨ * 4 configurations é…ç½®è§„åˆ™åˆ—è¡¨ * * @param url Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @param listener A listener of the change event, not allowed to be empty * */ void subscribe(URL url, NotifyListener listener); /** * å–æ¶ˆè®¢é˜… * * @param url Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @param listener A listener of the change event, not allowed to be empty * */ void unsubscribe(URL url, NotifyListener listener); /** * æŸ¥è¯¢ç¬¦åˆæ¡ä»¶çš„å·²æ³¨å†Œæ•°æ®ï¼Œå®ƒä¸ subscribe() æ–¹æ³•æ˜¯æœ‰åŒºåˆ«çš„ï¼Œsubscribe() æ–¹æ³•é‡‡ç”¨çš„æ˜¯ push æ¨¡å¼ï¼Œlookup() æ–¹æ³•é‡‡ç”¨çš„æ˜¯ pull æ¨¡å¼ã€‚ * * @param url Query condition, is not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @return The registered information list, which may be empty, the meaning is the same as the parameters of &#123;@link com.alibaba.dubbo.registry.NotifyListener#notify(List&lt;URL&gt;)&#125;. * @see com.alibaba.dubbo.registry.NotifyListener#notify(List) */ List&lt;URL&gt; lookup(URL url);&#125; RegistryService æ¥å£ä¹Ÿæ˜¯ä¸€ä¸ªé¡¶çº§æ¥å£ï¼Œæ˜¯æ³¨å†Œä¸­å¿ƒæœåŠ¡æ¥å£ï¼ŒæŠ½è±¡äº†æ³¨å†ŒæœåŠ¡çš„åŸºæœ¬è¡Œä¸ºã€‚å®šä¹‰äº†èŠ‚ç‚¹çš„æ³¨å†Œ/åæ³¨å†Œã€è®¢é˜…/åè®¢é˜…ä»¥åŠæŸ¥è¯¢ä¸‰ç§æ“ä½œæ–¹æ³•ã€‚Dubbo åœ¨ä¸Šå±‚è¿›è¡Œäº†æŠ½è±¡ï¼Œå…·ä½“çš„å®ç°ç»†èŠ‚äº¤ç»™ä¸åŒçš„æ³¨å†Œä¸­å¿ƒã€‚ Registry12345678/** * Registry. (SPI, Prototype, ThreadSafe) * * @see com.alibaba.dubbo.registry.RegistryFactory#getRegistry(com.alibaba.dubbo.common.URL) * @see com.alibaba.dubbo.registry.support.AbstractRegistry */public interface Registry extends Node, RegistryService &#123;&#125; æ³¨å†Œä¸­å¿ƒæ¥å£ï¼Œè¯¥æ¥å£ä¸­æ²¡æœ‰å®šä¹‰æ–¹æ³•åªæ˜¯ç»§æ‰¿äº† Node å’Œ RegistryService æ¥å£ï¼Œå› æ­¤å…·å¤‡äº†æ³¨å†Œã€è®¢é˜…ã€æŸ¥è¯¢ç­‰æ“ä½œï¼Œæ³¨å†Œä¸­å¿ƒå…·ä½“å®ç°éƒ½è¦ç»§æ‰¿è¯¥æ¥å£ã€‚ AbstractRegistryRegistry çš„æŠ½è±¡ç±»ï¼Œå®ç°äº†é€šç”¨çš„æ³¨å†Œã€è®¢é˜…ã€æŸ¥è¯¢ä»¥åŠé€šçŸ¥ç­‰æ–¹æ³•ã€‚å…¶ä¸­ï¼Œå®ç°äº†å½“å‰èŠ‚ç‚¹è®¢é˜…çš„æ•°æ®ï¼ˆURLï¼‰ç¼“å­˜åˆ°æœ¬åœ°åŠæŒä¹…åŒ–åˆ°æ–‡ä»¶ï¼Œä¸€æ–¹é¢ä¸ºäº†å‡è½»æ³¨å†Œä¸­å¿ƒç»„ä»¶çš„å‹åŠ›ï¼Œå¦ä¸€æ–¹é¢è¯¥æ–‡ä»¶å¯ç”¨äºå½“æ¶ˆè´¹è€…æ— æ³•ä»æ³¨å†Œä¸­å¿ƒæ‹‰å–æœåŠ¡æä¾›è€…åˆ—è¡¨ä¿¡æ¯æ—¶å°±ä»è¯¥æ–‡ä»¶ä¸­è·å–ï¼Œæ”¯æŒäº†å³ä½¿æ³¨å†Œä¸­å¿ƒå®•æœºæ¶ˆè´¹è€…ä»ç„¶å¯ä»¥å’Œæä¾›è€…é€šä¿¡ã€‚ å±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public abstract class AbstractRegistry implements Registry &#123; // Log output protected final Logger logger = LoggerFactory.getLogger(getClass()); // URLåœ°å€åˆ†å‰²ç¬¦ï¼Œç”¨äºæ–‡ä»¶ç¼“å­˜ä¸­ï¼Œåˆ†å‰²URL private static final char URL_SEPARATOR = ' '; // URLåœ°å€åˆ†éš”æ­£åˆ™è¡¨è¾¾å¼ï¼Œç”¨äºè§£ææ–‡ä»¶ç¼“å­˜ä¸­URLåˆ—è¡¨ private static final String URL_SPLIT = \"\\\\s+\"; /** * æœ¬åœ°ç£ç›˜ç¼“å­˜ * 1 å…¶ä¸­ç‰¹æ®Šçš„ keyå€¼ä¸º registriesï¼Œ å¯¹åº”çš„å€¼è®°å½•æ³¨å†Œä¸­å¿ƒåˆ—è¡¨ï¼Œ å…¶ä»–çš„å‡ä¸º&#123;@link #notified&#125; æœåŠ¡æä¾›è€…åˆ—è¡¨ * 2 æ•°æ®æµå‘ï¼š åˆ›å»ºæ³¨å†Œä¸­å¿ƒå®ä¾‹æ—¶ä»fileè¯»å–æ•°æ®åˆ° propertiesä¸­ï¼›ç›‘å¬åˆ°æ³¨å†Œä¸­å¿ƒæ•°æ®å‘ç”Ÿå˜æ›´æ—¶ï¼Œä¿®æ”¹propertieså¯¹åº”çš„å€¼ï¼Œå¹¶å†™å…¥file * 3 æ•°æ®çš„é”®-å€¼å¯¹ * ï¼ˆ1ï¼‰å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œé”®ä¸ºè®¢é˜…è€…çš„æœåŠ¡é”® &#123;@link URL#getServiceKey()&#125;,å€¼ä¸º æœåŠ¡æä¾›è€…åˆ—è¡¨/è·¯ç”±è§„åˆ™åˆ—è¡¨/é…ç½®è§„åˆ™åˆ—è¡¨ * ï¼ˆ2ï¼‰ç‰¹æ®Šæƒ…å†µä¸‹æ˜¯ é”®ä¸º registriesï¼Œå€¼ä¸ºæ³¨å†Œä¸­å¿ƒåˆ—è¡¨ */ // Local disk cache, where the special key value.registies records the list of registry centers, and the others are the list of notified service providers private final Properties properties = new Properties(); /** * æ³¨å†Œä¸­å¿ƒæ•°æ®ç¼“å­˜çº¿ç¨‹æ±  */ private final ExecutorService registryCacheExecutor = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"DubboSaveRegistryCache\", true)); /** * propertieså‘ç”Ÿå˜æ›´æ—¶ï¼Œæ˜¯å¦åŒæ­¥å†™å…¥æ–‡ä»¶ */ private final boolean syncSaveFile; /** * æ•°æ®ç‰ˆæœ¬å· &#123;@link #properties&#125;ï¼Œæ¯æ¬¡å†™å…¥ file æ–‡ä»¶æ—¶éƒ½æ˜¯å…¨è¦†ç›–å†™å…¥ï¼Œè€Œä¸æ˜¯ä¿®æ”¹æ–‡ä»¶ï¼Œå› æ­¤éœ€è¦å¹¶å‘å¤„ç†ï¼Œé˜²æ­¢æ—§æ•°æ®è¦†ç›–æ–°æ•°æ® */ private final AtomicLong lastCacheChanged = new AtomicLong(); /** * å·²æ³¨å†Œ URL é›†åˆ */ private final Set&lt;URL&gt; registered = new ConcurrentHashSet&lt;URL&gt;(); /** * è®¢é˜… URL çš„ç›‘å¬å™¨é›†åˆ * keyï¼š è®¢é˜…URLï¼Œä¹Ÿå³è¢«ç›‘å¬çš„URL * value: è®¢é˜…URLç›¸åº”çš„ç›‘å¬å™¨é›†åˆ */ private final ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; subscribed = new ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(); /** * é€šçŸ¥çš„URLåˆ°ç›‘å¬å™¨ç›‘å¬åˆ°æ•°æ®å˜åŒ–åçš„ ç»“æœURLé›†åˆ * key1: è®¢é˜…URLï¼Œå½“å‰èŠ‚ç‚¹ä½œä¸ºæ¶ˆè´¹è€…æˆ–æä¾›è€…çš„ä¸€ä¸ªè®¢é˜…URLï¼Œå¦‚æœåŠ¡å¼•ç”¨æ—¶è¿›è¡Œè®¢é˜…çš„ consumeråè®®çš„çš„URLï¼ŒæœåŠ¡æš´æš´éœ²æ—¶è®¢é˜…çš„ provideråè®®çš„URLï¼Œå’Œ &#123;@link #subscribed&#125; çš„é”®ä¸€è‡´ * key2: åˆ†ç±»ï¼Œå¦‚ï¼š providers,consumers,routes,configuratorsã€‚ã€å¯¹äºæ¶ˆè´¹ç€æ¥è¯´ä¸€èˆ¬æ˜¯æ— consumers,å› ä¸ºæ¶ˆè´¹è€…ä¸ä¼šå»è®¢é˜…å¦å¤–çš„æ¶ˆè´¹è€…çš„åˆ—è¡¨ã€‘ * value: æ–°çš„URLé›†åˆ */ private final ConcurrentMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt; notified = new ConcurrentHashMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt;(); /** * æ³¨å†Œä¸­å¿ƒ URLï¼ŒåŒ…å«äº†åˆ›å»ºå½“å‰Registryå¯¹è±¡çš„å…¨éƒ¨é…ç½®ä¿¡æ¯ï¼Œæ³¨æ„ï¼ŒAbstractRegistryFactory å¯¹å…¶è¿›è¡Œäº†è§„èŒƒåŒ–å¤„ç† */ private URL registryUrl; /** * ç¼“å­˜æ•°æ®çš„ç£ç›˜æ–‡ä»¶ */ private File file; /** * æ„é€ æ–¹æ³•ï¼Œæ¯æ¬¡åˆ›å»ºæ³¨å†Œä¸­å¿ƒéƒ½ä¼šåŒæ­¥ç£ç›˜æ–‡ä»¶æ•°æ®åˆ°ç¼“å­˜ä¸­ * @param url */ public AbstractRegistry(URL url) &#123; setUrl(url); /** * å¯ä»¥æŒ‡å®šæ³¨å†Œä¸­å¿ƒç£ç›˜ç¼“å­˜æ–‡ä»¶ï¼Œé…ç½®æ–¹å¼ï¼š * 1 ä½¿ç”¨fileå±æ€§æŒ‡å®š &lt;dubbo:registry address=\"xxx\" file=\"/opt/xxx\"/&gt; * 2 ä½¿ç”¨save.fileå±æ€§æŒ‡å®š &lt;dubbo:registry address=\"xxx\" save.file=\"/opt/xxx\"/&gt; * 3 ä¸æ˜¾ç¤ºæŒ‡å®šçš„è¯ï¼Œä½¿ç”¨é»˜è®¤å€¼ï¼šSystem.getProperty(\"user.home\") + \"/.dubbo/dubbo-registry-\" + åº”ç”¨å + \"-\" + url.getAddress() + \".cache\" */ // Start file save timer syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, false); // è·å¾— file String filename = url.getParameter(Constants.FILE_KEY, System.getProperty(\"user.home\") + \"/.dubbo/dubbo-registry-\" + url.getParameter(Constants.APPLICATION_KEY) + \"-\" + url.getAddress() + \".cache\"); File file = null; if (ConfigUtils.isNotEmpty(filename)) &#123; file = new File(filename); if (!file.exists() &amp;&amp; file.getParentFile() != null &amp;&amp; !file.getParentFile().exists()) &#123; if (!file.getParentFile().mkdirs()) &#123; throw new IllegalArgumentException(\"Invalid registry store file \" + file + \", cause: Failed to create directory \" + file.getParentFile() + \"!\"); &#125; &#125; &#125; this.file = file; // åŠ è½½æœ¬åœ°ç£ç›˜ç¼“å­˜æ–‡ä»¶åˆ°å†…å­˜ç¼“å­˜ï¼Œå³ properties.load(in)ï¼Œåˆ°propertieså±æ€§ä¸­ loadProperties(); // é€šçŸ¥ç›‘å¬å™¨ï¼ŒURL å˜åŒ–ç»“æœ ã€‚ ä¸ºä»€ä¹ˆæ„é€ æ–¹æ³•è¦é€šçŸ¥ï¼Œzkè¿æ¥éƒ½æ²¡æœ‰å»ºç«‹ï¼Œç›‘å¬å™¨æ›´æ²¡æœ‰æ³¨å†Œï¼Œå³ subscribed é‡Œé¢è¿˜æ²¡æœ‰å€¼ notify(url.getBackupUrls()); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; AbstractRegistry æŠ½è±¡ç±»ä¸­çš„å±æ€§å¤§è‡´æœ‰å››ç±»ï¼Œæ³¨å†Œçš„URLã€ç¼“å­˜æ•°æ®ç›¸å…³çš„ã€è®¢é˜…URLçš„ç›‘å¬å™¨ã€é€šçŸ¥URLå¯¹åº”çš„å˜æ›´URLã€‚åœ¨ AbstractRegistry åˆå§‹åŒ–æ—¶ï¼Œä¼šå°†å¯¹åº”çš„ file æ–‡ä»¶ä¸­çš„è®¢é˜…æ•°æ®åŠ è½½åˆ° properties å­—æ®µä¸­ã€‚å½“ properties ä¸­çš„æ³¨å†Œæ•°æ®å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä¼šå†™å…¥æœ¬åœ°çš„ file æ–‡ä»¶è¿›è¡ŒåŒæ­¥ã€‚æœ¬åœ°ç¼“å­˜æ–‡ä»¶çš„è·¯å¾„å¦‚ä¸‹ï¼š user.home/.dubbo/dubbo-registry-${å½“å‰åº”ç”¨å}-${å½“å‰æ³¨å†Œä¸­å¿ƒæ‰€åœ¨çš„IPåœ°å€}.cache æ³¨å†Œ/åæ³¨å†Œ123456789101112131415161718192021222324252627282930313233343536373839public abstract class AbstractRegistry implements Registry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * å…ˆæ·»åŠ åˆ° registered ç¼“å­˜ä¸­ï¼Œè¿›è¡ŒçŠ¶æ€çš„ç»´æŠ¤ã€‚å†ç”±å­ç±» FailbackRegistryç±» çœŸæ­£æ³¨å†Œ * * @param url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin */ @Override public void register(URL url) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"register url == null\"); &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Register: \" + url); &#125; registered.add(url); &#125; /** * å…ˆä» registered ç¼“å­˜ä¸­ç§»é™¤ï¼Œå†ç”±å­ç±» FailbackRegistry çœŸæ­£å–æ¶ˆæ³¨å†Œ * * @param url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin */ @Override public void unregister(URL url) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"unregister url == null\"); &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Unregister: \" + url); &#125; registered.remove(url); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; AbstractRegistry æŠ½è±¡ç±»ä¸­çš„æ³¨å†Œå’Œåæ³¨å†Œæ–¹æ³•åªæ˜¯æ“ä½œç¼“å­˜ï¼ŒçœŸæ­£çš„å®ç°äº¤ç»™å­ç±» FailbackRegistry å®Œæˆã€‚ è®¢é˜…/åè®¢é˜…1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public abstract class AbstractRegistry implements Registry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * å…ˆç¼“å­˜åˆ° subscribed ä¸­ï¼Œå†é€šè¿‡å­ç±» FailbackRegistry å…·ä½“æ‰§è¡Œè®¢é˜…é€»è¾‘ * * @param url è®¢é˜…æ¡ä»¶ï¼Œä¸å…è®¸ä¸ºç©ºï¼Œå¦‚ï¼šconsumer://10.10.10.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @param listener å˜æ›´äº‹ä»¶ç›‘å¬å™¨ï¼Œä¸å…è®¸ä¸ºç©º */ @Override public void subscribe(URL url, NotifyListener listener) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"subscribe url == null\"); &#125; if (listener == null) &#123; throw new IllegalArgumentException(\"subscribe listener == null\"); &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Subscribe: \" + url); &#125; /** * 1 ä»ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; subscribedä¸­è·å–keyä¸ºurlçš„é›†åˆSet&lt;NotifyListener&gt; * 2 å¦‚æœè¯¥é›†åˆå­˜åœ¨ï¼Œç›´æ¥å°†å½“å‰çš„NotifyListenerå®ä¾‹å­˜å…¥è¯¥é›†åˆ,å¦‚æœé›†åˆä¸å­˜åœ¨ï¼Œå…ˆåˆ›å»ºï¼Œä¹‹åæ”¾å…¥subscribedä¸­ï¼Œå¹¶å°†å½“å‰çš„NotifyListenerå®ä¾‹å­˜å…¥åˆšåˆšåˆ›å»ºçš„é›†åˆ */ Set&lt;NotifyListener&gt; listeners = subscribed.get(url); if (listeners == null) &#123; subscribed.putIfAbsent(url, new ConcurrentHashSet&lt;NotifyListener&gt;()); listeners = subscribed.get(url); &#125; listeners.add(listener); &#125; /** * å…ˆä»ç¼“å­˜ä¸­ç§»é™¤ï¼Œå†é€šè¿‡å­ç±» FailbackRegistry å…·ä½“æ‰§è¡Œå–æ¶ˆè®¢é˜…çš„é€»è¾‘ * * @param url Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @param listener A listener of the change event, not allowed to be empty */ @Override public void unsubscribe(URL url, NotifyListener listener) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"unsubscribe url == null\"); &#125; if (listener == null) &#123; throw new IllegalArgumentException(\"unsubscribe listener == null\"); &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Unsubscribe: \" + url); &#125; Set&lt;NotifyListener&gt; listeners = subscribed.get(url); if (listeners != null) &#123; listeners.remove(listener); &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; AbstractRegistry æŠ½è±¡ç±»ä¸­çš„è®¢é˜…å’Œåè®¢é˜…æ–¹æ³•åªæ˜¯æ“ä½œç¼“å­˜ï¼ŒçœŸæ­£çš„å®ç°äº¤ç»™å­ç±» FailbackRegistry å®Œæˆã€‚ æ–­çº¿é‡è¿12345678910111213141516171819202122232425262728293031323334353637public abstract class AbstractRegistry implements Registry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * å’Œæ³¨å†Œä¸­å¿ƒæ–­å¼€ï¼Œé‡è¿æˆåŠŸä¼šè°ƒç”¨è¯¥æ–¹æ³•ï¼Œæ¢å¤æ³¨å†Œå’Œè®¢é˜… * * @throws Exception */ protected void recover() throws Exception &#123; // register Set&lt;URL&gt; recoverRegistered = new HashSet&lt;URL&gt;(getRegistered()); if (!recoverRegistered.isEmpty()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Recover register url \" + recoverRegistered); &#125; for (URL url : recoverRegistered) &#123; // æ”¾å…¥ç¼“å­˜ register(url); &#125; &#125; // subscribe Map&lt;URL, Set&lt;NotifyListener&gt;&gt; recoverSubscribed = new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed()); if (!recoverSubscribed.isEmpty()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Recover subscribe url \" + recoverSubscribed.keySet()); &#125; for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : recoverSubscribed.entrySet()) &#123; URL url = entry.getKey(); for (NotifyListener listener : entry.getValue()) &#123; subscribe(url, listener); &#125; &#125; &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; AbstractRegistry æŠ½è±¡ç±»ä¸­çš„æ–­çº¿é‡è¿é€»è¾‘æ˜¯ï¼Œä¸æ³¨å†Œä¸­å¿ƒæ–­å¼€åé‡æ–°è¿æ¥æ—¶ä¼šä»ç¼“å­˜ä¸­å–å‡ºå·²ç»æ³¨å†Œçš„URLé›†åˆï¼Œç„¶åæ”¾å…¥ç¼“å­˜ï¼Œè®¢é˜…åŒç†ã€‚ é€šçŸ¥äºæœ¬åœ°ç¼“å­˜1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public abstract class AbstractRegistry implements Registry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /* * è®¢é˜…URLæ˜ å°„çš„èŠ‚ç‚¹å¯¹åº”çš„å­èŠ‚ç‚¹å‘ç”Ÿå˜åŒ–æ—¶ï¼Œé€šçŸ¥ç›‘å¬å™¨ * @param url è®¢é˜…URL * @param listener è®¢é˜…ULRå¯¹åº”çš„ç›‘å¬å™¨ * @param urls è®¢é˜…URLæ˜ å°„çš„è·¯å¾„ä¸‹çš„å­è·¯å¾„é›†åˆï¼ˆå…¨é‡æ•°æ®ï¼‰ */ protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"notify url == null\"); &#125; if (listener == null) &#123; throw new IllegalArgumentException(\"notify listener == null\"); &#125; if ((urls == null || urls.isEmpty()) &amp;&amp; !Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; logger.warn(\"Ignore empty notify urls for subscribe url \" + url); return; &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Notify urls for subscribe url \" + url + \", urls: \" + urls); &#125; // 1 å°† `urls` æŒ‰ç…§ URLä¸­çš„ 'category` å‚æ•°è¿›è¡Œåˆ†ç±»ï¼Œæ·»åŠ åˆ°Mapé›†åˆresultä¸­ Map&lt;String, List&lt;URL&gt;&gt; result = new HashMap&lt;String, List&lt;URL&gt;&gt;(); // éå† for (URL u : urls) &#123; // å­è·¯å¾„URLæ˜¯å¦åŒ¹é…è®¢é˜…URL if (UrlUtils.isMatch(url, u)) &#123; // è·å–åˆ†ç±»ï¼Œé»˜è®¤ä¸º providers String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY); // åŠ å…¥åˆ°ç»“æœé›† List&lt;URL&gt; categoryList = result.get(category); if (categoryList == null) &#123; categoryList = new ArrayList&lt;URL&gt;(); result.put(category, categoryList); &#125; categoryList.add(u); &#125; &#125; if (result.size() == 0) &#123; return; &#125; // è·å¾—è®¢é˜…URLå¯¹åº”çš„ç¼“å­˜`notified`,å³é€šçŸ¥çš„ URL å˜åŒ–ç»“æœï¼ˆå…¨é‡æ•°æ®ï¼‰ï¼Œä¼šæŠŠresultä¸­çš„å€¼æ”¾å…¥åˆ° categoryNotifiedä¸­ Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url); if (categoryNotified == null) &#123; notified.putIfAbsent(url, new ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;()); categoryNotified = notified.get(url); &#125; // å¤„ç†é€šçŸ¥çš„ URL å˜åŒ–ç»“æœï¼ˆå…¨é‡æ•°æ®ï¼‰ï¼Œå³æŒ‰ç…§åˆ†ç±»ï¼Œå¾ªç¯å¤„ç†é€šçŸ¥çš„URLå˜åŒ–ç»“æœï¼ˆå…¨é‡æ•°æ®ï¼‰ for (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123; // è·å¾—åˆ†ç±»å String category = entry.getKey(); // è·å¾—åˆ†ç±»åå¯¹åº”çš„é€šçŸ¥ULRåˆ—è¡¨ List&lt;URL&gt; categoryList = entry.getValue(); // 1 å°†result è¦†ç›–åˆ° `notified`ç¼“å­˜ã€æ›´æ–°notifiedé›†åˆä¸­çš„é€šçŸ¥ULRåˆ—è¡¨ã€‘ï¼Œéœ€è¦æ³¨æ„ï¼šå½“æŸä¸ªåˆ†ç±»çš„æ•°æ®ä¸ºç©ºæ—¶ï¼Œä¼šä¾ç„¶æœ‰URLï¼Œå¦‚ empty://...` ï¼Œé€šè¿‡è¿™ç§æ–¹å¼ç»Ÿä¸€å¤„ç†æ‰€æœ‰è®¢é˜…URLå¯¹åº”çš„æ•°æ®ä¸ºç©ºçš„æƒ…å†µã€‚ categoryNotified.put(category, categoryList); // 2 ä¿å­˜è®¢é˜…urlå¯¹åº”çš„è¢«é€šçŸ¥çš„URLåˆ° propertieså’Œæ–‡ä»¶ ä¸­ // åœ¨å¾ªç¯ä¸­çš„ä¿å­˜çš„åŸå› æ˜¯ï¼Œè®¢é˜…urlå¯¹åº”çš„é€šçŸ¥urlå¯èƒ½æ˜¯å˜åŠ¨çš„ï¼Œä¸Šä¸€æ­¥çš„æ“ä½œä¼šæ›´æ–°notifiedé›†åˆï¼Œä¸ºäº†è®© propertieså’Œæ–‡ä»¶ä¸­çš„ è®¢é˜…-é€šçŸ¥å…³ç³»æ­£ç¡®å°±éœ€è¦ä¸æ–­æ›´æ–°ã€‚ saveProperties(url); // 3 è°ƒç”¨ä¼ å…¥çš„listenerçš„notify()æ–¹æ³• listener.notify(categoryList); &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œå‘æ³¨å†Œä¸­å¿ƒå‘èµ·è®¢é˜…åï¼Œä¼šè·å–åˆ°è®¢é˜…URLæ‰€å¯¹åº”çš„å…¨é‡æ•°æ®ï¼Œæ¥ç€è°ƒç”¨è¯¥ä¸Šè¿°æ–¹æ³•ï¼›å½“æ³¨å†Œä¸­å¿ƒç›‘æ§çš„æ•°æ®å‘ç”Ÿå˜æ›´æ—¶ï¼Œä¼šè°ƒç”¨ä¸Šè¿°æ–¹æ³•ï¼Œè™½ç„¶å˜åŒ–çš„æ˜¯å¢é‡çš„ï¼Œä½†æ˜¯ä»æ³¨å†Œä¸­å¿ƒæ‹‰å–çš„æ˜¯å…¨é‡çš„æ•°æ®ï¼Œå³æœ€æ–°çš„æ•°æ®ã€‚è¯¥æ–¹æ³•çš„ä½¿ç”¨ä¸»è¦åœ¨æœåŠ¡æš´éœ²è¿‡ç¨‹ä¸­æœåŠ¡æä¾›è€…è®¢é˜…é…ç½®ä¿¡æ¯ï¼Œä¾¿äºé…ç½®å‘ç”Ÿæ”¹å˜æ—¶é€šè¿‡ç›‘å¬å™¨è¿›è¡Œæ•æ‰ç„¶åå›è°ƒè¯¥æ–¹æ³•ï¼Œæœ€ç»ˆå®ŒæˆæœåŠ¡é‡æ–°æš´éœ²ã€‚åœ¨æœåŠ¡å¼•ç”¨è¿‡ç¨‹ä¸­æ¶ˆè´¹è€…è®¢é˜…æœåŠ¡ä¿¡æ¯ã€é…ç½®ä¿¡æ¯ç­‰æœ€ç»ˆå®ŒæˆæœåŠ¡å¼•ç”¨ã€‚è¯¥æ–¹æ³•åœ¨ Dubbo æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…å‘æŒ¥é‡è¦çš„ä½œç”¨ï¼Œåœ¨åˆ†æå®ŒæœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨åä¼šå•ç‹¬å†™ä¸€ç¯‡æ–‡ç« è¯¦ç»†è¯´æ˜ã€‚ é”€æ¯12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public abstract class AbstractRegistry implements Registry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; @Override public void destroy() &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Destroy registry:\" + getUrl()); &#125; // å–æ¶ˆæ³¨å†Œé€»è¾‘ Set&lt;URL&gt; destroyRegistered = new HashSet&lt;URL&gt;(getRegistered()); if (!destroyRegistered.isEmpty()) &#123; for (URL url : new HashSet&lt;URL&gt;(getRegistered())) &#123; if (url.getParameter(Constants.DYNAMIC_KEY, true)) &#123; try &#123; // å–æ¶ˆæ³¨å†Œï¼Œæ“ä½œç¼“å­˜ï¼Œå…·ä½“å®ç°äº¤ç»™å­ç±» unregister(url); if (logger.isInfoEnabled()) &#123; logger.info(\"Destroy unregister url \" + url); &#125; &#125; catch (Throwable t) &#123; logger.warn(\"Failed to unregister url \" + url + \" to registry \" + getUrl() + \" on destroy, cause: \" + t.getMessage(), t); &#125; &#125; &#125; &#125; // å–æ¶ˆè®¢é˜…ï¼Œæ“ä½œç¼“å­˜ï¼Œå…·ä½“å®ç°äº¤ç»™å­ç±» Map&lt;URL, Set&lt;NotifyListener&gt;&gt; destroySubscribed = new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed()); if (!destroySubscribed.isEmpty()) &#123; for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : destroySubscribed.entrySet()) &#123; // è®¢é˜…URL URL url = entry.getKey(); // è®¢é˜…URLå¯¹åº”çš„ç›‘å¬å™¨åˆ—è¡¨ for (NotifyListener listener : entry.getValue()) &#123; try &#123; // å–æ¶ˆè®¢é˜… unsubscribe(url, listener); if (logger.isInfoEnabled()) &#123; logger.info(\"Destroy unsubscribe url \" + url); &#125; &#125; catch (Throwable t) &#123; logger.warn(\"Failed to unsubscribe url \" + url + \" to registry \" + getUrl() + \" on destroy, cause: \" + t.getMessage(), t); &#125; &#125; &#125; &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; ä¸»è¦æ˜¯å–æ¶ˆæ³¨å†Œå’Œè®¢é˜…ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ— è®ºæ˜¯æœåŠ¡æä¾›è€…è¿˜æ˜¯æ¶ˆè´¹è€…ï¼Œéƒ½ä¼šå‘Registryå‘èµ·æ³¨å†Œå’Œè®¢é˜…ï¼Œæ‰€ä»¥åœ¨JVMå…³é—­ç¤ºï¼Œéƒ½è¦è¿›è¡Œå–æ¶ˆã€‚ æœ¬åœ°ç¼“å­˜123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class AbstractRegistry implements Registry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * * @param url è®¢é˜…URL */ private void saveProperties(URL url) &#123; if (file == null) &#123; return; &#125; try &#123; StringBuilder buf = new StringBuilder(); // notified ç¼“å­˜çš„å€¼ï¼š è®¢é˜…URL å¯¹åº”çš„æ˜ å°„é›†åˆï¼Œåªè¦è®¢é˜…URLå…³è”çš„è·¯å¾„ä¸‹æœ‰èŠ‚ç‚¹å˜åŒ–ï¼Œå°±ä¼šä¸æ–­åˆ·æ–°ï¼Œæœ€æ–°æœ€å…¨æ•°æ®ã€‚ Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url); if (categoryNotified != null) &#123; for (List&lt;URL&gt; us : categoryNotified.values()) &#123; for (URL u : us) &#123; if (buf.length() &gt; 0) &#123; buf.append(URL_SEPARATOR); &#125; buf.append(u.toFullString()); &#125; &#125; &#125; properties.setProperty(url.getServiceKey(), buf.toString()); // ç‰ˆæœ¬å·ï¼Œä½¿ç”¨CAS long version = lastCacheChanged.incrementAndGet(); // ä¿å­˜å˜æ›´æ•°æ®åˆ°ç£ç›˜æ–‡ä»¶ if (syncSaveFile) &#123; doSaveProperties(version); &#125; else &#123; registryCacheExecutor.execute(new SaveProperties(version)); &#125; &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; è¯¥æ–¹æ³•ä¸­ä¼šå–å‡ºè®¢é˜…çš„å„ä¸ªåˆ†ç±»ä¸‹çš„URLè¿æ¥èµ·æ¥ï¼ˆä¸­é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼‰ï¼Œç„¶åä»¥è®¢é˜…URLçš„æœåŠ¡é”®ä¸ºkeyå…ˆä¿å­˜åˆ°å†…å­˜ä¸­çš„ Properties ä¸­ï¼Œç„¶ååœ¨åŒæ­¥æˆ–å¼‚æ­¥ä¿å­˜åˆ°ç£ç›˜æ–‡ä»¶ä¸­ï¼ŒåŒæ­¥æˆ–å¼‚æ­¥æ ¹æ® syncSaveFile å‚æ•°å€¼ã€‚æ¥ç€åˆ†æä¿å­˜å˜æ›´æ•°æ®åˆ°ç£ç›˜æ–‡ä»¶ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public abstract class AbstractRegistry implements Registry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * @param version ç‰ˆæœ¬å· */ public void doSaveProperties(long version) &#123; /** * å®‰å…¨æªæ–½ï¼š * 1 CASåˆ¤æ–­ï¼š * åœ¨saveProperties(URL url)æ–¹æ³•ä¸­æ‰§è¡Œäº†long version = lastCacheChanged.incrementAndGet(); * è¿™é‡Œè¿›è¡Œif (version &lt; lastCacheChanged.get())åˆ¤æ–­ï¼Œå¦‚æœæ»¡è¶³è¿™ä¸ªæ¡ä»¶ï¼Œè¯´æ˜å½“å‰çº¿ç¨‹åœ¨è¿›è¡ŒdoSaveProperties(long version)æ—¶ï¼Œ * å·²ç»æœ‰å…¶ä»–çº¿ç¨‹æ‰§è¡Œäº†saveProperties(URL url)ï¼Œé©¬ä¸Šå°±è¦æ‰§è¡ŒdoSaveProperties(long version)ï¼Œæ‰€ä»¥å½“å‰çº¿ç¨‹æ”¾å¼ƒæ“ä½œï¼Œè®©åè¾¹çš„è¿™ä¸ªçº¿ç¨‹æ¥åšä¿å­˜æ“ä½œã€‚ * 2 æ–‡ä»¶é” FileLockï¼š * FileLock æ˜¯è¿›ç¨‹æ–‡ä»¶é”ï¼Œç”¨äºè¿›ç¨‹é—´å¹¶å‘ï¼Œæ§åˆ¶ä¸åŒç¨‹åºï¼ˆJVMï¼‰å¯¹åŒä¸€æ–‡ä»¶çš„å¹¶å‘è®¿é—®ï¼Œæ–‡ä»¶é”å¯ä»¥è§£å†³å¤šä¸ªè¿›ç¨‹å¹¶å‘è®¿é—®ã€å¯ä»¥é€šè¿‡å¯¹ä¸€ä¸ªå¯å†™æ–‡ä»¶åŠ é”ï¼Œä¿è¯åŒæ—¶åªæœ‰ä¸€ä¸ªè¿›ç¨‹å¯ä»¥æ‹¿åˆ°æ–‡ä»¶é”ï¼Œè¿™ä¸ªè¿›ç¨‹ä»è€Œå¯ä»¥å¯¹æ–‡ä»¶è¿›è¡Œæ“ä½œï¼Œ * è€Œå…¶å®ƒæ‹¿ä¸åˆ°é”çš„è¿›ç¨‹è¦ä¹ˆè¢«æŒ‚èµ·ç­‰å¾…ï¼Œè¦ä¹ˆå¯ä»¥å»åšä¸€äº›å…¶å®ƒäº‹æƒ…ï¼Œè¿™ç§æœºåˆ¶ä¿è¯äº†è¿›ç¨‹é—´æ–‡ä»¶çš„å¹¶å‘å®‰å…¨æ“ä½œã€‚ä¿®æ”¹åŒä¸€ä¸ªæ–‡ä»¶çš„é—®é¢˜ï¼Œä½†ä¸èƒ½è§£å†³å¤šçº¿ç¨‹å¹¶å‘è®¿é—®ã€ä¿®æ”¹åŒä¸€æ–‡ä»¶çš„é—®é¢˜ã€‚FileLock æ–‡ä»¶é”çš„æ•ˆæœæ˜¯ä¸æ“ä½œç³»ç»Ÿç›¸å…³çš„ï¼Œæ˜¯ç”±æ“ä½œç³»ç»Ÿåº•å±‚æ¥å®ç°ã€‚ */ if (version &lt; lastCacheChanged.get()) &#123; return; &#125; if (file == null) &#123; return; &#125; // Save try &#123; File lockfile = new File(file.getAbsolutePath() + \".lock\"); if (!lockfile.exists()) &#123; lockfile.createNewFile(); &#125; RandomAccessFile raf = new RandomAccessFile(lockfile, \"rw\"); try &#123; FileChannel channel = raf.getChannel(); try &#123; // å¯¹æ–‡ä»¶åŠ é”ï¼Œé»˜è®¤ä¸ºæ’å®ƒé”ï¼Œæ²¡æœ‰è·å–åˆ°é”çš„è¿›ç¨‹é˜»å¡ç­‰å¾… FileLock lock = channel.tryLock(); if (lock == null) &#123; throw new IOException(\"Can not lock the registry cache file \" + file.getAbsolutePath() + \", ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties\"); &#125; // Save try &#123; if (!file.exists()) &#123; file.createNewFile(); &#125; FileOutputStream outputFile = new FileOutputStream(file); try &#123; properties.store(outputFile, \"Dubbo Registry Cache\"); &#125; finally &#123; outputFile.close(); &#125; // é‡Šæ”¾æ–‡ä»¶é” &#125; finally &#123; lock.release(); &#125; &#125; finally &#123; channel.close(); &#125; &#125; finally &#123; raf.close(); &#125; &#125; catch (Throwable e) &#123; if (version &lt; lastCacheChanged.get()) &#123; return; &#125; else &#123; registryCacheExecutor.execute(new SaveProperties(lastCacheChanged.incrementAndGet())); &#125; logger.warn(\"Failed to save registry store file, cause: \" + e.getMessage(), e); &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; è¯¥æ–¹æ³•ç”¨äºå°† Properties æ–‡ä»¶ä¸­çš„å˜æ›´æ•°æ®ä¿å­˜åˆ°ç£ç›˜æ–‡ä»¶ä¸­ï¼Œåœ¨ä¿å­˜çš„æ—¶å€™åšäº†å¹¶å‘å¤„ç†æ“ä½œï¼Œè¯¦ç»†è§ä»£ç æ³¨é‡Šã€‚ åŠ è½½å˜æ›´æ•°æ®åˆ°å†…å­˜12345678910111213141516171819202122232425262728public abstract class AbstractRegistry implements Registry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; private void loadProperties() &#123; if (file != null &amp;&amp; file.exists()) &#123; InputStream in = null; try &#123; in = new FileInputStream(file); properties.load(in); if (logger.isInfoEnabled()) &#123; logger.info(\"Load registry store file \" + file + \", data: \" + properties); &#125; &#125; catch (Throwable e) &#123; logger.warn(\"Failed to load registry store file \" + file, e); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; &#125; &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; è¯¥æ–¹æ³•ç”¨äºå°†ç£ç›˜æ–‡ä»¶ä¸­çš„å˜æ›´æ•°æ®åŠ è½½åˆ°å†…å­˜ä¸­çš„ Properties ä¸­ã€‚ è·å–è®¢é˜…URLå¯¹åº”çš„å˜æ›´URLåˆ—è¡¨1234567891011121314151617181920212223242526272829303132public abstract class AbstractRegistry implements Registry &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * @param url è®¢é˜…URL * @return */ public List&lt;URL&gt; getCacheUrls(URL url) &#123; for (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123; // æ˜ å°„URL String key = (String) entry.getKey(); // æ˜ å°„URL å¯¹åº”çš„ é€šçŸ¥URLä¸² String value = (String) entry.getValue(); if (key != null &amp;&amp; key.length() &gt; 0 &amp;&amp; key.equals(url.getServiceKey()) &amp;&amp; (Character.isLetter(key.charAt(0)) || key.charAt(0) == '_') &amp;&amp; value != null &amp;&amp; value.length() &gt; 0) &#123; // å¯¹é€šçŸ¥çš„URLä¸² ä»¥ 'ç©ºæ ¼' è¿›è¡Œåˆ†å‰²æˆå­—ç¬¦ä¸² String[] arr = value.trim().split(URL_SPLIT); List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); for (String u : arr) &#123; // è§£æURLä¸² urls.add(URL.valueOf(u)); &#125; return urls; &#125; &#125; return null; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; AbstractRegistry å°ç»“AbstractRegistry æ ¸å¿ƒåŠŸèƒ½æ˜¯æœ¬åœ°æ–‡ä»¶ç¼“å­˜ï¼Œåœ¨ AbstractRegistry åˆå§‹åŒ–æ—¶ï¼Œä¼šè°ƒç”¨ loadProperties() æ–¹æ³•å°†æœ¬åœ°æ–‡ä»¶åŠ è½½åˆ° properties å¯¹è±¡ä¸­ã€‚å½“ç½‘ç»œæŠ–åŠ¨ç­‰æƒ…å†µå¯¼è‡´è®¢é˜…å¤±è´¥æ—¶ï¼Œæ¶ˆè´¹è€…ç«¯çš„ Registry å°±å¯ä»¥è°ƒç”¨ getCacheUrls() æ–¹æ³•è·å–æœ¬åœ°ç¼“å­˜ï¼Œä»è€Œå¾—åˆ°æœ€è¿‘æ³¨å†Œçš„æœåŠ¡æä¾›è€…URLåˆ—è¡¨ï¼ˆè¿˜æœ‰å…¶å®ƒåˆ—è¡¨ï¼‰ï¼ŒAbstractRegistry é€šè¿‡æœ¬åœ°ç¼“å­˜æä¾›äº†ä¸€ç§å®¹é”™æœºåˆ¶ï¼Œä¿è¯äº†æœåŠ¡çš„å¯é æ€§ã€‚ é‡è¯•æœºåˆ¶åœ¨å¾®æœåŠ¡ç³»ç»Ÿä¸­ï¼Œæ³¨å†Œä¸­å¿ƒä¸€èˆ¬éƒ½ä¼šç‹¬ç«‹éƒ¨ç½²æˆä¸€ä¸ªé›†ç¾¤ï¼Œå…¶å®ƒåº”ç”¨é€šè¿‡å®¢æˆ·ç«¯è¿æ¥é›†ç¾¤ï¼Œä»¥å®Œæˆæ³¨å†Œã€è®¢é˜…ç­‰æ“ä½œã€‚ä½†ç½‘ç»œé€šä¿¡æ˜¯ä¸å¯é çš„ï¼Œä¸ºäº†ä¿è¯æœåŠ¡çš„å¯é æ€§ï¼Œé‡è¯•æœºåˆ¶å°±å˜å¾—å¿…ä¸å¯å°‘äº†ã€‚ FailbackRegistryç»§æ‰¿äº† AbstractRegistry æŠ½é—²ç±»ï¼Œæ”¯æŒå¤±è´¥é‡è¯•çš„ Registry æŠ½è±¡ç±»ã€‚AbstractRegistry ä¸­çš„æ³¨å†Œã€è®¢é˜…æ“ä½œæ›´å¤šçš„æ˜¯æ“ä½œç¼“å­˜ï¼Œå¹¶æ²¡æœ‰å’Œæ³¨å†Œä¸­å¿ƒäº¤äº’ã€‚FailbackRegistry åœ¨ AbstractRegistry çš„åŸºç¡€ä¸Šæä¾›äº†æ³¨å†Œå’Œè®¢é˜…çš„æ¨¡ç‰ˆæ–¹æ³•äº¤ç”±å…·ä½“å­ç±»å®ç°é€»è¾‘ï¼Œå¹¶æ”¯æŒå¤±è´¥é‡è¯•æ“ä½œã€‚ä¹Ÿå°±æ˜¯è¯´ FailbackRegistry åŠå…¶ä¸Šå±‚å°†æ•´ä¸ªæµç¨‹æ¨¡å‹æ„å»ºå¥½äº†ï¼Œå…·ä½“å®ç°å¦‚ ZookeeperRegistryã€RedisRegistry ç­‰åªéœ€å…³æ³¨åŠŸèƒ½ç‚¹å³å¯ï¼Œæ— éœ€å…³æ³¨æ•´ä¸ªæ³¨å†Œä¸­å¿ƒæµç¨‹ã€‚ å±æ€§1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public abstract class FailbackRegistry extends AbstractRegistry &#123; /** * å®šæ—¶ä»»åŠ¡æ‰§è¡Œå™¨ */ private final ScheduledExecutorService retryExecutor = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"DubboRegistryFailedRetryTimer\", true)); /** * å¤±è´¥é‡è¯•ScheduledFutureï¼Œå®šæ—¶æ£€æŸ¥æ˜¯å¦æœ‰è¯·æ±‚å¤±è´¥ï¼Œå¦‚æœ‰ï¼Œæ— é™æ¬¡é‡è¯• */ private final ScheduledFuture&lt;?&gt; retryFuture; /** * æ³¨å†Œå¤±è´¥çš„URLé›†åˆ */ private final Set&lt;URL&gt; failedRegistered = new ConcurrentHashSet&lt;URL&gt;(); /** * å–æ¶ˆæ³¨å†Œå¤±è´¥çš„URLé›†åˆ */ private final Set&lt;URL&gt; failedUnregistered = new ConcurrentHashSet&lt;URL&gt;(); /** * è®¢é˜…å¤±è´¥çš„ç›‘å¬å™¨é›†åˆ key: è®¢é˜…å¤±è´¥çš„URL value: å¯¹åº”çš„ç›‘å¬å™¨ */ private final ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; failedSubscribed = new ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(); /** * å–æ¶ˆè®¢é˜…å¤±è´¥çš„ç›‘å¬å™¨é›†åˆ key: è®¢é˜…URL value: å¯¹åº”çš„ç›‘å¬å™¨ */ private final ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; failedUnsubscribed = new ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(); /** * é€šçŸ¥å¤±è´¥çš„URLé›†åˆ key1: è®¢é˜…URL key2: è®¢é˜…URLå¯¹åº”çš„ç›‘å¬å™¨ value: è®¢é˜…URLå¯¹åº”çš„å˜æ›´æ•°æ® */ private final ConcurrentMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt; failedNotified = new ConcurrentHashMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt;(); /** * The time in milliseconds the retryExecutor will wait // é‡è¯•æ“ä½œçš„æ—¶é—´é—´éš” */ private final int retryPeriod; public FailbackRegistry(URL url) &#123; /** * æ‰§è¡Œçˆ¶ç±»æ„é€ æ–¹æ³•ï¼Œ åŠ è½½æœ¬åœ°ç£ç›˜ç¼“å­˜æ–‡ä»¶åˆ°å†…å­˜ç¼“å­˜ï¼Œå³ properties.load(in)ï¼Œåˆ°propertieså±æ€§ä¸­ã€‚ * è¯´æ˜ï¼š * è¿™ä¸ªå¾ˆé‡è¦ï¼Œæ³¨å†Œä¸­å¿ƒå®•æœºçš„æƒ…å†µä¸‹ï¼Œä¾èµ–ç¼“å­˜æ–‡ä»¶ä¸­çš„ä¿¡æ¯å¯ä»¥æ„å»ºInvokerï¼Œä¸å½±å“æœåŠ¡çš„è°ƒç”¨ï¼Œåªæ˜¯ä¸èƒ½è°ƒç”¨æ–°çš„æœåŠ¡äº†ã€‚ */ super(url); // é‡è¯•é¢‘ç‡ï¼Œå•ä½ æ¯«ç§’ this.retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD); // åˆ›å»ºå¤±è´¥é‡è¯•å®šæ—¶å™¨ã€å°±æ˜¯å°†ä¸€å †å¤±è´¥è®°å½•è¿›è¡Œå¯¹åº”çš„é‡è¯•æ“ä½œã€‘ this.retryFuture = retryExecutor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; // Check and connect to the registry try &#123; // æ‰§è¡Œé‡è¯•æ“ä½œ retry(); &#125; catch (Throwable t) &#123; // Defensive fault tolerance logger.error(\"Unexpected error occur at failed retry, cause: \" + t.getMessage(), t); &#125; &#125; &#125;, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS); &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; // ==== Template method ==== protected abstract void doRegister(URL url); protected abstract void doUnregister(URL url); protected abstract void doSubscribe(URL url, NotifyListener listener); protected abstract void doUnsubscribe(URL url, NotifyListener listener);&#125; è¯¥æŠ½è±¡ç±»ä¸»è¦ç»´æŠ¤äº†æ³¨å†Œ/å–æ¶ˆæ³¨å†Œå¤±è´¥ã€è®¢é˜…/å–æ¶ˆè®¢é˜…å¤±è´¥ã€é€šçŸ¥å¤±è´¥çš„ç¼“å­˜ï¼Œä»¥åŠæä¾›è€…äº†æ³¨å†Œ/å–æ¶ˆæ³¨å†Œã€è®¢é˜…/å–æ¶ˆè®¢é˜…çš„æ¨¡ç‰ˆæ–¹æ³•ã€‚è¿›è¡Œæ³¨å†Œæˆ–è®¢é˜…æ“ä½œæ—¶ï¼Œä¼šå…ˆè°ƒç”¨å…¶çˆ¶ç±» AbstractRegistry ä¸­çš„æ–¹æ³•è¿›è¡Œç¼“å­˜æ“ä½œï¼Œç„¶åå†è°ƒç”¨å…¶å…·ä½“å­ç±»çš„æ–¹æ³•ã€‚ register1234567891011121314151617181920212223242526272829303132333435363738public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; @Override public void register(URL url) &#123; // è°ƒç”¨çˆ¶ç±»æ“ä½œç¼“å­˜çš„æ–¹æ³• super.register(url); failedRegistered.remove(url); failedUnregistered.remove(url); try &#123; // å‘èµ·æ³¨å†Œè¯·æ±‚åˆ°æ³¨å†Œä¸­å¿ƒæœåŠ¡å™¨ï¼Œå…·ä½“ç”±å­ç±»å®ç°ï¼Œé€šè¿‡æ³¨å†Œä¸­å¿ƒå®¢æˆ·ç«¯è¿æ¥åˆ°æœåŠ¡ç«¯ doRegister(url); &#125; catch (Exception e) &#123; Throwable t = e; // å¦‚æœå¼€å¯äº†å¯åŠ¨æ—¶æ£€æµ‹ï¼Œåˆ™ç›´æ¥æŠ›å‡ºå¼‚å¸¸ boolean check = getUrl().getParameter(Constants.CHECK_KEY, true) &amp;&amp; url.getParameter(Constants.CHECK_KEY, true) &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol()); boolean skipFailback = t instanceof SkipFailbackWrapperException; if (check || skipFailback) &#123; if (skipFailback) &#123; t = t.getCause(); &#125; throw new IllegalStateException(\"Failed to register \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t); &#125; else &#123; logger.error(\"Failed to register \" + url + \", waiting for retry, cause: \" + t.getMessage(), t); &#125; // è®°å½•æ³¨å†Œå¤±è´¥çš„URLåˆ°æ³¨å†Œå¤±è´¥çš„åˆ—è¡¨ä¸­ï¼Œä¸ºäº†ä»¥åå®šæ—¶é‡è¯• failedRegistered.add(url); &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; unregister1234567891011121314151617181920212223242526272829303132333435363738public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; @Override public void unregister(URL url) &#123; // è°ƒç”¨çˆ¶ç±»æ“ä½œç¼“å­˜çš„æ–¹æ³• super.unregister(url); failedRegistered.remove(url); failedUnregistered.remove(url); try &#123; // å‘èµ·å–æ¶ˆæ³¨å†Œè¯·æ±‚åˆ°æ³¨å†Œä¸­å¿ƒæœåŠ¡å™¨ï¼Œå…·ä½“ç”±å­ç±»å®ç°ï¼Œé€šè¿‡æ³¨å†Œä¸­å¿ƒå®¢æˆ·ç«¯è¿æ¥åˆ°æœåŠ¡ç«¯ doUnregister(url); &#125; catch (Exception e) &#123; Throwable t = e; // If the startup detection is opened, the Exception is thrown directly. boolean check = getUrl().getParameter(Constants.CHECK_KEY, true) &amp;&amp; url.getParameter(Constants.CHECK_KEY, true) &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol()); boolean skipFailback = t instanceof SkipFailbackWrapperException; if (check || skipFailback) &#123; if (skipFailback) &#123; t = t.getCause(); &#125; throw new IllegalStateException(\"Failed to unregister \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t); &#125; else &#123; logger.error(\"Failed to uregister \" + url + \", waiting for retry, cause: \" + t.getMessage(), t); &#125; // Record a failed registration request to a failed list, retry regularly failedUnregistered.add(url); &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; subscribe12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; @Override public void subscribe(URL url, NotifyListener listener) &#123; /** è°ƒç”¨çˆ¶ç±» å°†listenerå®ä¾‹åŠ å…¥åˆ°urlæ‰€å¯¹åº”çš„ç›‘å¬å™¨é›†åˆä¸­ &#123;@link #subscribed &#125; ä¸­ */ super.subscribe(url, listener); // å°†listenerä»failedSubscribed/failedUnsubscribedä¸­åˆ é™¤ ï¼Œæ¥ç€ä»failedNotifiedè·å–å½“å‰urlçš„é€šçŸ¥å¤±è´¥Map&lt;NotifyListener, List&lt;URL&gt;&gt;ï¼Œç„¶åä»ä¸­ åˆ é™¤æ‰listener åˆ° éœ€è¦é€šçŸ¥çš„æ‰€æœ‰url çš„æ˜ å°„ removeFailedSubscribed(url, listener); try &#123; // å‘æœåŠ¡ç«¯å‘é€è®¢é˜…è¯·æ±‚,å…·ä½“è¯·æ±‚å¤„ç†ç”±å­ç±»å®ç° doSubscribe(url, listener); /** å¦‚æœåœ¨è®¢é˜…çš„è¿‡ç¨‹æŠ›å‡ºå¼‚å¸¸ï¼Œé‚£ä¹ˆå°è¯•è·å–ç¼“å­˜urlï¼Œå¦‚æœæœ‰ç¼“å­˜urlï¼Œåˆ™è¿›è¡Œå¤±è´¥é€šçŸ¥ã€‚ä¹‹åâ€œå°†å¤±è´¥çš„è®¢é˜…è¯·æ±‚è®°å½•åˆ°å¤±è´¥åˆ—è¡¨ï¼Œå®šæ—¶é‡è¯•â€ï¼Œå¦‚æœæ²¡æœ‰ç¼“å­˜urlï¼Œ * è‹¥å¼€å¯äº†å¯åŠ¨æ—¶æ£€æµ‹æˆ–è€…ç›´æ¥æŠ›å‡ºçš„å¼‚å¸¸æ˜¯SkipFailbackWrapperExceptionï¼Œåˆ™ç›´æ¥æŠ›å‡ºå¼‚å¸¸ï¼Œä¸ä¼šâ€œå°†å¤±è´¥çš„è®¢é˜…è¯·æ±‚è®°å½•åˆ°å¤±è´¥åˆ—è¡¨ï¼Œå®šæ—¶é‡è¯•â€ */ &#125; catch (Exception e) &#123; Throwable t = e; /** * * ä»Propertiesç¼“å­˜æ–‡ä»¶ä¸­å–å‡ºé€šçŸ¥URLé›†åˆ * ã€æ³¨æ„ï¼šè¿™äº›URLæ˜¯ç”±æ³¨å†Œä¸­å¿ƒç»´æŠ¤çš„ï¼Œæ¯æ¬¡è®¢é˜…æ–¹è¯·æ±‚è®¢é˜…æ—¶ï¼Œæ³¨å†Œä¸­å¿ƒéƒ½ä¼šæŠŠå¯¹åº”çš„è¦é€šçŸ¥çš„URLåˆ—è¡¨è®°å½•åˆ°propertiesæ–‡ä»¶ä¸­ï¼Œç„¶åå†™å…¥ç£ç›˜ï¼Œæ³¨æ„ empty://çš„æƒ…å†µã€‘ */ List&lt;URL&gt; urls = getCacheUrls(url); if (urls != null &amp;&amp; !urls.isEmpty()) &#123; notify(url, listener, urls); logger.error(\"Failed to subscribe \" + url + \", Using cached list: \" + urls + \" from cache file: \" + getUrl().getParameter(Constants.FILE_KEY, System.getProperty(\"user.home\") + \"/dubbo-registry-\" + url.getHost() + \".cache\") + \", cause: \" + t.getMessage(), t); &#125; else &#123; // å¦‚æœå¼€å¯äº†å¯åŠ¨æ—¶æ£€æµ‹check=true,åˆ™ç›´æ¥æŠ›å‡ºå¼‚å¸¸ boolean check = getUrl().getParameter(Constants.CHECK_KEY, true) &amp;&amp; url.getParameter(Constants.CHECK_KEY, true); boolean skipFailback = t instanceof SkipFailbackWrapperException; if (check || skipFailback) &#123; if (skipFailback) &#123; t = t.getCause(); &#125; throw new IllegalStateException(\"Failed to subscribe \" + url + \", cause: \" + t.getMessage(), t); &#125; else &#123; logger.error(\"Failed to subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t); &#125; &#125; // å°†å¤±è´¥çš„è®¢é˜…è¯·æ±‚è®°å½•åˆ°å¤±è´¥åˆ—è¡¨ï¼Œå®šæ—¶é‡è¯• addFailedSubscribed(url, listener); &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; è¯¥æ–¹æ³•ä¸­å‘æœåŠ¡ç«¯å‘é€è®¢é˜…è¯·æ±‚ä¼šäº¤ç»™å­ç±»å¤„ç†ï¼Œå¤±è´¥æ—¶ä¼šè¿›å…¥åˆ° catch å—ä¸­çš„é€»è¾‘ï¼Œæ³¨å†Œä¸­å¿ƒç»´æŠ¤çš„é€šçŸ¥URLåˆ—è¡¨ç”¨åœ¨äº†è¿™é‡Œï¼Œå³å½“è®¢é˜…å‘ç”Ÿå¼‚å¸¸æ—¶ï¼Œä¼šå–å‡ºç¼“å­˜ä¸­çš„é€šçŸ¥ULRåˆ—è¡¨ï¼Œè°ƒç”¨ notify æ–¹æ³•è¿›è¡Œé€šçŸ¥ã€‚è¯¥é€»è¾‘ä¹Ÿè§£é‡Šäº†å³ä½¿æ³¨å†Œä¸­å¿ƒå®•æœºäº†ï¼Œæ— è®ºæ˜¯æ¶ˆè´¹æ–¹åœ¨æ³¨å†Œä¸­å¿ƒå®•æœºå‰å¯åŠ¨å®Œæˆè¿˜æ˜¯å®•æœºåå¯åŠ¨ï¼Œåªè¦æ¶ˆè´¹æ–¹ç¼“å­˜ä¸­çš„æœåŠ¡æä¾›è€…å¯ç”¨ï¼Œå°±å¯ä»¥å®ç°æœåŠ¡è°ƒç”¨ã€‚ unsubscribe123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; /** * å–æ¶ˆè®¢é˜…ï¼Œç§»é™¤ç›¸å…³çš„ç¼“å­˜ã€‚çœŸæ­£çš„å–æ¶ˆè®¢é˜…ç”±å­ç±»æ‰§è¡Œ * * @param url Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @param listener A listener of the change event, not allowed to be empty */ @Override public void unsubscribe(URL url, NotifyListener listener) &#123; // è°ƒç”¨çˆ¶ç±»æ–¹æ³•ï¼Œç§»é™¤urlå¯¹åº”çš„listenerå®ä¾‹ super.unsubscribe(url, listener); // ç§»é™¤ç›¸å…³çš„ è®¢é˜…/å–æ¶ˆè®¢é˜…å¤±è´¥ç¼“å­˜ï¼Œä»¥åŠå¤±è´¥é€šçŸ¥ç¼“å­˜ removeFailedSubscribed(url, listener); try &#123; // å‘æœåŠ¡ç«¯å‘é€å–æ¶ˆè®¢é˜…è¯·æ±‚,å…·ä½“è¯·æ±‚å¤„ç†ç”±å­ç±»å®ç° doUnsubscribe(url, listener); &#125; catch (Exception e) &#123; Throwable t = e; // If the startup detection is opened, the Exception is thrown directly. boolean check = getUrl().getParameter(Constants.CHECK_KEY, true) &amp;&amp; url.getParameter(Constants.CHECK_KEY, true); boolean skipFailback = t instanceof SkipFailbackWrapperException; if (check || skipFailback) &#123; if (skipFailback) &#123; t = t.getCause(); &#125; throw new IllegalStateException(\"Failed to unsubscribe \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t); &#125; else &#123; logger.error(\"Failed to unsubscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t); &#125; // è®°å½•å–æ¶ˆè®¢é˜…ï¼Œä¾¿äºé‡è¯• Set&lt;NotifyListener&gt; listeners = failedUnsubscribed.get(url); if (listeners == null) &#123; failedUnsubscribed.putIfAbsent(url, new ConcurrentHashSet&lt;NotifyListener&gt;()); listeners = failedUnsubscribed.get(url); &#125; listeners.add(listener); &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; notify1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; /** * @param url è®¢é˜…URL * @param listener ç›‘å¬å™¨ * @param urls é€šçŸ¥çš„URLå˜åŒ–ç»“æœï¼ˆå…¨é‡æ•°æ®ï¼‰ã€æ³¨æ„ï¼šå…¨é‡æŒ‡çš„æ˜¯è‡³å°‘è¦æ˜¯ä¸€ä¸ªåˆ†ç±»çš„å…¨é‡[åŠ¨æ€ç±»å‹çš„]ï¼Œè€Œä¸ä¸€å®šæ˜¯å…¨éƒ¨æ•°æ®ã€‘ */ @Override protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"notify url == null\"); &#125; if (listener == null) &#123; throw new IllegalArgumentException(\"notify listener == null\"); &#125; try &#123; // è¿›è¡Œé€šçŸ¥ doNotify(url, listener, urls); &#125; catch (Exception t) &#123; // å°†å¤±è´¥çš„é€šçŸ¥è¯·æ±‚è®°å½•åˆ°å¤±è´¥åˆ—è¡¨ä¸­ï¼Œå®šæ—¶é‡è¯• Map&lt;NotifyListener, List&lt;URL&gt;&gt; listeners = failedNotified.get(url); if (listeners == null) &#123; failedNotified.putIfAbsent(url, new ConcurrentHashMap&lt;NotifyListener, List&lt;URL&gt;&gt;()); listeners = failedNotified.get(url); &#125; listeners.put(listener, urls); logger.error(\"Failed to notify for subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t); &#125; &#125; /** * ä¼šè°ƒç”¨çˆ¶ç±»çš„é€šçŸ¥æ–¹æ³• * * @param url è®¢é˜…URL * @param listener ç›‘å¬å™¨ * @param urls è®¢é˜…URLæ˜ å°„è·¯å¾„ ä¸‹çš„å­è·¯å¾„é›†åˆ */ protected void doNotify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123; super.notify(url, listener, urls); &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; FailbackRegistry ä¸­çš„ notifyæ–¹æ³• æœ¬è´¨ä¸Šè¿˜æ˜¯è°ƒç”¨ AbstractRegistry ä¸­çš„ notify æ–¹æ³•ï¼ŒåŒºåˆ«åœ¨äº FailbackRegistry ä¼šæ”¶é›†å¤±è´¥é€šçŸ¥è¯·æ±‚å¹¶è®°å½•åˆ°ç¼“å­˜ä¸­ï¼Œä¾¿äºé‡è¯•ã€‚ æ–­çº¿é‡è¿1234567891011121314151617181920212223242526272829303132333435363738public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; /** * * @throws Exception */ @Override protected void recover() throws Exception &#123; // register Set&lt;URL&gt; recoverRegistered = new HashSet&lt;URL&gt;(getRegistered()); if (!recoverRegistered.isEmpty()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Recover register url \" + recoverRegistered); &#125; for (URL url : recoverRegistered) &#123; failedRegistered.add(url); &#125; &#125; // subscribe Map&lt;URL, Set&lt;NotifyListener&gt;&gt; recoverSubscribed = new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed()); if (!recoverSubscribed.isEmpty()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Recover subscribe url \" + recoverSubscribed.keySet()); &#125; for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : recoverSubscribed.entrySet()) &#123; URL url = entry.getKey(); for (NotifyListener listener : entry.getValue()) &#123; addFailedSubscribed(url, listener); &#125; &#125; &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; FailbackRegistry å®Œå…¨è¦†å†™çˆ¶ç±»æ–¹æ³•(å³ä¸åƒå‰å‡ ä¸ªæ–¹æ³•ï¼Œä¼šè°ƒç”¨çˆ¶ç±»çš„æ–¹æ³•)ï¼Œå°†å·²æ³¨å†Œå’Œè®¢é˜…çš„URLæ·»åŠ åˆ° {@link #failedRegistered} ,{@link #failedSubscribed} å±æ€§ä¸­ï¼Œè¿™æ ·åœ¨{@link #retry()}æ–¹æ³•ä¸­ä¼šè¿›è¡Œé‡è¯•ã€‚ é‡è¯•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; protected void retry() &#123; //é‡æ–°æ³¨å†Œæ²¡æœ‰æ³¨å†ŒæˆåŠŸçš„URLé›†åˆ if (!failedRegistered.isEmpty()) &#123; Set&lt;URL&gt; failed = new HashSet&lt;URL&gt;(failedRegistered); if (failed.size() &gt; 0) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Retry register \" + failed); &#125; try &#123; for (URL url : failed) &#123; try &#123; doRegister(url); failedRegistered.remove(url); &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry register \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry register \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; // é‡æ–°å–æ¶ˆæ³¨å†Œæ²¡æœ‰å–æ¶ˆæ³¨å†ŒæˆåŠŸçš„URLé›†åˆ if (!failedUnregistered.isEmpty()) &#123; Set&lt;URL&gt; failed = new HashSet&lt;URL&gt;(failedUnregistered); if (!failed.isEmpty()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Retry unregister \" + failed); &#125; try &#123; for (URL url : failed) &#123; try &#123; doUnregister(url); failedUnregistered.remove(url); &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry unregister \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry unregister \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; /** * * é‡æ–°è®¢é˜… ä¹‹å‰è®¢é˜…å¤±è´¥çš„URL *1 æŠŠè¦è®¢é˜…çš„URLæ˜ å°„çš„è·¯å¾„ä¸ç›‘å¬å™¨ç»‘å®š *2 åˆ›å»ºè¯¥ç›‘å¬å™¨å…³è”çš„ChildListenerï¼Œåº•å±‚åˆä¼šä½¿ç”¨TargetChildListenerå»åŒ…è£¹ChildListenerï¼Œæ³¨æ„ï¼ŒTargetChildListenerçš„å®ç°ä¼šæœ‰ä¸åŒ *3 TargetChildListenerç›´æ¥ç›‘å¬è®¢é˜…çš„URLæ˜ å°„è·¯å¾„çš„å­è·¯å¾„ï¼Œå½“å­è·¯å¾„æœ‰å˜åŒ–ï¼Œå…ˆè§¦å‘TargetChildListenerçš„æ–¹æ³•ï¼Œç„¶åè¯¥æ–¹æ³•ä¼šè°ƒç”¨ChildListenerçš„childChangedæ–¹æ³•ï¼Œæ¥ç€è°ƒç”¨ç›‘å¬çš„notifyæ–¹æ³• * * TargetChildListener */ if (!failedSubscribed.isEmpty()) &#123; Map&lt;URL, Set&lt;NotifyListener&gt;&gt; failed = new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failedSubscribed); for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failed).entrySet()) &#123; if (entry.getValue() == null || entry.getValue().size() == 0) &#123; failed.remove(entry.getKey()); &#125; &#125; if (failed.size() &gt; 0) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Retry subscribe \" + failed); &#125; try &#123; for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : failed.entrySet()) &#123; URL url = entry.getKey(); Set&lt;NotifyListener&gt; listeners = entry.getValue(); for (NotifyListener listener : listeners) &#123; try &#123; doSubscribe(url, listener); listeners.remove(listener); &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry subscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry subscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; // é‡æ–°ç§»é™¤URLæ˜ å°„è·¯å¾„ä¸‹çš„å­è·¯å¾„å…³è”çš„ç›‘å¬å™¨ if (!failedUnsubscribed.isEmpty()) &#123; Map&lt;URL, Set&lt;NotifyListener&gt;&gt; failed = new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failedUnsubscribed); for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : new HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failed).entrySet()) &#123; if (entry.getValue() == null || entry.getValue().isEmpty()) &#123; failed.remove(entry.getKey()); &#125; &#125; if (failed.size() &gt; 0) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Retry unsubscribe \" + failed); &#125; try &#123; for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : failed.entrySet()) &#123; URL url = entry.getKey(); Set&lt;NotifyListener&gt; listeners = entry.getValue(); for (NotifyListener listener : listeners) &#123; try &#123; doUnsubscribe(url, listener); listeners.remove(listener); &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry unsubscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry unsubscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; // é‡æ–°é€šçŸ¥ã€çœ‹é€šçŸ¥çš„URLåˆ—è¡¨ï¼ˆå‘ç”Ÿæ”¹å˜çš„URLåˆ—è¡¨ï¼‰å’ŒåŸå§‹çš„URLåˆ—è¡¨å¯¹æ¯”ï¼Œçœ‹æ˜¯å¦æ”¹å˜ï¼Œæ”¹å˜äº†å°±éœ€è¦é‡æ–°æš´éœ²æœåŠ¡ã€‘ if (!failedNotified.isEmpty()) &#123; Map&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt; failed = new HashMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt;(failedNotified); for (Map.Entry&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt; entry : new HashMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt;(failed).entrySet()) &#123; if (entry.getValue() == null || entry.getValue().size() == 0) &#123; failed.remove(entry.getKey()); &#125; &#125; if (failed.size() &gt; 0) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Retry notify \" + failed); &#125; try &#123; for (Map&lt;NotifyListener, List&lt;URL&gt;&gt; values : failed.values()) &#123; for (Map.Entry&lt;NotifyListener, List&lt;URL&gt;&gt; entry : values.entrySet()) &#123; try &#123; NotifyListener listener = entry.getKey(); List&lt;URL&gt; urls = entry.getValue(); listener.notify(urls); values.remove(listener); &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry notify \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; &#125; catch (Throwable t) &#123; // Ignore all the exceptions and wait for the next retry logger.warn(\"Failed to retry notify \" + failed + \", waiting for again, cause: \" + t.getMessage(), t); &#125; &#125; &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; é‡è¯•æ–¹æ³•å°±æ˜¯éå†ç¼“å­˜ä¸­äº”ä¸ª failedXxxå±æ€§ï¼Œé‡è¯•å¯¹åº”çš„æ“ä½œï¼Œå¾ˆæ¸…æ™°ã€‚ é”€æ¯12345678910111213141516171819202122public abstract class FailbackRegistry extends AbstractRegistry &#123; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125; @Override public void destroy() &#123; // è°ƒç”¨çˆ¶æ–¹æ³•ï¼Œå–æ¶ˆæ³¨å†Œå’Œè®¢é˜… super.destroy(); try &#123; // å–æ¶ˆé‡è¯•ä»»åŠ¡ retryFuture.cancel(true); &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; // ä¼˜é›…å…³é—­çº¿ç¨‹æ±  ExecutorUtil.gracefulShutdown(retryExecutor, retryPeriod); &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; å–æ¶ˆæ³¨å†Œå’Œè®¢é˜…ï¼Œå¹¶å…³é—­é‡è¯•ä»»åŠ¡ã€‚å–æ¶ˆæ³¨å†Œå’Œè®¢é˜…è¿˜æ˜¯è°ƒç”¨å…¶çˆ¶ç±» AbstractRegistry çš„ destroy çš„æ–¹æ³•ï¼Œåœ¨çˆ¶ç±»åŸºç¡€ä¸Šå¢åŠ äº†å¯¹ä»»åŠ¡å–æ¶ˆæ“ä½œä»¥åŠå…³é—­é‡è¯•çº¿ç¨‹æ± ã€‚ RegistryFactory1234567891011121314151617/** * RegistryFactory. (SPI, Singleton, ThreadSafe) æ³¨å†Œä¸­å¿ƒå·¥å‚æ¥å£ï¼Œåˆ›å»ºçš„æ³¨å†Œä¸­å¿ƒï¼ŒåŒ…å«æ³¨å†Œä¸­å¿ƒå®¢æˆ·ç«¯ã€‚æ³¨æ„å’Œæ³¨å†Œä¸­å¿ƒå®¢æˆ·ç«¯å·¥å‚çš„åŒºåˆ«ã€‚ * * @see com.alibaba.dubbo.registry.support.AbstractRegistryFactory */@SPI(\"dubbo\")public interface RegistryFactory &#123; /** * è·å–æ³¨å†Œä¸­å¿ƒ * * @param url æ³¨å†Œä¸­å¿ƒåœ°å€ï¼Œä¸å…è®¸ä¸ºç©º * @return æ³¨å†Œä¸­å¿ƒå¼•ç”¨ï¼Œæ€»ä¸è¿”å›ç©º */ @Adaptive(&#123;\"protocol\"&#125;) Registry getRegistry(URL url);&#125; æ³¨å†Œä¸­å¿ƒå·¥å‚ï¼Œå®ƒæ˜¯ä¸€ä¸ª Dubbo çš„æ‰©å±•ç‚¹ï¼Œé»˜è®¤æ‰©å±•åæ˜¯ dubbo ï¼Œå³é»˜è®¤çš„æ‰©å±•å®ç°æ˜¯ DubboRegistryFactory ï¼Œ@Adaptive æ³¨è§£è¡¨ç¤ºä¼šç”Ÿæˆé€‚é…å™¨ç±»å¹¶æ ¹æ® URL å‚æ•°ä¸­çš„ protocol å‚æ•°å€¼é€‰æ‹©ç›¸åº”çš„å®ç°ã€‚ç”¨äºè´Ÿè´£åˆ›å»º Registry å¯¹è±¡ï¼Œæ¯ä¸ª Registry å®ç°ç±»éƒ½æœ‰å¯¹åº”çš„ RegistryFactory å·¥å‚å®ç°ã€‚ AbstractRegistryFactory1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * AbstractRegistryFactory. (SPI, Singleton, ThreadSafe) * * @see com.alibaba.dubbo.registry.RegistryFactory */public abstract class AbstractRegistryFactory implements RegistryFactory &#123; // Log output private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRegistryFactory.class); /** * LOCK é”ï¼Œç”¨äº #destroyAll() å’Œ #getRegistry(url) æ–¹æ³•ï¼Œå¤„ç†å¯¹ REGISTRIES å±æ€§è®¿é—®çš„ç«äº‰ã€‚ */ private static final ReentrantLock LOCK = new ReentrantLock(); /** * Registry é›†åˆ */ private static final Map&lt;String, Registry&gt; REGISTRIES = new ConcurrentHashMap&lt;String, Registry&gt;(); /** * Get all registries * * @return all registries */ public static Collection&lt;Registry&gt; getRegistries() &#123; return Collections.unmodifiableCollection(REGISTRIES.values()); &#125; /** * é”€æ¯æ‰€æœ‰çš„Registryå¯¹è±¡ */ public static void destroyAll() &#123; if (LOGGER.isInfoEnabled()) &#123; LOGGER.info(\"Close all registries \" + getRegistries()); &#125; // è·å¾—é” // Lock up the registry shutdown process LOCK.lock(); try &#123; // å¾ªç¯è°ƒç”¨ destroy() æ–¹æ³• for (Registry registry : getRegistries()) &#123; try &#123; // AbstractRegistry å®ç°äº†å…¬ç”¨çš„é”€æ¯é€»è¾‘ï¼Œå–æ¶ˆæ³¨å†Œå’Œè®¢é˜… registry.destroy(); &#125; catch (Throwable e) &#123; LOGGER.error(e.getMessage(), e); &#125; &#125; // æ¸…ç©ºç¼“å­˜ REGISTRIES.clear(); &#125; finally &#123; // Release the lock LOCK.unlock(); &#125; &#125; @Override public Registry getRegistry(URL url) &#123; url = url.setPath(RegistryService.class.getName()) // å°† RegistryService çš„ç±»åè®¾ç½®ä¸º URL çš„ path å€¼ .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName()) // å°† RegistryService çš„ç±»åè®¾ç½®ä¸º URL çš„interface å€¼ï¼Œè¯¥å±æ€§åœ¨åæ¥çš„è®¢é˜…é€šçŸ¥å¾ˆæœ‰ç”¨ .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY); // è§„èŒƒ URL æ“ä½œï¼ŒåŠåˆ é™¤ export å’Œ refer å‚æ•° String key = url.toServiceString(); // Lock the registry access process to ensure a single instance of the registry LOCK.lock(); try &#123; // è®¿é—®ç¼“å­˜ Registry registry = REGISTRIES.get(key); if (registry != null) &#123; return registry; &#125; // ç¼“å­˜æœªå‘½ä¸­ï¼Œåˆ›å»ºRegistry å®ä¾‹ï¼Œäº¤ç»™å…·ä½“å­ç±»å®ç° registry = createRegistry(url); if (registry == null) &#123; throw new IllegalStateException(\"Can not create registry \" + url); &#125; // å†™å…¥ç¼“å­˜ REGISTRIES.put(key, registry); return registry; &#125; finally &#123; // Release the lock LOCK.unlock(); &#125; &#125; /** * åˆ›å»ºæ³¨å†Œä¸­å¿ƒçš„æ¨¡ç‰ˆæ–¹æ³•ï¼Œç”±å…·ä½“å­ç±»å®ç°ï¼Œè¿‡ç¨‹åŒ…æ‹¬ï¼š * 1 åˆ›å»ºæ³¨å†Œä¸­å¿ƒå®¢æˆ·ç«¯ * 2 å¯åŠ¨å®¢æˆ·ç«¯ * * @param url æ³¨å†Œä¸­å¿ƒåœ°å€ * @return Registry å¯¹è±¡ */ protected abstract Registry createRegistry(URL url);&#125; å®ç° RegistryFactory æ¥å£ï¼Œæ˜¯RegistryFactory æŠ½è±¡ç±»ï¼Œä¸»è¦ä¸¤ä¸ªå·¥ä½œï¼Œå°†è·å–çš„æ³¨å†Œä¸­å¿ƒæ”¾å…¥åˆ°ç¼“å­˜å’Œå®ç°äº†å…¬ç”¨çš„é”€æ¯é€»è¾‘ï¼Œå–æ¶ˆæ³¨å†Œå’Œè®¢é˜…ã€‚ NotifyListener1234567891011121314/** * NotifyListener. (API, Prototype, ThreadSafe) é€šçŸ¥ç›‘å¬å™¨ * * @see com.alibaba.dubbo.registry.RegistryService#subscribe(URL, NotifyListener) */public interface NotifyListener &#123; /** * å½“æ”¶åˆ°è®¢é˜…URLå¯¹åº”çš„æ•°æ®å‘ç”Ÿå˜åŒ–ï¼Œé€šçŸ¥è§¦å‘ * * @param urls å·²æ³¨å†Œä¿¡æ¯åˆ—è¡¨ï¼Œæ€»ä¸ä¸ºç©º */ void notify(List&lt;URL&gt; urls);&#125; è¯¥æ¥å£çš„å®ç°ç±»ä¸»è¦åˆ†ä¸ºä¸¤å¤§ç±»ï¼ŒRegistryDirectory å’Œ åŒ¿åç±»å†…éƒ¨ç±»ï¼Œå…·ä½“çš„ä½œç”¨åœ¨è®¢é˜…é€šçŸ¥ç« èŠ‚è¯´æ˜ã€‚ å°ç»“æœ¬ç« ä¸»è¦ä»‹ç»äº†æ³¨å†Œçš„æŠ½è±¡å±‚ï¼Œæ¥ä¸‹æ¥çš„æ–‡ç« ä¼šåˆ†æ Zookeeper å’Œ Redis çš„å®ç°ï¼Œå…¶ä»–ä¸¤ç§ä¸åšåˆ†æã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - æœåŠ¡å®¹å™¨","slug":"rpc/æœåŠ¡å®¹å™¨","date":"2020-04-09T16:00:00.000Z","updated":"2020-09-04T07:39:03.454Z","comments":false,"path":"posts/714ea63d/","link":"","permalink":"https://gentryhuang.com/posts/714ea63d/","excerpt":"","text":"å‰è¨€å‰é¢çš„ Dubbo SPIã€Dubboé…ç½®ç­‰æ–‡ç« æè¿°çš„å‡ ä¹éƒ½åªæ˜¯æœåŠ¡æš´éœ²ã€æœåŠ¡å¼•ç”¨ã€æœåŠ¡è°ƒç”¨ä¹‹å‰çš„å‡†å¤‡å·¥ä½œï¼Œæœ‰äº†è¿™äº›å‡†å¤‡å·¥ä½œåï¼Œä¸‹é¢ä»‹ç»Dubboçš„æœåŠ¡å®¹å™¨ï¼Œé€šè¿‡DubboæœåŠ¡å®¹å™¨å¯ä»¥éå¸¸æ–¹ä¾¿å¯åŠ¨ä¸€ä¸ªDubboæœåŠ¡ã€‚ DubboæœåŠ¡å®¹å™¨Dubboçš„æœåŠ¡å®¹å™¨åªæ˜¯ä¸€ä¸ªç®€å•çš„Mainï¼Œç±»ä¼¼SpringBoot,è´Ÿè´£åˆå§‹åŒ–å’Œå¯åŠ¨ä¸åŒåŠŸèƒ½çš„ Container ï¼Œå¦‚æœè¯´dubboçš„æœåŠ¡å®¹å™¨æ˜¯ä¸€ä¸ªç®€å•çš„Mainæ–¹æ³•ï¼Œé‚£ä¹ˆæ‰¿è½½ä¸åŒåŠŸèƒ½çš„Containerå°±æ˜¯æœåŠ¡å®¹å™¨çš„å…·ä½“å®ç°ï¼Œå¯ä»¥æœ‰ä¸åŒçš„ç±»å‹ã€‚umlå…³ç³»å›¾å¦‚ä¸‹ï¼š å®¹å™¨æ‰©å±•ç‚¹123456789101112131415161718/** * Container. (SPI, Singleton, ThreadSafe) * * æœåŠ¡å®¹å™¨æ¥å£ï¼ŒDubboçš„æ‰©å±•ç‚¹ï¼Œé»˜è®¤ä¸º spring */@SPI(\"spring\")public interface Container &#123; /** * start. å¯åŠ¨å®¹å™¨ */ void start(); /** * stop. ä½“åˆ¶å®¹å™¨ */ void stop();&#125; å¯åŠ¨å™¨Main123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class Main &#123; private static final Logger logger = LoggerFactory.getLogger(Main.class); /** * Containerçš„é…ç½®é¡¹ï¼Œå¦‚ dubbo.container=spring,log4j */ public static final String CONTAINER_KEY = \"dubbo.container\"; /** * Dubbo ä¼˜é›…åœæœºé…ç½®é¡¹ï¼Œå¦‚ dubbo.shutdown.hook=true */ public static final String SHUTDOWN_HOOK_KEY = \"dubbo.shutdown.hook\"; /** * Containeræ‰©å±•ç‚¹çš„åŠ è½½å™¨ */ private static final ExtensionLoader&lt;Container&gt; loader = ExtensionLoader.getExtensionLoader(Container.class); /** * é” */ private static final ReentrantLock LOCK = new ReentrantLock(); /** * é”çš„æ¡ä»¶ */ private static final Condition STOP = LOCK.newCondition(); /** * @param args å¯åŠ¨å‚æ•°ï¼Œå¯ä»¥åœ¨å¯åŠ¨æ—¶æŒ‡å®šè¦åŠ è½½çš„å®¹å™¨ï¼Œå¦‚ java com.alibaba.dubbo.container.Main spring log4j */ public static void main(String[] args) &#123; try &#123; // å¦‚æœ main æ–¹æ³•çš„å‚æ•°æ²¡æœ‰ä¼ å…¥å€¼ï¼Œåˆ™ä»é…ç½®ä¸­åŠ è½½ã€‚å¦‚æœè·å–ä¸åˆ°å°±ä½¿ç”¨Container é»˜è®¤æ‰©å±• spring if (args == null || args.length == 0) &#123; String config = ConfigUtils.getProperty(CONTAINER_KEY, loader.getDefaultExtensionName()); args = Constants.COMMA_SPLIT_PATTERN.split(config); &#125; final List&lt;Container&gt; containers = new ArrayList&lt;Container&gt;(); for (int i = 0; i &lt; args.length; i++) &#123; // ä½¿ç”¨Dubbo SPI åŠ è½½ Container ,å¹¶æŠŠåŠ è½½çš„Container æ”¾å…¥åˆ°Listä¸­ containers.add(loader.getExtension(args[i])); &#125; logger.info(\"Use container type(\" + Arrays.toString(args) + \") to run dubbo serivce.\"); // å½“é…ç½®JVMå¯åŠ¨å‚æ•°å¸¦æœ‰ -Ddubbo.shutdown.hook=trueæ—¶ï¼Œæ·»åŠ å…³é—­çš„ShutdownHook if (\"true\".equals(System.getProperty(SHUTDOWN_HOOK_KEY))) &#123; // ä¼˜é›…åœæœº Runtime.getRuntime().addShutdownHook(new Thread(\"dubbo-container-shutdown-hook\") &#123; @Override public void run() &#123; for (Container container : containers) &#123; try &#123; // å…³é—­å®¹å™¨ container.stop(); logger.info(\"Dubbo \" + container.getClass().getSimpleName() + \" stopped!\"); &#125; catch (Throwable t) &#123; logger.error(t.getMessage(), t); &#125; try &#123; // è·å¾— ReentrantLock LOCK.lock(); // å”¤é†’ Main ä¸»çº¿ç¨‹çš„ç­‰å¾… STOP.signal(); &#125; finally &#123; // é‡Šæ”¾ LOCK LOCK.unlock(); &#125; &#125; &#125; &#125;); &#125; // å¯åŠ¨å®¹å™¨ for (Container container : containers) &#123; container.start(); logger.info(\"Dubbo \" + container.getClass().getSimpleName() + \" started!\"); &#125; System.out.println(new SimpleDateFormat(\"[yyyy-MM-dd HH:mm:ss]\").format(new Date()) + \" Dubbo service server started!\"); // å‘ç”Ÿå¼‚å¸¸ï¼Œæ‰“å°é”™è¯¯æ—¥å¿—ï¼Œå¹¶JVMé€€å‡º &#125; catch (RuntimeException e) &#123; e.printStackTrace(); logger.error(e.getMessage(), e); System.exit(1); &#125; try &#123; // è·å¾— LOCK é” LOCK.lock(); /** * é‡Šæ”¾é”ï¼Œè¿›å…¥ç­‰å¾…ï¼Œç›´åˆ°è¢«å”¤é†’ * ä½œç”¨ï¼šçº¿ç¨‹ä¸ç»“æŸï¼Œä¸è§¦å‘JVMé€€å‡ºï¼Œè¿™æ ·Dubboå°±ä¸ä¼šé€€å‡ºã€‚å¦‚æœä¸ç­‰å¾…ï¼Œmainæ–¹æ³•æ‰§è¡Œå®Œæˆï¼Œå°±ä¼šè§¦å‘JVMé€€å‡ºï¼Œå¯¼è‡´DubboæœåŠ¡é€€å‡º */ STOP.await(); &#125; catch (InterruptedException e) &#123; logger.warn(\"Dubbo service server stopped, interrupted by other thread!\", e); &#125; finally &#123; // é‡Šæ”¾ LOCK LOCK.unlock(); &#125; &#125;&#125; è¯´æ˜ dubboæœåŠ¡å®¹å™¨åªæ˜¯ä¸€ä¸ªç®€å•Main æ–¹æ³•ï¼Œé»˜è®¤æƒ…å†µä¸‹åªä¼šåŠ è½½ä¸€ä¸ªç®€å•çš„Springå®¹å™¨ï¼Œç”¨äºæš´éœ²æœåŠ¡ã€‚DubboæœåŠ¡å®¹å™¨çš„åŠ è½½å†…å®¹å¯ä»¥æ‰©å±•ï¼Œå³å¯é€šè¿‡å®¹å™¨æ‰©å±•ç‚¹è¿›è¡Œæ‰©å±•ï¼Œå¦‚ï¼šspringã€logbackç­‰ã€‚ dubboæœåŠ¡å®¹å™¨æ˜¯dubboæœåŠ¡çš„å¯åŠ¨å™¨ï¼Œå®ƒçš„æœ¬è´¨æ˜¯å¯åŠ¨æ—¶åŠ è½½dubboçš„ç›¸å…³å†…å®¹ã€é€šè¿‡springé…ç½®ï¼Œlog4jé…ç½®ç­‰ä½“ç°ã€‘ç„¶åå¯åŠ¨Containerã€‚ä½†æ˜¯ å®é™…ç”Ÿäº§ä¸­ï¼Œä¸€èˆ¬ä¸ä¼šç›´æ¥ä½¿ç”¨dubboçš„æœåŠ¡å®¹å™¨ï¼Œæ›´å¤šä¸»æµçš„æ˜¯ä½¿ç”¨Springæˆ–è€…SpringBoot SpringContainer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * SpringContainer. (SPI, Singleton, ThreadSafe) * å®ç°Containeræ¥å£ï¼ŒSpringå®¹å™¨å®ç°ç±» */public class SpringContainer implements Container &#123; private static final Logger logger = LoggerFactory.getLogger(SpringContainer.class); /** * Spring é…ç½®å±æ€§ */ public static final String SPRING_CONFIG = \"dubbo.spring.config\"; /** * é»˜è®¤é…ç½®æ–‡ä»¶åœ°å€ */ public static final String DEFAULT_SPRING_CONFIG = \"classpath*:META-INF/spring/*.xml\"; /** * Spring ä¸Šä¸‹æ–‡ ï¼Œé™æ€å±æ€§ï¼Œå…¨å±€å”¯ä¸€ */ static ClassPathXmlApplicationContext context; public static ClassPathXmlApplicationContext getContext() &#123; return context; &#125; @Override public void start() &#123; // è·å¾—Spring é…ç½®æ–‡ä»¶çš„åœ°å€ã€å…ˆä¼˜å…ˆä»JVMå‚æ•°ä¸­å–ï¼Œæ²¡æœ‰å†ä»dubbo.propertiesæ–‡ä»¶ä¸­å–ã€‘ String configPath = ConfigUtils.getProperty(SPRING_CONFIG); // å¦‚æœæ²¡æœ‰é…ç½®å°±ä½¿ç”¨é»˜è®¤è·¯å¾„ä¸‹çš„é…ç½®æ–‡ä»¶ if (configPath == null || configPath.length() == 0) &#123; configPath = DEFAULT_SPRING_CONFIG; &#125; // åˆ›å»ºSpring ä¸Šä¸‹æ–‡ context = new ClassPathXmlApplicationContext(configPath.split(\"[,\\\\s]+\"), false); // æ·»åŠ ç›‘å¬å™¨ [dubboæœåŠ¡æš´éœ²ã€æœåŠ¡é”€æ¯ä»¥åŠä¼˜é›…åœæœºçš„å…³é”®] context.addApplicationListener(new DubboApplicationListener()); // ç›‘å¬å®¹å™¨å…³é—­ [æ³¨å†Œä¼˜é›…åœæœºé’©å­] context.registerShutdownHook(); // åˆ·æ–°Springå®¹å™¨ context.refresh(); // å¯åŠ¨Springå®¹å™¨ï¼ŒåŠ è½½Dubboçš„é…ç½®ï¼Œä»è€Œå¯åŠ¨Dubbo æœåŠ¡ context.start(); &#125; @Override public void stop() &#123; try &#123; if (context != null) &#123; // åœæ­¢ä¸Šä¸‹æ–‡ï¼Œä¼šè§¦å‘ ContextStoppedEvent äº‹ä»¶ context.stop(); // å…³é—­ä¸Šä¸‹æ–‡ï¼Œä¼šè§¦å‘ ContextClosedEvent äº‹ä»¶ context.close(); // ç½®ç©ºï¼Œä¾¿äºè¢«å›æ”¶ context = null; &#125; &#125; catch (Throwable e) &#123; logger.error(e.getMessage(), e); &#125; &#125;&#125; è¯´æ˜ DubboApplicationListenerå®ç°äº†ApplicationListeneræ¥å£ï¼Œç”¨äºç›‘å¬Springå®¹å™¨çš„èµ·åœï¼Œåœ¨å¯åŠ¨å’Œé”€æ¯çš„æ—¶å€™åˆ†åˆ«æ‰§è¡ŒæœåŠ¡æš´éœ²å’Œå–æ¶ˆæœåŠ¡æš´éœ²ä»¥åŠæ‰§è¡Œä¼˜é›…åœæœº åˆ›å»ºDubboApplicationListenerå¯¹è±¡çš„æ—¶å€™ï¼Œéƒ½ä¼šåˆ›å»ºDubboBootstrapå¯¹è±¡ï¼Œè¯¥å¯¹è±¡ä¸»è¦å®ŒæˆæœåŠ¡æš´éœ²ã€å–æ¶ˆæœåŠ¡æš´éœ²ã€æ³¨å†Œä¸ç§»é™¤jdk shutdownhook åœ¨åˆ›å»ºDubboBootstrapå¯¹è±¡æ—¶ï¼Œä¼šä¸ºè¯¥ç±»æ³¨å…¥DubboShutdownHookå¯¹è±¡ï¼Œè¯¥å¯¹è±¡ç»§æ‰¿äº†Threadï¼Œå°†é‡Šæ”¾èµ„æºçš„æ–¹æ³•ä½œä¸ºä»»åŠ¡ä½“ï¼Œè¯¥å¯¹è±¡æ˜¯çœŸæ­£è¦æ³¨å†Œåˆ°ç³»ç»Ÿä¸­çš„é’©å­ï¼Œå½“JVMé€€å‡ºæ—¶è¯¥é’©å­ä¼šå›è°ƒå®ƒçš„ä»»åŠ¡ä½“ å…³ç³»å›¾å¦‚ä¸‹ DubboApplicationListener1234567891011121314151617181920212223242526272829303132333435/** * An application listener that listens the ContextClosedEvent. * Upon the event, this listener will do the necessary clean up to avoid memory leak. */public class DubboApplicationListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123; /** * Dubboå¼•å¯¼ç¨‹åº */ private DubboBootstrap dubboBootstrap; public DubboApplicationListener() &#123; // åˆ›å»ºDubboBootstrap dubboBootstrap = new DubboBootstrap(false); &#125; public DubboApplicationListener(DubboBootstrap dubboBootstrap) &#123; this.dubboBootstrap = dubboBootstrap; &#125; /** * ç›‘å¬springäº‹ä»¶ * @param applicationEvent */ @Override public void onApplicationEvent(ApplicationEvent applicationEvent) &#123; // springå®¹å™¨åˆ·æ–°å®Œæˆ if (applicationEvent instanceof ContextRefreshedEvent) &#123; dubboBootstrap.start(); // springå®¹å™¨é”€æ¯ &#125; else if (applicationEvent instanceof ContextClosedEvent) &#123; dubboBootstrap.stop(); &#125; &#125;&#125; DubboBootstrap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * A bootstrap class to easily start and stop Dubbo via programmatic API. * The bootstrap class will be responsible to cleanup the resources during stop. */public class DubboBootstrap &#123; /** * æœåŠ¡é…ç½®å¯¹è±¡åˆ—è¡¨ */ private List&lt;ServiceConfig&gt; serviceConfigList; /** * å¯åŠ¨æœŸé—´æ˜¯å¦æ³¨å†Œ é’©å­ */ private final boolean registerShutdownHookOnStart; /** * åœ¨åµŒå…¥å¼ç¯å¢ƒä¸‹[Mainæ–¹æ³•]è¿è¡ŒDubboæ—¶ä½¿ç”¨çš„ é’©å­ */ private DubboShutdownHook shutdownHook; public DubboBootstrap() &#123; // è·å–DubboShutdownHookï¼Œå¹¶æ³¨å…¥åˆ°è¯¥ç±»ä¸­ this(true, DubboShutdownHook.getDubboShutdownHook()); &#125; public DubboBootstrap(boolean registerShutdownHookOnStart) &#123; // è·å–DubboShutdownHookï¼Œå¹¶æ³¨å…¥åˆ°è¯¥ç±»ä¸­ this(registerShutdownHookOnStart, DubboShutdownHook.getDubboShutdownHook()); &#125; public DubboBootstrap(boolean registerShutdownHookOnStart, DubboShutdownHook shutdownHook) &#123; this.serviceConfigList = new ArrayList&lt;ServiceConfig&gt;(); this.shutdownHook = shutdownHook; this.registerShutdownHookOnStart = registerShutdownHookOnStart; &#125; /** * Register service config to bootstrap, which will be called during &#123;@link DubboBootstrap#stop()&#125; * @param serviceConfig the service * @return the bootstrap instance */ public DubboBootstrap registerServiceConfig(ServiceConfig serviceConfig) &#123; serviceConfigList.add(serviceConfig); return this; &#125; /** * dubboå¼•å¯¼ç¨‹åº - start * 1 æ˜¯å¦æ³¨å†Œshutdown hook * 2 æœåŠ¡æš´éœ² */ public void start() &#123; // å¯åŠ¨æœŸé—´æ˜¯å¦æ³¨å†Œè¿‡shutdown hook if (registerShutdownHookOnStart) &#123; registerShutdownHook(); &#125; else &#123; // å¦‚æœDubboShutdown hook å·²ç»æ³¨å†Œåˆ°ç³»ç»Ÿä¸­ï¼Œéœ€è¦ç§»é™¤æ‰ removeShutdownHook(); &#125; // å¾ªç¯æœåŠ¡é…ç½®å¯¹è±¡ï¼Œä¾æ¬¡è¿›è¡ŒæœåŠ¡æš´éœ² for (ServiceConfig serviceConfig: serviceConfigList) &#123; serviceConfig.export(); &#125; &#125; /** * dubboå¼•å¯¼ç¨‹åº - stop * 1 å–æ¶ˆæœåŠ¡æš´éœ² * 2 */ public void stop() &#123; for (ServiceConfig serviceConfig: serviceConfigList) &#123; serviceConfig.unexport(); &#125; // æ‰§è¡Œ shutdown hook é‡Šæ”¾èµ„æº shutdownHook.destroyAll(); // å¦‚æœå¯åŠ¨æœŸå·²ç»æ³¨å†Œè¿‡ï¼Œåˆ™ä»ç³»ç»Ÿä¸­ç§»é™¤ todo ??? ä¸ºä»€ä¹ˆè¿˜è¦æ³¨å†Œåˆ°ç³»ç»Ÿï¼Œç›´æ¥æ ¹æ®springé”€æ¯äº‹ä»¶ç„¶åæ‰§è¡Œé‡Šæ”¾ä»»åŠ¡ä¸å°±å¯ä»¥äº†å—ï¼Ÿ if (registerShutdownHookOnStart) &#123; removeShutdownHook(); &#125; &#125; /** * æ³¨å†Œ shutdown hook */ public void registerShutdownHook() &#123; Runtime.getRuntime().addShutdownHook(shutdownHook); &#125; /** * ç§»é™¤ shutdown hook */ public void removeShutdownHook() &#123; try &#123; Runtime.getRuntime().removeShutdownHook(shutdownHook); &#125; catch (IllegalStateException ex) &#123; // ignore - VM is already shutting down &#125; &#125;&#125; DubboShutdownHook123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * The shutdown hook thread to do the clean up stuff. * This is a singleton in order to ensure there is only one shutdown hook registered. * Because &#123;@link ApplicationShutdownHooks&#125; use &#123;@link java.util.IdentityHashMap&#125; * to store the shutdown hooks. */public class DubboShutdownHook extends Thread &#123; private static final Logger logger = LoggerFactory.getLogger(DubboShutdownHook.class); /** * ShutdownHook,ç±»å±æ€§ */ private static final DubboShutdownHook dubboShutdownHook = new DubboShutdownHook(\"DubboShutdownHook\"); public static DubboShutdownHook getDubboShutdownHook() &#123; return dubboShutdownHook; &#125; /** * Has it already been destroyed or not? * &lt;p&gt; * æ˜¯å¦å·²ç»è¢«é”€æ¯æ ‡è¯† */ private final AtomicBoolean destroyed; private DubboShutdownHook(String name) &#123; super(name); this.destroyed = new AtomicBoolean(false); &#125; /** * ShutdownHookçš„ä»»åŠ¡ä½“ */ @Override public void run() &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Run shutdown hook now.\"); &#125; destroyAll(); &#125; /** * Destroy all the resources, including registries and protocols. * &lt;p&gt; * é”€æ¯æ‰€æœ‰çš„èµ„æºï¼ŒåŒ…æ‹¬ Registryç›¸å…³ å’Œ Protocolç›¸å…³ */ public void destroyAll() &#123; //å¦‚æœå·²ç»é”€æ¯åˆ™å¿½ç•¥ if (!destroyed.compareAndSet(false, true)) &#123; return; &#125; // é”€æ¯æ‰€æœ‰çš„ Registry,å–æ¶ˆåº”ç”¨ç¨‹åºä¸­çš„æœåŠ¡æä¾›è€…å’Œæ¶ˆè´¹è€…çš„è®¢é˜…ä¸æ³¨å†Œ AbstractRegistryFactory.destroyAll(); /** * é”€æ¯æ‰€æœ‰çš„ Protocol * * è¯´æ˜ï¼š * è¿™é‡Œçš„Protocolæ¯”è¾ƒå¤šï¼Œå¤§ä½“ä¸Šå¯ä»¥åˆ†ä¸¤ç±»ï¼š * 1 å’ŒRegistryç›¸å…³çš„Protocolï¼ŒRegistryProtocolå…³æ³¨æœåŠ¡çš„æ³¨å†Œ * 2 å…·ä½“åè®®ï¼Œå¦‚ DubboProtocolã€httpProtocolç­‰,å…³æ³¨æœåŠ¡çš„æš´éœ²å’Œå¼•ç”¨ */ ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol.class); for (String protocolName : loader.getLoadedExtensions()) &#123; try &#123; Protocol protocol = loader.getLoadedExtension(protocolName); if (protocol != null) &#123; protocol.destroy(); &#125; &#125; catch (Throwable t) &#123; logger.warn(t.getMessage(), t); &#125; &#125; &#125;&#125; LogbackContainer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * LogbackContainer. (SPI, Singleton, ThreadSafe) * å®ç° Container æ¥å£ï¼ŒLogback å®¹å™¨å®ç°ç±» */public class LogbackContainer implements Container &#123; /** * æ—¥å¿—æ–‡ä»¶è·¯å¾„ */ public static final String LOGBACK_FILE = \"dubbo.logback.file\"; /** * æ—¥å¿—æ–‡ä»¶çº§åˆ« */ public static final String LOGBACK_LEVEL = \"dubbo.logback.level\"; /** * æ—¥å¿—ä¿ç•™å¤©æ•° */ public static final String LOGBACK_MAX_HISTORY = \"dubbo.logback.maxhistory\"; /** * é»˜è®¤æ—¥å¿—çº§åˆ« */ public static final String DEFAULT_LOGBACK_LEVEL = \"ERROR\"; @Override public void start() &#123; // è·å¾— logback é…ç½®çš„æ—¥å¿—æ–‡ä»¶è·¯å¾„ String file = ConfigUtils.getProperty(LOGBACK_FILE); if (file != null &amp;&amp; file.length() &gt; 0) &#123; // è·å¾—æ—¥å¿—çº§åˆ« String level = ConfigUtils.getProperty(LOGBACK_LEVEL); if (level == null || level.length() == 0) &#123; level = DEFAULT_LOGBACK_LEVEL; &#125; // è·å¾—æ—¥å¿—ä¿ç•™å¤©æ•°ï¼Œå¦‚æœæ˜¯0åˆ™æ°¸ä¹…ä¿ç•™ int maxHistory = StringUtils.parseInteger(ConfigUtils.getProperty(LOGBACK_MAX_HISTORY)); // åˆå§‹åŒ– logback doInitializer(file, level, maxHistory); &#125; &#125; /** * åœæ­¢ä¸ºç©ºï¼Œå› ä¸ºä¸éœ€è¦å…³é—­ */ @Override public void stop() &#123; &#125; /** * åˆå§‹åŒ– logback * * @param file æ—¥å¿—æ–‡ä»¶è·¯å¾„ * @param level æ—¥å¿—çº§åˆ« * @param maxHistory æ—¥å¿—ä¿ç•™å¤©æ•° */ private void doInitializer(String file, String level, int maxHistory) &#123; // è·å–æ—¥å¿—å·¥å‚ LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory(); // é€šè¿‡å·¥å‚è·å–Logger Logger rootLogger = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME); rootLogger.detachAndStopAllAppenders(); // åˆ›å»ºæ—¥å¿—è¿½åŠ å™¨ RollingFileAppender&lt;ILoggingEvent&gt; fileAppender = new RollingFileAppender&lt;ILoggingEvent&gt;(); fileAppender.setContext(loggerContext); fileAppender.setName(\"application\"); fileAppender.setFile(file); fileAppender.setAppend(true); // åˆ›å»ºæ»šåŠ¨ç­–ç•¥ TimeBasedRollingPolicy&lt;ILoggingEvent&gt; policy = new TimeBasedRollingPolicy&lt;ILoggingEvent&gt;(); policy.setContext(loggerContext); policy.setMaxHistory(maxHistory); policy.setFileNamePattern(file + \".%d&#123;yyyy-MM-dd&#125;\"); policy.setParent(fileAppender); policy.start(); fileAppender.setRollingPolicy(policy); // æ ¼å¼ PatternLayoutEncoder encoder = new PatternLayoutEncoder(); encoder.setContext(loggerContext); encoder.setPattern(\"%date [%thread] %-5level %logger (%file:%line\\\\) - %msg%n\"); encoder.start(); fileAppender.setEncoder(encoder); fileAppender.start(); rootLogger.addAppender(fileAppender); rootLogger.setLevel(Level.toLevel(level)); rootLogger.setAdditive(false); &#125;&#125; Log4jContainer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * Log4jContainer. (SPI, Singleton, ThreadSafe) * å®ç°Containeræ¥å£ï¼ŒLog4jå®¹å™¨å®ç°ç±» */public class Log4jContainer implements Container &#123; /** * æ—¥å¿—æ–‡ä»¶è·¯å¾„é…ç½®ï¼Œå¦‚ dubbo.log4j.file=/opt/log/access.log */ public static final String LOG4J_FILE = \"dubbo.log4j.file\"; /** * æ—¥å¿—çº§åˆ« å¦‚ï¼š dubbo.log4j.level=WARN */ public static final String LOG4J_LEVEL = \"dubbo.log4j.level\"; /** * æ—¥å¿—å­è·¯å¾„é…ç½® */ public static final String LOG4J_SUBDIRECTORY = \"dubbo.log4j.subdirectory\"; /** * é»˜è®¤æ—¥å¿—çº§åˆ« */ public static final String DEFAULT_LOG4J_LEVEL = \"ERROR\"; /** * è‡ªåŠ¨é…ç½®log4j */ @Override @SuppressWarnings(\"unchecked\") public void start() &#123; // è·å¾— log4j é…ç½®çš„æ—¥å¿—æ–‡ä»¶è·¯å¾„ String file = ConfigUtils.getProperty(LOG4J_FILE); // è·å–æ—¥å¿—çº§åˆ« if (file != null &amp;&amp; file.length() &gt; 0) &#123; String level = ConfigUtils.getProperty(LOG4J_LEVEL); if (level == null || level.length() == 0) &#123; level = DEFAULT_LOG4J_LEVEL; &#125; // åˆ›å»ºPropertyConfiguratoræ‰€éœ€çš„ Properties å¯¹è±¡ï¼Œ Properties properties = new Properties(); properties.setProperty(\"log4j.rootLogger\", level + \",application\"); properties.setProperty(\"log4j.appender.application\", \"org.apache.log4j.DailyRollingFileAppender\"); properties.setProperty(\"log4j.appender.application.File\", file); properties.setProperty(\"log4j.appender.application.Append\", \"true\"); properties.setProperty(\"log4j.appender.application.DatePattern\", \"'.'yyyy-MM-dd\"); properties.setProperty(\"log4j.appender.application.layout\", \"org.apache.log4j.PatternLayout\"); properties.setProperty(\"log4j.appender.application.layout.ConversionPattern\", \"%d [%t] %-5p %C&#123;6&#125; (%F:%L) - %m%n\"); PropertyConfigurator.configure(properties); &#125; // è·å¾—æ—¥å¿—å­ç›®å½•ï¼Œç”¨äºå¤šè¿›ç¨‹å¯åŠ¨æ—¶ï¼Œé¿å…å†²çª String subdirectory = ConfigUtils.getProperty(LOG4J_SUBDIRECTORY); if (subdirectory != null &amp;&amp; subdirectory.length() &gt; 0) &#123; // è·å– Logger åˆ—è¡¨ Enumeration&lt;org.apache.log4j.Logger&gt; ls = LogManager.getCurrentLoggers(); while (ls.hasMoreElements()) &#123; org.apache.log4j.Logger l = ls.nextElement(); if (l != null) &#123; // æ‹¿åˆ°å½“å‰Logger çš„è¿½åŠ å™¨ Enumeration&lt;Appender&gt; as = l.getAllAppenders(); while (as.hasMoreElements()) &#123; Appender a = as.nextElement(); if (a instanceof FileAppender) &#123; FileAppender fa = (FileAppender) a; String f = fa.getFile(); if (f != null &amp;&amp; f.length() &gt; 0) &#123; int i = f.replace('\\\\', '/').lastIndexOf('/'); String path; if (i == -1) &#123; path = subdirectory; &#125; else &#123; path = f.substring(0, i); if (!path.endsWith(subdirectory)) &#123; path = path + \"/\" + subdirectory; &#125; f = f.substring(i + 1); &#125; // è®¾ç½®æ–°çš„æ–‡ä»¶å fa.setFile(path + \"/\" + f); // ç”Ÿæ•ˆé…ç½® fa.activateOptions(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; /** * ç©ºæ–¹æ³•ï¼Œæ— éœ€å…³é—­ */ @Override public void stop() &#123; &#125;&#125; å®¹å™¨å¯åŠ¨ é€šè¿‡åŠ è½½propertiesé…ç½®æ–‡ä»¶åŠ è½½ç›®æ ‡å®¹å™¨ 1dubbo.container&#x3D;spring,logback,log4j ç¼ºçœåªåŠ è½½springå®¹å™¨ 1java org.apache.dubbo.container.Main é€šè¿‡mainæ–¹æ³•å‚æ•°ä¼ å…¥è¦åŠ è½½çš„å®¹å™¨ 1java org.apache.dubbo.container.Main spring logback log4j é€šè¿‡ JVM å¯åŠ¨å‚æ•°ä¼ å…¥è¦åŠ è½½çš„å®¹å™¨ 1java org.apache.dubbo.container.Main -Ddubbo.container&#x3D;spring,jetty,log4j å°ç»“è™½ç„¶å®é™…ç”Ÿäº§ä¸­ä¸€èˆ¬ä¸ä¼šç›´æ¥ä½¿ç”¨dubboçš„æœåŠ¡å®¹å™¨ï¼Œä½†æ˜¯å®ƒçš„å®ç°æœºåˆ¶æˆ‘ä»¬å¯ä»¥å­¦ä¹ ä¸‹ã€‚äº†è§£äº†DubboæœåŠ¡å®¹å™¨åï¼Œæˆ‘ä»¬ä»æºç å±‚é¢ä¸Šé‡æ–°è®¤è¯†äº†Dubboçš„å¯åœæµç¨‹ï¼Œä»ä¸‹ä¸€ç¯‡æ–‡ç« å¼€å§‹æ­£å¼è¿›å…¥åˆ°Dubboçš„æ ¸å¿ƒæ¨¡å—æºç åˆ†æé˜¶æ®µã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"Spring","slug":"Spring","permalink":"https://gentryhuang.com/tags/Spring/"}]},{"title":"Dubboæºç åˆ†æ - æ³¨è§£é…ç½®","slug":"rpc/æ³¨è§£é…ç½®","date":"2020-04-01T16:00:00.000Z","updated":"2020-09-04T07:15:55.737Z","comments":false,"path":"posts/1a889dcd/","link":"","permalink":"https://gentryhuang.com/posts/1a889dcd/","excerpt":"","text":"å‰è¨€åœ¨ Dubboæºç åˆ†æ - XMLé…ç½® ä¸­ï¼Œè¯¦ç»†ä»‹ç»äº†Dubboçš„XMLé…ç½®æ–¹å¼ï¼Œæœ¬ç¯‡æ–‡ç« ä»‹ç»Dubboæ³¨è§£é…ç½®æ–¹å¼ï¼Œä½¿ç”¨ç¤ºä¾‹è§ Dubboç¤ºä¾‹ - æ³¨è§£é…ç½®ã€‚ ç¤ºä¾‹è¯´æ˜1234567891011121314151617181920212223242526272829/** * AnnotationProvider * * Java Config + æ³¨è§£çš„æ–¹å¼ */public class AnnotationProvider &#123; public static void main(String[] args) throws Exception &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ProviderConfiguration.class); context.start(); System.in.read(); &#125; @Configuration @EnableDubbo(scanBasePackages = \"com.alibaba.dubbo.examples.annotation.impl\") @PropertySource(\"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-provider.properties\") static public class ProviderConfiguration &#123; /** * è¿™é‡Œé€šè¿‡Java Configæ˜¾ç¤ºç»„è£…Beanï¼Œä¼šæ³¨å…¥ç»™DubboæœåŠ¡ï¼Œå³æ ‡æ³¨æœ‰@Serviceçš„ç±»ã€‚å¦‚æœä¸æ˜¾ç¤ºè£…é…ï¼ŒDubboä¼šé»˜è®¤åˆ›å»ºå†…ç½®çš„é…ç½®ç±»å®šä¹‰ï¼Œåˆ›å»ºå†…ç½®çš„é…ç½®ç±»å®šä¹‰çš„å‰ææ˜¯é…ç½®äº†ç›¸å…³çš„å±æ€§ï¼Œå¦åˆ™ä¸ä¼šåˆ›å»ºã€‚å…¶ä»–é…ç½®ç±»ä¼¼ã€‚ */ @Bean public ProviderConfig providerConfig() &#123; ProviderConfig providerConfig = new ProviderConfig(); providerConfig.setTimeout(5000); return providerConfig; &#125; &#125;&#125; è¿™é‡Œä½¿ç”¨ Dubboç¤ºä¾‹ - æ³¨è§£é…ç½® ä¸­çš„æä¾›è€…é…ç½®è¿›è¡Œè¯´æ˜ã€‚å½“Springå¯åŠ¨åï¼Œä¼šå…ˆè·å–é…ç½®ç±»ä¸Šçš„ @PropertySource æ³¨è§£ï¼ŒæŠŠå¤–éƒ¨é…ç½®è¿›è¡Œè§£æç„¶åæ”¾å…¥Springç¯å¢ƒä¸­ï¼Œä¸ºä¹‹åæµç¨‹ä¸­çš„Dubboé…ç½®ç±»çš„å¯¹è±¡è¿›è¡Œå±æ€§èµ‹å€¼ã€‚Springä¼šé€’å½’è·å–é…ç½®ç±»çš„ @Import æ³¨è§£ï¼Œå³æœé›†é…ç½®ç›¸å…³çš„æ‰€æœ‰@Importæ³¨è§£ï¼Œä»¥è·å–ä½¿ç”¨è¯¥æ³¨è§£å¼•å…¥çš„Selectoræˆ–Registrarç±»ï¼Œè¿™äº›ç±»æ˜¯ç”¨æ¥ç»™Springå®¹å™¨å¯¼å…¥ç»„ä»¶çš„ã€‚Dubboçš„æ³¨è§£å®ç°åŒ…æ‹¬ä¸¤å¤§éƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯å¤–éƒ¨åŒ–é…ç½®ï¼Œå¦ä¸€ä¸ªæ˜¯æ³¨è§£é©±åŠ¨ï¼Œå®ƒä»¬çš„èƒ½åŠ›æ˜¯ç”±Selectoræˆ–Registrarç±»å¯¼å…¥æ‰€éœ€ç»„ä»¶å®ç°çš„ï¼Œç¬”è€…è°ƒè¯•è¿™å—èŠ±äº†å¾ˆå¤šæ—¶é—´ï¼Œç»†èŠ‚ç‚¹è¿˜æ˜¯æŒºå¤šçš„ï¼Œç”±äºè¿™äº›éƒ½æ˜¯Springæºç çš„çŸ¥è¯†ç‚¹å°±ä¸è¿›è¡Œåˆ†æäº†ã€‚ æ³¨è§£é…ç½®ä»£ç ç»“æ„ åœ¨ Dubbo 2.5.7ä¹‹å‰çš„ç‰ˆæœ¬ ï¼ŒDubbo æä¾›äº†ä¸¤ä¸ªæ ¸å¿ƒæ³¨è§£ @Service ä»¥åŠ @Referenceï¼Œåˆ†åˆ«ç”¨äºDubbo æœåŠ¡æä¾›å’Œ Dubbo æœåŠ¡å¼•ç”¨ã€‚@Service ä½œä¸º XMLé…ç½®&lt;dubbo:service&gt;çš„æ›¿ä»£ï¼Œä¸ Spring Framework @Service ç±»ä¼¼ï¼Œç”¨äºæœåŠ¡æš´éœ²ã€‚@Reference åˆ™æ˜¯æ›¿ä»£&lt;dubbo:reference &gt; ï¼Œç±»ä¼¼äº Spring ä¸­çš„ @Autowiredï¼Œå¼•ç”¨æœåŠ¡ã€‚ä½†2.5.7ä¹‹å‰Dubboæ³¨è§£æ˜¯åŸºäºAnnotationBeanå®ç°çš„ï¼Œä¸»è¦å­˜åœ¨ä»¥ä¸‹å‡ ä¸ªé—®é¢˜ï¼š æ³¨è§£æ”¯æŒä¸å……åˆ†ï¼Œéœ€è¦XMLé…ç½®&lt;dubbo:annotation&gt; @Service ä¸æ”¯æŒSpring AOP @Reference ä¸æ”¯æŒå­—æ®µç»§æ‰¿æ€§ åŸºäºåŸæ¥å®ç°æ€è·¯çš„åŸºç¡€ä¸Šæ— æ³•è§£å†³å†å²é—ç•™é—®é¢˜ï¼Œä»2.5.7å¼€å§‹Dubboçš„æ³¨è§£å®ç°å·²ç»å®Œå…¨é‡å†™ï¼ŒAnnotationBeanå·²ç»è¢«åºŸå¼ƒã€‚ è®¾è®¡åŸåˆ™Spring Framework 3.1 å¼•å…¥äº† @ComponentScan å®Œå…¨æ›¿ä»£äº† XML å…ƒç´  &lt;context:component-scan&gt; ã€‚åŒæ ·åœ°ï¼Œ @DubboComponentScan ä½œä¸º Dubbo 2.5.7 æ–°å¢çš„ Annotationï¼Œä¹Ÿæ˜¯XML å…ƒç´  &lt;dubbo:annotation&gt; çš„æ›¿ä»£æ–¹æ¡ˆï¼Œä¸æ³¨è§£é©±åŠ¨ç›¸å…³ã€‚ @DubboComponentScan ç›¸å¯¹æ¯”è¾ƒç¹é‡ï¼ŒåŸå› åœ¨äºå¤„ç†Dubbo @Service æ ‡æ³¨çš„ç±»æš´éœ²DubboæœåŠ¡å¤–ï¼Œè¿˜è¦æ”¯æŒSpring Beançš„ @Reference å­—æ®µæˆ–æ–¹æ³•æ³¨å…¥DubboæœåŠ¡ä»£ç†ï¼Œå³ @DubboComponentScan é™¤äº†æ‰«æ Dubbo @Service ç»„ä»¶ä»¥å¤–ï¼Œè¿˜éœ€è¦å¤„ç† @Referenceæ³¨å…¥ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœ @Reference å­—æ®µæˆ–æ–¹æ³•æ‰€åœ¨çš„ç±»ä¸æ˜¯ Spring Bean çš„è¯ï¼Œ @DubboComponentScan ä¸ä¼šå¤„ç† @Reference æ³¨å…¥ï¼Œå…¶åŸç†ä¸ Spring @Autowired ä¸€è‡´ã€‚@EnableDubboConfig ç”¨äºæ”¯æŒDubboçš„å¤–éƒ¨åŒ–é…ç½®ï¼Œå¸¸ç”¨äºæ˜¾ç¤ºæŒ‡å®šDubboçš„é…ç½®ã€‚éœ€è¦æ³¨æ„çš„æ˜¯Dubboæ¡†æ¶ä¸­çš„dubbo.propertiesä»æŸç§æ„ä¹‰ä¸Šæ¥è¯´æ˜¯ç‰¹æ®Šçš„Dubboçš„å¤–éƒ¨åŒ–é…ç½®ï¼Œæ¡†æ¶é»˜è®¤æƒ…å†µä¸‹ä¼šåŠ è½½ç±»è·¯å¾„ä¸‹çš„è¯¥é…ç½®æ–‡ä»¶ï¼Œè¯¦ç»†å‚è§ å±æ€§é…ç½®ã€‚ æ³¨è§£ä»‹ç»@Service æ³¨è§£@Service ç”¨æ¥é…ç½®Dubboçš„æœåŠ¡æä¾›æ–¹ï¼Œé€šè¿‡ @Service ä¸Šæä¾›çš„å±æ€§ï¼Œå¯ä»¥è¿›ä¸€æ­¥çš„å®šåˆ¶åŒ– Dubbo çš„æœåŠ¡æä¾›è€…ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Inheritedpublic @interface Service &#123; Class&lt;?&gt; interfaceClass() default void.class; String interfaceName() default \"\"; String version() default \"\"; String group() default \"\"; String path() default \"\"; boolean export() default false; String token() default \"\"; boolean deprecated() default false; boolean dynamic() default false; String accesslog() default \"\"; int executes() default 0; boolean register() default true; int weight() default 0; String document() default \"\"; int delay() default 0; String local() default \"\"; String stub() default \"\"; String cluster() default \"\"; String proxy() default \"\"; int connections() default 0; int callbacks() default 0; String onconnect() default \"\"; String ondisconnect() default \"\"; String owner() default \"\"; String layer() default \"\"; int retries() default 0; String loadbalance() default \"\"; boolean async() default false; int actives() default 0; boolean sent() default false; String mock() default \"\"; String validation() default \"\"; int timeout() default 0; String cache() default \"\"; String[] filter() default &#123;&#125;; String[] listener() default &#123;&#125;; String[] parameters() default &#123;&#125;; String application() default \"\"; String module() default \"\"; String provider() default \"\"; String[] protocol() default &#123;&#125;; String monitor() default \"\"; String[] registry() default &#123;&#125;;&#125; @Serviceå®šä¹‰åœ¨ä¸€ä¸ªç±»ä¸Šï¼Œè¡¨ç¤ºä¸€ä¸ªæœåŠ¡çš„å…·ä½“å®ç°ï¼Œæ¯”è¾ƒé‡è¦çš„å±æ€§ï¼š interfaceClassï¼šæŒ‡å®šæœåŠ¡æä¾›æ–¹å®ç°çš„ interface çš„ç±» interfaceNameï¼šæŒ‡å®šæœåŠ¡æä¾›æ–¹å®ç°çš„ interface çš„ç±»å versionï¼šæŒ‡å®šæœåŠ¡çš„ç‰ˆæœ¬å· groupï¼šæŒ‡å®šæœåŠ¡çš„åˆ†ç»„ exportï¼šæ˜¯å¦æš´éœ²æœåŠ¡ registryï¼šæ˜¯å¦å‘æ³¨å†Œä¸­å¿ƒæ³¨å†ŒæœåŠ¡ applicationï¼šåº”ç”¨é…ç½® moduleï¼šæ¨¡å—é…ç½® providerï¼šæœåŠ¡æä¾›æ–¹é…ç½® protocolï¼šåè®®é…ç½® monitorï¼šç›‘æ§ä¸­å¿ƒé…ç½® registryï¼šæ³¨å†Œä¸­å¿ƒé…ç½® å…¶ä¸­ï¼Œapplicationã€moduleã€providerã€protocolã€monitorã€registryå±æ€§éœ€è¦æä¾›çš„æ˜¯å¯¹åº”çš„Spring Beançš„åå­—ï¼ŒBeanç»„è£…æ–¹å¼å¯ä»¥é€šè¿‡XMLé…ç½®ï¼Œä¹Ÿå¯ä»¥é€šè¿‡Java Configé…ç½®ã€‚ @Reference æ³¨è§£@Reference ç”¨æ¥é…ç½®Dubboçš„æœåŠ¡æ¶ˆè´¹æ–¹ï¼Œé€šè¿‡ @Reference ä¸Šæä¾›çš„å±æ€§ï¼Œå¯ä»¥è¿›ä¸€æ­¥çš„å®šåˆ¶åŒ– Dubbo çš„æœåŠ¡æ¶ˆè´¹æ–¹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Reference * * @export */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)public @interface Reference &#123; Class&lt;?&gt; interfaceClass() default void.class; String interfaceName() default \"\"; String version() default \"\"; String group() default \"\"; String url() default \"\"; String client() default \"\"; boolean generic() default false; boolean injvm() default false; boolean check() default true; boolean init() default false; boolean lazy() default false; boolean stubevent() default false; String reconnect() default \"\"; boolean sticky() default false; String proxy() default \"\"; String stub() default \"\"; String cluster() default \"\"; int connections() default 0; int callbacks() default 0; String onconnect() default \"\"; String ondisconnect() default \"\"; String owner() default \"\"; String layer() default \"\"; int retries() default 2; String loadbalance() default \"\"; boolean async() default false; int actives() default 0; boolean sent() default false; String mock() default \"\"; String validation() default \"\"; int timeout() default 0; String cache() default \"\"; String[] filter() default &#123;&#125;; String[] listener() default &#123;&#125;; String[] parameters() default &#123;&#125;; String application() default \"\"; String module() default \"\"; String consumer() default \"\"; String monitor() default \"\"; String[] registry() default &#123;&#125;;&#125; @Reference å¯ä»¥å®šä¹‰åœ¨ç±»ä¸­çš„ä¸€ä¸ªå­—æ®µä¸Šï¼Œä¹Ÿå¯ä»¥å®šä¹‰åœ¨ä¸€ä¸ªæ–¹æ³•ä¸Šï¼Œç”šè‡³å¯ä»¥ç”¨æ¥ä¿®é¥°å¦ä¸€ä¸ª annotationï¼Œè¡¨ç¤ºä¸€ä¸ªæœåŠ¡å¼•ç”¨ã€‚ä¸€èˆ¬å¤šæŠŠ@Reference å®šä¹‰åœ¨ä¸€ä¸ªå­—æ®µä¸Šï¼Œè¯¥æ³¨è§£æœ‰ä»¥ä¸‹é‡è¦å±æ€§ï¼š interfaceClassï¼šæŒ‡å®šæœåŠ¡çš„ interface çš„ç±» interfaceNameï¼šæŒ‡å®šæœåŠ¡çš„ interface çš„ç±»å versionï¼šæŒ‡å®šæœåŠ¡çš„ç‰ˆæœ¬å· groupï¼šæŒ‡å®šæœåŠ¡çš„åˆ†ç»„ urlï¼šé€šè¿‡æŒ‡å®šæœåŠ¡æä¾›æ–¹çš„ URL åœ°å€ç›´æ¥ç»•è¿‡æ³¨å†Œä¸­å¿ƒå‘èµ·è°ƒç”¨ applicationï¼šåº”ç”¨é…ç½® moduleï¼šæ¨¡å—é…ç½® consumerï¼šæœåŠ¡æ¶ˆè´¹æ–¹é…ç½® protocolï¼šåè®®é…ç½® monitorï¼šç›‘æ§ä¸­å¿ƒé…ç½® registryï¼šæ³¨å†Œä¸­å¿ƒé…ç½® å…¶ä¸­ï¼Œapplicationã€moduleã€consumerã€protocolã€monitorã€registryå±æ€§éœ€è¦æä¾›çš„æ˜¯å¯¹åº”çš„Spring Beançš„åå­—ï¼ŒBeanç»„è£…æ–¹å¼å¯ä»¥é€šè¿‡XMLé…ç½®ï¼Œä¹Ÿå¯ä»¥é€šè¿‡Java Configé…ç½®ã€‚ @EnableDubbo æ³¨è§£@EnableDubbo æ³¨è§£æ˜¯ @EnableDubboConfig å’Œ @DubboComponentScan ä¸¤è€…ç»„åˆçš„ä¾¿æ·è¡¨è¾¾æ–¹å¼ã€‚ä¸æ³¨è§£é©±åŠ¨ç›¸å…³çš„æ˜¯ @DubboComponentScanï¼Œä¸å¤–éƒ¨åŒ–é…ç½®ç›¸å…³çš„æ˜¯ @EnableDubboConfig ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented@EnableDubboConfig // å¼€å¯Dubbo Config ã€DubboConfigå¯¹è±¡çš„åˆ›å»ºå’ŒDubboConfigä¸­çš„å±æ€§è®¾ç½®ã€‘@DubboComponentScan // æ‰«æDubbo çš„@Service å’Œ @Reference æ³¨è§£çš„åŒ…æˆ–è€…ç±»ï¼Œä»è€Œåˆ›å»ºBeanå¯¹è±¡public @interface EnableDubbo &#123; /** * * é…ç½®@DubboComponentScan æ³¨è§£ æ‰«æçš„åŒ… * * Base packages to scan for annotated @Service classes. * &lt;p&gt; * Use &#123;@link #scanBasePackageClasses()&#125; for a type-safe alternative to String-based * package names. * * @return the base packages to scan * @see DubboComponentScan#basePackages() */ @AliasFor(annotation = DubboComponentScan.class, attribute = \"basePackages\") String[] scanBasePackages() default &#123;&#125;; /** * * é…ç½® @DubboComponentScan æ³¨è§£ æ‰«æçš„ç±» * * Type-safe alternative to &#123;@link #scanBasePackages()&#125; for specifying the packages to * scan for annotated @Service classes. The package of each class specified will be * scanned. * * @return classes from the base packages to scan * @see DubboComponentScan#basePackageClasses */ @AliasFor(annotation = DubboComponentScan.class, attribute = \"basePackageClasses\") Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;; /** * é…ç½® @EnableDubboConfig æ³¨è§£ï¼Œæ˜¯å¦å°†é…ç½®å±æ€§ç»‘å®šåˆ°å¤šä¸ªSpring Bean ä¸Š * * It indicates whether &#123;@link AbstractConfig&#125; binding to multiple Spring Beans. * * @return the default value is &lt;code&gt;false&lt;/code&gt; * @see EnableDubboConfig#multiple() */ @AliasFor(annotation = EnableDubboConfig.class, attribute = \"multiple\") boolean multipleConfig() default false;&#125; @EnableDubbo å¯ä»¥é€šè¿‡ scanBasePackageså±æ€§ æŒ‡å®šè¦æ‰«æçš„åŒ…ï¼Œé€šè¿‡ scanBasePackageClasseså±æ€§ æŒ‡å®šè¦æ‰«æçš„ç±»[æœ€åè¿˜æ˜¯ä¼šè½¬ä¸ºæ‰«æåŒ…çš„æ–¹å¼]ï¼Œè¿›è€Œæ‰«æDubbo çš„æœåŠ¡æä¾›è€…ï¼ˆä»¥ @Service æ ‡æ³¨ï¼‰ä»¥åŠ Dubbo çš„æœåŠ¡æ¶ˆè´¹è€…ï¼ˆä»¥ Reference æ ‡æ³¨ï¼‰ã€‚æ‰«æåˆ° Dubbo çš„æœåŠ¡æä¾›æ–¹å’Œæ¶ˆè´¹è€…ä¹‹åï¼Œå¯¹å…¶åšç›¸åº”çš„ç»„è£…å¹¶åˆå§‹åŒ–ï¼Œå¹¶æœ€ç»ˆå®ŒæˆæœåŠ¡æš´éœ²æˆ–è€…å¼•ç”¨çš„å·¥ä½œã€‚å¦‚æœä¸ä½¿ç”¨å¤–éƒ¨åŒ–é…ç½®çš„è¯ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ @DubboComponentScanã€‚ @EnableDubboConfig æ³¨è§£è¯¥æ³¨è§£ç”¨äºå¼€å¯Dubboé…ç½®ï¼Œæ”¯æŒå¤–éƒ¨åŒ–é…ç½®ã€‚ 1234567891011121314151617181920212223242526272829/** * As a convenient and multiple &#123;@link EnableDubboConfigBinding&#125; * * @see EnableDubboConfigBinding * @see DubboConfigConfiguration * @see DubboConfigConfigurationSelector * @since 2.5.8 * * å¼€å¯Dubboé…ç½® * */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented@Import(DubboConfigConfigurationSelector.class) public @interface EnableDubboConfig &#123; /** * é…ç½®æ˜¯å¦ç»‘å®šåˆ°å¤šä¸ªSpring Beanä¸Šï¼Œå³è¡¨ç¤ºæ˜¯å¦æ”¯æŒå¤šDubboé…ç½®Beançš„ç»‘å®šï¼Œé»˜è®¤å€¼ä¸ºfalseï¼Œå³å•Dubbo é…ç½®Beançš„ç»‘å®šã€‚ * * It indicates whether binding to multiple Spring Beans. * * @return the default value is &lt;code&gt;false&lt;/code&gt; * @revised 2.5.9 */ boolean multiple() default false;&#125; è¯¥æ³¨è§£æœ‰ä¸€ä¸ªæ ¸å¿ƒçš„å±æ€§ï¼Œmultiple å±æ€§ç”¨äºæ”¯æŒå¤šDubboé…ç½®Beançš„æ•°æ®ç»‘å®šã€‚@Import çš„valueå±æ€§å€¼ DubboConfigConfigurationSelector ç”¨äºç»™Springå®¹å™¨å¯¼å…¥ç»„ä»¶ï¼Œå¯¼å…¥çš„ç»„ä»¶æ˜¯ DubboConfigConfiguration.Single æˆ– DubboConfigConfiguration.Multipleï¼Œå…·ä½“å¯¼å…¥å“ªä¸ªç»„ä»¶å–å†³äº multiple çš„å€¼ã€‚ DubboConfigConfigurationSelector1234567891011121314151617181920212223242526272829303132public class DubboConfigConfigurationSelector implements ImportSelector, Ordered &#123; /** * @param importingClassMetadata @Import(DubboConfigConfigurationSelector.class) æ‰€æ ‡æ³¨çš„æ³¨è§£ä¿¡æ¯ * @return */ @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; // è·å¾— @EnableDubboConfigæ³¨è§£çš„å±æ€§ AnnotationAttributes attributes = AnnotationAttributes.fromMap( importingClassMetadata.getAnnotationAttributes(EnableDubboConfig.class.getName())); //è·å¾—multipleå±æ€§ boolean multiple = attributes.getBoolean(\"multiple\"); // å¦‚æœä¸ºtrueï¼Œåˆ™æ³¨å†Œ DubboConfigConfiguration.Multiple Beanå¯¹è±¡ if (multiple) &#123; return of(DubboConfigConfiguration.Multiple.class.getName()); &#125; else &#123; // å¦‚æœä¸ºfalseï¼Œåˆ™æ³¨å†Œ DubboConfigConfiguration.Single Beanå¯¹è±¡ return of(DubboConfigConfiguration.Single.class.getName()); &#125; &#125; private static &lt;T&gt; T[] of(T... values) &#123; return values; &#125; @Override public int getOrder() &#123; return HIGHEST_PRECEDENCE; &#125;&#125; è¯¥ç±»å®ç°äº†Springçš„ImportSelectoræ¥å£ï¼ŒåŠŸèƒ½å¦‚ä¸‹ï¼š åˆ©ç”¨ImportSelectorè¦å¯¼å…¥å“ªäº›ç»„ä»¶ï¼Œåªéœ€è¦è¿”å›è¦å¯¼å…¥ç»„ä»¶çš„å…¨é™å®šç±»åï¼Œå³ selectImportsæ–¹æ³•è¿”å›å€¼ã€‚ å¦‚æœselectImportsæ–¹æ³•è¿”å›å€¼å¯¹åº”çš„ç±»ï¼Œå®ƒé‡Œé¢æœ‰ä½¿ç”¨@Beanæ³¨è§£çš„æ–¹æ³•ï¼Œé‚£ä¹ˆæ­¤æ—¶ç»™å®¹å™¨ä¸­å¯¼å…¥çš„ä¸åªæœ‰å½“å‰è¿”å›å€¼å¯¹åº”ç±»çš„å®ä¾‹ï¼Œè¿˜æœ‰è¯¥ç±»å‹ä¸­åŠ äº†@Beanå¯¹åº”çš„å®ä¾‹ã€‚ ç»™å®¹å™¨å¯¼å…¥çš„ä¸æ˜¯ DubboConfigConfigurationSelectorï¼Œå› ä¸ºå®ƒå®ç°äº†ImportSelectoræ¥å£ï¼Œå¯¼å…¥çš„æ˜¯è¯¥ç±»çš„selectImportsæ–¹æ³•ä¸­è¿”å›çš„å€¼å¯¹åº”çš„ç±»ã€‚ é€šè¿‡ä»¥ä¸Šè§„åˆ™å¯ä»¥çŸ¥é“ï¼Œè¯¥ç±»å°±æ˜¯ç»™Springå®¹å™¨å¯¼å…¥ DubboConfigConfiguration.Single æˆ– DubboConfigConfiguration.Multiple ç»„ä»¶ã€‚å¯ä»¥çœ‹å‡ºå®ƒä»¬éƒ½æ˜¯ DubboConfigConfiguration ç±»çš„å†…éƒ¨ç±»ï¼Œä¸‹é¢æˆ‘ä»¬çœ‹ä¸‹è¯¥ç±»çš„å…·ä½“ä¿¡æ¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Dubbo &#123;@link AbstractConfig Config&#125; &#123;@link Configuration&#125; * * @see Configuration * @see EnableDubboConfigBindings * @see EnableDubboConfigBinding * @see ApplicationConfig * @see ModuleConfig * @see RegistryConfig * @see ProtocolConfig * @see MonitorConfig * @see ProviderConfig * @see ConsumerConfig * @since 2.5.8 */public class DubboConfigConfiguration &#123; /** * Single Dubbo &#123;@link AbstractConfig Config&#125; Bean Binding * @EnableDubboConfigBinding æ³¨è§£ prefix éƒ½æ˜¯å•æ•° */ @EnableDubboConfigBindings(&#123; @EnableDubboConfigBinding(prefix = \"dubbo.application\", type = ApplicationConfig.class), @EnableDubboConfigBinding(prefix = \"dubbo.module\", type = ModuleConfig.class), @EnableDubboConfigBinding(prefix = \"dubbo.registry\", type = RegistryConfig.class), @EnableDubboConfigBinding(prefix = \"dubbo.protocol\", type = ProtocolConfig.class), @EnableDubboConfigBinding(prefix = \"dubbo.monitor\", type = MonitorConfig.class), @EnableDubboConfigBinding(prefix = \"dubbo.provider\", type = ProviderConfig.class), @EnableDubboConfigBinding(prefix = \"dubbo.consumer\", type = ConsumerConfig.class) &#125;) public static class Single &#123; &#125; /** * Multiple Dubbo &#123;@link AbstractConfig Config&#125; Bean Binding * @EnableDubboConfigBinding æ³¨è§£ prefix éƒ½æ˜¯å¤æ•° */ @EnableDubboConfigBindings(&#123; @EnableDubboConfigBinding(prefix = \"dubbo.applications\", type = ApplicationConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = \"dubbo.modules\", type = ModuleConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = \"dubbo.registries\", type = RegistryConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = \"dubbo.protocols\", type = ProtocolConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = \"dubbo.monitors\", type = MonitorConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = \"dubbo.providers\", type = ProviderConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = \"dubbo.consumers\", type = ConsumerConfig.class, multiple = true) &#125;) public static class Multiple &#123; &#125;&#125; DubboConfigConfiguration ç±»ä¸­æ²¡æœ‰å±æ€§å’Œæ–¹æ³•ï¼Œåªæœ‰ä¸¤ä¸ªé™æ€å†…éƒ¨ç±»ï¼Œå…·ä½“å¯¼å…¥å“ªä¸ªç±»ä¸Šé¢å·²ç»ä»‹ç»è¿‡äº†ï¼Œä¸‹é¢æˆ‘ä»¬æ¥è¯¦ä»‹ç»ä¸‹ @EnableDubboConfigBindings å’Œ @EnableDubboConfigBinding æ³¨è§£ã€‚ @EnableDubboConfigBindings æ³¨è§£12345678910111213141516171819/** * Multiple &#123;@link EnableDubboConfigBinding&#125; &#123;@link Annotation&#125; * * @since 2.5.8 * @see EnableDubboConfigBinding */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(DubboConfigBindingsRegistrar.class) public @interface EnableDubboConfigBindings &#123; /** * The value of &#123;@link EnableDubboConfigBindings&#125; * * @return non-null */ EnableDubboConfigBinding[] value();&#125; è¯¥æ³¨è§£æœ‰ä¸€ä¸ªvalueå±æ€§ï¼Œç±»å‹æ˜¯ EnableDubboConfigBinding[] ï¼Œå³ @EnableDubboConfigBinding æ•°ç»„ã€‚è¯¥æ³¨è§£ä¸Šä½¿ç”¨ @Import æ³¨è§£ï¼Œä½¿ç”¨DubboConfigBindingsRegistrar ç±»ç»™Springå®¹å™¨å¯¼å…¥ç»„ä»¶ï¼Œä¸‹é¢æˆ‘ä»¬ç»§ç»­è·Ÿè¿›ï¼Œçœ‹ä¸‹å…·ä½“å¯¼å…¥å“ªäº›ç»„ä»¶ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * &#123;@link AbstractConfig Dubbo Config&#125; binding Bean registrar for &#123;@link EnableDubboConfigBindings&#125; * * @see EnableDubboConfigBindings * @see DubboConfigBindingRegistrar * @since 2.5.8 */public class DubboConfigBindingsRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; private ConfigurableEnvironment environment; /** * * @param importingClassMetadata æ ‡æ³¨ç±»æ³¨è§£ä¿¡æ¯ * @param registry Beanå®šä¹‰æ³¨å†Œè¡¨ */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; /** * è·å¾— EnableDubboConfigBindings æ³¨è§£ */ AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings.class.getName())); // è·å¾—EnableDubboConfigBindings æ³¨è§£çš„value å±æ€§å€¼ï¼ˆè¿™é‡Œæ˜¯ EnableDubboConfigBinding æ³¨è§£æ•°ç»„ï¼‰ AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray(\"value\"); // åˆ›å»ºDubboConfigBindignRegistrar å¯¹è±¡ï¼Œå¹¶è®¾ç½®ç¯å¢ƒå˜é‡ DubboConfigBindingRegistrar registrar = new DubboConfigBindingRegistrar(); registrar.setEnvironment(environment); // ä¾æ¬¡éå† EnableDubboConfigBinding æ³¨è§£é›†åˆï¼Œè°ƒç”¨ DubboConfigBindingRegistrarçš„æ³¨å†ŒBeanæ–¹æ³•è¿›è¡Œç»„ä»¶æ³¨å†Œ for (AnnotationAttributes element : annotationAttributes) &#123; // æ ¹æ® EnableDubboConfigBinding æ³¨è§£ä¿¡æ¯ï¼Œè¿›è¡Œå¯¹åº”ç»„ä»¶çš„æ³¨å†Œ registrar.registerBeanDefinitions(element, registry); &#125; &#125; @Override public void setEnvironment(Environment environment) &#123; Assert.isInstanceOf(ConfigurableEnvironment.class, environment); this.environment = (ConfigurableEnvironment) environment; &#125;&#125; ä¸Šé¢çš„ç±»ä¸»è¦åšäº†ä¸‰ä»¶äº‹æƒ…ï¼š è·å– @EnableDubboConfigBindings æ³¨è§£ä¿¡æ¯ï¼Œå¹¶è·å–è¯¥æ³¨è§£çš„valueå±æ€§å€¼ï¼Œå³è·å–çš„æ˜¯ @EnableDubboConfigBinding æ³¨è§£æ•°ç»„ã€‚ åˆ›å»º DubboConfigBindingRegistrarå¯¹è±¡ã€‚ éå†@EnableDubboConfigBinding æ³¨è§£æ•°ç»„ï¼Œè°ƒç”¨DubboConfigBindingRegistrarå¯¹è±¡çš„ registerBeanDefinitionsæ–¹æ³•ã€‚ æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œ@EnableDubboConfigBindingsåˆ©ç”¨DubboConfigBindingsRegistrarå¯¼å…¥ç»„ä»¶é€»è¾‘å¾ˆç®€å•ï¼Œå› ä¸ºæ•´ä¸ªå¯¼å…¥é€»è¾‘éƒ½å°è£…åœ¨äº†DubboConfigBindingRegistrarå¯¹è±¡çš„ registerBeanDefinitionsæ–¹æ³•ä¸­ã€‚æˆ‘ä»¬æ¥ç€åˆ†æDubboConfigBindingsRegistrarç±»ï¼Œéœ€è¦è¯´æ˜çš„æ˜¯@EnableDubboConfigBindingæ³¨è§£å°±æ˜¯é€šè¿‡@Importæ³¨è§£ä½¿ç”¨è¯¥ç±»ã€‚ 1234567891011121314151617181920212223public class DubboConfigBindingRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; // $&#123;å…¶ä»–ä»£ç &#125; /** * @param attributes @EnableDubboConfigBindingæ³¨è§£ä¿¡æ¯ * @param registry Beanå®šä¹‰æ³¨å†Œè¡¨ */ protected void registerBeanDefinitions(AnnotationAttributes attributes, BeanDefinitionRegistry registry) &#123; // è·å¾—prefix å±æ€§ï¼ˆå› ä¸ºæœ‰å¯èƒ½æœ‰å ä½ç¬¦ï¼Œéœ€è¦è¦è§£æï¼‰ String prefix = environment.resolvePlaceholders(attributes.getString(\"prefix\")); // è·å¾—typeå±æ€§ï¼Œå³AbstractConfigçš„å®ç°ç±»ï¼Œè¿™å°±æ˜¯è¦å¯¼å…¥çš„ç»„ä»¶ã€‚éœ€è¦ç‰¹åˆ«è¯´æ˜çš„æ˜¯ï¼Œä½¿ç”¨æ³¨è§£æ–¹å¼åˆ›å»ºDubboçš„é…ç½®Beanï¼ŒDubbo Config éƒ½æ˜¯å›ºå®šå†™åœ¨@EnableDubboConfigBindingæ³¨è§£å±æ€§ä¸­ã€‚ Class&lt;? extends AbstractConfig&gt; configClass = attributes.getClass(\"type\"); // è·çš„multipleå±æ€§ï¼Œå†³å®šé…ç½®æ˜¯å¦ç”¨äºå¤šBeanDefinition boolean multiple = attributes.getBoolean(\"multiple\"); // æ³¨å†ŒDubbo Config Bean registerDubboConfigBeans(prefix, configClass, multiple, registry); &#125; // $&#123;å…¶ä»–ä»£ç &#125;&#125; ç”±ä»£ç å¯ä»¥çœ‹å‡ºDubboConfigBindingsRegistrarå°±æ˜¯ä½¿ç”¨ DubboConfigBindingRegistrar å¯¹è±¡è§£æ@EnableDubboConfigBinding æ³¨è§£ä¿¡æ¯ï¼Œå³é…ç½®å±æ€§çš„å‰ç¼€å’Œé…ç½®å±æ€§å¯¹åº”çš„Dubbo Configç±»ï¼Œæ¥ç€è°ƒç”¨registerDubboConfigBeans æ–¹æ³•æ‰§è¡Œæ³¨å†ŒBeanå®šä¹‰é€»è¾‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class DubboConfigBindingRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * æ³¨å†Œdubbo Config Beanå¯¹è±¡ * * @param prefix é…ç½®å±æ€§å‰ç¼€ * @param configClass é…ç½®ç±» * @param multiple æ˜¯å¦æ”¯æŒå¤šBeané…ç½® * @param registry Springæ³¨å†Œè¡¨ */ private void registerDubboConfigBeans(String prefix, Class&lt;? extends AbstractConfig&gt; configClass, boolean multiple, BeanDefinitionRegistry registry) &#123; // è·å¾—prefix å¼€å¤´çš„é…ç½®å±æ€§ï¼Œä»¥mapå½¢å¼è¿”å› ã€environment.getPropertySources() è·å¾—æ˜¯ç³»ç»Ÿå±æ€§ã€ç³»ç»Ÿå˜é‡å’Œ@ResourcePropertyæ³¨è§£å¯¼å…¥çš„propertisé…ç½®å±æ€§ã€‘ Map&lt;String, Object&gt; properties = getSubProperties(environment.getPropertySources(), prefix); // é…ç½®ç±»æ²¡æœ‰é…ç½®ç›¸å…³å±æ€§ï¼Œåˆ™ä¸åˆ›å»ºå¯¹åº”çš„BeanDefinition if (CollectionUtils.isEmpty(properties)) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"There is no property for binding to dubbo config class [\" + configClass.getName() + \"] within prefix [\" + prefix + \"]\"); &#125; return; &#125; // è·å¾—é…ç½®ç±»çš„Beanåç§°ï¼ŒBeanåç§°ç”Ÿæˆè§„åˆ™å–å†³ä¸ multiple çš„å€¼ Set&lt;String&gt; beanNames = multiple ? resolveMultipleBeanNames(properties) : Collections.singleton(resolveSingleBeanName(properties, configClass, registry)); // éå†Beanåå­—é›†åˆ for (String beanName : beanNames) &#123; // 1. æ³¨å†ŒDubbo Configçš„Bean å¯¹è±¡ã€æ²¡æœ‰è®¾ç½®å±æ€§å€¼ã€‘ registerDubboConfigBean(beanName, configClass, registry); // 2. æ³¨å†ŒDubbo Configçš„Beanå¯¹è±¡å¯¹åº”çš„DubboConfigBindingBeanPostProcessorå¯¹è±¡ï¼Œå³Dubboé…ç½®å±æ€§ç»‘å®šçš„åç½®å¤„ç†å™¨ã€æ³¨æ„ï¼Œæ¯ä¸€ä¸ªDubbo Configçš„Beanå¯¹è±¡éƒ½å¯¹åº”ä¸€ä¸ªç»‘å®šé…ç½®çš„åç½®å¤„ç†å™¨ã€‘ registerDubboConfigBindingBeanPostProcessor(prefix, beanName, multiple, registry); &#125; &#125; /** * æ³¨å†ŒDubbo ConfigBeanå¯¹è±¡ * * @param beanName Beançš„åç§° * @param configClass é…ç½®ç±» * @param registry æ³¨å†Œè¡¨ */ private void registerDubboConfigBean(String beanName, Class&lt;? extends AbstractConfig&gt; configClass, BeanDefinitionRegistry registry) &#123; // åˆ›å»º configClasså¯¹åº”çš„Beanå®šä¹‰Builder [è¯¥è¿‡ç¨‹Beanå®šä¹‰å·²ç»åˆ›å»º] BeanDefinitionBuilder builder = rootBeanDefinition(configClass); // ç”± Beanå®šä¹‰Builder è·å–Beanå®šä¹‰ AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); // æ³¨å†Œåˆ° Spring çš„æ³¨å†Œè¡¨ä¸­ registry.registerBeanDefinition(beanName, beanDefinition); if (log.isInfoEnabled()) &#123; log.info(\"The dubbo config bean definition [name : \" + beanName + \", class : \" + configClass.getName() + \"] has been registered.\"); &#125; &#125; /** * åˆ›å»ºçš„Dubbo Configçš„Beanå¯¹è±¡çš„DubboConfigBindingBeanPostProcessorå¯¹è±¡ ã€ç›®çš„ï¼šå®ç°å¯¹Dubbo Configçš„Beanå¯¹è±¡çš„é…ç½®å±æ€§è®¾ç½®ã€‘ * * @param prefix é…ç½®å±æ€§å‰ç¼€ * @param beanName Beançš„åç§° * @param multiple æ˜¯å¦æ”¯æŒå¤šBean * @param registry Springæ³¨å†Œè¡¨ */ private void registerDubboConfigBindingBeanPostProcessor(String prefix, String beanName, boolean multiple, BeanDefinitionRegistry registry) &#123; // åˆ›å»ºDubboé…ç½®ç»‘å®š Beanåç½®å¤„ç†å™¨å¯¹åº”çš„BeanDefinitionBuilderå¯¹è±¡ Class&lt;?&gt; processorClass = DubboConfigBindingBeanPostProcessor.class; BeanDefinitionBuilder builder = rootBeanDefinition(processorClass); /** * æ„é€ æ–¹æ³•çš„å‚æ•°ä¸º actualPrefix å’Œ beanNameï¼Œå³åˆ›å»ºDubboConfigBindingBeanPostProcessorå¯¹è±¡éœ€è¦è¿™ä¸¤ä¸ªå‚æ•°ï¼Œåé¢å±æ€§ç»‘å®šä¼šç”¨åˆ°è¿™ä¸¤ä¸ªå±æ€§ã€‚ * @see DubboConfigBindingBeanPostProcessor#DubboConfigBindingBeanPostProcessor(java.lang.String, java.lang.String) */ String actualPrefix = multiple ? normalizePrefix(prefix) + beanName : prefix; builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName); // è·å¾— DubboConfigBindingBeanPostProcessor çš„ BeanDefinition å¯¹è±¡ AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); // è®¾ç½®rolå±æ€§ beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); // æ³¨å†Œåˆ°æ³¨å†Œè¡¨ registerWithGeneratedName(beanDefinition, registry); if (log.isInfoEnabled()) &#123; log.info(\"The BeanPostProcessor bean definition [\" + processorClass.getName() + \"] for dubbo config bean [name : \" + beanName + \"] has been registered.\"); &#125; &#125; // $&#123;çœç•¥ä»£ç &#125; &#125; registerDubboConfigBeans æ–¹æ³•ä¸»è¦å®Œæˆäº†ä¸¤ä¸ªæ ¸å¿ƒçš„å·¥ä½œï¼Œåˆ›å»ºDubbo Configçš„Beanå®šä¹‰å’ŒDubbo Configçš„å±æ€§ç»‘å®šåç½®å¤„ç†å™¨ã€‚Dubbo Configæ˜¯çº¦å®šå¥½çš„é…ç½®ç±»ï¼Œå…·ä½“çº¦å®šçš„é…ç½®ç±»å¯ä»¥å‚è§ DubboConfigConfigurationï¼Œå¹¶ä¸”æŒ‡å®šäº†è¿™äº›é…ç½®ç±»çš„å¤–éƒ¨é…ç½®å±æ€§çš„å‰ç¼€ã€‚è¿™ä¸ªè¿‡ç¨‹è¿˜æ¶‰åŠåˆ°Dubbo Configçš„Beanå®šä¹‰çš„åç§°ç”Ÿæˆï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class DubboConfigBindingRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * è·å¾—é…ç½®ç±»å¯¹åº”çš„Bean åç§°çš„é›†åˆã€‚é…ç½®ç”¨äºå¤šä¸ªBeançš„æƒ…å†µ * &lt;p&gt; * ä¾‹å¦‚ï¼š dubbo.application.$&#123;beanName&#125;.name=dubbo-demo-annotation-providerï¼Œ$&#123;beanName&#125;å°±æ˜¯é…ç½®ç±»å¯¹åº”çš„Beançš„åç§° * * @param properties é…ç½®å±æ€§é›†åˆ * @return */ private Set&lt;String&gt; resolveMultipleBeanNames(Map&lt;String, Object&gt; properties) &#123; Set&lt;String&gt; beanNames = new LinkedHashSet&lt;String&gt;(); for (String propertyName : properties.keySet()) &#123; // è·å–$&#123;beanName&#125; å­—ç¬¦ä¸² int index = propertyName.indexOf(\".\"); if (index &gt; 0) &#123; String beanName = propertyName.substring(0, index); beanNames.add(beanName); &#125; &#125; return beanNames; &#125; /** * è·å¾—é…ç½®ç±»å¯¹åº”çš„Bean åç§° * ä¾‹å¦‚ï¼š dubbo.application.name=dubbo-demo-annotation-provider * * @param properties * @param configClass * @param registry * @return */ private String resolveSingleBeanName(Map&lt;String, Object&gt; properties, Class&lt;? extends AbstractConfig&gt; configClass, BeanDefinitionRegistry registry) &#123; // è·å¾—Beançš„åç§° String beanName = (String) properties.get(\"id\"); // æ²¡æœ‰æ²¡æœ‰å®šä¹‰ï¼Œå°±åŸºäºSpringæä¾›çš„æœºåˆ¶ç”Ÿæˆå¯¹åº”çš„Beançš„åå­—ã€‚ å¦‚ï¼š org.apache.dubbo.config.ApplicationConfig#0 if (!StringUtils.hasText(beanName)) &#123; BeanDefinitionBuilder builder = rootBeanDefinition(configClass); beanName = BeanDefinitionReaderUtils.generateBeanName(builder.getRawBeanDefinition(), registry); &#125; return beanName; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; ç”±ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼Œé…ç½®ç”¨äºå¤šä¸ªBeançš„æ—¶å€™Beançš„åç§°ç›´æ¥ä»é…ç½®å±æ€§å€¼ä¸­è·å–ï¼Œå³è·å–${beanName} çš„å€¼ä½œä¸ºBeanåç§°ï¼ŒBeançš„åç§°å¯èƒ½ä¼šæœ‰å¤šä¸ªã€‚é…ç½®ç”¨äºå•ä¸ªBeançš„æ—¶å€™Beançš„åç§°å…ˆå°è¯•ä½¿ç”¨idå±æ€§å€¼ï¼Œæ²¡æœ‰é…ç½®idå±æ€§å°±è‡ªåŠ¨ç”Ÿæˆã€‚è¿™ä¸¤ç§æƒ…å†µå¯èƒ½ä¸€ä¸‹å­ä¸å¥½ç†è§£ï¼Œä¸‹æ–‡è¿˜ä¼šè¯¦ç»†è¯´æ˜ã€‚ä¸Šé¢çš„è¿‡ç¨‹ä¸­Beanå®šä¹‰æ˜¯æ³¨å†Œåˆ°äº†æ³¨å†Œè¡¨ä¸­ï¼Œä½†æ˜¯Beançš„å±æ€§è¿˜æ²¡æœ‰è®¾ç½®ï¼Œä¸‹é¢æˆ‘ä»¬æ¥åˆ†æ DubboConfigBindingBeanPostProcessor æ˜¯å¦‚ä½•è¿›è¡Œå±æ€§ç»‘å®šçš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/** * Dubbo Config Binding &#123;@link BeanPostProcessor&#125; * * @see EnableDubboConfigBinding * @see DubboConfigBindingRegistrar * @since 2.5.8 * &lt;p&gt; * å¤„ç†Dubbo AbstractConfig Beançš„é…ç½®å±æ€§æ³¨å…¥ */public class DubboConfigBindingBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware, InitializingBean &#123; private final Log log = LogFactory.getLog(getClass()); /** * å±æ€§é…ç½®å‰ç¼€ */ private final String prefix; /** * Binding Bean Name // Beançš„åå­—ï¼Œæ¯ä¸ªé…ç½®ç±»çš„Beanéƒ½æœ‰è‡ªå·±çš„åç§° */ private final String beanName; /** * Dubbo é…ç½®å±æ€§ç»‘å®šå™¨ ï¼Œç”¨æ¥ç»‘å®šé…ç½®å±æ€§åˆ°Dubbo Configä¸­ ï¼ˆå†…éƒ¨ä½¿ç”¨Spring DataBinderå®Œæˆå±æ€§ç»‘å®šï¼‰ */ private DubboConfigBinder dubboConfigBinder; /** * åº”ç”¨ä¸Šä¸‹æ–‡ */ private ApplicationContext applicationContext; /** * æ˜¯å¦å¿½ç•¥æœªçŸ¥çš„å±æ€§ */ private boolean ignoreUnknownFields = true; /** * æ˜¯å¦å¿½ç•¥ç±»å‹ä¸å¯¹çš„å±æ€§ */ private boolean ignoreInvalidFields = true; /** * æ„é€ æ–¹æ³•ï¼Œå±æ€§å‰ç¼€å’Œé…ç½®ç±»çš„Beanæ˜¯é€šè¿‡æ„é€ æ–¹æ³•ä¼ å…¥è¿›æ¥çš„ã€‚ * * @param prefix the prefix of Configuration Properties * @param beanName the binding Bean Name */ public DubboConfigBindingBeanPostProcessor(String prefix, String beanName) &#123; Assert.notNull(prefix, \"The prefix of Configuration Properties must not be null\"); Assert.notNull(beanName, \"The name of bean must not be null\"); this.prefix = prefix; this.beanName = beanName; &#125; /** * Beanåå¤„ç†å™¨çš„ å‰ç½®å¤„ç†æ–¹æ³•ã€‚å°†é…ç½®å±æ€§ç»‘å®šåˆ°Dubbo Configä¸­ * * @param bean * @param beanName * @return * @throws BeansException */ @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; // é€‰æ‹©beançš„åç§°æ˜¯ this.beanNameã€é’ˆå¯¹æ³¨è§£æœºåˆ¶åˆ›å»ºBeanå®šä¹‰ï¼Œå…¶ä»–æ–¹å¼åˆ›å»ºçš„Beanå®šä¹‰ä¸ç¬¦åˆæ¡ä»¶ã€‘ï¼Œå¹¶ä¸”æ˜¯AbstractConfigç±»å‹çš„ Beanå®šä¹‰ if (beanName.equals(this.beanName) &amp;&amp; bean instanceof AbstractConfig) &#123; AbstractConfig dubboConfig = (AbstractConfig) bean; // è®¾ç½®prefixå¼€å¤´çš„é…ç½®å±æ€§åˆ° DubboConfigä¸­ dubboConfigBinder.bind(prefix, dubboConfig); if (log.isInfoEnabled()) &#123; log.info(\"The properties of bean [name : \" + beanName + \"] have been binding by prefix of \" + \"configuration properties : \" + prefix); &#125; &#125; return bean; &#125; /** * Beanåå¤„ç†å™¨çš„åç½®å¤„ç†æ–¹æ³•ï¼Œè¿™é‡Œç›´æ¥è¿”å›Dubbo Configçš„Beanå¯¹è±¡ï¼Œä¸åšå…¶ä»–çš„å¤„ç† * * @param bean * @param beanName * @return * @throws BeansException */ @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; /** * è®¾ç½® Dubbo é…ç½®å±æ€§ç»‘å®šå™¨ï¼Œæ³¨æ„å®ƒçš„è§¦å‘æ—¶æœºã€‚ * * @throws Exception */ @Override public void afterPropertiesSet() throws Exception &#123; // è·å¾—DubboConfigBinderå¯¹è±¡ if (dubboConfigBinder == null) &#123; try &#123; dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class); &#125; catch (BeansException ignored) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"DubboConfigBinder Bean can't be found in ApplicationContext.\"); &#125; // Use Default implementation // åˆ›å»ºé»˜è®¤çš„é…ç½®ç»‘å®šå™¨ dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment()); &#125; &#125; // è®¾ç½® æ˜¯å¦å¿½ç•¥æœªçŸ¥/æ— æ•ˆçš„å±æ€§ dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields); dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields); &#125; /** * Create &#123;@link DubboConfigBinder&#125; instance. * * @param environment * @return &#123;@link DefaultDubboConfigBinder&#125; */ protected DubboConfigBinder createDubboConfigBinder(Environment environment) &#123; // åˆ›å»ºDefaultDubboConfigBinderå¯¹è±¡ DefaultDubboConfigBinder defaultDubboConfigBinder = new DefaultDubboConfigBinder(); // è®¾ç½®environmentå±æ€§ defaultDubboConfigBinder.setEnvironment(environment); return defaultDubboConfigBinder; &#125; public boolean isIgnoreUnknownFields() &#123; return ignoreUnknownFields; &#125; public void setIgnoreUnknownFields(boolean ignoreUnknownFields) &#123; this.ignoreUnknownFields = ignoreUnknownFields; &#125; public boolean isIgnoreInvalidFields() &#123; return ignoreInvalidFields; &#125; public void setIgnoreInvalidFields(boolean ignoreInvalidFields) &#123; this.ignoreInvalidFields = ignoreInvalidFields; &#125; public DubboConfigBinder getDubboConfigBinder() &#123; return dubboConfigBinder; &#125; public void setDubboConfigBinder(DubboConfigBinder dubboConfigBinder) &#123; this.dubboConfigBinder = dubboConfigBinder; &#125;&#125; Dubbo Configçš„å±æ€§ç»‘å®šåç½®å¤„ç†å™¨é€»è¾‘ä¸ç®—å¤æ‚ï¼Œå°±æ˜¯ä»Springç¯å¢ƒä¸­è·å–é…ç½®å±æ€§ï¼Œç„¶ååˆ©ç”¨Springçš„æ•°æ®ç»‘å®šå™¨DataBinderå®ŒæˆDubbo Configçš„Beanå±æ€§çš„ç»‘å®šï¼Œé€»è¾‘å¦‚ä¸‹ï¼š 12345678910111213141516171819202122/** * Default &#123;@link DubboConfigBinder&#125; implementation based on Spring &#123;@link DataBinder&#125; * &lt;p&gt; * ä½¿ç”¨Spring DataBinderï¼Œå°†é…ç½®å±æ€§è®¾ç½®åˆ°Dubbo Configå¯¹è±¡ä¸­ */public class DefaultDubboConfigBinder extends AbstractDubboConfigBinder &#123; @Override public &lt;C extends AbstractConfig&gt; void bind(String prefix, C dubboConfig) &#123; // å°†Dubbo ConfigåŒ…è£…æˆ DataBinderå¯¹è±¡ DataBinder dataBinder = new DataBinder(dubboConfig); // æ˜¯å¦å¿½ç•¥æ— æ•ˆå’ŒæœªçŸ¥å±æ€§ dataBinder.setIgnoreInvalidFields(isIgnoreInvalidFields()); dataBinder.setIgnoreUnknownFields(isIgnoreUnknownFields()); // ä»PropertySourcesä¸­è·å–prefixå¼€å¤´çš„é…ç½®å±æ€§ [getPropertySources() : ç³»ç»Ÿå±æ€§ï¼Œç³»ç»Ÿç¯å¢ƒå’Œ@ProperSourcesçš„å±æ€§k-v] Map&lt;String, Object&gt; properties = getSubProperties(getPropertySources(), prefix); // æ ¹æ®é…ç½®å±æ€§é›†åˆ åˆ›å»º MutablePropertyValueså¯¹è±¡ MutablePropertyValues propertyValues = new MutablePropertyValues(properties); // ç»‘å®šé…ç½®å±æ€§åˆ° Dubboçš„é…ç½®å¯¹è±¡ä¸­ dataBinder.bind(propertyValues); &#125;&#125; åœ¨Springçš„åç½®å¤„ç†å™¨çš„æ–¹æ³•ä¸­ä¼šè°ƒç”¨ DefaultDubboConfigBinder#bindæ–¹æ³•è¿›è¡ŒDubbo Configçš„Beançš„å±æ€§è®¾ç½®ï¼Œæœ¬è´¨æ˜¯ä½¿ç”¨Springçš„DataBinderå®Œæˆå±æ€§è®¾ç½®ã€‚è‡³æ­¤ï¼Œ@EnableDubboConfigBindingsæ¶‰åŠçš„å¤„ç†é€»è¾‘åˆ†æå®Œæ¯•ï¼Œè¿™ä¸ªè¿‡ç¨‹åˆ›å»ºäº†Dubbo Configçš„Beanï¼Œå¹¶ä¸”åˆ›å»ºäº†è¯¥Beanå¯¹åº”çš„å±æ€§ç»‘å®šBeanåç½®å¤„ç†å™¨ï¼Œåœ¨Springçš„ç”Ÿå‘½å‘¨æœŸä¸­è¯¥Beanåç½®å¤„ç†å™¨ä¼šå›è°ƒå¯¹åº”çš„æ–¹æ³•ä»¥å®Œæˆå±æ€§çš„ç»‘å®šã€‚æ¥ä¸‹æ¥æˆ‘ä»¬å†æ¥åˆ†æ @EnableDubboConfigBinding æ³¨è§£ï¼Œè¯¥æ³¨è§£æ˜¯ @EnableDubboConfigBindings æ³¨è§£çš„å±æ€§æ•°ç»„çš„ç±»å‹ï¼Œ @EnableDubboConfigBindings æ³¨è§£çš„é€»è¾‘å¤„ç†åŸºæœ¬å°±æ˜¯ @EnableDubboConfigBinding æ³¨è§£çš„é€»è¾‘å¤„ç†ã€‚ @EnableDubboConfigBinding æ³¨è§£123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Enables Spring's annotation-driven &#123;@link AbstractConfig Dubbo Config&#125; from &#123;@link PropertySources properties&#125;. * &lt;p&gt; * Default , &#123;@link #prefix()&#125; associates with a prefix of &#123;@link PropertySources properties&#125;, e,g. \"dubbo.application.\" * or \"dubbo.application\" * &lt;pre class=\"code\"&gt; * &lt;/pre&gt; * * @see DubboConfigBindingRegistrar * @see DubboConfigBindingBeanPostProcessor * @see EnableDubboConfigBindings * @since 2.5.8 */@Target(&#123;ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(DubboConfigBindingRegistrar.class)public @interface EnableDubboConfigBinding &#123; /** * é…ç½®å±æ€§çš„å‰ç¼€ï¼Œç”¨äºæ˜ å°„åˆ° AbstractConfig ä¸­çš„å±æ€§ * &lt;p&gt; * The name prefix of the properties that are valid to bind to &#123;@link AbstractConfig Dubbo Config&#125;. * * @return the name prefix of the properties to bind */ String prefix(); /** * Dubbo Config é…ç½®ç±»ï¼Œè¿™æ˜¯ä¸€ä¸ªçº¦å®šï¼ŒDubbo Configé…ç½®ç±»æœ‰å“ªäº›æ˜¯å›ºå®šçš„ï¼Œè¿™ä¸ªé…ç½®å¿…é¡»æ˜¯AbstractConfigçš„å®ç°å­ç±»ã€‚ * * @return The binding type of &#123;@link AbstractConfig Dubbo Config&#125;. * @see AbstractConfig * @see ApplicationConfig * @see ModuleConfig * @see RegistryConfig */ Class&lt;? extends AbstractConfig&gt; type(); /** * æ˜¯å¦æ”¯æŒé…ç½®ç”¨äºå¤šä¸ªBean * * It indicates whether &#123;@link #prefix()&#125; binding to multiple Spring Beans. * * @return the default value is &lt;code&gt;false&lt;/code&gt; */ boolean multiple() default false;&#125; è¯¥æ³¨è§£æœ‰ä¸‰ä¸ªå±æ€§ï¼Œæ¯ä¸ªå±æ€§çš„ä½œç”¨å·²ç»æ³¨é‡Šè¿‡äº†ï¼Œæˆ‘ä»¬ç›´æ¥æ¥çœ‹ @Import(DubboConfigBindingRegistrar.class)ï¼ŒDubboConfigBindingRegistrarçš„ä¸»è¦é€»è¾‘å·²ç»åœ¨ä¸Šé¢åˆ†æè¿‡äº†ï¼Œæˆ‘ä»¬åœ¨ç®€å•çœ‹ä¸‹æ²¡æœ‰åˆ†æåˆ°çš„ä»£ç ã€‚ 12345678910111213141516171819202122232425262728/** * &#123;@link AbstractConfig Dubbo Config&#125; binding Bean registrar * * @see EnableDubboConfigBinding * @see DubboConfigBindingBeanPostProcessor * @since 2.5.8 * &lt;p&gt; * å¤„ç† @EnableDubboConfigBinding æ³¨è§£ï¼Œæ³¨å†Œç›¸åº”çš„ Dubbo AbstractConfig åˆ°Spring å®¹å™¨ */public class DubboConfigBindingRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; private final Log log = LogFactory.getLog(getClass()); private ConfigurableEnvironment environment; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; // è·å¾— @EnableDubboConfigBindingæ³¨è§£ä¿¡æ¯ AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBinding.class.getName())); // æ ¹æ® @EnableDubboConfigBindingæ³¨è§£ä¿¡æ¯ æ³¨å†Œé…ç½®å¯¹åº”çš„ BeanDefinition å¯¹è±¡ registerBeanDefinitions(attributes, registry); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; è‡³æ­¤ï¼Œ@EnableDubboConfig æ³¨è§£å·²ç»åˆ†æå®Œäº†ï¼Œè¯¥æ³¨è§£å°±æ˜¯ç”¨äºå¼€å¯Dubboçš„é…ç½®ï¼Œåˆ›å»ºDubboæ¡†æ¶å†…ç½®çš„é…ç½®ç±»çš„Beanï¼Œå¹¶ä¸”åˆ›å»ºé…ç½®ç±»çš„Beanå¯¹åº”çš„å±æ€§ç»‘å®šBeanåç½®å¤„ç†å™¨ï¼ŒSpringåº”ç”¨ä¸Šä¸‹æ–‡å¯åŠ¨åï¼Œå°±å¯ä»¥å®ç°é…ç½®å¯¹è±¡çš„åˆ›å»ºä¸åˆå§‹åŒ–ã€‚ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¹¶ä¸æ˜¯æŒ‡å®šäº†é…ç½®ç±»å°±ä¼šåˆ›å»ºå¯¹åº”çš„Beanï¼Œåªæœ‰å½“è§„çº¦çš„å¤–éƒ¨é…ç½®å­˜åœ¨æ—¶ï¼Œé…ç½®ç±»æ‰ä¼šæå‡ä¸ºSpring Beanã€‚ Dubboé…ç½®Beanç»‘å®šåŠè‡ªå®šä¹‰é…ç½®Beanç»‘å®šè¿™å—å†…å®¹è¿˜æ˜¯ä¸å°‘çš„ï¼Œè¿™é‡Œå°±ä¸è¯¦ç»†è¯´æ˜äº†ã€‚æˆ‘ä»¬ç›´æ¥çœ‹ Dubbo PMC çš„æ–‡ç«  Dubbo æ–°ç¼–ç¨‹æ¨¡å‹ä¹‹å¤–éƒ¨åŒ–é…ç½®ï¼Œé‡Œé¢è¯¦ç»†ä»‹ç»äº†å¤šé…ç½®Beançš„å±æ€§ç»‘å®šä»¥åŠè‡ªå®šä¹‰Beançš„å±æ€§ç»‘å®šã€‚ @DubboComponentScan æ³¨è§£è¯¥æ³¨è§£ç”¨äºé…ç½®è¦æ‰«æ @Service å’Œ @Reference æ³¨è§£çš„åŒ…æˆ–ç±»ï¼Œè¿›è€Œåˆ›å»ºå¯¹åº”çš„Beanå¯¹è±¡ã€‚æ³¨è§£æ‰«ææ˜¯å§”æ‰˜ç»™Springçš„ï¼Œæœ¬è´¨ä¸Šä½¿ç”¨ASMåº“è¿›è¡Œå­—èŠ‚ç æ‰«ææ³¨è§£å…ƒæ•°æ®ã€‚å½“ç”¨æˆ·ä½¿ç”¨æ³¨è§£ @DubboComponentScan æ—¶ï¼Œä¼šæ¿€æ´» DubboComponentScanRegistrarï¼Œè¿™ä¸ªç±»å°±æ˜¯å®ç°æœåŠ¡æä¾›è€…é€šè¿‡æ³¨è§£ @Service è¿›è¡ŒæœåŠ¡æš´éœ²çš„ï¼Œå¯¹æ¶ˆè´¹è€…é€šè¿‡æ³¨è§£ @Reference è¿›è¡ŒæœåŠ¡å¼•ç”¨çš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Dubbo Component Scan &#123;@link Annotation&#125;,scans the classpath for annotated components that will be auto-registered as * Spring beans. Dubbo-provided &#123;@link Service&#125; and &#123;@link Reference&#125;. * * @see Service * @see Reference * @since 2.5.7 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(DubboComponentScanRegistrar.class)public @interface DubboComponentScan &#123; /** * Alias for the &#123;@link #basePackages()&#125; attribute. Allows for more concise annotation * declarations e.g.: &#123;@code @DubboComponentScan(\"org.my.pkg\")&#125; instead of * &#123;@code @DubboComponentScan(basePackages=\"org.my.pkg\")&#125;. * * @return the base packages to scan * * å’Œ basePackages ç­‰ä»· * */ String[] value() default &#123;&#125;; /** * Base packages to scan for annotated @Service classes. &#123;@link #value()&#125; is an * alias for (and mutually exclusive with) this attribute. * &lt;p&gt; * Use &#123;@link #basePackageClasses()&#125; for a type-safe alternative to String-based * package names. * * @return the base packages to scan * * è¦æ‰«æåŒ…çš„æ•°ç»„ * */ String[] basePackages() default &#123;&#125;; /** * Type-safe alternative to &#123;@link #basePackages()&#125; for specifying the packages to * scan for annotated @Service classes. The package of each class specified will be * scanned. * * @return classes from the base packages to scan * * è¦æ‰«æçš„ç±»çš„æ•°ç»„ * */ Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;&#125; è¯¥æ³¨è§£çš„å±æ€§ä½œç”¨å·²ç»æ³¨é‡Šï¼Œæˆ‘ä»¬é‡ç‚¹å…³æ³¨ä¸‹@Importçš„valueå±æ€§å€¼ DubboComponentScanRegistrar ï¼Œå®ƒç”¨äºå¤„ç†DubboComponentScanæ³¨è§£ï¼Œä¸ºSpringå®¹å™¨æ³¨å†ŒServiceAnnotationå’ŒReferenceAnnotationçš„Beanåç½®å¤„ç†å™¨ï¼Œè¿›è€Œåˆ›å»ºServiceBeanå’ŒReferenceBeanå¯¹è±¡ã€‚ä¸‹é¢æˆ‘ä»¬å°±æ¥è¯¦ç»†åˆ†æDubboæ³¨è§£å®ç°çš„è¿™ä¸ªæ ¸å¿ƒç±»ã€‚ DubboComponentScanRegistrar1234567891011121314151617181920212223242526272829303132333435/** * Dubbo &#123;@link DubboComponentScan&#125; Bean Registrar * * @see Service * @see DubboComponentScan * @see ImportBeanDefinitionRegistrar * @see ServiceAnnotationBeanPostProcessor * @see ReferenceAnnotationBeanPostProcessor * @since 2.5.7 * */public class DubboComponentScanRegistrar implements ImportBeanDefinitionRegistrar &#123; /** * @param importingClassMetadata @DubboComponentScan æ³¨è§£çš„ä¿¡æ¯ * @param registry Beanå®šä¹‰æ³¨å†Œè¡¨ */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; /** * 1. è·å¾—è¦æ‰«æçš„åŒ… */ Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata); /** * 2. åˆ›å»º ServiceAnnotationBeanPostProcessor Bean å¯¹è±¡ï¼Œåç»­æ‰«æ `@Service` æ³¨è§£çš„ç±»ï¼Œåˆ›å»ºå¯¹åº”çš„ Service Bean å¯¹è±¡ */ registerServiceAnnotationBeanPostProcessor(packagesToScan, registry); /** * 3. åˆ›å»º ReferenceAnnotationBeanPostProcessor Bean å¯¹è±¡ï¼Œåç»­æ‰«æ `@Reference` æ³¨è§£çš„ç±»ï¼Œåˆ›å»ºå¯¹åº”çš„ Reference Bean å¯¹è±¡ */ registerReferenceAnnotationBeanPostProcessor(registry); &#125; // $&#123;çœç•¥å…¶ä»–çš„ä»£ç &#125;&#125; DubboComponentScanRegistrar å®ç° ImportBeanDefinitionRegistraræ¥å£ï¼Œç”¨æ¥å¤„ç† @DubboComponentScanæ³¨è§£ï¼Œæ³¨å†Œ ServiceAnnotationBeanPostProcessor å’Œ ReferenceAnnotationBeanPostProcessor åˆ°Springå®¹å™¨ï¼ŒSpringåº”ç”¨ä¸Šä¸‹æ–‡å¯åŠ¨åï¼Œå°±å¯ä»¥å®ç°Service Beanå¯¹è±¡å’ŒReference Beanå¯¹è±¡çš„åˆ›å»ºã€‚ä¸‹é¢æˆ‘ä»¬ä¾æ¬¡åˆ†æä»¥ä¸Šä¸‰ä¸ªæ­¥éª¤çš„å…·ä½“é€»è¾‘ã€‚ è·å–è¦æ‰«æçš„åŒ…123456789101112131415161718192021222324252627282930313233343536373839public class DubboComponentScanRegistrar implements ImportBeanDefinitionRegistrar &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * è·å¾— DubboComponentScanæ³¨è§£æ‰«æçš„åŒ… * * @param metadata * @return */ private Set&lt;String&gt; getPackagesToScan(AnnotationMetadata metadata) &#123; // è·å¾— @DubboComponentScan æ³¨è§£ AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(DubboComponentScan.class.getName())); // è·å¾—basePackages å±æ€§å€¼ String[] basePackages = attributes.getStringArray(\"basePackages\"); // è·å¾—basePackageClasseså±æ€§å€¼ Class&lt;?&gt;[] basePackageClasses = attributes.getClassArray(\"basePackageClasses\"); // è·å¾—é»˜è®¤å±æ€§ï¼ˆbasePackagesçš„é»˜è®¤å±æ€§ï¼‰ String[] value = attributes.getStringArray(\"value\"); // å°†å±æ€§æ·»åŠ åˆ° packagesToScan é›†åˆä¸­ Set&lt;String&gt; packagesToScan = new LinkedHashSet&lt;String&gt;(Arrays.asList(value)); packagesToScan.addAll(Arrays.asList(basePackages)); // å¤„ç† æ‰«æçš„ç±»çš„æ•°ç»„ ï¼Œå¾—åˆ°æ¯ä¸ªç±»çš„åŒ…åï¼Œç„¶åæ·»åŠ åˆ° åŒ…è·¯å¾„æ•°ç»„ä¸­ for (Class&lt;?&gt; basePackageClass : basePackageClasses) &#123; packagesToScan.add(ClassUtils.getPackageName(basePackageClass)); &#125; // packagesToScan ä¸ºç©ºçš„è¯ï¼Œåˆ™é»˜è®¤ä½¿ç”¨DubboComponentScanæ³¨è§£ç±»æ‰€åœ¨çš„åŒ…åšä¸ºæ‰«æåŒ… if (packagesToScan.isEmpty()) &#123; return Collections.singleton(ClassUtils.getPackageName(metadata.getClassName())); &#125; return packagesToScan; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; è·å–è¦æ‰«æçš„åŒ…é€»è¾‘è¿˜æ˜¯å¾ˆç›´è§‚çš„ï¼Œå°†é…ç½®çš„æ‰«æåŒ…è·¯å¾„å’Œé…ç½®çš„æ‰«æç±»å¯¹åº”çš„åŒ…è·¯å¾„èšåˆåœ¨ä¸€èµ·ä½œä¸ºç›®æ ‡åŒ…è·¯å¾„ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯å½“é…ç½®æ‰«æç±»æ—¶éœ€è¦è·å–æ‰«æç±»çš„åŒ…åï¼Œå³è¿˜æ˜¯ä¼šè½¬ä¸ºåŒ…æ‰«æã€‚å¦‚æœæ²¡æœ‰é…ç½®æ‰«æåŒ…åŠæ‰«æç±»ï¼Œé‚£ä¹ˆå°±æ˜¯ä½¿ç”¨DubboComponentScanæ³¨è§£ç±»æ‰€åœ¨çš„åŒ…åšä¸ºæ‰«æåŒ…ã€‚ åˆ›å»ºæ‰«æ @Service æ³¨è§£çš„åç½®å¤„ç†å™¨1234567891011121314151617181920212223242526272829public class DubboComponentScanRegistrar implements ImportBeanDefinitionRegistrar &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * Registers &#123;@link ServiceAnnotationBeanPostProcessor&#125; * * @param packagesToScan packages to scan without resolving placeholders * @param registry &#123;@link BeanDefinitionRegistry&#125; * @since 2.5.8 * &lt;p&gt; * åˆ›å»º ServiceAnnotationBeanPostProcessor Bean å¯¹è±¡ï¼Œåç»­æ‰«æ @Service æ³¨è§£çš„ç±»ï¼Œåˆ›å»ºå¯¹åº”çš„ Service Bean å¯¹è±¡ */ private void registerServiceAnnotationBeanPostProcessor(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry) &#123; // åˆ›å»ºServiceAnnotationBeanPostProcessorçš„BeanDefinitionBuilder å¯¹è±¡ BeanDefinitionBuilder builder = rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class); // è®¾ç½®æ„é€ æ–¹æ³•å‚æ•°ä¸º packagesToScan builder.addConstructorArgValue(packagesToScan); // è®¾ç½® role å±æ€§ builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); // è·å¾— AbstractBeanDefinition å¯¹è±¡ AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); // æ³¨å†Œåˆ°æ³¨å†Œè¡¨ä¸­ BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; åˆ›å»ºæ‰«æ @Service æ³¨è§£çš„ç±»çš„åç½®å¤„ç†å™¨é€»è¾‘å¾ˆç®€å•ï¼Œå°±æ˜¯åˆ›å»ºä¸€ä¸ªBeanå®šä¹‰ç„¶åæ³¨å†Œåˆ°æ³¨å†Œè¡¨ä¸­ã€‚ä¸‹é¢æˆ‘ä»¬é‡ç‚¹åˆ†æè¿™ä¸ªåç½®å¤„ç†çš„é€»è¾‘ï¼Œçœ‹å®ƒæ˜¯å¦‚ä½•å°† @Service æ ‡æ³¨çš„ç±»æå‡ä¸ºSpring Beançš„ã€‚ ServiceAnnotationBeanPostProcessor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * &#123;@link Service&#125; Annotation * &#123;@link BeanDefinitionRegistryPostProcessor Bean Definition Registry Post Processor&#125; * * @since 2.5.8 */public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; private final Logger logger = LoggerFactory.getLogger(getClass()); /** * è¦æ‰«æçš„åŒ…çš„é›†åˆï¼Œé€šè¿‡æ„é€ æ–¹æ³•è¿›è¡Œè®¾ç½® */ private final Set&lt;String&gt; packagesToScan; /** * ç¯å¢ƒ */ private Environment environment; /** * èµ„æºåŠ è½½å™¨ */ private ResourceLoader resourceLoader; /** * ç±»åŠ è½½å™¨ */ private ClassLoader classLoader; public ServiceAnnotationBeanPostProcessor(String... packagesToScan) &#123; this(Arrays.asList(packagesToScan)); &#125; public ServiceAnnotationBeanPostProcessor(Collection&lt;String&gt; packagesToScan) &#123; this(new LinkedHashSet&lt;String&gt;(packagesToScan)); &#125; public ServiceAnnotationBeanPostProcessor(Set&lt;String&gt; packagesToScan) &#123; this.packagesToScan = packagesToScan; &#125; // $&#123;çœç•¥å…¶ä»–é€»è¾‘ä»£ç &#125; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; &#125; @Override public void setEnvironment(Environment environment) &#123; this.environment = environment; &#125; @Override public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; @Override public void setBeanClassLoader(ClassLoader classLoader) &#123; this.classLoader = classLoader; &#125; ServiceAnnotationBeanPostProcessor å®ç° BeanDefinitionRegistryPostProcessorã€EnvironmentAwareã€ResourceLoaderAwareã€BeanClassLoaderAware æ¥å£ï¼Œå…·å¤‡äº†Springçš„ç‰¹å®šåŠŸèƒ½ï¼Œå¦‚Springå®¹å™¨ä¸­æ‰€æœ‰Beanæ³¨å†Œä¹‹åå›è°ƒ postProcessBeanDefinitionRegistry æ–¹æ³•ã€‚è¯¥ç±»ä¸»è¦æ˜¯å°† @Service æ ‡æ³¨çš„ç±»æå‡ä¸ºSpring Beanï¼Œä¸»è¦çš„é€»è¾‘å¦‚ä¸‹ï¼š è§£ææ‰«æåŒ…é›†åˆï¼Œå¤„ç†å­˜åœ¨å ä½ç¬¦çš„åŒ…åã€‚ åˆ›å»ºDubboClassPathBeanDefinitionScannerå¯¹è±¡ï¼Œç”¨äºæ‰«ææŒ‡å®šåŒ…ä¸‹çš„ @Service æ ‡æ³¨çš„ç±»å¹¶æ³¨å†Œè¯¥ç±»çš„Beanå®šä¹‰åˆ°æ³¨å†Œè¡¨ã€‚ ä¸ºæ¯ä¸ª@Serviceæ ‡æ³¨çš„ç±»åˆ›å»ºå¯¹åº”çš„ ServiceBeanï¼Œå¹¶æ³¨å†Œåˆ°æ³¨å†Œè¡¨ã€‚ è§£ææ‰«æåŒ…é›†åˆ 123456789101112131415161718192021222324252627public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * * @param registry æ³¨å†Œè¡¨ * @throws BeansException */ @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123; // è§£æ packagesToScané›†åˆï¼ŒåŒ…åå¯èƒ½å­˜åœ¨å ä½ç¬¦çš„æƒ…å†µ Set&lt;String&gt; resolvedPackagesToScan = resolvePackagesToScan(packagesToScan); if (!CollectionUtils.isEmpty(resolvedPackagesToScan)) &#123; // æ‰«æ packagesToScan åŒ…ï¼Œåˆ›å»ºå¯¹åº”çš„ Spring BeanDefinition å¯¹è±¡ï¼Œä»è€Œè§¦å‘ Dubbo ServiceBean å®šä¹‰å’Œæ³¨å†Œ registerServiceBeans(resolvedPackagesToScan, registry); &#125; else &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"packagesToScan is empty , ServiceBean registry will be ignored!\"); &#125; &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; ä¸Šé¢çš„ä»£ç ä¸»è¦å¤„ç†åŒ…åå­˜åœ¨å ä½ç¬¦çš„æƒ…å†µï¼ŒåŒæ—¶ä¸Šé¢çš„æ–¹æ³•ä¹Ÿæ˜¯Springçš„Beanåå¤„ç†å™¨çš„å›è°ƒæ–¹æ³•ï¼Œåœ¨Springçš„ç”Ÿå‘½å‘¨æœŸå†…è¿›è¡Œå›è°ƒã€‚æ¥ä¸‹æˆ‘ä»¬çœ‹æ‰«æDubboçš„ @Service æ³¨è§£çš„é€»è¾‘ã€‚ æ‰«æDubboçš„ @Service æ³¨è§£ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * æ‰«æ packagesToScan åŒ…ï¼Œåˆ›å»ºå¯¹åº”çš„ Spring BeanDefinition å¯¹è±¡ï¼Œä»è€Œåˆ›å»º Dubbo Service Bean å¯¹è±¡ * &lt;p&gt; * Registers Beans whose classes was annotated &#123;@link Service&#125; * * @param packagesToScan è¦æ‰«æçš„åŒ…é›†åˆ * @param registry æ³¨å†Œè¡¨ */ private void registerServiceBeans(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry) &#123; // åˆ›å»º Dubboçš„ç±»è·¯å¾„Beanå®šä¹‰æ‰«æå¯¹è±¡ï¼Œè¯¥ç±»ç»§æ‰¿äº†Springçš„ ClassPathBeanDefinitionScannerï¼Œå³ç”¨äºæ‰«ææŒ‡å®šåŒ…ä¸‹ç¬¦åˆæ¡ä»¶çš„ç±»ï¼Œå°†ç¬¦åˆæ¡ä»¶çš„ç±»åˆ›å»ºå¯¹åº”çš„BeanDefinitionå¯¹è±¡ DubboClassPathBeanDefinitionScanner scanner = new DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader); // è·å¾— BeanNameGenerator å¯¹è±¡ï¼Œå¹¶è®¾ç½® beanNameGenerator åˆ° scanner ä¸­ BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry); scanner.setBeanNameGenerator(beanNameGenerator); // æŒ‡å®šæ‰«æå™¨æ‰«æå¸¦æœ‰Dubboçš„@Serviceæ³¨è§£çš„ç±»ï¼Œä¸ä¼šæ‰«æSpringçš„@Serviceæ³¨è§£ scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class)); // éå†æ‰«æçš„åŒ…é›†åˆ for (String packageToScan : packagesToScan) &#123; // æ‰§è¡Œæ‰«æï¼Œå¹¶æ³¨å†Œç›®æ ‡ç±»çš„Beanå®šä¹‰åˆ°æ³¨å†Œè¡¨ï¼Œä½¿ç”¨beanNameGeneratorç”ŸæˆBeançš„åç§° scanner.scan(packageToScan); // åˆ›å»ºæ¯ä¸ªè¢«æ‰«æçš„ç±»çš„BeanDefinitionHolderå¯¹è±¡ï¼Œè¿”å›BeanDefinitionHolderé›†åˆï¼Œç”¨äºç”ŸæˆServiceBeanå®šä¹‰ã€æ³¨æ„ï¼Œè¿™é‡Œä¹Ÿä¼šåˆ›å»ºæ‰«æçš„ç±»çš„Beanå®šä¹‰ï¼Œä¹Ÿæ˜¯ä½¿ç”¨ beanNameGenerator ç”Ÿæˆåç§°ï¼Œä½†æ²¡æœ‰æ³¨å†Œåˆ°æ³¨å†Œè¡¨ã€‘ Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders = findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator); // ä¸ºæ¯ä¸ª@Serviceæ ‡æ³¨çš„ç±»åˆ›å»ºå¯¹åº”çš„ ServiceBeanï¼Œå¹¶æ³¨å†Œåˆ°æ³¨å†Œè¡¨ã€‚ if (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123; for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123; registerServiceBean(beanDefinitionHolder, registry, scanner); &#125; if (logger.isInfoEnabled()) &#123; logger.info(beanDefinitionHolders.size() + \" annotated Dubbo's @Service Components &#123; \" + beanDefinitionHolders + \" &#125; were scanned under package[\" + packageToScan + \"]\"); &#125; &#125; else &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"No Spring Bean annotating Dubbo's @Service was found under package[\" + packageToScan + \"]\"); &#125; &#125; &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; ä¸Šé¢ä»£ç ä¸»è¦åšäº†å››ä»¶äº‹æƒ…ï¼Œå¦‚ä¸‹ï¼š åˆ›å»ºç±»è·¯å¾„æ‰«æå™¨ DubboClassPathBeanDefinitionScannerï¼ŒæŒ‡å®šæ‰«æçš„æ³¨è§£åŒ…å«Dubboçš„@Serviceæ³¨è§£ã€‚ è·å–BeanNameGeneratorå¯¹è±¡ï¼Œç”¨äº @Service æ ‡æ³¨ç±»çš„Beanå®šä¹‰åç§°ã€‚ ä½¿ç”¨æ‰«æå™¨æ‰«æåŒ…ï¼Œæå‡@Serviceæ ‡æ³¨çš„ç±»ä¸ºSpring Beanï¼Œå¹¶æ³¨å†Œåˆ°æ³¨å†Œè¡¨ä¸­ã€‚ è·å–ç¬¬3æ­¥çš„Spring Beançš„BeanDefinitionHolderé›†åˆï¼Œå°†ç”¨äºåˆ›å»ºDubboçš„ServiceBeanå¯¹è±¡ã€‚ ä»£ç ä¸­çš„ä¸»è¦é€»è¾‘å·²ç»è¯¦ç»†æ ‡æ³¨ï¼Œèƒ–å‹è‡ªå·±ç…ç…ï¼Œä¸‹é¢æˆ‘ä»¬ç®€å•åˆ†æä¸‹æ‰«æå™¨çš„åŸç†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105ClassPathBeanDefinitionScanner#scan(String... basePackages) &#123; int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); // æ‰«æé€»è¾‘ doScan(basePackages); // Register annotation config processors, if necessary. if (this.includeAnnotationConfig) &#123; AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); &#125; return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart); &#125; // æ‰«æåŒ…é€»è¾‘ protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, \"At least one base package must be specified\"); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) &#123; // ä»åŒ…ä¸­è·å–å€™é€‰BeanDefinition Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) &#123; ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); // ä½¿ç”¨beanNameGenerator ç”ŸæˆBeanDefinitionçš„åç§° String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); &#125; // æ˜¯å¦æ˜¯å€™é€‰BeanDefinition if (checkCandidate(beanName, candidate)) &#123; BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // æ³¨å†Œåˆ°æ³¨å†Œè¡¨ registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; return beanDefinitions; &#125; /** * ä»åŒ…ä¸­è·å–BeanDefinitioné›†åˆ * * Scan the class path for candidate components. * @param basePackage the package to check for annotated classes * @return a corresponding Set of autodetected bean definitions */ public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) &#123; Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try &#123; // ç±»è·¯å¾„ä¸‹çš„æŒ‡å®šåŒ…ä¸‹çš„æ‰€æœ‰.classæ–‡ä»¶ ï¼ˆå¦‚ï¼šclasspath*:com/code/resource/reading/consumer/annotation/consumer/**/*.classï¼‰ String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) &#123; if (traceEnabled) &#123; logger.trace(\"Scanning \" + resource); &#125; if (resource.isReadable()) &#123; try &#123; MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); // æ˜¯å¦æ˜¯å€™é€‰ BeanDefinition if (isCandidateComponent(metadataReader)) &#123; // åˆ›å»º BeanDefinition ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (isCandidateComponent(sbd)) &#123; if (debugEnabled) &#123; logger.debug(\"Identified candidate component class: \" + resource); &#125; candidates.add(sbd); &#125; else &#123; if (debugEnabled) &#123; logger.debug(\"Ignored because not a concrete top-level class: \" + resource); &#125; &#125; &#125; else &#123; if (traceEnabled) &#123; logger.trace(\"Ignored because not matching any filter: \" + resource); &#125; &#125; &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException( \"Failed to read candidate component class: \" + resource, ex); &#125; &#125; else &#123; if (traceEnabled) &#123; logger.trace(\"Ignored because not readable: \" + resource); &#125; &#125; &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex); &#125; return candidates; &#125; æˆ‘ä»¬åªè¦å¤§è‡´äº†è§£ä¸‹æ‰«æå™¨æ˜¯æ€ä¹ˆæŠŠæŒ‡å®šåŒ…ä¸‹çš„æ³¨è§£æ ‡æ³¨çš„ç±»æå‡ä¸ºSpring Beanå°±å¯ä»¥äº†ã€‚æœ‰äº†ç›®æ ‡ç±»çš„Beanå®šä¹‰ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬åˆ†æDubboæ˜¯å¦‚ä½•åˆ›å»ºè¯¥ç›®æ ‡ç±»å¯¹åº”çš„ServiceBeanå¯¹è±¡çš„ã€‚ åˆ›å»ºServiceBeanå¹¶æ³¨å†Œåˆ°æ³¨å†Œè¡¨ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;/** * Registers &#123;@link ServiceBean&#125; from new annotated &#123;@link Service&#125; &#123;@link BeanDefinition&#125; * * @param beanDefinitionHolder @Serviceæ ‡æ³¨çš„ç±»çš„BeanDefinitionHolder * @param registry æ³¨å†Œè¡¨ * @param scanner æ‰«æå™¨ * @see ServiceBean * @see BeanDefinition */ private void registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry, DubboClassPathBeanDefinitionScanner scanner) &#123; // ä»holderä¸­å–å‡ºBeanDefinitionï¼Œå¹¶è§£æå‡ºå¯¹åº”çš„ç±» Class&lt;?&gt; beanClass = resolveClass(beanDefinitionHolder); // è·å¾—@Service æ³¨è§£ Service service = findAnnotation(beanClass, Service.class); // è·å¾—æ³¨è§£æ ‡æ³¨ç±»çš„æ¥å£ Class&lt;?&gt; interfaceClass = resolveServiceInterfaceClass(beanClass, service); // è·å¾—Beançš„åå­— String annotatedServiceBeanName = beanDefinitionHolder.getBeanName(); // åˆ›å»ºAbstractBeanDefinition å¯¹è±¡ ï¼Œè¿™é‡ŒçœŸæ­£åˆ›å»ºServiceBean AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName); // é‡æ–°ç”ŸæˆBean çš„åå­— ã€æ ¼å¼ï¼šServiceBean:$&#123;interfaceClassName&#125;:$&#123;version&#125;:$&#123;group&#125;ã€‘ï¼Œé‡æ–°åˆ›å»ºçš„ServiceBeanåç§°æ˜¯æŠŠä¸Šé¢çš„BeanDefinitionæ³¨å†Œåˆ°æ³¨å†Œè¡¨ä¸­ï¼Œéœ€è¦ä¸€ä¸ªåç§° String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName); // æ ¡éªŒåœ¨ æ³¨å†Œè¡¨ ä¸­æ˜¯å¦å·²ç»å­˜åœ¨beanNameï¼Œè‹¥ä¸å­˜åœ¨åˆ™è¿›è¡Œæ³¨å†Œ if (scanner.checkCandidate(beanName, serviceBeanDefinition)) &#123; // æ³¨å†Œ registry.registerBeanDefinition(beanName, serviceBeanDefinition); if (logger.isInfoEnabled()) &#123; logger.warn(\"The BeanDefinition[\" + serviceBeanDefinition + \"] of ServiceBean has been registered with name : \" + beanName); &#125; &#125; else &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"The Duplicated BeanDefinition[\" + serviceBeanDefinition + \"] of ServiceBean[ bean name : \" + beanName + \"] was be found , Did @DubboComponentScan scan to same package in many times?\"); &#125; &#125; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; ä¸Šé¢çš„æ–¹æ³•ä¸»è¦æ˜¯ä¸ºåˆ›å»ºServiceBeanæä¾›æ¡ä»¶ï¼Œå¦‚ï¼šè·å–Dubboçš„@Serviceæ ‡æ³¨ç±»çš„ClassåŠæ¥å£ã€è·å–@Serviceä¿¡æ¯ã€è·å–Dubboçš„@Serviceæ ‡æ³¨ç±»çš„Beanå®šä¹‰çš„åç§°ã€‚æœ‰äº†è¿™äº›ä¿¡æ¯ï¼Œå°±å¯ä»¥åˆ›å»ºç›®æ ‡æœåŠ¡ç±»ï¼ˆDubboçš„@Serviceæ ‡æ³¨çš„ç±»ï¼‰çš„ServiceBeanã€‚åœ¨åˆ†æåˆ›å»ºServiceBeanä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹ç›®æ ‡æœåŠ¡ç±»çš„æ¥å£è·å–é€»è¾‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * è·å¾—@Service æ³¨è§£çš„ç±»çš„æ¥å£ * * @param annotatedServiceBeanClass * @param service * @return */ private Class&lt;?&gt; resolveServiceInterfaceClass(Class&lt;?&gt; annotatedServiceBeanClass, Service service) &#123; // ä»æ³¨è§£å±æ€§ä¸­è·å– Class&lt;?&gt; interfaceClass = service.interfaceClass(); if (void.class.equals(interfaceClass)) &#123; interfaceClass = null; // è·å¾—@Service æ³¨è§£çš„interfaceName å±æ€§ String interfaceClassName = service.interfaceName(); // å¦‚æœå­˜åœ¨ï¼Œè·å¾—å…¶å¯¹åº”çš„ç±» if (StringUtils.hasText(interfaceClassName)) &#123; if (ClassUtils.isPresent(interfaceClassName, classLoader)) &#123; interfaceClass = resolveClassName(interfaceClassName, classLoader); &#125; &#125; &#125; //ä»æ³¨è§£å±æ€§ä¸­è·å¾—ä¸åˆ°ï¼Œåˆ™ä»è¢«æ³¨è§£çš„ç±»ä¸Šè·å¾—å…¶å®ç°çš„ç¬¬ä¸€ä¸ªæ¥å£ if (interfaceClass == null) &#123; // è·å–æ¥å£åˆ—è¡¨ Class&lt;?&gt;[] allInterfaces = annotatedServiceBeanClass.getInterfaces(); // å­˜åœ¨çš„è¯å–ç¬¬ä¸€ä¸ªæ¥å£ if (allInterfaces.length &gt; 0) &#123; interfaceClass = allInterfaces[0]; &#125; &#125; Assert.notNull(interfaceClass,\"@Service interfaceClass() or interfaceName() or interface class must be present!\"); Assert.isTrue(interfaceClass.isInterface(),\"The type that was annotated @Service is not an interface!\"); return interfaceClass; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; è·å–ç›®æ ‡æœåŠ¡ç±»çš„æ¥å£è§„åˆ™æ˜¯å…ˆä»@Serviceæ³¨è§£å±æ€§ä¸­å–ï¼Œæ²¡æœ‰è®¾ç½®å†è·å–ç›®æ ‡æœåŠ¡ç±»çš„ç¬¬ä¸€ä¸ªå®ç°æ¥å£ã€‚ä¸‹é¢æˆ‘ä»¬æ¥åˆ†æä¸‹ServiceBeançš„å®šä¹‰å¦‚ä½•ç”Ÿæˆï¼Œå¯ä»¥å¯¹æ¯”ä¸‹XMLé…ç½®çš„ç”Ÿæˆè§„åˆ™ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;/** * åˆ›å»ºAbstraceBeanDefinitionå¯¹è±¡ * * @param service @Service æ³¨è§£ * @param interfaceClass ç›®æ ‡æœåŠ¡ç±»çš„æ¥å£ * @param annotatedServiceBeanName ç›®æ ‡æœåŠ¡ç±»çš„Beanå®šä¹‰çš„åç§° * @return */ private AbstractBeanDefinition buildServiceBeanDefinition(Service service, Class&lt;?&gt; interfaceClass, String annotatedServiceBeanName) &#123; // åˆ›å»ºServiceBeançš„BeanDefinitionBuilderå¯¹è±¡ BeanDefinitionBuilder builder = rootBeanDefinition(ServiceBean.class); // è·å¾—ServiceBeançš„AbstractBeanDefinition å¯¹è±¡ AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); // è·å¾— MutablePropertyValueså¯¹è±¡ï¼Œåç»­å¯ä»¥é€šè¿‡å®ƒä¸ºServiceBeanæ·»åŠ å±æ€§ MutablePropertyValues propertyValues = beanDefinition.getPropertyValues(); // åˆ›å»ºAnnotationPropertyValuesAdapter å¯¹è±¡ï¼Œæ·»åŠ åˆ°propertyValuesä¸­ã€‚æ³¨æ„æ˜¯å°†æ³¨è§£ä¸Šçš„å±æ€§è®¾ç½®åˆ°PropertyValuesä¸­ï¼Œå¹¶ä¸”æŒ‡å®šå“ªäº›å±æ€§è¦å¿½ç•¥ã€‚è¢«å¿½ç•¥çš„å±æ€§ä¼šå•ç‹¬è®¾ç½®ã€‚ String[] ignoreAttributeNames = of(\"provider\", \"monitor\", \"application\", \"module\", \"registry\", \"protocol\", \"interface\"); propertyValues.addPropertyValues(new AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames)); // è®¾ç½®ServiceBean ref å±æ€§ï¼Œå³@Serviceæ ‡æ³¨çš„ç±»çš„Beanå®šä¹‰åç§° addPropertyReference(builder, \"ref\", annotatedServiceBeanName); // è®¾ç½®ServiceBeançš„ interface å±æ€§ builder.addPropertyValue(\"interface\", interfaceClass.getName()); // æ·»åŠ ServiceBeançš„ provider å±æ€§ String providerConfigBeanName = service.provider(); if (StringUtils.hasText(providerConfigBeanName)) &#123; addPropertyReference(builder, \"provider\", providerConfigBeanName); &#125; // æ·»åŠ ServiceBeançš„monitorå±æ€§ String monitorConfigBeanName = service.monitor(); if (StringUtils.hasText(monitorConfigBeanName)) &#123; addPropertyReference(builder, \"monitor\", monitorConfigBeanName); &#125; // æ·»åŠ ServiceBean çš„ application å±æ€§ String applicationConfigBeanName = service.application(); if (StringUtils.hasText(applicationConfigBeanName)) &#123; addPropertyReference(builder, \"application\", applicationConfigBeanName); &#125; // æ·»åŠ ServiceBeançš„ module å±æ€§å¯¹åº”çš„ ModuleConfig Bean å¯¹è±¡ String moduleConfigBeanName = service.module(); if (StringUtils.hasText(moduleConfigBeanName)) &#123; addPropertyReference(builder, \"module\", moduleConfigBeanName); &#125; //-------------- ä¸‹é¢ä¸¤ä¸ªå±æ€§å’Œä¸Šé¢çš„ä¸ä¸€æ ·ï¼Œå› ä¸ºå¯èƒ½ä¼šæœ‰å¤šä¸ª ï¼Œå³å¤šæ³¨å†Œä¸­å¿ƒï¼Œå¤šåè®®çš„æƒ…å†µ-------------------/ // æ·»åŠ ServiceBeançš„ registries å±æ€§ String[] registryConfigBeanNames = service.registry(); List&lt;RuntimeBeanReference&gt; registryRuntimeBeanReferences = toRuntimeBeanReferences(registryConfigBeanNames); if (!registryRuntimeBeanReferences.isEmpty()) &#123; builder.addPropertyValue(\"registries\", registryRuntimeBeanReferences); &#125; // æ·»åŠ ServiceBeançš„ protocols å±æ€§ String[] protocolConfigBeanNames = service.protocol(); List&lt;RuntimeBeanReference&gt; protocolRuntimeBeanReferences = toRuntimeBeanReferences(protocolConfigBeanNames); if (!protocolRuntimeBeanReferences.isEmpty()) &#123; builder.addPropertyValue(\"protocols\", protocolRuntimeBeanReferences); &#125; return builder.getBeanDefinition(); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; ä¸Šé¢çš„ä»£ç å°±æ˜¯ä¸ºServiceBeanè®¾ç½®ç®€å•å±æ€§å€¼å’Œå¼•ç”¨ç±»å‹çš„å€¼ï¼Œå½“ServiceBeançš„å±æ€§æ˜¯å¼•ç”¨ç±»å‹æ—¶ï¼Œè§£æå™¨ä¼šä¾æ®ä¾èµ–beançš„nameåˆ›å»ºä¸€ä¸ªRuntimeBeanReferenceå¯¹åƒï¼Œå°†è¿™ä¸ªå¯¹åƒæ”¾å…¥ServiceBeançš„BeanDefinitionçš„MutablePropertyValuesä¸­ã€‚ServiceBeançš„Beanå®šä¹‰åˆ›å»ºå®Œæˆåï¼Œæ¥ç€å°±æŠŠè¯¥Beanå®šä¹‰æ³¨å†Œåˆ°æ³¨å†Œè¡¨ä¸­ã€‚è‡³æ­¤ï¼Œæ‰«æ @Service æ³¨è§£çš„Beanåç½®å¤„ç†å™¨é€»è¾‘å·²ç»åˆ†æå®Œæ¯•ã€‚ä¸‹é¢æˆ‘ä»¬å¼€å§‹åˆ†ææ‰«æ @Reference æ³¨è§£çš„åç½®å¤„ç†å™¨ã€‚ åˆ›å»ºæ‰«æ @Reference æ³¨è§£çš„åç½®å¤„ç†å™¨123456789101112131415161718public class DubboComponentScanRegistrar implements ImportBeanDefinitionRegistrar &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * Registers &#123;@link ReferenceAnnotationBeanPostProcessor&#125; into &#123;@link BeanFactory&#125; * * @param registry &#123;@link BeanDefinitionRegistry&#125; */ private void registerReferenceAnnotationBeanPostProcessor(BeanDefinitionRegistry registry) &#123; // Register @Reference Annotation Bean Processor BeanRegistrar.registerInfrastructureBean(registry, ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor.class); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; åˆ›å»ºæ‰«æ @Reference æ³¨è§£çš„åç½®å¤„ç†å™¨éœ€è¦æ³¨æ„è¯¥Beanå®šä¹‰çš„åç§°æ˜¯ referenceAnnotationBeanPostProcessorï¼Œæ˜¯å¸¸é‡ç»´æŠ¤çš„ã€‚ä¸‹é¢æˆ‘ä»¬å¼€å§‹åˆ†æReferenceAnnotationBeanPostProcessorçš„é€»è¾‘ï¼Œçœ‹å®ƒåˆæ˜¯å¦‚ä½•ä¸º @Reference æ³¨è§£çš„å±æ€§æˆ–æ–¹æ³•å¼•å…¥ä»£ç†å¯¹è±¡ã€‚ ReferenceAnnotationBeanPostProcessor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * &#123;@link org.springframework.beans.factory.config.BeanPostProcessor&#125; implementation * that Consumer service &#123;@link Reference&#125; annotated fields * @since 2.5.7 */public class ReferenceAnnotationBeanPostProcessor extends AnnotationInjectedBeanPostProcessor&lt;Reference&gt; implements ApplicationContextAware, ApplicationListener &#123; /** * The bean name of &#123;@link ReferenceAnnotationBeanPostProcessor&#125; */ public static final String BEAN_NAME = \"referenceAnnotationBeanPostProcessor\"; /** * Cache size */ private static final int CACHE_SIZE = Integer.getInteger(BEAN_NAME + \".cache.size\", 32); /** * ReferenceBean ç¼“å­˜ Map,key:Reference Bean çš„åå­— */ private final ConcurrentMap&lt;String, ReferenceBean&lt;?&gt;&gt; referenceBeanCache = new ConcurrentHashMap&lt;String, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE); /** * ReferenceBeanInvocationHandler ç¼“å­˜ Mapï¼Œkeyï¼šReference Beançš„åå­— */ private final ConcurrentHashMap&lt;String, ReferenceBeanInvocationHandler&gt; localReferenceBeanInvocationHandlerCache = new ConcurrentHashMap&lt;String, ReferenceBeanInvocationHandler&gt;(CACHE_SIZE); /** * ä½¿ç”¨å±æ€§è¿›è¡Œæ³¨å…¥çš„ @Reference Bean çš„ç¼“å­˜ Mapã€‚ï¼ˆè¿™ç§æ–¹å¼ä½¿ç”¨çš„è¾ƒå¤šï¼‰ */ private final ConcurrentMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; injectedFieldReferenceBeanCache = new ConcurrentHashMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE); /** * ä½¿ç”¨æ–¹æ³•è¿›è¡Œæ³¨å…¥çš„ @Reference Bean çš„ç¼“å­˜ Map */ private final ConcurrentMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; injectedMethodReferenceBeanCache = new ConcurrentHashMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE); /** * åº”ç”¨ä¸Šä¸‹æ–‡ */ private ApplicationContext applicationContext; /** * Gets all beans of &#123;@link ReferenceBean&#125; * * @return non-null read-only &#123;@link Collection&#125; * @since 2.5.9 */ public Collection&lt;ReferenceBean&lt;?&gt;&gt; getReferenceBeans() &#123; return referenceBeanCache.values(); &#125; /** * Get &#123;@link ReferenceBean&#125; &#123;@link Map&#125; in injected field. * * @return non-null &#123;@link Map&#125; * @since 2.5.11 */ public Map&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; getInjectedFieldReferenceBeanMap() &#123; return Collections.unmodifiableMap(injectedFieldReferenceBeanCache); &#125; /** * Get &#123;@link ReferenceBean&#125; &#123;@link Map&#125; in injected method. * * @return non-null &#123;@link Map&#125; * @since 2.5.11 */ public Map&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; getInjectedMethodReferenceBeanMap() &#123; return Collections.unmodifiableMap(injectedMethodReferenceBeanCache); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; ä¸Šé¢ä»£ç æ˜¯æ‰«æ @Reference æ³¨è§£çš„åç½®å¤„ç†å™¨çš„å±æ€§ä¿¡æ¯ï¼Œè¯¥ç±»ç»§æ‰¿äº†AnnotationInjectedBeanPostProcessoræŠ½è±¡ç±»ï¼Œè¯¥ç±»ä¸­æœ‰å‡ ä¸ªå¾ˆé‡è¦çš„æ–¹æ³•å’Œç±»ï¼Œå®ƒä»¬å±äºSpringæºç çš„çŸ¥è¯†ç‚¹ï¼Œä¸ºäº†ä½¿æ•´ä¸ªé€»è¾‘å®Œæ•´æˆ‘ä»¬è¿˜æ˜¯ä¸€èµ·æ¥çœ‹çœ‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public abstract class AnnotationInjectedBeanPostProcessor&lt;A extends Annotation&gt; extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware, BeanClassLoaderAware, EnvironmentAware, DisposableBean &#123; // $&#123;çœç•¥å…¶ä»–çš„ä»£ç &#125; // 1. Beanåç½®å¤„ç†å™¨çš„å›è°ƒæ–¹æ³• @Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123; if (beanType != null) &#123; // è·å–BeanTypeä¸­çš„å­—æ®µå’Œæ–¹æ³•ä¸Šçš„æ³¨è§£ï¼Œå³å¯¹äºDubboæ¡†æ¶æ¥è¯´å°±æ˜¯æŸ¥æ‰¾Beanæ‰€æœ‰æ ‡æ³¨äº†@Referenceçš„å­—æ®µå’Œæ–¹æ³•ã€‚ InjectionMetadata metadata = findInjectionMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); &#125; &#125; // 5. åˆ›å»ºBeanå¯¹è±¡çš„è¿‡ç¨‹ä¸­éœ€è¦å¡«å……Beanå¯¹è±¡çš„å±æ€§å€¼ï¼Œä¼šè°ƒç”¨è¯¥æ–¹æ³•ã€‚å³åœ¨Springçš„Beanåˆå§‹åŒ–å‰ä¼šè§¦å‘è¯¥æ–¹æ³•ã€‚ @Override public PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException &#123; // è·å–Beanå¯¹è±¡çš„ç±»ä¸­çš„å­—æ®µå’Œæ–¹æ³•çš„æ³¨è§£å¯¹è±¡ - AnnotatedInjectionMetadataï¼Œå³å¯¹äºDubboæ¡†æ¶æ¥è¯´å°±æ˜¯æŸ¥æ‰¾Beanæ‰€æœ‰æ ‡æ³¨äº†@Referenceçš„å­—æ®µå’Œæ–¹æ³•ã€‚ InjectionMetadata metadata = findInjectionMetadata(beanName, bean.getClass(), pvs); try &#123; // è°ƒç”¨AnnotatedInjectionMetadataçš„injectæ–¹æ³•ï¼Œå¯¹å­—æ®µæˆ–æ–¹æ³•è¿›è¡Œåå°„ç»‘å®š metadata.inject(bean, beanName, pvs); &#125; catch (BeanCreationException ex) &#123; throw ex; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, \"Injection of @\" + getAnnotationType().getName() + \" dependencies is failed\", ex); &#125; return pvs; &#125; /** * 4. å±æ€§å’Œæ–¹æ³•æ³¨è§£åŒ…è£…å¯¹è±¡ * &#123;@link A&#125; &#123;@link InjectionMetadata&#125; implementation */ private class AnnotatedInjectionMetadata extends InjectionMetadata &#123; // å­—æ®µæ³¨è§£å¯¹è±¡é›†åˆ private final Collection&lt;AnnotatedFieldElement&gt; fieldElements; // æ–¹æ³•æ³¨è§£å¯¹è±¡é›†åˆ private final Collection&lt;AnnotatedMethodElement&gt; methodElements; public AnnotatedInjectionMetadata(Class&lt;?&gt; targetClass, Collection&lt;AnnotatedFieldElement&gt; fieldElements, Collection&lt;AnnotatedMethodElement&gt; methodElements) &#123; super(targetClass, combine(fieldElements, methodElements)); this.fieldElements = fieldElements; this.methodElements = methodElements; &#125; public Collection&lt;AnnotatedFieldElement&gt; getFieldElements() &#123; return fieldElements; &#125; public Collection&lt;AnnotatedMethodElement&gt; getMethodElements() &#123; return methodElements; &#125; &#125; /** * 3. æ–¹æ³•æ³¨è§£ * &#123;@link A&#125; &#123;@link Method&#125; &#123;@link InjectionMetadata.InjectedElement&#125; */ private class AnnotatedMethodElement extends InjectionMetadata.InjectedElement &#123; // æ–¹æ³•å¯¹è±¡ private final Method method; // æ³¨è§£ private final A annotation; private volatile Object object; protected AnnotatedMethodElement(Method method, PropertyDescriptor pd, A annotation) &#123; super(method, pd); this.method = method; this.annotation = annotation; &#125; @Override protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable &#123; // è·å–å±æ€§ç±»å‹ Class&lt;?&gt; injectedType = pd.getPropertyType(); // Hå¶å»ä¾èµ– Object injectedObject = getInjectedObject(annotation, bean, beanName, injectedType, this); // è®¾ç½®å¯è®¿é—® ReflectionUtils.makeAccessible(method); // åå°„æ³¨å…¥ä¾èµ– method.invoke(bean, injectedObject); &#125; &#125; /** * 2. å±æ€§æ³¨è§£ * &#123;@link A&#125; &#123;@link Field&#125; &#123;@link InjectionMetadata.InjectedElement&#125; */ public class AnnotatedFieldElement extends InjectionMetadata.InjectedElement &#123; // å±æ€§å¯¹è±¡ private final Field field; // æ³¨è§£ private final A annotation; private volatile Object bean; protected AnnotatedFieldElement(Field field, A annotation) &#123; super(field, null); this.field = field; this.annotation = annotation; &#125; @Override protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable &#123; // è·å–å±æ€§ç±»å‹ Class&lt;?&gt; injectedType = field.getType(); // è·å–ä¾èµ– Object injectedObject = getInjectedObject(annotation, bean, beanName, injectedType, this); // è®¾ç½®å¯è®¿é—® ReflectionUtils.makeAccessible(field); // åå°„è®¾ç½®å€¼ field.set(bean, injectedObject); &#125; &#125;&#125;public class InjectionMetadata &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; // 3. éå†æ³¨å…¥å…ƒç´ å¯¹è±¡ï¼ˆå¯èƒ½æ˜¯å­—æ®µï¼Œä¹Ÿå¯èƒ½æ˜¯æ–¹æ³•ï¼‰ï¼Œå®Œæˆæ³¨å…¥ public void inject(Object target, String beanName, PropertyValues pvs) throws Throwable &#123; // Collection&lt;InjectedElement&gt; elementsToIterate = (this.checkedElements != null ? this.checkedElements : this.injectedElements); if (!elementsToIterate.isEmpty()) &#123; boolean debug = logger.isDebugEnabled(); for (InjectedElement element : elementsToIterate) &#123; if (debug) &#123; logger.debug(\"Processing injected element of bean '\" + beanName + \"': \" + element); &#125; element.inject(target, beanName, pvs); &#125; &#125; &#125;&#125; ä¸Šé¢çš„ä»£ç æ‰§è¡Œçš„é¡ºåºå·²ç»æ ‡æ³¨ï¼Œæ‰§è¡Œé¡ºåºæ¯”è¾ƒç²—ç•¥ï¼Œå…ˆæŸ¥æ‰¾æœåŠ¡å¼•ç”¨çš„å­—æ®µæˆ–æ–¹æ³•ï¼Œç„¶åè§¦å‘å­—æ®µæˆ–æ–¹æ³•å€¼çš„åå°„æ³¨å…¥ã€‚ä½†æ˜¯ç›®çš„å·²ç»è¾¾åˆ°äº†ï¼Œä»ä»£ç ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ³¨è§£ä¿¡æ¯å·²ç»æ”¶é›†å®Œæ¯•ï¼Œæ¥ä¸‹æ¥å°±æ˜¯è·å–ä¾èµ–å¯¹è±¡äº†ï¼Œæ‰¾åˆ°ä¾èµ–å¯¹è±¡å°±å¯ä»¥é€šè¿‡åå°„æ³¨å…¥ï¼Œå¯¹äº@Referenceæ³¨è§£è€Œè¨€ï¼Œè·å–ä¾èµ–çš„æ–¹æ³•å°±æ˜¯ ReferenceAnnotationBeanPostProcessor#doGetInjectedBeanã€‚ä¸‹é¢æˆ‘ä»¬å¼€å§‹åˆ†æ ReferenceAnnotationBeanPostProcessor ä¸­çš„é€»è¾‘ã€‚ è·å–è¦æ³¨å…¥çš„ä¾èµ–Bean 123456789101112131415161718192021222324252627282930313233343536373839public class ReferenceAnnotationBeanPostProcessor extends AnnotationInjectedBeanPostProcessor&lt;Reference&gt; implements ApplicationContextAware, ApplicationListener &#123; // $&#123;çœç•¥ä»£ç &#125; /** * è·å¾—è¦æ³¨å…¥çš„ ä¾èµ– * * @param reference @Referenceæ³¨è§£ * @param bean @Referenceæ³¨è§£æ ‡æ³¨å±æ€§æˆ–æ–¹æ³•æ‰€åœ¨çš„ç±»çš„å¯¹è±¡ * @param beanName @Referenceæ³¨è§£æ ‡æ³¨å±æ€§æˆ–æ–¹æ³•æ‰€åœ¨çš„ç±»çš„å¯¹è±¡åç§° * @param injectedType è¦æ³¨å…¥ä¾èµ–çš„ç±»å‹ * @param injectedElement æ³¨å…¥å…ƒä¿¡æ¯ * @return * @throws Exception */ @Override protected Object doGetInjectedBean(Reference reference, Object bean, String beanName, Class&lt;?&gt; injectedType, InjectionMetadata.InjectedElement injectedElement) throws Exception &#123; // 1 è·å¾—è¦æ³¨å…¥ä¾èµ–çš„åå­— String referencedBeanName = buildReferencedBeanName(reference, injectedType); // 2 åˆ›å»ºReferenceBean å¯¹è±¡ [æ¯”è¾ƒå¤æ‚] ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referencedBeanName, reference, injectedType, getClassLoader()); // 3 ç¼“å­˜åˆ° injectedFieldReferenceBeanCache æˆ– injectedMethodReferenceBeanCache cacheInjectedReferenceBean(referenceBean, injectedElement); // 4 åˆ›å»º Proxy ä»£ç† Object proxy = buildProxy(referencedBeanName, referenceBean, injectedType); return proxy; &#125;// $&#123;çœç•¥ä»£ç &#125;&#125; doGetInjectedBean æ–¹æ³•ä¸»è¦å®Œæˆä»¥ä¸Š4ä¸ªæµç¨‹ï¼Œæˆ‘ä»¬é‡ç‚¹åˆ†æåˆ›å»ºReferenceBeanå’ŒProxyä»£ç†æµç¨‹ã€‚ åˆ›å»ºReferenceBeanå¯¹è±¡ 123456789101112131415161718192021222324252627282930313233343536public class ReferenceAnnotationBeanPostProcessor extends AnnotationInjectedBeanPostProcessor&lt;Reference&gt; implements ApplicationContextAware, ApplicationListener &#123; // $&#123;çœç•¥ä»£ç &#125;/** * è·å¾— ReferenceBean å¯¹è±¡ * * @param referencedBeanName * @param reference * @param referencedType * @param classLoader * @return * @throws Exception */ private ReferenceBean buildReferenceBeanIfAbsent(String referencedBeanName, Reference reference, Class&lt;?&gt; referencedType, ClassLoader classLoader) throws Exception &#123; // å…ˆä»ç¼“å­˜ä¸­è·å¾—referencedBeanName å¯¹åº”çš„ ReferenceBean å¯¹è±¡ ReferenceBean&lt;?&gt; referenceBean = referenceBeanCache.get(referencedBeanName); // å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¿›è¡Œåˆ›å»ºï¼Œç„¶åæ·»åŠ åˆ°ç¼“å­˜ä¸­ if (referenceBean == null) &#123; ReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder .create(reference, classLoader, applicationContext) // å¼•ç”¨ç±»å‹ä½œä¸ºæ¥å£ç±»å‹ .interfaceClass(referencedType); // åˆ›å»ºReferenceBeanã€1. åˆ›å»ºReferenceBeanå¯¹è±¡ 2.ReferenceBean é…ç½®ã€‘ referenceBean = beanBuilder.build(); referenceBeanCache.put(referencedBeanName, referenceBean); &#125; return referenceBean; &#125;// $&#123;çœç•¥ä»£ç &#125;&#125; buildReferenceBeanIfAbsent æ–¹æ³•åŸºæœ¬æ²¡æœ‰æ ¸å¿ƒé€»è¾‘ï¼Œæ‰€æœ‰çš„é€»è¾‘éƒ½å°è£…åœ¨äº† ReferenceBeanBuilder ä¸­ï¼Œå®ƒæ˜¯ReferenceBeançš„æ„å»ºå™¨ï¼Œæˆ‘ä»¬ç»§ç»­è·Ÿè¿›è¯¥ç±»ã€‚ ReferenceBeanå¯¹è±¡çš„æ„å»ºå™¨ 12345678910111213141516171819202122232425262728class ReferenceBeanBuilder extends AbstractAnnotationConfigBeanBuilder&lt;Reference, ReferenceBean&gt; &#123; /** * å°†æ³¨è§£çš„å±æ€§è®¾ç½®åˆ°ReferenceBeanï¼Œå¿½ç•¥ä»¥ä¸‹å±æ€§ï¼Œè¿™äº›å±æ€§ä¼šå•ç‹¬å¤„ç† */ static final String[] IGNORE_FIELD_NAMES = of(\"application\", \"module\", \"consumer\", \"monitor\", \"registry\"); private ReferenceBeanBuilder(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext) &#123; super(annotation, classLoader, applicationContext); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * åˆ›å»ºReferenceBeanBuilder * * @param annotation * @param classLoader * @param applicationContext * @return */ public static ReferenceBeanBuilder create(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext) &#123; // åˆ›å»º ReferenceBean çš„æ„å»ºå™¨ return new ReferenceBeanBuilder(annotation, classLoader, applicationContext); &#125;&#125;` ç”±äºå¾ˆå¤šå±æ€§éƒ½åœ¨å…¶çˆ¶ç±» AbstractAnnotationConfigBeanBuilder ä¸­ï¼Œå¦‚ä¸Šé¢çš„interfaceClassï¼Œä»¥åŠå¾ˆé‡è¦çš„buildæ–¹æ³•ã€‚æˆ‘ä»¬å†åˆ†æä¸‹è¯¥ç±»ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950abstract class AbstractAnnotationConfigBeanBuilder&lt;A extends Annotation, B extends AbstractInterfaceConfig&gt; &#123; protected final Log logger = LogFactory.getLog(getClass()); /** * æ³¨è§£ */ protected final A annotation; /** * åº”ç”¨ä¸Šä¸‹æ–‡ */ protected final ApplicationContext applicationContext; /** * ç±»åŠ è½½å™¨ */ protected final ClassLoader classLoader; /** * Bean å¯¹è±¡ */ protected Object bean; /** * æ¥å£ */ protected Class&lt;?&gt; interfaceClass; // æ„é€ æ–¹æ³• protected AbstractAnnotationConfigBeanBuilder(A annotation, ClassLoader classLoader, ApplicationContext applicationContext) &#123; Assert.notNull(annotation, \"The Annotation must not be null!\"); Assert.notNull(classLoader, \"The ClassLoader must not be null!\"); Assert.notNull(applicationContext, \"The ApplicationContext must not be null!\"); this.annotation = annotation; this.applicationContext = applicationContext; this.classLoader = classLoader; &#125; public &lt;T extends AbstractAnnotationConfigBeanBuilder&lt;A, B&gt;&gt; T bean(Object bean) &#123; this.bean = bean; return (T) this; &#125; // è®¾ç½®æ¥å£ public &lt;T extends AbstractAnnotationConfigBeanBuilder&lt;A, B&gt;&gt; T interfaceClass(Class&lt;?&gt; interfaceClass) &#123; this.interfaceClass = interfaceClass; return (T) this; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; &#125; ä»¥ä¸Šä»£ç æ¯”è¾ƒç®€å•ï¼Œåªéœ€æ³¨æ„è®¾ç½®çš„æ¥å£å³å¯ï¼Œä¸‹é¢æˆ‘ä»¬åˆ†æåˆ›å»ºReferenceBeançš„buildæ–¹æ³•ã€‚ 123456789101112131415161718192021222324252627282930313233abstract class AbstractAnnotationConfigBeanBuilder&lt;A extends Annotation, B extends AbstractInterfaceConfig&gt; &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * Build &#123;@link B&#125; æ„é€ æ³›å‹Bå¯¹è±¡ï¼Œæ­¤å¤„å°±æ˜¯æ„é€ ReferenceBeanå¯¹è±¡ * * @return non-null * @throws Exception */ public final B build() throws Exception &#123; /** * 1. æ ¡éªŒä¾èµ–ï¼Œç›®å‰æ˜¯ä¸ªç©ºæ–¹æ³• */ checkDependencies(); // 2. åˆ›å»º Bean å¯¹è±¡ï¼Œå…·ä½“å®ç°äº¤ç»™å­ç±» B bean = doBuild(); // 3. é…ç½®Bean å¯¹è±¡ configureBean(bean); if (logger.isInfoEnabled()) &#123; logger.info(\"The bean[type:\" + bean.getClass().getSimpleName() + \"] has been built.\"); &#125; return bean; &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; ä»¥ä¸Šä»£ç ä½¿ç”¨äº†æ¨¡ç‰ˆæ–¹æ³•æ¨¡å¼ï¼Œæˆ‘ä»¬å…ˆçœ‹doBuild()æ–¹æ³•çš„å…·ä½“å®ç°ï¼Œç„¶åå†åˆ†æé…ç½®Beanå¯¹è±¡çš„é€»è¾‘ã€‚ 123456789101112131415161718class ReferenceBeanBuilder extends AbstractAnnotationConfigBeanBuilder&lt;Reference, ReferenceBean&gt; &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * ReferenceBeanBuilder#buildçš„æ–¹æ³•è°ƒç”¨ï¼Œç”¨æ¥åˆ›å»ºReferenceå¯¹è±¡ã€‚ã€å¯¹çˆ¶ç±»æ–¹æ³•çš„é‡å†™ã€‘ * * @return */ @Override protected ReferenceBean doBuild() &#123; // åˆ›å»º ReferenceBeanå¯¹è±¡ return new ReferenceBean&lt;Object&gt;(); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; ä¸€è¡Œä»£ç å°±æå®šäº†ï¼Œç›´æ¥åˆ›å»ºReferenceBeanå¯¹è±¡ï¼Œæˆ‘ä»¬æ¥ç€åˆ†æé…ç½®Beané€»è¾‘ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243abstract class AbstractAnnotationConfigBeanBuilder&lt;A extends Annotation, B extends AbstractInterfaceConfig&gt; &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * é…ç½®ReferenceBeanå¯¹è±¡ * @param bean * @throws Exception */ protected void configureBean(B bean) throws Exception &#123; /** * å‰ç½®é…ç½®Beané€»è¾‘ï¼Œå…·ä½“å®ç°äº¤ç»™å­ç±» */ preConfigureBean(annotation, bean); /** * å°è¯•ä»Springä¸­è·å–@Referenceæ³¨è§£ä¸­é…ç½®çš„registryå±æ€§å€¼å¯¹åº”çš„RegistryConfigå¯¹è±¡é›†åˆï¼Œç„¶åè®¾ç½®åˆ°çš„ReferenceBeanå¯¹è±¡çš„registrieså±æ€§ä¸­ */ configureRegistryConfigs(bean); /** * è®¾ç½®ReferenceBeançš„monitorå±æ€§ï¼ŒåŸç†åŒä¸Š */ configureMonitorConfig(bean); /** * è®¾ç½®ReferenceBeançš„applicationå±æ€§ï¼ŒåŸç†åŒä¸Š */ configureApplicationConfig(bean); /** * è®¾ç½® ReferenceBeançš„moduleå±æ€§ï¼ŒåŸç†åŒä¸Š */ configureModuleConfig(bean); /** * åç½®é…ç½®Beané€»è¾‘ï¼Œå…·ä½“å®ç°äº¤ç»™å­ç±» */ postConfigureBean(annotation, bean); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; ä¸Šé¢ä»£ç ä¹Ÿæ˜¯ä½¿ç”¨æ¨¡ç‰ˆæ–¹æ³•æ¨¡å¼ï¼Œå…¶ä¸­ReferenceBeançš„registriesã€monitorã€applicationã€moduleå±æ€§çš„å€¼æ˜¯é€šè¿‡è¯¥æ–¹æ³•è¿›è¡Œè®¾ç½®çš„ï¼Œå‰ç½®é…ç½®Beanå’Œåç½®é…ç½®Beançš„é€»è¾‘æ˜¯ç”±å­ç±»å®ç°çš„ï¼Œæˆ‘ä»¬ç»§ç»­è·Ÿè¿›å»ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class ReferenceBeanBuilder extends AbstractAnnotationConfigBeanBuilder&lt;Reference, ReferenceBean&gt; &#123; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125; /** * ReferenceBean çš„å‰ç½®é…ç½® * @param reference * @param referenceBean */ @Override protected void preConfigureBean(Reference reference, ReferenceBean referenceBean) &#123; Assert.notNull(interfaceClass, \"The interface class must set first!\"); // åˆ›å»ºDataBinderå¯¹è±¡,å°†ReferenceBeanåŒ…è£…æˆDataBinder,è¿›è¡Œå±æ€§ç»‘å®šï¼Œç»‘å®šåˆ°çš„å¯¹è±¡å°±æ˜¯ReferenceBean DataBinder dataBinder = new DataBinder(referenceBean); // Register CustomEditors for special fields // æ³¨å†ŒæŒ‡å®šå±æ€§çš„è‡ªå®šä¹‰Editor dataBinder.registerCustomEditor(String.class, \"filter\", new StringTrimmerEditor(true)); dataBinder.registerCustomEditor(String.class, \"listener\", new StringTrimmerEditor(true)); dataBinder.registerCustomEditor(Map.class, \"parameters\", new PropertyEditorSupport() &#123; public void setAsText(String text) throws java.lang.IllegalArgumentException &#123; // Trim all whitespace String content = StringUtils.trimAllWhitespace(text); if (!StringUtils.hasText(content)) &#123; // No content , ignore directly return; &#125; // replace \"=\" to \",\" content = StringUtils.replace(content, \"=\", \",\"); // replace \":\" to \",\" content = StringUtils.replace(content, \":\", \",\"); // String[] to Map Map&lt;String, String&gt; parameters = CollectionUtils.toStringMap(commaDelimitedListToStringArray(content)); setValue(parameters); &#125; &#125;); /** Bind annotation attributes å°†æ³¨è§£çš„å±æ€§è®¾ç½®åˆ°ReferenceBeanä¸­ï¼Œæ’é™¤ &#123;@link IGNORE_FIELD_NAMES&#125; å±æ€§ï¼Œè¿™äº›å±æ€§åç»­å•ç‹¬å¤„ç† &#123;@link AbstractAnnotationConfigBeanBuilder#configureBean(com.alibaba.dubbo.config.AbstractInterfaceConfig) */ dataBinder.bind(new AnnotationPropertyValuesAdapter(reference, applicationContext.getEnvironment(), IGNORE_FIELD_NAMES)); &#125; /** * ReferenceBean çš„åç½®é…ç½® * * @param annotation * @param bean * @throws Exception */ @Override protected void postConfigureBean(Reference annotation, ReferenceBean bean) throws Exception &#123; // è®¾ç½® Spring ä¸Šä¸‹æ–‡åˆ° ReferenceBean ä¸­ï¼Œå¹¶ä¸” å°† Dubbo å’Œ Springå®¹å™¨æ‰“é€šï¼Œå³ è®¾ç½®SpringExtensionFactoryä¸­çš„ä¸Šä¸‹æ–‡ bean.setApplicationContext(applicationContext); // é…ç½®æœåŠ¡æ¥å£ configureInterface(annotation, bean); // å°è¯•ä»Springä¸­è·å–@Referenceæ³¨è§£ä¸­é…ç½®çš„consumerå±æ€§å€¼å¯¹åº”çš„ConsumerConfigå¯¹è±¡ï¼Œç„¶åè®¾ç½®åˆ°çš„ReferenceBeanå¯¹è±¡çš„consumerå±æ€§ä¸­ configureConsumerConfig(annotation, bean); // ä¸»åŠ¨è§¦å‘ ReferenceBean çš„ afterPropertiesSet æ–¹æ³• bean.afterPropertiesSet(); &#125; // $&#123;çœç•¥å…¶ä»–ä»£ç &#125;&#125; è‡³æ­¤ï¼Œåˆ›å»ºReferenceBeanå¯¹è±¡åˆ†æå®Œæ¯•ï¼Œæˆ‘ä»¬å†å›è¿‡å¤´åˆ†æ ReferenceAnnotationBeanPostProcessor#doGetInjectedBean æ–¹æ³•ä¸­çš„åˆ›å»º Proxy å¯¹è±¡çš„é€»è¾‘ã€‚ åˆ›å»ºProxyå¯¹è±¡ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ReferenceAnnotationBeanPostProcessor extends AnnotationInjectedBeanPostProcessor&lt;Reference&gt; implements ApplicationContextAware, ApplicationListener &#123; // $&#123;çœç•¥ä»£ç &#125; /** * åˆ›å»ºProxyä»£ç†å¯¹è±¡ * * @param referencedBeanName * @param referenceBean * @param injectedType * @return */ private Object buildProxy(String referencedBeanName, ReferenceBean referenceBean, Class&lt;?&gt; injectedType) &#123; // 1. åˆ›å»ºReferenceBeanInvocationHandlerå¯¹è±¡ InvocationHandler handler = buildInvocationHandler(referencedBeanName, referenceBean); // 2. ä½¿ç”¨JDKçš„åŠ¨æ€ä»£ç†åˆ›å»ºæœåŠ¡æ¥å£çš„ä»£ç†å¯¹è±¡ Object proxy = Proxy.newProxyInstance(getClassLoader(), new Class[]&#123;injectedType&#125;, handler); return proxy; &#125; /** * åˆ›å»ºReferenceBeanInvocationHandlerå¯¹è±¡ * * @param referencedBeanName æ³¨å…¥ä¾èµ–çš„åå­—ï¼Œå³æœåŠ¡çš„åç§° * @param referenceBean ReferenceBeanå¯¹è±¡ * @return */ private InvocationHandler buildInvocationHandler(String referencedBeanName, ReferenceBean referenceBean) &#123; // ä»ç¼“å­˜ä¸­è·å–å¯¹åº”çš„ handlerå¯¹è±¡ ReferenceBeanInvocationHandler handler = localReferenceBeanInvocationHandlerCache.get(referencedBeanName); // ä¸å­˜åœ¨åˆ™åˆ›å»ºReferenceBeançš„ InvocationHandler å¯¹è±¡ if (handler == null) &#123; handler = new ReferenceBeanInvocationHandler(referenceBean); &#125; // å¦‚æœåº”ç”¨ä¸Šä¸‹æ–‡ä¸­å·²ç»åˆå§‹åŒ–äº†ï¼Œè¯´æ˜å¼•å…¥çš„æœåŠ¡æ˜¯æœ¬åœ°çš„@Service Bean ï¼Œåˆ™å°†å¼•å…¥çš„DubboæœåŠ¡çš„InvocationHandleræ·»åŠ åˆ°æœ¬åœ°ç¼“å­˜ä¸­ï¼Œä¸è¿›è¡Œåˆå§‹åŒ–ï¼ˆè¦æƒ³åˆå§‹åŒ–ï¼Œå¼•å…¥çš„æœåŠ¡å¿…é¡»æ˜¯å·²ç»æš´éœ²çš„çŠ¶æ€ï¼‰ if (applicationContext.containsBean(referencedBeanName)) &#123; // ReferenceBeanInvocationHandler's initialization has to wait for current local @Service Bean has been exported. localReferenceBeanInvocationHandlerCache.put(referencedBeanName, handler); &#125; else &#123; // å¦‚æœåº”ç”¨ä¸Šä¸‹æ–‡ä¸­æ²¡æœ‰ï¼Œåˆ™è¯´æ˜æ˜¯å¼•å…¥çš„æ˜¯è¿œç¨‹çš„æœåŠ¡å¯¹è±¡ï¼Œåˆ™ç«‹å³åˆå§‹åŒ– handler.init(); &#125; return handler; &#125;// $&#123;çœç•¥ä»£ç &#125;&#125; ä»¥ä¸Šä»£ç åªåšäº†ä¸€ä»¶äº‹æƒ…ï¼Œä¸ºæœåŠ¡æ¥å£åˆ›å»ºä¸€ä¸ªä»£ç†å¯¹è±¡ï¼Œåˆ›å»ºä»£ç†å¯¹è±¡æ˜¯ä½¿ç”¨JDKçš„åŠ¨æ€ä»£ç†ã€‚å…¶ä¸­ä»£ç†å¯¹è±¡çš„æ‰§è¡Œé€»è¾‘å°è£…åœ¨ReferenceBeanInvocationHandlerå¯¹è±¡ä¸­ï¼Œä¸‹é¢æˆ‘ä»¬å°±æ¥è¯¦ç»†åˆ†æè¯¥Handlerã€‚ ReferenceBeanInvocationHandler 1234567891011121314151617181920212223242526272829303132/** * å®ç°äº† Dubbo çš„ InvocationHandleræ¥å£ */ private static class ReferenceBeanInvocationHandler implements InvocationHandler &#123; /** * ReferenceBeanå¯¹è±¡ */ private final ReferenceBean referenceBean; /** * Bean å¯¹è±¡(å¼•ç”¨çš„æœåŠ¡) */ private Object bean; private ReferenceBeanInvocationHandler(ReferenceBean referenceBean) &#123; this.referenceBean = referenceBean; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // è°ƒç”¨ Bean çš„å¯¹åº”çš„æ–¹æ³• return method.invoke(bean, args); &#125; /** * 1 é€šè¿‡åˆå§‹åŒ–æ–¹æ³•ï¼Œè·å¾— ReferenceBean.ref (å¼•ç”¨çš„æœåŠ¡)ï¼Œå³ä»£ç†å¯¹è±¡ * 2 è°ƒç”¨ReferenceBean#get()æ–¹æ³•ï¼Œè¿›è¡Œå¼•ç”¨çš„Beançš„åˆå§‹åŒ–ï¼Œæœ€åè¿”å›æœåŠ¡æ¥å£ä»£ç†å¯¹è±¡ */ private void init() &#123; this.bean = referenceBean.get(); &#125; &#125; ReferenceBeanInvocationHandleræ˜¯ReferenceAnnotationBeanPostProcessorçš„é™æ€å†…éƒ¨ç±»ï¼Œå®ç°äº†InvocationHanderæ¥å£ã€‚å…¶ä¸­referenceBeanå±æ€§å€¼æ˜¯é€šè¿‡æ„é€ æ–¹æ³•è®¾ç½®çš„ï¼Œbeanå±æ€§çš„å€¼å°±æ˜¯å¼•ç”¨çš„æœåŠ¡ï¼Œå³æœåŠ¡æ¥å£ä»£ç†å¯¹è±¡ã€‚invokeæ–¹æ³•æ˜¯å›è°ƒæ–¹æ³•ï¼Œå½“æ¶ˆè´¹æ–¹é€šè¿‡åˆ›å»ºçš„proxyè°ƒç”¨æœåŠ¡æ–¹æ³•å°±ä¼šå›è°ƒã€‚è‡³æ­¤ï¼Œ@Reference æ‰€éœ€è¦çš„ä¾èµ–å·²ç»åˆ›å»ºå®Œæ¯•ï¼Œé€šè¿‡åå°„è®¾ç½®åˆ°æ‰€éœ€ç»„ä»¶ä¸­å³å¯ã€‚ Dubboæ³¨è§£é…ç½®æµç¨‹æ€»ç»“ å‰é¢å·²ç»è¯¦ç»†åˆ†æDubboæ³¨è§£é…ç½®çš„æµç¨‹ï¼Œè¿™é‡Œè¿›è¡Œå°ç»“ã€‚Dubboçš„æ³¨è§£è§£ææœºåˆ¶ä¸»è¦ä¾èµ–ä¸Šå›¾ä¸­çš„æ ¸å¿ƒç»„ä»¶ã€‚å¦‚æœç”¨æˆ·ä½¿ç”¨äº†é…ç½®æ–‡ä»¶ï¼Œåˆ™Dubboæ¡†æ¶æŒ‰éœ€ç”Ÿæˆå¯¹åº”çš„Beanã€‚Dubboæ¡†æ¶ä¼šå°†æ‰€æœ‰ä½¿ç”¨Dubboçš„æ³¨è§£@Serviceæ ‡æ³¨çš„ç±»æå‡ä¸ºBeanï¼Œä¸ºä½¿ç”¨@Referenceæ³¨è§£çš„å­—æ®µæˆ–æ–¹æ³•æ³¨å…¥ä»£ç†å¯¹è±¡ã€‚ æ€»ç»“ä»£ç é‡è¿œæ¯”é¢„è®¡å¾—å¤šï¼Œå†™çš„è¿˜æ˜¯æœ‰ç‚¹æ··ä¹±çš„ã€‚ä»ä»£ç æ•´ä¸ªæµç¨‹å¯ä»¥çœ‹å‡ºï¼Œè™½ç„¶æ³¨è§£ä½¿ç”¨æ›´åŠ ç®€æ´ã€æ–¹ä¾¿ï¼Œä½†æ˜¯èƒŒåçš„å·¥ä½œä¸€ç‚¹éƒ½æ²¡æœ‰å°‘ï¼Œç”šè‡³æ›´å¤šæ›´å¤æ‚ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - XMLé…ç½®","slug":"rpc/xmlé…ç½®","date":"2020-03-28T16:00:00.000Z","updated":"2020-09-03T03:12:53.638Z","comments":false,"path":"posts/a8d76a91/","link":"","permalink":"https://gentryhuang.com/posts/a8d76a91/","excerpt":"","text":"å‰è¨€åœ¨ Dubboæºç åˆ†æ - APIå’Œå±æ€§é…ç½® ä¸­ä»‹ç»äº†Dubboçš„é…ç½®æ‰¿è½½å¯¹è±¡ï¼Œåˆ†æäº†æ ¸å¿ƒçš„é…ç½®ç±»åŠæ–¹æ³•ã€‚äº†è§£äº†APIé…ç½®åXMLé…ç½®å°±å®¹æ˜“å¤šäº†ï¼ŒXMLé…ç½®ç›¸æ¯”è¾ƒAPIé…ç½®çš„åŒºåˆ«åœ¨é…ç½®å¯¹è±¡åˆ›å»ºåŠå…¶å±æ€§çš„è®¾ç½®æ˜¯ç”±Springç®¡ç†çš„ï¼ŒDubboå’ŒSpring XMLèåˆæ˜¯å…³é”®ã€‚ Dubboå’ŒSpringèåˆDubboæ¡†æ¶ç›´æ¥é›†æˆäº†Springçš„èƒ½åŠ›ï¼Œåˆ©ç”¨Springé…ç½®æ–‡ä»¶æ‰©å±•å‡ºè‡ªå®šä¹‰çš„è§£ææ–¹å¼ï¼Œå³ä½¿ç”¨Springçš„è‡ªå®šæ ‡ç­¾ã€‚å…³äºSpringè‡ªå®šæ ‡ç­¾çš„ç¤ºä¾‹ï¼Œåœ¨Springè‡ªå®šä¹‰æ ‡ç­¾ ä¸­æœ‰è¯¦ç»†ä»‹ç»ï¼ŒDubboåŸºäºschemaçš„è®¾è®¡ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œä¸‹é¢æˆ‘ä»¬å°±æ¥åˆ†æä¸‹Dubboæ˜¯æ€ä¹ˆå’ŒSpringèåˆçš„ã€‚ Dubboçš„é…ç½®å¯¹è±¡æ¨¡å‹Dubboçš„é…ç½®å¯¹è±¡æ¨¡å‹å·²ç»åœ¨ [Dubboæºç åˆ†æ - APIå’Œå±æ€§é…ç½®] ä¸­è¯¦ç»†ä»‹ç»è¿‡äº†ï¼Œåœ¨Dubboçš„å‘½åç©ºé—´å¤„ç†å™¨ä¸­ä¹Ÿå¯ä»¥å…·ä½“çœ‹åˆ°å“ªäº›é…ç½®ç±»å’ŒSpringè¿›è¡Œäº¤äº’ï¼Œè¿™é‡Œå°±ä¸å†ä»‹ç»ã€‚ Dubboçš„xsdæ–‡ä»¶dubbo.xsdæ–‡ä»¶æ˜¯ç”¨æ¥çº¦æŸä½¿ç”¨XMLé…ç½®æ—¶çš„æ ‡ç­¾å’Œå¯¹åº”çš„å±æ€§ï¼Œå¦‚Dubboä¸­çš„&lt;dubbo:service&gt;æ ‡ç­¾ç­‰ã€‚ç”±äºå½“å‰åˆ†æçš„dubboç‰ˆæœ¬æ˜¯2.6.5ï¼ŒDubboå·²ç»æç»™äº†Apacheç»„ç»‡ï¼Œä¸ºäº†éµå¾ªApacheæ ‡å‡†å’Œå…¼å®¹DubboåŸæ¥çš„ç‰ˆæœ¬ï¼Œä¼šå‡ºç°ä¸¤ä¸ªxsdæ–‡ä»¶ï¼Œè¿™ç¯‡æ–‡ç« è¿˜æ˜¯æŒ‰ç…§DubboåŸæ¥çš„ç‰ˆæœ¬è¿›è¡Œç›¸å…³æè¿°ã€‚ dubbo.xsdæ€»è§ˆ Dubboè®¾è®¡çš„ç²’åº¦å¾ˆå¤šéƒ½æ˜¯é’ˆå¯¹æ–¹æ³•çº§åˆ«çš„ï¼Œå¦‚æ–¹æ³•çº§åˆ«çš„timeoutã€retriesç­‰ç‰¹æ€§ã€‚å…·ä½“çš„æ¯ä¸ªå¤æ‚ç±»å‹çš„è¯¦ç»†ä½¿ç”¨å¯ä»¥å‚è€ƒ:å®˜æ–¹æ–‡æ¡£ dubbo.xsdä¸­çš„ç±»å‹å…³ç³» ä¸Šå›¾çš„ç±»å‹ç»§æ‰¿å…³ç³»å’ŒDubboçš„é…ç½®ç±»ä¹‹é—´çš„å…³ç³»å‡ ä¹ä¿æŒä¸€è‡´ï¼Œå› ä¸ºè¿™é‡Œå®šä¹‰çš„å¤æ‚ç±»å‹å°±æ˜¯è¦æ˜ å°„åˆ°é…ç½®ç±»çš„å±æ€§ä¸Šï¼Œå³schemaä¸­çš„å­—æ®µå¯¹åº”Configç±»ä¸­çš„å±æ€§å’Œget/setæ–¹æ³•ã€‚ Dubboçš„spring.schemasæ–‡ä»¶12http\\:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&#x3D;META-INF&#x2F;dubbo.xsdhttp\\:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&#x3D;META-INF&#x2F;compat&#x2F;dubbo.xsd spring.schemasæ–‡ä»¶ç”¨æ¥æŒ‡æ˜çº¦æŸæ–‡ä»¶çš„å…·ä½“è·¯å¾„ã€‚ Dubboçš„spring.handlers12http\\:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x3D;com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandlerhttp\\:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x3D;com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler spring.handlersæ–‡ä»¶ç”¨æ¥æŒ‡æ˜Dubboçš„XMLå‘½åç©ºé—´å¤„ç†å™¨ï¼Œå³ä½¿ç”¨DubboNamespaceHandleræ¥è§£æDubboè‡ªå®šä¹‰çš„æ ‡ç­¾ã€‚ Dubboçš„DubboNamespaceHandler123456789101112131415161718192021222324public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123; static &#123; Version.checkDuplicate(DubboNamespaceHandler.class); &#125; /** * æ–¹æ³•ä¸­å®šä¹‰äº†æ¯ä¸ª&lt;xsd:element/&gt;å¯¹åº”çš„BeanDefinitionParser ã€Dubbo Beanå®šä¹‰è§£æå™¨ã€‘ */ @Override public void init() &#123; registerBeanDefinitionParser(\"application\", new DubboBeanDefinitionParser(ApplicationConfig.class, true)); registerBeanDefinitionParser(\"module\", new DubboBeanDefinitionParser(ModuleConfig.class, true)); registerBeanDefinitionParser(\"registry\", new DubboBeanDefinitionParser(RegistryConfig.class, true)); registerBeanDefinitionParser(\"monitor\", new DubboBeanDefinitionParser(MonitorConfig.class, true)); registerBeanDefinitionParser(\"provider\", new DubboBeanDefinitionParser(ProviderConfig.class, true)); registerBeanDefinitionParser(\"consumer\", new DubboBeanDefinitionParser(ConsumerConfig.class, true)); registerBeanDefinitionParser(\"protocol\", new DubboBeanDefinitionParser(ProtocolConfig.class, true)); registerBeanDefinitionParser(\"service\", new DubboBeanDefinitionParser(ServiceBean.class, true)); registerBeanDefinitionParser(\"reference\", new DubboBeanDefinitionParser(ReferenceBean.class, false)); // æ³¨è§£å·²ç»é‡å†™ï¼ŒAnnotationBeanDefinitionParser å·²ç»åºŸå¼ƒï¼Œå³@DubboComponentScan ä½œä¸º Dubbo 2.5.7 æ–°å¢çš„ Annotationï¼Œæ˜¯XML å…ƒç´  &lt;dubbo:annotation&gt; çš„æ›¿ä»£æ–¹æ¡ˆã€‚ registerBeanDefinitionParser(\"annotation\", new AnnotationBeanDefinitionParser()); &#125;&#125; Dubboè§£æé…ç½®çš„å…¥å£æ˜¯åœ¨ DubboNamespaceHandlerç±»ä¸­å®Œæˆçš„ï¼Œè¯¥ç±»ä¸»è¦æŠŠä¸åŒçš„æ ‡ç­¾å…³è”åˆ°è§£æå®ç°ç±»ä¸­ï¼ŒregisterBeanDefinitionParseræ–¹æ³•çº¦å®šåœ¨é‡åˆ°Dubboè‡ªå®šçš„æ ‡ç­¾å¦‚applicationã€registryã€protocolç­‰éƒ½ä¼šå§”æ‰˜ç»™Dubboçš„å‘½åç©ºé—´å¤„ç†å™¨DubboNamespaceHandlerå¤„ç†ï¼Œè¯¥å¤„ç†å™¨åˆä¼šæŠŠè§£æä»»åŠ¡äº¤ç»™DubboBeanDefinitionParseræ¥å¤„ç†ã€‚ Dubboçš„DubboBeanDefinitionParserå®ç°äº†Springçš„BeanDefinitionParseræ¥å£ï¼Œæ˜¯çœŸæ­£ç”¨æ¥è§£æè‡ªå®šçš„Dubboæ ‡ç­¾ï¼Œå°†æ ‡ç­¾è§£ææˆå¯¹åº”çš„Beanå®šä¹‰å¹¶æ³¨å†Œåˆ°Springä¸Šä¸‹æ–‡ä¸­ã€‚ ä½¿ç”¨Dubboæ ‡ç­¾123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- provider's application name, used for tracing dependency relationship --&gt; &lt;dubbo:application name=\"demo-provider\" owner=\"gentryhuang\"/&gt; &lt;!-- use multicast registry center to export service --&gt; &lt;!--&lt;dubbo:registry address=\"multicast://224.5.6.7:1234\" protocol=\"test\"/&gt; --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- use dubbo protocol to export service on port 20880 --&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!-- service implementation, as same as regular local bean --&gt; &lt;bean id=\"demoService\" class=\"com.alibaba.dubbo.demo.provider.DemoServiceImpl\"/&gt; &lt;!-- declare the service interface to be exported --&gt; &lt;dubbo:service interface=\"com.alibaba.dubbo.demo.DemoService\" ref=\"demoService\"/&gt;&lt;/beans&gt; å°ç»“ä»¥ä¸Šå°±æ˜¯Dubboå’ŒSpringçš„XMLé…ç½®è¿›è¡Œèåˆçš„è¿‡ç¨‹ï¼Œä¸ Springè‡ªå®šä¹‰æ ‡ç­¾ æ–‡ç« ä¸­çš„æµç¨‹æ˜¯ä¸€æ ·çš„ã€‚æ€»çš„æ¥è¯´ï¼ŒDubboæ¡†æ¶å…ˆä»¥æµçš„å½¢å¼è£…è½½Springçš„XMLé…ç½®æ–‡ä»¶ï¼Œåœ¨å°†æµè§£ææˆDOMçš„è¿‡ç¨‹ä¸­ä¼šåŠ è½½spring.schemasæ–‡ä»¶ï¼Œç„¶åè¯»å–è¯¥æ–‡ä»¶ä¸­æŒ‡å®šçš„çš„xsdçº¦æŸæ–‡ä»¶ï¼Œæ¥ç€ä½¿ç”¨xsdä¸­çš„çº¦æŸè§„åˆ™å¯¹æ¯ä¸ªæ ‡ç­¾åŠå…¶å±æ€§è¿›è¡Œæ ¡éªŒï¼Œä¸åˆæ³•åˆ™æŠ›å‡ºå¼‚å¸¸ï¼Œæ•´ä¸ªé…ç½®æ–‡ä»¶ç¬¦åˆçº¦æŸè§„åˆ™åˆ™ç”ŸæˆDOMå¯¹è±¡ã€‚å’Œspring.handlersæ–‡ä»¶ã€‚spring.schemaæ–‡ä»¶æŒ‡å®šäº†é…ç½®çº¦æŸæ–‡ä»¶çš„ä½ç½®ï¼ŒåŠ è½½spring.schemasæ–‡ä»¶çš„ç›®çš„å°±æ˜¯ç”¨æ¥æ ¡éªŒSpringçš„XMLé…ç½®æ–‡ä»¶å†…å®¹æ˜¯å¦åˆæ³•ã€‚åŠ è½½spring.handlersæ–‡ä»¶çš„ç›®çš„æ˜¯ï¼Œå½“è§£æSpringçš„XMLé…ç½®æ–‡ä»¶ä¸­çš„æ ‡ç­¾æ—¶,ä¼šæŸ¥æ‰¾è¯¥æ–‡ä»¶ä¸­æŒ‡å®šçš„DubboNamespaceHandlerç±»æ¥è¿›è¡Œè‡ªå®šä¹‰æ ‡ç­¾çš„åˆå§‹åŒ–å’Œè§£æã€‚ è§£æå‡†å¤‡åŠ è½½ spring.schemas æ–‡ä»¶12345678910111213141516AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory)&#123; // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); // è®¾ç½® 'META-INF/spring.schemas' åˆ° ResourceEntityResolver beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader);&#125; ä¸Šé¢ä»£ç å°±è®¾ç½® spring.schemas æ–‡ä»¶è·¯å¾„ï¼Œä¸ºæ¥ä¸‹æ¥åŠ è½½ spring.schemas æ–‡ä»¶åšå‡†å¤‡ã€‚ 123456789XmlBeanDefinitionReader#doLoadBeanDefinitions(InputSource inputSource, Resource resource)&#123; try &#123; // åŠ è½½ META-INF/spring.schemas ä¸­xsdæ–‡ä»¶ï¼Œåœ¨æ„å»ºDomæ—¶è¿›è¡Œæ ¡éªŒXMLé…ç½®å†…å®¹æ˜¯å¦æ­£ç¡® Document doc = doLoadDocument(inputSource, resource); // åŠ è½½ META-INF/spring.handlers ä¸­çš„å‘½åç©ºé—´å¤„ç†å™¨ï¼Œåˆå§‹åŒ–å¹¶æ”¾å…¥ç¼“å­˜ return registerBeanDefinitions(doc, resource); &#125; // çœç•¥æ— å…³ä»£ç &#125; ä¸Šé¢çš„ä»£ç æ˜¯æ³¨å†ŒXMLä¸­çš„Beançš„å¤§æµç¨‹å…¥å£ï¼Œåˆ†åˆ«æ˜¯åŠ è½½ META-INF/spring.schemas ä¸­xsdæ–‡ä»¶ï¼Œç”¨äºæ„å»ºDOMæ—¶æ ¡éªŒXMLé…ç½®å†…å®¹æ˜¯å¦æ­£ç¡®ï¼ŒåŠ è½½ META-INF/spring.handlers ä¸­çš„å‘½åç©ºé—´å¤„ç†å™¨ï¼Œç”¨äºå¤„ç†æ ‡ç­¾å’ŒBeanDefinitionParserçš„æ˜ å°„å…³ç³»ä»¥åŠè§£ææ ‡ç­¾ã€‚ä¸‹é¢æˆ‘ä»¬æ¥çœ‹Springæ˜¯å¦‚ä½•åŠ è½½spring.schemasæ–‡ä»¶å†…å®¹çš„ã€‚ 12345678910111213141516171819202122232425PluggableSchemaResolver#getSchemaMappings()&#123; if (this.schemaMappings == null) &#123; synchronized (this) &#123; if (this.schemaMappings == null) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Loading schema mappings from [\" + this.schemaMappingsLocation + \"]\"); &#125; try &#123; // ä» META-INF/spring.schemas ä¸­è¯»å–xsdæ–‡ä»¶è·¯å¾„ Properties mappings = PropertiesLoaderUtils.loadAllProperties(this.schemaMappingsLocation, this.classLoader); if (logger.isDebugEnabled()) &#123; logger.debug(\"Loaded schema mappings: \" + mappings); &#125; Map&lt;String, String&gt; schemaMappings = new ConcurrentHashMap&lt;String, String&gt;(mappings.size()); // æ”¾å…¥ç¼“å­˜ä¸­ CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings); this.schemaMappings = schemaMappings; &#125;catch (IOException ex) &#123; throw new IllegalStateException(\"Unable to load schema mappings from location [\" + this.schemaMappingsLocation + \"]\", ex); &#125; &#125; &#125; &#125; return this.schemaMappings;&#125; 12345678910111213141516171819202122232425262728/** * @param publicId * @param systemId */PluggableSchemaResolver#resolveEntity(String publicId, String systemId)&#123; if (systemId != null) &#123; // æ ¹æ® spring.schemasä¸­é…ç½®çš„xxx.xsdæ‰¾åˆ°å¯¹åº”çš„xsdæ–‡ä»¶ String resourceLocation = getSchemaMappings().get(systemId); if (resourceLocation != null) &#123; // åŠ è½½xsdæ–‡ä»¶ Resource resource = new ClassPathResource(resourceLocation, this.classLoader); try &#123; InputSource source = new InputSource(resource.getInputStream()); source.setPublicId(publicId); source.setSystemId(systemId); if (logger.isDebugEnabled()) &#123; logger.debug(\"Found XML schema [\" + systemId + \"] in classpath: \" + resourceLocation); &#125; return source; &#125;catch (FileNotFoundException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Couldn't find XML schema [\" + systemId + \"]: \" + resource, ex); &#125; &#125; &#125; &#125; return null;&#125; ä»¥ä¸Šå°±æ˜¯Springåœ¨å¯åŠ¨æ—¶åŠ è½½spring.schemasä¸­é…ç½®çš„xsdæ–‡ä»¶çš„å‡ ä¸ªä»£ç ç‰‡æ®µï¼Œå°†XMLé…ç½®æ–‡ä»¶è§£ææˆDOMçš„è¿‡ç¨‹ä¸­ï¼Œå¯¹æ¯ä¸ªæ ‡ç­¾åŠå…¶å±æ€§è¿›è¡Œæ ¡éªŒï¼Œä¾æ®å°±æ˜¯xsdä¸­çš„çº¦æŸæ¡ä»¶ã€‚ç”±äºæ˜¯Springçš„æºç éƒ¨åˆ†ï¼Œè¿™é‡Œä¸è¿›è¡Œæ·±å…¥åˆ†æï¼Œæ„Ÿå…´è¶£çš„èƒ–å‹å¯ä»¥è‡ªè¡Œè°ƒè¯•ã€‚ åŠ è½½ spring.handlers æ–‡ä»¶123456789101112/** * @param doc é…ç½®æ–‡ä»¶å¯¹åº”çš„DOMå¯¹è±¡ * @param resource é…ç½®æ–‡ä»¶èµ„æºå¯¹è±¡ */XmlBeanDefinitionReader#registerBeanDefinitions(Document doc, Resource resource)&#123; // åˆ›å»ºBeanå®šä¹‰çš„DOMReaderï¼Œç”¨æ¥è¯»å–ã€è§£æDOMï¼Œæ¥ç€åˆ›å»ºå¯¹åº”çš„Bean BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); // è¯»å–ã€è§£æDOMã€åˆ›å»ºå¯¹åº”çš„Bean documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; registerBeanDefinitionsæ–¹æ³•æ˜¯å°†Springçš„XMLé…ç½®æ–‡ä»¶ä¸­å®šä¹‰çš„æœ‰å…³æ ‡ç­¾è¿›è¡Œåˆ›å»ºå¹¶æ³¨å†Œåˆ°Springçš„æ³¨å†Œè¡¨ä¸­ã€‚æ³¨æ„ï¼Œè¿™é‡Œæ‰€è¯´çš„èƒ½å¤Ÿåˆ›å»ºBeançš„æœ‰å…³æ ‡ç­¾å¿…é¡»æœ‰å¯¹åº”çš„BeanDefinitionParserï¼Œå¦åˆ™ä¸ä¼šå¯¹è¯¥æ ‡ç­¾è¿›è¡Œå¤„ç†ã€‚ 1234567891011121314/** * @param resource é…ç½®æ–‡ä»¶èµ„æºå¯¹è±¡ */XmlBeanDefinitionReader#createReaderContext(Resource resource)&#123; return new XmlReaderContext( resource, this.problemReporter, this.eventListener, this.sourceExtractor, this, // è¯»å– META-INF/spring.handlers æ–‡ä»¶ getNamespaceHandlerResolver() );&#125; createReaderContext æ–¹æ³•ç”¨æ¥åˆ›å»º XmlReaderContextï¼Œè¯¥å¯¹è±¡ä¸­åŒ…å«çš„æ ¸å¿ƒå±æ€§å¦‚ä¸‹ï¼š ç”±XmlReaderContextå¯¹è±¡ä¸­çš„å±æ€§å¯çŸ¥ï¼Œåœ¨åˆ›å»ºè¯¥å¯¹è±¡çš„è¿‡ç¨‹ä¸­å¯¹ META-INF/spring.handlers æ–‡ä»¶è¿›è¡Œäº†è¯»å–ã€‚ç°åœ¨æœ‰äº†é…ç½®æ–‡ä»¶çš„DOMå¯¹è±¡ã€Beanå®šä¹‰å·¥å‚ä»¥åŠspring.handlersæ–‡ä»¶ä¸­å„ç§NamespaceHandlerï¼Œæ¥ä¸‹æ¥å°±å¯ä»¥è§£æDOMæ ‘ï¼Œåˆ›å»ºå¹¶æ³¨å†Œç›¸åº”çš„Beanã€‚ 12345678DefaultBeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)&#123; this.readerContext = readerContext; logger.debug(\"Loading bean definitions\"); // è·å–DOMçš„æ ¹å…ƒç´ ï¼Œä¸€èˆ¬æ˜¯ beans Element root = doc.getDocumentElement(); // è§£æå…¥å£ doRegisterBeanDefinitions(root);&#125; ä¸Šé¢çš„ä»£ç ä¸»è¦æ˜¯è·å–DOMå¯¹è±¡çš„æ ¹å…ƒç´ ï¼Œç„¶åä»¥è¿™ä¸ªæ ¹å…ƒç´ ä½œä¸ºèµ·ç‚¹è¿›è¡Œè§£æï¼Œä¸‹é¢æˆ‘ä»¬æ¥ç€è§£æä»£ç ã€‚ 123456789101112131415161718192021222324252627282930/*** Parse the elements at the root level in the document:* \"import\", \"alias\", \"bean\".* @param root DOMçš„æ ¹å…ƒç´ * @param delegate Beanå®šä¹‰è§£æå™¨ä»£ç†*/DefaultBeanDefinitionDocumentReader#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; // åˆ¤è¯»æ ¹å…ƒç´ æ˜¯ä¸æ˜¯é»˜è®¤çš„å‘½åç©ºé—´ 'http://www.springframework.org/schema/beans' if (delegate.isDefaultNamespace(root)) &#123; // è·å–æ ¹å…ƒç´ ä¸‹çš„å­å…ƒç´ åˆ—è¡¨ NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); // åˆ¤æ–­æ˜¯å¦æ˜¯å…ƒç´  if (node instanceof Element) &#123; Element ele = (Element) node; // å½“å‰å…ƒç´ çš„å‘½åç©ºé—´å¦‚æœæ˜¯é»˜è®¤çš„å‘½åç©ºé—´å³Springè‡ªèº«çš„å‘½åç©ºé—´ï¼Œåˆ™é€šè¿‡Springè‡ªèº«é€»è¾‘è¿›è¡Œè§£æ if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; // å½“å‰å…ƒç´ çš„å‘½åç©ºé—´éé»˜è®¤çš„å‘½åç©ºé—´å³è‡ªå®šä¹‰çš„æ ‡ç­¾ï¼Œåˆ™é€šè¿‡è‡ªå®šä¹‰é€»è¾‘è¿›è¡Œè§£æ else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125;else &#123; delegate.parseCustomElement(root); &#125;&#125; ä¸Šé¢ä»£ç çš„ä¸»è¦é€»è¾‘æ˜¯åˆ¤æ–­è¦è§£æçš„DOMå…ƒç´ å³æ ‡ç­¾ï¼Œæ˜¯å¦æ˜¯Springå†…ç½®çš„ï¼Œå¦‚æœæ˜¯Springå†…ç½®åˆ™æ•´ä¸ªè§£æé€»è¾‘ä½¿ç”¨Springè‡ªèº«çš„é‚£ä¸€å¥—ï¼Œå¦‚æœæ˜¯è‡ªå®šä¹‰çš„ï¼Œåˆ™è§£æé€»è¾‘äº¤ç»™å¼€å‘è€…ã€‚Springè‡ªèº«çš„è§£æé€»è¾‘å¿½ç•¥ï¼Œä¸‹é¢æˆ‘ä»¬æ¥åˆ†æä¸‹è‡ªå®šä¹‰çš„æ ‡ç­¾çš„å¤„ç†æµç¨‹ã€‚ 1234567891011121314151617181920BeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element ele)&#123; return parseCustomElement(ele, null);&#125;/** * @param ele DOMçš„æ ¹å…ƒç´  * @param containingBd */BeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element ele, org.springframework.beans.factory.config.BeanDefinition containingBd)&#123; // è·å–å…ƒç´ å³æ ‡ç­¾çš„å‘½åç©ºé—´ String namespaceUri = getNamespaceURI(ele); // ä½¿ç”¨ XmlReaderContextä¸­çš„ DefaultNamespaceHandlerResolverè·å–å‘½åç©ºé—´å¯¹åº”çš„ NamespaceHandlerå¯¹è±¡ NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) &#123; error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele); return null; &#125; // ä½¿ç”¨ NamespaceHandler å¯¹è±¡è§£ææ ‡ç­¾ return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; ä¸Šé¢ä»£ç å…ˆæ˜¯è·å–å½“å‰å…ƒç´ çš„å‘½åç©ºé—´ï¼Œç„¶åé€šè¿‡è¯¥å‘½åç©ºé—´è·å–å¯¹åº” NamespaceHandlerå¯¹è±¡ï¼Œæœ€åé€šè¿‡è¯¥å¯¹è±¡è§£æå½“å‰å…ƒç´ ã€‚ä¸‹é¢æˆ‘ä»¬ä¾æ¬¡åˆ†æè¿™ä¸¤ä¸ªæ­¥éª¤çš„ä»£ç ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738DefaultNamespaceHandlerResolver#resolve(String namespaceUri)&#123;// è·å– DefaultNamespaceHandlerResolver#handlerMappingså±æ€§ï¼Œå³å‘½åç©ºé—´åˆ°NamespaceHandlerçš„æ˜ å°„ï¼Œæ³¨æ„è¿™é‡Œçš„NamespaceHandlerå¯èƒ½æ˜¯è¿˜æ²¡æœ‰è¿›è¡Œå®ä¾‹åŒ–çš„å­—ç¬¦ä¸² Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();// ä»ç¼“å­˜ä¸­è·å– NamespaceHandler Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) &#123; return null; &#125;// å¦‚æœå½“å‰å‘½åç©ºé—´å¯¹åº”çš„ NamespaceHandler å°±æ˜¯ NamespaceHandlerå¯¹è±¡ï¼Œåˆ™éœ€è¦è¿›è¡Œå®ä¾‹åŒ–ï¼Œç›´æ¥è¿”å›å³å¯ else if (handlerOrClassName instanceof NamespaceHandler) &#123; return (NamespaceHandler) handlerOrClassName; &#125; // å½“å‰å‘½åç©ºé—´å¯¹åº”çš„ NamespaceHandler è¿˜æ˜¯å­—ç¬¦ä¸²ï¼Œéœ€è¦åå°„åˆ›å»ºå¯¹è±¡ else &#123; String className = (String) handlerOrClassName; try &#123; // è·å–å½“å‰ å½“å‰å‘½åç©ºé—´å¯¹åº”çš„ NamespaceHandler ä¸² çš„ Class Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123; throw new FatalBeanException(\"Class [\" + className + \"] for namespace [\" + namespaceUri + \"] does not implement the [\" + NamespaceHandler.class.getName() + \"] interface\"); &#125; // åˆ›å»ºå¯¹è±¡ NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); // æ‰§è¡Œ init æ–¹æ³•ï¼Œè¿›è¡Œæ ‡ç­¾å’ŒBeanDefinitionParser çš„å…³è” namespaceHandler.init(); // åŠ å…¥ç¼“å­˜ handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; &#125;catch (ClassNotFoundException ex) &#123; throw new FatalBeanException(\"NamespaceHandler class [\" + className + \"] for namespace [\" + namespaceUri + \"] not found\", ex); &#125;catch (LinkageError err) &#123; throw new FatalBeanException(\"Invalid NamespaceHandler class [\" + className + \"] for namespace [\" + namespaceUri + \"]: problem with handler class file or dependent class\", err); &#125; &#125;&#125; ä¸Šé¢ä»£ç æ ¸å¿ƒæ˜¯è·å–å½“å‰å‘½åç©ºé—´å¯¹åº”çš„ NamespaceHandler ï¼Œå¦‚æœ NamespaceHandler è¿˜æ˜¯ä¸ªå­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆå°±é€šè¿‡åå°„åˆ›å»ºå¯¹è±¡ï¼Œæ¥ç€è°ƒç”¨è¯¥å¯¹è±¡çš„ init(),è¿›è¡Œæ ‡ç­¾å’Œ BeanDefinitionParser çš„å…³è” ï¼Œæ–¹æ³•å¦‚æœå·²ç»åˆ›å»ºè¿‡äº†å¯¹è±¡åˆ™ç›´æ¥è¿”å›è¯¥ NamespaceHandler å¯¹è±¡ã€‚ç”±äºDubboè‡ªå®šä¹‰æ ‡ç­¾çš„å‘½åç©ºé—´å¯¹åº”çš„NamespaceHandleræ˜¯ DubboNamespaceHandlerï¼Œæˆ‘ä»¬åœ¨å‰é¢å·²ç»åˆ†æè¿‡äº†å®ƒçš„æºç ï¼Œè¿™é‡Œå†è¯¦ç»†è¯´æ˜ä¸‹ã€‚ 1234567891011121314151617181920212223public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123; static &#123; Version.checkDuplicate(DubboNamespaceHandler.class); &#125; /** * æ–¹æ³•ä¸­å®šä¹‰äº†æ¯ä¸ª&lt;xsd:element/&gt;å¯¹åº”çš„BeanDefinitionParser ã€Dubbo Beanå®šä¹‰è§£æå™¨ã€‘ */ @Override public void init() &#123; registerBeanDefinitionParser(\"application\", new DubboBeanDefinitionParser(ApplicationConfig.class, true)); registerBeanDefinitionParser(\"module\", new DubboBeanDefinitionParser(ModuleConfig.class, true)); registerBeanDefinitionParser(\"registry\", new DubboBeanDefinitionParser(RegistryConfig.class, true)); registerBeanDefinitionParser(\"monitor\", new DubboBeanDefinitionParser(MonitorConfig.class, true)); registerBeanDefinitionParser(\"provider\", new DubboBeanDefinitionParser(ProviderConfig.class, true)); registerBeanDefinitionParser(\"consumer\", new DubboBeanDefinitionParser(ConsumerConfig.class, true)); registerBeanDefinitionParser(\"protocol\", new DubboBeanDefinitionParser(ProtocolConfig.class, true)); registerBeanDefinitionParser(\"service\", new DubboBeanDefinitionParser(ServiceBean.class, true)); registerBeanDefinitionParser(\"reference\", new DubboBeanDefinitionParser(ReferenceBean.class, false)); registerBeanDefinitionParser(\"annotation\", new AnnotationBeanDefinitionParser()); &#125;&#125; ä¸Šé¢çš„ä»£ç æ¯”è¾ƒç›´è§‚ï¼Œä¸€ä¸ªæ ‡ç­¾å¯¹åº”ä¸€ä¸ª DubboBeanDefinitionParser å¯¹è±¡ï¼ŒåŒæ—¶ä¹Ÿå¯¹åº”è¿™ä¸€ä¸ªDubboçš„é…ç½®æ‰¿è½½ç±»ã€‚æˆ‘ä»¬æ¥ä¸‹ä¸»è¦çœ‹registerBeanDefinitionParseræ–¹æ³•æ˜¯æ€ä¹ˆæŠŠæ ‡ç­¾å’ŒDubboBeanDefinitionParserå…³è”åˆ°ä¸€èµ·çš„ã€‚ 1234567891011121314public abstract class NamespaceHandlerSupport implements NamespaceHandler &#123; /** * æ ‡ç­¾å åˆ° BeanDefinitionParser æ˜ å°„é›†åˆ */ private final Map&lt;String, BeanDefinitionParser&gt; parsers = new HashMap&lt;String, BeanDefinitionParser&gt;(); /** * å…³è” æ ‡ç­¾å åˆ° BeanDefinitionParser */ protected final void registerBeanDefinitionParser(String elementName, BeanDefinitionParser parser) &#123; this.parsers.put(elementName, parser); &#125;&#125; åŸæ¥å¦‚æ­¤ç®€å•ï¼Œå°±æ˜¯è°ƒç”¨çˆ¶ç±» NamespaceHandlerSupport çš„registerBeanDefinitionParseræ–¹æ³•ï¼Œå°†æ ‡ç­¾ååˆ°BeanDefinitionParserçš„æ˜ å°„ä¿å­˜åˆ°ç¼“å­˜ä¸­ã€‚åˆ°äº†è¿™é‡Œæ‰€æœ‰è§£æå‰çš„å·¥ä½œå·²ç»å‡†å¤‡å°±ç»ªï¼Œç»ˆäºå¯ä»¥è¿›å…¥åˆ°è¿™ç¯‡æ–‡ç« çš„æ ¸å¿ƒéƒ¨åˆ†äº†ã€‚ä¹‹æ‰€ä»¥ç”¨äº†é‚£ä¹ˆå¤šçš„é“ºå«ï¼Œå°±æ˜¯æƒ³æŠŠæ•´ä¸ªè¿‡ç¨‹ä¸²èµ·æ¥ï¼Œå¦‚æœä¸€ä¸‹å­è¿›å…¥åˆ°Dubboè‡ªå®šä¹‰æ ‡ç­¾çš„è§£ææ„Ÿè§‰è¿˜æ˜¯æŒºå¥‡æ€ªçš„ï¼Œæ¯•ç«Ÿç¬”è€…å¯¹Springçš„æºç ä¹Ÿä¸ç†Ÿæ‚‰ï¼Œå°±æŒ‰éƒ¨å°±ç­å§ã€‚ è§£ææ ‡ç­¾è§£æå‡†å¤‡æ˜¯ç‰¹æ„ä¸ºè§£ææ ‡ç­¾åšçš„é“ºå«ï¼Œæœ‰äº†è¿™ä¸ªé“ºå«ä¸‹é¢çš„è§£æé€»è¾‘å°±å®¹æ˜“å¾ˆå¤šäº†ã€‚æˆ‘ä»¬æ¥ç€è§£æå‡†å¤‡ä¸­çš„ parseCustomElement æ–¹æ³•ç»§ç»­åˆ†æã€‚ 123456789101112public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123; // 1. è·å–DOMå…ƒç´ å³æ ‡ç­¾å¯¹åº”çš„å‘½åç©ºé—´ String namespaceUri = getNamespaceURI(ele); // 2. è·å–å‘½åç©ºé—´æ˜ å°„çš„ NamespaceHandlerå¯¹è±¡ NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) &#123; error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele); return null; &#125; // 3. è°ƒç”¨ NamespaceHandlerå¯¹è±¡ çš„parseæ–¹æ³•è¿›è¡Œè§£æ return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; ä¸Šé¢ä»£ç ä¸­çš„ç¬¬3æ­¥æ‰æ­£å¼è¿›å…¥åˆ°æ ‡ç­¾çš„è§£æï¼Œè¿™é‡Œçš„ NamespaceHandler å°± DubboNamespaceHandlerå¯¹è±¡ï¼Œparse æ–¹æ³•æ˜¯å…¶çˆ¶ç±» NamespaceHandlerSupport ä¸­çš„æ–¹æ³•ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹é€»è¾‘ã€‚ 123456789101112131415161718192021 @Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; /* * 1. è·å–æ ‡ç­¾çš„åç§°å…³è”çš„ BeanDefinitionParser * 2. ä½¿ç”¨ BeanDefinitionParserè§£ææ ‡ç­¾ */ return findParserForElement(element, parserContext).parse(element, parserContext);&#125;private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) &#123; // è·å–æ ‡ç­¾å String localName = parserContext.getDelegate().getLocalName(element); // ä»ç¼“å­˜ä¸­è·å–æ ‡ç­¾åå¯¹åº”çš„ BeanDefinitionParserå¯¹è±¡ï¼Œå³ DubboBeanDefinitionParserå¯¹è±¡ BeanDefinitionParser parser = this.parsers.get(localName); if (parser == null) &#123; parserContext.getReaderContext().fatal( \"Cannot locate BeanDefinitionParser for element [\" + localName + \"]\", element); &#125; return parser;&#125; ä¸Šé¢ä»£ç å°±æ˜¯ä» æ ‡ç­¾å åˆ° BeanDefinitionParser æ˜ å°„é›†åˆparsersä¸­è·å–æ ‡ç­¾åå¯¹åº”çš„BeanDefinitionParserå¯¹è±¡ï¼Œè¯¥æ˜ å°„é›†åˆæ˜¯åœ¨ DubboNamespaceHandler#init æ–¹æ³•æ‰§è¡Œæ—¶ç»´æŠ¤çš„ã€‚ä¸‹é¢æˆ‘ä»¬æ¥ç€åˆ†æDubboBeanDefinitionParserç±»ã€‚ Dubbo Beanå®šä¹‰è§£æå™¨1234567891011121314151617181920212223242526272829303132333435public class DubboBeanDefinitionParser implements BeanDefinitionParser &#123; /** * æ ‡ç­¾å…ƒç´ å¯¹åº”çš„å¯¹è±¡ç±» */ private final Class&lt;?&gt; beanClass; /** * æ˜¯å¦éœ€è¦Beançš„ id å±æ€§ */ private final boolean required; /** * @param beanClass Bean å¯¹è±¡çš„ç±» * @param required æ˜¯å¦éœ€è¦åœ¨Beanå¯¹è±¡çš„ç¼–å·ï¼ˆidï¼‰ä¸å­˜åœ¨æ—¶è‡ªåŠ¨ç”Ÿæˆç¼–å·ã€‚æ— éœ€è¢«å…¶ä»–åº”ç”¨å¼•ç”¨çš„é…ç½®å¯¹è±¡ï¼Œæ— éœ€è‡ªåŠ¨ç”Ÿæˆç¼–å·ã€‚ egï¼š&lt;dubbo:reference/&gt; */ public DubboBeanDefinitionParser(Class&lt;?&gt; beanClass, boolean required) &#123; this.beanClass = beanClass; this.required = required; &#125; /** * Springè§£ææ ‡ç­¾çš„å…¥å£æ–¹æ³• * * @param element æ ‡ç­¾å…ƒç´ å¯¹è±¡ * @param parserContext è§£æä¸Šä¸‹æ–‡ * @return */ @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; return parse(element, parserContext, beanClass, required); &#125; // $&#123;çœç•¥çš„ä»£ç &#125; &#125; DubboBeanDefinitionParserå®ç°äº†Springçš„BeanDefinitionParseræ¥å£ï¼Œå³Springçš„Beanå®šä¹‰è§£æå™¨ã€‚è¯¥ç±»ä¸­æœ‰ä¸¤ä¸ªé‡è¦å±æ€§ï¼ŒbeanClass å’Œ requiredï¼Œè¿™ä¸¤ä¸ªå±æ€§çš„å€¼æ˜¯åœ¨åˆ›å»ºDubboçš„Beanå®šä¹‰è§£æå™¨æ—¶é€šè¿‡æ„é€ æ–¹æ³•ä¼ å…¥çš„ï¼Œåˆ†åˆ«æ˜¯æ ‡ç­¾å…ƒç´ å¯¹åº”çš„é…ç½®ç±»å’Œåœ¨åˆ›å»ºé…ç½®Beançš„æ—¶å€™å¯èƒ½éœ€è¦içš„då±æ€§ã€‚parseæ–¹æ³•æ˜¯è§£æXMLå…ƒç´ çš„ä¸»æµç¨‹çš„å…¥å£ï¼Œå…¶ä¸­ parserContext å‚æ•°æ˜¯XMLè§£æçš„ä¸Šä¸‹æ–‡ï¼Œå®ƒåŒ…å«äº† XmlReaderContext è¿™ä¸ªé‡è¦å¯¹è±¡ï¼Œè€Œè¯¥å¯¹è±¡ä¸­åˆåŒ…å«äº†BeanFactoryç­‰ä¿¡æ¯ï¼Œå…·ä½“å¦‚ä¸‹å›¾: æœ‰äº†BeanFactoryå°±å¯ä»¥å®ç°Beançš„å®šä¹‰äº†ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ç»§ç»­åˆ†æDubboæ˜¯å¦‚ä½•å¤„ç†è‡ªå®šä¹‰æ ‡ç­¾ä¸å¯¹åº”çš„é…ç½®ç±»ä¹‹é—´çš„å…³ç³»ï¼Œä»¥åŠæ€æ ·åˆ›å»ºæ ‡ç­¾å¯¹åº”çš„Beanå®šä¹‰çš„ã€‚ åˆ›å»ºBeanå®šä¹‰å¹¶æ³¨å†Œåˆ°Springä¸Šä¸‹æ–‡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @param element æ ‡ç­¾å¯¹åº”çš„DOM * @param parserContext spring è§£æä¸Šä¸‹æ–‡ * @param beanClass æ ‡ç­¾å¯¹åº”çš„é…ç½®ç±» * @param required åœ¨åˆ›å»ºBeanå®šä¹‰çš„æ—¶å€™æ˜¯å¦éœ€è¦id * @return æ ‡ç­¾å¯¹åº”çš„é…ç½®ç±»çš„Beanå®šä¹‰ */ @SuppressWarnings(\"unchecked\") private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123; // ç”ŸæˆSpringçš„Beanå®šä¹‰ï¼ŒæŒ‡å®šbeanClassäº¤ç»™Springåå°„åˆ›å»ºå®ä¾‹ RootBeanDefinition beanDefinition = new RootBeanDefinition(); beanDefinition.setBeanClass(beanClass); /** * è®¾ç½®Beanåˆå§‹åŒ–æ–¹å¼ï¼Œé»˜è®¤è®¾ç½®ä¸ºå»¶è¿ŸåŠ è½½ã€‚ * éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œå¼•ç”¨ç¼ºçœæ˜¯å»¶è¿Ÿåˆå§‹åŒ–çš„ï¼Œåªæœ‰å¼•ç”¨è¢«æ³¨å…¥åˆ°å…¶å®ƒBeanæˆ–è€…getBean() è·å–æ‰ä¼šåˆå§‹åŒ–ã€‚å¦‚æœéœ€è¦ç«‹å³åˆå§‹åŒ–å¯ä»¥é…ç½®ï¼š &lt;dubbo:reference init=\"true\"/&gt; */ beanDefinition.setLazyInit(false); //--------------------------- ç¡®ä¿Spring å®¹å™¨ä¸­æ²¡æœ‰é‡å¤çš„Beanå®šä¹‰ å¼€å§‹ ------------------------/ // è§£ææ ‡ç­¾å¯¹è±¡çš„idå±æ€§ String id = element.getAttribute(\"id\"); // æ ‡ç­¾æ²¡æœ‰è®¾ç½®idå±æ€§ï¼Œå¹¶ä¸”åˆ›å»ºçš„Beanå®šä¹‰éœ€è¦idæ—¶ï¼Œå°±æ‰§è¡Œç”Ÿæˆidçš„é€»è¾‘ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒDubboçš„referenceæ ‡ç­¾å¯¹åº”Beanå®šä¹‰ä¸éœ€è¦id if ((id == null || id.length() == 0) &amp;&amp; required) &#123; // 1. å–nameå±æ€§å€¼ String generatedBeanName = element.getAttribute(\"name\"); if (generatedBeanName == null || generatedBeanName.length() == 0) &#123; // 2. ä¹Ÿæ²¡æœ‰è®¾ç½®nameå±æ€§ï¼Œæ­¤æ—¶å¦‚æœå½“å‰æ ‡ç­¾æ˜¯Protocolï¼Œé‚£ä¹ˆidçš„å€¼å°±ç›´æ¥è®¾ç½®ä¸º 'dubbo'ï¼ŒéProtocolåè®®åˆ™å°è¯•å–æ ‡ç­¾çš„interfaceå±æ€§å€¼ if (ProtocolConfig.class.equals(beanClass)) &#123; generatedBeanName = \"dubbo\"; &#125; else &#123; generatedBeanName = element.getAttribute(\"interface\"); &#125; &#125; // 3. ä»¥ä¸Šè¿‡ç¨‹éƒ½æ²¡æœ‰ç”Ÿæˆidï¼Œåˆ™æœ€åä½¿ç”¨æ ‡ç­¾å¯¹åº”çš„é…ç½®ç±»çš„ç±»å if (generatedBeanName == null || generatedBeanName.length() == 0) &#123; generatedBeanName = beanClass.getName(); &#125; id = generatedBeanName; int counter = 2; // æ£€æŸ¥Springæ³¨å†Œè¡¨ä¸­æ˜¯å¦å­˜åœ¨æ ‡è¯†idï¼Œå­˜åœ¨å°±é€šè¿‡è‡ªå¢åºåˆ—ç»§ç»­å¤„ç†id,ä½¿å…¶å”¯ä¸€ while (parserContext.getRegistry().containsBeanDefinition(id)) &#123; id = generatedBeanName + (counter++); &#125; &#125; if (id != null &amp;&amp; id.length() &gt; 0) &#123; if (parserContext.getRegistry().containsBeanDefinition(id)) &#123; throw new IllegalStateException(\"Duplicate spring bean id \" + id); &#125; // æŠŠæ ‡ç­¾å¯¹åº”çš„é…ç½®ç±»çš„Beanå®šä¹‰æ³¨å†Œåˆ°Springï¼ŒBean åç§°ä¸ºid parserContext.getRegistry().registerBeanDefinition(id, beanDefinition); // ä¸ºBeanè¿½åŠ idå±æ€§ beanDefinition.getPropertyValues().addPropertyValue(\"id\", id); &#125; // $&#123;çœç•¥çš„ä»£ç &#125; &#125; ç‰¹æ®Šå¤„ç†protocolæ ‡ç­¾123456789101112131415161718192021222324252627282930313233343536373839/** * @param element æ ‡ç­¾å¯¹åº”çš„DOM * @param parserContext spring è§£æä¸Šä¸‹æ–‡ * @param beanClass æ ‡ç­¾å¯¹åº”çš„é…ç½®ç±» * @param required åœ¨åˆ›å»ºBeanå®šä¹‰çš„æ—¶å€™æ˜¯å¦éœ€è¦id * @return æ ‡ç­¾å¯¹åº”çš„é…ç½®ç±»çš„Beanå®šä¹‰ */ @SuppressWarnings(\"unchecked\") private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123; // $&#123;çœç•¥çš„ä»£ç &#125; if (ProtocolConfig.class.equals(beanClass)) &#123; /** * ä»¥ä¸‹ä»£ç é€»è¾‘éœ€è¦æ»¡è¶³ï¼š * é¡ºåºéœ€è¦è¿™æ ·ï¼š * 1 &lt;dubbo:service interface=\"com.xxx.xxxService protocol=\"dubbo\" ref=\"xxxServiceImpl\"/&gt; * 2 &lt;dubbo:protocol id =\"dubbo\" name=\"dubbo\" port=\"20880\"/&gt; */ // è·å–Beanæ³¨å†Œè¡¨ä¸­æ‰€æœ‰çš„Bean id for (String name : parserContext.getRegistry().getBeanDefinitionNames()) &#123; // æ ¹æ®idè·å–Beanå®šä¹‰ BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name); // è·å–å½“å‰Beanå®šä¹‰çš„å±æ€§å¯¹è±¡é›†åˆï¼Œå¹¶å°è¯•è·å–å±æ€§åä¸º 'protocol' çš„å±æ€§å¯¹è±¡ PropertyValue property = definition.getPropertyValues().getPropertyValue(\"protocol\"); if (property != null) &#123; // è·å–å±æ€§å€¼ Object value = property.getValue(); // å¦‚æœå½“å‰éå†çš„Beanå®šä¹‰ä¸­çš„å±æ€§æ»¡è¶³æ¡ä»¶ï¼Œå°±æ›´æ–°è¯¥Beançš„ protocol å±æ€§å€¼ï¼Œå³åç§°ä¸ºidçš„RuntimeBeanReferenceå¯¹è±¡ if (value instanceof ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) &#123; definition.getPropertyValues().addPropertyValue(\"protocol\", new RuntimeBeanReference(id)); &#125; &#125; &#125; &#125; // $&#123;çœç•¥çš„ä»£ç &#125; &#125; ä¸Šé¢çš„ä»£ç ç”¨æ¥å¤„ç†æ¡†æ¶ä¸­é‚£äº›å±æ€§åä¸ºâ€™protocolâ€™ä¸”å±æ€§ç±»å‹ä¸ºä¸ºProtocolConfigçš„Beanï¼Œå¦‚æœè¯¥Beanç¬¦åˆæ¡ä»¶å°±æ›´æ–°è¯¥Beançš„protocolå±æ€§å€¼ã€‚ ç‰¹æ®Šå¤„ç†serviceæ ‡ç­¾1234567891011121314151617181920212223242526272829/** * @param element æ ‡ç­¾å¯¹åº”çš„DOM * @param parserContext spring è§£æä¸Šä¸‹æ–‡ * @param beanClass æ ‡ç­¾å¯¹åº”çš„é…ç½®ç±» * @param required åœ¨åˆ›å»ºBeanå®šä¹‰çš„æ—¶å€™æ˜¯å¦éœ€è¦id * @return æ ‡ç­¾å¯¹åº”çš„é…ç½®ç±»çš„Beanå®šä¹‰ */ @SuppressWarnings(\"unchecked\") private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123; // $&#123;çœç•¥çš„ä»£ç &#125; else if (ServiceBean.class.equals(beanClass)) &#123; // å¦‚æœ&lt;dubbo:service&gt;é…ç½®äº†classå±æ€§ï¼Œé‚£ä¹ˆä¸ºå…·ä½“classé…ç½®çš„ç±»åˆ›å»ºBeanå®šä¹‰ï¼Œå¹¶ä¸”æŠŠè¯¥å®šä¹‰æ³¨å…¥åˆ°Serviceçš„ refå±æ€§ã€‚ä¸€èˆ¬ä¸è¿™ä¹ˆä½¿ç”¨ã€‚ // eg: &lt;dubbo:service interface=\"com.alibaba.dubbo.demo.DemoService class=\"com.alibaba.dubbo.demo.provider.DemoServiceImpl\"/&gt; String className = element.getAttribute(\"class\"); if (className != null &amp;&amp; className.length() &gt; 0) &#123; RootBeanDefinition classDefinition = new RootBeanDefinition(); classDefinition.setBeanClass(ReflectUtils.forName(className)); classDefinition.setLazyInit(false); // è§£æ &lt;dubbo:service class=\"xxx\"/&gt; æƒ…å†µä¸‹å†…åµŒçš„&lt;property/&gt;æ ‡ç­¾ï¼Œç„¶åè®¾ç½®åˆ°classDefinitionçš„å±æ€§ä¸­ parseProperties(element.getChildNodes(), classDefinition); // è®¾ç½®refå±æ€§ï¼Œç›¸å½“äºè®¾ç½® &lt;dubbo:service ref=\"\"/&gt;å±æ€§ beanDefinition.getPropertyValues().addPropertyValue(\"ref\", new BeanDefinitionHolder(classDefinition, id + \"Impl\")); &#125; &#125; // $&#123;çœç•¥çš„ä»£ç &#125; &#125; ä¸Šé¢çš„ä»£ç ç”¨æ¥å¤„ç† serviceæ ‡ç­¾ ä¸­æœ‰ class å±æ€§çš„æƒ…å†µï¼Œå¤„ç†é€»è¾‘å°±æ˜¯åˆ›å»ºclasså¯¹åº”çš„Beanå®šä¹‰ï¼Œç„¶åè®¾ç½®åˆ° serviceæ ‡ç­¾ å¯¹åº”çš„Beançš„refå±æ€§ä¸­ã€‚æˆ‘ä»¬å†æ¥çœ‹çœ‹å¯¹serviceçš„å­æ ‡ç­¾ property çš„è§£æã€‚ 123456789101112131415161718192021222324252627282930313233/** * è§£æ &lt;dubbo:service class=\"xxx\"/&gt; æƒ…å†µä¸‹å†…åµŒçš„&lt;property/&gt; * * @param nodeList å­å…ƒç´ æ•°ç»„ * @param beanDefinition Beanå®šä¹‰å¯¹è±¡ */private static void parseProperties(NodeList nodeList, RootBeanDefinition beanDefinition) &#123; if (nodeList != null &amp;&amp; nodeList.getLength() &gt; 0) &#123; for (int i = 0; i &lt; nodeList.getLength(); i++) &#123; Node node = nodeList.item(i); // åªè§£æ&lt;property/&gt;æ ‡ç­¾ if (node instanceof Element) &#123; if (\"property\".equals(node.getNodeName()) || \"property\".equals(node.getLocalName())) &#123; String name = ((Element) node).getAttribute(\"name\"); // ä¼˜å…ˆä½¿ç”¨valueå±æ€§ï¼Œå…¶æ¬¡ä½¿ç”¨refå±æ€§ if (name != null &amp;&amp; name.length() &gt; 0) &#123; String value = ((Element) node).getAttribute(\"value\"); String ref = ((Element) node).getAttribute(\"ref\"); if (value != null &amp;&amp; value.length() &gt; 0) &#123; beanDefinition.getPropertyValues().addPropertyValue(name, value); &#125; else if (ref != null &amp;&amp; ref.length() &gt; 0) &#123; beanDefinition.getPropertyValues().addPropertyValue(name, new RuntimeBeanReference(ref)); &#125; else &#123; // å±æ€§ä¸å…¨ï¼ŒæŠ›å‡ºå¼‚å¸¸ throw new UnsupportedOperationException(\"Unsupported &lt;property name=\\\"\" + name + \"\\\"&gt; sub tag, Only supported &lt;property name=\\\"\" + name + \"\\\" ref=\\\"...\\\" /&gt; or &lt;property name=\\\"\" + name + \"\\\" value=\\\"...\\\" /&gt;\"); &#125; &#125; &#125; &#125; &#125; &#125;&#125; ä¸Šé¢çš„ä»£ç ç”¨æ¥è§£æserviceçš„propertyæ ‡ç­¾ï¼Œç›®çš„æ˜¯ä¸ºserviceæ ‡ç­¾çš„classå±æ€§å¯¹åº”çš„Beanå®šä¹‰è®¾ç½®å±æ€§ï¼Œæ¯”è¾ƒç®€å•ã€‚ ç‰¹æ®Šå¤„ç†provider/consumeræ ‡ç­¾1234567891011121314151617181920212223/** * @param element æ ‡ç­¾å¯¹åº”çš„DOM * @param parserContext spring è§£æä¸Šä¸‹æ–‡ * @param beanClass æ ‡ç­¾å¯¹åº”çš„é…ç½®ç±» * @param required åœ¨åˆ›å»ºBeanå®šä¹‰çš„æ—¶å€™æ˜¯å¦éœ€è¦id * @return æ ‡ç­¾å¯¹åº”çš„é…ç½®ç±»çš„Beanå®šä¹‰ */ @SuppressWarnings(\"unchecked\") private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123; // $&#123;çœç•¥çš„ä»£ç &#125; else if (ProviderConfig.class.equals(beanClass)) &#123; // è§£æ &lt;dubbo:provider/&gt; çš„å†…åµŒå­å…ƒç´ &lt;dubbo:service/&gt; parseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition); &#125;else if (ConsumerConfig.class.equals(beanClass)) &#123; // è§£æ &lt;dubbo:consumer/&gt; çš„å†…åµŒå­å…ƒç´ &lt;dubbo:reference/&gt; parseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition); &#125; // $&#123;çœç•¥çš„ä»£ç &#125; &#125; ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼Œç‰¹æ®Šå¤„ç†provider/consumeræ ‡ç­¾å°±æ˜¯å¤„ç†å®ƒæœ‰service/referenceå­æ ‡ç­¾çš„æƒ…å†µï¼Œä»£ç è¿‡ç¨‹å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * è§£æå†…åµŒçš„æ ‡ç­¾ * * @param element çˆ¶æ ‡ç­¾å¯¹è±¡ - provider/consumeræ ‡ç­¾å¯¹è±¡ * @param parserContext Springè§£æä¸Šä¸‹æ–‡ * @param beanClass å†…åµŒå­å…ƒç´ çš„Beanç±» - ServiceBean/ReferenceBean * @param required æ˜¯å¦éœ€è¦Beançš„idå±æ€§ * @param tag å­å…ƒç´ æ ‡ç­¾å service/reference * @param property çˆ¶Beanå¯¹è±¡åœ¨å­å…ƒç´ ä¸­çš„å±æ€§å provider/consumer * @param ref çˆ¶Beançš„id * @param beanDefinition çˆ¶Beanå®šä¹‰å¯¹è±¡ */ private static void parseNested(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required, String tag, String property, String ref, BeanDefinition beanDefinition) &#123; // è·å–å­èŠ‚ç‚¹åˆ—è¡¨ NodeList nodeList = element.getChildNodes(); if (nodeList != null &amp;&amp; nodeList.getLength() &gt; 0) &#123; boolean first = true; for (int i = 0; i &lt; nodeList.getLength(); i++) &#123; // è·å–å­èŠ‚ç‚¹ Node node = nodeList.item(i); if (node instanceof Element) &#123; // å½“å‰èŠ‚ç‚¹æ˜¯å¦æ˜¯æŒ‡å®šçš„å­èŠ‚ç‚¹ï¼Œè¿™é‡Œå¯èƒ½æ˜¯service/referenceèŠ‚ç‚¹ if (tag.equals(node.getNodeName()) || tag.equals(node.getLocalName())) &#123; if (first) &#123; first = false; // è·å–çˆ¶èŠ‚ç‚¹çš„defaultçš„å±æ€§å€¼ [æš‚æ—¶ä¸çŸ¥é“æœ‰ä»€ä¹ˆç”¨] String isDefault = element.getAttribute(\"default\"); if (isDefault == null || isDefault.length() == 0) &#123; beanDefinition.getPropertyValues().addPropertyValue(\"default\", \"false\"); &#125; &#125; // è§£æå­å…ƒç´ ï¼Œåˆ›å»ºBeanDefinition å¯¹è±¡ ï¼ˆé€’å½’ï¼‰ BeanDefinition subDefinition = parse((Element) node, parserContext, beanClass, required); // è®¾ç½®å­BeanDefinitionçš„æŒ‡å‘ï¼ŒæŒ‡å‘çˆ¶BeanDefinition if (subDefinition != null &amp;&amp; ref != null &amp;&amp; ref.length() &gt; 0) &#123; subDefinition.getPropertyValues().addPropertyValue(property, new RuntimeBeanReference(ref)); &#125; &#125; &#125; &#125; &#125; &#125; ä¸Šé¢çš„ä»£ç ä¸»è¦å¤„ç†provider/consumeræ ‡ç­¾å†…éƒ¨åµŒå¥—çš„æ ‡ç­¾ï¼Œå†…éƒ¨åµŒå¥—çš„æ ‡ç­¾å¯¹è±¡ä¼šè‡ªåŠ¨æŒæœ‰å¤–å±‚æ ‡ç­¾çš„å¯¹è±¡ã€‚ è®¾ç½®æ ‡ç­¾çš„å±æ€§åˆ° BeanDefinitionå‰é¢å¤„ç†çš„é€»è¾‘å±äºç‰¹æ®Šçš„æƒ…å†µï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬åˆ†ææ ‡ç­¾çš„å±æ€§æ˜¯å¦‚ä½•è®¾ç½®åˆ°é…ç½®å¯¹è±¡ä¸­çš„ã€‚æœ¬è´¨ä¸Šæ˜¯é€šè¿‡éå†é…ç½®å¯¹è±¡çš„getã€setå’Œiså‰ç¼€æ–¹æ³•ï¼Œé€šè¿‡åå°„å°†æ ‡ç­¾å±æ€§è®¾ç½®åˆ°é…ç½®å¯¹è±¡ä¸­ã€‚æ€»ä½“ä¸Šåˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š å¦‚æœæ ‡ç­¾å±æ€§å’Œæ–¹æ³•åç›¸åŒï¼Œåˆ™é€šè¿‡åå°„è°ƒç”¨è®¾ç½®æ ‡ç­¾çš„å€¼åˆ°é…ç½®å¯¹è±¡ä¸­ã€‚ å¦‚æœæ ‡ç­¾å±æ€§ä¸èƒ½åŒ¹é…åˆ°é…ç½®å¯¹è±¡ä¸­çš„æ–¹æ³•åç§°ï¼Œåˆ™å°†æ ‡ç­¾å±æ€§å½“ä½œparameterå‚æ•°è®¾ç½®åˆ°é…ç½®å¯¹è±¡ä¸­ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194/** * @param element æ ‡ç­¾å¯¹åº”çš„DOM * @param parserContext spring è§£æä¸Šä¸‹æ–‡ * @param beanClass æ ‡ç­¾å¯¹åº”çš„é…ç½®ç±» * @param required åœ¨åˆ›å»ºBeanå®šä¹‰çš„æ—¶å€™æ˜¯å¦éœ€è¦id * @return æ ‡ç­¾å¯¹åº”çš„é…ç½®ç±»çš„Beanå®šä¹‰ */ @SuppressWarnings(\"unchecked\") private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123; // $&#123;çœç•¥çš„ä»£ç &#125; // ç”¨æ¥ä¿å­˜å·²éå†çš„é…ç½®å¯¹è±¡çš„å±æ€§é›†åˆï¼Œç”¨æ¥åˆ¤æ–­æ ‡ç­¾ä¸­å“ªäº›å±æ€§æ²¡æœ‰åŒ¹é…ä¸Š Set&lt;String&gt; props = new HashSet&lt;String&gt;(); // ä¸“é—¨å­˜æ”¾&lt;dubbo:parameters/&gt; æ ‡ç­¾ä¸‹å­æ ‡ç­¾å±æ€§ä¿¡æ¯ã€‚æœ€åéƒ½è®¾ç½®åˆ°Beanå®šä¹‰ä¸­ ManagedMap parameters = null; // 1. è·å–é…ç½®å¯¹è±¡æ‰€æœ‰æ–¹æ³• for (Method setter : beanClass.getMethods()) &#123; String name = setter.getName(); // 2. é€‰æ‹©æ‰€æœ‰setå‰ç¼€æ–¹æ³•ï¼Œå¹¶ä¸”åªæœ‰ä¸€ä¸ªå‚æ•°çš„ public æ–¹æ³• if (name.length() &gt; 3 &amp;&amp; name.startsWith(\"set\") &amp;&amp; Modifier.isPublic(setter.getModifiers()) &amp;&amp; setter.getParameterTypes().length == 1) &#123; // è·å–æ–¹æ³•çš„å‚æ•°ç±»å‹ Class&lt;?&gt; type = setter.getParameterTypes()[0]; // 3. æå–setå¯¹åº”çš„å±æ€§åå­—ï¼Œeg: setTimeout-&gt;timeout,setBeanName-&gt;bean-name String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \"-\"); // ä¿å­˜åˆ°å±æ€§ props é›†åˆä¸­ props.add(property); // 4. å°è¯•è·å–å±æ€§å¯¹åº”çš„getteræ–¹æ³• Method getter = null; try &#123; getter = beanClass.getMethod(\"get\" + name.substring(3), new Class&lt;?&gt;[0]); &#125; catch (NoSuchMethodException e) &#123; try &#123; // æ²¡æœ‰setterå¯¹åº”çš„getteræ–¹æ³•ï¼Œå°è¯•è·å–isæ–¹æ³•ï¼Œisæ–¹æ³•åœ¨åŠŸèƒ½ä¸Šæ˜¯åŒgetter getter = beanClass.getMethod(\"is\" + name.substring(3), new Class&lt;?&gt;[0]); &#125; catch (NoSuchMethodException e2) &#123; &#125; &#125; // 5. æ ¡éªŒå±æ€§æ˜¯å¦æœ‰å¯¹åº”çš„getter/iså‰ç¼€æ–¹æ³•ï¼Œæ²¡æœ‰å°±è·³è¿‡ if (getter == null || !Modifier.isPublic(getter.getModifiers()) || !type.equals(getter.getReturnType())) &#123; continue; &#125; // 6. è§£æ &lt;dubbo:parameter/&gt; æ ‡ç­¾ï¼Œå°†å½“å‰æ ‡ç­¾elementçš„å­æ ‡ç­¾ &lt;dubbo:parameter/&gt; çš„å±æ€§é”®å€¼å¯¹ä¿å­˜åˆ°parametersä¸­ if (\"parameters\".equals(property)) &#123; parameters = parseParameters(element.getChildNodes(), beanDefinition); // 7. è§£æ &lt;dubbo:method/&gt; æ ‡ç­¾ï¼Œå°†å½“å‰æ ‡ç­¾elementçš„å­æ ‡ç­¾ &lt;dubbo:method/&gt; è¿›è¡Œè§£æï¼Œå°†è§£æå¾—åˆ°çš„å¯¹åº”BeanDefinitonæ”¾å…¥åˆ°ManagedListé›†åˆä¸­ï¼Œæœ€åä½œä¸º beanDefinitonçš„methodså±æ€§å€¼ã€‚ &#125; else if (\"methods\".equals(property)) &#123; parseMethods(id, element.getChildNodes(), beanDefinition, parserContext); // 8. è§£æ &lt;dubbo:argument/&gt;æ ‡ç­¾ï¼Œå°†å½“å‰æ ‡ç­¾elementçš„å­æ ‡ç­¾ &lt;dubbo:argument/&gt; è¿›è¡Œè§£æï¼Œå°†è§£æå¾—åˆ°çš„å¯¹åº”çš„BeanDefinitionæ”¾å…¥åˆ°ManagedListé›†åˆä¸­ï¼Œæœ€åä½œä¸º beanDefinitionçš„argumentså±æ€§å€¼ã€‚ &#125; else if (\"arguments\".equals(property)) &#123; parseArguments(id, element.getChildNodes(), beanDefinition, parserContext); &#125; else &#123; // 9. è·å–æ ‡ç­¾å±æ€§çš„å€¼ ã€å‰é¢çš„æ­¥éª¤ä¹‹æ‰€ä»¥å•ç‹¬å¤„ç†ï¼Œæ˜¯å› ä¸ºå½“å‰é…ç½®é…ç½®å¯¹è±¡å¯¹åº”çš„å±æ€§ä¸æ˜¯ä¸€ä¸ªæ ‡ç­¾å±æ€§ï¼Œè€Œæ˜¯ä¸€ä¸ªå­æ ‡ç­¾ã€‘ String value = element.getAttribute(property); if (value != null) &#123; value = value.trim(); if (value.length() &gt; 0) &#123; // 9.1 æ ‡ç­¾ä¸­é…ç½®äº† registry=N/A, ä¸æƒ³æ³¨å†Œåˆ°çš„æƒ…å†µ if (\"registry\".equals(property) &amp;&amp; RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) &#123; RegistryConfig registryConfig = new RegistryConfig(); // RegistryConfigçš„åœ°å€è®¾ç½® N/A registryConfig.setAddress(RegistryConfig.NO_AVAILABLE); beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig); // 9.2 å¤šæ³¨å†Œä¸­å¿ƒæƒ…å†µï¼Œå°†å¤šä¸ªæ³¨å†Œä¸­å¿ƒå¤„ç†æˆä¸€ä¸ªé›†åˆï¼Œç„¶åè®¾ç½®åˆ° beanDefiniton ä¸­ï¼Œå±æ€§åä¸º 'registries' &#125; else if (\"registry\".equals(property) &amp;&amp; value.indexOf(',') != -1) &#123; parseMultiRef(\"registries\", value, beanDefinition, parserContext); // 9.3 å¤šæœåŠ¡æä¾›è€…æƒ…å†µï¼Œå°†å¤šä¸ªæœåŠ¡æä¾›è€…å¤„ç†æˆä¸€ä¸ªé›†åˆï¼Œç„¶åè®¾ç½®åˆ° beanDefinition ä¸­ï¼Œå±æ€§ä¸º 'providers' &#125; else if (\"provider\".equals(property) &amp;&amp; value.indexOf(',') != -1) &#123; parseMultiRef(\"providers\", value, beanDefinition, parserContext); // 9.4 å¤šåè®®æƒ…å†µï¼Œå°†å¤šä¸ªåè®®å¤„ç†æˆä¸€ä¸ªé›†åˆï¼Œç„¶åè®¾ç½®åˆ° beanDefinition ä¸­ï¼Œå±æ€§ä¸º 'protocols' &#125; else if (\"protocol\".equals(property) &amp;&amp; value.indexOf(',') != -1) &#123; parseMultiRef(\"protocols\", value, beanDefinition, parserContext); &#125; else &#123; Object reference; // 10. å±æ€§ç±»å‹ä¸ºåŸºæœ¬ç±»å‹çš„æƒ…å†µ if (isPrimitive(type)) &#123; // å…¼å®¹æ€§å¤„ç†ã€ä¸€äº›è®¾ç½®äº†ä½†æ˜¯æ„ä¹‰ä¸å¤§çš„å±æ€§å°±æŠŠå€¼è®¾ç½®ä¸ºnullã€‘ if (\"async\".equals(property) &amp;&amp; \"false\".equals(value) || \"timeout\".equals(property) &amp;&amp; \"0\".equals(value) || \"delay\".equals(property) &amp;&amp; \"0\".equals(value) || \"version\".equals(property) &amp;&amp; \"0.0.0\".equals(value) || \"stat\".equals(property) &amp;&amp; \"-1\".equals(value) || \"reliable\".equals(property) &amp;&amp; \"false\".equals(value)) &#123; // backward compatibility for the default value in old version's xsd value = null; &#125; reference = value; //11. å¤„ç†åœ¨&lt;dubbo:provider/&gt; æˆ–è€… &lt;dubbo:service/&gt; ä¸Šå®šä¹‰äº† protocol å±æ€§çš„å…¼å®¹æ€§ï¼Œç›®å‰å·²ç»ä¸æ¨èè¿™æ ·ä½¿ç”¨äº†ï¼Œåº”è¯¥å•ç‹¬é…ç½® &lt;dubbo:protocol/&gt; &#125; else if (\"protocol\".equals(property) &amp;&amp; ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(value) &amp;&amp; (!parserContext.getRegistry().containsBeanDefinition(value) || !ProtocolConfig.class.getName().equals(parserContext.getRegistry().getBeanDefinition(value).getBeanClassName()))) &#123; if (\"dubbo:provider\".equals(element.getTagName())) &#123; logger.warn(\"Recommended replace &lt;dubbo:provider protocol=\\\"\" + value + \"\\\" ... /&gt; to &lt;dubbo:protocol name=\\\"\" + value + \"\\\" ... /&gt;\"); &#125; // backward compatibility ProtocolConfig protocol = new ProtocolConfig(); protocol.setName(value); reference = protocol; //------- 12. äº‹ä»¶é€šçŸ¥: åœ¨è°ƒç”¨å‰ï¼Œè°ƒç”¨åï¼Œå‡ºç°å¼‚å¸¸ï¼Œä¼šè§¦å‘oninvokeï¼Œonreturn,onthrowä¸‰ä¸ªäº‹ä»¶ï¼Œå¯ä»¥é…ç½®å½“äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œé€šçŸ¥å“ªä¸ªç±»çš„å“ªä¸ªæ–¹æ³• ------// /* // æ ¼å¼ï¼šå®ç°Bean.æ–¹æ³• &lt;bean id=\"demoCallBack\" class = \"com.alibaba.dubbo.callback.implicit.NofifyImpl\"/&gt; &lt;dubbo:reference id = \"demoService\" interface=\"com.alibaba.dubbo.IDemoService\"&gt; &lt;dubbo:method name=\"get\" onreturn=\"demoCallBack.xxxMethod\" onthrow=\"demoCallBack.xMethod\"/&gt; &lt;/dubbo:reference&gt; */ // 12.1 å¤„ç† onreturn å±æ€§ &#125; else if (\"onreturn\".equals(property)) &#123; // æŒ‰ç…§ . æ‹†åˆ† int index = value.lastIndexOf(\".\"); // è·å–å®ä¾‹å String returnRef = value.substring(0, index); // è·å–å®ä¾‹çš„æ–¹æ³• String returnMethod = value.substring(index + 1); // åˆ›å»º RuntimeBeanReferenceï¼ŒæŒ‡å‘å›è°ƒçš„å¯¹è±¡ reference = new RuntimeBeanReference(returnRef); // è®¾ç½® onreturnMethod åˆ° BeanDefinition çš„å±æ€§å€¼ beanDefinition.getPropertyValues().addPropertyValue(\"onreturnMethod\", returnMethod); // 12.2 å¤„ç† onthrow å±æ€§ &#125; else if (\"onthrow\".equals(property)) &#123; int index = value.lastIndexOf(\".\"); String throwRef = value.substring(0, index); String throwMethod = value.substring(index + 1); // åˆ›å»º RuntimeBeanReferenceï¼ŒæŒ‡å‘å›è°ƒçš„å¯¹è±¡ reference = new RuntimeBeanReference(throwRef); // è®¾ç½® onthrowMethod åˆ° BeanDefinition çš„å±æ€§å€¼ beanDefinition.getPropertyValues().addPropertyValue(\"onthrowMethod\", throwMethod); //12.3 å¤„ç†oninvoke å±æ€§ &#125; else if (\"oninvoke\".equals(property)) &#123; int index = value.lastIndexOf(\".\"); String invokeRef = value.substring(0, index); String invokeRefMethod = value.substring(index + 1); reference = new RuntimeBeanReference(invokeRef); beanDefinition.getPropertyValues().addPropertyValue(\"oninvokeMethod\", invokeRefMethod); //----------------------------- äº‹ä»¶é€šçŸ¥ç»“æŸ ------------------------------// &#125; else &#123; // 13. å±æ€§åæ²¡æœ‰åŒ¹é…åˆ°å¯¹åº”çš„æ ‡ç­¾åï¼Œéƒ½ä¼šåˆ°è¿™é‡Œ //13.1 å¦‚æœå±æ€§åæ˜¯ref, ref å¯¹åº”çš„Bean å¿…é¡»æ˜¯å•ä¾‹çš„ if (\"ref\".equals(property) &amp;&amp; parserContext.getRegistry().containsBeanDefinition(value)) &#123; BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value); if (!refBean.isSingleton()) &#123; throw new IllegalStateException(\"The exported service ref \" + value + \" must be singleton! Please set the \" + value + \" bean scope to singleton, eg: &lt;bean id=\\\"\" + value + \"\\\" scope=\\\"singleton\\\" ...&gt;\"); &#125; &#125; // åˆ›å»ºRuntimeBeanReference reference = new RuntimeBeanReference(value); &#125; // è®¾ç½®Beanå®šä¹‰çš„å±æ€§ beanDefinition.getPropertyValues().addPropertyValue(property, reference); &#125; &#125; &#125; &#125; &#125; &#125; // å°†æ ‡ç­¾ä¸­è‡ªå®šä¹‰çš„å±æ€§ï¼ˆä¸æ˜¯Dubbo Schema çº¦å®šå¥½çš„ï¼‰ä¹ŸåŠ å…¥åˆ° parameters é›†åˆä¸­ NamedNodeMap attributes = element.getAttributes(); int len = attributes.getLength(); for (int i = 0; i &lt; len; i++) &#123; Node node = attributes.item(i); String name = node.getLocalName(); if (!props.contains(name)) &#123; if (parameters == null) &#123; parameters = new ManagedMap(); &#125; String value = node.getNodeValue(); parameters.put(name, new TypedStringValue(value, String.class)); &#125; &#125; if (parameters != null) &#123; beanDefinition.getPropertyValues().addPropertyValue(\"parameters\", parameters); &#125; return beanDefinition; &#125; ä¸Šé¢çš„ä»£ç æ˜¯æŠŠå±æ€§æ³¨å…¥åˆ°æ ‡ç­¾å¯¹åº”çš„BeanDefinitionï¼Œå¦‚æœå±æ€§æ˜¯å¼•ç”¨å¯¹è±¡ï¼ŒDubboé»˜è®¤ä¼šåˆ›å»º RuntimeBeanReference ç±»å‹æ³¨å…¥ï¼Œè¿è¡Œæ—¶ç”±Springæ³¨å…¥å¼•ç”¨å¯¹è±¡ã€‚ æ€»ç»“Dubboæ¡†æ¶è§£æé…ç½®æ–‡ä»¶ç”ŸæˆBeanDefinitionå…¶å®æ˜¯ç”Ÿæˆæ ‡ç­¾å¯¹åº”çš„é…ç½®ç±»çš„Beanå®šä¹‰ï¼ŒBeanå®šä¹‰ä¸­çš„å±æ€§å€¼ä¸»è¦æ¥æºäºæ ‡ç­¾çš„å±æ€§å€¼ï¼ŒDubboå¯¹æ ‡ç­¾å±æ€§åªæ˜¯è¿›è¡Œäº†æå–ï¼Œæ ‡ç­¾çš„å†…åµŒæ ‡ç­¾å¤„ç†ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œè¿è¡Œæ—¶å±æ€§æ³¨å…¥å’Œè½¬æ¢éƒ½è¿˜æ˜¯Springæ¥å®Œæˆçš„ï¼ŒDubboæ¡†æ¶ç”Ÿæˆçš„BeanDefinitionæœ€ç»ˆä¼šå§”æ‰˜Springåˆ›å»ºå¯¹åº”çš„å¯¹è±¡ï¼Œè¿™ä¸ªå±äºSpringçš„æµç¨‹å°±ä¸å¤šè¯´äº†ã€‚dubbo.xsdæ–‡ä»¶ä¸­å®šä¹‰çš„ç±»å‹éƒ½ä¼šæœ‰ä¸ä¹‹å¯¹åº”çš„é…ç½®æ‰¿è½½ç±»ä¸­çš„å±æ€§ï¼Œæˆ‘ä»¬å·²ç»åœ¨APIé…ç½®ä¸­ä»‹ç»è¿‡äº†ã€‚XMLé…ç½®è§£æè¿˜æ˜¯æŒºå¤æ‚çš„ï¼Œåˆ†æ”¯æµæ¯”è¾ƒå¤šï¼Œä¸‹ä¸€ç« è¦åˆ†æçš„æ³¨è§£é…ç½®ç¨å¾®æ¯”è¿™ä¸ªå¤æ‚ä¸€äº›ã€‚éšç€åé¢æ·±å…¥çš„åˆ†æå°±ä¼šå‘ç°è¿™äº›ä¸œè¥¿éƒ½æ˜¯åŸºç¡€ï¼Œç»“åˆDubboçš„æ•´ä¸ªè¿‡ç¨‹å°±å¾ˆå®¹æ˜“ç†è§£äº†ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboæºç åˆ†æ - APIå’Œå±æ€§é…ç½®","slug":"rpc/APIé…ç½®","date":"2020-03-24T16:00:00.000Z","updated":"2020-09-03T03:12:53.647Z","comments":false,"path":"posts/1d3295e6/","link":"","permalink":"https://gentryhuang.com/posts/1d3295e6/","excerpt":"","text":"å‰è¨€æˆ‘ä»¬é€šè¿‡ Dubbo URLç»Ÿä¸€æ¨¡å‹ å·²ç»äº†è§£äº†Dubbo URLæ˜¯Dubooçš„é…ç½®æ€»çº¿ï¼Œè´¯ç©¿æ•´ä¸ªDubboçš„ç”Ÿå‘½å‘¨æœŸã€‚è™½ç„¶Dubbo URLç›´æ¥å†³å®šäº†Dubboç»„ä»¶çš„è§’è‰²å¹¶æ§åˆ¶Dubboçš„è¡Œä¸ºï¼Œä½†æ˜¯Dubbo URLä¸­çš„ä¿¡æ¯éœ€è¦Dubboçš„é…ç½®æ‰¿å¯¹è±¡æ¥æä¾›ï¼Œè€Œé…ç½®æ‰¿è½½å¯¹è±¡ä¸­çš„æ•°æ®æ¥æºäºå¤šç§é…ç½®å’Œè®¾ç½®ã€‚ ç›®å‰Dubboæ¡†æ¶åŒæ—¶æ”¯æŒ4ç§é…ç½®æ–¹å¼ï¼šAPIç¡¬ç¼–ç é…ç½®ã€XMLé…ç½®ã€æ³¨è§£é…ç½®ã€å±æ€§é…ç½®ã€‚è€Œæ‰€æœ‰çš„é…ç½®é¡¹åˆ†ä¸ºä¸‰å¤§ç±»: æœåŠ¡æ³¨å†Œå’Œå‘ç°ï¼šè¡¨ç¤ºè¯¥é…ç½®é¡¹ç”¨äºæœåŠ¡çš„æ³¨å†Œå’Œå‘ç°ã€‚ æœåŠ¡æ²»ç†ï¼šè¡¨ç¤ºè¯¥é…ç½®é¡¹ç”¨äºæ²»ç†æœåŠ¡é—´çš„å…³ç³»ï¼Œæˆ–ä¸ºå¼€å‘æµ‹è¯•æä¾›ä¾¿åˆ©æ¡ä»¶ã€‚ æ€§èƒ½è°ƒä¼˜ï¼šè¡¨ç¤ºè¯¥é…ç½®é¡¹ç”¨äºè°ƒä¼˜æ€§èƒ½ï¼Œä¸åŒçš„é€‰é¡¹å¯¹æ€§èƒ½ä¼šäº§ç”Ÿå½±å“ã€‚ æ³¨æ„ï¼šæ‰€æœ‰é…ç½®æœ€ç»ˆéƒ½ä¼šè½¬æ¢ä¸ºDubbo URL é…ç½®æ‰¿è½½å¯¹è±¡ä¸ç®¡æ˜¯æ³¨è§£è¿˜æ˜¯XMLé…ç½®éƒ½éœ€è¦é…ç½®å¯¹è±¡æ¥æ‰¿è½½ï¼ŒXMLé…ç½®ã€æ³¨è§£é…ç½®ã€å±æ€§é…ç½®éƒ½æ˜¯å’Œé…ç½®å¯¹è±¡æˆ–å…¶å±æ€§ç›¸æ˜ å°„çš„ï¼Œä¸ºä»€ä¹ˆè¿™é‡Œæ²¡æœ‰è¯´APIé…ç½®å’Œé…ç½®å¯¹è±¡çš„æ˜ å°„å…³ç³»å‘¢ï¼Ÿå…¶å®APIé…ç½®å°±æ˜¯ç›´æ¥æ“ä½œé…ç½®å¯¹è±¡ï¼Œè€ŒXMLé…ç½®å’Œæ³¨è§£é…ç½®éƒ½æ˜¯ç”±Springæ¥åˆ›å»ºé…ç½®å¯¹è±¡å¹¶è®¾ç½®å±æ€§çš„ï¼Œè€Œæˆ‘ä»¬çš„å±æ€§é…ç½®æ˜¯åœ¨é…ç½®å¯¹è±¡å·²ç»å­˜åœ¨çš„åŸºç¡€ä¸Šï¼Œä¸ºå…¶è®¾ç½®æŒ‡å®šçš„å±æ€§å€¼ã€‚ä¸‹é¢æ˜¯Dubboçš„å±æ€§é…ç½®ç±»çš„ç»“æ„ï¼š ä¸Šå›¾ä¸­æˆ‘ä½¿ç”¨äº†é»„è‰²æ¡†å’Œçº¢è‰²æ¡†åˆ†åˆ«å¯¹æŠ½è±¡é…ç½®ç±»å’Œé…ç½®å®ç°ç±»è¿›è¡Œäº†æ ‡æ³¨ï¼Œå…¶ä¸­DubboShutdownHookå…ˆå¿½ç•¥ã€‚çº¢è‰²æ¡†ä¸­çš„é…ç½®ç±»æ˜¯ç›´æ¥çš„é…ç½®æ‰¿è½½ç±»ï¼Œé»„è‰²æ¡†ä¸­çš„æŠ½è±¡é…ç½®ç±»æ˜¯é…ç½®æ‰¿è½½ç±»çš„çˆ¶ç±»ã€‚ä¸‹é¢æ˜¯é…ç½®æ‰¿è½½ç±»çš„UMLå›¾ï¼š ç›´è§‚å›¾ ä¾èµ–å…³ç³»å›¾ é€šè¿‡ä¸Šé¢çš„å…³ç³»å›¾æˆ‘ä»¬å¯ä»¥å¾ˆæ¸…æ¥šåœ°äº†è§£åˆ°æ¯ä¸ªé…ç½®ä¹‹é—´çš„å…³ç³»ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥å°±é¡ºç€å…³ç³»å›¾åˆ†åˆ«ä»‹ç»æ ¸å¿ƒçš„é…ç½®ç±»ã€‚ AbstractConfig æŠ½è±¡é…ç½®ç±»é™¤äº†ArgumentConfigé…ç½®ç±»ï¼Œå‡ ä¹å…¶ä»–çš„æ‰€æœ‰é…ç½®ç±»éƒ½ç›´æ¥æˆ–é—´æ¥ç»§æ‰¿è¯¥ç±»ï¼Œè¯¥ç±»ä¸»è¦æä¾›é…ç½®è§£æä¸æ ¡éªŒç›¸å…³çš„å·¥å…·æ–¹æ³•ã€‚ æ ¼å¼æ ¡éªŒ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public abstract class AbstractConfig implements Serializable &#123; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125; //-------------------------- æ ¼å¼æ£€éªŒ -----------------------------/ private static final int MAX_LENGTH = 200; private static final int MAX_PATH_LENGTH = 200; private static final Pattern PATTERN_NAME = Pattern.compile(\"[\\\\-._0-9a-zA-Z]+\"); private static final Pattern PATTERN_MULTI_NAME = Pattern.compile(\"[,\\\\-._0-9a-zA-Z]+\"); private static final Pattern PATTERN_METHOD_NAME = Pattern.compile(\"[a-zA-Z][0-9a-zA-Z]*\"); private static final Pattern PATTERN_PATH = Pattern.compile(\"[/\\\\-$._0-9a-zA-Z]+\"); private static final Pattern PATTERN_NAME_HAS_SYMBOL = Pattern.compile(\"[:*,/\\\\-._0-9a-zA-Z]+\"); private static final Pattern PATTERN_KEY = Pattern.compile(\"[*,\\\\-._0-9a-zA-Z]+\"); protected static void checkExtension(Class&lt;?&gt; type, String property, String value) &#123; checkName(property, value); if (value != null &amp;&amp; value.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(type).hasExtension(value)) &#123; throw new IllegalStateException(\"No such extension \" + value + \" for \" + property + \"/\" + type.getName()); &#125; &#125; protected static void checkMultiExtension(Class&lt;?&gt; type, String property, String value) &#123; checkMultiName(property, value); if (value != null &amp;&amp; value.length() &gt; 0) &#123; String[] values = value.split(\"\\\\s*[,]+\\\\s*\"); for (String v : values) &#123; if (v.startsWith(Constants.REMOVE_VALUE_PREFIX)) &#123; v = v.substring(1); &#125; if (Constants.DEFAULT_KEY.equals(v)) &#123; continue; &#125; if (!ExtensionLoader.getExtensionLoader(type).hasExtension(v)) &#123; throw new IllegalStateException(\"No such extension \" + v + \" for \" + property + \"/\" + type.getName()); &#125; &#125; &#125; &#125; protected static void checkLength(String property, String value) &#123; checkProperty(property, value, MAX_LENGTH, null); &#125; protected static void checkPathLength(String property, String value) &#123; checkProperty(property, value, MAX_PATH_LENGTH, null); &#125; protected static void checkName(String property, String value) &#123; checkProperty(property, value, MAX_LENGTH, PATTERN_NAME); &#125; protected static void checkNameHasSymbol(String property, String value) &#123; checkProperty(property, value, MAX_LENGTH, PATTERN_NAME_HAS_SYMBOL); &#125; protected static void checkKey(String property, String value) &#123; checkProperty(property, value, MAX_LENGTH, PATTERN_KEY); &#125; protected static void checkMultiName(String property, String value) &#123; checkProperty(property, value, MAX_LENGTH, PATTERN_MULTI_NAME); &#125; protected static void checkPathName(String property, String value) &#123; checkProperty(property, value, MAX_PATH_LENGTH, PATTERN_PATH); &#125; protected static void checkMethodName(String property, String value) &#123; checkProperty(property, value, MAX_LENGTH, PATTERN_METHOD_NAME); &#125; protected static void checkParameterName(Map&lt;String, String&gt; parameters) &#123; if (parameters == null || parameters.size() == 0) &#123; return; &#125; for (Map.Entry&lt;String, String&gt; entry : parameters.entrySet()) &#123; checkNameHasSymbol(entry.getKey(), entry.getValue()); &#125; &#125; protected static void checkProperty(String property, String value, int maxlength, Pattern pattern) &#123; if (value == null || value.length() == 0) &#123; return; &#125; if (value.length() &gt; maxlength) &#123; throw new IllegalStateException(\"Invalid \" + property + \"=\\\"\" + value + \"\\\" is longer than \" + maxlength); &#125; if (pattern != null) &#123; Matcher matcher = pattern.matcher(value); if (!matcher.matches()) &#123; throw new IllegalStateException(\"Invalid \" + property + \"=\\\"\" + value + \"\\\" contains illegal \" + \"character, only digit, letter, '-', '_' or '.' is legal.\"); &#125; &#125; &#125; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; AbstractConfigçš„å­ç±»ä¼šè°ƒç”¨è¿™é‡Œçš„æ–¹æ³•è¿›è¡Œç›¸å…³çš„å‚æ•°æ ¡éªŒã€‚ æ·»åŠ å±æ€§ï¼ˆå±æ€§å’Œç³»ç»Ÿå‚æ•°é…ç½®ï¼‰è¯»å–å¯åŠ¨å‚æ•°å˜é‡å’ŒPropertiesé…ç½®æ–‡ä»¶ä¸­å±æ€§åˆ°é…ç½®æ‰¿è½½å¯¹è±¡ä¸­ï¼Œè¯¥æ–¹æ³•å…¶å®å°±æ˜¯å±æ€§é…ç½® å’Œ ç³»ç»Ÿå‚æ•°é…ç½®çš„é€»è¾‘ã€‚è¿™ä¸ªé€»è¾‘éå¸¸é‡è¦ï¼Œæ— è®ºæ˜¯APIé…ç½®è¿˜æ˜¯XMLé…ç½®ï¼Œä»¥åŠæ³¨è§£é…ç½®ï¼Œéƒ½ä¼šä½¿ç”¨è¯¥é€»è¾‘ä¸ºé…ç½®æ‰¿è½½å¯¹è±¡è®¾ç½®ç³»ç»Ÿå‚æ•°å€¼ä»¥åŠé…ç½®å±æ€§å€¼ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public abstract class AbstractConfig implements Serializable &#123; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125; /** * 1 id å±æ€§ï¼ŒBeanå®šä¹‰çš„åç§°ï¼Œé€‚ç”¨äºé™¤äº†APIé…ç½®ä¹‹å¤–çš„ä¸‰ç§é…ç½®ï¼ˆå±æ€§é…ç½®ï¼Œxmlé…ç½®,æ³¨è§£é…ç½®ï¼‰æ–¹å¼ï¼Œå¯ç”¨äºå¯¹è±¡ä¹‹é—´çš„å¼•ç”¨ * 2 ä¸é€‚ç”¨APIé…ç½®ï¼Œæ˜¯å› ä¸ºAPIé…ç½®ç›´æ¥setter(xxx)å¯¹è±¡å³å¯ */ protected String id; /** * è¯»å–å¸¦æœ‰é…ç½®é¡¹åå‰ç¼€çš„å¯åŠ¨å‚æ•°å˜é‡å’Œpropertiesé…ç½®åˆ° é…ç½®æ‰¿è½½å¯¹è±¡ä¸­ã€‚ * è¯´æ˜ï¼šåœ¨æ­¤ä¹‹å‰é…ç½®æ‰¿è½½å¯¹è±¡ä¸­åªå¯èƒ½æœ‰xmlé…ç½®çš„å±æ€§å€¼ï¼Œæˆ–è€…æ³¨è§£é…ç½®çš„å±æ€§å€¼ * * @param config é…ç½®å¯¹è±¡ */ protected static void appendProperties(AbstractConfig config) &#123; if (config == null) &#123; return; &#125; // è·å¾—é…ç½®é¡¹å‰ç¼€ï¼ˆä½¿ç”¨é…ç½®ç±»çš„ç±»åï¼Œè·å¾—å¯¹åº”çš„å±æ€§æ ‡ç­¾ï¼‰-&gt; dubbo.tag. String prefix = \"dubbo.\" + getTagName(config.getClass()) + \".\"; // è·å¾—é…ç½®ç±»çš„æ‰€æœ‰æ–¹æ³•ï¼Œç”¨äºä¸‹é¢é€šè¿‡åå°„è·å¾—é…ç½®é¡¹çš„å±æ€§åï¼Œå†ç”¨å±æ€§åå»è¯»å–å¯åŠ¨å‚æ•°å˜é‡å’Œ.propertiesé…ç½®åˆ°é…ç½®å¯¹è±¡ Method[] methods = config.getClass().getMethods(); for (Method method : methods) &#123; try &#123; // æ‹¿åˆ°æ–¹æ³•å String name = method.getName(); // é€‰æ‹©æ–¹æ³•æ˜¯ ã€public &amp;&amp; setter &amp;&amp; å”¯ä¸€å‚æ•°ä¸ºåŸºæœ¬ç±»å‹ã€‘ çš„æ–¹æ³• if (name.length() &gt; 3 &amp;&amp; name.startsWith(\"set\") &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 1 &amp;&amp; isPrimitive(method.getParameterTypes()[0])) &#123; // è·å¾—å±æ€§å å¦‚ï¼š ApplicationConfig#setName(...) æ–¹æ³•ï¼Œå¯¹åº”çš„å±æ€§åä¸º name String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \".\"); //----------- è¯»å–çš„è¦†ç›–ç­–ç•¥ï¼š JVM -D &gt; XML &gt; .properties ----------/ String value = null; //ã€å¯åŠ¨å‚æ•°å˜é‡ã€‘ä¼˜å…ˆä»å¸¦æœ‰ idå±æ€§çš„XxxConfigçš„é…ç½®ä¸­è·å–ï¼Œä¾‹å¦‚ dubbo.application.demo-provider.name if (config.getId() != null &amp;&amp; config.getId().length() &gt; 0) &#123; // idå­—æ®µ String pn = prefix + config.getId() + \".\" + property; value = System.getProperty(pn); if (!StringUtils.isBlank(value)) &#123; logger.info(\"Use System Property \" + pn + \" to config dubbo\"); &#125; &#125; //ã€å¯åŠ¨å‚æ•°å˜é‡ã€‘è·å–ä¸åˆ°ï¼Œå†ä»ä¸å¸¦ idå±æ€§ çš„XxxConfigçš„é…ç½®ä¸­è·å–ï¼Œä¾‹å¦‚ï¼šdubbo.application.name if (value == null || value.length() == 0) &#123; // æ²¡æœ‰idå­—æ®µ String pn = prefix + property; value = System.getProperty(pn); if (!StringUtils.isBlank(value)) &#123; logger.info(\"Use System Property \" + pn + \" to config dubbo\"); &#125; &#125; // é…ç½®ä¼˜å…ˆçº§ä»¥åŠè¦†ç›–ï¼š å¯åŠ¨å‚æ•°å˜é‡ &gt; XMLé…ç½®[æ³¨è§£/javaé…ç½®] &gt; propertiesé…ç½® ã€‚å› æ­¤éœ€è¦ä½¿ç”¨getteråˆ¤æ–­XMLæ˜¯å¦å·²ç»é…ç½® if (value == null || value.length() == 0) &#123; Method getter; try &#123; getter = config.getClass().getMethod(\"get\" + name.substring(3)); &#125; catch (NoSuchMethodException e) &#123; try &#123; getter = config.getClass().getMethod(\"is\" + name.substring(3)); &#125; catch (NoSuchMethodException e2) &#123; getter = null; &#125; &#125; if (getter != null) &#123; // ä½¿ç”¨getter åˆ¤æ–­XMLæ˜¯å¦å·²ç»è®¾ç½®è¿‡ï¼Œå¦‚æœæ²¡æœ‰è®¾ç½®çš„è¯å°±ä».propertiesæ–‡ä»¶ä¸­è¯»å– if (getter.invoke(config) == null) &#123; // [propertiesé…ç½®] ä¼˜å…ˆä»å¸¦æœ‰ id å±æ€§çš„é…ç½®ä¸­è·å–ï¼Œä¾‹å¦‚ï¼šdubbo.application.demo-provider.name if (config.getId() != null &amp;&amp; config.getId().length() &gt; 0) &#123; value = ConfigUtils.getProperty(prefix + config.getId() + \".\" + property); &#125; // [propertiesé…ç½®]è·å–ä¸åˆ°ï¼Œå†ä»ä¸å¸¦ id å±æ€§çš„é…ç½®ä¸­è·å–ï¼Œä¾‹å¦‚ï¼šdubbo.application.name if (value == null || value.length() == 0) &#123; value = ConfigUtils.getProperty(prefix + property); &#125; // [propertiesé…ç½®]è·å–ä¸åˆ°ï¼Œè¿™é‡Œè¿›è¡Œè€ç‰ˆæœ¬å…¼å®¹ï¼Œä»ä¸å¸¦idå±æ€§çš„é…ç½®ä¸­è·å– if (value == null || value.length() == 0) &#123; String legacyKey = legacyProperties.get(prefix + property); if (legacyKey != null &amp;&amp; legacyKey.length() &gt; 0) &#123; value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey)); &#125; &#125; &#125; &#125; &#125; // è·å–åˆ°å€¼ï¼ˆç³»ç»Ÿå‚æ•°é…ç½®æˆ–è€….propertiesæ–‡ä»¶ä¸­çš„ï¼Œä¸åŒ…å«xmlé…ç½®ï¼Œxmlé…ç½®æœ‰å•ç‹¬çš„è®¾ç½®æ–¹æ³•ï¼‰ if (value != null &amp;&amp; value.length() &gt; 0) &#123; method.invoke(config, convertPrimitive(method.getParameterTypes()[0], value)); &#125; &#125; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; &#125; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; ä¸Šé¢çš„ä»£ç ä¸»è¦å°±æ˜¯ä¸ºå·²ç»å®ä¾‹åŒ–å¥½çš„é…ç½®æ‰¿è½½å¯¹è±¡è®¾ç½®å±æ€§å€¼ï¼Œä¸»è¦é€»è¾‘å¦‚ä¸‹ï¼š æ ¹æ®é…ç½®å¯¹è±¡è·å–å±æ€§é…ç½®çš„å‰ç¼€ï¼Œå¦‚ dubbo.application. éå†é…ç½®æ‰¿è½½å¯¹è±¡ä¸­çš„æ‰€æœ‰æ–¹æ³•æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„setteræ–¹æ³• æ ¹æ®é…ç½®è¦†ç›–ç­–ç•¥çš„ä¼˜å…ˆçº§ï¼Œè®¾ç½®é…ç½®æ‰¿è½½å¯¹è±¡çš„å±æ€§å€¼ é…ç½®å¯¹è±¡çš„å±æ€§åˆ°å‚æ•°é›†åˆå°†é…ç½®æ‰¿è½½å¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°å‚æ•°é›†åˆä¸­ï¼Œç”¨äºæ„å»ºDubbo URLï¼Œå¦‚åœ¨æœåŠ¡æš´éœ²å’Œå¼•ç”¨æ˜¯æ„å»ºç›¸å…³çš„URLã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public abstract class AbstractConfig implements Serializable &#123; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125; /** * å°†é…ç½®å¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°å‚æ•°é›†åˆ * * @param parameters * @param config */ protected static void appendParameters(Map&lt;String, String&gt; parameters, Object config) &#123; appendParameters(parameters, config, null); &#125; /** * å°†é…ç½®å¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°å‚æ•°é›†åˆï¼Œä¸»è¦é€»è¾‘ï¼š * &lt;p&gt; * 1 é€šè¿‡åå°„è·å–ç›®æ ‡å¯¹è±¡çš„getteræ–¹æ³•ï¼Œå¹¶è°ƒç”¨è¯¥æ–¹æ³•è·å–å±æ€§å€¼ï¼Œç„¶åå†é€šè¿‡getteræ–¹æ³•åè§£æå‡ºå±æ€§åï¼Œå¦‚ï¼šä»æ–¹æ³•ågetNameä¸­å¯è§£æå‡ºå±æ€§nameï¼Œå¦‚æœç”¨æˆ·ä¼ å…¥äº†å±æ€§åå‰ç¼€ï¼Œæ­¤æ—¶éœ€è¦å°†å±æ€§ååŠ å…¥å‰ç¼€å†…å®¹ã€‚ * 2 å°† å±æ€§å-å±æ€§å€¼ é”®å€¼å¯¹å­˜å…¥åˆ°mapä¸­å°±å¯ä»¥äº† * * @param parameters å‚æ•°é›†åˆï¼Œè¯¥é›†åˆä¼šç”¨äºURL * @param config é…ç½®å¯¹è±¡ * @param prefix å±æ€§å‰ç¼€ã€‚ç”¨äºé…ç½®é¡¹æ·»åŠ åˆ°å‚æ•°é›†åˆä¸­æ—¶çš„å‰ç¼€ */ @SuppressWarnings(\"unchecked\") protected static void appendParameters(Map&lt;String, String&gt; parameters, Object config, String prefix) &#123; if (config == null) &#123; return; &#125; // è·å¾—æ‰€æœ‰æ–¹æ³•çš„æ•°ç»„ï¼Œä¸ºä¸‹é¢é€šè¿‡åå°„è·å¾—é…ç½®é¡¹çš„å€¼åšå‡†å¤‡ Method[] methods = config.getClass().getMethods(); for (Method method : methods) &#123; try &#123; String name = method.getName(); // é€‰æ‹©æ–¹æ³•ä¸º è¿”å›å€¼ä¸ºåŸºæœ¬ç±»å‹ + publicçš„getter/isæ–¹æ³• ï¼ˆå’Œè§£æåˆ°é…ç½®ç±»çš„è¿‡æ»¤æ·»åŠ å‘¼åº”ï¼‰ if ((name.startsWith(\"get\") || name.startsWith(\"is\")) &amp;&amp; !\"getClass\".equals(name) &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 0 &amp;&amp; isPrimitive(method.getReturnType())) &#123; // å°è¯•è·å–æ–¹æ³•ä¸Šçš„@Parameteræ³¨è§£ Parameter parameter = method.getAnnotation(Parameter.class); // æ–¹æ³•è¿”å›ç±»å‹æ˜¯Objectçš„æˆ–è€…æ–¹æ³•çš„@Parameter(excluded = true)çš„ï¼Œ ä¸ç»Ÿè®¡å¯¹åº”çš„å€¼åˆ°å‚æ•°é›†åˆ if (method.getReturnType() == Object.class || parameter != null &amp;&amp; parameter.excluded()) &#123; continue; &#125; // è·å¾—å±æ€§å int i = name.startsWith(\"get\") ? 3 : 2; String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), \".\"); String key; // @Parameteræ³¨è§£æœ‰é…ç½®keyå±æ€§å°±å–å‡ºè¯¥å€¼ if (parameter != null &amp;&amp; parameter.key().length() &gt; 0) &#123; key = parameter.key(); &#125; else &#123; key = prop; &#125; // åˆ©ç”¨åå°„è·å¾—å±æ€§çš„å€¼ Object value = method.invoke(config); String str = String.valueOf(value).trim(); if (value != null &amp;&amp; str.length() &gt; 0) &#123; // æ˜¯å¦è½¬ç§»ï¼Œé»˜è®¤ä¸è½¬è¯‘ if (parameter != null &amp;&amp; parameter.escaped()) &#123; str = URL.encode(str); &#125; // @Parameteræ³¨è§£æœ‰é…ç½®appendå±æ€§ï¼Œå°±è¿›è¡Œæ‹¼æ¥ if (parameter != null &amp;&amp; parameter.append()) &#123; // 1. çœ‹å‚æ•°é›†åˆä¸­æ˜¯å¦æœ‰keyä¸ºï¼š default.keyçš„å€¼(é»˜è®¤å±æ€§å€¼),æœ‰å°±æ‹¼æ¥åˆ°å±æ€§å€¼å‰é¢ String pre = parameters.get(Constants.DEFAULT_KEY + \".\" + key); if (pre != null &amp;&amp; pre.length() &gt; 0) &#123; str = pre + \",\" + str; &#125; // 2. çœ‹å‚æ•°é›†åˆä¸­æ˜¯å¦æœ‰keyå¯¹åº”çš„å€¼ï¼Œæœ‰å°±æ‹¼æ¥åˆ°å±æ€§å€¼å‰é¢ pre = parameters.get(key); if (pre != null &amp;&amp; pre.length() &gt; 0) &#123; str = pre + \",\" + str; &#125; &#125; // å¦‚æœæŒ‡å®šäº†å±æ€§å‰ç¼€å°±æ‹¼æ¥ä¸Šå»ï¼Œå°±åœ¨å±æ€§åå‰é¢åŠ ä¸Šå‰ç¼€ if (prefix != null &amp;&amp; prefix.length() &gt; 0) &#123; key = prefix + \".\" + key; &#125; // æŠŠæœ€åå¤„ç†çš„å±æ€§å€¼åŠ å…¥å‚æ•°é›†åˆä¸­ parameters.put(key, str); // å½“é…ç½®å¯¹è±¡çš„å±æ€§getteræ–¹æ³•åŠ äº†@Parameter(required=true)æ—¶ï¼Œæ ¡éªŒé…ç½®é¡¹éç©º &#125; else if (parameter != null &amp;&amp; parameter.required()) &#123; throw new IllegalStateException(config.getClass().getSimpleName() + \".\" + key + \" == null\"); &#125; // å½“æ–¹æ³•ä¸ºpublic Map getParameters()&#123;...&#125;æ—¶ï¼Œå°±ä»¥æ­¤å°†Mapä¸­çš„key-valueåŠ å…¥åˆ°å‚æ•°é›†åˆ &#125; else if (\"getParameters\".equals(name) &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 0 &amp;&amp; method.getReturnType() == Map.class) &#123; // é€šè¿‡ getParameters()æ–¹æ³•ï¼Œè·å–åŠ¨æ€è®¾ç½®çš„é…ç½®é¡¹ Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) method.invoke(config, new Object[0]); if (map != null &amp;&amp; map.size() &gt; 0) &#123; String pre = (prefix != null &amp;&amp; prefix.length() &gt; 0 ? prefix + \".\" : \"\"); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue()); &#125; &#125; &#125; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; &#125; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; ä¸Šé¢ä»£ç ä¸»è¦å°±æ˜¯å°†é…ç½®æ‰¿è½½å¯¹è±¡ä¸­çš„å±æ€§è®¾ç½®åˆ°å±æ€§é›†åˆMapä¸­ï¼Œç”¨äºæ„å»ºDubbo URLã€‚æ•´ä¸ªé€»è¾‘éœ€è¦æ³¨æ„ï¼Œé…ç½®æ‰¿è½½å¯¹è±¡çš„getteræ–¹æ³•ä¸Šæ ‡æ³¨çš„ @Parameter æ³¨è§£ï¼Œä»¥åŠé…ç½®æ‰¿è½½å¯¹è±¡çš„getParametersæ–¹æ³•ã€‚ æ·»åŠ äº‹ä»¶é€šçŸ¥å±æ€§12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public abstract class AbstractConfig implements Serializable &#123; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125; protected static void appendAttributes(Map&lt;Object, Object&gt; parameters, Object config) &#123; appendAttributes(parameters, config, null); &#125; /** * * @param parameters å‚æ•°é›†åˆ * @param config é…ç½®å¯¹è±¡ * @param prefix å±æ€§å‰ç¼€ã€‚ç”¨äºé…ç½®é¡¹æ·»åŠ åˆ°å‚æ•°é›†åˆä¸­æ—¶çš„å‰ç¼€ */ protected static void appendAttributes(Map&lt;Object, Object&gt; parameters, Object config, String prefix) &#123; if (config == null) &#123; return; &#125; Method[] methods = config.getClass().getMethods(); for (Method method : methods) &#123; try &#123; String name = method.getName(); // é€‰æ‹©æ–¹æ³•ä¸º è¿”å›å€¼ä¸ºåŸºæœ¬ç±»å‹ + publicçš„getter/isæ–¹æ³• ï¼ˆå’Œè§£æåˆ°é…ç½®ç±»çš„è¿‡æ»¤æ·»åŠ å‘¼åº”ï¼‰ if ((name.startsWith(\"get\") || name.startsWith(\"is\")) &amp;&amp; !\"getClass\".equals(name) &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 0 &amp;&amp; isPrimitive(method.getReturnType())) &#123; // é€‰æ‹©å¸¦æœ‰@Parameter(attribute=true)çš„æ–¹æ³• Parameter parameter = method.getAnnotation(Parameter.class); if (parameter == null || !parameter.attribute()) &#123; continue; &#125; String key; parameter.key(); if (parameter.key().length() &gt; 0) &#123; key = parameter.key(); &#125; else &#123; int i = name.startsWith(\"get\") ? 3 : 2; key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1); &#125; // è·å¾—å±æ€§å€¼ï¼Œå­˜åœ¨åˆ™æ·»åŠ åˆ°å‚æ•°é›†åˆä¸­ Object value = method.invoke(config); if (value != null) &#123; if (prefix != null &amp;&amp; prefix.length() &gt; 0) &#123; key = prefix + \".\" + key; &#125; parameters.put(key, value); &#125; &#125; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; &#125; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; ä¸Šé¢ä»£ç ä¸»è¦ç”¨äºDubboçš„äº‹ä»¶é€šçŸ¥çš„ï¼Œå…·ä½“æ˜¯æ ‡æ³¨åœ¨MethodConfigé…ç½®æ‰¿è½½å¯¹è±¡çš„ getOnreturn(),getOnreturnMethod(),getOnthrow()â€¦æ–¹æ³•ä¸Šã€‚ AbstractInterfaceConfig æŠ½è±¡é…ç½®ç±»ç»§æ‰¿å…³ç³»å¦‚ä¸‹ï¼š 123AbstractConfig - AbstractMethodConfig - AbstractInterfaceConfig AbstractConfigæŠ½è±¡ç±»çš„æ ¸å¿ƒé€»è¾‘å·²ç»åˆ†æè¿‡ï¼ŒAbstractMethodConfigæŠ½è±¡ç±»ä¸­æ²¡æœ‰æ¯”è¾ƒé‡è¦çš„é€»è¾‘ï¼ŒåŸºæœ¬éƒ½æ˜¯ é…ç½®å±æ€§çš„è®¾ç½®/è·å–æ–¹æ³•ï¼Œå°±ä¸å†åˆ†æï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ä¸€èµ·çœ‹ä¸‹AbstractInterfaceConfigæŠ½è±¡ç±»çš„é€»è¾‘ã€‚ æ ¡éªŒæ³¨å†Œä¸­å¿ƒé…ç½®123456789101112131415161718192021222324252627282930313233343536public abstract class AbstractInterfaceConfig extends AbstractMethodConfig &#123;// çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;protected void checkRegistry() &#123; // for backward compatibility if (registries == null || registries.isEmpty()) &#123; String address = ConfigUtils.getProperty(\"dubbo.registry.address\"); if (address != null &amp;&amp; address.length() &gt; 0) &#123; registries = new ArrayList&lt;RegistryConfig&gt;(); String[] as = address.split(\"\\\\s*[|]+\\\\s*\"); for (String a : as) &#123; RegistryConfig registryConfig = new RegistryConfig(); registryConfig.setAddress(a); registries.add(registryConfig); &#125; &#125; &#125; if ((registries == null || registries.isEmpty())) &#123; throw new IllegalStateException((getClass().getSimpleName().startsWith(\"Reference\") ? \"No such any registry to refer service in consumer \" : \"No such any registry to export service in provider \") + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", Please add &lt;dubbo:registry address=\\\"...\\\" /&gt; to your spring config. If you want unregister, please set &lt;dubbo:service registry=\\\"N/A\\\" /&gt;\"); &#125; for (RegistryConfig registryConfig : registries) &#123; // è°ƒç”¨AbstractConfigä¸­çš„æ–¹æ³• appendProperties(registryConfig); &#125; &#125;// çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; æ ¡éªŒåº”ç”¨é…ç½®123456789101112131415161718192021222324252627282930313233public abstract class AbstractInterfaceConfig extends AbstractMethodConfig &#123;// çœç•¥å…¶å®ƒä»£ç  $&#123;&#125; protected void checkApplication() &#123; // for backward compatibility if (application == null) &#123; String applicationName = ConfigUtils.getProperty(\"dubbo.application.name\"); if (applicationName != null &amp;&amp; applicationName.length() &gt; 0) &#123; application = new ApplicationConfig(); &#125; &#125; if (application == null) &#123; throw new IllegalStateException( \"No such application config! Please add &lt;dubbo:application name=\\\"...\\\" /&gt; to your spring config.\"); &#125; // è°ƒç”¨AbstractConfigä¸­çš„æ–¹æ³• appendProperties(application); String wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_KEY); if (wait != null &amp;&amp; wait.trim().length() &gt; 0) &#123; System.setProperty(Constants.SHUTDOWN_WAIT_KEY, wait.trim()); &#125; else &#123; wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY); if (wait != null &amp;&amp; wait.trim().length() &gt; 0) &#123; System.setProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY, wait.trim()); &#125; &#125; &#125;// çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; åŠ è½½æ³¨å†Œä¸­å¿ƒURLæ•°ç»„12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public abstract class AbstractInterfaceConfig extends AbstractMethodConfig &#123;// çœç•¥å…¶å®ƒä»£ç  $&#123;&#125; /** * åŠ è½½æ³¨å†Œä¸­å¿ƒURLæ•°ç»„ * * @param provider æ˜¯å¦æ˜¯æœåŠ¡æä¾›è€… * @return URLæ•°ç»„ */ protected List&lt;URL&gt; loadRegistries(boolean provider) &#123; // æ ¡éªŒRegistryConfig é…ç½®æ•°ç»„ï¼Œä¸å­˜åœ¨ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œå¹¶ä¸”è¯¥æ–¹æ³•ä¼šåˆå§‹åŒ–RegistryConfigçš„é…ç½®å±æ€§ checkRegistry(); // åˆ›å»ºæ³¨å†Œä¸­å¿ƒURLæ•°ç»„ List&lt;URL&gt; registryList = new ArrayList&lt;URL&gt;(); if (registries != null &amp;&amp; !registries.isEmpty()) &#123; // éå†RegistryConfig æ•°ç»„ for (RegistryConfig config : registries) &#123; // è·å–æ³¨å†Œä¸­å¿ƒçš„åœ°å€ String address = config.getAddress(); // åœ°å€ä¸ºç©ºå°±ä½¿ç”¨ 0.0.0.0 ä»»æ„åœ°å€ if (address == null || address.length() == 0) &#123; address = Constants.ANYHOST_VALUE; &#125; // å¦‚æœé…ç½®äº†å¯åŠ¨å‚æ•°çš„æ³¨å†Œä¸­å¿ƒåœ°å€ï¼Œå®ƒçš„ä¼˜å…ˆçº§æœ€é«˜ï¼Œå°±è¿›è¡Œè¦†ç›– String sysaddress = System.getProperty(\"dubbo.registry.address\"); if (sysaddress != null &amp;&amp; sysaddress.length() &gt; 0) &#123; address = sysaddress; &#125; // é€‰æ‹©æœ‰æ•ˆçš„æ³¨å†Œä¸­å¿ƒåœ°å€ if (address.length() &gt; 0 &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123; // åˆ›å»ºå‚æ•°é›†åˆmap,ç”¨äºDubbo URLçš„æ„å»º Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // å°†åº”ç”¨é…ç½®å¯¹è±¡å’Œæ³¨å†Œä¸­å¿ƒé…ç½®å¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°å‚æ•°é›†åˆmapä¸­ appendParameters(map, application); /** * éœ€è¦æ³¨æ„çš„æ˜¯ï¼šRegistryConfig çš„ getAddressæ–¹æ³•ä¸Šä½¿ç”¨äº† @Parameter(excluded = true)æ³¨è§£ï¼Œå› æ­¤å®ƒçš„addresså±æ€§ä¸ä¼šåŠ å…¥åˆ°å‚æ•°é›†åˆmapä¸­ * @Parameter(excluded = true) * public String getAddress() &#123;return address;&#125; */ appendParameters(map, config); // æ·»åŠ  path,dubbo,timestamp,pid åˆ°å‚æ•°é›†åˆmapä¸­ map.put(\"path\", RegistryService.class.getName()); // è¿™é‡Œçš„pathè¦å’ŒæœåŠ¡æš´éœ²é€»è¾‘ä¸­çš„pathåŒºåˆ†ï¼Œæ³¨å†Œä¸­å¿ƒçš„URLä¸­çš„pathä¸ºRegistryServiceçš„å…¨è·¯å¾„å map.put(\"dubbo\", Version.getProtocolVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; // å‚æ•°é›†åˆmapä¸­ä¸å­˜åœ¨ protocol å‚æ•°ã€ä»¥ä¸Šé…ç½®å¯¹è±¡çš„å±æ€§ä¸­æ²¡æœ‰æœ‰æ•ˆçš„åè®®protocolå‚æ•°ã€‘ï¼Œå°±é»˜è®¤ ä½¿ç”¨ dubbo ä½œä¸º åè®®protocolçš„å€¼ if (!map.containsKey(\"protocol\")) &#123; // ä¸éœ€è€ƒè™‘remoteæ‰©å±•å®ç°çš„æƒ…å†µ if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(\"remote\")) &#123; map.put(\"protocol\", \"remote\"); &#125; else &#123; map.put(\"protocol\", \"dubbo\"); &#125; &#125; // è§£æåœ°å€ï¼Œåˆ›å»ºDubbo URLæ•°ç»„ï¼Œæ³¨æ„addresså¯èƒ½åŒ…å«å¤šä¸ªæ³¨å†Œä¸­å¿ƒip, ã€æ•°ç»„å¤§å°å¯ä»¥ä¸ºä¸€ã€‘ List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map); // å¾ªç¯ dubbo Register url for (URL url : urls) &#123; // è®¾ç½® registry=$&#123;protocol&#125;å‚æ•°,è®¾ç½®åˆ°æ³¨å†Œä¸­å¿ƒçš„ URLçš„å‚æ•°éƒ¨åˆ†çš„ä½ç½®ä¸Šï¼Œå¹¶ä¸”æ˜¯è¿½åŠ å¼çš„æ·»åŠ  url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol()); // é‡ç½® URLä¸­çš„ protocolå±æ€§ä¸º 'registry',å³å°†URLçš„åè®®å¤´è®¾ç½®ä¸º'registry' url = url.setProtocol(Constants.REGISTRY_PROTOCOL); /** * é€šè¿‡åˆ¤æ–­æ¡ä»¶ï¼Œå†³å®šæ˜¯å¦æ·»åŠ urlåˆ°registryListä¸­ï¼Œæ¡ä»¶å¦‚ä¸‹ï¼š * 1 å¦‚æœæ˜¯æœåŠ¡æä¾›è€…,æ˜¯å¦åªè®¢é˜…ä¸æ³¨å†Œï¼Œå¦‚æœæ˜¯å°±ä¸æ·»åŠ åˆ°æ³¨å†Œä¸­å¿ƒURLæ•°ç»„ä¸­ * 2 å¦‚æœæ˜¯æœåŠ¡æ¶ˆè´¹è€…ï¼Œæ˜¯å¦æ˜¯åªæ³¨å†Œä¸è®¢é˜…ï¼Œå¦‚æœæ˜¯å°±ä¸æ·»åŠ åˆ°æ³¨å†Œä¸­å¿ƒURLæ•°ç»„ä¸­ * */ if ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, true))) &#123; registryList.add(url); &#125; &#125; &#125; &#125; &#125; return registryList; &#125;// çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; åŠ è½½ç›‘æ§ä¸­å¿ƒURL12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public abstract class AbstractInterfaceConfig extends AbstractMethodConfig &#123;// çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;/** * åŠ è½½ç›‘æ§ä¸­å¿ƒURL * * @param registryURL æ³¨å†Œä¸­å¿ƒURL * @return ç›‘æ§ä¸­å¿ƒURL */ protected URL loadMonitor(URL registryURL) &#123; // å¦‚æœç›‘æ§é…ç½®ä¸ºç©ºï¼Œå°±ä»å±æ€§é…ç½®ä¸­åŠ è½½é…ç½®åˆ°MonitorConfig if (monitor == null) &#123; // è·å–ç›‘æ§åœ°å€ String monitorAddress = ConfigUtils.getProperty(\"dubbo.monitor.address\"); // è·å–ç›‘æ§åè®® String monitorProtocol = ConfigUtils.getProperty(\"dubbo.monitor.protocol\"); // æ²¡æœ‰é…ç½®å°±ç›´æ¥è¿”å› if ((monitorAddress == null || monitorAddress.length() == 0) &amp;&amp; (monitorProtocol == null || monitorProtocol.length() == 0)) &#123; return null; &#125; // åˆ›å»ºMonitorConfig monitor = new MonitorConfig(); if (monitorAddress != null &amp;&amp; monitorAddress.length() &gt; 0) &#123; monitor.setAddress(monitorAddress); &#125; if (monitorProtocol != null &amp;&amp; monitorProtocol.length() &gt; 0) &#123; monitor.setProtocol(monitorProtocol); &#125; &#125; // ä¸ºMonitorConfigåŠ è½½é…ç½®ã€å¯åŠ¨å‚æ•°å˜é‡å’Œpropertiesé…ç½®åˆ°é…ç½®å¯¹è±¡ã€‘ appendProperties(monitor); // æ·»åŠ  interface,dubbo,timestamp,pid åˆ° map é›†åˆä¸­ Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(Constants.INTERFACE_KEY, MonitorService.class.getName()); map.put(\"dubbo\", Version.getProtocolVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; //set ip String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY); if (hostToRegistry == null || hostToRegistry.length() == 0) &#123; hostToRegistry = NetUtils.getLocalHost(); &#125; else if (isInvalidLocalHost(hostToRegistry)) &#123; throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + Constants.DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry); &#125; map.put(Constants.REGISTER_IP_KEY, hostToRegistry); appendParameters(map, monitor); appendParameters(map, application); // è·å¾—ç›‘æ§åœ°å€ String address = monitor.getAddress(); // å¦‚æœå¯åŠ¨å‚æ•°é…ç½®äº†ç›‘æ§ä¸­å¿ƒåœ°å€ï¼Œå°±è¿›è¡Œè¦†ç›–ï¼Œå¯åŠ¨å‚æ•°ä¼˜å…ˆçº§æœ€é«˜ String sysaddress = System.getProperty(\"dubbo.monitor.address\"); if (sysaddress != null &amp;&amp; sysaddress.length() &gt; 0) &#123; address = sysaddress; &#125; // ç›´è¿ç›‘æ§ä¸­å¿ƒæœåŠ¡å™¨åœ°å€ if (ConfigUtils.isNotEmpty(address)) &#123; // è‹¥ç›‘æ§åœ°å€ä¸å­˜åœ¨ protocol å‚æ•°ï¼Œé»˜è®¤ dubbo æ·»åŠ åˆ° map é›†åˆä¸­ if (!map.containsKey(Constants.PROTOCOL_KEY)) &#123; // logstatè¿™ä¸ªæ‹“å±•å®ç°å·²ç»ä¸å­˜åœ¨äº†,å¯ä»¥å¿½ç•¥ if (ExtensionLoader.getExtensionLoader(MonitorFactory.class).hasExtension(\"logstat\")) &#123; map.put(Constants.PROTOCOL_KEY, \"logstat\"); &#125; else &#123; map.put(Constants.PROTOCOL_KEY, \"dubbo\"); &#125; &#125; // è§£æåœ°å€ï¼Œåˆ›å»ºDubbo URL å¯¹è±¡ return UrlUtils.parseURL(address, map); /** * 1 å½“ protocol=registryæ—¶ï¼Œå¹¶ä¸”æ³¨å†Œä¸­å¿ƒURLéç©ºæ—¶ï¼Œä»æ³¨å†Œä¸­å¿ƒå‘ç°ç›‘æ§ä¸­å¿ƒåœ°å€ï¼Œä»¥æ³¨å†Œä¸­å¿ƒURLä¸ºåŸºç¡€ï¼Œåˆ›å»ºç›‘æ§ä¸­å¿ƒURL * 2 åŸºäºæ³¨å†Œä¸­å¿ƒåˆ›å»ºçš„ç›‘æ§ä¸­å¿ƒURLï¼š protocol = dubbo,parameters.protocol=registry,parameter.refer=map */ &#125; else if (Constants.REGISTRY_PROTOCOL.equals(monitor.getProtocol()) &amp;&amp; registryURL != null) &#123; return registryURL.setProtocol(\"dubbo\").addParameter(Constants.PROTOCOL_KEY, \"registry\").addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)); &#125; return null; &#125;// çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; æ ¡éªŒæ¥å£å’Œæ–¹æ³•åˆ—è¡¨123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class AbstractInterfaceConfig extends AbstractMethodConfig &#123;// çœç•¥å…¶å®ƒä»£ç  $&#123;&#125; /** * æ ¡éªŒæ¥å£å’Œæ–¹æ³•ï¼š * 1 æ¥å£ç±»å¿…é¡»éç©ºå¹¶ä¸”å¿…é¡»æ˜¯æ¥å£ * 2 æ–¹æ³•åœ¨æ¥å£ä¸­å·²ç»å®šä¹‰ * * @param interfaceClass * @param methods */ protected void checkInterfaceAndMethods(Class&lt;?&gt; interfaceClass, List&lt;MethodConfig&gt; methods) &#123; // interface cannot be null if (interfaceClass == null) &#123; throw new IllegalStateException(\"interface not allow null!\"); &#125; // to verify interfaceClass is an interface if (!interfaceClass.isInterface()) &#123; throw new IllegalStateException(\"The interface class \" + interfaceClass + \" is not a interface!\"); &#125; // check if methods exist in the interface if (methods != null &amp;&amp; !methods.isEmpty()) &#123; for (MethodConfig methodBean : methods) &#123; String methodName = methodBean.getName(); if (methodName == null || methodName.length() == 0) &#123; throw new IllegalStateException(\"&lt;dubbo:method&gt; name attribute is required! Please check: &lt;dubbo:service interface=\\\"\" + interfaceClass.getName() + \"\\\" ... &gt;&lt;dubbo:method name=\\\"\\\" ... /&gt;&lt;/&lt;dubbo:reference&gt;\"); &#125; boolean hasMethod = false; for (java.lang.reflect.Method method : interfaceClass.getMethods()) &#123; if (method.getName().equals(methodName)) &#123; hasMethod = true; break; &#125; &#125; if (!hasMethod) &#123; throw new IllegalStateException(\"The interface \" + interfaceClass.getName() + \" not found method \" + methodName); &#125; &#125; &#125; &#125;// çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; æ ¡éªŒStubå’ŒMockç›¸å…³çš„é…ç½®1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public abstract class AbstractInterfaceConfig extends AbstractMethodConfig &#123;// çœç•¥å…¶å®ƒä»£ç  $&#123;&#125; /** * æ ¡éªŒStubå’ŒMockç›¸å…³çš„é…ç½® * * @param interfaceClass */ protected void checkStubAndMock(Class&lt;?&gt; interfaceClass) &#123; if (ConfigUtils.isNotEmpty(local)) &#123; Class&lt;?&gt; localClass = ConfigUtils.isDefault(local) ? ReflectUtils.forName(interfaceClass.getName() + \"Local\") : ReflectUtils.forName(local); if (!interfaceClass.isAssignableFrom(localClass)) &#123; throw new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceClass.getName()); &#125; try &#123; ReflectUtils.findConstructor(localClass, interfaceClass); &#125; catch (NoSuchMethodException e) &#123; throw new IllegalStateException(\"No such constructor \\\"public \" + localClass.getSimpleName() + \"(\" + interfaceClass.getName() + \")\\\" in local implementation class \" + localClass.getName()); &#125; &#125; if (ConfigUtils.isNotEmpty(stub)) &#123; Class&lt;?&gt; localClass = ConfigUtils.isDefault(stub) ? ReflectUtils.forName(interfaceClass.getName() + \"Stub\") : ReflectUtils.forName(stub); if (!interfaceClass.isAssignableFrom(localClass)) &#123; throw new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceClass.getName()); &#125; try &#123; ReflectUtils.findConstructor(localClass, interfaceClass); &#125; catch (NoSuchMethodException e) &#123; throw new IllegalStateException(\"No such constructor \\\"public \" + localClass.getSimpleName() + \"(\" + interfaceClass.getName() + \")\\\" in local implementation class \" + localClass.getName()); &#125; &#125; // mock é…ç½®æ ¡éªŒ if (ConfigUtils.isNotEmpty(mock)) &#123; // å¦‚æœmockä»¥ 'return' å¼€å¤´ï¼Œåˆ™å»æ‰è¯¥å‰ç¼€ if (mock.startsWith(Constants.RETURN_PREFIX)) &#123; // è·å–return æŒ‡å®šçš„å†…å®¹ String value = mock.substring(Constants.RETURN_PREFIX.length()); try &#123; // è§£æreturnæŒ‡å®šçš„å†…å®¹ï¼Œå¹¶è½¬æ¢æˆå¯¹åº”çš„è¿”å›ç±»å‹ MockInvoker.parseMockValue(value); &#125; catch (Exception e) &#123; throw new IllegalStateException(\"Illegal mock json value in &lt;dubbo:service ... mock=\\\"\" + mock + \"\\\" /&gt;\"); &#125; // ä¸æ˜¯ä»¥ 'return' å¼€å¤´ &#125; else &#123; // è·å¾—Mockç±» Class&lt;?&gt; mockClass = ConfigUtils.isDefault(mock) ? ReflectUtils.forName(interfaceClass.getName() + \"Mock\") : ReflectUtils.forName(mock); // æ ¡éªŒæ˜¯å¦å®ç°æ¥å£ if (!interfaceClass.isAssignableFrom(mockClass)) &#123; throw new IllegalStateException(\"The mock implementation class \" + mockClass.getName() + \" not implement interface \" + interfaceClass.getName()); &#125; // æ ¡éªŒæ˜¯å¦æœ‰é»˜è®¤çš„æ„é€ æ–¹æ³• try &#123; mockClass.getConstructor(new Class&lt;?&gt;[0]); &#125; catch (NoSuchMethodException e) &#123; throw new IllegalStateException(\"No such empty constructor \\\"public \" + mockClass.getSimpleName() + \"()\\\" in mock implementation class \" + mockClass.getName()); &#125; &#125; &#125; &#125;// çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; ServiceConfig é…ç½®ç±»è¯¥ç±»æ˜¯ æœåŠ¡æš´éœ² çš„æ ¸å¿ƒç±»ï¼Œæˆ‘ä»¬åœ¨ Dubboç¤ºä¾‹ - APIé…ç½® ä¸­å·²ç»ä½¿ç”¨APIçš„æ–¹å¼åˆ›å»ºä¸€ä¸ªDubboåº”ç”¨ï¼Œæœ€åé€šè¿‡è°ƒç”¨ ServiceConfig#export()æ–¹æ³•è¿›è¡ŒæœåŠ¡çš„å¯¼å‡ºï¼ŒServiceConfig ç»§æ‰¿å…³ç³»å¦‚ä¸‹ï¼š 12345AbstractConfig - AbstractMethodConfig - AbstractInterfaceConfig - AbstractServiceConfig - ServiceConfig AbstractServiceConfig æŠ½è±¡ç±»ä¸­ä¹Ÿæ²¡æœ‰æ ¸å¿ƒçš„é€»è¾‘ï¼Œä¸»è¦å°±æ˜¯é…ç½®å±æ€§çš„è®¾ç½®å’Œè·å–æ–¹æ³•ï¼Œå› æ­¤ä¹Ÿä¸å†åˆ†æã€‚ ServiceConfig#export()æ–¹æ³•ä¸»è¦åšä»¥ä¸‹å‡ ä»¶äº‹ï¼š è¿›ä¸€æ­¥åˆå§‹åŒ–Dubboçš„é…ç½®æ‰¿è½½å¯¹è±¡ï¼Œå› ä¸ºæœ‰çš„é…ç½®å¯¹è±¡æˆ‘ä»¬å¯èƒ½å¹¶æ²¡æœ‰æ˜¾ç¤ºåˆ›å»ºæˆ–é…ç½®ã€‚ å¯¹é…ç½®å¯¹è±¡ä»¬è¿›è¡Œæ ¡éªŒæ˜¯å¦ä¸ºç©ºï¼Œä¸ºç©ºåˆ™æ–°å»ºï¼Œæˆ–è€…æŠ›å‡ºå¼‚å¸¸ã€‚ ServiceConfigèšé›†äº†DubboæœåŠ¡çš„çš„æ‰€æœ‰é…ç½®å±æ€§ï¼Œä½¿ç”¨å®ƒçš„å±æ€§æ„å»ºDubbo URLå¯¹è±¡ è¿›è¡ŒæœåŠ¡æš´éœ² ServiceConfig å±æ€§1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ServiceConfig&lt;T&gt; extends AbstractServiceConfig &#123; /** * è‡ªé€‚åº” Protocolå®ç°å¯¹è±¡ */ private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension(); /** * è‡ªé€‚åº” ProxyFactory å®ç°å¯¹è±¡ */ private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension(); /** * éšæœºç«¯å£é›†åˆ */ private static final Map&lt;String, Integer&gt; RANDOM_PORT_MAP = new HashMap&lt;String, Integer&gt;(); /** * å»¶è¿Ÿæš´éœ²çº¿ç¨‹æ±  */ private static final ScheduledExecutorService delayExportExecutor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"DubboServiceDelayExporter\", true)); private final List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); /** * æœåŠ¡é…ç½®æš´éœ²çš„Exporter é›†åˆ */ private final List&lt;Exporter&lt;?&gt;&gt; exporters = new ArrayList&lt;Exporter&lt;?&gt;&gt;(); /** * æœåŠ¡æ¥å£å…¨è·¯å¾„å */ private String interfaceName; /** * éé…ç½®ï¼Œé€šè¿‡interfaceName é€šè¿‡åå°„è·å¾— */ private Class&lt;?&gt; interfaceClass; /** * æœåŠ¡æ¥å£çš„å®ç°å¯¹è±¡ */ private T ref; /** * æœåŠ¡å */ private String path; /** * æœåŠ¡æ–¹æ³•é…ç½®å¯¹è±¡é›†åˆ */ private List&lt;MethodConfig&gt; methods; /** * æœåŠ¡æä¾›è€…é»˜è®¤é…ç½®çš„é…ç½®å¯¹è±¡ */ private ProviderConfig provider; private transient volatile boolean exported; private transient volatile boolean unexported; /** * æ³›åŒ– */ private volatile String generic; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; è¿›ä¸€æ­¥åˆå§‹åŒ–é…ç½®æ‰¿è½½å¯¹è±¡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182public class ServiceConfig&lt;T&gt; extends AbstractServiceConfig &#123; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125; /** * æš´éœ²æœåŠ¡å…¥å£ï¼ŒåŠ jvmé” */ public synchronized void export() &#123; // å½“export æˆ–è€… delay æœªé…ç½®æ—¶ï¼Œä»ProviderConfigå¯¹è±¡è¯»å– if (provider != null) &#123; if (export == null) &#123; export = provider.getExport(); &#125; if (delay == null) &#123; delay = provider.getDelay(); &#125; &#125; // ä¸æš´éœ²æœåŠ¡(export = false),åˆ™ä¸è¿›è¡Œæš´éœ²æœåŠ¡é€»è¾‘ if (export != null &amp;&amp; !export) &#123; return; &#125; // å»¶è¿Ÿæš´éœ²çš„è¯ï¼Œå°±æ˜¯ä½¿ç”¨ä»»åŠ¡çº¿ç¨‹æ± ScheduledExecutorServiceå¤„ç† if (delay != null &amp;&amp; delay &gt; 0) &#123; delayExportExecutor.schedule(new Runnable() &#123; @Override public void run() &#123; doExport(); &#125; &#125;, delay, TimeUnit.MILLISECONDS); &#125; else &#123; doExport(); &#125; &#125; /** * æœåŠ¡æš´éœ²ï¼Œjvmé” */ protected synchronized void doExport() &#123; // æ£€æŸ¥æ˜¯å¦å¯ä»¥æš´éœ²ï¼Œè‹¥å¯ä»¥ï¼Œæ ‡è®°å·²ç»æš´éœ²ç„¶åæ‰§è¡ŒæœåŠ¡æš´éœ²é€»è¾‘ if (unexported) &#123; throw new IllegalStateException(\"Already unexported!\"); &#125; // å¦‚æœå·²ç»æš´éœ²äº†ç›´æ¥è¿”å› if (exported) &#123; return; &#125; // æ ‡è®°å·²ç»æš´éœ²è¿‡äº† exported = true; // æ ¡éªŒinterfaceName æ˜¯å¦åˆæ³•ï¼Œå³æ¥å£åéç©º if (interfaceName == null || interfaceName.length() == 0) &#123; throw new IllegalStateException(\"&lt;dubbo:service interface=\\\"\\\" /&gt; interface not allow null!\"); &#125; // æ ¡éªŒprovideræ˜¯å¦ä¸ºç©ºï¼Œä¸ºç©ºåˆ™æ–°å»ºä¸€ä¸ªï¼Œå¹¶æ‹¼æ¥å±æ€§é…ç½®ï¼ˆç¯å¢ƒå˜é‡ + .propertiesæ–‡ä»¶ä¸­çš„ å±æ€§ï¼‰åˆ°ProviderConfigå¯¹è±¡ checkDefault(); // æ£€æµ‹applicationï¼Œmoduleç­‰æ ¸å¿ƒé…ç½®ç±»å¯¹è±¡æ˜¯å¦ä¸ºç©ºï¼Œè‹¥ä¸ºç©ºåˆ™å°è¯•ä»å…¶ä»–é…ç½®ç±»å¯¹è±¡ä¸­è·å–å¯¹åº”çš„å®ä¾‹ã€‚å³ï¼š ä»ProviderConfig å¯¹è±¡ä¸­ï¼Œè¯»å–application,module,registries,monitor,protocolsé…ç½®å¯¹è±¡ if (provider != null) &#123; if (application == null) &#123; application = provider.getApplication(); &#125; if (module == null) &#123; module = provider.getModule(); &#125; if (registries == null) &#123; registries = provider.getRegistries(); &#125; if (monitor == null) &#123; monitor = provider.getMonitor(); &#125; if (protocols == null) &#123; protocols = provider.getProtocols(); &#125; &#125; // ä»ModuleConfig å¯¹è±¡ä¸­ï¼Œè¯»å–registries,monitoré…ç½®å¯¹è±¡ if (module != null) &#123; if (registries == null) &#123; registries = module.getRegistries(); &#125; if (monitor == null) &#123; monitor = module.getMonitor(); &#125; &#125; // ä»ApplicationConfig å¯¹è±¡ä¸­ï¼Œè¯»å–registries,monitoré…ç½®å¯¹è±¡ if (application != null) &#123; if (registries == null) &#123; registries = application.getRegistries(); &#125; if (monitor == null) &#123; monitor = application.getMonitor(); &#125; &#125; // æ£€æµ‹refæ˜¯å¦æ³›åŒ–æ¥å£çš„å®ç° if (ref instanceof GenericService) &#123; // è®¾ç½® interfaceClass ä¸º GenericService.class interfaceClass = GenericService.class; if (StringUtils.isEmpty(generic)) &#123; // è®¾ç½® generic = \"true\" generic = Boolean.TRUE.toString(); &#125; // æ™®é€šæ¥å£çš„å®ç° &#125; else &#123; try &#123; // é€šè¿‡åå°„è·å–å¯¹åº”çš„æ¥å£çš„Class interfaceClass = Class.forName(interfaceName, true, Thread.currentThread() .getContextClassLoader()); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; // æ£€éªŒæ¥å£å’Œæ–¹æ³• ï¼ˆæ¥å£éç©ºï¼Œæ–¹æ³•éƒ½åœ¨æ¥å£ä¸­å®šä¹‰ï¼‰ checkInterfaceAndMethods(interfaceClass, methods); // æ ¡éªŒå¼•ç”¨refæ˜¯å¦å®ç°äº†å½“å‰æ¥å£ checkRef(); // æ ‡è®°ä¸ºéæ³›åŒ–å®ç° generic = Boolean.FALSE.toString(); &#125; /** å¤„ç†æœåŠ¡æ¥å£å®¢æˆ·ç«¯æœ¬åœ°ä»£ç†,å³æœ¬åœ°å­˜æ ¹ï¼ˆlocal å±æ€§ -&gt; AbstractInterfaceConfig#setLocalï¼‰ã€‚ç›®å‰å·²ç»åºŸå¼ƒï¼Œæ­¤å¤„ä¸»è¦ç”¨äºå…¼å®¹ï¼Œä½¿ç”¨stubå±æ€§. todo æœåŠ¡ç«¯æ²¡æœ‰æ„ä¹‰ &#123;@link StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125; */ if (local != null) &#123; // å¦‚æœlocalå±æ€§è®¾ç½®ä¸ºtureï¼Œè¡¨ç¤ºä½¿ç”¨ç¼ºçœä»£ç†ç±»åï¼Œå³ï¼šæ¥å£å + Local åç¼€ if (\"true\".equals(local)) &#123; local = interfaceName + \"Local\"; &#125; Class&lt;?&gt; localClass; try &#123; // è·å–æœ¬åœ°å­˜æ ¹ç±» localClass = ClassHelper.forNameWithThreadContextClassLoader(local); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; // æ£€æµ‹æœ¬åœ°å­˜æ ¹ç±»æ˜¯å¦å¯èµ‹å€¼ç»™æ¥å£ç±»ï¼Œè‹¥ä¸å¯èµ‹å€¼åˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œæé†’ä½¿ç”¨è€…æœ¬åœ°å­˜æ ¹ç±»ç±»å‹ä¸åˆæ³• if (!interfaceClass.isAssignableFrom(localClass)) &#123; throw new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceName); &#125; &#125; /** å¤„ç†æœåŠ¡æ¥å£å®¢æˆ·ç«¯æœ¬åœ°ä»£ç†(stub å±æ€§)ç›¸å…³ï¼Œå³æœ¬åœ°å­˜æ ¹ã€‚ç›®çš„ï¼šæƒ³åœ¨å®¢æˆ·ç«¯ã€æœåŠ¡æ¶ˆè´¹æ–¹ã€‘æ‰§è¡Œéœ€è¦çš„é€»è¾‘ï¼Œä¸å±€é™æœåŠ¡æä¾›çš„é€»è¾‘ã€‚æœ¬åœ°å­˜æ ¹ç±»ç¼–å†™æ–¹å¼æ˜¯å›ºå®šã€‚todo æœåŠ¡ç«¯æ²¡æœ‰æ„ä¹‰ &#123;@link StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125;*/ if (stub != null) &#123; // å¦‚æœstubå±æ€§è®¾ç½®ä¸ºtureï¼Œè¡¨ç¤ºä½¿ç”¨ç¼ºçœä»£ç†ç±»åï¼Œå³ï¼šæ¥å£å + Stub åç¼€ if (\"true\".equals(stub)) &#123; stub = interfaceName + \"Stub\"; &#125; Class&lt;?&gt; stubClass; try &#123; // è·å–æœ¬åœ°å­˜æ ¹ç±» stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; // åˆ¤æ–­interfaceClass æ˜¯å¦æ˜¯ stubClass çš„æ¥å£ï¼Œå³ æ£€æµ‹æœ¬åœ°å­˜æ ¹ç±»æ˜¯å¦å¯èµ‹å€¼ç»™æ¥å£ç±»ï¼Œè‹¥ä¸å¯èµ‹å€¼åˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œæé†’ä½¿ç”¨è€…æœ¬åœ°å­˜æ ¹ç±»ç±»å‹ä¸åˆæ³• if (!interfaceClass.isAssignableFrom(stubClass)) &#123; throw new IllegalStateException(\"The stub implementation class \" + stubClass.getName() + \" not implement interface \" + interfaceName); &#125; &#125; /* æ£€æµ‹å„ç§å¯¹è±¡æ˜¯å¦ä¸ºç©ºï¼Œä¸ºç©ºåˆ™æ–°å»ºï¼Œæˆ–è€…æŠ›å‡ºå¼‚å¸¸*/ // æ ¡éªŒApplicationConfigé…ç½® checkApplication(); // æ ¡éªŒRegistryConfigé…ç½® checkRegistry(); // æ ¡éªŒProtocolConfigé…ç½®æ•°ç»„ checkProtocol(); // è¯»å–ç¯å¢ƒå˜é‡å’Œpropertiesé…ç½®åˆ°ServiceConfigå¯¹è±¡ï¼ˆè‡ªå·±ï¼‰ appendProperties(this); // æ ¡éªŒStubå’ŒMockç›¸å…³çš„é…ç½® checkStubAndMock(interfaceClass); // æœåŠ¡è·¯å¾„ï¼Œç¼ºçœæ˜¯æ¥å£å if (path == null || path.length() == 0) &#123; path = interfaceName; &#125; // æš´éœ²æœåŠ¡ doExportUrls(); ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref); ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel); &#125; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; å¤šåè®®å¤šæ³¨å†Œä¸­å¿ƒ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196public class ServiceConfig&lt;T&gt; extends AbstractServiceConfig &#123; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125; /** * Dubbo å…è®¸æˆ‘ä»¬ä½¿ç”¨ä¸åŒçš„åè®®å¯¼å‡ºæœåŠ¡ï¼Œä¹Ÿå…è®¸æˆ‘ä»¬å‘å¤šä¸ªæ³¨å†Œä¸­å¿ƒæ³¨å†ŒæœåŠ¡ã€‚Dubbo åœ¨ doExportUrls æ–¹æ³•ä¸­å¯¹å¤šåè®®ï¼Œå¤šæ³¨å†Œä¸­å¿ƒè¿›è¡Œäº†æ”¯æŒ */ @SuppressWarnings(&#123;\"unchecked\", \"rawtypes\"&#125;) private void doExportUrls() &#123; // åŠ è½½æ³¨å†Œä¸­å¿ƒURL æ•°ç»„ ã€åè®®å·²ç»å¤„ç†è¿‡ï¼Œä¸å†æ˜¯é…ç½®çš„æ³¨å†Œä¸­å¿ƒåè®® å¦‚ï¼šzookeeper ,è€Œæ˜¯ç»Ÿä¸€æ›¿æ¢æˆäº†registryã€‘ List&lt;URL&gt; registryURLs = loadRegistries(true); // éå†åè®®é›†åˆï¼Œæ”¯æŒå¤šåè®®æš´éœ²ã€‚ for (ProtocolConfig protocolConfig : protocols) &#123; doExportUrlsFor1Protocol(protocolConfig, registryURLs); &#125; &#125; /** * ä½¿ç”¨ä¸åŒçš„åè®®ï¼Œé€ä¸ªå‘æ³¨å†Œä¸­å¿ƒåˆ†ç»„æš´éœ²æœåŠ¡ã€‚è¯¥æ–¹æ³•ä¸­åŒ…å«äº†æœ¬åœ°å’Œè¿œç¨‹ä¸¤ç§æš´éœ²æ–¹å¼ * * @param protocolConfig åè®®é…ç½®å¯¹è±¡ * @param registryURLs å¤„ç†è¿‡çš„æ³¨å†Œä¸­å¿ƒåˆ†ç»„é›†åˆã€å·²ç»æ·»åŠ äº†ApplicationConfigå’ŒRegistryConfigçš„å‚æ•°ã€‘ */ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; // åè®®å String name = protocolConfig.getName(); // åè®®åä¸ºç©ºæ—¶ï¼Œç¼ºçœè®¾ç½®ä¸º dubbo if (name == null || name.length() == 0) &#123; name = \"dubbo\"; &#125; // åˆ›å»ºå‚æ•°é›†åˆmapï¼Œç”¨äºDubbo URL çš„æ„å»ºï¼ˆæœåŠ¡æä¾›è€…URLï¼‰ Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // å°†side,dubbo,timestamp,pidå‚æ•°ï¼Œæ·»åŠ åˆ°mapé›†åˆä¸­ map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE); map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; // é€šè¿‡åå°„å°†å„ç§é…ç½®å¯¹è±¡ä¸­çš„å±æ€§æ·»åŠ åˆ°mapé›†åˆä¸­ï¼Œmapç”¨äºURLçš„æ„å»ºã€æ³¨æ„å±æ€§è¦†ç›–é—®é¢˜ã€‘ appendParameters(map, application); appendParameters(map, module); appendParameters(map, provider, Constants.DEFAULT_KEY); appendParameters(map, protocolConfig); appendParameters(map, this); // å°†MethodConfig å¯¹è±¡æ•°ç»„æ·»åŠ åˆ° map é›†åˆä¸­ã€‚å°±æ˜¯å°†æ¯ä¸ªMethodConfigå’Œå…¶å¯¹åº”çš„ArgumentConfigå¯¹è±¡æ•°ç»„æ·»åŠ åˆ°mapä¸­ã€å¤„ç†æ–¹æ³•ç›¸å…³çš„å±æ€§åˆ°mapã€‘ if (methods != null &amp;&amp; !methods.isEmpty()) &#123; // methods ä¸º MethodConfig é›†åˆï¼ŒMethodConfig ä¸­å­˜å‚¨äº† &lt;dubbo:method&gt; æ ‡ç­¾çš„é…ç½®ä¿¡æ¯ for (MethodConfig method : methods) &#123; /** * å°†MethodConfigå¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°mapé›†åˆä¸­ï¼Œå…¶ä¸­å±æ€§é”® = æ–¹æ³•å.å±æ€§åã€‚å¦‚ï¼š * &lt;dubbo:method name=\"sleep\" retries=\"2\"&gt;&lt;/dubbo:method&gt;å¯¹åº”çš„MethodConfigï¼Œå±æ€§åˆ°mapçš„æ ¼å¼ map=&#123;\"sleep.retries\":2,...&#125; */ appendParameters(map, method, method.getName()); // å½“é…ç½®äº† MehodConfig.retry = false æ—¶ï¼Œå¼ºåˆ¶ç¦ç”¨é‡è¯• String retryKey = method.getName() + \".retry\"; if (map.containsKey(retryKey)) &#123; String retryValue = map.remove(retryKey); // æ£€æµ‹ MethodConfig retry æ˜¯å¦ä¸º falseï¼Œè‹¥æ˜¯ï¼Œåˆ™è®¾ç½®é‡è¯•æ¬¡æ•°ä¸º0 if (\"false\".equals(retryValue)) &#123; map.put(method.getName() + \".retries\", \"0\"); &#125; &#125; // å°†MethodConfigä¸‹çš„ArgumentConfig å¯¹è±¡æ•°ç»„ï¼Œæ·»åŠ åˆ° map é›†åˆä¸­ List&lt;ArgumentConfig&gt; arguments = method.getArguments(); if (arguments != null &amp;&amp; !arguments.isEmpty()) &#123; for (ArgumentConfig argument : arguments) &#123; // æ£€æµ‹type å±æ€§æ˜¯å¦ä¸ºç©ºï¼Œ if (argument.getType() != null &amp;&amp; argument.getType().length() &gt; 0) &#123; // é€šè¿‡åå°„å–å‡ºæ¥å£çš„æ–¹æ³•åˆ—è¡¨ Method[] methods = interfaceClass.getMethods(); // éå†æ¥å£ä¸­çš„æ–¹æ³•åˆ—è¡¨ if (methods != null &amp;&amp; methods.length &gt; 0) &#123; for (int i = 0; i &lt; methods.length; i++) &#123; String methodName = methods[i].getName(); // æ¯”å¯¹æ–¹æ³•åï¼ŒæŸ¥æ‰¾ç›®æ ‡æ–¹æ³• if (methodName.equals(method.getName())) &#123; // é€šè¿‡åå°„å–å‡ºç›®æ ‡æ–¹æ³•çš„å‚æ•°ç±»å‹åˆ—è¡¨ Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes(); // è‹¥æœé…ç½®indexé…ç½®é¡¹ï¼Œä¸”å€¼ä¸ä¸º-1 if (argument.getIndex() != -1) &#123; // ä»argtypesæ•°ç»„ä¸­è·å–ä¸‹æ ‡indexå¤„çš„å…ƒç´ argTypeï¼Œå¹¶æ£€æµ‹ArgumentConfigä¸­çš„typeå±æ€§ä¸argTypeåç§°æ˜¯å¦ä¸€è‡´ï¼Œä¸ä¸€è‡´åˆ™æŠ›å‡ºå¼‚å¸¸ if (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123; // å°†ArgumentConfigå¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°mapé›†åˆä¸­ï¼Œé”®å‰ç¼€=æ–¹æ³•å.indexï¼Œå¦‚ï¼šmap = &#123;\"sleep.2\":true&#125; appendParameters(map, argument, method.getName() + \".\" + argument.getIndex()); &#125; else &#123; throw new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType()); &#125; &#125; else &#123; // éå†å‚æ•°ç±»å‹æ•°ç»„argtypesï¼ŒæŸ¥æ‰¾argument.typeç±»å‹çš„å‚æ•° for (int j = 0; j &lt; argtypes.length; j++) &#123; Class&lt;?&gt; argclazz = argtypes[j]; // ä»å‚æ•°ç±»å‹åˆ—è¡¨ä¸­æŸ¥æ‰¾ç±»å‹åç§°ä¸ºargument.typeçš„å‚æ•° if (argclazz.getName().equals(argument.getType())) &#123; // å°†ArgumentConfigå¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°mapé›†åˆä¸­ appendParameters(map, argument, method.getName() + \".\" + j); if (argument.getIndex() != -1 &amp;&amp; argument.getIndex() != j) &#123; throw new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType()); &#125; &#125; &#125; &#125; &#125; &#125; &#125; // ç”¨æˆ·æœªé…ç½® type å±æ€§ï¼Œä½†é…ç½®äº†indexå±æ€§ï¼Œä¸”index != -1 &#125; else if (argument.getIndex() != -1) &#123; // æŒ‡å®šå•ä¸ªå‚æ•°çš„ä½ç½® // å°†ArgumentConfigå¯¹è±¡çš„å±æ€§æ·»åŠ åˆ°mapé›†åˆä¸­ appendParameters(map, argument, method.getName() + \".\" + argument.getIndex()); &#125; else &#123; throw new IllegalArgumentException(\"argument config must set index or type attribute.eg: &lt;dubbo:argument index='0' .../&gt; or &lt;dubbo:argument type=xxx .../&gt;\"); &#125; &#125; &#125; &#125; // end of methods for &#125; //------------------- æ£€æµ‹ generic æ˜¯å¦ ä¸º true ,å¹¶æ ¹æ®æ£€æµ‹ç»“æœå‘mapä¸­æ·»åŠ ä¸åŒçš„ä¿¡æ¯ ---/ // å°† generic,methods,revision åŠ å…¥åˆ°æ•°ç»„ if (ProtocolUtils.isGeneric(generic)) &#123; map.put(Constants.GENERIC_KEY, generic); map.put(Constants.METHODS_KEY, Constants.ANY_VALUE); &#125; else &#123; // å…ˆä»MAINFEST.MF ä¸­è·å–ç‰ˆæœ¬å·ï¼Œè‹¥è·å–ä¸åˆ°ï¼Œå†ä»jaråŒ…å‘½åä¸­å¯èƒ½å¸¦çš„ç‰ˆæœ¬å·ä½œä¸ºç»“æœï¼Œå¦‚ 2.6.5.RELEASEã€‚è‹¥éƒ½ä¸å­˜åœ¨ï¼Œè¿”å›é»˜è®¤ç‰ˆæœ¬å·ã€æºç è¿è¡Œå¯èƒ½ä¼šæ²¡æœ‰ã€‘ String revision = Version.getVersion(interfaceClass, version); if (revision != null &amp;&amp; revision.length() &gt; 0) &#123; map.put(\"revision\", revision); // ä¿®è®¢å· &#125; // ä¸ºæ¥å£ç”ŸæˆåŒ…è£¹ç±» Wrapperï¼ŒWrapper ä¸­åŒ…å«äº†æ¥å£çš„è¯¦ç»†ä¿¡æ¯ï¼Œæ¯”å¦‚æ¥å£æ–¹æ³•åæ•°ç»„ï¼Œå­—æ®µä¿¡æ¯ç­‰ã€Dubbo è‡ªå®šä¹‰åŠŸèƒ½ç±»ã€‘ String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames(); // æ·»åŠ æ–¹æ³•ååˆ° map ä¸­ï¼Œå¦‚æœåŒ…å«å¤šä¸ªæ–¹æ³•åï¼Œåˆ™ç”¨é€—å·éš”å¼€ï¼Œæ¯”å¦‚ï¼šmethod=a,b if (methods.length == 0) &#123; logger.warn(\"NO method found in service interface \" + interfaceClass.getName()); // æ²¡æœ‰æ–¹æ³•åå°±æ·»åŠ  method=* map.put(Constants.METHODS_KEY, Constants.ANY_VALUE); &#125; else &#123; // å°†é€—å·ä½œä¸ºåˆ†éš”ç¬¦è¿æ¥æ–¹æ³•åï¼Œå¹¶å°†è¿æ¥åçš„å­—ç¬¦ä¸²æ”¾å…¥ map ä¸­ map.put(Constants.METHODS_KEY, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), \",\")); &#125; &#125; // token ã€ä½¿æš´éœ²å‡ºå»çš„æœåŠ¡æ›´å®‰å…¨ï¼Œä½¿ç”¨tokenåšå®‰å…¨æ ¡éªŒã€‘ if (!ConfigUtils.isEmpty(token)) &#123; if (ConfigUtils.isDefault(token)) &#123; map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString()); &#125; else &#123; map.put(Constants.TOKEN_KEY, token); &#125; &#125; // åè®®ä¸ºinjvmæ—¶ï¼Œä¸æ³¨å†Œï¼Œä¸é€šçŸ¥ if (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123; protocolConfig.setRegister(false); map.put(\"notify\", \"false\"); &#125; // è·å¾—åŸºç¡€è·¯å¾„ String contextPath = protocolConfig.getContextpath(); if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) &#123; contextPath = provider.getContextpath(); &#125; // --------------------------- ä¸»æœºç»‘å®š----------------------------/ // è·å¾—æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒçš„æœåŠ¡æä¾›è€…hostï¼Œå¹¶ä¸ºmapè®¾ç½®bind.ip , anyhost ä¸¤ä¸ªkey String host = this.findConfigedHosts(protocolConfig, registryURLs, map); // è·å–ç«¯å£ï¼Œå¹¶ä¸ºmapè®¾ç½®bing.port key Integer port = this.findConfigedPorts(protocolConfig, name, map); /** * åˆ›å»ºDubbo URLå¯¹è±¡ ã€æ³¨æ„è¿™é‡Œçš„ path çš„å€¼ã€‘ * 1 name: åè®®å * 2 host: ä¸»æœºå * 3 port: ç«¯å£ * 4 path: ã€åŸºç¡€è·¯å¾„ã€‘/path * 5 parameters: å±æ€§é›†åˆmap */ URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? \"\" : contextPath + \"/\") + path, map); // çœç•¥æœåŠ¡æš´éœ²ä»£ç  &#125; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; ReferenceConfig é…ç½®ç±»è¯¥ç±»æ˜¯ æœåŠ¡å¼•ç”¨ çš„æ ¸å¿ƒç±»ï¼Œæˆ‘ä»¬åœ¨ Dubboç¤ºä¾‹ - APIé…ç½® ä¸­å·²ç»ä½¿ç”¨APIçš„æ–¹å¼åˆ›å»ºä¸€ä¸ªDubboåº”ç”¨ï¼Œæœ€åé€šè¿‡è°ƒç”¨ ReferenceConfig#get()æ–¹æ³•å¼•ç”¨æœåŠ¡ï¼ŒReferenceConfig ç»§æ‰¿å…³ç³»å¦‚ä¸‹ï¼š 12345AbstractConfig - AbstractMethodConfig - AbstractInterfaceConfig - AbstractReferenceConfig - ReferenceConfig AbstractReferenceConfig æŠ½è±¡ç±»ä¸­ä¹Ÿæ²¡æœ‰æ ¸å¿ƒçš„é€»è¾‘ï¼Œä¸»è¦å°±æ˜¯é…ç½®å±æ€§çš„è®¾ç½®å’Œè·å–æ–¹æ³•ï¼Œå› æ­¤ä¹Ÿä¸å†åˆ†æã€‚ ReferenceConfig#get()æ–¹æ³•ä¸»è¦åšä»¥ä¸‹å‡ ä»¶äº‹ï¼š è¿›ä¸€æ­¥åˆå§‹åŒ–Dubboçš„é…ç½®æ‰¿è½½å¯¹è±¡ï¼Œå› ä¸ºæœ‰çš„é…ç½®å¯¹è±¡æˆ‘ä»¬å¯èƒ½å¹¶æ²¡æœ‰æ˜¾ç¤ºåˆ›å»ºæˆ–é…ç½®ã€‚ å¯¹é…ç½®å¯¹è±¡ä»¬è¿›è¡Œæ ¡éªŒæ˜¯å¦ä¸ºç©ºï¼Œä¸ºç©ºåˆ™æ–°å»ºï¼Œæˆ–è€…æŠ›å‡ºå¼‚å¸¸ã€‚ ReferenceConfigèšé›†äº†DubboæœåŠ¡æ¶ˆè´¹è€…çš„çš„æ‰€æœ‰é…ç½®å±æ€§ï¼Œä½¿ç”¨å®ƒçš„å±æ€§æ„å»ºDubbo URLå¯¹è±¡ è¿›è¡ŒæœåŠ¡å¼•ç”¨ ReferenceConfig å±æ€§1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ReferenceConfig&lt;T&gt; extends AbstractReferenceConfig &#123; /** * è‡ªé€‚åº” Protocol æ‹“å±•å®ç° */ private static final Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension(); /** * è‡ªé€‚åº” Cluster æ‹“å±•å®ç° */ private static final Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension(); /** * è‡ªé€‚åº” ProxyFactory æ‹“å±•å®ç° */ private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension(); /** * æœåŠ¡å¼•ç”¨URLæ•°ç»„ */ private final List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); /** * æœåŠ¡æ¥å£å */ private String interfaceName; /** * æœåŠ¡æ¥å£ */ private Class&lt;?&gt; interfaceClass; /** * è¿æ¥ç±»å‹ */ private String client; /** * ç›´è¿æœåŠ¡æä¾›è€…åœ°å€ * 1 å¯ä»¥æ˜¯æ³¨å†Œä¸­å¿ƒï¼Œä¹Ÿå¯ä»¥æ˜¯æœåŠ¡æä¾›è€… * 2 å¯ä»¥é…ç½®å¤šä¸ªï¼Œä½¿ç”¨ \";\" åˆ†å‰² */ private String url; /** * æ–¹æ³•é…ç½®å¯¹è±¡é›†åˆ */ private List&lt;MethodConfig&gt; methods; /** * æ¶ˆè´¹è€…é»˜è®¤é…ç½®çš„é…ç½®å¯¹è±¡ */ private ConsumerConfig consumer; /** * åè®® */ private String protocol; /** * æœåŠ¡æ¥å£ä»£ç†å¯¹è±¡ */ private transient volatile T ref; /** * Invoker */ private transient volatile Invoker&lt;?&gt; invoker; private transient volatile boolean initialized; private transient volatile boolean destroyed; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; è¿›ä¸€æ­¥åˆå§‹åŒ–é…ç½®æ‰¿è½½å¯¹è±¡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230public class ReferenceConfig&lt;T&gt; extends AbstractReferenceConfig &#123; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125; public synchronized T get() &#123; // å·²é”€æ¯ï¼Œä¸å¯è·å¾— if (destroyed) &#123; throw new IllegalStateException(\"Already destroyed!\"); &#125; // è‹¥æœªåˆå§‹åŒ–ï¼Œè°ƒç”¨init()æ–¹æ³•è¿›è¡Œåˆå§‹åŒ– if (ref == null) &#123; init(); &#125; // è¿”å›å¼•ç”¨æœåŠ¡ return ref; &#125; private void init() &#123; // å·²ç»åˆå§‹åŒ–è¿‡ï¼Œç›´æ¥è¿”å› if (initialized) &#123; return; &#125; initialized = true; // æ ¡éªŒæ¥å£åéç©º if (interfaceName == null || interfaceName.length() == 0) &#123; throw new IllegalStateException(\"&lt;dubbo:reference interface=\\\"\\\" /&gt; interface not allow null!\"); &#125; // æ‹¼æ¥å±æ€§é…ç½®ï¼ˆç¯å¢ƒå˜é‡ + .properties ä¸­çš„å±æ€§ï¼‰åˆ° ConsumerConfigå¯¹è±¡ checkDefault(); // æ‹¼æ¥å±æ€§é…ç½®ï¼ˆç¯å¢ƒå˜é‡ + .properties ä¸­çš„å±æ€§ï¼‰åˆ°ReferenceConfigï¼ˆè‡ªå·±ï¼‰ appendProperties(this); // è‹¥æœªè®¾ç½® generic å±æ€§ï¼Œå°±ä½¿ç”¨ConsumerConfigçš„genericå±æ€§ if (getGeneric() == null &amp;&amp; getConsumer() != null) &#123; setGeneric(getConsumer().getGeneric()); &#125; // æ˜¯å¦æ˜¯æ³›åŒ–æ¥å£çš„å®ç°ï¼Œå¦‚æœæ˜¯æ³›åŒ–æ¥å£å®ç°çš„è¯ï¼Œå°±ç›´æ¥è®¾ç½®å½“å‰æ¥å£ä¸º GenericService.class if (ProtocolUtils.isGeneric(getGeneric())) &#123; interfaceClass = GenericService.class; // æ™®é€šæ¥å£çš„å®ç° &#125; else &#123; try &#123; // æ ¹æ®æ¥å£åï¼Œè·å¾—å¯¹åº”çš„æ¥å£ç±» interfaceClass = Class.forName(interfaceName, true, Thread.currentThread().getContextClassLoader()); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; // æ ¡éªŒæ¥å£å’Œæ–¹æ³• checkInterfaceAndMethods(interfaceClass, methods); &#125; // ç›´è¿æä¾›è€…ï¼Œç¬¬ä¸€ä¼˜å…ˆçº§ï¼Œé€šè¿‡ -D å‚æ•°ï¼ˆç³»ç»Ÿå˜é‡ï¼‰æŒ‡å®š ï¼Œä¾‹å¦‚ java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890 String resolve = System.getProperty(interfaceName); String resolveFile = null; // ç›´è¿æä¾›è€…ç¬¬äºŒä¼˜å…ˆçº§ï¼Œé€šè¿‡æ–‡ä»¶æ˜ å°„ï¼Œä¾‹å¦‚ com.alibaba.xxx.XxxService=dubbo://localhost:20890 if (resolve == null || resolve.length() == 0) &#123; // ä»ç³»ç»Ÿå±æ€§ä¸­è·å–è§£ææ–‡ä»¶è·¯å¾„ resolveFile = System.getProperty(\"dubbo.resolve.file\"); if (resolveFile == null || resolveFile.length() == 0) &#123; // é»˜è®¤å…ˆåŠ è½½ $&#123;user.home&#125;/dubbo-resolve.properties æ–‡ä»¶ï¼Œæ— éœ€é…ç½®ï¼Œè‡ªåŠ¨åŠ è½½ File userResolveFile = new File(new File(System.getProperty(\"user.home\")), \"dubbo-resolve.properties\"); if (userResolveFile.exists()) &#123; // è·å–æ–‡ä»¶ç»å¯¹è·¯å¾„ resolveFile = userResolveFile.getAbsolutePath(); &#125; &#125; // å­˜åœ¨resolveFile,åˆ™è¿›è¡Œæ–‡ä»¶è¯»å–åŠ è½½ if (resolveFile != null &amp;&amp; resolveFile.length() &gt; 0) &#123; Properties properties = new Properties(); FileInputStream fis = null; try &#123; fis = new FileInputStream(new File(resolveFile)); // ä»æ–‡ä»¶ä¸­åŠ è½½é…ç½® properties.load(fis); &#125; catch (IOException e) &#123; throw new IllegalStateException(\"Unload \" + resolveFile + \", cause: \" + e.getMessage(), e); &#125; finally &#123; try &#123; if (null != fis) &#123; fis.close(); &#125; &#125; catch (IOException e) &#123; logger.warn(e.getMessage(), e); &#125; &#125; // æ ¹æ®æœåŠ¡å…¨è·¯å¾„åè·å–å¯¹åº”çš„ ç›´è¿æä¾›è€…çš„url resolve = properties.getProperty(interfaceName); &#125; &#125; // è®¾ç½®ç›´è¿æä¾›è€…çš„ url if (resolve != null &amp;&amp; resolve.length() &gt; 0) &#123; url = resolve; if (logger.isWarnEnabled()) &#123; if (resolveFile != null) &#123; logger.warn(\"Using default dubbo resolve file \" + resolveFile + \" replace \" + interfaceName + \"\" + resolve + \" to p2p invoke remote service.\"); &#125; else &#123; logger.warn(\"Using -D\" + interfaceName + \"=\" + resolve + \" to p2p invoke remote service.\"); &#125; &#125; &#125; // ä¸é€šè¿‡ç³»ç»Ÿå±æ€§æŒ‡å®šï¼Œå°±ä½¿ç”¨é…ç½®çš„ç›´è¿ï¼ˆåœ¨é…ç½®çš„å‰æä¸‹ï¼‰ï¼Œå¦‚ï¼š&lt;dubbo:reference id=\"xxxService\" interface=\"com.alibaba.xxx.XxxService\" url=\"dubbo://localhost:20890\" /&gt; // å°è¯•ä»ConsumerConfig å¯¹è±¡ä¸­ï¼Œè¯»å– application,module,registries,monitor é…ç½®å¯¹è±¡ if (consumer != null) &#123; if (application == null) &#123; application = consumer.getApplication(); &#125; if (module == null) &#123; module = consumer.getModule(); &#125; if (registries == null) &#123; registries = consumer.getRegistries(); &#125; if (monitor == null) &#123; monitor = consumer.getMonitor(); &#125; &#125; // ä»ModuleConfig å¯¹è±¡ä¸­ï¼Œè¯»å–registries,monitoré…ç½®å¯¹è±¡ if (module != null) &#123; if (registries == null) &#123; registries = module.getRegistries(); &#125; if (monitor == null) &#123; monitor = module.getMonitor(); &#125; &#125; // ä»ApplicationConfigå¯¹è±¡ä¸­ï¼Œè¯»å–registries,monitoré…ç½®å¯¹è±¡ if (application != null) &#123; if (registries == null) &#123; registries = application.getRegistries(); &#125; if (monitor == null) &#123; monitor = application.getMonitor(); &#125; &#125; // æ ¡éªŒApplicationConfigé…ç½® checkApplication(); // æ ¡éªŒ Stubå’Œ Mock ç›¸å…³çš„é…ç½® checkStubAndMock(interfaceClass); // åˆ›å»ºå‚æ•°é›†åˆmapï¼Œç”¨äºä¸‹é¢åˆ›å»ºDubbo URL Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // ç¬¦åˆæ¡ä»¶çš„æ–¹æ³•å¯¹è±¡çš„å±æ€§ï¼Œä¸»è¦ç”¨æ¥Dubboäº‹ä»¶é€šçŸ¥ Map&lt;Object, Object&gt; attributes = new HashMap&lt;Object, Object&gt;(); // å°† sideï¼Œdubbo,timestamp,pidå‚æ•°ï¼Œæ·»åŠ åˆ°mapé›†åˆä¸­ map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE); map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; // éæ³›åŒ–æœåŠ¡ï¼Œè®¾ç½®revision,methods,interfaceåŠ å…¥åˆ°mapé›†åˆä¸­ if (!isGeneric()) &#123; String revision = Version.getVersion(interfaceClass, version); if (revision != null &amp;&amp; revision.length() &gt; 0) &#123; map.put(\"revision\", revision); &#125; // è·å–æ¥å£æ–¹æ³•åˆ—è¡¨ï¼Œå¹¶æ·»åŠ åˆ°mapä¸­ String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames(); if (methods.length == 0) &#123; logger.warn(\"NO method found in service interface \" + interfaceClass.getName()); map.put(\"methods\", Constants.ANY_VALUE); &#125; else &#123; map.put(\"methods\", StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), \",\")); &#125; &#125; map.put(Constants.INTERFACE_KEY, interfaceName); // å°†å„ç§é…ç½®å¯¹è±¡ä¸­çš„å±æ€§ï¼Œæ·»åŠ åˆ° map é›†åˆä¸­ appendParameters(map, application); appendParameters(map, module); appendParameters(map, consumer, Constants.DEFAULT_KEY); appendParameters(map, this); // è·å¾—æœåŠ¡é”®ï¼Œä½œä¸ºå‰ç¼€ æ ¼å¼ï¼šgroup/interface:version String prefix = StringUtils.getServiceKey(map); // å°†MethodConfig å¯¹è±¡æ•°ç»„ä¸­æ¯ä¸ªMethodConfigä¸­çš„å±æ€§æ·»åŠ åˆ°mapä¸­ if (methods != null &amp;&amp; !methods.isEmpty()) &#123; // éå† MethodConfig åˆ—è¡¨ for (MethodConfig method : methods) &#123; appendParameters(map, method, method.getName()); // å½“é…ç½®äº† MethodConfig.retry=false æ—¶ï¼Œå¼ºåˆ¶ç¦ç”¨é‡è¯• String retryKey = method.getName() + \".retry\"; if (map.containsKey(retryKey)) &#123; String retryValue = map.remove(retryKey); if (\"false\".equals(retryValue)) &#123; // æ·»åŠ é‡è¯•æ¬¡æ•°é…ç½® methodName.retries map.put(method.getName() + \".retries\", \"0\"); &#125; &#125; // å°†å¸¦æœ‰@Parameter(attribute=true)é…ç½®å¯¹è±¡çš„å±æ€§ï¼Œæ·»åŠ åˆ°å‚æ•°é›†åˆä¸­ appendAttributes(attributes, method, prefix + \".\" + method.getName()); // æ£€æŸ¥å±æ€§é›†åˆä¸­çš„äº‹ä»¶é€šçŸ¥æ–¹æ³•æ˜¯å¦æ­£ç¡®ï¼Œè‹¥æ­£ç¡®ï¼Œè¿›è¡Œè½¬æ¢ checkAndConvertImplicitConfig(method, map, attributes); &#125; &#125; // ä»¥ç³»ç»Ÿç¯å¢ƒå˜é‡ï¼ˆDUBBO_IP_TO_REGISTRYï¼‰çš„å€¼ä½œä¸ºæœåŠ¡æ¶ˆè´¹è€…ipåœ°å€,æ²¡æœ‰è®¾ç½®å†å–ä¸»æœºåœ°å€ String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY); if (hostToRegistry == null || hostToRegistry.length() == 0) &#123; hostToRegistry = NetUtils.getLocalHost(); &#125; else if (isInvalidLocalHost(hostToRegistry)) &#123; throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + Constants.DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry); &#125; map.put(Constants.REGISTER_IP_KEY, hostToRegistry); // æŠŠattributesé›†åˆæ·»åŠ åˆ°StaticContextè¿›è¡Œç¼“å­˜ï¼Œä¸ºäº†ä»¥åçš„äº‹ä»¶é€šçŸ¥ StaticContext.getSystemContext().putAll(attributes); try&#123; System.out.println(\" ref = createProxy(map); is begin.....\"); Thread.sleep(5000); &#125;catch (Exception ex)&#123; &#125; // çœç•¥æœåŠ¡å¼•ç”¨ä»£ç  &#125; // çœç•¥å…¶å®ƒä»£ç  $&#123;&#125;&#125; å…¶å®ƒé…ç½®ç±»å‰é¢åªæ˜¯é’ˆå¯¹Dubboçš„æ ¸å¿ƒé…ç½®ç±»è¿›è¡Œäº†åˆ†æï¼Œè¿˜å¾ˆå¤šå…¶å®ƒçš„é…ç½®ç±»å¹¶æ²¡æœ‰åˆ†æåˆ°(ServiceBeanå’ŒReferenceBeanå±äºæ•´åˆSpringçš„é…ç½®ç±»ï¼Œæˆ‘ä»¬åœ¨XMLé…ç½®ä¸­åˆ†æ)ï¼Œä¸è¿‡æ²¡æœ‰åˆ†æåˆ°çš„é…ç½®ç±»ä¸­å‡ ä¹éƒ½æ²¡æœ‰å¤æ‚çš„é€»è¾‘ï¼Œå¤§å¤šæ˜¯å°è£…äº†é…ç½®å±æ€§çš„è®¾ç½®å’Œè·å–æ“ä½œã€‚æ¯ä¸ªé…ç½®ç±»ä¸­å°è£…çš„é…ç½®å±æ€§éƒ½æœ‰æ‰€ä¸åŒï¼Œé‚£äº›æŠ½è±¡çš„é…ç½®ç±»å°è£…çš„éƒ½æ˜¯å¯ä¾›ä¸åŒå­ç±»å¤ç”¨çš„å±æ€§å’Œæ–¹æ³•ï¼Œæ¯ä¸ªé…ç½®ç±»å¯ä»¥è®¾ç½®é‚£äº›å±æ€§æˆ‘ä»¬å¯ä»¥å‚è€ƒå®˜æ–¹æ–‡æ¡£ï¼Œéœ€è¦è¯´æ˜çš„æ˜¯ï¼Œå®˜ç½‘ç»™å‡ºçš„æ˜¯XMLé…ç½®å½¢å¼ï¼Œä¸è¿‡æŒ‰ç…§å¯¹åº”çš„è§„åˆ™è½¬æ¢å°±å¯ä»¥ç›¸é€šäº†ã€‚ æ€»ç»“Dubboçš„é…ç½®ç›¸å¯¹æ¯”è¾ƒæ¯ç‡¥ï¼Œåˆšå¼€å§‹çœ‹çš„æ—¶å€™å¯èƒ½æœ‰ç‚¹è’™åœˆï¼Œç¬”è€…ä¹Ÿæ˜¯ç¡¬ç€å¤´çš®çœ‹äº†å¥½ä¹…ï¼Œçœ‹å®Œåä¹Ÿä¸æ˜¯å¾ˆç†è§£ï¼Œä½†æ˜¯æŠŠæ•´ä¸ªæµç¨‹çœ‹å®Œåå†å›æ¥çœ‹ä½“ä¼šå°±æ›´æ·±äº†ã€‚XMLé…ç½®å’Œæ³¨è§£é…ç½®ä¹Ÿæ˜¯åŸºäºAPIé…ç½®å’Œå±æ€§é…ç½®çš„ï¼ŒåŒºåˆ«æ˜¯XMLé…ç½®å’Œæ³¨è§£é…ç½®è¦è§£å†³å’ŒSpringèåˆé—®é¢˜ï¼Œæˆ‘ä»¬åœ¨æ¥ä¸‹æ¥çš„æ–‡ç« ä¸­å†è¯¦ç»†åˆ†æã€‚å˜¿å’»ï¼Œæ•´ç¯‡æ–‡ç« éƒ½åœ¨è´´ä»£ç ï¼","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"Dubboæºç åˆ†æ - åŠ¨æ€ç¼–è¯‘","slug":"rpc/DubboåŠ¨æ€ç¼–è¯‘","date":"2020-03-21T16:00:00.000Z","updated":"2021-02-18T09:59:43.253Z","comments":false,"path":"posts/68ac5094/","link":"","permalink":"https://gentryhuang.com/posts/68ac5094/","excerpt":"","text":"æ¦‚è¿°åœ¨Dubboè‡ªé€‚åº”æ‰©å±•ä¸­ï¼Œæˆ‘ä»¬å·²ç»å¾—åˆ°äº†è‡ªé€‚åº”æ‰©å±•ç±»çš„å­—ç¬¦ä¸²ï¼Œéœ€è¦é€šè¿‡ç¼–è¯‘æ‰èƒ½å¾—åˆ°çœŸæ­£çš„Classï¼Œæœ¬ç¯‡æ–‡ç« å°±æ¥ä»‹ç»å°†ç±»çš„å­—ç¬¦ä¸²ç¼–è¯‘æˆç±»çš„è¿‡ç¨‹ã€‚ åŠ¨æ€ç¼–è¯‘ dubbo çš„åŠ¨æ€ç¼–è¯‘çš„æ•´ä½“ç»“æ„å¦‚ä¸Šå›¾æ‰€ç¤ºã€‚dubboä¸­çš„CompileråŸºäºdubbo spiæœºåˆ¶è¿›è¡ŒåŠ è½½ï¼Œç›®å‰æ”¯æŒjdkå’Œjavassistä¸¤ç§å®ç°ï¼š 12&lt;dubbo:application compiler=\"jdk\" /&gt;&lt;dubbo:application compiler=\"javassist\" /&gt; æ•´ä½“äº†è§£äº†dubboçš„åŠ¨æ€ç¼–è¯‘åï¼Œæˆ‘ä»¬æ¥ç€ä¸Šä¸€ç¯‡æ–‡ç« ç»§ç»­åˆ†æï¼ŒdubboåŠ¨æ€ç¼–è¯‘å…¥å£çš„ä»£ç å¦‚ä¸‹ï¼š 12345678910private Class&lt;?&gt; createAdaptiveExtensionClass() &#123; // ç”Ÿæˆè‡ªé€‚åº”æ‹“å±•å®ç°çš„ä»£ç å­—ç¬¦ä¸² String code = createAdaptiveExtensionClassCode(); // è·å–ç±»åŠ è½½å™¨ ClassLoader classLoader = findClassLoader(); // è·å–Compilerè‡ªé€‚åº”æ‰©å±•å¯¹è±¡ com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension(); // åŠ¨æ€ç¼–è¯‘ï¼Œç”ŸæˆClass return compiler.compile(code, classLoader);&#125; è¯¥æ–¹æ³•åœ¨ç¼–è¯‘é˜¶æ®µéœ€è¦å…ˆè·å–è‡ªé€‚åº”ç¼–è¯‘å¯¹è±¡ï¼Œç„¶åè°ƒç”¨è¯¥å¯¹è±¡çš„compileæ–¹æ³•è¿›è¡Œä»£ç çš„ç¼–è¯‘ã€‚å…¶å®è¿™é‡Œå¹¶ä¸æ˜¯ç›´æ¥ä½¿ç”¨è‡ªé€‚åº”å¯¹è±¡è¿›è¡Œä»£ç ç¼–è¯‘ï¼Œè€Œæ˜¯å°†å…·ä½“çš„ç¼–è¯‘ä»»åŠ¡äº¤ç»™å­ç±»æ¥å®Œæˆï¼Œå³JdkCompilerå­ç±»å’ŒJavassistCompilerå­ç±»ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹dubbo åŠ¨æ€ç¼–è¯‘çš„æˆå‘˜åŠå®ƒä»¬çš„ç”¨é€”ã€‚ Compiler æ‰©å±•æ¥å£12345678910111213141516/** * Compiler. (SPI, Singleton, ThreadSafe) * ä½¿ç”¨Dubbo SPIæœºåˆ¶ï¼Œé»˜è®¤æ‹“å±•åä¸ºjavassist */@SPI(\"javassist\")public interface Compiler &#123; /** * ç¼–è¯‘Java ä»£ç  * * @param code Javaä»£ç å­—ç¬¦ä¸² * @param classLoader ç±»åŠ è½½å™¨ * @return Compiled class ç¼–è¯‘åçš„ç±» */ Class&lt;?&gt; compile(String code, ClassLoader classLoader);&#125; AdaptiveCompiler å›ºå®šè‡ªé€‚åº”æ‰©å±•ç±»12345678910111213141516171819202122232425262728293031323334353637383940/** * AdaptiveCompiler. (SPI, Singleton, ThreadSafe) * å®ç°Compileræ¥å£ï¼Œå¸¦æœ‰@Adaptiveæ³¨è§£ï¼Œæ˜¯å›ºå®šçš„è‡ªé€‚åº”å®ç°ç±» */@Adaptivepublic class AdaptiveCompiler implements Compiler &#123; /** * é»˜è®¤ç¼–è¾‘å™¨çš„æ‹“å±•å */ private static volatile String DEFAULT_COMPILER; /** * é™æ€æ–¹æ³•ï¼Œè®¾ç½®é»˜è®¤ç¼–è¾‘å™¨çš„æ‹“å±•åã€‚è¯¥æ–¹æ³•è¢« &#123;@link com.alibaba.dubbo.config.ApplicationConfig#setCompiler(java.lang.String)&#125;æ–¹æ³•è°ƒç”¨. * åœ¨&lt;dubbo:application compiler=\"\"/&gt; é…ç½® å¯è§¦å‘è¯¥æ–¹æ³• * * @param compiler */ public static void setDefaultCompiler(String compiler) &#123; DEFAULT_COMPILER = compiler; &#125; @Override public Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123; Compiler compiler; // è·å¾—Compilerçš„ExtensionLoaderå¯¹è±¡ ExtensionLoader&lt;Compiler&gt; loader = ExtensionLoader.getExtensionLoader(Compiler.class); // å£°æ˜ name å˜é‡ String name = DEFAULT_COMPILER; // ä½¿ç”¨è®¾ç½®çš„æ‹“å±•åï¼Œè·å¾—Compileræ‹“å±•å¯¹è±¡ if (name != null &amp;&amp; name.length() &gt; 0) &#123; compiler = loader.getExtension(name); // è·å¾—é»˜è®¤çš„Compileræ‹“å±•å¯¹è±¡ &#125; else &#123; compiler = loader.getDefaultExtension(); &#125; // ä½¿ç”¨çœŸæ­£çš„Compilerå¯¹è±¡ï¼ŒåŠ¨æ€ç¼–è¯‘ä»£ç  return compiler.compile(code, classLoader); &#125;&#125; è¯¥ç±»ä½¿ç”¨äº†@Adaptiveæ³¨è§£ï¼Œè¯´æ˜AdaptiveCompilerä¼šå›ºå®šä¸ºé»˜è®¤å®ç°ï¼Œé€šè¿‡ä»£ç çš„é€»è¾‘ä¸éš¾å‘ç°ï¼Œè¯¥ç±»ä¸»è¦ç”¨æ¥ç®¡ç†å…¶å®ƒçš„Compiler,æ¯æ¬¡è°ƒç”¨compileræ–¹æ³•æ—¶ä¼šå°è¯•æ ¹æ®æ‰©å±•åè·å–Compilerçš„æ‰©å±•å¯¹è±¡ï¼Œé»˜è®¤æƒ…å†µä¸‹ä½¿ç”¨JavassistCompileræ‰©å±•å¯¹è±¡ï¼Œç„¶åä½¿ç”¨ç¼–è¯‘å¯¹è±¡è¿›è¡ŒåŠ¨æ€ç¼–è¯‘ä»£ç ä¸²ã€‚ AbstractCompiler æŠ½è±¡ç¼–è¯‘ç±»1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public abstract class AbstractCompiler implements Compiler &#123; /** * åŒ…åçš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œæ³¨æ„åŒ¹é…ç»„ */ private static final Pattern PACKAGE_PATTERN = Pattern.compile(\"package\\\\s+([$_a-zA-Z][$_a-zA-Z0-9\\\\.]*);\"); /** * ç±»åçš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œæ³¨æ„åŒ¹é…ç»„ */ private static final Pattern CLASS_PATTERN = Pattern.compile(\"class\\\\s+([$_a-zA-Z][$_a-zA-Z0-9]*)\\\\s+\"); @Override public Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123; // è·å¾—åŒ…å code = code.trim(); Matcher matcher = PACKAGE_PATTERN.matcher(code); String pkg; if (matcher.find()) &#123; pkg = matcher.group(1); &#125; else &#123; pkg = \"\"; &#125; // è·å¾—ç±»å matcher = CLASS_PATTERN.matcher(code); String cls; if (matcher.find()) &#123; cls = matcher.group(1); &#125; else &#123; throw new IllegalArgumentException(\"No such class name in \" + code); &#125; // è·å¾—å®Œæ•´ç±»åï¼š åŒ…å.ç±»å String className = pkg != null &amp;&amp; pkg.length() &gt; 0 ? pkg + \".\" + cls : cls; try &#123; // ä½¿ç”¨ç±»åŠ è½½å™¨å°è¯•åŠ è½½ç±»ï¼Œå¦‚æœåŠ è½½æˆåŠŸï¼Œè¯´æ˜å·²ç»å­˜åœ¨ï¼ˆå¯èƒ½ç¼–è¯‘è¿‡äº†ï¼‰ return Class.forName(className, true, ClassHelper.getCallerClassLoader(getClass())); // å¦‚æœåŠ è½½å¤±è´¥ï¼Œå¯èƒ½ç±»ä¸å­˜åœ¨ï¼Œè¯´æ˜å¯èƒ½æœªç¼–è¯‘è¿‡ï¼Œå°±è¿›è¡Œç¼–è¯‘ &#125; catch (ClassNotFoundException e) &#123; // ä»£ç æ ¼å¼éªŒè¯ if (!code.endsWith(\"&#125;\")) &#123; throw new IllegalStateException(\"The java code not endsWith \\\"&#125;\\\", code: \\n\" + code + \"\\n\"); &#125; try &#123; // ä½¿ç”¨å…·ä½“çš„ç¼–è¯‘å™¨è¿›è¡Œä»£ç ç¼–è¯‘ï¼Œç”±å­ç±»å®ç° return doCompile(className, code); &#125; catch (RuntimeException t) &#123; throw t; &#125; catch (Throwable t) &#123; throw new IllegalStateException(\"Failed to compile class, cause: \" + t.getMessage() + \", class: \" + className + \", code: \\n\" + code + \"\\n, stack: \" + ClassUtils.toString(t)); &#125; &#125; &#125; /** * ç¼–è¯‘ä»£ç  * * @param name ç±»å * @param source ä»£ç ä¸² * @return ç¼–è¯‘åçš„ç±» * @throws Throwable å¼‚å¸¸ */ protected abstract Class&lt;?&gt; doCompile(String name, String source) throws Throwable;&#125; è¯¥æŠ½è±¡ç±»ä¸»è¦åšä¸¤ä»¶äº‹æƒ…ï¼Œå…ˆè·å–è¦ç¼–è¯‘çš„å­—ç¬¦ä¸²ä¸­çš„ç±»çš„å…¨è·¯å¾„åï¼Œæ ¹æ®ç±»åå°è¯•åŠ è½½å¯¹åº”çš„ç±»ï¼Œå¦‚æœåŠ è½½æˆåŠŸè¯´æ˜å·²ç»ç¼–è¯‘è¿‡äº†ï¼Œå°±ç›´æ¥è¿”å›å³å¯ï¼Œé˜²æ­¢é‡å¤ç¼–è¯‘ã€‚å¦‚æœåŠ è½½å¤±è´¥ï¼Œé‚£ä¹ˆå°±éœ€è¦è¿›è¡Œç¼–è¯‘å¤„ç†ã€‚æ¥ä¸‹æ¥å°†ç¼–è¯‘çš„ä»»åŠ¡äº¤ç»™å…·ä½“çš„å­ç±»æ¥å®Œæˆã€‚ JavassistCompiler ç¼–è¯‘å™¨åœ¨ä»‹ç»JavassistCompilerç¼–è¯‘å™¨å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆç®€å•äº†è§£ä¸‹Javassistï¼Œè¿™æ ·å°±èƒ½å¾ˆå¥½ç†è§£JavassistCompilerçš„é€»è¾‘äº†ã€‚Javassistæ˜¯ç”¨æ¥å¤„ç†javaå­—èŠ‚ç çš„ç±»åº“ï¼Œå¯ä»¥è¿›è¡Œåˆ†æã€ç¼–è¾‘å’Œåˆ›å»ºJavaå­—èŠ‚ç ï¼Œå®ƒæä¾›äº†ä¸°å¯Œçš„APIï¼Œå¯ä»¥ä½¿å¼€å‘äººå‘˜å¾ˆæ–¹ä¾¿æ“ä½œå­—èŠ‚ç ã€‚ä¸ä»…å¦‚æ­¤ï¼Œæˆ‘ä»¬çŸ¥é“å¤„ç†Javaå­—èŠ‚ç çš„å·¥å…·å¾ˆå¤šï¼Œå¦‚cglibï¼Œasmç­‰ï¼Œä¸ºä»€ä¹ˆé€‰æ‹©Javassistå‘¢ï¼Ÿå› ä¸ºJavassistç®€å•ä¸”å¿«é€Ÿï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨Javaç¼–ç çš„æ–¹å¼è€Œä¸éœ€è¦äº†è§£è™šæ‹ŸæœºæŒ‡ä»¤å°±èƒ½åŠ¨æ€æ”¹å˜ç±»çš„ç»“æ„ï¼Œæˆ–è€…åŠ¨æ€ç”Ÿæˆç±»ã€‚ä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸‹javassistçš„å‡ ä¸ªAPIï¼Œdubboå°±æ˜¯ä½¿ç”¨javassistçš„APIæ¥åŠ¨æ€ç”Ÿæˆç±»çš„ã€‚ è¯»å–Class 1234567891011121314// è·å–é»˜è®¤çš„ClassPoolï¼ˆæœç´¢ç±»è·¯å¾„åªæ˜¯JVMçš„åŒè·¯å¾„ä¸‹çš„classï¼‰ï¼Œæ˜¯ä¸€ä¸ªJavassistçš„ç±»æ± ClassPool pool = ClassPool.getDefault();//ä»classpathä¸­æŸ¥è¯¢ç±»XxxCtClass cc = pool.get(\"Xxx\");//è®¾ç½®Xxxçš„çˆ¶ç±»Yyycc.setSuperclass(pool.get(\"Yyy\"));// è½¬ä¸ºå­—èŠ‚æ•°ç»„ï¼Œè¿›è¡ŒCtClassçš„å†»ç»“byte[] b=cc.toBytecode();// ç”Ÿæˆclass ç±»ï¼Œé»˜è®¤åŠ è½½åˆ°å½“å‰çº¿ç¨‹çš„ClassLoaderä¸­ï¼Œä¹Ÿå¯ä»¥é€‰æ‹©è¾“å‡ºçš„ClassLoaderã€‚Class clazz=cc.toClass();// ä¿®æ”¹è¯»å–çš„Classçš„nameï¼Œè¿™æ ·ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„Classï¼Œæ—§çš„ä¸ä¼šåˆ é™¤cc.setName(\"XxxTemp\");// å…¶å®ƒapi... åˆ›å»ºClass 12345678910111213ClassPool pool = ClassPool.getDefault();// åˆ›å»ºä¸€ä¸ªXxxç±»CtClass cc = pool.makeClass(\"Xxx\");//æ–°å¢æ–¹æ³•CtMethod m = CtNewMethod.make(\"public void test()&#123;System.out.print(hello world)&#125;\",cc);cc.addMethod(m);//æ–°å¢FieldCtField f = new CtField(CtClass.intType, \"a\", point);cc.addField(f);//å¼•å…¥åŒ…pool.importPackage(\"package\");// å…¶å®ƒapi... æœç´¢è·¯å¾„ 12345678910ClassPool pool = ClassPool.getDefault();//é»˜è®¤åŠ è½½æ–¹å¼å¦‚pool.insertClassPath(new ClassClassPath(this.getClass()));//ä»æ–‡ä»¶åŠ è½½classpathpool.insertClassPath(\"filepath\")//ä»URLä¸­åŠ è½½pool.insertClassPath(new URLClassPath(\"xxx\"));//è¿½åŠ  LoaderClassPathpool.appendClassPath(new LoaderClassPath(ClassHelper.getCallerClassLoader(getClass()))); å…·ä½“æ“ä½œç¤ºä¾‹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class JavassistCompilerDemo &#123; public static void main(String[] args) throws Exception &#123; // åˆ›å»º createStudentClass(); // è¯»å– readStudentClass(); &#125; /** * åˆ›å»ºå­—èŠ‚ç ä¿¡æ¯ * * @throws Exception */ private static void createStudentClass() throws Exception &#123; // åˆ›å»ºClassPool ClassPool pool = ClassPool.getDefault(); // åˆ›å»º com.alibaba.dubbo.test.Student ç±» CtClass ctClass = pool.makeClass(\"com.alibaba.dubbo.test.Student\"); // åˆ›å»ºå±æ€§(é€šç”¨å½¢å¼) CtField nameField = CtField.make(\"private String name;\", ctClass); ctClass.addField(nameField); // APIå½¢å¼åˆ›å»ºå±æ€§ CtField ageField = new CtField(pool.getCtClass(\"int\"), \"age\", ctClass); ageField.setModifiers(Modifier.PRIVATE); ctClass.addField(ageField); // åˆ›å»ºæ–¹æ³• ï¼ˆé€šç”¨æ–¹å¼ï¼‰ CtMethod setName = CtMethod.make(\"public void setName(String name)&#123;this.name = name;&#125;\", ctClass); CtMethod getName = CtMethod.make(\"public String getName()&#123;return name;&#125;\", ctClass); ctClass.addMethod(setName); ctClass.addMethod(getName); // apiå½¢å¼åˆ›å»ºæ–¹æ³• ctClass.addMethod(CtNewMethod.getter(\"getAge\", ageField)); ctClass.addMethod(CtNewMethod.setter(\"setAge\", ageField)); //åˆ›å»ºæ— å‚æ„é€ æ–¹æ³• CtConstructor ctConstructor = new CtConstructor(null, ctClass); ctConstructor.setBody(\"&#123;&#125;\"); ctClass.addConstructor(ctConstructor); // åˆ›å»ºæœ‰å‚æ„é€ æ–¹æ³• CtConstructor constructor = new CtConstructor(new CtClass[]&#123;CtClass.intType, pool.get(\"java.lang.String\")&#125;, ctClass); constructor.setBody(\"&#123;this.age=age;this.name=name;&#125;\"); ctClass.addConstructor(constructor); // apiåˆ›å»ºæ™®é€šæ–¹æ³• CtMethod ctMethod = new CtMethod(CtClass.voidType, \"sayHello\", new CtClass[]&#123;&#125;, ctClass); ctMethod.setModifiers(Modifier.PUBLIC); ctMethod.setBody(new StringBuilder(\"&#123;\\n System.out.println(\\\"hello world!\\\"); \\n&#125;\").toString()); ctClass.addMethod(ctMethod); // ç”Ÿæˆclass ç±» Class&lt;?&gt; clazz = ctClass.toClass(); // åå°„åˆ›å»ºå¯¹è±¡ Object obj = clazz.newInstance(); //æ–¹æ³•è°ƒç”¨ obj.getClass().getMethod(\"sayHello\", new Class[]&#123;&#125;).invoke(obj); // è·å–ctClassçš„å­—èŠ‚ç  byte[] codeByteArray = ctClass.toBytecode(); // å°†å­—èŠ‚ç å†™å…¥åˆ°classæ–‡ä»¶ä¸­ FileOutputStream fos = new FileOutputStream(new File(\"/opt/test/Student.class\")); fos.write(codeByteArray); fos.close(); &#125; /** * è®¿é—®å·²å­˜åœ¨çš„å­—èŠ‚ç ä¿¡æ¯ * * @throws Exception */ private static void readStudentClass() throws Exception &#123; // åˆ›å»ºClassPool ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.get(\"com.alibaba.dubbo.test.Student\"); //å¾—åˆ°å­—èŠ‚ç  byte[] bytes = ctClass.toBytecode(); System.out.println(Arrays.toString(bytes)); //è·å–ç±»å System.out.println(ctClass.getName()); //è·å–æ¥å£ System.out.println(Arrays.toString(ctClass.getInterfaces())); //è·å–æ–¹æ³•åˆ—è¡¨ System.out.println(Arrays.toString(ctClass.getMethods())); &#125;&#125; è¿è¡Œä¸Šé¢çš„ä»£ç ä¼šåœ¨æœ¬åœ°/opt/testæ–‡ä»¶ç›®å½•ä¸‹ç”Ÿæˆäº†ä¸€ä¸ªStudent.classæ–‡ä»¶ï¼Œæˆ‘ä»¬é€šè¿‡ javap å‘½ä»¤è¿›è¡Œåç¼–è¯‘çš„ç»“æœå¦‚ä¸‹ï¼š1234567891011$ javap Student.class Compiled from \"Student.java\"public class com.alibaba.dubbo.test.Student &#123; public void setName(java.lang.String); public java.lang.String getName(); public int getAge(); public void setAge(int); public com.alibaba.dubbo.test.Student(); public com.alibaba.dubbo.test.Student(int, java.lang.String); public void sayHello();&#125; å¯ä»¥æ¸…æ¥šåœ°çœ‹åˆ°ï¼Œé€šè¿‡JavassistæŠŠä¸€ä¸ªå®Œæ•´çš„classå­—ç¬¦ä¸²ç¼–è¯‘æˆä¸ºä¸€ä¸ªClassï¼Œæœ‰äº†è¿™ä¸ªæ¡ˆä¾‹çš„é“ºå«æˆ‘ä»¬å°±å¾ˆå®¹æ˜“ç†è§£JavassistCompilerçš„åŸç†äº†ï¼Œè®©æˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹å®ƒçš„é€»è¾‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/** * JavassistCompiler. (SPI, Singleton, ThreadSafe) * åŸºäº Javassist å®ç°çš„ Compiler */public class JavassistCompiler extends AbstractCompiler &#123; /** * åŒ¹é…import */ private static final Pattern IMPORT_PATTERN = Pattern.compile(\"import\\\\s+([\\\\w\\\\.\\\\*]+);\\n\"); /** * åŒ¹é… extents */ private static final Pattern EXTENDS_PATTERN = Pattern.compile(\"\\\\s+extends\\\\s+([\\\\w\\\\.]+)[^\\\\&#123;]*\\\\&#123;\\n\"); /** * åŒ¹é… implements */ private static final Pattern IMPLEMENTS_PATTERN = Pattern.compile(\"\\\\s+implements\\\\s+([\\\\w\\\\.]+)\\\\s*\\\\&#123;\\n\"); /** * æ­£åˆ™åŒ¹é…æ–¹æ³•/å±æ€§ */ private static final Pattern METHODS_PATTERN = Pattern.compile(\"\\n(private|public|protected)\\\\s+\"); /** * æ­£åˆ™åŒ¹é…å˜é‡ */ private static final Pattern FIELD_PATTERN = Pattern.compile(\"[^\\n]+=[^\\n]+;\"); @Override public Class&lt;?&gt; doCompile(String name, String source) throws Throwable &#123; // è·å¾—ç±»å int i = name.lastIndexOf('.'); String className = i &lt; 0 ? name : name.substring(i + 1); // åˆ›å»ºClassPollå¯¹è±¡ ClassPool pool = new ClassPool(true); // è®¾ç½®ç±»æœç´¢è·¯å¾„ pool.appendClassPath(new LoaderClassPath(ClassHelper.getCallerClassLoader(getClass()))); // åŒ¹é…import Matcher matcher = IMPORT_PATTERN.matcher(source); // å¼•å…¥åŒ…å List&lt;String&gt; importPackages = new ArrayList&lt;String&gt;(); // å¼•å…¥ç±»å Map&lt;String, String&gt; fullNames = new HashMap&lt;String, String&gt;(); // åŒ¹é…importï¼Œå¯¼å…¥ä¾èµ–åŒ… while (matcher.find()) &#123; String pkg = matcher.group(1); // å¯¼å…¥æ•´ä¸ªåŒ…ä¸‹çš„ç±»/æ¥å£ if (pkg.endsWith(\".*\")) &#123; String pkgName = pkg.substring(0, pkg.length() - 2); pool.importPackage(pkgName); importPackages.add(pkgName); // å¯¼å…¥æŒ‡å®šç±»/æ¥å£ &#125; else &#123; int pi = pkg.lastIndexOf('.'); if (pi &gt; 0) &#123; String pkgName = pkg.substring(0, pi); pool.importPackage(pkgName); importPackages.add(pkgName); fullNames.put(pkg.substring(pi + 1), pkg); &#125; &#125; &#125; String[] packages = importPackages.toArray(new String[0]); // åŒ¹é…extends matcher = EXTENDS_PATTERN.matcher(source); CtClass cls; if (matcher.find()) &#123; String extend = matcher.group(1).trim(); String extendClass; // å†…åµŒçš„ç±»ï¼Œå¦‚ï¼š extends A.B if (extend.contains(\".\")) &#123; extendClass = extend; // æŒ‡å®šå¼•ç”¨çš„ç±» &#125; else if (fullNames.containsKey(extend)) &#123; extendClass = fullNames.get(extend); // å¼•ç”¨æ•´ä¸ªåŒ…ä¸‹çš„ç±» &#125; else &#123; extendClass = ClassUtils.forName(packages, extend).getName(); &#125; // åˆ›å»º CtClass å¯¹è±¡ cls = pool.makeClass(name, pool.get(extendClass)); &#125; else &#123; // åˆ›å»º CtClass å¯¹è±¡ cls = pool.makeClass(name); &#125; // åŒ¹é… implements matcher = IMPLEMENTS_PATTERN.matcher(source); if (matcher.find()) &#123; String[] ifaces = matcher.group(1).trim().split(\"\\\\,\"); for (String iface : ifaces) &#123; iface = iface.trim(); String ifaceClass; // å†…åµŒçš„æ¥å£ï¼Œä¾‹å¦‚ï¼šextends A.B if (iface.contains(\".\")) &#123; ifaceClass = iface; // æŒ‡å®šå¼•ç”¨çš„æ¥å£ &#125; else if (fullNames.containsKey(iface)) &#123; ifaceClass = fullNames.get(iface); // å¼•ç”¨æ•´ä¸ªåŒ…ä¸‹çš„æ¥å£ &#125; else &#123; ifaceClass = ClassUtils.forName(packages, iface).getName(); &#125; // æ·»åŠ æ¥å£ cls.addInterface(pool.get(ifaceClass)); &#125; &#125; // è·å¾—ç±»ä¸­çš„å†…å®¹ï¼Œå³ &#123; &#125; å†…çš„å†…å®¹ String body = source.substring(source.indexOf(\"&#123;\") + 1, source.length() - 1); // åŒ¹é… æ–¹æ³•ã€å±æ€§ String[] methods = METHODS_PATTERN.split(body); for (String method : methods) &#123; method = method.trim(); if (method.length() &gt; 0) &#123; // æ„é€ æ–¹æ³• if (method.startsWith(className)) &#123; cls.addConstructor(CtNewConstructor.make(\"public \" + method, cls)); // å˜é‡ &#125; else if (FIELD_PATTERN.matcher(method).matches()) &#123; cls.addField(CtField.make(\"private \" + method, cls)); // æ–¹æ³• &#125; else &#123; cls.addMethod(CtNewMethod.make(\"public \" + method, cls)); &#125; &#125; &#125; // ç”Ÿæˆç±» return cls.toClass(ClassHelper.getCallerClassLoader(getClass()), JavassistCompiler.class.getProtectionDomain()); &#125;&#125; æ•´ä¸ªé€»è¾‘ä¸‹æ¥å°±æ˜¯æŒ‰ç…§ç¼–å†™ä¸€ä¸ªç±»çš„æ­¥éª¤å¯¹è‡ªé€‚åº”ç±»çš„å­—ç¬¦ä¸²è¿›è¡Œæ­£åˆ™åŒ¹é…æ‹†è§£ï¼Œä¸æ–­é€šè¿‡æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ä¸åŒéƒ¨åˆ†çš„ä»£ç ï¼Œç„¶åè°ƒç”¨Javassistçš„APIç”Ÿæˆä»£è¡¨ä¸åŒéƒ¨åˆ†çš„å¯¹è±¡ï¼Œæœ€ç»ˆç»„è£…æˆä¸€ä¸ªå®Œæ•´çš„è‡ªé€‚åº”æ‰©å±•ç±»ï¼Œè¿˜æ˜¯æŒºç®€å•çš„ã€‚è¿™é‡Œè¯´ä¸€å¥ï¼Œdubboä¸­å¾ˆå¤šåœ°æ–¹éƒ½æ˜¯é‡‡ç”¨æ‹¼æ¥å­—ç¬¦ä¸²æ–¹å¼ï¼Œç„¶åé€šè¿‡å…·ä½“çš„æŠ€æœ¯æ‰‹æ®µç”Ÿæˆç›®æ ‡å¯¹è±¡ï¼Œå¦‚dubbo çš„æœåŠ¡æš´éœ²æºç ä¸­Wrapperç±»çš„ç”Ÿæˆé€»è¾‘ä¹Ÿæ˜¯å…ˆæ‹¼æ¥å­—ç¬¦ä¸²ï¼Œç„¶åé€šè¿‡dubboçš„ClassGeneratorå¤„ç†æˆClassï¼Œä½†æ˜¯ClassGeneratorå†…éƒ¨ä¹Ÿæ˜¯å°è£…äº†Javassistç›¸å…³å¯¹è±¡ï¼Œå…·ä½“ç”ŸæˆClassè¿˜æ˜¯Javassistæ¥å®Œæˆçš„ã€‚ JdkCompiler ç¼–è¯‘å™¨JdkCompilerä½¿ç”¨çš„æ˜¯jdkå†…ç½®çš„ç¼–è¯‘å™¨ï¼Œä¸»è¦ä½¿ç”¨ä¸‰ä¸ªä¸åŒåŠŸèƒ½çš„å¯¹è±¡å®Œæˆå¯¹å­—ç¬¦ä¸²çš„ç¼–è¯‘: JavaFileObjectå¯¹è±¡å°†å­—ç¬¦ä¸²ä»£ç åŒ…è£…æˆä¸€ä¸ªæ–‡ä»¶å¯¹è±¡ JavaFileManageræ¥å£è´Ÿè´£ç®¡ç†æ–‡ä»¶çš„è¯»å–å’Œè¾“å‡ºä½ç½® JavaCompiler.CompilationTask å¯¹è±¡æŠŠJavaFileObjectå¯¹è±¡ ç¼–è¯‘æˆå…·ä½“çš„ç±» 1234567891011121314151617181920212223public Class&lt;?&gt; doCompile(String name, String sourceCode) throws Throwable &#123; int i = name.lastIndexOf('.'); String packageName = i &lt; 0 ? \"\" : name.substring(0, i); String className = i &lt; 0 ? name : name.substring(i + 1); // 1 åˆ›å»ºJavaFileObject å¯¹è±¡ JavaFileObjectImpl javaFileObject = new JavaFileObjectImpl(className, sourceCode); // 2 JavaFileManager ç®¡ç†ç±»æ–‡ä»¶çš„è¾“å…¥å’Œè¾“å‡ºä½ç½® javaFileManager.putFileForInput(StandardLocation.SOURCE_PATH, packageName, className + ClassUtils.JAVA_EXTENSION, javaFileObject); // 3 è°ƒç”¨JavaCompiler.CompilationTask çš„callæ–¹æ³• æŠŠJavaFileObjectå¯¹è±¡ ç¼–è¯‘æˆå…·ä½“çš„ç±» Boolean result = compiler.getTask(null, javaFileManager, diagnosticCollector, options, null, Arrays.asList(javaFileObject)) .call(); if (result == null || !result) &#123; throw new IllegalStateException(\"Compilation failed. class: \" + name + \", diagnostics: \" + diagnosticCollector); &#125; // åŠ è½½ç”Ÿæˆçš„ç±» return classLoader.loadClass(name);&#125; ä¸Šé¢ä»£ç å°±æ˜¯JdkCompilerç¼–è¯‘çš„é€»è¾‘ï¼Œä½¿ç”¨çš„éƒ½æ˜¯jdkçš„æ¥å£ï¼Œæƒ³è¦äº†è§£æ›´å¤šå¯ä»¥è‡ªè¡ŒæŸ¥çœ‹æºä»£ç ï¼Œå…¶å®ƒçš„å°±ä¸å¤šåšåˆ†æã€‚ å°ç»“è‡ªæ­¤ï¼Œdubbo spiåˆ†æå®Œäº†ã€‚dubboæ¡†æ¶å…·æœ‰è‰¯å¥½çš„æ‰©å±•æ€§å¾—ç›Šäºä¸¤ä¸ªæ–¹é¢ï¼Œç¬¬ä¸€ä¸ªæ–¹é¢å°±æ˜¯åœ¨ä¸åŒçš„åœºæ™¯ä¸­ï¼Œdubboä½¿ç”¨äº†ä¸åŒçš„è®¾è®¡æ¨¡å¼ï¼Œç¬¬äºŒä¸ªæ–¹é¢å°±æ˜¯dubbo spiæœºåˆ¶ã€‚å¯ä»¥è¯´dubboä¸­å‡ ä¹æ‰€æœ‰çš„ç»„ä»¶éƒ½æ˜¯é€šè¿‡dubbo spiæœºåˆ¶ä¸²è”èµ·æ¥çš„ï¼Œä¸²è”çš„æ€»çº¿å°±æ˜¯Dubbo URLï¼Œå¯è§dubbo spiåœ¨æ•´ä¸ªæ¡†æ¶ä¸­çš„é‡è¦æ€§ã€‚åœ¨æ¥ä¸‹æ¥çš„å‡ ç¯‡æ–‡ç« ä¸­æˆ‘ä»¬å°†ä¸€èµ·äº†è§£ä¸‹dubboå¤šæ ·çš„é…ç½®ï¼Œæ€»ä½“ä¸Šä¸éš¾ï¼Œå°±æ˜¯å†…å®¹æœ‰ç‚¹å¤šã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Javassist","slug":"Javassist","permalink":"https://gentryhuang.com/tags/Javassist/"}]},{"title":"Dubboæºç åˆ†æ - è‡ªé€‚åº”æ‰©å±•","slug":"rpc/Dubboè‡ªé€‚åº”æ‰©å±•","date":"2020-03-17T16:00:00.000Z","updated":"2020-09-03T03:12:53.633Z","comments":false,"path":"posts/3e0b5964/","link":"","permalink":"https://gentryhuang.com/posts/3e0b5964/","excerpt":"","text":"å‰è¨€ä¸Šä¸€ç¯‡æ–‡ç« ä¸­æˆ‘ä»¬åˆ†æäº†dubbo spiæœºåˆ¶ï¼Œä½†æ˜¯é—ç•™äº†è‡ªé€‚åº”æ‰©å±•å¹¶æ²¡æœ‰å±•å¼€è¯´æ˜ï¼Œè¿™ç¯‡æ–‡ç« å°±æ˜¯æ¥å¡«å‘çš„ã€‚ä¸Šç¯‡æ–‡ç« ä¸­ä¹Ÿä»‹ç»äº†å›ºå®šçš„è‡ªé€‚åº”æ‰©å±•ç±»ä»¥åŠåŠ è½½çš„æµç¨‹ï¼Œè¿™ç¯‡æ–‡ç« ä¸»è¦ä¸“æ³¨äºè‡ªåŠ¨ç”Ÿæˆçš„è‡ªé€‚åº”æ‰©å±•ç±»ä»¥åŠè‡ªé€‚åº”æ‰©å±•å¯¹è±¡çš„åˆ›å»ºï¼Œå°±ä¸å†è¿‡å¤šä»‹ç»å›ºå®šçš„è‡ªé€‚åº”æ‰©å±•ã€‚è‡ªé€‚åº”æ‰©å±•æ•´ä½“ä¸Šéœ€è¦è®¨è®ºä¸‰éƒ¨åˆ†å†…å®¹ï¼šè‡ªé€‚åº”æ‰©å±•åŸç†ã€è‡ªé€‚åº”æ‰©å±•ç±»ä¸²çš„ç”Ÿæˆ å’Œ åŠ¨æ€ç¼–è¯‘ ã€‚ è¯¥ç¯‡æ–‡ç« å°†è®¨è®ºå‰ä¸¤ä¸ªéƒ¨åˆ†ï¼ŒåŠ¨æ€ç¼–è¯‘ä¼šå•ç‹¬å†™ä¸€ç¯‡æ–‡ç« è¯¦ç»†è¯´æ˜ã€‚ è‡ªé€‚åº”æ‰©å±•åŸç†æ‰©å±•ç‚¹çš„æ‰©å±•ç±»ä¸€èˆ¬ä¼šåœ¨æ¡†æ¶å¯åŠ¨æ—¶è¢«åŠ è½½ï¼Œä½†æˆ‘ä»¬è¿™æ¬¡çš„ä¸»è§’å¹¶ä¸ä¼šåœ¨æ¡†æ¶å¯åŠ¨æ—¶è¢«åŠ è½½ï¼Œåªå¯èƒ½åœ¨è·å–è‡ªé€‚åº”å®ç°çš„æ—¶å€™è¢«åˆ›å»ºã€ç¼–è¯‘å’Œå®ä¾‹åŒ–ã€‚è¿™é‡Œä¹‹æ‰€ä»¥è¯´å¯èƒ½ï¼Œæ˜¯å½“ä¸€ä¸ªæ‰©å±•æ¥å£æ—¢æœ‰å›ºå®šçš„è‡ªé€‚åº”æ‰©å±•ç±»ï¼Œåˆæƒ³å®ç°è‡ªåŠ¨ç”Ÿæˆè‡ªé€‚åº”æ‰©å±•ç±»çš„æƒ…å†µä¸‹ï¼Œåªä¼šä»¥å›ºå®šçš„è‡ªé€‚åº”æ‰©å±•ç±»ä¸ºå‡†ï¼Œä¸ä¼šå»åˆ›å»ºåŠ¨æ€çš„è‡ªé€‚åº”æ‰©å±•ç±»ï¼Œåœ¨æ¡†æ¶å¯åŠ¨æ—¶å°±ä¼šåŠ è½½å›ºå®šæ‰©å±•ç±»å¹¶æ”¾å…¥ç¼“å­˜ã€‚å½“ç¼“å­˜ä¸­ä¸å­˜åœ¨è‡ªé€‚åº”æ‰©å±•ç±»æ—¶ï¼Œdubboæ²¡æœ‰ç›´æ¥ä½¿ç”¨ä»£ç†æ¨¡å¼å®ç°è‡ªé€‚åº”æ‰©å±•ï¼Œè€Œæ˜¯ä¸ºæ‰©å±•æ¥å£ç”Ÿæˆå…·æœ‰ä»£ç†åŠŸèƒ½çš„ä»£ç ï¼Œç„¶åé€šè¿‡åŠ¨æ€ç¼–è¯‘å¾—åˆ°è‡ªé€‚åº”ç±»ï¼Œæ•´ä¸ªè¿‡ç¨‹æœ€ç»ˆçš„ç›®çš„æ˜¯ä¸ºæ‰©å±•ç‚¹ç”Ÿæˆä»£ç†å¯¹è±¡ï¼Œè€Œä»£ç†å¯¹è±¡ä¸»è¦ä»»åŠ¡å°±æ˜¯ä»URLä¸­è·å–æ‰©å±•åå¯¹åº”çš„æ‰©å±•å®ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬é€šè¿‡å¯¹å®˜ç½‘çš„ä¾‹å­ç¨åŠ æ”¹åŠ¨æ¥è¯´æ˜è‡ªåŠ¨ç”Ÿæˆçš„è‡ªé€‚åº”æ‰©å±•çš„åŸç†ã€‚ è½¦è½®åˆ¶é€ æ¥å£ WheelMaker 123public interface WheelMaker &#123; void makeWheel(URL url);&#125; WheelMaker æ¥å£çš„æ™®é€šå®ç°ç±» 123456// CommonWheelMakerå¯¹åº”çš„æ‰©å±•åè®¾ç½®ä¸º commonWheelMakerpublic class CommonWheelMaker implements WheelMaker &#123; public void makeWheel(URL url) &#123; System.out.println(\"æ‰“å°urlï¼Œåˆ¶é€ å…¨å®‡å®™æœ€å¥½çš„è½¦è½®...\" + url); &#125;&#125; WheelMaker æ¥å£çš„è‡ªé€‚åº”å®ç°ç±» 12345678910111213141516171819public class AdaptiveWheelMaker implements WheelMaker &#123; public void makeWheel(URL url) &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; // 1.ä» URL ä¸­è·å– WheelMaker åç§° String wheelMakerName = url.getParameter(\"wheel.maker\"); if (wheelMakerName == null) &#123; throw new IllegalArgumentException(\"wheelMakerName == null\"); &#125; // 2.é€šè¿‡ SPI åŠ è½½ WheelMaker åç§° å¯¹åº”WheelMakerå…·ä½“å®ç°ã€‚è¿™é‡Œè·å–æ‰©å±•å®ç°è¿˜æ˜¯ä½¿ç”¨getExtensionæ–¹æ³•ã€‚ WheelMaker wheelMaker = ExtensionLoader.getExtensionLoader(WheelMaker.class).getExtension(wheelMakerName); // 3.è°ƒç”¨ç›®æ ‡æ–¹æ³• wheelMaker.makeWheel(url); &#125;&#125; AdaptiveWheelMaker æ˜¯ä¸€ä¸ªä»£ç†ç±»[åœ¨dubboæ¡†æ¶ä¸­è¯¥ç±»å‹çš„ç±»æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„,å¹¶å‘æ‰‹åŠ¨å®ç°],ä¸ä¼ ç»Ÿçš„ä»£ç†é€»è¾‘ä¸åŒï¼ŒAdaptiveWheelMaker æ‰€ä»£ç†çš„å¯¹è±¡æ˜¯åœ¨ makeWheel æ–¹æ³•ä¸­é€šè¿‡ SPI åŠ è½½å¾—åˆ°çš„ã€‚makeWheel æ–¹æ³•ä¸»è¦åšäº†ä¸‰ä»¶äº‹æƒ…ï¼š ä» URL ä¸­è·å– WheelMaker æ‰©å±•å é€šè¿‡ SPI åŠ è½½å…·ä½“çš„ WheelMaker å®ç°ç±» è°ƒç”¨ç›®æ ‡æ–¹æ³• ç¨‹åºè¿è¡Œæ—¶ï¼Œå‡è®¾æˆ‘ä»¬è·å–åˆ°äº†AdaptiveWheelMakerå¯¹è±¡ï¼Œç„¶åè°ƒç”¨å®ƒçš„makeWheelæ–¹æ³•ï¼Œç„¶åæœ‰è¿™æ ·ä¸€ä¸ª url å‚æ•°ä¼ å…¥ï¼š 1dubbo:&#x2F;&#x2F;192.168.0.101:20880&#x2F;XxxService?wheel.maker&#x3D;commonWheelMaker AdaptiveWheelMaker çš„ makeWheel æ–¹æ³•ä» url ä¸­æå– wheel.maker å‚æ•°ï¼Œå¾—åˆ°æ‰©å±•å commonWheelMakerï¼Œä¹‹åå†é€šè¿‡ SPI åŠ è½½æ‰©å±•åä¸º commonWheelMaker çš„å®ç°ç±»ï¼Œæœ€ç»ˆå¾—åˆ°å…·ä½“çš„ WheelMaker å®ä¾‹ã€‚ åŸç†å°ç»“è¿™ä¸ªä¾‹å­å±•ç¤ºäº†è‡ªåŠ¨ç”Ÿæˆçš„è‡ªé€‚åº”æ‰©å±•ç±»çš„æ ¸å¿ƒå®ç°ï¼Œå³åœ¨æ‰©å±•æ¥å£çš„æ–¹æ³•è¢«è°ƒç”¨ï¼ˆdubboä¸­æ˜¯ä½¿ç”¨è‡ªé€‚åº”æ‰©å±•å¯¹è±¡è°ƒç”¨çš„ï¼‰æ—¶ï¼Œé€šè¿‡SPIåŠ è½½å…·ä½“çš„æ‰©å±•å¯¹è±¡ï¼Œå¹¶è°ƒç”¨è¯¥æ‰©å±•å¯¹è±¡çš„åŒåæ–¹æ³•ã€‚ è‡ªé€‚åº”æ‰©å±•ç±»ä¸²çš„ç”Ÿæˆé€šè¿‡ä¸Šé¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬ç›´è§‚çš„è®¤è¯†äº†è‡ªé€‚åº”æ‰©å±•ç±»çš„å·¥ä½œåŸç†ã€‚é€šè¿‡ä¸Šä¸€ç¯‡æ–‡ç« æˆ‘ä»¬çŸ¥é“@Adaptive å¯æ³¨è§£åœ¨ç±»æˆ–æ–¹æ³•ä¸Šï¼Œæ³¨è§£åœ¨ç±»ä¸Šæ—¶ï¼ŒDubbo ä¸ä¼šä¸ºè¯¥ç±»ç”Ÿæˆä»£ç†ç±»ã€‚æ³¨è§£åœ¨æ‰©å±•æ¥å£çš„æ–¹æ³•ä¸Šæ—¶ï¼ŒDubbo ä¼šä¸ºä¸ºè¯¥æ¥å£ç”Ÿæˆä»£ç†é€»è¾‘ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬ä»ä¸Šä¸€ç¯‡æ–‡ç« æåˆ°çš„getAdaptiveExtensionæ–¹æ³•å…¥å£ç»§ç»­åˆ†æã€‚ getAdaptiveExtension æ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637public T getAdaptiveExtension() &#123; // ä»ç¼“å­˜ä¸­è·å–æ‰©å±•ç‚¹å¯¹åº”çš„è‡ªé€‚åº”æ‰©å±•å¯¹è±¡ Object instance = cachedAdaptiveInstance.get(); // å¦‚æœç¼“å­˜æœªå‘½ä¸­ï¼Œåˆ™é€šè¿‡åŒé‡æ£€é”è·å–/åˆ›å»º if (instance == null) &#123; // è‹¥ä¹‹å‰åˆ›å»ºçš„æ—¶å€™æ²¡æœ‰æŠ¥é”™ï¼Œå³ä¹‹å‰åˆ›å»ºäº†å¹¶ä¸”æ²¡æœ‰æŠ›å‡ºå¼‚å¸¸ if (createAdaptiveInstanceError == null) &#123; synchronized (cachedAdaptiveInstance) &#123; // å†æ¬¡å°è¯•ä»ç¼“å­˜ä¸­è·å– instance = cachedAdaptiveInstance.get(); if (instance == null) &#123; try &#123; // åˆ›å»ºè‡ªé€‚åº”æ‹“å±•å¯¹è±¡ instance = createAdaptiveExtension(); // æ”¾å…¥ç¼“å­˜ä¸­ cachedAdaptiveInstance.set(instance); &#125; catch (Throwable t) &#123; createAdaptiveInstanceError = t; throw new IllegalStateException(\"fail to create adaptive instance: \" + t.toString(), t); &#125; &#125; &#125; // è‹¥ä¹‹å‰åˆ›å»ºçš„æ—¶å€™æŠ¥é”™ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ &#125; else &#123; throw new IllegalStateException(\"fail to create adaptive instance: \" + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError); &#125; &#125; return (T) instance;&#125; ä¸Šé¢çš„ä»£ç ç”¨æ¥è·å–æ‰©å±•ç‚¹çš„è‡ªé€‚åº”å¯¹è±¡ï¼Œè¯¥æ–¹æ³•å…ˆæ£€æŸ¥ç¼“å­˜ï¼Œç¼“å­˜ä¸­æ²¡æœ‰åˆ™è°ƒç”¨ createAdaptiveExtension æ–¹æ³•å°è¯•åˆ›å»ºè‡ªé€‚åº”å¯¹è±¡ã€‚æˆ‘ä»¬ç»§ç»­è·Ÿè¿› createAdaptiveExtension æ–¹æ³•ã€‚ 12345678910111213private T createAdaptiveExtension() &#123; try &#123; /** * 1 getAdaptiveExtensionClassæ–¹æ³•ç”¨æ¥è·å¾—è‡ªé€‚åº”æ‰©å±•ç±»ã€æ³¨æ„ï¼Œè·å¾—çš„è‡ªé€‚åº”æ‰©å±•ç±»å¯èƒ½æ˜¯é…ç½®æ–‡ä»¶ä¸­çš„ç±»ï¼Œä¹Ÿå¯èƒ½æ˜¯é€šè¿‡å­—èŠ‚ç åˆ›å»ºçš„ã€‘ * 2 é€šè¿‡åå°„åˆ›å»ºè‡ªé€‚åº”æ‰©å±•å¯¹è±¡ * 3 è°ƒç”¨injectExtensionæ–¹æ³•ï¼Œå‘åˆ›å»ºçš„è‡ªé€‚åº”æ‹“å±•å¯¹è±¡æ³¨å…¥ä¾èµ– */ return injectExtension((T) getAdaptiveExtensionClass().newInstance()); &#125; catch (Exception e) &#123; throw new IllegalStateException(\"Can not create adaptive extension \" + type + \", cause: \" + e.getMessage(), e); &#125; &#125; ä¸Šé¢çš„æ–¹æ³•å…ˆè·å–è‡ªé€‚åº”æ‰©å±•ç±»ï¼Œç„¶ååˆ©ç”¨åå°„åˆ›å»ºè‡ªé€‚åº”å¯¹è±¡ï¼Œæ¥ç€ä¼šå‘åˆ›å»ºçš„è‡ªé€‚åº”å¯¹è±¡æ³¨å…¥ä¾èµ–ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“äº†è‡ªé€‚åº”æ‰©å±•ç±»åˆ†ä¸ºä¸¤ç±»ï¼Œå›ºå®šçš„è‡ªé€‚åº”æ‰©å±•ç±»ä¸­å¯èƒ½å­˜åœ¨ä¸€äº›ä¾èµ–ï¼Œè¿™æ—¶éœ€è¦ä½¿ç”¨æ‰©å±•å·¥å‚è¿›è¡Œsetteræ³¨å…¥ï¼Œè‡ªåŠ¨ç”Ÿæˆçš„æ‰©å±•å®ç°ä¸€èˆ¬ä¸ä¼šä¾èµ–å…¶å®ƒå±æ€§ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬åˆ†æä¸‹è‡ªé€‚åº”æ‰©å±•ç±»æ€ä¹ˆè·å–çš„ã€‚ 123456789101112private Class&lt;?&gt; getAdaptiveExtensionClass() &#123; // åˆ·æ–°æ‰©å±•ç‚¹å®ç°ç±»é›†åˆ getExtensionClasses(); // ç¼“å­˜ä¸­æœ‰æ‰©å±•ç‚¹çš„è‡ªé€‚åº”ç±»å°±ç›´æ¥è¿”å› if (cachedAdaptiveClass != null) &#123; return cachedAdaptiveClass; &#125; // æ²¡æœ‰å°±è‡ªåŠ¨ç”Ÿæˆè‡ªé€‚åº”æ‹“å±•ç±»çš„ä»£ç ï¼Œç¼–è¯‘åè¿”å›è¯¥ç±» return cachedAdaptiveClass = createAdaptiveExtensionClass(); &#125; ä¸Šé¢çš„ä»£ç å…ˆæ˜¯åˆ·æ–°æ‰©å±•ç‚¹å®ç°ç±»é›†åˆï¼Œæ³¨æ„å¦‚æœæ‰©å±•æ¥å£çš„å®ç°ç±»ä¸­æœ‰æ ‡æ³¨@Adaptiveæ³¨è§£çš„ç±»ï¼Œé‚£ä¹ˆcachedAdaptiveClassç¼“å­˜å±æ€§ä¸­ä¿å­˜çš„å°±æ˜¯è¯¥ç±»ï¼Œå³å›ºå®šçš„è‡ªé€‚åº”æ‰©å±•ç±»ã€‚å¦‚æœæ²¡æœ‰çš„è¯ï¼Œè¯´æ˜å½“å‰æ‰©å±•æ¥å£çš„å®ç°ç±»ä¸­ä¸å­˜åœ¨å›ºå®šçš„è‡ªé€‚åº”æ‰©å±•ç±»ï¼Œé‚£ä¹ˆåªèƒ½å°è¯•åˆ›å»ºè¯¥æ¥å£çš„è‡ªé€‚åº”æ‰©å±•ç±»ï¼Œä»£ç é€»è¾‘å¦‚ä¸‹ï¼š 1234567891011private Class&lt;?&gt; createAdaptiveExtensionClass() &#123; // ç”Ÿæˆè‡ªé€‚åº”æ‹“å±•å®ç°ç±»çš„ä»£ç å­—ç¬¦ä¸² String code = createAdaptiveExtensionClassCode(); // è·å–ç±»åŠ è½½å™¨ ClassLoader classLoader = findClassLoader(); // è·å–Compilerè‡ªé€‚åº”æ‰©å±•å¯¹è±¡ com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension(); // åŠ¨æ€ç¼–è¯‘ï¼Œç”ŸæˆClass return compiler.compile(code, classLoader); &#125; createAdaptiveExtensionClass æ–¹æ³•åŒ…å«ä¸‰ä¸ªæ­¥éª¤ï¼š ç”Ÿæˆè‡ªé€‚åº”æ‰©å±•å®ç°ç±»çš„ä»£ç å­—ç¬¦ä¸² è·å–Compilerè‡ªé€‚åº”æ‰©å±•å¯¹è±¡ åŠ¨æ€ç¼–è¯‘ è‡ªé€‚åº”æ‹“å±•å®ç°ç±»çš„ä»£ç å­—ç¬¦ä¸² ï¼Œç”ŸæˆClass åé¢ä¸¤ä¸ªæ­¥éª¤å±äº åŠ¨æ€ç¼–è¯‘ éƒ¨åˆ†ï¼Œä¸åœ¨æœ¬æ–‡èŒƒç•´ï¼Œæˆ‘ä»¬ä¸»è¦å…³æ³¨ è‡ªé€‚åº”æ‰©å±•å®ç°ç±»çš„ä»£ç å­—ç¬¦ä¸² çš„ç”Ÿæˆé€»è¾‘ã€‚ è‡ªé€‚åº”æ‰©å±•ç±»ä»£ç ç”ŸæˆcreateAdaptiveExtensionClassCodeæ–¹æ³•ä»£ç éå¸¸å¤šï¼Œä¸è¿‡æ€»çš„é€»è¾‘å¤§è‡´å¯ä»¥åˆ†ä¸ºå…«ä¸ªé€»è¾‘åˆ†æ”¯ï¼Œå·²ç»è¿›è¡Œè¯¦ç»†çš„æ³¨é‡Šï¼Œä¸‹é¢å°±ç›´æ¥è´´ä¸Šä»£ç ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322private String createAdaptiveExtensionClassCode() &#123; StringBuilder codeBuilder = new StringBuilder(); //----------------- 1 æ£€æŸ¥æ‰©å±•æ¥å£æ–¹æ³•æ˜¯å¦åŒ…å« Adaptiveæ³¨è§£ï¼Œè¦æ±‚è‡³å°‘æœ‰ä¸€ä¸ªæ–¹æ³•è¢« Adaptive æ³¨è§£ä¿®é¥° --------------------/ // åå°„è·å–æ‰©å±•ç‚¹æ‰€æœ‰æ–¹æ³• Method[] methods = type.getMethods(); boolean hasAdaptiveAnnotation = false; // éå†æ–¹æ³•åˆ—è¡¨ï¼Œæ£€æµ‹æ˜¯å¦æ ‡æ³¨ Adaptive æ³¨è§£ for (Method m : methods) &#123; if (m.isAnnotationPresent(Adaptive.class)) &#123; hasAdaptiveAnnotation = true; break; &#125; &#125; // è‹¥æ‰€æœ‰æ–¹æ³•ä¸Šéƒ½æ²¡æœ‰Adaptiveæ³¨è§£ï¼Œå°±æŠ›å‡ºå¼‚å¸¸ if (!hasAdaptiveAnnotation) &#123; throw new IllegalStateException(\"No adaptive method on extension \" + type.getName() + \", refuse to create the adaptive class!\"); &#125; //------------------ 2 ç”Ÿæˆè‡ªé€‚åº”æ‰©å±•ç±»çš„ä»£ç å­—ç¬¦ä¸²ï¼Œä»£ç ç”Ÿæˆçš„é¡ºåºä¸ Java æ–‡ä»¶å†…å®¹é¡ºåºä¸€è‡´ ---------------------------/ // ç”Ÿæˆpackage codeBuilder.append(\"package \").append(type.getPackage().getName()).append(\";\"); // ç”Ÿæˆimportï¼Œæ³¨æ„è‡ªé€‚åº”ç±»åªä¾èµ–ExtensionLoaderï¼Œå…¶å®ƒçš„éƒ½ä¸ä¼šä¾èµ–ï¼Œå› ä¸ºä½¿ç”¨çš„éƒ½æ˜¯å…¨è·¯å¾„åï¼Œä¸éœ€è¦å†å¯¼å…¥åŒ…äº† codeBuilder.append(\"\\nimport \").append(ExtensionLoader.class.getName()).append(\";\"); // å¼€å§‹ç”Ÿæˆ class codeBuilder.append(\"\\npublic class \").append(type.getSimpleName()).append(\"$Adaptive\").append(\" implements \").append(type.getCanonicalName()).append(\" &#123;\"); //------------------ 3 ç”Ÿæˆè‡ªé€‚åº”æ‰©å±•ç±»ä¸­çš„æ–¹æ³•ï¼Œæ¥å£ä¸­æ–¹æ³•å¯ä»¥è¢« Adaptive æ³¨è§£ä¿®é¥°ï¼Œä¹Ÿå¯ä»¥ä¸è¢«ä¿®é¥°ï¼Œä½†å¤„ç†æ–¹å¼ä¹Ÿä¸åŒ -------/ // éå†æ–¹æ³•åˆ—è¡¨ï¼Œä¸ºç±»ä¸­å¡«å……æ–¹æ³• for (Method method : methods) &#123; // æ–¹æ³•è¿”å›ç±»å‹ Class&lt;?&gt; rt = method.getReturnType(); // æ–¹æ³•å‚æ•°ç±»å‹ Class&lt;?&gt;[] pts = method.getParameterTypes(); // æ–¹æ³•å¼‚å¸¸ç±»å‹ Class&lt;?&gt;[] ets = method.getExceptionTypes(); // å°è¯•è·å–æ–¹æ³•çš„ Adaptive æ³¨è§£ï¼Œæœ‰æ— æ³¨è§£çš„åŒºåˆ«ä½“ç°åœ¨ ç”Ÿæˆæ–¹æ³•å­—ç¬¦ä¸²çš„å·®å¼‚ä¸Š Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class); // ç±»ä¸­çš„æ–¹æ³•å­—ç¬¦ä¸²é›† StringBuilder code = new StringBuilder(512); // 3.1 ç”Ÿæˆæ²¡æœ‰Adaptiveæ³¨è§£çš„æ–¹æ³•ä»£ç ä¸²ã€‚Dubboä¸ä¼šä¸ºæ²¡æœ‰æ ‡æ³¨Adaptiveæ³¨è§£çš„æ–¹æ³•ç”Ÿæˆä»£ç†é€»è¾‘ï¼Œä»…ä»…ç”Ÿæˆä¸€å¥æŠ›å‡ºå¼‚å¸¸ä»£ç  if (adaptiveAnnotation == null) &#123; code.append(\"throw new UnsupportedOperationException(\\\"method \") .append(method.toString()).append(\" of interface \") .append(type.getName()).append(\" is not adaptive method!\\\");\"); // 3.2 ç”Ÿæˆæœ‰Adaptiveæ³¨è§£çš„æ–¹æ³•ä»£ç ä¸²ã€‚æ ¸å¿ƒé€»è¾‘å°±æ˜¯ä»æ–¹æ³•çš„å‚æ•°åˆ—è¡¨ä¸­ç›´æ¥æˆ–é—´æ¥è·å–é…ç½®æ€»çº¿URLï¼Œç„¶åç»“åˆAdaptiveæ³¨è§£å€¼åŠé»˜è®¤æ‰©å±•åç­–ç•¥ï¼Œä»URLä¸­å¾—åˆ°æ‰©å±•åï¼Œç„¶åé€šè¿‡ExtensionLoaderè·å–æ‰©å±•åå¯¹åº”çš„æ‰©å±•å®ç°å¯¹è±¡ã€‚ &#125; else &#123; int urlTypeIndex = -1; // éå†æ–¹æ³•å‚æ•°ç±»å‹æ•°ç»„ for (int i = 0; i &lt; pts.length; ++i) &#123; // åˆ¤æ–­å‚æ•°ç±»å‹æ˜¯ä¸æ˜¯URLï¼Œç¡®å®šURLå‚æ•°ä½ç½® if (pts[i].equals(URL.class)) &#123; urlTypeIndex = i; break; &#125; &#125; // urlTypeIndex != -1ï¼Œè¡¨ç¤ºå‚æ•°åˆ—è¡¨ä¸­å­˜åœ¨ URLç±»å‹çš„å‚æ•°ï¼Œå³ç›´æ¥è·å–é…ç½®æ€»çº¿URLã€‚å¦‚ï¼š &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException æ–¹æ³• if (urlTypeIndex != -1) &#123; // ä¸º URL ç±»å‹å‚æ•°ç”Ÿæˆåˆ¤ç©ºä»£ç ï¼Œå¦‚ï¼šif (arg0 == null) throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument == null\"); String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"url == null\\\");\", urlTypeIndex); code.append(s); // ä¸º URL ç±»å‹å‚æ•°ç”Ÿæˆèµ‹å€¼ä»£ç ï¼Œå½¢å¦‚ URL url = arg0 s = String.format(\"\\n%s url = arg%d;\", URL.class.getName(), urlTypeIndex); code.append(s); &#125; // å‚æ•°åˆ—è¡¨ä¸­ä¸å­˜åœ¨ URL ç±»å‹å‚æ•°ï¼Œåªèƒ½é—´æ¥å°è¯•è·å–é…ç½®æ€»çº¿URLã€‚å¦‚ï¼š&lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException æ–¹æ³•ï¼Œé…ç½®æ€»çº¿URLæ˜¯ä»invokerä¸­è·å–ã€‚ else &#123; // ç›®æ ‡æ–¹æ³•åï¼Œè¿™é‡Œå¦‚æœå­˜åœ¨å°±æ˜¯ getUrl String attribMethod = null; // find URL getter method LBL_PTS: // éå†æ–¹æ³•çš„å‚æ•°ç±»å‹åˆ—è¡¨ for (int i = 0; i &lt; pts.length; ++i) &#123; // è·å–å½“å‰æ–¹æ³•çš„å‚æ•°ç±»å‹ çš„ å…¨éƒ¨æ–¹æ³• Method[] ms = pts[i].getMethods(); // åˆ¤æ–­æ–¹æ³•å‚æ•°å¯¹è±¡ä¸­æ˜¯å¦æœ‰ public URL getUrl() æ–¹æ³• for (Method m : ms) &#123; String name = m.getName(); if ((name.startsWith(\"get\") || name.length() &gt; 3) &amp;&amp; Modifier.isPublic(m.getModifiers()) &amp;&amp; !Modifier.isStatic(m.getModifiers()) &amp;&amp; m.getParameterTypes().length == 0 &amp;&amp; m.getReturnType() == URL.class) &#123; urlTypeIndex = i; attribMethod = name; // æ‰¾åˆ°æ–¹æ³•å‚æ•°åˆ—è¡¨ä¸­é—´æ¥å­˜åœ¨URLçš„å‚æ•°ï¼Œåˆ™ç»“æŸå¯»æ‰¾é€»è¾‘ break LBL_PTS; &#125; &#125; &#125; // å¦‚æœå‚æ•°åˆ—è¡¨ä¸­æ²¡æœ‰ä¸€ä¸ªå‚æ•°æœ‰getUrlæ–¹æ³•ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ if (attribMethod == null) &#123; throw new IllegalStateException(\"fail to create adaptive class for interface \" + type.getName() + \": not found url parameter or url attribute in parameters of method \" + method.getName()); &#125; // ä¸ºå¯è¿”å›URLçš„å‚æ•°ç”Ÿæˆåˆ¤ç©ºä»£ç ï¼Œå¦‚ï¼šif (arg0 == null) throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument == null\"); String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"%s argument == null\\\");\", urlTypeIndex, pts[urlTypeIndex].getName()); code.append(s); // ä¸ºå¯è¿”å›URLçš„å‚æ•° çš„getUrlæ–¹æ³•è¿”å› çš„URLç”Ÿæˆåˆ¤ç©ºä»£ç ï¼Œå¦‚ï¼šif (arg0.getUrl() == null) throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null\"); s = String.format(\"\\nif (arg%d.%s() == null) throw new IllegalArgumentException(\\\"%s argument %s() == null\\\");\", urlTypeIndex, attribMethod, pts[urlTypeIndex].getName(), attribMethod); code.append(s); // ç”Ÿæˆèµ‹å€¼è¯­å¥ï¼Œå½¢å¦‚ï¼šURL url = argN.getUrl(); s = String.format(\"%s url = arg%d.%s();\", URL.class.getName(), urlTypeIndex, attribMethod); code.append(s); &#125; //----------------- 4 è·å– Adaptive æ³¨è§£å€¼ ï¼ŒAdaptive æ³¨è§£å€¼ value ç±»å‹ä¸º String[]ï¼Œå¯å¡«å†™å¤šä¸ªå€¼ï¼Œé»˜è®¤æƒ…å†µä¸‹ä¸ºç©ºæ•°ç»„ -------------/ /** * è·å–@Adaptiveæ³¨è§£çš„å€¼ï¼Œå¦‚æœæœ‰å€¼ï¼Œè¿™äº›å€¼å°†ä½œä¸ºè·å–æ‰©å±•åçš„keyï¼Œéœ€è¦æ³¨æ„ï¼ŒProtocolæ‰©å±•å’Œå…¶å®ƒæ‰©å±•ç‚¹æ˜¯ä¸åŒçš„ï¼Œå‰è€…è·å–æ‰©å±•åæ˜¯å–åè®®ï¼Œåè€…è·å–æ‰©å±•åæ˜¯å–å‚æ•°çš„å€¼ * 1 æ™®é€šæ‰©å±•ç‚¹ï¼Œå¦‚ProxyFactorï¼š String extName = url.getParameter(\"proxy\", \"javassist\"); * 2 Protocolæ‰©å±•ç‚¹ï¼š String extName = ( url.getProtocol() == null ? \"dubbo\" : url.getProtocol() ); */ String[] value = adaptiveAnnotation.value(); // å¦‚æœ@Adaptiveæ³¨è§£æ²¡æœ‰æŒ‡å®šå€¼ï¼Œåˆ™æ ¹æ®æ‰©å±•æ¥å£åç”Ÿæˆã€‚å¦‚ï¼šSimpleExt -&gt; simple.extï¼Œå³å°†æ‰©å±•æ¥å£åä¸­çš„å¤§å†™è½¬å°å†™ï¼Œå¹¶ä½¿ç”¨'.'æŠŠå®ƒä»¬è¿æ¥èµ·æ¥ if (value.length == 0) &#123; // è·å–æ‰©å±•æ¥å£ç®€å•åç§°çš„å­—ç¬¦æ•°ç»„ char[] charArray = type.getSimpleName().toCharArray(); StringBuilder sb = new StringBuilder(128); for (int i = 0; i &lt; charArray.length; i++) &#123; // åˆ¤æ–­æ˜¯å¦å¤§å†™å­—æ¯ï¼Œå¦‚æœæ˜¯å°±ä½¿ç”¨ '.' è¿æ¥ï¼Œå¹¶å¤§å†™è½¬å°å†™ if (Character.isUpperCase(charArray[i])) &#123; if (i != 0) &#123; sb.append(\".\"); &#125; sb.append(Character.toLowerCase(charArray[i])); &#125; else &#123; sb.append(charArray[i]); &#125; &#125; value = new String[]&#123;sb.toString()&#125;; &#125; //--------------------- 5 æ£€æµ‹æ–¹æ³•å‚æ•°åˆ—è¡¨ä¸­æ˜¯å¦å­˜åœ¨ Invocation ç±»å‹çš„å‚æ•°ï¼Œæœ‰åˆ™è¡¨ç¤ºæ˜¯è°ƒç”¨æ–¹æ³• --------------------/ boolean hasInvocation = false; for (int i = 0; i &lt; pts.length; ++i) &#123; // å‚æ•°ç±»å‹æ˜¯Invocation if (pts[i].getName().equals(\"com.alibaba.dubbo.rpc.Invocation\")) &#123; // ä¸º Invocation ç±»å‹å‚æ•°ç”Ÿæˆåˆ¤ç©ºä»£ç  String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"invocation == null\\\");\", i); code.append(s); // ç”Ÿæˆ String methodName = argN.getMethodName()ï¼› ä»£ç ï¼ŒInvocationæ˜¯è°ƒç”¨ä¿¡æ¯ï¼Œé‡Œé¢åŒ…å«è°ƒç”¨æ–¹æ³• s = String.format(\"\\nString methodName = arg%d.getMethodName();\", i); code.append(s); hasInvocation = true; break; &#125; &#125; //----------------------- 6 æ‰©å±•åå†³ç­–é€»è¾‘ï¼Œ@SPIã€@Adaptiveä»¥åŠæ–¹æ³•å«æœ‰Invocationç±»å‹å‚æ•°éƒ½ä¼šå½±å“æœ€ç»ˆçš„æ‰©å±•å -------------------------/ // è®¾ç½®é»˜è®¤æ‹“å±•åï¼ŒSPIæ³¨è§£å€¼ï¼Œé»˜è®¤æƒ…å†µä¸‹ SPIæ³¨è§£å€¼ä¸ºç©ºä¸²ï¼Œæ­¤æ—¶cachedDefaultName = null String defaultExtName = cachedDefaultName; String getNameCode = null; /** * éå†Adaptive çš„æ³¨è§£å€¼ï¼Œç”¨äºç”Ÿæˆä»URLä¸­è·å–æ‹“å±•åçš„ä»£ç ï¼Œæœ€ç»ˆçš„æ‰©å±•åä¼šèµ‹å€¼ç»™ getNameCode å˜é‡ã€‚ * æ³¨æ„ï¼š * 1 è¿™ä¸ªå¾ªç¯çš„éå†é¡ºåºæ˜¯ç”±åå‘å‰éå†çš„ï¼Œå› ä¸ºAdaptiveæ³¨è§£å¯èƒ½é…ç½®äº†å¤šä¸ªæ‰©å±•åï¼Œè€Œdubboè·å–æ‰©å±•åçš„ç­–ç•¥æ˜¯ä»å‰å¾€åä¾æ¬¡è·å–ï¼Œæ‰¾åˆ°å³ç»“æŸï¼Œä»¥ä¸‹ä»£ç æ‹¼æ¥çš„æ—¶å€™ä¹Ÿæ˜¯ä»åå¾€å‰æ‹¼æ¥ã€‚ * 2 ç”Ÿæˆçš„æ‰©å±•åä»£ç å¤§è‡´æœ‰3å¤§ç±»ï¼ŒAdaptiveçš„æ³¨è§£ä¸­å±æ€§å€¼çš„æ•°ç›®å†³å®šäº†å†…åµŒå±‚çº§ï¼š *ï¼ˆ1ï¼‰ String extName = (url.getProtocol() == null ? defaultExtName : url.getProtocol()); è·å–åè®®æ‰©å±•ç‚¹çš„æ‰©å±•å *ï¼ˆ2ï¼‰ String extName = url.getMethodParameter(methodName, Adaptiveçš„æ³¨è§£å€¼, defaultExtName); è·å–æ–¹æ³•çº§åˆ«çš„å‚æ•°å€¼ä½œä¸ºæ‰©å±•åï¼Œå› ä¸ºæ–¹æ³•çš„å‚æ•°åˆ—è¡¨ä¸­å«æœ‰Invocationè°ƒç”¨ä¿¡æ¯ã€‚ *ï¼ˆ3ï¼‰ String extName = url.getParameter(Adaptiveçš„æ³¨è§£å€¼, defaultExtName); è·å–å‚æ•°å€¼ä½œä¸ºæ‰©å±•å *ï¼ˆ4ï¼‰ å¦‚æœAdaptiveçš„æ³¨è§£ä¸­å±æ€§å€¼æœ‰å¤šä¸ªï¼Œå°±è¿›è¡ŒåµŒå¥—è·å–ã€‚å¦‚é…ç½®ä¸¤ä¸ªï¼Œä»¥(3)ä¸ºä¾‹ï¼šString extName = url.getParameter(Adaptiveçš„æ³¨è§£å€¼[0],url.getParameter(Adaptiveçš„æ³¨è§£å€¼[1], defaultExtName)); * 3 å‚æ•°å¦‚æœæ˜¯protocolï¼Œprotocolæ˜¯urlä¸»è¦éƒ¨åˆ†ï¼Œå¯é€šè¿‡getProtocolæ–¹æ³•ç›´æ¥è·å–ã€‚å¦‚æœæ˜¯å…¶ä»–çš„éœ€è¦æ˜¯ä»URLå‚æ•°éƒ¨åˆ†è·å–ã€‚ä¸¤è€…è·å–æ–¹æ³•ä¸ä¸€æ ·ã€‚å…¶ä¸­å‚æ•°è·å–åˆå¯åˆ†ä¸ºæ–¹æ³•çº§åˆ«å‚æ•°å’Œéæ–¹æ³•çº§åˆ«å‚æ•° */ for (int i = value.length - 1; i &gt;= 0; --i) &#123; // ç¬¬ä¸€æ¬¡éå†åˆ†æ”¯ if (i == value.length - 1) &#123; if (null != defaultExtName) &#123; if (!\"protocol\".equals(value[i])) &#123; // æ–¹æ³•å‚æ•°åˆ—è¡¨ä¸­æœ‰è°ƒç”¨ä¿¡æ¯Invocationå‚æ•° if (hasInvocation) &#123; getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName); &#125; else &#123; getNameCode = String.format(\"url.getParameter(\\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName); &#125; &#125; else &#123; getNameCode = String.format(\"( url.getProtocol() == null ? \\\"%s\\\" : url.getProtocol() )\", defaultExtName); &#125; &#125; else &#123; if (!\"protocol\".equals(value[i])) &#123; // æ–¹æ³•å‚æ•°åˆ—è¡¨ä¸­æœ‰è°ƒç”¨ä¿¡æ¯Invocationå‚æ•° if (hasInvocation) &#123; getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName); &#125; else &#123; getNameCode = String.format(\"url.getParameter(\\\"%s\\\")\", value[i]); &#125; &#125; else &#123; getNameCode = \"url.getProtocol()\"; &#125; &#125; // ç¬¬äºŒæ¬¡å¼€å§‹éƒ½èµ°è¯¥åˆ†æ”¯ï¼Œç”¨äºåµŒå¥—è·å–æ‰©å±•å &#125; else &#123; if (!\"protocol\".equals(value[i])) &#123; // æ–¹æ³•å‚æ•°åˆ—è¡¨ä¸­æœ‰è°ƒç”¨ä¿¡æ¯Invocationå‚æ•° if (hasInvocation) &#123; getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName); &#125; else &#123; getNameCode = String.format(\"url.getParameter(\\\"%s\\\", %s)\", value[i], getNameCode); &#125; &#125; else &#123; getNameCode = String.format(\"url.getProtocol() == null ? (%s) : url.getProtocol()\", getNameCode); &#125; &#125; &#125; // ç”Ÿæˆæ‰©å±•æ˜ èµ‹å€¼ä»£ç  code.append(\"\\nString extName = \").append(getNameCode).append(\";\"); // ç”Ÿæˆ æ‰©å±•æ˜ åˆ¤ç©ºä»£ç  String s = String.format(\"\\nif(extName == null) \" + \"throw new IllegalStateException(\\\"Fail to get extension(%s) name from url(\\\" + url.toString() + \\\") use keys(%s)\\\");\", type.getName(), Arrays.toString(value)); code.append(s); //---------------------------------------- 7 ç”Ÿæˆ è·å–æ‰©å±•å¯¹è±¡ä»£ç  ä»¥åŠ è°ƒç”¨æ‰©å±•å¯¹è±¡çš„ç›®æ ‡æ–¹æ³•ä»£ç  ---------------------------------/ // ç”Ÿæˆ extensionæ‰©å±•å¯¹è±¡ èµ‹å€¼ ä»£ç  s = String.format(\"\\n%s extension = (%&lt;s)%s.getExtensionLoader(%s.class).getExtension(extName);\", type.getName(), ExtensionLoader.class.getSimpleName(), type.getName()); code.append(s); // å¦‚æœæ–¹æ³•è¿”å›å€¼ç±»å‹évoidï¼Œåˆ™ç”Ÿæˆreturnè¯­å¥ if (!rt.equals(void.class)) &#123; code.append(\"\\nreturn \"); &#125; // ç”Ÿæˆ extensionæ‰©å±•å¯¹è±¡ è°ƒç”¨ç›®æ ‡æ–¹æ³•é€»è¾‘ï¼Œå½¢å¦‚ï¼š extension.æ–¹æ³•å(arg0, arg2, ..., argN); s = String.format(\"extension.%s(\", method.getName()); code.append(s); // ç”Ÿæˆextensionè°ƒç”¨æ–¹æ³•ä¸­çš„å‚æ•° æ‹¼æ¥ï¼Œæ³¨æ„å’Œç”Ÿæˆæ–¹æ³•ç­¾åçš„å‚æ•°åä¿æŒä¸€ç›´ for (int i = 0; i &lt; pts.length; i++) &#123; if (i != 0) &#123; code.append(\", \"); &#125; code.append(\"arg\").append(i); &#125; code.append(\");\"); &#125; //------------------------------------------- 8 ç”Ÿæˆæ–¹æ³•ç­¾åï¼ŒåŒ…è£¹æ–¹æ³•ä½“å†…å®¹ ---------------------------------------/ // ç”Ÿæˆæ–¹æ³•ç­¾åï¼Œæ ¼å¼ï¼špublic + è¿”å›å€¼å…¨é™å®šå + æ–¹æ³•å +( codeBuilder.append(\"\\npublic \").append(rt.getCanonicalName()).append(\" \").append(method.getName()).append(\"(\"); // ç”Ÿæˆæ–¹æ³•ç­¾åçš„å‚æ•°åˆ—è¡¨ for (int i = 0; i &lt; pts.length; i++) &#123; if (i &gt; 0) &#123; codeBuilder.append(\", \"); &#125; codeBuilder.append(pts[i].getCanonicalName()); codeBuilder.append(\" \"); codeBuilder.append(\"arg\").append(i); &#125; codeBuilder.append(\")\"); // ç”Ÿæˆå¼‚å¸¸æŠ›å‡ºä»£ç  if (ets.length &gt; 0) &#123; codeBuilder.append(\" throws \"); for (int i = 0; i &lt; ets.length; i++) &#123; if (i &gt; 0) &#123; codeBuilder.append(\", \"); &#125; codeBuilder.append(ets[i].getCanonicalName()); &#125; &#125; // æ–¹æ³•å¼€å§‹ç¬¦å· codeBuilder.append(\" &#123;\"); // åŒ…æ‹¬æ–¹æ³•ä½“å†…å®¹ codeBuilder.append(code.toString()); // è¿½åŠ æ–¹æ³•ç»“æŸç¬¦å· codeBuilder.append(\"\\n&#125;\"); &#125; // è¿½åŠ ç±»çš„ç»“æŸç¬¦å·ï¼Œç”Ÿæˆè‡ªé€‚åº”æ‰©å±•ç±»ç»“æŸ codeBuilder.append(\"\\n&#125;\"); if (logger.isDebugEnabled()) &#123; logger.debug(codeBuilder.toString()); &#125; return codeBuilder.toString(); &#125; ä¸Šé¢çš„ä»£ç é€»è¾‘å°±ä¸€ä¸ªä»»åŠ¡ï¼Œä½¿ç”¨å­—ç¬¦ä¸²æ‹¼æ¥ä¸€ä¸ªè‡ªé€‚åº”æ‰©å±•ç±»ä¸²ï¼Œæ¢³ç†å‡ºæ¥åå¹¶æ²¡æœ‰é‚£ä¹ˆå¤æ‚ï¼Œå…¶å®å°±æ˜¯æŒ‰ç…§ç¼–å†™ä¸€ä¸ªç±»çš„æ­¥éª¤è¿›è¡Œæ‹¼æ¥çš„ã€‚å¦‚æœéè¦è¯´å¤æ‚çš„è¯ï¼Œé‚£ä¹ˆå°±æä½“ç°åœ¨æ‹¼æ¥æ‰©å±•åçš„é€»è¾‘ä»£ç ä¸­ï¼Œå› ä¸ºæƒ…å†µéå¸¸å¤šï¼Œèƒ–å‹ä»¬å¯ä»¥å¤šè°ƒè¯•å¤šå½’ç±»ã€‚æƒ³è¦è§‚å¯Ÿç”Ÿæˆçš„è‡ªé€‚åº”æ‰©å±•ç±»æœ‰ä¸¤ç§åŠæ³•ï¼Œæ—¥å¿—çº§åˆ«è®¾ç½®æˆdebugæ˜¯ä¸€ç§ç®€å•ç²—æš´çš„æ–¹å¼ï¼Œè¿˜å¯ä»¥ä½¿ç”¨åç¼–è¯‘å·¥å…·è¿›è¡ŒæŸ¥çœ‹ã€‚ æ€»ç»“æœ¬ç¯‡æ–‡ç« ä¸»è¦åˆ†æäº†è‡ªåŠ¨ç”Ÿæˆçš„è‡ªé€‚åº”æ‰©å±•ç±»çš„åŸç†ï¼Œä»¥åŠè¯¦ç»†åˆ†æäº†ç”Ÿæˆä¸€ä¸ªè‡ªé€‚åº”æ‰©å±•ç±»çš„è¿‡ç¨‹ï¼Œæ€»ä½“æ¥è¯´è¿˜æ˜¯å¾ˆå¤æ‚çš„ã€‚è‡³äºä¸ºä»€ä¹ˆä¸ç›´æ¥ä½¿ç”¨ä»£ç†çš„æ–¹å¼ç”Ÿæˆè‡ªé€‚åº”æ‰©å±•ç±»ï¼Œä¸»è¦çš„åŸå› æ˜¯ä»£ç†æ–¹å¼æ•ˆç‡å¤ªä½ï¼Œæ›´è¯¦ç»†çš„å¯ä»¥å‚è€ƒæ¢é£å¤§ä½¬çš„åšå®¢ åŠ¨æ€ä»£ç†æ–¹æ¡ˆæ€§èƒ½å¯¹æ¯”ã€‚è‡ªé€‚åº”æ‰©å±•è¿˜æ²¡ç»“æŸï¼Œæˆ‘ä»¬è™½ç„¶æœ‰äº†ä¸€ä¸ªè‡ªé€‚åº”æ‰©å±•ç±»çš„å­—ç¬¦ä¸²ï¼Œä½†æ˜¯è¿˜éœ€è¦å¯¹è¿™ä¸ªå­—ç¬¦ä¸²è¿›è¡Œç¼–è¯‘å¤„ç†æˆClassï¼Œè¿™æ ·æ‰èƒ½åˆ›å»ºä¸€ä¸ªå¯¹è±¡è‡ªé€‚åº”æ‰©å±•å¯¹è±¡ï¼Œä¸‹ä¸€ç¯‡æ–‡ç« ä¸­æˆ‘ä»¬å°±æ¥åˆ†ædubboçš„åŠ¨æ€ç¼–è¯‘åŸç†ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"SPI","slug":"SPI","permalink":"https://gentryhuang.com/tags/SPI/"}]},{"title":"Dubboæºç åˆ†æ - Dubbo SPI","slug":"rpc/spiæœºåˆ¶ä¹‹dubbo","date":"2020-03-12T16:00:00.000Z","updated":"2021-02-26T01:46:13.504Z","comments":false,"path":"posts/5d81f464/","link":"","permalink":"https://gentryhuang.com/posts/5d81f464/","excerpt":"","text":"æ¦‚è¿°Dubboå¹¶æœªä½¿ç”¨jdkæ ‡å‡†çš„SPIæœºåˆ¶ï¼Œè€Œæ˜¯å¯¹å…¶è¿›è¡Œäº†å¢å¼ºï¼Œä¼˜åŒ–äº†æ€§èƒ½é—®é¢˜å¹¶ä¸”ç›¸æ¯”jdk spiæ›´åŠ å¥å£®ã€‚ Dubbo SPI å¯¹ JDK SPIçš„æ”¹è¿› JDK æ ‡å‡†çš„ SPI ä¼šä¸€æ¬¡æ€§å®ä¾‹åŒ–æ‰©å±•ç‚¹æ‰€æœ‰å®ç°ï¼Œå¦‚æœæœ‰æ‰©å±•å®ç°åˆå§‹åŒ–å¾ˆè€—æ—¶ï¼Œä½†å¦‚æœæ²¡ç”¨ä¸Šä¹ŸåŠ è½½ï¼Œä¼šå¾ˆæµªè´¹èµ„æºï¼Œè€Œdubboå¯ä»¥é€‰æ‹©æ€§å®ä¾‹åŒ–ã€‚ å¦‚æœæ‰©å±•ç‚¹åŠ è½½å¤±è´¥ï¼Œè¿æ‰©å±•ç‚¹çš„åç§°éƒ½æ‹¿ä¸åˆ°äº†ã€‚æ¯”å¦‚ï¼šJDKæ ‡å‡†çš„ ScriptEngineï¼Œé€šè¿‡ getName() è·å–è„šæœ¬ç±»å‹çš„åç§°ï¼Œä½†å¦‚æœRubyScriptEngine å› ä¸ºæ‰€ä¾èµ–çš„ jruby.jar ä¸å­˜åœ¨ï¼Œå¯¼è‡´ RubyScriptEngine ç±»åŠ è½½å¤±è´¥ï¼Œè¿™ä¸ªå¤±è´¥åŸå› è¢«åƒæ‰äº†ï¼Œå’Œ ruby å¯¹åº”ä¸èµ·æ¥ï¼Œå½“ç”¨æˆ·æ‰§è¡Œ ruby è„šæœ¬æ—¶ä¼šæŠ¥ä¸æ”¯æŒrubyï¼Œè€Œä¸æ˜¯çœŸæ­£å¤±è´¥çš„åŸå› ã€‚ å¯¹ JDK SPI é…ç½®æ–‡ä»¶è¿›è¡Œäº†æ‰©å±•å’Œä¿®æ”¹ï¼Œå…¼å®¹äº† JDK SPI é…ç½®ã€‚ å¢åŠ äº†å¯¹æ‰©å±•ç‚¹ IoC å’Œ AOP çš„æ”¯æŒï¼Œä¸€ä¸ªæ‰©å±•ç‚¹å¯ä»¥ç›´æ¥ setter æ³¨å…¥å…¶å®ƒæ‰©å±•ç‚¹ã€‚ åŸå§‹jdk spi ä¸æ”¯æŒç¼“å­˜ï¼Œdubboè®¾è®¡äº†å¤šç»´åº¦ç¼“å­˜ï¼Œæé«˜äº†æ¡†æ¶çš„æ€§èƒ½ã€‚ SPI æ ¸å¿ƒæ¦‚å¿µ æ‰©å±•ç‚¹ï¼šé€šè¿‡ SPI æœºåˆ¶æŸ¥æ‰¾å¹¶åŠ è½½å®ç°çš„æ¥å£æˆä¸ºæ‰©å±•ç‚¹ï¼Œä¹Ÿå«åšæ‰©å±•æ¥å£ æ‰©å±•(ç‚¹)å®ç°ï¼šå®ç°äº†æ‰©å±•ç‚¹çš„å®ç°ç±» Dubbo SPI é…ç½®è§„èŒƒ spié…ç½®æ–‡ä»¶è·¯å¾„ 123META-INF&#x2F;dubbo&#x2F;internal : ä¸»è¦ç”¨äº Dubbo å†…éƒ¨æä¾›çš„æ‹“å±•ç‚¹å®ç°META-INF&#x2F;dubbo : ä¸»è¦ç”¨äºè‡ªå®šä¹‰æ‰©å±•ç‚¹å®ç°META-INF&#x2F;services : ç”¨äºå…¼å®¹jdkçš„spi è¯´æ˜: ä¸Šé¢çš„ SPI é…ç½®æ–‡ä»¶è·¯å¾„æ˜¯ç§è§„èŒƒï¼Œå®é™…ä¸Šåœ¨ä½¿ç”¨çš„æ—¶å€™å†™åœ¨å“ªä¸ªæ–‡ä»¶ä¸‹éƒ½å¯ä»¥è¢«åŠ è½½åˆ°ï¼Œä½†æ˜¯å®é™…å¼€æ”¾ç§æœ€å¥½æŒ‰ç…§è§„èŒƒé…ç½®ã€‚ spié…ç½®æ–‡ä»¶åç§° 1æ‰©å±•ç‚¹å…¨è·¯å¾„å æ–‡ä»¶å†…å®¹ 12key&#x3D;valueå½¢å¼ï¼Œå¤šä¸ªä½¿ç”¨æ¢è¡Œç¬¦åˆ†å‰²ï¼Œè¿™æ˜¯Dubboé…ç½®çš„æ–¹å¼valueå½¢å¼ï¼Œæ²¡æœ‰æŒ‡å®šæ‰©å±•åï¼Œè¿™æ˜¯jdké…ç½®æ–¹å¼ï¼ŒDubboè¿›è¡Œäº†å…¼å®¹ï¼Œä¼šè‡ªåŠ¨ä¸ºæ‰©å±•å®ç°ç±»ç”Ÿæˆé»˜è®¤çš„æ‰©å±•å è¯´æ˜: Dubbo SPI é€šè¿‡é”®å€¼å¯¹çš„æ–¹å¼è¿›è¡Œé…ç½®ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥æŒ‰éœ€å®ä¾‹åŒ–æ‰©å±•ç‚¹çš„å®ç°ï¼Œè€Œä¸æ˜¯ä¸€æ¬¡å®ä¾‹åŒ–æ‰€æœ‰çš„æ‰©å±•å®ç°ç±»ã€‚æ­¤å¤–ï¼Œå¼‚å¸¸ä¿¡æ¯æ›´åŠ å‡†ç¡®ï¼Œä¾¿äºå®šä½é—®é¢˜ï¼Œå¦‚åœ¨ Dubbo SPI æŠ›å‡ºå¼‚å¸¸æ—¶ï¼Œä¸€èˆ¬ä¼šæºå¸¦æ‰©å±•åä¿¡æ¯è€Œä¸æ˜¯ç›´æ¥æŠ›å‡ºæ— æ³•åŠ è½½æ‰©å±•å®ç°ç±»çš„å¼‚å¸¸ä¿¡æ¯ã€‚ åŠ è½½æ‰©å±•å®ç°1Dubboä½¿ç”¨ExtensionLoaderåŠ è½½æŒ‡å®šå®ç°ç±»ï¼ŒDubbo SPI çš„é€»è¾‘å‡ ä¹éƒ½å°è£…åœ¨è¯¥ç±»ä¸­ã€‚ ç¤ºä¾‹å‰é¢ç®€å•ä»‹ç»äº†Dubbo SPIæœºåˆ¶ï¼Œä¸‹é¢æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªä¾‹å­æ¥æ¼”ç¤ºDubbo SPIçš„ç®€å•ç”¨æ³•ã€‚æ‰©å±•ç‚¹æ¥å£åŠå®ç°å¤ç”¨ spiæœºåˆ¶ä¹‹jdkç¤ºä¾‹ ä¸­ä»£ç ï¼ŒåŒºåˆ«æ˜¯Dubbo SPIçš„æ¥å£ä½¿ç”¨@SPIæ³¨è§£è¿›è¡Œæ ‡æ³¨ã€‚ å®šä¹‰æ‰©å±•æ¥å£ï¼Œä½¿ç”¨@SPIæ³¨è§£è¿›è¡Œæ ‡æ³¨ 123456789package com.alibaba.dubbo.spi;@SPIpublic interface Command &#123; /** * æ‰§è¡Œæ–¹æ³• */ void execute();&#125; åœ¨META-INF/dubboæ–‡ä»¶ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œåç§°ä¸ºCommandçš„å…¨è·¯å¾„å com.alibaba.dubbo.spi.Commandã€‚ é…ç½®å†…å®¹ä¸ºæ‰©å±•å®ç°ç±»åŠå…¶æ‰©å±•åï¼Œå¦‚ä¸‹ï¼š 12start&#x3D;com.alibaba.dubbo.spi.impl.StartCommandshutdown&#x3D;com.alibaba.dubbo.spi.impl.ShutdownCommand å‡†å¤‡å°±ç»ªåï¼Œæœ€åå†™æµ‹è¯•ä»£ç ï¼Œå¦‚ä¸‹ï¼š 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; // ExtensionLoaderæ˜¯dubboæä¾›çš„ï¼Œç”¨æ¥åŠ è½½æ‹“å±•å®ç°ç±» ExtensionLoader&lt;Command&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Command.class); // åŠ è½½æŒ‡å®šæ‰©å±•åå¯¹åº”çš„æ‰©å±•å®ç°å¯¹è±¡ï¼ˆè·å–çš„æ—¶å€™ä¼šè¿›è¡Œå®ä¾‹åŒ–ï¼‰ Command startCommand = extensionLoader.getExtension(\"start\"); startCommand.execute(); Command shutdownCommand = extensionLoader.getExtension(\"shutdown\"); shutdownCommand.execute(); &#125;&#125; æµ‹è¯•ç»“æœå¦‚ä¸‹ï¼š 1234start commandshut down commandProcess finished with exit code 0 ç®€å•è¯´æ˜å’Œæ¼”ç¤ºDubbo SPIåï¼Œæˆ‘ä»¬å¯¹Dubbo SPIæœ‰äº†ä¸€å®šçš„è®¤è¯†ï¼Œä½¿ç”¨èµ·æ¥è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œæ¥ä¸‹æ¥è¿›å…¥æºç åˆ†æé˜¶æ®µï¼Œè®©æˆ‘ä»¬ä¸€èµ·å»çœ‹çœ‹Dubboåº•å±‚æ˜¯æ€ä¹ˆåŠ è½½å’Œé€‰æ‹©æ‰©å±•å®ç°çš„ã€‚ Dubbo SPI æºç åˆ†æè¿›è¡Œæºç åˆ†æä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸‹Dubbo SPIæ•´ä½“çš„ä»£ç ç»“æ„ï¼Œç„¶åå¯¹æ ¸å¿ƒæ³¨è§£å’Œç±»è¿›è¡Œè¯´æ˜ã€‚ ä»£ç ç»“æ„ æ‰©å±•ç‚¹ SPI æ³¨è§£æ‰©å±•ç‚¹æ¥å£æ ‡è¯†ï¼ŒDubboçš„æ‰©å±•ç‚¹å¿…é¡»æ ‡æ³¨è¯¥æ³¨è§£ï¼Œå¦åˆ™åœ¨æ‰§è¡ŒSPIé€»è¾‘æ—¶æ¡†æ¶ä¼šæŠ¥å¼‚å¸¸ã€‚ 1234567891011@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)public @interface SPI &#123; /** * @return ç¼ºçœæ‰©å±•å */ String value() default \"\";&#125; SPIæ³¨è§£çš„valueå±æ€§æ˜¯ç”¨æ¥æŒ‡å®šæ‰©å±•ç‚¹çš„é»˜è®¤æ‰©å±•åï¼Œå¦‚Protocolæ‰©å±•æ¥å£ï¼š 12@SPI(\"dubbo\")public interface Protocol &#123;//...&#125; // dubboå¯¹åº”çš„æ‰©å±•å®ç°ç±»å°±æ˜¯DubboProtocolï¼Œå³Protocolé»˜è®¤çš„æ‰©å±•å®ç°ç±» æ‰©å±•ç‚¹ Adaptive æ³¨è§£è¯¥æ³¨è§£ç”¨æ¥å®ç°é€‚é…å™¨åŠŸèƒ½ï¼Œæ ‡æ³¨è¯¥æ³¨è§£çš„å¯èƒ½æ—¶ç±»æˆ–æ‰©å±•ç‚¹ä¸­çš„æ–¹æ³•ã€‚å‰è€…ä¸€èˆ¬ä¸å®ç°ä»»ä½•å…·ä½“çš„åŠŸèƒ½ä»…ç”¨æ¥é€‚é…æ‰©å±•æ¥å£çš„å®ç°ï¼Œå¦‚ AdaptiveExtensionFactory ç”¨æ¥é€‚é… ExtensionFactory çš„ SpiExtensionFactory å’Œ SpringExtensionFactory è¿™ä¸¤ç§å®ç°ï¼Œå®ƒä¼šæ ¹æ®è¿è¡Œæ—¶çš„çŠ¶æ€é€‰æ‹©åˆé€‚çš„ ExtensionFactory çš„å®ç°ã€‚åè€…ä¼šåŠ¨æ€ç”Ÿæˆé€‚é…å™¨ç±»ï¼Œç”Ÿæˆçš„è¿™ä¸ªé€‚é…å™¨ç±»çš„é€»è¾‘åŒæ ·æ˜¯åœ¨è¿è¡Œæ—¶é€‰æ‹©åˆé€‚çš„æ‰©å±•å®ç°ã€‚ 12345678910111213141516171819@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface Adaptive &#123; /** * æ ¹æ®URLçš„Keyè·å–å¯¹åº”çš„Valueä½œä¸ºè‡ªé€‚åº”æ‹“å±•åã€‚æ¯”å¦‚ï¼Œ&lt;code&gt;String[] &#123;\"key1\", \"key2\"&#125;&lt;/code&gt;ï¼Œè¡¨ç¤º * &lt;ul&gt; * &lt;li&gt;å…ˆåœ¨URLä¸Šæ‰¾key1çš„Valueä½œä¸ºè‡ªé€‚åº”æ‹“å±•åï¼› * &lt;li&gt;key1æ²¡æœ‰valueï¼Œåˆ™ä½¿ç”¨key2çš„valueä½œä¸ºè‡ªé€‚åº”æ‹“å±•åã€‚ * &lt;li&gt;key2æ²¡æœ‰valueï¼Œå°±ä½¿ç”¨ç¼ºçœçš„æ‰©å±•ï¼Œå³ï¼š å¦‚æœ&#123;@link URL&#125;è¿™äº›Keyéƒ½æ²¡æœ‰valueï¼Œä½¿ç”¨ç¼ºçœçš„æ‰©å±•ï¼ˆåœ¨æ¥å£çš„&#123;@link SPI&#125;ä¸­è®¾å®šçš„å€¼ï¼‰ * &lt;li&gt;å¦‚æœæ²¡æœ‰è®¾ç½®ç¼ºçœæ‰©å±•åæˆ–è€…ç¼ºçœæ‰©å±•åä¹Ÿæ²¡æœ‰valueï¼Œåˆ™æ–¹æ³•è°ƒç”¨ä¼šæŠ›å‡º&#123;@link IllegalStateException&#125;ã€‚ * &lt;/ul&gt; * æ³¨æ„ï¼šå¦‚æœæ²¡æœ‰ä½¿ç”¨Adaptiveæ³¨è§£æŒ‡å®šæ‰©å±•åï¼Œæ‰©å±•æ¥å£ä¹Ÿæ²¡æœ‰æŒ‡å®š@SPIé»˜è®¤å€¼ï¼Œåˆ™åœ¨åŠ è½½æ‰©å±•å®ç°çš„æ—¶å€™dubboä¼šè‡ªåŠ¨æŠŠæ‰©å±•æ¥å£åç§°æ ¹æ®é©¼å³°å¤§å°å†™åˆ†å¼€ï¼Œå¹¶ä½¿ç”¨ '.' ç¬¦å·è¿æ¥èµ·æ¥ï¼Œ * ä»¥æ­¤åç§°ä½œä¸ºé»˜è®¤æ‰©å±•åã€‚å¦‚ï¼šSimpleExt -&gt; simple.ext * * @return parameter key names in URL */ String[] value() default &#123;&#125;;&#125; ä¸€ä¸ªæ‹“å±•æ¥å£ï¼Œåœ¨æ¡†æ¶ä¸­åŒæ—¶åªèƒ½å­˜åœ¨ä¸€ä¸ª Adaptive æ‹“å±•å®ç°ç±»ï¼Œå¯èƒ½æ˜¯å›ºå®šçš„æ‰©å±•å®ç°ç±»ï¼Œä¹Ÿå¯èƒ½æ˜¯è‡ªåŠ¨ç”Ÿæˆã€ç¼–è¯‘å¾—åˆ°çš„æ‰©å±•å®ç°ç±»ã€‚@Adaptive æ³¨è§£ï¼Œå¯æ·»åŠ ç±»æˆ–æ–¹æ³•ä¸Šï¼Œåˆ†åˆ«ä»£è¡¨äº†ä¸¤ç§ä¸åŒçš„ä½¿ç”¨æ–¹å¼ã€‚ç¬¬ä¸€ç§ï¼Œæ ‡è®°åœ¨ç±»ä¸Šï¼ˆå±äºè£…é¥°ç±»ï¼‰ï¼Œæ•´ä¸ªå®ç°ç±»ä¼šä½œä¸ºè‡ªé€‚åº”æ‰©å±•ç±»ï¼ŒDubboä¸ä¼šä¸ºè¯¥ç±»ç”Ÿæˆä»£ç†ç±»ï¼Œå®ƒä¸»è¦ç”¨äºå›ºå®šå·²çŸ¥ç±»ã€‚ç›®å‰ Dubbo é¡¹ç›®é‡Œï¼Œåªæœ‰ ExtensionFactory æ‹“å±•çš„å®ç°ç±» AdaptiveExtensionFactory å’ŒCompiler æ‹“å±•çš„å®ç°AdaptiveCompilerè¿™ä¹ˆä½¿ç”¨ã€‚ç¬¬äºŒç§ï¼Œæ ‡è®°åœ¨æ‰©å±•æ¥å£çš„æ–¹æ³•ä¸Šï¼Œä»£è¡¨è‡ªåŠ¨ç”Ÿæˆã€ç¼–è¯‘ä¸€ä¸ªè¯¥æ¥å£çš„åŠ¨æ€Adaptiveæ‹“å±•å®ç°ç±»ï¼ˆå±äºåŠ¨æ€ä»£ç†ç±»ï¼Œå¦‚Protocol$Adaptiveï¼‰ï¼Œä¸€èˆ¬è¯¥ç±»æ²¡æœ‰å®é™…çš„å·¥ä½œï¼Œåªæ˜¯æ ¹æ®å‚æ•°å’Œè¿è¡ŒçŠ¶æ€åŠ è½½å…¶ä»–çš„æ‰©å±•å®ç°æ¥å®Œæˆæœ€ç»ˆçš„å·¥ä½œã€‚ æ‰©å±•ç‚¹ Activate æ³¨è§£123456789101112131415161718192021222324252627282930313233343536@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface Activate &#123; /** * groupè¿‡æ»¤æ¡ä»¶ã€‚åœ¨è°ƒç”¨&#123;@link ExtensionLoader#getActivateExtension(URL, String, String)&#125; æ–¹æ³•æ—¶ï¼Œå¦‚æœä¼ å…¥çš„groupå‚æ•°ç¬¦åˆè¯¥æ³¨è§£è®¾ç½®çš„groupå±æ€§å€¼ï¼Œåˆ™åŒ¹é…ã€‚ * å³ ä¿®é¥°çš„å®ç°ç±»æ˜¯åœ¨ Provider ç«¯è¢«æ¿€æ´»è¿˜æ˜¯åœ¨ Consumer ç«¯è¢«æ¿€æ´» */ String[] group() default &#123;&#125;; /** * keyè¿‡æ»¤æ¡ä»¶ã€‚åœ¨è°ƒç”¨&#123;@link ExtensionLoader#getActivateExtension(URL, String, String)&#125; æ–¹æ³•æ—¶ï¼Œå¦‚æœurlä¸­çš„å‚æ•°ä¸­å­˜åœ¨è¯¥æ³¨è§£è®¾ç½®çš„keyå€¼ï¼Œåˆ™æ¿€æ´»ã€‚ */ String[] value() default &#123;&#125;; /** * æ’åºå±æ€§ * * @return extension list which should be put before the current one */ String[] before() default &#123;&#125;; /** * æ’åºå±æ€§ * * @return extension list which should be put after the current one */ String[] after() default &#123;&#125;; /** * æ’åºå±æ€§ * * @return absolute ordering info */ int order() default 0;&#125; è¯¥æ³¨è§£ç”¨äºè®¾ç½®æ‰©å±•å®ç°ç±»è¢«è‡ªåŠ¨æ¿€æ´»çš„åŠ è½½æ¡ä»¶ï¼Œå¦‚ï¼šè¿‡æ»¤å™¨æ‰©å±•ç‚¹æœ‰å¤šä¸ªå®ç°ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨è¯¥æ³¨è§£è®¾ç½®æ¿€æ´»æ¡ä»¶ï¼Œåœ¨è·å–è‡ªåŠ¨æ¿€æ´»æ‰©å±•å®ç°æ—¶éœ€è¦ç¬¦åˆæ¡ä»¶æ‰èƒ½è·å–åˆ°ã€‚æ¡†æ¶é€šè¿‡ExtensionLoader#getActivateExtensionæ–¹æ³•è·å¾—æ¿€æ´»æ¡ä»¶çš„æ‰©å±•å®ç°é›†åˆã€‚ ExtensionLoaderDubboçš„æ‰©å±•åŠ è½½å™¨ï¼ŒåŠŸèƒ½ç±»ä¼¼äº JDK SPI ä¸­çš„ ServiceLoaderã€‚Dubbo SPI çš„ç›¸å…³é€»è¾‘å‡ ä¹éƒ½è¢«å°è£…åœ¨è¯¥ç±»ä¸­ï¼Œè¯¥ç±»æ˜¯ Dubbo SPI çš„ æ ¸å¿ƒã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class ExtensionLoader&lt;T&gt; &#123; //========================================= ç±»å±æ€§ï¼Œæ‰€æœ‰ExtensionLoaderå¯¹è±¡å…±äº« ================================================ /** * dubboæ‰©å±•ç‚¹ç›®å½• ï¼Œè¯¥ç›®å½•æ˜¯ä¸ºäº†å…¼å®¹jdkçš„spi */ private static final String SERVICES_DIRECTORY = \"META-INF/services/\"; /** * dubboæ‰©å±•ç‚¹ç›®å½•ï¼Œä¸»è¦ç”¨äºè‡ªå®šä¹‰æ‰©å±•ç‚¹å®ç° */ private static final String DUBBO_DIRECTORY = \"META-INF/dubbo/\"; /** * dubboæ‰©å±•ç‚¹ç›®å½•ï¼Œç”¨äº Dubbo å†…éƒ¨æä¾›çš„æ‹“å±•ç‚¹å®ç° */ private static final String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + \"internal/\"; /** * æ‰©å±•ç‚¹å®ç°åçš„åˆ†éš”ç¬¦ æ­£åˆ™è¡¨è¾¾å¼ï¼Œå¤šä¸ªæ‰©å±•ç‚¹åä¹‹é—´ä½¿ç”¨ ',' è¿›è¡Œåˆ†å‰² */ private static final Pattern NAME_SEPARATOR = Pattern.compile(\"\\\\s*[,]+\\\\s*\"); /** * æ‰©å±•ç‚¹åŠ è½½å™¨é›†åˆ * key: æ‹“å±•ç‚¹æ¥å£ * value: æ‰©å±•ç‚¹åŠ è½½å™¨ã€‚ ä¸€ä¸ªæ‰©å±•ç‚¹æ¥å£å¯¹åº”ä¸€ä¸ª æ‰©å±•ç‚¹åŠ è½½å™¨ */ private static final ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = new ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;(); /** * æ‰©å±•ç‚¹å®ç°ç±»é›†åˆ * key: æ‰©å±•ç‚¹å®ç°ç±» * value: æ‰©å±•ç‚¹å®ç°å¯¹è±¡ * è¯´æ˜ï¼š * ä¸€ä¸ªæ‰©å±•ç‚¹é€šè¿‡å¯¹åº”çš„ExtensionLoaderå»åŠ è½½å®ƒçš„å…·ä½“å®ç°ï¼Œè€ƒè™‘åˆ°æ€§èƒ½å’Œèµ„æºé—®é¢˜ï¼Œåœ¨åŠ è½½æ‹“å±•é…ç½®åä¸ä¼šç«‹é©¬è¿›è¡Œæ‰©å±•å®ç°çš„å¯¹è±¡çš„åˆå§‹åŒ–ï¼Œè€Œæ˜¯å…ˆæŠŠæ‰©å±•é…ç½®å­˜èµ·æ¥ã€‚ * ç­‰åˆ°çœŸæ­£ä½¿ç”¨å¯¹åº”çš„æ‹“å±•å®ç°æ—¶æ‰è¿›è¡Œæ‰©å±•å®ç°çš„å¯¹è±¡çš„åˆå§‹åŒ–ï¼Œåˆå§‹åŒ–åä¹Ÿè¿›è¡Œç¼“å­˜ã€‚å³ï¼š * 1 ç¼“å­˜åŠ è½½çš„æ‹“å±•é…ç½® * 2 ç¼“å­˜åˆ›å»ºçš„æ‹“å±•å®ç°å¯¹è±¡ */ private static final ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = new ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;(); // ============================== å®ä¾‹å±æ€§ ï¼Œæ¯ä¸ªExtensionLoaderå¯¹è±¡ç‹¬æœ‰ ==================================================== /** * æ‰©å±•ç‚¹ï¼Œå¦‚ï¼šProtocol */ private final Class&lt;?&gt; type; /** * æ‰©å±•ç‚¹å®ç°å·¥å‚ï¼Œç”¨äºå‘æ‰©å±•å¯¹è±¡ä¸­æ³¨å…¥ä¾èµ–å±æ€§ï¼Œä¸€èˆ¬é€šè¿‡è°ƒç”¨ &#123;@link #injectExtension(Object)&#125; æ–¹æ³•è¿›è¡Œå®ç°ã€‚ * ç‰¹åˆ«è¯´æ˜ï¼š * é™¤äº†ExtensionFactoryæ‰©å±•æ¥å£ï¼Œå…¶ä½™çš„æ‰€æœ‰æ‰©å±•æ¥å£çš„ExtensionLoaderå¯¹è±¡éƒ½ä¼šæ‹¥æœ‰ä¸€ä¸ªè‡ªå·±çš„æ‰©å±•å·¥å‚ï¼Œå³ objectFactory = AdaptiveExtensionFactoryï¼› * @see ExtensionLoader æ„é€ æ–¹æ³• */ private final ExtensionFactory objectFactory; /** * æ‰©å±•ç‚¹å®ç°ç±» åˆ° æ‰©å±•å çš„æ˜ å°„ * å¦‚ï¼š * dubbo=dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol ===&gt; &lt;DubboProtocol,dubbo&gt; */ private final ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = new ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;(); /** * æ‰©å±•å åˆ° æ‰©å±•ç‚¹å®ç°ç±» çš„æ˜ å°„ * ä¸åŒ…æ‹¬ä»¥ä¸‹ä¸¤ç§ç±»å‹ï¼š * 1 è‡ªé€‚åº”æ‰©å±•å®ç°ç±»ï¼Œå¦‚ï¼šAdaptiveExtensionFactory * 2 æ‰©å±•ç‚¹çš„Wrapperå®ç°ç±»ï¼Œå¦‚ï¼šProtocolFilterWrapper * å¦‚ï¼š * dubbo=dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol ===&gt; &lt;dubbo,DubboProtocol&gt; */ private final Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = new Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;(); /** * æ‰©å±•å åˆ° @Activateæ³¨è§£ çš„æ˜ å°„ï¼Œ å¦‚ï¼š ContextFilter -&gt; Activate */ private final Map&lt;String, Activate&gt; cachedActivates = new ConcurrentHashMap&lt;String, Activate&gt;(); /** * æ‰©å±•å åˆ° æ‰©å±•ç‚¹å®ç°å¯¹è±¡ çš„æ˜ å°„ * å¦‚ï¼š * dubbo=dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol ===&gt; &lt;dubbo,Holder&lt;DubboProtocolå¯¹è±¡&gt;&gt; */ private final ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = new ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;(); /** * è‡ªé€‚åº”æ‰©å±•å¯¹è±¡ * æ³¨æ„: ä¸€ä¸ªæ‰©å±•ç‚¹æœ€å¤šåªèƒ½æœ‰ä¸€ä¸ªè‡ªé€‚åº”æ‰©å±•å¯¹è±¡ï¼Œ&gt; 1 æ¡†æ¶å°±ä¼šæŠ¥é”™ */ private final Holder&lt;Object&gt; cachedAdaptiveInstance = new Holder&lt;Object&gt;(); /** * è‡ªé€‚åº”æ‰©å±•å®ç°ç±» &#123;@link #getAdaptiveExtensionClass()&#125; */ private volatile Class&lt;?&gt; cachedAdaptiveClass = null; /** * æ‰©å±•ç‚¹çš„é»˜è®¤æ‰©å±•åï¼Œé€šè¿‡ &#123;@link SPI&#125; æ³¨è§£è·å¾—ï¼Œå³è®°å½•äº† type å¯¹åº”æ‰©å±•æ¥å£ä¸Š @SPI æ³¨è§£çš„ value å€¼ã€‚ */ private String cachedDefaultName; /** * åˆ›å»ºè‡ªé€‚åº”å¯¹è±¡æ—¶å‘ç”Ÿçš„å¼‚å¸¸ -&gt; &#123;@link #createAdaptiveExtension()&#125; */ private volatile Throwable createAdaptiveInstanceError; /** * æ‰©å±•ç‚¹Wrapperå®ç°ç±»é›†åˆï¼Œå¦‚ï¼šProtocolFilterWrapper */ private Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses; /** * æ‰©å±•å åˆ° åŠ è½½å¯¹åº”æ‰©å±•ç±»å‘ç”Ÿçš„å¼‚å¸¸ çš„æ˜ å°„ */ private Map&lt;String, IllegalStateException&gt; exceptions = new ConcurrentHashMap&lt;String, IllegalStateException&gt;(); /** * æ„é€ æ–¹æ³• * è¯´æ˜ï¼š * 1 ä»»æ„ä¸€ä¸ªæ‰©å±•ç‚¹åœ¨è·å–å¯¹åº”çš„ExtensionLoaderæ—¶ï¼Œéƒ½ä¼šå…ˆå°è¯•è·å–å±äºå®ƒçš„ExtensionFactoryè‡ªé€‚åº”æ‰©å±•ï¼Œå³ AdaptiveExtensionFactoryï¼Œ * å®ƒç®¡ç†ç€SpiExtensionFactoryå’ŒSpringExtensionFactoryè¿™ä¸¤å¤§æ‰©å±•ç‚¹å·¥å‚ï¼Œç”¨äºè°ƒç”¨ &#123;@link #injectExtension(Object)&#125;æ–¹æ³•ï¼Œå‘æ‰©å±•å®ç°ä¸­æ³¨å…¥ä¾èµ–å±æ€§ï¼Œ * éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒSpiExtensionFactoryå’ŒSpringExtensionFactoryè·å¾—å¯¹è±¡æ˜¯ä¸åŒçš„ï¼Œå‰è€…è·å–è‡ªé€‚åº”å¯¹è±¡ï¼Œåè€…ä»Springå®¹å™¨ä¸­è·å–å¯¹è±¡ã€‚ * 2 å½“æ‰©å±•ç‚¹æ˜¯ExtensionFactoryæ—¶ï¼Œé‚£ä¹ˆå®ƒçš„å¯¹åº”çš„ExtensionLoaderçš„objectFactory å±æ€§ä¸ºnull * * @param type æ‰©å±•ç‚¹ */ private ExtensionLoader(Class&lt;?&gt; type) &#123; this.type = type; objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()); &#125; // çœç•¥å…¶å®ƒä»£ç ...&#125; åŸºäºæ€§èƒ½çš„è€ƒè™‘ï¼ŒDubbo SPIç›¸æ¯”è¾ƒä¸JDK SPIçš„ä¸€ä¸ªæ”¹è¿›å°±æ˜¯ä½¿ç”¨äº†å¤§é‡çš„ç¼“å­˜ï¼ŒDubbo SPI ç¼“å­˜ä»å¤§çš„æ–¹å‘å¯åˆ†ä¸º ç±»ç¼“å­˜ã€å®ä¾‹ç¼“å­˜ï¼Œè¿™ä¸¤ç§ç¼“å­˜åˆèƒ½æ ¹æ®æ‰©å±•å®ç°ç±»çš„ç§ç±»åˆ†ä¸º æ™®é€šæ‰©å±•ç¼“å­˜ã€åŒ…è£…æ‰©å±•ç¼“å­˜ã€è‡ªé€‚åº”æ‰©å±•ç¼“å­˜ã€‚ ç±»ç¼“å­˜ Dubbo SPIåœ¨æŸ¥è¯¢æ‰©å±•ç±»æ—¶ï¼Œä¼šå…ˆä»ç¼“å­˜ä¸­è·å–ï¼Œå¦‚æœç¼“å­˜ä¸­ä¸å­˜åœ¨ï¼Œå†åŠ è½½é…ç½®æ–‡ä»¶å¹¶åˆ†ç±»ç¼“å­˜ï¼Œæ³¨æ„ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸ä¼šè¿›è¡Œåˆå§‹åŒ–æµç¨‹ã€‚ å®ä¾‹ç¼“å­˜ Dubbo SPIç¼“å­˜çš„Classæ˜¯æŒ‰éœ€è¿›è¡Œå®ä¾‹åŒ–çš„ï¼Œåœ¨æŸ¥è¯¢å®ä¾‹æ—¶ä¼šå…ˆä»ç¼“å­˜ä¸­è·å–ï¼Œå¦‚æœç¼“å­˜ä¸å­˜åœ¨åˆ™ä¼šè¿›è¡ŒåŠ è½½/åˆå§‹åŒ–ï¼Œç„¶åç¼“å­˜èµ·æ¥ã€‚ å¤šç±»å‹çš„æ‰©å±•ç‚¹æ ¹æ®æ‰©å±•å®ç°ç±»çš„ç‰¹ç‚¹åŠç”¨é€”å¯ä»¥åˆ†ä¸ºæ™®é€šæ‰©å±•ç±»ã€è‡ªåŠ¨æ¿€æ´»æ‰©å±•ç±»ã€åŒ…è£…æ‰©å±•ç±»ä»¥åŠè‡ªé€‚åº”æ‰©å±•ç±»ï¼Œå…¶ä¸­è‡ªåŠ¨æ¿€æ´»æ‰©å±•ç±»å±äºæ™®é€šæ‰©å±•ç±»ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé™¤äº†åŠ¨æ€ç¼–è¯‘å¾—åˆ°çš„è‡ªé€‚åº”æ‰©å±•ç±»ï¼Œå…¶å®ƒçš„æ‰€æœ‰æ‰©å±•ç±»éƒ½éœ€è¦åœ¨é…ç½®æ–‡ä»¶ä¸­è¿›è¡Œé…ç½®ï¼Œå¦åˆ™æ¡†æ¶æ— æ³•åŠ è½½åˆ°ã€‚ä¸‹é¢æˆ‘ä»¬ç®€å•è¯´æ˜ä¸‹å„ä¸ªç±»å‹çš„æ‰©å±•ç±»åŠå…¶ç‰¹ç‚¹ã€‚ æ™®é€šæ‰©å±•ç±»å±äºæœ€åŸºç¡€çš„æ‰©å±•ç±»ï¼Œä¸€èˆ¬é€šè¿‡æ‰©å±•åè·å–å¯¹åº”çš„æ‰©å±•å®ç°å°±æ˜¯è¯¥ç±»å‹ã€‚åœ¨é…ç½®æ™®é€šæ‰©å±•ç±»æ—¶éœ€è¦æŒ‡å®šæ‰©å±•åï¼Œä¸æŒ‡å®šä¼šæŒ‰è§„åˆ™è‡ªåŠ¨ç”Ÿæˆï¼Œå› ä¸ºæ™®é€šæ‰©å±•å®ç°éƒ½æ˜¯æ ¹æ®æ‰©å±•åè·å–çš„ã€‚ åŒ…è£…æ‰©å±•ç±»åŒ…æ‹¬æ‰©å±•ç±»åˆå« Wrapperç±»ï¼Œä¸€èˆ¬ä¸æ˜¯æ‰©å±•ç‚¹çš„çœŸæ­£å®ç°ï¼Œä¸»è¦ç”¨æ¥å¯¹æ‰©å±•å®ç°è¿›è¡ŒåŠŸèƒ½å¢å¼ºæˆ–é€šç”¨é€»è¾‘å¤„ç†ã€‚Wrapperç±»æœ‰ä¸¤ä¸ªç‰¹å¾ï¼šå®ç°æ‰©å±•æ¥å£ã€å­˜åœ¨ä¸€ä¸ªå‚æ•°ç±»å‹æ˜¯æ‰©å±•ç‚¹çš„æ„é€ æ–¹æ³•ã€‚Wrapperç±»æ˜¯Dubbo AOPçš„å®ç°ã€‚åœ¨é…ç½®Wrapperç±»æ—¶ï¼Œå¯ä»¥ä¸æŒ‡å®šæ‰©å±•åï¼Œå³ä½¿æŒ‡å®šäº†ä¹Ÿä¸ä¼šä½¿ç”¨ï¼Œä½†ä¸€èˆ¬æƒ…å†µæ ¹æ®Dubbo SPIçš„çº¦å®šè¿˜æ˜¯ç»Ÿä¸€é…ç½®ã€‚ è‡ªé€‚åº”ç±»è‡ªé€‚åº”ç±»éå¸¸çµæ´»ï¼Œä¹Ÿå« Adaptiveç±»ï¼Œæ›´ç›´è§‚çš„ç§°ä¸ºé€‚é…å™¨ç±»ï¼Œæœ‰ä¸¤ç§å®ç°æ–¹å¼ã€‚Adaptiveç±»çš„ä¸¤ä¸ªç‰¹å¾ï¼šå®ç°æ‰©å±•æ¥å£ã€å®ç°ç±»æˆ–æ‰©å±•æ¥å£çš„æ–¹æ³•ä¸Šéœ€è¦ä½¿ç”¨ @Adaptive æ ‡æ³¨ã€‚ç±»ä¸Šæ ‡æ³¨@Adaptiveæ˜¯ä¸€ä¸ªAdaptiveç±»å¯ä»¥ç†è§£ï¼Œä½†æ˜¯æ‰©å±•æ¥å£çš„æ–¹æ³•ä¸Šæ ‡æ³¨@Adaptiveæ€ä¹ˆä¼šæ˜¯ä¸€ä¸ªç±»å‘¢ï¼Ÿæ˜¯å› ä¸ºæ ‡æ³¨åœ¨æ‰©å±•æ¥å£çš„æ–¹æ³•ä¸Šï¼ŒDubbo SPIæœºåˆ¶åœ¨è·å–è‡ªé€‚åº”æ‰©å±•å®ç°ç±»æ—¶ï¼Œå¦‚æœå½“å‰ç¯å¢ƒä¸­æ²¡æœ‰è‡ªé€‚åº”æ‰©å±•å®ç°ç±»å°±ä¼šå¯¹æ ‡æ³¨çš„æ–¹æ³•æ‰€åœ¨æ¥å£è¿›è¡Œjavassistæ“ä½œï¼Œç”Ÿæˆè‡ªé€‚åº”æ‰©å±•ç±»çš„å­—ç¬¦ä¸²ï¼Œç„¶åé€šè¿‡åŠ¨æ€ç¼–è¯‘æˆä¸€ä¸ªè‡ªé€‚åº”ç±»ã€‚@Adaptiveæ ‡æ³¨åœ¨æ‰©å±•æ¥å£çš„æ–¹æ³•ä¸Šçš„æ–¹å¼ï¼Œå¯ä»¥åŠ¨æ€åœ°é€šè¿‡URLä¸­çš„å‚æ•°æ¥ç¡®å®šä½¿ç”¨å“ªä¸ªæ‰©å±•å®ç°ã€‚åœ¨é…ç½®æ–‡ä»¶ä¸­å¯ä»¥ä¸æŒ‡å®šæ‰©å±•åï¼Œå³ä½¿æŒ‡å®šäº†ä¹Ÿä¸ä¼šä½¿ç”¨ï¼Œä½†ä¸€èˆ¬æƒ…å†µæ ¹æ®Dubbo SPIçš„çº¦å®šè¿˜æ˜¯ç»Ÿä¸€é…ç½®ã€‚éœ€è¦æ³¨æ„ï¼Œè‡ªé€‚åº”æ‰©å±•ç±»ä»€ä¹ˆå®é™…å·¥ä½œéƒ½ä¸åšï¼Œåªæ˜¯æ ¹æ®å‚æ•°å’ŒçŠ¶æ€é€‰æ‹©å…¶å®ƒå®ç°è€Œå·²ã€‚ è‡ªåŠ¨æ¿€æ´»ç±»è‡ªåŠ¨æ¿€æ´»ç±»å±äºç‰¹æ®Šçš„æ™®é€šæ‰©å±•ç±»ï¼Œè¯¥ç±»çš„ä¸¤ä¸ªç‰¹å¾ï¼šå®ç°æ¥å£ã€ç±»ä¸Šä½¿ç”¨ @Activate æ ‡æ³¨ã€‚å®ƒæ”¯æŒæŸä¸ªæ‰©å±•ç‚¹éœ€è¦åŒæ—¶æ¿€æ´»å¤šä¸ªå®ç°çš„ç‰¹æ€§ï¼Œå¦‚ Dubboä¸­çš„è¿‡æ»¤å™¨æ‰©å±•ç‚¹ï¼Œéœ€è¦æ¿€æ´»å¤šä¸ªæ‰©å±•å®ç°ã€‚ ExtensionLoader å·¥ä½œæµç¨‹ExtensionLoaderå°è£…äº†Dubbo SPIçš„ä¸»è¦é€»è¾‘ï¼Œé…ç½®çš„åŠ è½½ã€æ‰©å±•ç±»ç¼“å­˜ã€æ‰©å±•å®ç°çš„å®ä¾‹åŒ–åŠç¼“å­˜ã€è‡ªé€‚åº”ç±»çš„ç”Ÿæˆä¸ç¼–è¯‘åŠç¼“å­˜ã€è‡ªé€‚åº”å¯¹è±¡çš„å®ä¾‹åŒ–åŠç¼“å­˜ä»¥åŠDubbo IOC å’Œ AOP çš„å®ç°ç­‰ã€‚è¿™äº›é€»è¾‘ä¸»è¦ä½“ç°åœ¨ä¸‰ä¸ªå…¥å£æ–¹æ³•ä¸­ï¼Œæ¯ä¸ªå…¥å£æ–¹æ³•è·å–åˆ°çš„æ‰©å±•å®ç°ç±»å‹ä¼šæœ‰æ‰€ä¸åŒï¼Œä½†æ˜¯æ–¹æ³•å†…éƒ¨é€»è¾‘æœ‰ç›¸åŒä¹‹å¤„ã€‚ä¸‹é¢æˆ‘ä»¬åˆ†åˆ«ä»ä¸‰ä¸ªå…¥å£æ–¹æ³•å¼€å§‹è¯¦ç»†åˆ†æDubbo SPIçš„æ•´ä¸ªæµç¨‹ï¼Œéœ€è¦è¯´æ˜çš„æ˜¯ï¼ŒgetExtensionæ–¹æ³•æ˜¯æœ€æ ¸å¿ƒçš„æ–¹æ³•ï¼Œå…¶å®ƒä¸¤ä¸ªå…¥å£æ–¹æ³•éƒ½ä¼šä¾èµ–è¯¥æ–¹æ³•ä¸­çš„éƒ¨åˆ†æµç¨‹ï¼Œå› æ­¤æˆ‘ä»¬ä¼šå…ˆåˆ†ægetExtensionæ–¹æ³•ï¼Œåœ¨åˆ†æå…¶å®ƒä¸¤ä¸ªæ–¹æ³•çš„æ—¶å€™æ¶‰åŠé‡å¤çš„æµç¨‹å°±ä¸å†åˆ†æã€‚ getExtension æ–¹æ³•ExtensionLoaderä¸­æœ€æ ¸å¿ƒçš„æ–¹æ³•ï¼Œå› ä¸ºå®ƒå®ç°äº†ä¸€ä¸ªå®Œæ•´çš„æŸ¥è¯¢æ‰©å±•å®ç°çš„é€»è¾‘ã€‚è·å–è¿‡ç¨‹ä¸­çš„æ¯ä¸€æ­¥éƒ½ä¼šå…ˆæ£€æŸ¥ç¼“å­˜æ˜¯å¦å‘½ä¸­ï¼Œå‘½ä¸­å°±ç›´æ¥è¿”å›æˆ–è¿›è¡Œèµ‹å€¼ï¼Œæ²¡æœ‰å‘½ä¸­åˆ™åŠ è½½é…ç½®æ–‡ä»¶ï¼Œç„¶åç¼“å­˜é…ç½®æ–‡ä»¶ä¸­çš„æ‰©å±•å®ç°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940/** * è·å¾—æŒ‡å®šæ‰©å±•åçš„æ‰©å±•å¯¹è±¡ * * @param name æ‰©å±•å * @return */ @SuppressWarnings(\"unchecked\") public T getExtension(String name) &#123; if (name == null || name.length() == 0) &#123; throw new IllegalArgumentException(\"Extension name == null\"); &#125; // å¦‚æœå½“å‰æ‰©å±•åæ˜¯ 'true'ï¼Œå°±è·å–é»˜è®¤çš„æ‰©å±•å¯¹è±¡ if (\"true\".equals(name)) &#123; // æ–¹æ³•ç®€åŒ–ä¸º getExtension(cachedDefaultName) , cacheDefaultNameçš„å€¼å‚è§ @SPIæ³¨è§£ return getDefaultExtension(); &#125; // ä»ç¼“å­˜ä¸­è·å¾—å¯¹åº”çš„æ‰©å±•å¯¹è±¡ Holder&lt;Object&gt; holder = cachedInstances.get(name); if (holder == null) &#123; cachedInstances.putIfAbsent(name, new Holder&lt;Object&gt;()); holder = cachedInstances.get(name); &#125; Object instance = holder.get(); // ç¼“å­˜ä¸­æ²¡æœ‰ï¼Œ åŒé‡æ£€é”è·å–æ‰©å±•åå¯¹åº”æ‰©å±•å®ç°å¯¹è±¡ if (instance == null) &#123; synchronized (holder) &#123; instance = holder.get(); if (instance == null) &#123; // ç¼“å­˜ä¸­ç¡®å®æ²¡æœ‰ï¼Œå°±åˆ›å»ºæ‰©å±•åå¯¹åº”çš„æ‰©å±•å®ç°å¯¹è±¡ instance = createExtension(name); // å°†æ‰©å±•å®ç°å¯¹è±¡æ”¾å…¥ç¼“å­˜ä¸­ holder.set(instance); &#125; &#125; &#125; return (T) instance; &#125; ä¸Šé¢çš„ä»£ç é€»è¾‘æ¯”è¾ƒç®€å•ï¼Œæ ¹æ®æ‰©å±•åè·å–æ‰©å±•å¯¹è±¡ï¼Œå…ˆæ£€æŸ¥ç¼“å­˜ä¸­æ˜¯å¦æœ‰ç›®æ ‡å¯¹è±¡ï¼Œæ²¡æœ‰åˆ™è°ƒç”¨ createExtensionæ–¹æ³•å¼€å§‹åˆ›å»ºæ‰©å±•å¯¹è±¡ã€‚éœ€è¦ç‰¹è¢«è¯´æ˜çš„æ˜¯ï¼Œå¦‚æœnameæ˜¯trueçš„æƒ…å†µï¼ŒåŠ è½½çš„å°±æ˜¯é»˜è®¤æ‰©å±•ç±»ã€‚é‚£ä¹ˆä¸‹é¢æˆ‘ä»¬æ¥åˆ†æcreateExtensionæ–¹æ³•æµç¨‹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * åˆ›å»ºæ‰©å±•åå¯¹åº”çš„æ‰©å±•ç‚¹å®ç°å¯¹è±¡å¹¶ç¼“å­˜åˆ°ç±»å±æ€§çš„é›†åˆä¸­ * * @param name * @return */ @SuppressWarnings(\"unchecked\") private T createExtension(String name) &#123; // è·å–æ‰©å±•åå¯¹åº”çš„æ‰©å±•ç‚¹å®ç°ç±»ï¼Œå…ˆå°è¯•ä»ç¼“å­˜ä¸­å–å¯¹åº”çš„æ‰©å±•å®ç°ç±»ï¼Œæ²¡æœ‰çš„è¯å°±åŠ è½½é…ç½®æ–‡ä»¶ç„¶åå†æ¬¡è·å– Class&lt;?&gt; clazz = getExtensionClasses() .get(name); // æ²¡æœ‰æ‰¾åˆ°æ‰©å±•åå¯¹åº”çš„æ‰©å±•ç‚¹å®ç°ç±»ï¼Œåˆ™æŠ¥é”™ if (clazz == null) &#123; throw findException(name); &#125; try &#123; // ä»ç±»å±æ€§ç¼“å­˜é›†åˆä¸­å°è¯•è·å–æ‰©å±•ç‚¹å®ç°ç±»å¯¹åº”çš„å¯¹è±¡ T instance = (T) EXTENSION_INSTANCES.get(clazz); // å½“ç¼“å­˜ä¸­æ²¡æœ‰ï¼Œå°±é€šè¿‡åå°„åˆ›å»ºæ‰©å±•ç‚¹å®ç°ç±»å¯¹è±¡å¹¶æ”¾å…¥ç¼“å­˜ if (instance == null) &#123; EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance()); instance = (T) EXTENSION_INSTANCES.get(clazz); &#125; // dubbo iocå®ç°ï¼Œè¿›è¡Œsetteræ³¨å…¥ injectExtension(instance); /** * dubbo aopå®ç° * æ³¨æ„ï¼š * å¦‚æœå½“å‰æ‰©å±•ç‚¹å­˜åœ¨ Wrapperç±»ï¼Œé‚£ä¹ˆä»ExtensionLoader ä¸­è·å¾—çš„å®é™…ä¸Šæ˜¯ Wrapper ç±»çš„å®ä¾‹ï¼ŒWrapper æŒæœ‰äº†å®é™…çš„æ‰©å±•ç‚¹å®ç°ç±»ï¼Œå› æ­¤è°ƒç”¨æ–¹æ³•æ—¶è°ƒç”¨çš„æ˜¯Wrapperç±»ä¸­çš„æ–¹æ³•ï¼Œå¹¶éç›´æ¥è°ƒç”¨æ‰©å±•ç‚¹çš„çœŸæ­£å®ç°ã€‚ * å³ å¦‚æœåœ¨Wrapperçš„æ–¹æ³•ä¸­ä¸æ˜¾ç¤ºè°ƒç”¨æ‰©å±•ç‚¹çš„çœŸæ­£å®ç°çš„è¯ï¼Œé‚£ä¹ˆç»“æœä¸€å®šä¸æ˜¯é¢„æœŸçš„ã€‚ */ Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses; if (wrapperClasses != null &amp;&amp; !wrapperClasses.isEmpty()) &#123; for (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123; // åˆ›å»º Wrapper å®ä¾‹ï¼Œç„¶åè¿›è¡Œ setteræ³¨å…¥ä¾èµ–å±æ€§ instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance)); &#125; &#125; return instance; &#125; catch (Throwable t) &#123; throw new IllegalStateException(\"Extension instance(name: \" + name + \", class: \" + type + \") could not be instantiated: \" + t.getMessage(), t); &#125; &#125; createExtension(String name)æ–¹æ³•çš„é€»è¾‘ä»£ç ä¸­å·²ç»è¯¦ç»†æ³¨é‡Šè¯´æ˜ï¼Œä¸‹é¢å°ç»“å…³é”®çš„æ­¥éª¤ï¼š è°ƒç”¨getExtensionClasses()åˆ·æ–°æ‰©å±•ç‚¹å®ç°ç±»é›†åˆ é€šè¿‡åå°„åˆ›å»ºæ‰©å±•ç‚¹çš„æ‰©å±•å¯¹è±¡å¹¶æ”¾å…¥ç±»ç¼“å­˜ä¸­ ä½¿ç”¨Dubboçš„setteræ³¨å…¥å‘æ‰©å±•å¯¹è±¡ä¸­æ³¨å…¥ä¾èµ–å±æ€§ ä½¿ç”¨æ‰©å±•ç‚¹çš„Wrapperå¯¹æ‰©å±•å¯¹è±¡å®ç°Dubboçš„aopå¤„ç†é€»è¾‘ é€šè¿‡æ‰©å±•åè·å–æ‰©å±•å¯¹è±¡æ—¶å¯èƒ½ä¸èƒ½å‘½ä¸­ç¼“å­˜ï¼Œæ­¤æ—¶å°±è¦åˆ›å»ºæ‰©å±•å¯¹è±¡ï¼Œåˆ›å»ºæ‰©å±•å¯¹è±¡éœ€è¦æ‰©å±•å®ç°ç±»ï¼Œä¸‹é¢æˆ‘ä»¬çœ‹ä¸‹Dubboè·å–æ‰©å±•ååˆ°æ‰©å±•å®ç°ç±»çš„æ˜ å°„é›†åˆã€‚ 123456789101112131415161718192021222324/** * è·å–æ‰©å±•ç‚¹å®ç°ç±»çš„é›†åˆï¼Œå…ˆä»ç¼“å­˜ä¸­è·å–ï¼Œæ²¡æœ‰å‘½ä¸­ç¼“å­˜å°±ä»é…ç½®æ–‡ä»¶ä¸­åŠ è½½å¹¶åˆ†ç±»æ”¾å…¥ç¼“å­˜ã€‚ * * @return */ private Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123; // å…ˆä»ç¼“å­˜ä¸­è·å– Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get(); // åŒé‡æ£€é”ï¼Œè·å–æ‰©å±•ç‚¹çš„æ‰©å±•å®ç°ç±»é›†åˆ if (classes == null) &#123; synchronized (cachedClasses) &#123; classes = cachedClasses.get(); if (classes == null) &#123; // åŠ è½½æ‰©å±•ç±» classes = loadExtensionClasses(); // å°† æ‰©å±•ååˆ°æ‰©å±•ç‚¹å®ç°ç±»çš„æ˜ å°„ åŠ å…¥åˆ° cachedClasses é›†åˆä¸­ï¼Œç¼“å­˜èµ·æ¥ cachedClasses.set(classes); &#125; &#125; &#125; return classes; &#125; å¦‚æœç¼“å­˜ä¸èƒ½å‘½ä¸­æ‰©å±•åå¯¹åº”çš„æ‰©å±•å®ç°ç±»å°±åªèƒ½åŠ è½½é…ç½®æ–‡ä»¶åˆ·æ–°æ‰©å±•ç‚¹å®ç°ç±»é›†åˆ,ä¸‹é¢æˆ‘ä»¬çœ‹ä¸‹Dubboæ˜¯å¦‚ä½•åŠ è½½é…ç½®æ–‡ä»¶çš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123; //1ã€ é€šè¿‡@SPIæ³¨è§£è·å¾—æ‰©å±•ç‚¹çš„é»˜è®¤æ‰©å±•åï¼ˆå‰ææ˜¯å½“å‰æ‹“å±•ç‚¹éœ€è¦æœ‰@SPIæ³¨è§£ï¼Œå…¶å®ç¨‹åºæ‰§è¡Œåˆ°è¿™é‡Œtypeä¸€å®šæ˜¯æœ‰@SPIæ³¨è§£çš„ï¼Œå› ä¸ºåœ¨è·å–æ‰©å±•ç‚¹çš„æ‰©å±•åŠ è½½å™¨çš„æ—¶å€™å·²ç»åˆ¤æ–­äº†ï¼‰ final SPI defaultAnnotation = type.getAnnotation(SPI.class); //1.1 å¦‚æœæ‰©å±•ç‚¹çš„@SPIæ³¨è§£è®¾ç½®äº†é»˜è®¤å€¼ if (defaultAnnotation != null) &#123; // @SPIæ³¨è§£çš„å€¼å°±æ˜¯æ‰©å±•ç‚¹çš„é»˜è®¤æ‰©å±•å String value = defaultAnnotation.value(); if ((value = value.trim()).length() &gt; 0) &#123; // å¯¹é»˜è®¤æ‰©å±•åè¿›è¡Œåˆ†éš”å¤„ç†ï¼Œä»¥é€—å·åˆ†éš”ä¸ºå­—ç¬¦ä¸²æ•°ç»„ String[] names = NAME_SEPARATOR.split(value); // æ£€æµ‹ SPI æ³¨è§£å†…å®¹æ˜¯å¦åˆæ³•ï¼Œä¸åˆæ³•åˆ™æŠ›å‡ºå¼‚å¸¸ if (names.length &gt; 1) &#123; throw new IllegalStateException(\"more than 1 default extension name on extension \" + type.getName() + \": \" + Arrays.toString(names)); &#125; /** è®¾ç½®é»˜è®¤åç§°ï¼ŒcachedDefaultName æ˜¯ç”¨æ¥åŠ è½½æ‰©å±•ç‚¹çš„é»˜è®¤å®ç° &#123;@link #getDefaultExtension()&#125; */ if (names.length == 1) &#123; cachedDefaultName = names[0]; &#125; &#125; &#125; //2ã€ ä»é…ç½®æ–‡ä»¶ä¸­åŠ è½½æ‹“å±•å®ç°ç±»é›†åˆï¼Œè¿™é‡Œåˆ†åˆ«å¯¹åº”ä¸‰ç±»æ–‡ä»¶ï¼ˆ1. Dubboå†…ç½®çš„ 2. Dubboè‡ªå®šä¹‰ 3. JDK SPIï¼‰ Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;String, Class&lt;?&gt;&gt;(); loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY); loadDirectory(extensionClasses, DUBBO_DIRECTORY); loadDirectory(extensionClasses, SERVICES_DIRECTORY); return extensionClasses;&#125; æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¯¥æ–¹æ³•æ²¡æœ‰å¤ªå¤šçš„é€»è¾‘ï¼Œä¸»è¦å¤„ç†æ‰©å±•ç‚¹çš„é»˜è®¤æ‰©å±•åï¼Œå¦‚æœå­˜åœ¨çš„åŒ–å°±æ”¾å…¥ç¼“å­˜ä¸­ï¼Œå…·ä½“åŠ è½½é…ç½®æ–‡ä»¶çš„é€»è¾‘ç”±loadDirectoryæ–¹æ³•å®ç°ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå”¯ä¸€è°ƒç”¨è¯¥æ–¹æ³•çš„å…¥å£ {@link #getExtensionClasses()} å·²ç»åŠ è¿‡äº†é”ï¼Œå› æ­¤æ­¤å¤„æ— éœ€å†æ¬¡åŠ é”ã€‚æ¥ä¸‹æ¥ç»§ç»­åˆ†æDubboå¦‚ä½•åŠ è½½é…ç½®æ–‡ä»¶ã€‚ 123456789101112131415161718192021222324252627282930313233private void loadDirectory(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir) &#123; // æ‹¼æ¥å®Œæ•´çš„æ–‡ä»¶åï¼ˆç›¸å¯¹è·¯å¾„ï¼‰ï¼š ç›®å½• + typeå…¨ç±»å String fileName = dir + type.getName(); try &#123; Enumeration&lt;java.net.URL&gt; urls; // ç±»åŠ è½½å™¨ ClassLoader classLoader = findClassLoader(); /** è·å¾—æ–‡ä»¶åå¯¹åº”çš„æ‰€æœ‰æ–‡ä»¶æ•°ç»„ï¼ˆå¯èƒ½åŒä¸€ä¸ªæ–‡ä»¶ååœ¨ä¸åŒçš„ç›®å½•ç»“æ„ä¸­ï¼Œè¿™æ ·å°±ä¼šè·å–å¤šä¸ªæ–‡ä»¶ï¼‰,æ¯ä¸ªæ–‡ä»¶å†…å®¹å°è£…åˆ°ä¸€ä¸ªjava.net.URLä¸­*/ if (classLoader != null) &#123; urls = classLoader.getResources(fileName); &#125; else &#123; urls = ClassLoader.getSystemResources(fileName); &#125; // éå†java.net.URLé›†åˆ if (urls != null) &#123; while (urls.hasMoreElements()) &#123; java.net.URL resourceURL = urls.nextElement(); // åŠ è½½java.net.URL loadResource(extensionClasses, classLoader, resourceURL); &#125; &#125; &#125; catch (Throwable t) &#123; logger.error(\"Exception when load extension class(interface: \" + type + \", description file: \" + fileName + \").\", t); &#125;&#125; é€šè¿‡ä¸Šé¢ä»£ç å¯ä»¥çœ‹å‡º,loadDirectoryæ–¹æ³•ä¸»è¦å°±åšä¸€ä»¶äº‹ï¼ŒåŠ è½½é…ç½®æ–‡ä»¶å¹¶å°†æ¯ä¸ªé…ç½®æ–‡ä»¶å†…å®¹å°è£…åˆ°java.net.URLé›†åˆä¸­ï¼Œæ¥ä¸‹æ¥åœ¨loadResourceæ–¹æ³•ä¸­å°±å¯ä»¥ä»è¯¥URLä¸­ä¾æ¬¡è§£ææ‰©å±•åå’Œæ‰©å±•å®ç°ç±»ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * åŠ è½½é…ç½®æ–‡ä»¶å†…å®¹ï¼ˆå·²ç»å°è£…æˆäº†java.net.URLï¼‰ * * @param extensionClasses æ‰©å±•ç±»é›†åˆ * @param classLoader ç±»åŠ è½½å™¨ * @param resourceURL æ–‡ä»¶å†…å®¹èµ„æº */ private void loadResource(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL) &#123; try &#123; // è¯»å–æ–‡ä»¶å†…å®¹ BufferedReader reader = new BufferedReader(new InputStreamReader(resourceURL.openStream(), \"utf-8\")); try &#123; String line; // ä¸€è¡Œä¸€è¡Œçš„è¯»å–ã€‚ä¼šè·³è¿‡å½“å‰è¢«æ³¨é‡Šæ‰è¡Œï¼Œä¾‹å¦‚ï¼š#dubbo=xxx while ((line = reader.readLine()) != null) &#123; // å¦‚æœæœ‰#æ³¨é‡Šï¼Œé‚£ä¹ˆciä¸º0ï¼Œæ²¡æœ‰å°±ä¸º-1 final int ci = line.indexOf('#'); // åœ¨æœ‰#æ³¨é‡Šçš„æƒ…å†µä¸‹ï¼Œæ­¤æ—¶lineçš„é•¿åº¦ä¸º0 if (ci &gt;= 0) &#123; line = line.substring(0, ci); &#125; // å»é™¤å‰åç«¯ç©ºæ ¼ï¼Œé˜²æ­¢è‡ªå®šä¹‰æ‰©å±•ç‚¹å®ç°æ—¶é…ç½®ä¸è§„èŒƒ line = line.trim(); // æ²¡æœ‰#æ³¨é‡Šçš„æƒ…å†µ if (line.length() &gt; 0) &#123; try &#123; /** * æ‹†åˆ† key=value ï¼Œnameä¸ºæ‹“å±•å lineä¸ºæ‹“å±•å®ç°ç±»åã€‚æ³¨æ„ï¼š * 1 è¿™é‡Œnameå¯èƒ½ä¸ºç©º,è¿™ç§æƒ…å†µæ‰©å±•åä¼šè‡ªåŠ¨ç”Ÿæˆï¼ˆå› ä¸ºDubbo SPIå…¼å®¹Java SPIï¼ŒDubbo SPIé…ç½®å¼ºè°ƒkey=valueæ ¼å¼ï¼Œåº”è¯¥å°½å¯èƒ½éµå®ˆè§„åˆ™ï¼‰ * 2 æ‰©å±•ååªå¯¹æ™®é€šæ‰©å±•æ‰æœ‰æ„ä¹‰ï¼Œå¯¹è‡ªé€‚åº”æ‰©å±•ã€Wrapperæ˜¯æ²¡ç”¨çš„ï¼Œä¹‹æ‰€ä»¥è¦é…ç½®ï¼Œæ˜¯ä¸ºäº†ç»Ÿä¸€dubbo spié…ç½®è§„åˆ™ */ String name = null; // i &gt; 0ï¼Œæœ‰æ‰©å±•åï¼› i &lt; 0 æ²¡æœ‰é…ç½®æ‰©å±•åï¼Œå³å…¼å®¹Java SPI int i = line.indexOf('='); if (i &gt; 0) &#123; /** è·å– = å·¦è¾¹çš„key å³æ‰©å±•å */ name = line.substring(0, i).trim(); /** è·å– = å³è¾¹çš„value å³æ‹“å±•ç‚¹çš„å®ç°çš„å…¨é™å®šæ€§ç±»å */ line = line.substring(i + 1).trim(); &#125; // åŠ è½½å½“å‰è¡Œå¯¹åº”çš„æ‰©å±•ç‚¹é…ç½® if (line.length() &gt; 0) &#123; /** * 1 é€šè¿‡åå°„ï¼Œæ ¹æ®åç§°è·å–æ‰©å±•ç‚¹å®ç°ç±» * 2 å¯¹æ‰©å±•å®ç°ç±»è¿›è¡Œåˆ†ç±»ç¼“å­˜ */ loadClass(extensionClasses, resourceURL, Class.forName(line, true, classLoader), name); &#125; &#125; catch (Throwable t) &#123; IllegalStateException e = new IllegalStateException(\"Failed to load extension class(interface: \" + type + \", class line: \" + line + \") in \" + resourceURL + \", cause: \" + t.getMessage(), t); exceptions.put(line, e); &#125; &#125; &#125; &#125; finally &#123; reader.close(); &#125; &#125; catch (Throwable t) &#123; logger.error(\"Exception when load extension class(interface: \" + type + \", class file: \" + resourceURL + \") in \" + resourceURL, t); &#125; &#125; loadResourceæ–¹æ³•ç”¨äºå°†é…ç½®æ–‡ä»¶ä¸­çš„æ¯è¡Œè®°å½•è¯»å–å‡ºæ¥ï¼Œç»è¿‡è§£æå’Œåå°„å¤„ç†å°±èƒ½æ‹¿åˆ°æ‰©å±•åå’Œå¯¹åº”çš„æ‰©å±•å®ç°ç±»ï¼Œæ‰©å±•åå’Œæ‰©å±•å®ç°ç±»çš„è·å–é€»è¾‘å·²ç»åœ¨ä»£ç ä¸­è¯¦ç»†æ³¨é‡Šã€‚æœ€åè°ƒç”¨loadClassæ–¹æ³•è¿›è¡Œåˆ†ç±»ç¼“å­˜ï¼Œè¿™äº›ç¼“å­˜å¾ˆå¤šï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹Dubboæ˜¯å¦‚ä½•å¤„ç†å®ä¾‹ç¼“å­˜çš„åˆ†ç±»çš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * å¯¹æ‰©å±•ç‚¹å®ç°ç±»è¿›è¡Œåˆ†ç±»ç¼“å­˜ * * @param extensionClasses æ‰©å±•å®ç°ç±»é›†åˆ * @param resourceURL æ–‡ä»¶å†…å®¹èµ„æº * @param clazz æ‰©å±•ç‚¹å®ç°ç±» * @param name æ‰©å±•å ã€åªå¯¹æ™®é€šæ‰©å±•æ‰æœ‰æ„ä¹‰ã€‘ * @throws NoSuchMethodException */private void loadClass(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name) throws NoSuchMethodException &#123; // åˆ¤æ–­æ‹“å±•ç‚¹å®ç°ç±»ï¼Œæ˜¯å¦å®ç°äº†å½“å‰typeæ¥å£ï¼Œæ²¡æœ‰å®ç°å°±ä¼šæŠ¥é”™ if (!type.isAssignableFrom(clazz)) &#123; throw new IllegalStateException(\"Error when load extension class(interface: \" + type + \", class line: \" + clazz.getName() + \"), class \" + clazz.getName() + \"is not subtype of interface.\"); &#125; //-------------------------------------- æ ¹æ®æ‰©å±•ç‚¹å®ç°ç±»çš„ç±»å‹å¯åˆ†ä¸ºä¸‰å¤§ç±» ï¼Œåœ¨è¿›è¡Œåˆ†ç±»ç¼“å­˜ä¸­æœ‰ä¼˜å…ˆçº§ï¼Œå³åŒä¸€ä¸ªå®ç°ç±»åªèƒ½å½’å±åˆ°æŸä¸ªåˆ†ç±»ä¸­ --------------------------------/ /** * 1ã€è‡ªé€‚åº”æ‰©å±•ç±» * è¯´æ˜ï¼š * ï¼ˆ1ï¼‰å½“å‰æ‰©å±•ç‚¹å®ç°ç±»æ˜¯å¦æ ‡æ³¨@Adaptiveæ³¨è§£ï¼Œæ ‡è®°çš„è¯å°±æ˜¯è‡ªé€‚åº”æ‰©å±•ç±»ï¼Œç›´æ¥ç¼“å­˜åˆ° cachedAdaptiveClass å±æ€§ä¸­ï¼Œç„¶åç»“æŸé€»è¾‘ï¼Œå³ä¸ä¼šè¿›è¡Œä¸‹é¢çš„ Wrapperã€æ™®é€šæ‰©å±•ç±»ä»¥åŠè‡ªåŠ¨æ¿€æ´»ç±»é€»è¾‘åˆ¤æ–­ã€‚ * ï¼ˆ2ï¼‰è‡ªé€‚åº”å›ºå®šæ‰©å±•å®ç°ç±»å…¶å®ä¸éœ€è¦é…ç½®æ‰©å±•åï¼Œå³ä½¿é…ç½®äº†ä¹Ÿç”¨ä¸åˆ°ï¼Œå› ä¸ºè‡ªé€‚åº”æ‰©å±•ç±»å’Œè‡ªé€‚åº”æ‰©å±•å¯¹è±¡æ•´ä¸ªè½¬æ¢é—­ç¯éƒ½ç”¨ä¸åˆ°æ‰©å±•åã€‚ä¹‹æ‰€ä»¥é…ç½®ï¼Œæ˜¯ä¸ºäº†ç»Ÿä¸€è§„åˆ™ã€‚ */ if (clazz.isAnnotationPresent(Adaptive.class)) &#123; // ä¸€ä¸ªæ‰©å±•ç‚¹æœ‰ä¸”ä»…å…è®¸ä¸€ä¸ªè‡ªé€‚åº”æ‰©å±•å®ç°ç±»ï¼Œå¦‚æœç¬¦åˆæ¡ä»¶å°±åŠ å…¥åˆ°ç¼“å­˜ä¸­ï¼Œå¦åˆ™æŠ›å‡ºå¼‚å¸¸ if (cachedAdaptiveClass == null) &#123; cachedAdaptiveClass = clazz; &#125; else if (!cachedAdaptiveClass.equals(clazz)) &#123; throw new IllegalStateException(\"More than 1 adaptive class found: \" + cachedAdaptiveClass.getClass().getName() + \", \" + clazz.getClass().getName()); &#125; /** * 2ã€Wrapperç±»å‹ ï¼ˆè¯¥ç±»éœ€è¦æœ‰æœ‰ä¸€ä¸ªå‚æ•°çš„æ„é€ æ–¹æ³•ï¼Œä¸”è¿™ä¸ªå‚æ•°ç±»å‹æ˜¯å½“å‰çš„æ‰©å±•ç‚¹typeï¼‰ * è¯´æ˜ï¼š * ï¼ˆ1ï¼‰å½“å‰æ‰©å±•ç‚¹å®ç°ç±»å¦‚æœæ˜¯Wrapperç±»ï¼Œç›´æ¥ç¼“å­˜åˆ° cachedWrapperClasses å±æ€§é›†åˆä¸­ï¼Œç„¶åç»“æŸé€»è¾‘ï¼Œå³ä¸ä¼šè¿›è¡Œä¸‹é¢çš„ æ™®é€šæ‰©å±•ç±»ä»¥åŠè‡ªåŠ¨æ¿€æ´»ç±»é€»è¾‘åˆ¤æ–­ã€‚ * ï¼ˆ2ï¼‰Wrapperç±»å…¶å®ä¸éœ€è¦é…ç½®æ‰©å±•åï¼Œå³ä½¿é…ç½®äº†ä¹Ÿç”¨ä¸åˆ°ã€‚ä¹‹æ‰€ä»¥é…ç½®ï¼Œæ˜¯ä¸ºäº†ç»Ÿä¸€è§„åˆ™ã€‚ */ &#125; else if (isWrapperClass(clazz)) &#123; Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses; if (wrappers == null) &#123; cachedWrapperClasses = new ConcurrentHashSet&lt;Class&lt;?&gt;&gt;(); wrappers = cachedWrapperClasses; &#125; wrappers.add(clazz); /** * 3ã€æ™®é€šçš„æ‰©å±•å®ç°ç±»ï¼Œæ³¨æ„Activateè‡ªåŠ¨æ¿€æ´»ç±»ä»å¤§çš„æ–¹é¢ä¹Ÿå±äºæ™®é€šçš„æ‰©å±•å®ç°ç±» */ &#125; else &#123; // åˆ¤æ–­æ˜¯å¦æœ‰é»˜è®¤çš„æ„é€ æ–¹æ³•ï¼Œæ²¡æœ‰ä¼šæŠ›å‡ºå¼‚å¸¸ clazz.getConstructor(); // æœªé…ç½®æ‰©å±•åï¼Œåˆ™è‡ªåŠ¨ç”Ÿæˆã€‚é€‚ç”¨äºJava SPIçš„é…ç½®æ–¹å¼ï¼ˆDubbo SPI å…¼å®¹Java SPIï¼‰ ä¾‹å¦‚ï¼š xxx.yyy.DemoFilterç”Ÿæˆçš„æ‹“å±•åä¸ºdemo if (name == null || name.length() == 0) &#123; // è‡ªåŠ¨ç”Ÿæˆæ‰©å±•å name = findAnnotationName(clazz); if (name.length() == 0) &#123; throw new IllegalStateException(\"No such extension name for the class \" + clazz.getName() + \" in the config \" + resourceURL); &#125; &#125; // å¯¹æ‰©å±•åè¿›è¡Œåˆ†å‰²å¤„ç†ï¼Œdubboæ”¯æŒé…ç½®å¤šä¸ªæ‰©å±•åã€‚å¦‚æœé…ç½®å¤šä¸ªæ‰©å±•åéœ€è¦ä»¥','åˆ†å‰² String[] names = NAME_SEPARATOR.split(name); if (names != null &amp;&amp; names.length &gt; 0) &#123; // 3.1ã€ å¦‚æœå½“å‰ç±»æ ‡æ³¨äº†@Activateï¼Œå°±ç¼“å­˜åˆ° cachedActivatesé›†åˆã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå³ä½¿æ‰©å±•ç‚¹é…ç½®å¤šä¸ªï¼ŒcachedActivates çš„key åªå–ç¬¬ä¸€ä¸ªã€‚ Activate activate = clazz.getAnnotation(Activate.class); if (activate != null) &#123; // æ‹“å±•åä¸ @Activateçš„æ˜ å°„ cachedActivates.put(names[0], activate); &#125; /** * 3.2ã€ç¼“å­˜å½“å‰æ‰©å±•ç‚¹åˆ†ç±»åˆ° cachedNames é›†åˆ å’Œ cachedClasses é›†åˆ * è¯´æ˜ï¼š * ï¼ˆ1ï¼‰cachedNames ç¼“å­˜é›†åˆä¸­çš„æ•°æ®ç‰¹ç‚¹ï¼šåŒä¸€ä¸ªæ‰©å±•ç‚¹å®ç°ç±»å¯¹åº”çš„æ‰©å±•åå³ä½¿åœ¨é…ç½®å¤šä¸ªæ‰©å±•åçš„æƒ…å†µä¸‹ä¹Ÿåªå–ç¬¬ä¸€ä¸ª * ï¼ˆ2ï¼‰cachedClasses ç¼“å­˜é›†åˆçš„æ•°æ®ç‰¹ç‚¹ï¼šåŒä¸€ä¸ªæ‰©å±•ç‚¹å®ç°ç±»å¯¹åº”çš„æ‰©å±•åå¯èƒ½å­˜åœ¨å¤šä¸ª */ for (String n : names) &#123; // ç¼“å­˜æ‰©å±•ç±»åˆ°æ‰©å±•åçš„æ˜ å°„ if (!cachedNames.containsKey(clazz)) &#123; cachedNames.put(clazz, n); &#125; // ç¼“å­˜æ‰©å±•ååˆ°æ‰©å±•ç±»çš„æ˜ å°„ï¼Œæ³¨æ„å¦‚æœåœ¨ä¸åŒçš„æ–‡ä»¶ä¸­é…ç½®åŒä¸€ä¸ªæ‰©å±•ç‚¹å®ç°ï¼Œå¹¶ä¸”æ‰©å±•åæœ‰ç›¸åŒçš„æƒ…å†µï¼Œè¿™æ—¶ä»¥è§£æçš„ç¬¬ä¸€ä¸ªä¸ºå‡† Class&lt;?&gt; c = extensionClasses.get(n); if (c == null) &#123; extensionClasses.put(n, clazz); &#125; else if (c != clazz) &#123; throw new IllegalStateException(\"Duplicate extension \" + type.getName() + \" name \" + n + \" on \" + c.getName() + \" and \" + clazz.getName()); &#125; &#125; &#125; &#125;&#125; é€šè¿‡ä¸Šé¢çš„ä»£ç å¯çŸ¥ï¼ŒloadClassæ–¹æ³•ä¸»è¦å°±æ˜¯åˆ†ç±»ç¼“å­˜ä¸åŒæ‰©å±•å®ç°ç±»ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸æ¶‰åŠæ‰©å±•å®ç°ç±»çš„å®ä¾‹åŒ–ï¼Œè¿™ä¹ŸéªŒè¯äº†å‰é¢çš„ç»“è®ºï¼ŒDubbo SPIæ˜¯æŒ‰éœ€å®ä¾‹åŒ–å¯¹è±¡ã€‚åˆ°è¿™é‡ŒgetExtensionæ–¹æ³•ä¸»è¦è¿‡å°±åˆ†æå®Œäº†ï¼Œå‰é¢ä¹Ÿè¯´åˆ°è¯¥æ–¹æ³•æ˜¯åŠ è½½æ‰©å±•å®ç°çš„å®Œæ•´é€»è¾‘ï¼Œå…¶å®ƒçš„ä¸¤ä¸ªå…¥å£ä¸­çš„é€»è¾‘ä¹Ÿä¼šä½¿ç”¨ä¸Šé¢è¿‡ç¨‹ä¸­çš„éƒ¨åˆ†é€»è¾‘ï¼Œåœ¨ä¸‹é¢çš„ä»£ç åˆ†æä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ã€‚ getActivateExtension æ–¹æ³•è¯¥æ–¹æ³•åªæ˜¯æ ¹æ®ä¸åŒçš„æ¡ä»¶åŒæ—¶æ¿€æ´»å¤šä¸ªæ™®é€šæ‰©å±•å®ç°ç±»ï¼Œå³ä¼šåšä¸€äº›é€šç”¨çš„åˆ¤æ–­æ¥ç­›é€‰æ˜¯å¦æ˜¯æ¿€æ´»æ‰©å±•æ‰©å±•å¯¹è±¡ã€‚å‰é¢å¤šæ¬¡æåˆ°è¯¥æ³•ä¼šä¾èµ–getExtensionæ–¹æ³•ä¸­çš„é€»è¾‘ï¼Œä¸‹é¢æˆ‘å°±ä¸€èµ·æ¥çœ‹çœ‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * è·å¾—æ¿€æ´»æ¡ä»¶çš„æ‰©å±•å®ç°å¯¹è±¡é›†åˆ * * @param url url * @param values æ¿€æ´»çš„æ‰©å±•åæ•°ç»„ï¼Œå¯èƒ½ä¸ºç©ºã€‚å¦‚ï¼šè·å–dubboå†…ç½®çš„è¿‡æ»¤å™¨æ—¶ï¼Œkey=service.filterï¼Œurlä¸­æ²¡æœ‰å¯¹åº”çš„å€¼ * @param group è¿‡æ»¤åˆ†ç»„å * @return è¢«æ¿€æ´»çš„æ‰©å±•å®ç°å¯¹è±¡é›†åˆ * @see com.alibaba.dubbo.common.extension.Activate */ public List&lt;T&gt; getActivateExtension(URL url, String[] values, String group) &#123; // æ¿€æ´»æ‰©å±•å®ç°å¯¹è±¡ç»“æœé›† List&lt;T&gt; exts = new ArrayList&lt;T&gt;(); // æ¿€æ´»çš„æ‰©å±•åé›†åˆ List&lt;String&gt; names = values == null ? new ArrayList&lt;String&gt;(0) : Arrays.asList(values); // åˆ¤æ–­æ‰©å±•åé›†åˆä¸­æ˜¯å¦æœ‰ '-default' , å¦‚ï¼š &lt;dubbo:service filter=\"-default\"/&gt; ä»£è¡¨ç§»å‡ºæ‰€æœ‰é»˜è®¤çš„è¿‡æ»¤å™¨ã€‚æ³¨æ„ï¼Œnamesæ˜¯ä¸ªç©ºçš„Listæ˜¯ç¬¦åˆæ¡ä»¶çš„ if (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123; // è·å–/åˆ·æ–° æ‰©å±•ç‚¹å®ç°ç±»çš„é›†åˆ getExtensionClasses(); /** * éå†cachedActivates (æ‹“å±•å åˆ° @Activate çš„æ˜ å°„) * 1 åŒ¹é…åˆ†ç»„ï¼ŒåŒ¹é…æˆåŠŸåˆ™ç»§ç»­é€»è¾‘ï¼Œå¦åˆ™ä¸å¤„ç† åŠ è½½é…ç½®æ–‡ä»¶æ—¶æ”¶é›†åˆ°çš„æ¿€æ´»æ‰©å±•ç±» * 2 å¯¹æ¿€æ´»æ‰©å±•ç±»è¿›è¡Œå®ä¾‹åŒ–[åˆæ¬¡æ‰ä¼šï¼Œä»¥åå°±ä»ç¼“å­˜ä¸­å–] * 3 åˆ¤æ–­å½“å‰ç¼“å­˜ä¸­çš„æ¿€æ´»æ‰©å±•ç±»æ˜¯å¦å’Œä¼ å…¥çš„æ¿€æ´»æ‰©å±•ç±»å†²çªï¼Œå¦‚æœæœ‰å†²çªï¼Œå°±å¿½ç•¥ç¼“å­˜ä¸­çš„æ¿€æ´»æ‰©å±•ç±»ï¼Œä»¥ä¼ å…¥çš„æ‰©å±•ç±»ä¸ºä¸» */ for (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123; // æ‰©å±•å String name = entry.getKey(); // Activate Activate activate = entry.getValue(); // åŒ¹é…åˆ†ç»„ï¼Œåˆ¤æ–­Activateæ³¨è§£çš„groupå±æ€§å€¼æ˜¯å¦åŒ…å«å½“å‰ä¼ å…¥çš„groupï¼ŒåŒ…å«å°±ç¬¦åˆåˆ†ç»„æ¡ä»¶ if (isMatchGroup(group, activate.group())) &#123; // è·å–æ‰©å±•åå¯¹åº”çš„æ‰©å±•ç‚¹å®ç°å¯¹è±¡ T ext = getExtension(name); // æ˜¯å¦å¿½ç•¥ åŠ è½½é…ç½®æ–‡ä»¶æ—¶æ”¶é›†åˆ°çš„æ¿€æ´»æ‰©å±•ç±» if (!names.contains(name) // åŒ¹é…æ‰©å±•å &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name) // å¦‚æœåŒ…å« '-' è¡¨ç¤ºä¸æ¿€æ´»è¯¥æ‰©å±•å®ç° &amp;&amp; isActive(activate, url)) // æ£€æµ‹URLä¸­æ˜¯å¦å‡ºç°äº†æŒ‡å®šçš„key &#123; exts.add(ext); &#125; &#125; &#125; // å¯¹æ‰©å±•å¯¹è±¡è¿›è¡Œæ’åºï¼ˆæ ¹æ®æ³¨è§£çš„beforeã€afterã€orderå±æ€§ï¼‰ Collections.sort(exts, ActivateComparator.COMPARATOR); &#125; // zæ‰§è¡Œåˆ°æ­¤æ­¥éª¤çš„æ—¶å€™DubboåŸç”Ÿçš„Filterå·²ç»æ·»åŠ å®Œæ¯•äº†ï¼Œä¸‹é¢å¤„ç†è‡ªå®šä¹‰çš„Filter List&lt;T&gt; usrs = new ArrayList&lt;T&gt;(); // éå†ä¼ å…¥çš„æ¿€æ´»æ‰©å±•åé›†åˆ for (int i = 0; i &lt; names.size(); i++) &#123; // è·å–æ¿€æ´»æ‰©å±•å String name = names.get(i); // åˆ¤æ–­æ˜¯å¦æ˜¯ ç§»é™¤æ¿€æ´»æ‰©å±•åï¼Œå¦‚æœæ˜¯å°±å¿½ç•¥ã€‚ å¦‚ï¼š &lt;dubbo:service filter=\"-demo\"/&gt;ï¼Œé‚£ä¹ˆæ­¤æ—¶demoå¯¹åº”çš„æ‰©å±•å®ç°å°±æ˜¯å±äºæ— æ•ˆçš„ if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX) &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123; // å¤„ç† è‡ªå®šä¹‰çš„æ¿€æ´»æ‰©å±•é…ç½®åœ¨é»˜è®¤çš„æ¿€æ´»æ‰©å±•å‰é¢çš„æƒ…å†µ, å¦‚ï¼š &lt;dubbo:service filter=\"demo,default\"/&gt;ï¼Œé‚£ä¹ˆè‡ªå®šä¹‰çš„demoæ¿€æ´»æ‰©å±•å°±ä¼˜å…ˆé»˜è®¤çš„æ¿€æ´»æ‰©å±•ã€‚ä¸»è¦æ˜¯extsä¸­çš„å€¼å˜åŒ–ï¼Œå‰é¢å·²ç»å¤„ç†äº†é»˜è®¤çš„æ¿€æ´»æ‰©å±•(åŠ è½½é…ç½®æ–‡ä»¶æ—¶æ”¶é›†åˆ°çš„æ¿€æ´»æ‰©å±•ç±») if (Constants.DEFAULT_KEY.equals(name)) &#123; if (!usrs.isEmpty()) &#123; exts.addAll(0, usrs); usrs.clear(); &#125; &#125; else &#123; // è·å¾—æ¿€æ´»æ‰©å±•å®ç°å¯¹è±¡ T ext = getExtension(name); usrs.add(ext); &#125; &#125; &#125; if (!usrs.isEmpty()) &#123; exts.addAll(usrs); &#125; return exts; &#125; è·å–æ¿€æ´»çš„æ‰©å±•å¯¹è±¡é€»è¾‘åœ¨ä»£ç ä¸­å·²ç»è¯¦ç»†æ³¨é‡Šè¯´æ˜ï¼Œè·å–æ‰©å±•å®ç°å¯¹è±¡è¿˜æ˜¯è°ƒç”¨äº†getExtensionæ–¹æ³•ã€‚è¯¥æ–¹æ³•ä¸»è¦æ­¥éª¤ï¼š å¦‚æœè§¦å‘è·å–æ‰©å±•å®ç°ç±»åŠ¨ä½œæ—¶ï¼Œä¼šæ£€æŸ¥ç¼“å­˜ï¼Œå¦‚æœç¼“å­˜ä¸­æ²¡æœ‰ï¼Œå°±åŠ è½½é…ç½®æ–‡ä»¶æ¥åˆ·æ–°æ‰©å±•å®ç°ç±»é›†åˆã€‚ éå†ç¼“å­˜ä¸­çš„æ¿€æ´»é›†åˆï¼ˆè¿™ä¸ªç¼“å­˜å†…å®¹æ˜¯åŠ è½½çš„å¸¦æœ‰@Activateæ³¨è§£çš„æ‰©å±•ç±»ä¿¡æ¯ï¼‰ï¼Œæ ¹æ®ä¼ å…¥çš„URLåŒ¹é…æ¡ä»¶ç­›é€‰å‡ºç¬¦åˆæ¿€æ´»æ¡ä»¶çš„æ‰©å±•ç±»å®ç°ï¼Œç„¶åè¿›è¡Œæ’åºæ“ä½œã€‚ éå†ä¼ å…¥çš„æ¿€æ´»æ‰©å±•åé›†åˆï¼Œæ ¹æ®è®¾ç½®çš„é¡ºåºè°ƒæ•´æ‰©å±•ç‚¹æ¿€æ´»é¡ºåºï¼Œå…¶ä¸­defaultä»£è¡¨çš„æ˜¯æ‰€æœ‰@Activateæ ‡æ³¨å¹¶ä¸”é…ç½®åœ¨é…ç½®æ–‡ä»¶ä¸­çš„æ‰©å±•å®ç°ç±» é€šè¿‡getExtension(name)è·å–æ¿€æ´»æ‰©å±•åå¯¹åº”çš„æ‰©å±•å¯¹è±¡å¹¶åŠ å…¥ç»“æœé›†åˆ è¿”å›ç¬¦åˆæ¡ä»¶çš„æ¿€æ´»ç±»é›†åˆ getAdaptiveExtension æ–¹æ³•è·å–è‡ªé€‚åº”æ‰©å±•å¯¹è±¡çš„å…¥å£ï¼Œå³é€‚é…å™¨å¯¹è±¡ã€‚å¦‚æœè·å–çš„è‡ªé€‚åº”æ‰©å±•ç±»å±äºå›ºå®šçš„ï¼Œé‚£ä¹ˆè¯¥æ–¹æ³•ç›¸å¯¹ç‹¬ç«‹ï¼Œå‡ ä¹ä¸ä¾èµ–getExtensionæ–¹æ³•çš„é€»è¾‘ã€‚å¦‚æœå±äºåŠ¨æ€ç”Ÿæˆåˆ™å†…éƒ¨ä¹Ÿä¼šè°ƒç”¨getExtensionæ–¹æ³•ã€‚ç”±äºè¯¥æ–¹æ³•ä¼šæ¶‰åŠåˆ°javassistã€åŠ¨æ€ç¼–è¯‘ç­‰æŠ€æœ¯ï¼Œå†…å®¹è¾ƒå¤šä¸”æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œä¸å†è¿›è¡Œåˆ†æï¼Œæˆ‘ä¼šå•ç‹¬å†™ä¸€ç¯‡æ–‡ç« è¿›è¡Œè¯¦ç»†è¯´æ˜ã€‚ä¸‹é¢å…ˆç»™å‡ºå›ºå®šçš„è‡ªé€‚åº”æ‰©å±•ç±»å’Œè‡ªåŠ¨ç”Ÿæˆçš„è‡ªé€‚åº”æ‰©å±•ç±»çš„ç¤ºä¾‹ï¼Œè®©èƒ–å‹ä»¬æœ‰ä¸ªæ¦‚å¿µã€‚ å›ºå®šçš„è‡ªé€‚åº”æ‰©å±•ç±»ï¼Œä»¥ç¼–è¯‘æ‰©å±•æ¥å£ä¸ºä¾‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940/** * AdaptiveCompiler. (SPI, Singleton, ThreadSafe) * å®ç°Compileræ¥å£ï¼Œè‡ªé€‚åº”Compilerå®ç°ç±» */@Adaptivepublic class AdaptiveCompiler implements Compiler &#123; /** * é»˜è®¤ç¼–è¾‘å™¨çš„æ‹“å±•å */ private static volatile String DEFAULT_COMPILER; /** * é™æ€æ–¹æ³•ï¼Œè®¾ç½®é»˜è®¤ç¼–è¾‘å™¨çš„æ‹“å±•åã€‚è¯¥æ–¹æ³•è¢« &#123;@link com.alibaba.dubbo.config.ApplicationConfig#setCompiler(java.lang.String)&#125;æ–¹æ³•è°ƒç”¨. * åœ¨&lt;dubbo:application compiler=\"\"/&gt; é…ç½®ä¸‹å¯è§¦å‘è¯¥æ–¹æ³• * * @param compiler */ public static void setDefaultCompiler(String compiler) &#123; DEFAULT_COMPILER = compiler; &#125; @Override public Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123; Compiler compiler; // è·å¾—Compilerçš„ExtensionLoaderå¯¹è±¡ ExtensionLoader&lt;Compiler&gt; loader = ExtensionLoader.getExtensionLoader(Compiler.class); // å£°æ˜ name å˜é‡ï¼Œå¼•ç”¨ DEFAULT_COMPILER çš„å€¼ï¼Œé¿å…ä¸‹é¢çš„å€¼å˜äº† String name = DEFAULT_COMPILER; // ä½¿ç”¨è®¾ç½®çš„æ‹“å±•åï¼Œè·å¾—Compileræ‹“å±•å¯¹è±¡ if (name != null &amp;&amp; name.length() &gt; 0) &#123; compiler = loader.getExtension(name); // è·å¾—é»˜è®¤çš„Compileræ‹“å±•å¯¹è±¡ &#125; else &#123; compiler = loader.getDefaultExtension(); &#125; // ä½¿ç”¨çœŸæ­£çš„Compilerå¯¹è±¡ï¼ŒåŠ¨æ€ç¼–è¯‘ä»£ç  return compiler.compile(code, classLoader); &#125;&#125; åŠ¨æ€ç”Ÿæˆçš„è‡ªé€‚åº”æ‰©å±•ç±»ï¼Œä»¥ZookeeperTransporteræ‰©å±•æ¥å£ä¸ºä¾‹ 12345678910111213141516171819import com.alibaba.dubbo.common.extension.ExtensionLoader;public class ZookeeperTransporter$Adaptive implements com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter &#123; public com.alibaba.dubbo.remoting.zookeeper.ZookeeperClient connect(com.alibaba.dubbo.common.URL arg0) &#123; if (arg0 == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; com.alibaba.dubbo.common.URL url = arg0; String extName = url.getParameter(\"client\", url.getParameter(\"transporter\", \"curator\")); if (extName == null) &#123; throw new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter) name from url(\" + url.toString() + \") use keys([client, transporter])\"); &#125; com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter extension = (com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter) ExtensionLoader .getExtensionLoader(com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter.class) .getExtension(extName); return extension.connect(arg0); &#125;&#125; hasExtension æ–¹æ³•123456789101112131415161718/** * åˆ¤æ–­æ˜¯å¦æœ‰å¯¹åº”çš„æ‰©å±•å®ç°ç±» * * @param name æ‰©å±•å * @return */ public boolean hasExtension(String name) &#123; if (name == null || name.length() == 0) &#123; throw new IllegalArgumentException(\"Extension name == null\"); &#125; try &#123; // æ²¡æœ‰nameå¯¹åº”çš„æ‰©å±•å®ç°ç±»å°±æŠ›å‡ºå¼‚å¸¸ï¼Œå³æœ€åè¿”å›false this.getExtensionClass(name); return true; &#125; catch (Throwable t) &#123; return false; &#125; &#125; ä¸Šé¢ä»£ç æ¯”è¾ƒç®€å•ï¼Œæ ¹æ®æ‰©å±•ååˆ¤æ–­æ˜¯å¦æœ‰å¯¹åº”çš„æ‰©å±•å®ç°ç±»ï¼Œä¹‹æ‰€ä»¥å•ç‹¬æ‹¿å‡ºæ¥ä»‹ç»æ˜¯Dubboçš„å¾ˆå¤šæµç¨‹ä¼šç”¨åˆ°è¯¥æ–¹æ³•ï¼Œæœ‰ä¸ªå°è±¡å°±å¯ä»¥äº†ã€‚ Dubbo IOC å®ç°Dubbo IOC å®ç°ç›®å‰ä»…æ”¯æŒsetteræ³¨å…¥ï¼Œä¸¥è°¨æ¥è¯´ï¼ŒDubbo IOC å®ç°æ–¹å¼è¿˜å¯ä»¥é€šè¿‡æ„é€ æ³¨å…¥ï¼Œå³Wrapperç±»çš„å®ç°ã€‚Dubboçš„setteræ³¨å…¥è¦æ±‚æ˜¯ï¼Œå¦‚æœæŸä¸ªæ‰©å±•ç±»æ˜¯å¦å¤–ä¸€ä¸ªæ‰©å±•ç‚¹å®ç°ç±»çš„æˆå‘˜å±æ€§ï¼Œå¹¶ä¸”æ‹¥æœ‰å¯¹åº”çš„setteræ–¹æ³•ï¼Œé‚£ä¹ˆDubboå°±ä¼šè‡ªåŠ¨æ³¨å…¥å¯¹åº”çš„æ‰©å±•ç‚¹å®ç°å¯¹è±¡ã€‚è¿™ä¸ªåŠŸèƒ½åœ¨ä¸Šé¢åˆ›å»ºæ‰©å±•å®ç°çš„æ—¶å€™éœ€è¦ç”¨åˆ°ï¼Œå½“æ—¶æ²¡æœ‰è¯¦ç»†è¯´æ˜ï¼Œä¸‹é¢æˆ‘ä»¬å•ç‹¬æ¥åˆ†æã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * ä¾èµ–æ³¨å…¥ * * @param instance æ‰©å±•å®ç°å¯¹è±¡ ï¼ˆæ³¨æ„ï¼Œå¯èƒ½ä¼šæ˜¯ä¸€ä¸ªWrapperï¼‰ * @return */ private T injectExtension(T instance) &#123; try &#123; // åªæœ‰ExtensionFactoryæ‰©å±•ç‚¹å¯¹åº”çš„ExtensionLoaderå¯¹è±¡çš„è¯¥å±æ€§ä¸ºnullï¼Œå…¶å®ƒæ‰©å±•ç‚¹çš„ExtensionLoaderå¯¹è±¡çš„è¯¥å±æ€§å¿…ç„¶ä¸ä¸ºnull if (objectFactory != null) &#123; // åå°„è·å¾—æ‰©å±•å®ç°å¯¹è±¡ä¸­çš„æ‰€æœ‰æ–¹æ³• for (Method method : instance.getClass().getMethods()) &#123; // è¿‡æ»¤è§„åˆ™ä¸º ' setå¼€å¤´ + ä»…æœ‰ä¸€ä¸ªå‚æ•° + public ' çš„æ–¹æ³• if (method.getName().startsWith(\"set\") &amp;&amp; method.getParameterTypes().length == 1 &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123; /** * æ£€æŸ¥æ–¹æ³•æ˜¯å¦æœ‰ @DisableInject æ³¨è§£ï¼Œæœ‰è¯¥æ³¨è§£å°±å¿½ç•¥ä¾èµ–æ³¨å…¥ */ if (method.getAnnotation(DisableInject.class) != null) &#123; continue; &#125; // è·å–setteræ–¹æ³•å‚æ•°ç±»å‹ Class&lt;?&gt; pt = method.getParameterTypes()[0]; try &#123; // è·å¾—å±æ€§åï¼Œå¦‚ï¼šsetXxx -&gt; xxx String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : \"\"; /** * é€šè¿‡æ‰©å±•å·¥å‚è·å¾—å±æ€§å€¼ï¼Œå³ æ–¹æ³•å‚æ•°ç±»å‹ä½œä¸ºæ‰©å±•ç‚¹ï¼Œå±æ€§åä½œä¸ºæ‰©å±•åã€‚ * ExtensionFactoryçš„å®ç°æœ‰ä¸‰ä¸ª,AdaptiveExtensionFactoryæ˜¯å¯¹å…¶å®ƒä¸¤ä¸ªå·¥å‚çš„ç®¡ç†ï¼ŒgetExtensionæ–¹æ³•çš„çœŸæ­£è°ƒç”¨çš„æ˜¯å…¶å®ƒä¸¤ä¸ªå·¥å‚çš„æ–¹æ³•: * 1ï¼‰SpringExtensionFactory * getExtensionæ–¹æ³•ä¼šè¿”å›å®¹å™¨ä¸­åç§°ä¸ºpropertyå¹¶ä¸”ç±»å‹ä¸ºptçš„beanå¯¹è±¡ * 2ï¼‰SpiExtensionFactory * getExtensionæ–¹æ³•ä¼šè¿”å›ç±»å‹ä¸ºptçš„è‡ªé€‚åº”æ‹“å±•å¯¹è±¡ï¼Œå› ä¸ºè¯¥æ–¹æ³•ä¼šæ ¡éªŒptæ˜¯æ¥å£ç±»å‹å¹¶ä¸”æœ‰@SPIæ³¨è§£ï¼Œç„¶åptæœ‰æ‹“å±•ç±»çš„æƒ…å†µä¸‹ï¼Œå°±ä¼šè·å–ptçš„è‡ªé€‚åº”æ‹“å±•å¯¹è±¡ï¼Œpropertyæ²¡ç”¨åˆ° */ Object object = objectFactory.getExtension(pt, property); // é€šè¿‡åå°„è®¾ç½®å±æ€§å€¼ if (object != null) &#123; method.invoke(instance, object); &#125; &#125; catch (Exception e) &#123; logger.error(\"fail to inject via method \" + method.getName() + \" of interface \" + type.getName() + \": \" + e.getMessage(), e); &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; return instance; &#125; Dubboçš„iocåŸºäºsetteræ–¹æ³•æ³¨å…¥ä¾èµ–çš„ï¼Œæ³¨å…¥çš„ä¾èµ–æ¥æºåˆ™éœ€è¦é€šè¿‡æ‰©å±•å·¥å‚æä¾›ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬æ¥åˆ†æDubboçš„æ‰©å±•å·¥å‚ã€‚ æ‰©å±•å·¥å‚æ¥å£123456789101112@SPIpublic interface ExtensionFactory &#123; /** * Get extension. è·å¾—æ‰©å±•å¯¹è±¡ * * @param type object type. æ‰©å±•æ¥å£ * @param name object name. æ‰©å±•å * @return object instance. æ‰©å±•å®ç°å®ä¾‹ */ &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name);&#125; ExtensionFactory æ‰©å±•å·¥å‚ï¼Œæ˜¯Dubboçš„ä¸€ä¸ªæ‰©å±•ç‚¹ã€‚ä¸»è¦ç”¨äºè·å–æ‰©å±•å®ç°å¯¹è±¡æ‰€éœ€çš„ä¾èµ–ï¼Œç„¶åå®Œæˆä¾èµ–æ³¨å…¥ï¼Œè¯¥æ¥å£çš„umlå…³ç³»å¦‚ä¸‹ï¼š ç”±umlå›¾å¯çŸ¥ï¼Œè¯¥æ¥å£æœ‰ä¸‰ä¸ªæ‰©å±•å®ç°ç±»ã€‚AdaptiveExtensionFactoryæ˜¯å®ƒçš„è‡ªé€‚åº”å®ç°ç±»ï¼Œåªæ˜¯ç”¨æ¥ç®¡ç†SpiExtensionFactoryå’ŒSpringExtensionFactoryï¼Œå…·ä½“ä¾èµ–çš„æŸ¥æ‰¾è¿˜æ˜¯ç”±è¿™ä¸¤ä¸ªç±»å®Œæˆï¼Œä¸‹é¢æˆ‘ä»¬åˆ†åˆ«æ¥åˆ†æã€‚ AdaptiveExtensionFactory å·¥å‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Adaptivepublic class AdaptiveExtensionFactory implements ExtensionFactory &#123; /** * ExtensionFactoryæ‰©å±•å®ç°å¯¹è±¡é›†åˆ */ private final List&lt;ExtensionFactory&gt; factories; /** * AdaptiveExtensionFactoryä¹Ÿæ˜¯ExtensionFactoryçš„æ‰©å±•å®ç°ç±»ï¼Œåªæ˜¯æ¯”è¾ƒç‰¹æ®Šï¼Œæ˜¯è‡ªé€‚åº”æ‰©å±•ç±»ï¼Œä¸åŒäºæ™®é€šçš„æ‰©å±•ç±» */ public AdaptiveExtensionFactory() &#123; ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class); List&lt;ExtensionFactory&gt; list = new ArrayList&lt;ExtensionFactory&gt;(); // ä½¿ç”¨ExtensionLoader åŠ è½½æ‹“å±•ç‚¹å®ç°ç±»ï¼ŒgetSupportedExtensions() è¿”å›çš„æ˜¯ExtensionFactoryæ‰©å±•ç‚¹å®ç°ç±»å¯¹åº”çš„æ‰©å±•åé›†åˆ for (String name : loader.getSupportedExtensions()) &#123; // æ ¹æ®æ‰©å±•åè·å– ExtensionFactory çš„æ‰©å±•å®ç°å¯¹è±¡ å¹¶åŠ å…¥ç¼“å­˜ä¸­ list.add(loader.getExtension(name)); &#125; factories = Collections.unmodifiableList(list); &#125; /** * è·å–ç›®æ ‡å¯¹è±¡ï¼Œä¸»è¦ç”¨äº &#123;@link ExtensionLoader#injectExtension(java.lang.Object)&#125; æ–¹æ³•ä¸­ï¼Œç”¨äºè·å–æ‰©å±•å®ç°å¯¹è±¡æ‰€éœ€è¦çš„ä¾èµ–å±æ€§å€¼ * * @param type object type. æ‰©å±•æ¥å£ * @param name object name. æ‰©å±•å * @param &lt;T&gt; * @return */ @Override public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123; // éå†æ‰©å±•å·¥å‚å¯¹è±¡ï¼Œè·å–æŒ‡å®šçš„æ‰©å±•å¯¹è±¡æˆ–Springä¸­çš„Beanå¯¹è±¡ for (ExtensionFactory factory : factories) &#123; T extension = factory.getExtension(type, name); if (extension != null) &#123; return extension; &#125; &#125; return null; &#125;&#125; AdaptiveExtensionFactory è‡ªé€‚åº”æ‰©å±•å·¥å‚ï¼Œå†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ª ExtensionFactory åˆ—è¡¨ï¼Œç”¨æ¥ç®¡ç†å…¶å®ƒçš„ExtensionFactoryã€‚åœ¨ç”¨æˆ·æ²¡æœ‰è‡ªå®šä¹‰ExtensionFactoryçš„æƒ…å†µä¸‹ï¼ŒDubboç›®å‰æä¾›äº†ä¸¤ç§ ExtensionFactoryï¼Œåˆ†åˆ«æ˜¯ SpiExtensionFactory å’Œ SpringExtensionFactoryã€‚å‰è€…ç”¨äºåˆ›å»º è‡ªé€‚åº”çš„æ‹“å±•ï¼Œåè€…ä»Springå®¹å™¨ä¸­è·å–æ‰€éœ€ä¾èµ–ã€‚ SpiExtensionFactory å·¥å‚12345678910111213141516171819202122232425public class SpiExtensionFactory implements ExtensionFactory &#123; /** * è·å–è‡ªé€‚åº”æ‰©å±•å¯¹è±¡ * * @param type object type. æ‰©å±•æ¥å£ * @param name object name. æ‰©å±•å * @param &lt;T&gt; * @return */ @Override public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123; // æ ¡éªŒæ˜¯æ¥å£ç±»å‹å¹¶ä¸”æœ‰@SPIæ³¨è§£ if (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123; // åŠ è½½æ‹“å±•æ¥å£å¯¹åº”çš„ ExtensionLoader ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type); // åˆ¤æ–­å½“å‰æ‰©å±•ç‚¹æ˜¯å¦æœ‰æ™®é€šçš„æ‰©å±•å®ç°ç±»ï¼Œæ³¨æ„ï¼šå½“å‰æ‰©å±•ç‚¹å­˜åœ¨æ™®é€šçš„æ‰©å±•å®ç°ç±»æ‰ä¼šå»è·å–å¯¹åº”çš„è‡ªé€‚åº”æ‰©å±•å¯¹è±¡ if (!loader.getSupportedExtensions().isEmpty()) &#123; // è·å–è‡ªé€‚åº”æ‰©å±•å¯¹è±¡ return loader.getAdaptiveExtension(); &#125; &#125; return null; &#125;&#125; SpiExtensionFactory æ˜¯æ ¹æ®æ‰©å±•æ¥å£è·å–ç›¸åº”çš„è‡ªé€‚åº”æ‰©å±•å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯é€‚é…å™¨ï¼Œå…¶ä¸­çš„å±æ€§åç§°æ²¡æœ‰ç”¨åˆ°ã€‚ SpringExtensionFactory å·¥å‚å°†å±æ€§åç§°ä½œä¸º Spring Bean çš„åç§°ï¼Œä» Spring å®¹å™¨ä¸­è·å– Beanã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class SpringExtensionFactory implements ExtensionFactory &#123; private static final Logger logger = LoggerFactory.getLogger(SpringExtensionFactory.class); /** * Springä¸Šä¸‹æ–‡ */ private static final Set&lt;ApplicationContext&gt; contexts = new ConcurrentHashSet&lt;ApplicationContext&gt;(); /** * ä¿å­˜Springä¸Šä¸‹æ–‡ * * @param context */ public static void addApplicationContext(ApplicationContext context) &#123; contexts.add(context); &#125; public static void removeApplicationContext(ApplicationContext context) &#123; contexts.remove(context); &#125; // currently for test purpose public static void clearContexts() &#123; contexts.clear(); &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123; // éå†SpringContextä¸Šä¸‹é›†åˆ for (ApplicationContext context : contexts) &#123; // åˆ¤æ–­å®¹å™¨ä¸­æ˜¯å¦åŒ…å«åç§°ä¸ºnameçš„bean if (context.containsBean(name)) &#123; // è·å¾—beanå¯¹è±¡ Object bean = context.getBean(name); // åˆ¤æ–­è·å¾—çš„beanç±»å‹æ˜¯å¦æ˜¯typeç±»å‹ if (type.isInstance(bean)) &#123; return (T) bean; &#125; &#125; &#125; logger.warn(\"No spring extension (bean) named:\" + name + \", try to find an extension (bean) of type \" + type.getName()); if (Object.class == type) &#123; return null; &#125; for (ApplicationContext context : contexts) &#123; try &#123; return context.getBean(type); &#125; catch (NoUniqueBeanDefinitionException multiBeanExe) &#123; logger.warn(\"Find more than 1 spring extensions (beans) of type \" + type.getName() + \", will stop auto injection. Please make sure you have specified the concrete parameter type and there's only one extension of that type.\"); &#125; catch (NoSuchBeanDefinitionException noBeanExe) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Error when get spring extension(bean) for type:\" + type.getName(), noBeanExe); &#125; &#125; &#125; logger.warn(\"No spring extension (bean) named:\" + name + \", type:\" + type.getName() + \" found, stop get bean.\"); return null; &#125;&#125; Dubboä½¿ç”¨Springå®¹å™¨ç®¡ç†çš„ä¾èµ–ä¸ºæ‰©å±•å¯¹è±¡æ³¨å…¥ä¾èµ–å±æ€§ã€‚Dubboæ˜¯å¦‚ä½•ä¸Springå®¹å™¨æ‰“é€šçš„å‘¢ï¼Ÿæœ‰ä¸¤å¤„ç»“åˆç‚¹ï¼Œåˆ†åˆ«æ˜¯æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨çš„æ—¶å€™ï¼Œåˆ©ç”¨ApplicationContextAwareçš„å›è°ƒæ–¹æ³•è®¾ç½®springä¸Šä¸‹æ–‡ã€‚ æœåŠ¡æš´éœ²ç»“åˆç‚¹ 123456789101112131415161718192021222324252627282930313233public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener&lt;ContextRefreshedEvent&gt;, BeanNameAware, ApplicationEventPublisherAware &#123; // çœç•¥æ— å…³ä»£ç  @Override public void setApplicationContext(ApplicationContext applicationContext) &#123;// å½“å‰åŠ è½½çš„ä¸Šä¸‹æ–‡ this.applicationContext = applicationContext; // ä¸ºSpringæ‹“å±•å·¥å‚æ³¨å…¥ä¸Šä¸‹æ–‡ , dubboå’ŒSpringå®¹å™¨æ‰“é€š SpringExtensionFactory.addApplicationContext(applicationContext); if (applicationContext != null) &#123; SPRING_CONTEXT = applicationContext; try &#123; Method method = applicationContext.getClass().getMethod(\"addApplicationListener\", new Class&lt;?&gt;[]&#123;ApplicationListener.class&#125;); // backward compatibility to spring 2.0.1 method.invoke(applicationContext, new Object[]&#123;this&#125;); supportedApplicationListener = true; // å½“å‰Springå®¹å™¨æ˜¯å¦æ”¯æŒä¸Šä¸‹æ–‡ç›‘å¬ &#125; catch (Throwable t) &#123; if (applicationContext instanceof AbstractApplicationContext) &#123; try &#123; Method method = AbstractApplicationContext.class.getDeclaredMethod(\"addListener\", new Class&lt;?&gt;[]&#123;ApplicationListener.class&#125;); // backward compatibility to spring 2.0.1 if (!method.isAccessible()) &#123; method.setAccessible(true); &#125; method.invoke(applicationContext, new Object[]&#123;this&#125;); supportedApplicationListener = true; &#125; catch (Throwable t2) &#123; &#125; &#125; &#125; &#125; &#125;&#125; æœåŠ¡å¼•ç”¨ç»“åˆç‚¹123456789public class ReferenceBean&lt;T&gt; extends ReferenceConfig&lt;T&gt; implements FactoryBean, ApplicationContextAware, InitializingBean, DisposableBean &#123; // çœç•¥æ— å…³ä»£ç  @Override public void setApplicationContext(ApplicationContext applicationContext) &#123; this.applicationContext = applicationContext; // dubbo å’Œ springå®¹å™¨æ‰“é€š SpringExtensionFactory.addApplicationContext(applicationContext); &#125;&#125; Dubbo AOP å®ç°Dubbo AOP å®ç°éœ€è¦Wrapperç±»ï¼Œå…³äºWrapperç±»å‰é¢å·²ç»ä»‹ç»è¿‡äº†ï¼Œè¿™é‡Œä¸å†è¯´æ˜ã€‚å…³äºDubbo AOP çš„åŠŸèƒ½ä¹Ÿåœ¨å‰é¢çš„æµç¨‹ä¸­ä½“ç°å‡ºæ¥äº†ï¼Œå•ç‹¬æŠŠDubbo AOP æ‹¿å‡ºæ¥è¿›è¡Œè¯´æ˜æ˜¯è€ƒè™‘åˆ°å‰é¢çš„ç¯‡å¹…æ²¡æœ‰å…·ä½“åˆ°Wrapperç±»ï¼Œåªæ˜¯é˜è¿°äº†å…¶åŠŸèƒ½å’Œå®ç°ã€‚å®ç°ä¸€ä¸ªWrapperç±»çš„åŸºæœ¬æ­¥éª¤å¦‚ä¸‹ï¼š å®šä¹‰ä¸€ä¸ªWrapperç±»å¹¶å®ç°æ‰©å±•æ¥å£ï¼Œç„¶åç¼–å†™AOPé€»è¾‘ã€‚ åœ¨é…ç½®æ–‡ä»¶é…ç½®è‡ªå®šä¹‰çš„Wrapperç±» å®šä¹‰ Wrapperç±»123456789101112131415161718192021public class CommandWrapper implements Command &#123; Command command; /** * æ„é€ æ–¹æ³•çš„å‚æ•°å¿…é¡»æ˜¯æ‰©å±•ç‚¹ç±»å‹ * * @param command */ public CommandWrapper(Command command) &#123; this.command = command; &#125; @Override public void execute() &#123; System.out.println(\"CommandWrapper is running ...\"); // æ‰§è¡Œæ‰©å±•å®ç°å¯¹è±¡ï¼Œæ³¨æ„ï¼Œå¦‚æœä¸æ˜¾ç¤ºè°ƒç”¨æ‰©å±•å®ç°ï¼Œé‚£ä¹ˆå°±è¾¾ä¸åˆ°ç›®æ ‡ç»“æœï¼Œåªä¼šæ‰§è¡Œè¿™ä¸ªå¹¶æ²¡æœ‰çœŸæ­£å®ç°çš„Wrapper command.execute(); &#125;&#125; å®šä¹‰Wrapperç±»å¾ˆç®€å•ï¼Œåªè¦æŒ‰ç…§Wrapperç±»çš„è¦æ±‚è¿›è¡Œå®ç°å³å¯ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œæˆ‘ä»¬æ‰€è¯´çš„Wrapperç±»å…¶å®ä¸å¼ºåˆ¶ç±»åä»¥Wrapperç»“å°¾ï¼Œåªè¦ç¬¦åˆWrapperç±»çš„è¦æ±‚å°±æ˜¯ä¸€ä¸ªWrapperç±»ï¼Œå¹¶ä¸æ˜¯ç”¨åå­—è¿›è¡ŒåŒºåˆ†æ˜¯å¦Wrapperç±»ï¼Œåªæ˜¯è¿™æ ·å†™æ˜¯Dubboçš„ä¸€ç§çº¦å®šç½¢äº†ã€‚ é…ç½® Wrapperç±» Dubbo å†…ç½®çš„Wrapper ä¸¾ä¾‹123456789101112131415161718192021222324252627/** * å®ç° Clusteræ¥å£ï¼ŒMockClusterWrapperå®ç°ç±»ï¼Œæ³¨æ„å®ƒæ˜¯ä¸ªWrapperç±»ï¼Œå¯¹åº”çš„Clusterå¯¹è±¡éƒ½ä¼šè¢«å®ƒæ‰€åŒ…è£…ã€‚ */public class MockClusterWrapper implements Cluster &#123; /** * çœŸæ­£çš„Cluster å¯¹è±¡ */ private Cluster cluster; public MockClusterWrapper(Cluster cluster) &#123; this.cluster = cluster; &#125; /** * åˆ›å»ºMockClusterInvokerå¯¹è±¡ * * @param directory Directory å¯¹è±¡ * @param &lt;T&gt; * @return * @throws RpcException */ @Override public &lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory) throws RpcException &#123; return new MockClusterInvoker&lt;T&gt;(directory, this.cluster.join(directory)); &#125;&#125; æ€»ç»“æœ¬ç¯‡æ–‡ç« ç®€å•ä»‹ç»äº†Dubbo SPI ç”¨æ³•ï¼Œå¹¶å¯¹ Dubbo SPI çš„æ ¸å¿ƒæºç è¿›è¡Œäº†åˆ†æï¼Œæ€»ä½“ä¸Šä¸ç®—å¤æ‚ä½†å¾ˆç¹çï¼Œç»†èŠ‚ç‚¹å¾ˆå¤šï¼Œæ¯”å¦‚ï¼Œæ‰©å±•åç”Ÿæˆçš„è§„åˆ™ï¼Œæ‰©å±•ç±»çš„ç§ç±»åŒºåˆ«ï¼Œè‡ªåŠ¨æ¿€æ´»æ‰©å±•ç”Ÿæ•ˆæ¡ä»¶ã€‚æƒ³è¦æŒæ¡æ•´ä¸ªæµç¨‹éœ€è¦è€å¿ƒè°ƒè¯•æºç ï¼Œç¬”è€…å·®ç‚¹è¢«spiåŠæ¥ä¸‹æ¥è¦åˆ†æçš„Dubboé…ç½®ç»™åŠé€€äº†ã€‚å¦å¤–ï¼Œç”±äºDubbo SPIè‡ªé€‚åº”æœºåˆ¶æ¶‰åŠåˆ°çš„ä»£ç é‡è¾ƒå¤šï¼Œé€»è¾‘æ¯”è¾ƒå¤æ‚ï¼Œæˆ‘å°†ä¼šåœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­å•ç‹¬è¿›è¡Œåˆ†æã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"SPI","slug":"SPI","permalink":"https://gentryhuang.com/tags/SPI/"}]},{"title":"Java SPI","slug":"rpc/SPIæœºåˆ¶ä¹‹JDK","date":"2020-03-10T16:00:00.000Z","updated":"2021-01-04T10:56:56.234Z","comments":false,"path":"posts/a9c33b8c/","link":"","permalink":"https://gentryhuang.com/posts/a9c33b8c/","excerpt":"","text":"SPIæ¦‚è¿°SPIï¼ˆService Provider Interfaceï¼‰æ˜¯JDKå†…ç½®çš„ä¸€ç§æœåŠ¡æä¾›å‘ç°æœºåˆ¶ã€‚ä¸€ä¸ªæœåŠ¡(Service)é€šå¸¸æŒ‡çš„æ˜¯å·²çŸ¥çš„æ¥å£æˆ–è€…æŠ½è±¡ç±»ï¼ŒæœåŠ¡æä¾›æ–¹å°±æ˜¯å¯¹è¿™ä¸ªæ¥å£æˆ–è€…æŠ½è±¡ç±»çš„å®ç°ï¼Œç„¶åæŒ‰ç…§SPIæ ‡å‡†å­˜æ”¾åˆ°èµ„æºè·¯å¾„META-INF/servicesç›®å½•ä¸‹ï¼Œæ–‡ä»¶çš„å‘½åä¸ºè¯¥æœåŠ¡æ¥å£çš„å…¨é™å®šåã€‚Java SPIä½¿ç”¨äº†ç­–ç•¥æ¨¡å¼ï¼Œä¸€ä¸ªæ¥å£å¤šç§å®ç°ï¼Œæˆ‘ä»¬åªå£°æ˜æ¥å£ï¼Œå…·ä½“çš„å®ç°å¹¶ä¸åœ¨ç¨‹åºä¸­ç›´æ¥ç¡®å®šï¼Œè€Œæ˜¯ç”±é…ç½®å†³å®šã€‚ çº¦å®š æœåŠ¡çš„æä¾›è€…çš„æ¥å£ï¼Œå®ƒçš„å¤šç§å®ç°ä¸€èˆ¬ä¼šåœ¨jaråŒ…çš„META-INF/services ç›®å½•ä¸‹ï¼Œåœ¨è¿™ä¸ªç›®å½•ä¸‹åˆ›å»ºæœåŠ¡æä¾›è€…æ¥å£åŒåæ–‡ä»¶ï¼Œè¿™ä¸ªæ–‡ä»¶ä¸­å°±æ˜¯æ¥å£çš„å…·ä½“å®ç°ç±»çš„å…¨é™å®šæ€§ç±»åã€‚è€Œå½“å¤–éƒ¨åŠ è½½è¿™ä¸ªæœåŠ¡æä¾›åŠŸèƒ½æ—¶ï¼Œå°±èƒ½é€šè¿‡è¯¥jaråŒ…META-INF/services/ä¸‹çš„é…ç½®æ–‡ä»¶å¾—åˆ°å…·ä½“çš„å®ç°ç±»åï¼Œå¹¶åŠ è½½å®ä¾‹åŒ–ï¼Œå®ŒæˆåŠŸèƒ½çš„è£…é…ã€‚ å®ç°æ­¥éª¤ å®šä¹‰æ¥å£ ç¼–å†™æ¥å£å®ç°ç±» åœ¨META-INF/services ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªä»¥æ¥å£å…¨è·¯å¾„åçš„æ–‡ä»¶ æ–‡ä»¶å†…å®¹æ˜¯æ¥å£å®ç°ç±»çš„å…¨è·¯å¾„åï¼Œå¯ä»¥æœ‰å¤šä¸ªï¼Œå¦‚æœå¤šä¸ªéœ€è¦ä½¿ç”¨åˆ†è¡Œç¬¦åˆ†å‰² åœ¨ä»£ç ä¸­ä½¿ç”¨jdkçš„ServiceLoaderæ¥åŠ è½½æ¥å£çš„å…·ä½“å®ç°ç±» ç¤ºä¾‹æœåŠ¡æä¾›è€…æ¥å£1234567package com.alibaba.dubbo.spi;public interface Command &#123; /** * æ‰§è¡Œæ–¹æ³• */ void execute();&#125; æœåŠ¡æä¾›è€…å®ç°ç±»1234567package com.alibaba.dubbo.spi.impl;public class StartCommand implements Command&#123; @Override public void execute() &#123; System.out.println(\"start....\"); &#125; &#125; 1234567package com.alibaba.dubbo.spi.impl;public class ShutdownCommand implements Command&#123; @Override public void execute() &#123; System.out.println(\"shutdown....\"); &#125; &#125; åœ¨META-INF/servicesä¸‹åˆ›å»º com.alibaba.dubbo.spi.Commandæ–‡ä»¶123# å†…å®¹com.alibaba.dubbo.spi.impl.StartCommandcom.alibaba.dubbo.spi.impl.ShutdownCommand åŠ è½½æ‰©å±•å®ç°123456789101112131415public class Main &#123; public static void main(String[] args) &#123; // ServiceLoaderæ˜¯JDKçš„ï¼Œç”¨æ¥åŠ è½½æ¥å£çš„å®ç°ç±»ï¼ˆé€šè¿‡é…ç½®æ–‡ä»¶åŠ è½½ï¼‰ ServiceLoader&lt;Command&gt; serviceLoader = ServiceLoader.load(Command.class); for (Command command : serviceLoader) &#123; if (command instanceof StartCommand) &#123; System.out.println(\"åˆ¤æ–­å‡ºæ˜¯Startï¼š\" + command.getClass().getSimpleName()); &#125; if (command instanceof ShutdownCommand) &#123; System.out.println(\"åˆ¤æ–­å‡ºæ˜¯Shutdownï¼š\" + command.getClass().getSimpleName()); &#125; command.execute(); &#125; &#125;&#125; JDK SPI æºç åˆ†æå±æ€§123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public final class ServiceLoader&lt;S&gt; implements Iterable&lt;S&gt;&#123; /** * æœåŠ¡çš„é…ç½®æ–‡ä»¶è·¯å¾„å‰ç¼€ */ private static final String PREFIX = \"META-INF/services/\"; /** * æœåŠ¡æ¥å£ */ private final Class&lt;S&gt; service; /** * ç±»åŠ è½½å™¨ */ private final ClassLoader loader; // The access control context taken when the ServiceLoader is created private final AccessControlContext acc; /** * æœåŠ¡ç¼“å­˜ * key: å®ç°ç±»çš„å…¨è·¯å¾„å * value: å®ç°ç±»å¯¹è±¡ */ private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;(); /** * å»¶è¿ŸæŸ¥æ‰¾è¿­ä»£å™¨ï¼Œå³åªæœ‰è·å–æœåŠ¡å®ç°çš„æ—¶å€™æ‰ä¼šåŠ è½½é…ç½®èµ„æºç„¶ååˆå§‹åŒ–ã€‚è¿™æ˜¯æœ€æ ¸å¿ƒçš„å¯¹è±¡ */ private LazyIterator lookupIterator; /** * Clear this loader's provider cache so that all providers will be * reloaded. * * &lt;p&gt; After invoking this method, subsequent invocations of the &#123;@link * #iterator() iterator&#125; method will lazily look up and instantiate * providers from scratch, just as is done by a newly-created loader. * * &lt;p&gt; This method is intended for use in situations in which new providers * can be installed into a running Java virtual machine. */ public void reload() &#123; // æ¸…ç†æœåŠ¡ç¼“å­˜ providers.clear(); // åˆ›å»ºå»¶è¿ŸæŸ¥æ‰¾è¿­ä»£å™¨ï¼Œç”¨äºè¯»å– SPI é…ç½®æ–‡ä»¶å¹¶å®ä¾‹åŒ–å®ç°ç±»å¯¹è±¡ lookupIterator = new LazyIterator(service, loader); &#125; // æ„é€ æ–¹æ³• private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123; service = Objects.requireNonNull(svc, \"Service interface cannot be null\"); loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl; acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null; reload(); &#125; /** * é€šè¿‡æŒ‡å®šçš„æœåŠ¡æ¥å£å’Œç±»åŠ è½½èµ·åˆ›å»º ServiceLoader * * @param æœåŠ¡æ¥å£ * @param ç±»åŠ è½½å™¨ * * @return A new service loader */ public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service, ClassLoader loader) &#123; return new ServiceLoader&lt;&gt;(service, loader); &#125; /** * é€šè¿‡æŒ‡å®šçš„æœåŠ¡æ¥å£å’Œå½“å‰çº¿ç¨‹çš„ç±»åŠ è½½å™¨åˆ›å»º ServiceLoader * * @param æœåŠ¡æ¥å£ * @return A new service loader */ public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; é€šè¿‡ä½¿ç”¨ä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° JDK SPI çš„å…¥å£æ˜¯ ServiceLoader.load() æ–¹æ³•ï¼Œç»“åˆä¸Šé¢çš„ ServiceLoader çš„éƒ¨åˆ†æºç å¯çŸ¥è¿™ä¸ªå…¥å£æ–¹æ³•ä¼šåˆ›å»º ServiceLoader å¯¹è±¡ï¼Œåˆ›å»ºå¯¹è±¡çš„è¿‡ç¨‹å®Œæˆä¸¤ä¸ªä»»åŠ¡ï¼Œä¸€ä¸ªæ˜¯æœåŠ¡ç¼“å­˜çš„æ¸…ç†ä»¥ä¿è¯æœåŠ¡æ˜¯æœ€æ–°çš„ï¼Œå¦ä¸€æ˜¯åˆ›å»º LazyIterator è¿­ä»£å™¨å¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡æ˜¯ ServiceLoader çš„æ ¸å¿ƒï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹è¿™ä¸ªè¿­ä»£å™¨ç±»ã€‚ LazyIterator123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173public final class ServiceLoader&lt;S&gt; implements Iterable&lt;S&gt;&#123; /** * æœåŠ¡çš„é…ç½®æ–‡ä»¶è·¯å¾„å‰ç¼€ */ private static final String PREFIX = \"META-INF/services/\"; /** * æœåŠ¡æ¥å£ */ private final Class&lt;S&gt; service; /** * ç±»åŠ è½½å™¨ */ private final ClassLoader loader; // The access control context taken when the ServiceLoader is created private final AccessControlContext acc; /** * æœåŠ¡ç¼“å­˜ * key: å®ç°ç±»çš„å…¨è·¯å¾„å * value: å®ç°ç±»å¯¹è±¡ */ private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;(); /** * å»¶è¿ŸæŸ¥æ‰¾è¿­ä»£å™¨ï¼Œå³åªæœ‰è·å–æœåŠ¡å®ç°çš„æ—¶å€™æ‰ä¼šåŠ è½½é…ç½®èµ„æºç„¶ååˆå§‹åŒ– */ private LazyIterator lookupIterator; /** * * &lt;p&gt; After invoking this method, subsequent invocations of the &#123;@link * #iterator() iterator&#125; method will lazily look up and instantiate * providers from scratch, just as is done by a newly-created loader. * * &lt;p&gt; This method is intended for use in situations in which new providers * can be installed into a running Java virtual machine. */ public void reload() &#123; // æ¸…ç†æœåŠ¡ç¼“å­˜ providers.clear(); // åˆ›å»ºå»¶è¿ŸæŸ¥æ‰¾è¿­ä»£å™¨ï¼Œç”¨äºè¯»å– SPI é…ç½®æ–‡ä»¶å¹¶å®ä¾‹åŒ–å®ç°ç±»å¯¹è±¡ lookupIterator = new LazyIterator(service, loader); &#125; // ç§æœ‰å†…éƒ¨ç±»ï¼Œç”¨äºè¯»å–æœåŠ¡é…ç½®æ–‡ä»¶å’Œå®ä¾‹åŒ–æœåŠ¡ private class LazyIterator implements Iterator&lt;S&gt; &#123; // æœåŠ¡æ¥å£ Class&lt;S&gt; service; // ç±»åŠ è½½å™¨ ClassLoader loader; // æœåŠ¡é…ç½®æ–‡ä»¶è¯»å–å†…å®¹ Enumeration&lt;URL&gt; configs = null; // æœåŠ¡é…ç½®æ–‡ä»¶ä¸­çš„æœåŠ¡å…¨è·¯å¾„åé›†åˆè¿­ä»£å™¨ Iterator&lt;String&gt; pending = null; // è®°å½• pending.next() çš„å€¼ String nextName = null; // æ„é€ æ–¹æ³• private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) &#123; this.service = service; this.loader = loader; &#125; // æŸ¥æ‰¾é…ç½®æ–‡ä»¶ï¼Œå¹¶è¿›è¡Œéå† private boolean hasNextService() &#123; // æœåŠ¡å®ç°ç±»å…¨è·¯å¾„åæ˜¯å¦ä¸ºç©º if (nextName != null) &#123; return true; &#125; // æœåŠ¡é…ç½®ç¼“å­˜ä¸ºç©ºï¼Œå°è¯•åŠ è½½é…ç½®æ–‡ä»¶ if (configs == null) &#123; try &#123; // æ‹¼æ¥æœåŠ¡çš„é…ç½®æ–‡ä»¶å®Œæ•´è·¯å¾„ String fullName = PREFIX + service.getName(); // ä½¿ç”¨ç±»åŠ è½½å™¨è·å–æœåŠ¡é…ç½®æ–‡ä»¶å†…å®¹ if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); &#125; catch (IOException x) &#123; fail(service, \"Error locating configuration files\", x); &#125; &#125; while ((pending == null) || !pending.hasNext()) &#123; if (!configs.hasMoreElements()) &#123; return false; &#125; // å°†æœåŠ¡é…ç½®æ–‡ä»¶å†…å®¹ï¼Œå³æœåŠ¡æ¥å£å®ç°ç±»çš„å…¨è·¯å¾„ååŠ è½½åˆ°ç¼“å­˜é›†åˆä¸­ pending = parse(service, configs.nextElement()); &#125; // å–å‡ºé›†åˆä¸­çš„ä¸€ä¸ªå…ƒç´  nextName = pending.next(); return true; &#125; // æ ¹æ®æœåŠ¡å®ç°ç±»å…¨è·¯å¾„åå®ä¾‹åŒ–å¯¹è±¡ private S nextService() &#123; if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class&lt;?&gt; c = null; try &#123; // ç”±ç±»åè·å–å¯¹åº”çš„ç±» c = Class.forName(cn, false, loader); &#125; catch (ClassNotFoundException x) &#123; fail(service, \"Provider \" + cn + \" not found\"); &#125; if (!service.isAssignableFrom(c)) &#123; fail(service, \"Provider \" + cn + \" not a subtype\"); &#125; try &#123; // åå°„åˆ›å»ºå¯¹è±¡ï¼Œå¹¶ç±»å‹è½¬æ¢ S p = service.cast(c.newInstance()); // å°†æœåŠ¡å®ä¾‹åŠ å…¥ç¼“å­˜ providers.put(cn, p); return p; &#125; catch (Throwable x) &#123; fail(service, \"Provider \" + cn + \" could not be instantiated\", x); &#125; throw new Error(); // This cannot happen &#125; // æ˜¯å¦è¿˜æœ‰å…ƒç´  public boolean hasNext() &#123; if (acc == null) &#123; return hasNextService(); &#125; else &#123; PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;Boolean&gt;() &#123; public Boolean run() &#123; return hasNextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125; &#125; // è·å–å…ƒç´  public S next() &#123; if (acc == null) &#123; return nextService(); &#125; else &#123; PrivilegedAction&lt;S&gt; action = new PrivilegedAction&lt;S&gt;() &#123; public S run() &#123; return nextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125; // $&#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; é€šè¿‡ä»£ç å¯ä»¥çœ‹å‡º LazyIterator æ˜¯ç”¨æ¥åŠ è½½æœåŠ¡çš„é…ç½®æ–‡ä»¶ï¼Œä»¥åŠå®ä¾‹åŒ–é…ç½®æ–‡ä»¶ä¸­æœåŠ¡å®ç°ç±»ï¼Œæ­¤å¤–è¿˜æä¾›äº†åˆ¤æ–­å’Œè·å–æœåŠ¡çš„æ–¹æ³•ã€‚æ€»å¾—æ¥è¯´ï¼Œ LazyIterator æœ‰ä¸¤ä¸ªä¸Šå±‚æ–¹æ³•ï¼ŒhashNext() æ–¹æ³•å’Œ next() æ–¹æ³•ï¼Œè€Œå‰è€…æœ€ç»ˆä¼šè°ƒç”¨ hasNextService() æ–¹æ³•ï¼Œåè€…æœ€ç»ˆä¼šè°ƒç”¨ nextService() æ–¹æ³•ï¼Œå…³ç³»å¦‚ä¸‹ï¼š 1234ServiceLoader.hasNext() - ServiceLoader.hasNextService()ServiceLoader.next() - ServiceLoader.nextService() hasNextService() æ–¹æ³•ç”¨äºåŠ è½½é…ç½®æ–‡ä»¶å†…å®¹åˆ°ç¼“å­˜ï¼ŒnextService() æ–¹æ³•ç”¨äºå®ä¾‹åŒ–hasNextService()æ–¹æ³•åŠ è½½çš„å®ç°ç±»ï¼Œå¹¶å°†å®ä¾‹åŒ–çš„å¯¹è±¡æ”¾åˆ° providers é›†åˆä¸­ç¼“å­˜èµ·æ¥ã€‚ ä»¥ä¸Šå°±æ˜¯ ServiceLoader åº•å±‚å®ç°ï¼Œå³åˆ›å»º ServiceLoader çš„åŒæ—¶ä¼šåˆ›å»ºå†…éƒ¨çš„ LazyIterator å¯¹è±¡ï¼ŒServiceLoader æŠŠé…ç½®æ–‡ä»¶çš„åŠ è½½ã€é…ç½®æ–‡ä»¶ä¸­çš„æœåŠ¡ç±»å®ä¾‹åŒ–ä»¥åŠå¯¹æœåŠ¡å¯¹è±¡çš„æ“ä½œéƒ½äº¤ç»™è¯¥ç±»ã€‚ä¸‹é¢æˆ‘ä»¬ç»§ç»­æ ¹æ®ä¾‹å­çœ‹ ServiceLoader çš„è¿­ä»£å™¨å®ç°ã€‚ 123456789101112131415161718192021222324252627282930313233public Iterator&lt;S&gt; iterator() &#123; // åˆ›å»ºåŒ¿åIterator å¯¹è±¡ return new Iterator&lt;S&gt;() &#123; // providers ç¼“å­˜åŒæ­¥è¿‡æ¥ Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator(); // åˆ¤æ–­æ˜¯å¦å­˜åœ¨å…ƒç´  public boolean hasNext() &#123; // ç¼“å­˜ä¸­æ˜¯å¦å­˜åœ¨ if (knownProviders.hasNext()) return true; // ç¼“å­˜ä¸­ä¸å­˜åˆ™è°ƒç”¨ LazyIterator çš„æ–¹æ³• return lookupIterator.hasNext(); &#125; // è·å–å…ƒç´  public S next() &#123; // ç¼“å­˜ä¸­æ˜¯å¦å­˜åœ¨ if (knownProviders.hasNext()) return knownProviders.next().getValue(); // ç¼“å­˜ä¸­ä¸å­˜åˆ™è°ƒç”¨ LazyIterator çš„æ–¹æ³• return lookupIterator.next(); &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125;; &#125; è‡³æ­¤ï¼Œæˆ‘ä»¬çŸ¥é“äº† ServiceLoaderè·å–çš„è¿­ä»£å™¨ï¼ˆfor å¾ªç¯å†…éƒ¨ä½¿ç”¨çš„å°±æ˜¯è¿­ä»£å™¨ï¼Œè¿™é‡Œç›¸å½“äº ServiceLoader.iterator()æ–¹æ³•ï¼‰æ˜¯å¦‚ä½•å®ç°çš„ï¼Œè¿™ä¸ªåŒ¿åè¿­ä»£å™¨æ˜¯å¯¹LazyIteratoråŒ…è£…ï¼Œæœ¬è´¨ä¸Šè¿˜æ˜¯ä½¿ç”¨ LazyIterator ä¸­çš„æ–¹æ³•ã€‚ ä½¿ç”¨jdkçš„spiçš„ä¾èµ–mysqlé©±åŠ¨ JDK ä¸­åªå®šä¹‰äº†ä¸€ä¸ª java.sql.Driver æ¥å£ï¼Œå…·ä½“çš„å®ç°æ˜¯ç”±ä¸åŒæ•°æ®åº“å‚å•†æ¥æä¾›çš„ï¼Œæ¯”å¦‚ä¸Šå›¾çš„ MySQL æä¾›çš„å®ç°ã€‚æˆ‘ä»¬åœ¨é€šè¿‡ JDK çš„ DriverManager è·å–è¿æ¥æ—¶ï¼Œä¼šä¼˜å…ˆé€šè¿‡ ServiceLoader åŠ è½½å…·ä½“çš„é©±åŠ¨ã€‚ 12345678910111213141516171819--- DriverManager static &#123; loadInitialDrivers(); println(\"JDBC DriverManager initialized\"); &#125; private static void loadInitialDrivers() &#123; String drivers = System.getProperty(\"jdbc.drivers\") // ä½¿ç”¨ ServiceLoader åŠ è½½æ‰€æœ‰ java.sql.Driverå®ç°ç±» ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); while(driversIterator.hasNext()) &#123; driversIterator.next(); &#125; // &#123;çœç•¥å…¶å®ƒä»£ç &#125;&#125; SpringServletContaineråˆå§‹åŒ–å™¨ å°ç»“jdkçš„spiæœºåˆ¶è™½ç„¶å®ç°äº†æœåŠ¡å‘ç°æœºåˆ¶ï¼Œå³åœ¨æ¨¡å—è£…é…çš„æ—¶å€™ä¸åœ¨æ¨¡å—ä¸­å†™æ­»ä»£ç å°±èƒ½å¤Ÿå‘ç°æœåŠ¡ï¼Œä½†æ˜¯å­˜åœ¨æ€§èƒ½å’Œå¥å£®æ€§é—®é¢˜ï¼Œå…·ä½“çš„é—®é¢˜åŠè§£å†³æ–¹æ¡ˆåœ¨dubbo spiä¸­è¯´æ˜ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"SPI","slug":"SPI","permalink":"https://gentryhuang.com/tags/SPI/"}]},{"title":"URLç»Ÿä¸€æ¨¡å‹","slug":"rpc/dubboä¹‹urlç»Ÿä¸€æ¨¡å‹","date":"2020-03-09T16:00:00.000Z","updated":"2020-10-17T10:36:28.342Z","comments":false,"path":"posts/46f95e97/","link":"","permalink":"https://gentryhuang.com/posts/46f95e97/","excerpt":"","text":"URL å®šä¹‰URL çš„å…¨åå³ç»Ÿä¸€èµ„æºå®šä½ç¬¦ï¼Œå› ç‰¹ç½‘ä¸Šçš„å¯ç”¨èµ„æºæ˜¯ä½¿ç”¨å­—ç¬¦ä¸²æ¥è¡¨ç¤ºçš„ï¼Œè€Œè¿™äº›å…·æœ‰ç‰¹å®šæ ¼å¼å’Œè¯­ä¹‰çš„å­—ç¬¦ä¸²å°±æ˜¯URLã€‚ æ ‡å‡†çš„URLæ ¼å¼: 12ç»„æˆï¼šåè®®ã€è´¦å·&#x2F;å¯†ç ã€ä¸»æœºã€ç«¯å£ã€è·¯å¾„ [å¤§å¤šæ•°urlä¸éœ€è¦è´¦å·&#x2F;å¯†ç ,éœ€è¦å®‰å…¨è®¤è¯çš„æ‰ä¼šéœ€è¦]æ ¼å¼ï¼šprotocol:&#x2F;&#x2F;[username:password@]host:port&#x2F;path?key&#x3D;value&amp;key&#x3D;value Dubboä¸­çš„ URLDubboä¸­ä¹Ÿä½¿ç”¨äº†ç±»ä¼¼çš„ URLï¼Œå®ƒæ˜¯æ•´ä¸ª Dubbo ä¸­éå¸¸åŸºç¡€åˆéå¸¸æ ¸å¿ƒçš„ä¸€ä¸ªç»„ä»¶ï¼ŒDubbo URL ä¸­çš„æ¯ä¸ªå‚æ•°å‡ ä¹éƒ½æœ‰å„è‡ªçš„ç”¨é€”ï¼Œå®ƒä»¬å¾€å¾€å¯¹åº”ç€ç‰¹å®šçš„åŠŸèƒ½æˆ–å®ç°ã€‚Dubboä¸­å¯¹è¿™ä¸ª URL åšäº†å°è£…ï¼Œå¤§ä½“ä¸Šåˆ†ä¸ºä¸»è¦å‚æ•°å’Œé”®å€¼å¯¹å‚æ•°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * url ä¾‹å­: * &lt;ul&gt; * &lt;li&gt;http://www.facebook.com/friends?param1=value1&amp;amp;param2=value2 * &lt;li&gt;http://username:password@10.20.130.230:8080/list?version=1.0.0 * &lt;li&gt;ftp://username:password@192.168.1.7:21/1/read.txt * &lt;li&gt;registry://192.168.1.7:9090/com.alibaba.service1?param1=value1&amp;amp;param2=value2 * &lt;/ul&gt; * ä¸€äº›ç‰¹åˆ«çš„url: * &lt;ul&gt; * &lt;li&gt;192.168.1.3:20880&lt;br&gt; * for this case, url protocol = null, url host = 192.168.1.3, port = 20880, url path = null * &lt;li&gt;file:///home/user1/router.js?type=script&lt;br&gt; * for this case, url protocol = file, url host = null, url path = home/user1/router.js * &lt;li&gt;file://home/user1/router.js?type=script&lt;br&gt; * for this case, url protocol = file, url host = home, url path = user1/router.js * &lt;li&gt;file:///D:/1/router.js?type=script&lt;br&gt; * for this case, url protocol = file, url host = null, url path = D:/1/router.js * &lt;li&gt;file:/D:/1/router.js?type=script&lt;br&gt; * åŒä¸Šï¼š file:///D:/1/router.js?type=script * &lt;li&gt;/home/user1/router.js?type=script &lt;br&gt; * å¯¹äºè¿™äº›ä¾‹å­ï¼š url protocol = null, url host = null, url path = home/user1/router.js * &lt;li&gt;home/user1/router.js?type=script &lt;br&gt; * å¯¹äºè¿™äº›ä¾‹å­ï¼š url protocol = null, url host = home, url path = user1/router.js * &lt;/ul&gt; * * @see java.net.URL * @see java.net.URI */public final class URL implements Serializable &#123; private static final long serialVersionUID = -1985165475234910535L; /** * åè®®å */ private final String protocol; /** * ç”¨æˆ·å */ private final String username; /** * å¯†ç  */ private final String password; /** by default, host to registry * åœ°å€ */ private final String host; /** by default, port to registry * ç«¯å£ */ private final int port; /** * è·¯å¾„ï¼ˆæœåŠ¡åï¼‰ */ private final String path; /** * å‚æ•°é›†åˆï¼Œé”®å€¼å¯¹å½¢å¼ */ private final Map&lt;String, String&gt; parameters; // çœç•¥å…¶å®ƒå±æ€§åŠæ„é€ å‡½æ•° public URL(String protocol, String username, String password, String host, int port, String path, Map&lt;String, String&gt; parameters) &#123; if ((username == null || username.length() == 0) &amp;&amp; password != null &amp;&amp; password.length() &gt; 0) &#123; throw new IllegalArgumentException(\"Invalid url, password without username!\"); &#125; this.protocol = protocol; this.username = username; this.password = password; this.host = host; this.port = (port &lt; 0 ? 0 : port); // trim the beginning \"/\" while (path != null &amp;&amp; path.startsWith(\"/\")) &#123; path = path.substring(1); &#125; this.path = path; if (parameters == null) &#123; parameters = new HashMap&lt;String, String&gt;(); &#125; else &#123; parameters = new HashMap&lt;String, String&gt;(parameters); &#125; this.parameters = Collections.unmodifiableMap(parameters); &#125; // çœç•¥å…¶å®ƒæ–¹æ³• &#125; é€šè¿‡ä¸Šé¢çš„ä»£ç ä¹Ÿå¯ä»¥çœ‹å‡ºï¼ŒDubbo ä½¿ç”¨ URL æ¥ç»Ÿä¸€æè¿°äº†æ‰€æœ‰å¯¹è±¡å’Œé…ç½®ä¿¡æ¯ï¼Œå¹¶è´¯ç©¿æ•´ä¸ª Dubbo æ¡†æ¶ä¸­ã€‚ Dubboä¸­å¸¸è§çš„ URL Dubboåè®®çš„æœåŠ¡ 1dubbo:&#x2F;&#x2F;192.168.21.50:20880&#x2F;com.alibaba.dubbo.demo.DemoService?anyhost&#x3D;true&amp;application&#x3D;demo-provider&amp;bean.name&#x3D;com.alibaba.dubbo.demo.DemoService&amp;bind.ip&#x3D;10.1.14.50&amp;bind.port&#x3D;20880&amp;dubbo&#x3D;2.0.2&amp;generic&#x3D;false&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;qos.port&#x3D;22222&amp;side&#x3D;provider&amp;timestamp&#x3D;1596611769521 æœåŠ¡æä¾›è€… 1provider:&#x2F;&#x2F;192.168.21.50:20880&#x2F;com.alibaba.dubbo.demo.DemoService?anyhost&#x3D;true&amp;application&#x3D;demo-provider&amp;bean.name&#x3D;com.alibaba.dubbo.demo.DemoService&amp;category&#x3D;configurators&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.2&amp;generic&#x3D;false&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;side&#x3D;provider&amp;timestamp&#x3D;1596611769521 æœåŠ¡æ¶ˆè´¹è€… 1consumer:&#x2F;&#x2F;192.168.21.50&#x2F;com.alibaba.dubbo.demo.DemoService?application&#x3D;demo-consumer&amp;category&#x3D;consumers&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.2&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;3363&amp;qos.port&#x3D;33333&amp;side&#x3D;consumer&amp;timestamp&#x3D;1596612621336 æœåŠ¡æš´éœ²è¿‡ç¨‹ä¸´æ—¶åè®® 1registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.2&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;qos.port&#x3D;22222&amp;registry&#x3D;zookeeper&amp;timestamp&#x3D;1596611658802 zkæ³¨å†Œä¸­å¿ƒ 1zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.2&amp;interface&#x3D;com.alibaba.dubbo.registry.RegistryService&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;qos.port&#x3D;22222&amp;timestamp&#x3D;1596611658802 è¯´æ˜: é™¤æ­¤ä¹‹å¤–è¿˜æœ‰å¾ˆå¤šç±»å‹çš„ URL ï¼Œä¸åŒçš„åè®®[å¦‚ï¼šdubboåè®®ã€httpåè®®ç­‰]å¯¹åº”ä¸åŒçš„URLã€ä¸åŒçš„è§’è‰²[å¦‚ï¼šæä¾›è€…ã€æ¶ˆè´¹è€…ã€æ³¨å†Œä¸­å¿ƒã€è·¯ç”±å™¨ç­‰]å¯¹åº”ä¸åŒçš„URLã€ä¸åŒçš„åŠŸèƒ½æµç¨‹[å¦‚ï¼šæœåŠ¡æš´éœ²ã€æœåŠ¡å¼•ç”¨ã€æœåŠ¡è·¯ç”±ç­‰]å¯¹åº”ä¸åŒçš„URLâ€¦è¿™äº›åœ¨åé¢çš„æºç è§£æä¸­éƒ½æœ‰å¯¹åº”ã€‚ Dubbo URL ä¸¾ä¾‹è¯´æ˜ Dubbo URL ç»Ÿä¸€æ¨¡å‹çš„æ„ä¹‰Dubboä¸­çš„ URL å¯ä»¥è¯´æ˜¯Dubboçš„é…ç½®æ€»çº¿ï¼Œå®ƒè´¯ç©¿æ•´ä¸ªDubboçš„ç”Ÿå‘½å‘¨æœŸã€‚ä¸Šä¸‹æ–‡çš„ä¿¡æ¯ä¼ é€’éœ€è¦ URL æ¥æä¾›ï¼Œç‰¹å®šåŠŸèƒ½çš„å®ç°éœ€è¦ URL çš„æ”¯æŒ[å¦‚ï¼šæ‰€æœ‰æ‰©å±•ç‚¹å‚æ•°éƒ½åŒ…å«urlå‚æ•°ï¼Œurlä½œä¸ºä¸Šä¸‹æ–‡ä¿¡æ¯è´¯ç©¿æ•´ä¸ªæ‹“å±•ç‚¹ä½“ç³»]ã€‚ Dubbo URL åº”ç”¨Dubbo URL åœ¨ Dubbo SPI ä¸­çš„åº”ç”¨åœ¨ Dubbo çš„è‡ªé€‚åº”æ‰©å±•å®ç°ä¸­ï¼Œå³æ‰©å±•æ¥å£ä¸­çš„æ–¹æ³•è¢« @Adaptive æ³¨è§£æ ‡æ³¨ä¼šç”Ÿæˆä¸€ä¸ªè‡ªé€‚åº”æ‰©å±•å®ç°ç±»ï¼Œè¿™ä¸ªå®ç°ç±»ä¸­çš„é€»è¾‘ä¼šæ ¹æ® Dubbo URL ä¸­çš„å‚æ•°é€‰æ‹©åˆé€‚çš„æ‰©å±•å®ç°ã€‚ä»¥ZookeeperTransporteræ‰©å±•æ¥å£ä¸ºä¾‹ï¼Œä¸‹é¢æ˜¯ç”Ÿæˆçš„è‡ªé€‚åº”æ‰©å±•å®ç°ã€‚ 12345678910111213141516171819import com.alibaba.dubbo.common.extension.ExtensionLoader;public class ZookeeperTransporter$Adaptive implements com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter &#123; public com.alibaba.dubbo.remoting.zookeeper.ZookeeperClient connect(com.alibaba.dubbo.common.URL arg0) &#123; if (arg0 == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; com.alibaba.dubbo.common.URL url = arg0; String extName = url.getParameter(\"client\", url.getParameter(\"transporter\", \"curator\")); if (extName == null) &#123; throw new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter) name from url(\" + url.toString() + \") use keys([client, transporter])\"); &#125; com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter extension = (com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter) ExtensionLoader .getExtensionLoader(com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter.class) .getExtension(extName); return extension.connect(arg0); &#125;&#125; æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œç”Ÿæˆçš„è‡ªé€‚åº”æ‰©å±•å®ç°ç±» ZookeeperTransporter$Adaptive ä¼šå®ç° ZookeeperTransporter ä¸­çš„ connect æ–¹æ³•ï¼Œå†…éƒ¨é€»è¾‘ä¼šæ ¹æ®ä¼ å…¥çš„ URL ä¸­çš„å‚æ•°æ¥ç¡®å®šå…·ä½“çš„æ‰©å±•å®ç°ç±»ã€‚ Dubbo URL åœ¨æœåŠ¡æ³¨å†Œä¸­åº”ç”¨æœåŠ¡æä¾›è€…åœ¨å¯åŠ¨åï¼Œå°†è‡ªå·±çš„æœåŠ¡åœ°å€å’Œç›¸å…³é…ç½®ä¿¡æ¯å°è£…æˆ Dubbo URL æ·»åŠ åˆ°æ³¨å†Œä¸­å¿ƒä¸­ï¼Œå³åœ¨æ³¨å†Œä¸­å¿ƒå†™å…¥çš„æ˜¯æœåŠ¡æä¾›è€…çš„ URL å­—ç¬¦ä¸²ï¼Œå¦‚ä¸‹ï¼š 1dubbo: &#x2F;&#x2F;192.168.21.50:20880&#x2F;com.alibaba.dubbo.demo.DemoService?anyhost&#x3D;true&amp;application&#x3D;demo-provider&amp;bean.name&#x3D;com.alibaba.dubbo.demo.DemoService&amp;bind.ip&#x3D;10.1.14.50&amp;bind.port&#x3D;20880&amp;dubbo&#x3D;2.0.2&amp;generic&#x3D;false&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;qos.port&#x3D;22222&amp;side&#x3D;provider&amp;timestamp&#x3D;1583841600000 Dubbo URL åœ¨æœåŠ¡è®¢é˜…ä¸­çš„åº”ç”¨æœåŠ¡æ¶ˆè´¹è€…åœ¨å¯åŠ¨åä¼šè¿›è¡Œæ³¨å†Œæ“ä½œï¼Œæ­¤å¤–è¿˜ä¼šå‘æ³¨å†Œä¸­å¿ƒè¿›è¡Œè®¢é˜…æ“ä½œï¼Œç”¨äºç›‘å¬è‡ªå·±å…³æ³¨çš„ Providerã€Configuratorã€Routerï¼Œæ³¨å†Œä¸­å¿ƒæ­£æ˜¯é€šè¿‡ Dubbo URL æ¥ç¡®å®šæ¶ˆè´¹è€…éœ€è¦å…³æ³¨çš„å“ªäº›è·¯å¾„ã€‚æœåŠ¡æ¶ˆè´¹è€…è®¢é˜…ä¼ å…¥çš„ Dubbo URL å¦‚ä¸‹ï¼š 1consumer:&#x2F;&#x2F;192.168.21.50&#x2F;com.alibaba.dubbo.demo.DemoService?application&#x3D;demo-consumer&amp;category&#x3D;providers,configurators,routers&amp;&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;... æ ¹æ®ä¸Šé¢çš„ Dubbo URL å¯çŸ¥ï¼š protocol ä¸º consumerï¼Œè¡¨ç¤ºæ˜¯ Consumer çš„è®¢é˜…åè®®ï¼Œå¦‚æœ protocol ä¸º provider åˆ™è¡¨ç¤ºæ˜¯ Provider çš„è®¢é˜…åè®®ã€‚category å‚æ•°è¡¨ç¤ºè¦è®¢é˜…çš„åˆ†ç±»ï¼ŒConsumer ä¸€èˆ¬ä¼šè®¢é˜… providersã€configurators ä»¥åŠ routers ä¸‰ä¸ªåˆ†ç±»ï¼ŒProviderä¸€èˆ¬ä¼šè®¢é˜… configurators åˆ†ç±»ã€‚interface å‚æ•°è¡¨ç¤ºè®¢é˜…å“ªä¸ªæœåŠ¡æ¥å£ï¼Œè¿™é‡Œæ˜¯ com.alibaba.dubbo.demo.DemoServiceã€‚ è®¢é˜…å°±æ˜¯ ZookeeperRegistry ä¼šå°†ä¸Šé¢çš„ URL è§£ææˆä¸€ä¸ª Zookeeper è·¯å¾„ï¼Œç„¶åè°ƒç”¨ Zookeeper å®¢æˆ·ç«¯åœ¨è¯¥è·¯å¾„ä¸Šæ·»åŠ ç›‘å¬å™¨ã€‚ é™¤äº†ä¸Šé¢ä¾‹ä¸¾å¤–ï¼ŒDubbo URL è¿˜ç”¨åœ¨å¾ˆå¤šåœ°æ–¹ï¼Œå¦‚è¿›è¡ŒæœåŠ¡æ²»ç†æ—¶çš„åŠ¨æ€é…ç½®ã€è·¯ç”±ã€é»‘ç™½åå•ç­‰ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"Dubboæºç ç¯å¢ƒ","slug":"rpc/Dubboæºç ç¯å¢ƒæ­å»º","date":"2020-03-08T16:00:00.000Z","updated":"2020-10-17T08:18:12.124Z","comments":false,"path":"posts/ba7cbd3a/","link":"","permalink":"https://gentryhuang.com/posts/ba7cbd3a/","excerpt":"","text":"å‰è¨€ä¸Šä¸€ç¯‡æ–‡ç« ä¸­å¯¹ Dubbo çš„æ•´ä¸ªé¡¹ç›®ç»“æ„è¿›è¡Œäº†è¯´æ˜ï¼Œæœ¬ç¯‡æ–‡ç« æˆ‘ä»¬æ¥è¿›è¡Œæºç æ­å»ºåŠæ ¸å¿ƒæ¨¡å—è¯´æ˜ã€‚ Dubbo æ¶æ„ èŠ‚ç‚¹è§’è‰²è¯´æ˜ä»¥ä¸‹è¯´æ˜ä¸­æ³¨å†Œä¸­å¿ƒä»¥ Zookeeper ä¸ºä¾‹ï¼Œä¸åŒçš„æ³¨å†Œä¸­å¿ƒçš„æ³¨å†Œå’Œè®¢é˜…æ˜¯ä¸åŒçš„ã€‚ Registry æ³¨å†Œä¸­å¿ƒæ³¨å†Œä¸­å¿ƒè´Ÿè´£æœåŠ¡åœ°å€çš„æ³¨å†Œä¸æŸ¥æ‰¾ï¼ŒæœåŠ¡æä¾›è€…å’Œæ¶ˆè´¹è€…åªåœ¨å¯åŠ¨æ—¶ä¸æ³¨å†Œä¸­å¿ƒäº¤äº’ï¼ˆä»¥å®¢æˆ·ç«¯å½¢å¼ï¼‰ï¼Œæ³¨å†Œä¸­å¿ƒä¸è½¬å‘è¯·æ±‚ï¼Œå‹åŠ›è¾ƒå°ã€‚æ³¨å†Œä¸­å¿ƒé€šè¿‡é•¿è¿æ¥æ„ŸçŸ¥æœåŠ¡æä¾›è€…çš„å­˜åœ¨ï¼ŒæœåŠ¡æä¾›è€…å®•æœºï¼Œæ³¨å†Œä¸­å¿ƒå°†ç«‹å³æ¨é€äº‹ä»¶é€šçŸ¥æ¶ˆè´¹è€…ã€‚æ³¨å†Œä¸­å¿ƒï¼ŒæœåŠ¡ææä¾›è€…ï¼ŒæœåŠ¡æ¶ˆè´¹è€…ä¸‰è€…ä¹‹é—´å‡ä¸ºé•¿è¿æ¥ã€‚ Provider æœåŠ¡æä¾›è€…å¯åŠ¨çš„æ—¶å€™å‘æ³¨å†Œä¸­å¿ƒè¿›è¡Œæ³¨å†Œæ“ä½œï¼Œå°†è‡ªå·±çš„æœåŠ¡åœ°å€å’Œç›¸å…³é…ç½®ä¿¡æ¯å°è£…æˆ Dubbo URL æ·»åŠ åˆ°æ³¨å†Œä¸­å¿ƒä¸­ã€‚æœåŠ¡æä¾›è€…æ— çŠ¶æ€ï¼Œä»»æ„ä¸€å°å®•æœºåä¸å½±å“ä½¿ç”¨ï¼Œå…¨éƒ¨å®•æœºåæœåŠ¡æ¶ˆè´¹è€…åº”ç”¨å°†æ— æ³•ä½¿ç”¨ã€‚ Consumer æœåŠ¡æ¶ˆè´¹è€…å¯åŠ¨çš„æ—¶å€™å‘æ³¨å†Œä¸­å¿ƒè¿›è¡Œæ³¨å†Œå’Œè®¢é˜…æ“ä½œï¼Œæ³¨å†Œæ“ä½œä¼šå°†è‡ªå·±çš„æœåŠ¡åœ°å€å’Œç›¸å…³é…ç½®ä¿¡æ¯å°è£…æˆ Dubbo URL æ·»åŠ åˆ°æ³¨å†Œä¸­å¿ƒä¸­ã€‚è®¢é˜…æ“ä½œä¼šä»æ³¨å†Œä¸­å¿ƒä¸­è·å–æœåŠ¡æä¾›è€…æ³¨å†Œçš„URLï¼Œå¹¶åœ¨æ³¨å†Œä¸­å¿ƒä¸­æ·»åŠ ç›¸åº”çš„ç›‘å¬å™¨ã€‚è·å–åˆ°æœåŠ¡æä¾›è€…URLåˆ—è¡¨åï¼Œæ¶ˆè´¹è€…ä¼šæ ¹æ®è´Ÿè½½å‡è¡¡ç®—æ³•ä»å¤šä¸ªæœåŠ¡æä¾›è€…ä¸­é€‰æ‹©ä¸€ä¸ªæœåŠ¡æä¾›è€…å¹¶ä¸å…¶å»ºç«‹è¿æ¥ï¼Œæœ€åå¯¹æœåŠ¡æä¾›è€…å‘èµ·è¿œç¨‹è°ƒç”¨ã€‚å¦‚æœæœåŠ¡æä¾›è€… URL å‘ç”Ÿå˜æ›´ï¼Œæ¶ˆè´¹è€…å°†ä¼šé€šè¿‡ä¹‹å‰è®¢é˜…è¿‡ç¨‹ä¸­åœ¨æ³¨å†Œä¸­å¿ƒæ·»åŠ çš„ç›‘å¬å™¨ï¼Œè·å–åˆ°æœ€æ–°çš„æœåŠ¡æä¾›è€…URLåˆ—è¡¨ï¼Œç„¶åæ›´æ–°æœåŠ¡ç›®å½•ã€‚æ¶ˆè´¹è€…ä¸æä¾›è€…å»ºç«‹çš„æ˜¯é•¿è¿æ¥ï¼Œä¸”æ¶ˆè´¹è€…ä¼šåœ¨æœ¬åœ°ç¼“å­˜æœåŠ¡æä¾›è€…åˆ—è¡¨ï¼Œæ‰€ä»¥ä¸€æ—¦è¿æ¥å»ºç«‹ï¼Œå³ä½¿æ³¨å†Œä¸­å¿ƒå®•æœºï¼ŒæœåŠ¡æä¾›è€…å’ŒæœåŠ¡æ¶ˆè´¹è€…ä»èƒ½é€šè¿‡æœ¬åœ°ç¼“å­˜é€šè®¯ã€‚ Monitor ç›‘æ§ä¸­å¿ƒ ç»Ÿè®¡æœåŠ¡çš„è°ƒç”¨æ¬¡æ•°å’Œè°ƒç”¨æ—¶é—´ã€‚æœåŠ¡æä¾›è€…å’ŒæœåŠ¡æ¶ˆè´¹è€…åœ¨è¿è¡Œè¿‡ç¨‹ä¸­ï¼Œä¼šåœ¨å†…å­˜ä¸­ç»Ÿè®¡è°ƒç”¨æ¬¡æ•°å’Œè°ƒç”¨æ—¶é—´ï¼Œå®šæ—¶å‘é€ç»Ÿè®¡æ•°æ®åˆ°ç›‘æ§ä¸­å¿ƒã€‚ç›‘æ§ä¸­å¿ƒåœ¨æ¶æ„å›¾ä¸­ä¸æ˜¯å¿…è¦è§’è‰²ï¼Œç›‘æ§ä¸­å¿ƒå®•æœºåªä¼šä¸¢å¤±ç›‘æ§æ•°æ®è€Œå·²ï¼Œå…¶å®ƒçš„æ²¡æœ‰å½±å“ã€‚ è°ƒç”¨å…³ç³» æœåŠ¡å®¹å™¨è´Ÿè´£å¯åŠ¨ï¼ŒåŠ è½½ï¼Œè¿è¡ŒæœåŠ¡æä¾›è€…ã€‚ æœåŠ¡æä¾›è€…åœ¨å¯åŠ¨æ—¶ï¼Œå‘æ³¨å†Œä¸­å¿ƒæ³¨å†Œè‡ªå·±æä¾›çš„æœåŠ¡ã€‚ æœåŠ¡æ¶ˆè´¹è€…åœ¨å¯åŠ¨æ—¶ï¼Œå‘æ³¨å†Œä¸­å¿ƒæ³¨å†Œè‡ªå·±çš„ä¿¡æ¯å¹¶è®¢é˜…è‡ªå·±æ‰€éœ€çš„æœåŠ¡ã€‚ æ³¨å†Œä¸­å¿ƒè¿”å›æœåŠ¡æä¾›è€…åœ°å€åˆ—è¡¨ç»™æ¶ˆè´¹è€…ï¼Œå¦‚æœæœ‰å˜æ›´ï¼Œæ³¨å†Œä¸­å¿ƒå°†åŸºäºé•¿è¿æ¥æ¨é€å˜æ›´æ•°æ®ç»™æ¶ˆè´¹è€…ã€‚ æœåŠ¡æ¶ˆè´¹è€…ï¼Œä»æä¾›è€…åœ°å€åˆ—è¡¨ä¸­ï¼ŒåŸºäºè½¯è´Ÿè½½å‡è¡¡ç®—æ³•ï¼Œé€‰ä¸€å°æä¾›è€…è¿›è¡Œè°ƒç”¨ï¼Œå¦‚æœè°ƒç”¨å¤±è´¥ï¼Œå†é€‰å¦ä¸€å°è°ƒç”¨ã€‚ æœåŠ¡æ¶ˆè´¹è€…å’Œæä¾›è€…ï¼Œåœ¨å†…å­˜ä¸­ç´¯è®¡è°ƒç”¨æ¬¡æ•°å’Œè°ƒç”¨æ—¶é—´ï¼Œå®šæ—¶æ¯åˆ†é’Ÿå‘é€ä¸€æ¬¡ç»Ÿè®¡æ•°æ®åˆ°ç›‘æ§ä¸­å¿ƒã€‚ æºç ç¯å¢ƒæ­å»º ç›´æ¥ä»å®˜æ–¹ä»“åº“å…‹éš†æºä»£ç 1https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;dubbo.git åˆ‡æ¢åˆ†æ”¯ï¼Œä½¿ç”¨ Dubbo 2.6.5 ç‰ˆæœ¬1git checkout -b dubbo-2.6.5 dubbo-2.6.5 ç¼–è¯‘1mvn clean install -Dmaven.test.skip&#x3D;true Dubbo æºç æ ¸å¿ƒæ¨¡å—è¯´æ˜ç¼–è¯‘å®Œæˆåæˆ‘ä»¬å¯ä»¥çœ‹åˆ°é¡¹ç›®ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸‹é¢æˆ‘ä»¬ç®€å•ä»‹ç»ä¸Šå›¾ä¸­çš„æ ¸å¿ƒæ¨¡å—ï¼Œæ¯ä¸ªæ¨¡å—çš„åˆ†æå°†åœ¨åé¢çš„æ–‡ç« ä¸­è¯¦ç»†è¯´æ˜ã€‚ dubbo-common æ¨¡å— Dubbo çš„ä¸€ä¸ªå…¬å…±æ¨¡å—ï¼Œé‡Œé¢åŒ…å«äº†åŠ¨æ€ç¼–è¯‘ç›¸å…³å®ç°ã€Dubbo SPIçš„æ ¸å¿ƒå®ç°ã€æ—¥å¿—æ¡†æ¶é›†æˆï¼Œçº¿ç¨‹æ± ç›¸å…³çš„å·¥å…·ç±»ç­‰ã€‚ dubbo-remoting æ¨¡å— Dubbo çš„è¿œç¨‹é€šä¿¡æ¨¡å—ï¼Œå…¶ä¸­çš„å­æ¨¡å—ä¾èµ–å„ç§å¼€æºç»„ä»¶å®ç°è¿œç¨‹é€šä¿¡ã€‚dubbo-remoting-api å­æ¨¡å—ä¸­å®šä¹‰äº†è¿œç¨‹é€šä¿¡çš„æŠ½è±¡æ¦‚å¿µï¼Œå…¶å®ƒå­æ¨¡å—ä¾èµ–å¼€æºç»„ä»¶è¿›è¡Œå®ç°ï¼Œå¦‚ dubbo-remoting-netty å­æ¨¡å—ä¾èµ– Netty 3 å®ç°è¿œç¨‹é€šä¿¡ã€‚ dubbo-rpc æ¨¡å— Dubbo çš„è¿œç¨‹è°ƒç”¨åè®®æ¨¡å—ï¼Œå…¶ä¸­æŠ½è±¡äº†å„ç§åè®®ï¼Œä¾èµ–äºè¿œç¨‹é€šä¿¡æ¨¡å—çš„è¿œç¨‹è°ƒç”¨åŠŸèƒ½ã€‚dubbo-rpc-api å­æ¨¡å—ä¸­å®šä¹‰äº†è°ƒç”¨åè®®çš„æŠ½è±¡ï¼Œå…¶å®ƒå­æ¨¡å—æ˜¯é’ˆå¯¹å…·ä½“åè®®çš„å®ç°ï¼Œå¦‚ dubbo-rpc-dubbo å­æ¨¡å—æ˜¯å¯¹ Dubbo åè®®çš„å®ç°ï¼Œä¾èµ–äº† dubbo-remoting æ¨¡å—ä¸­çš„ Netty ç­‰å­æ¨¡å—ã€‚æ³¨æ„ï¼Œdubbo-rpc æ¨¡å—çš„å®ç°ä¸­åªåŒ…å«ä¸€å¯¹ä¸€çš„è°ƒç”¨ï¼Œä¸å…³å¿ƒé›†ç¾¤çš„å†…å®¹ã€‚ dubbo-cluster æ¨¡å— Dubbo ä¸­è´Ÿè´£ç®¡ç†é›†ç¾¤çš„æ¨¡å—ï¼Œæä¾›äº†è´Ÿè½½å‡è¡¡ã€è·¯ç”±ã€å®¹é”™ç­‰é›†ç¾¤ç›¸å…³çš„åŠŸèƒ½ã€‚ dubbo-registry æ¨¡å— Dubbo ä¸­è´Ÿè´£ä¸å¤šç§æ³¨å†Œä¸­å¿ƒäº¤äº’çš„æ¨¡å—ï¼Œæä¾›æ³¨å†Œä¸­å¿ƒçš„èƒ½åŠ›ã€‚dubbo-registry-api å­æ¨¡å—æ˜¯å¯¹æ³¨å†Œä¸­å¿ƒçš„æŠ½è±¡ï¼Œå…¶å®ƒå­æ¨¡å—æ˜¯é’ˆå¯¹å…·ä½“æ³¨å†Œä¸­å¿ƒçš„å®ç°ï¼Œå¦‚ dubbo-registry-zookeeper å­æ¨¡å—æ˜¯ Dubbo æ¥å…¥ Zookeeper çš„å…·ä½“å®ç°ã€‚ dubbo-config æ¨¡å— Dubbo çš„é…ç½®ä¿¡æ¯æ˜¯ç”±è¯¥æ¨¡å—å®šä¹‰å’Œè§£æçš„ã€‚dubbo-config-api å­æ¨¡å—è´Ÿè´£å¤„ç† API æ–¹å¼çš„ç›¸å…³é…ç½®ï¼Œdubbo-config-spring å­æ¨¡å—è´Ÿè´£å¤„ç†ä¸ Spring é›†æˆæ–¹å¼çš„ç›¸å…³é…ç½®ã€‚æœ‰äº†é…ç½®æ¨¡å—ï¼Œå¼€å‘è€…åªéœ€è¦æ ¹æ® Dubbo çš„é…ç½®è§„åˆ™å»å®ç°åŠŸèƒ½å³å¯ï¼Œåº•å±‚å®ç°äº¤ç»™ Dubbo çš„å„ä¸ªæ¨¡å—å»å®Œæˆã€‚ dubbo-serialization æ¨¡å— Dubbo çš„åºåˆ—åŒ–æ¨¡å—ï¼Œæ˜¯ Dubbo è®¾è®¡çš„æœ€åä¸€å±‚ï¼Œè´Ÿè´£ç®¡ç†æ•´ä¸ªæ¡†æ¶ç½‘ç»œä¼ è¾“æ—¶çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–å·¥ä½œã€‚ dubbo-serialization-api å­æ¨¡å—æ˜¯å¯¹åºåˆ—åŒ–å’Œååºåˆ—æŠ½è±¡å®šä¹‰ï¼ŒåŒ…å«äº†å¾ˆå¤šçš„æ¥å£ï¼Œå…¶å®ƒå­æ¨¡å—é’ˆå¯¹å…·ä½“çš„åºåˆ—åŒ–æ–¹å¼è¿›è¡Œå®ç°ï¼Œå¦‚ dubbo-serialization-fastjson å­æ¨¡å—æ˜¯å¯¹ fastjson çš„å…·ä½“å®ç°ã€‚ å°ç»“æœ¬ç¯‡æ–‡ç« ç®€å•ä»‹ç»äº† Dubbo çš„æ ¸å¿ƒæ¶æ„åŠæ ¸å¿ƒç»„ä»¶çš„åŠŸèƒ½ï¼Œè¯´æ˜äº†æ­å»º Dubbo æºç ç¯å¢ƒæ­¥éª¤ï¼Œæœ€åä»‹ç»äº† Dubbo æ ¸å¿ƒæ¨¡å—ï¼Œä¸ºåç»­åˆ†æ Dubbo æºç åšå‡†å¤‡ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"}]},{"title":"Dubboé¡¹ç›®ç»“æ„æ€»è§ˆ","slug":"rpc/dubboé¡¹ç›®ç»“æ„æ€»è§ˆ","date":"2020-03-07T16:00:00.000Z","updated":"2020-10-17T05:29:32.637Z","comments":false,"path":"posts/e2577ca1/","link":"","permalink":"https://gentryhuang.com/posts/e2577ca1/","excerpt":"","text":"å‰è¨€dubboæºç åˆ†æç›¸å…³æ–‡ç« ä½¿ç”¨çš„dubboç‰ˆæœ¬ä¸º2.6.5ï¼Œå¦‚ä½¿ç”¨å…¶å®ƒç‰ˆæœ¬ä¼šæ˜¾ç¤ºè¯´æ˜ã€‚å‚è€ƒæ–‡æ¡£ä»¥å®˜æ–¹æ–‡æ¡£ ä¸ºä¸»ã€å®˜ç½‘æ–‡æ¡£å†™çš„å¤ªå¥½äº†ã€‘ï¼Œå‚è€ƒä¹¦ç±ã€Šæ·±å…¥ç†è§£Apache Dubboä¸å®æˆ˜ã€‹ã€‚ æ¡†æ¶è®¾è®¡ç”±äºdubboå®˜æ–¹æ–‡æ¡£å†™çš„éå¸¸å¥½ï¼Œè¿™é‡Œä¼šå¤§é‡å¼•ç”¨ç›¸å…³çš„å›¾ç‰‡åŠè¯´æ˜ï¼Œç‚¹æˆ‘ è¿›å…¥å®˜æ–¹æ–‡æ¡£ã€‚ æ•´ä½“è®¾è®¡ å›¾ä¾‹è¯´æ˜ï¼š å›¾ä¸­å·¦è¾¹æ·¡è“èƒŒæ™¯çš„ä¸ºæœåŠ¡æ¶ˆè´¹æ–¹ä½¿ç”¨çš„æ¥å£ï¼Œå³è¾¹æ·¡ç»¿è‰²èƒŒæ™¯çš„ä¸ºæœåŠ¡æä¾›æ–¹ä½¿ç”¨çš„æ¥å£ï¼Œä½äºä¸­è½´çº¿ä¸Šçš„ä¸ºåŒæ–¹éƒ½ç”¨åˆ°çš„æ¥å£ã€‚ å›¾ä¸­ä»ä¸‹è‡³ä¸Šåˆ†ä¸ºåå±‚ï¼Œå„å±‚å‡ä¸ºå•å‘ä¾èµ–ï¼Œå³è¾¹çš„é»‘è‰²ç®­å¤´ä»£è¡¨å±‚ä¹‹é—´çš„ä¾èµ–å…³ç³»ï¼Œæ¯ä¸€å±‚éƒ½å¯ä»¥å‰¥ç¦»ä¸Šå±‚è¢«å¤ç”¨ï¼Œå…¶ä¸­ï¼ŒService å’Œ Config å±‚ä¸º APIï¼Œå…¶å®ƒå„å±‚å‡ä¸º SPIã€‚ å›¾ä¸­ç»¿è‰²å°å—çš„ä¸ºæ‰©å±•æ¥å£ï¼Œè“è‰²å°å—ä¸ºå®ç°ç±»ï¼Œå›¾ä¸­åªæ˜¾ç¤ºç”¨äºå…³è”å„å±‚çš„å®ç°ç±»ã€‚ å›¾ä¸­è“è‰²è™šçº¿ä¸ºåˆå§‹åŒ–è¿‡ç¨‹ï¼Œå³å¯åŠ¨æ—¶ç»„è£…é“¾ï¼Œçº¢è‰²å®çº¿ä¸ºæ–¹æ³•è°ƒç”¨è¿‡ç¨‹ï¼Œå³è¿è¡Œæ—¶è°ƒæ—¶é“¾ï¼Œç´«è‰²ä¸‰è§’ç®­å¤´ä¸ºç»§æ‰¿ï¼Œå¯ä»¥æŠŠå­ç±»çœ‹ä½œçˆ¶ç±»çš„åŒä¸€ä¸ªèŠ‚ç‚¹ï¼Œçº¿ä¸Šçš„æ–‡å­—ä¸ºè°ƒç”¨çš„æ–¹æ³•ã€‚ æ€»ä½“åˆ†å±‚ä»æ•´ä½“è®¾è®¡è®¾è®¡å›¾å¯çŸ¥æ‚‰ï¼Œdubboçš„æ€»ä½“åˆ†ä¸ºä¸šåŠ¡å±‚(Business)ã€RPCå±‚ã€Remoteä¸‰å±‚ï¼Œæ¯ä¸€å±‚ç»†åˆ†å…±å¯åˆ†æˆåå±‚ã€‚Serviceå’ŒConfigä¸¤å±‚å¯ä»¥è®¤ä¸ºæ˜¯APIå±‚ï¼Œä¸»è¦æä¾›ç»™APIä½¿ç”¨è€…ï¼Œä½¿ç”¨è€…æ— é¡»å…³å¿ƒåº•å±‚çš„å®ç°ï¼Œåªéœ€è¦é…ç½®å’Œå®Œæˆä¸šåŠ¡ä»£ç å³å¯ã€‚å…¶å®ƒå…«å±‚åˆåœ¨ä¸€èµ·å¯ä»¥è®¤ä¸ºæ˜¯SPIå±‚ï¼Œç”¨äºæ‰©å±•ï¼Œå³å¼€æ”¾è€…å¯ä»¥åŸºäºSPIå±‚è‡ªå®šä¹‰ä¸€äº›ç»„ä»¶æ¥å®Œæˆå…·ä½“ä¸šåŠ¡ï¼Œä¹Ÿå¯ä»¥åŸºäºdubboæ¡†æ¶åšå®šåˆ¶æ€§çš„äºŒæ¬¡å¼€å‘ã€‚ dubboæ ¸å¿ƒç»„ä»¶dubboä¸­æ¯å±‚éƒ½ä»£è¡¨äº†ä¸åŒçš„é€»è¾‘å®ç°ï¼Œå®ƒä»¬æ˜¯ä¸€ä¸ªä¸ªç»„ä»¶ï¼Œè¿™äº›ç»„ä»¶æ„æˆäº†æ•´ä¸ªdubboä½“ç³»ã€‚å¯¹äºä½¿ç”¨æ–¹æ¥è¯´æ›´å¤šæ¥è§¦åˆ°çš„æ˜¯é…ç½®ï¼ŒæŒ‰ç…§dubboé…ç½®è§„åˆ™é€‰æ‹©é€‚åˆå½“å‰ä¸šåŠ¡çš„é…ç½®é¡¹å³å¯è½»æ¾å®ç°rpcè°ƒç”¨ã€‚æ­£æ˜¯ç”±äºdubboçš„å„ä¸ªç»„ä»¶èŒè´£åˆ†æ˜çš„è®¾è®¡ï¼Œæ‰ä½¿å¾—dubboæ¡†æ¶èƒ½å¤Ÿåšåˆ°é«˜æ‰©å±•æ€§ã€‚dubboæ ¸å¿ƒç»„ä»¶å¦‚ä¸‹è¡¨ï¼š åˆ†å±‚å ä½œç”¨ service ä¸šåŠ¡å±‚ï¼šåŒ…æ‹¬ä¸šåŠ¡ä»£ç çš„æ¥å£ä¸å®ç°ï¼Œå³å¼€å‘è€…å®ç°çš„ä¸šåŠ¡ä»£ç ã€‚ config é…ç½®å±‚ï¼šä¸»è¦å›´ç»•ServiceConfigï¼ˆæœåŠ¡æä¾›æ–¹é…ç½®ï¼‰å’ŒReferenceConfigï¼ˆæœåŠ¡æ¶ˆè´¹æ–¹ï¼‰å±•å¼€ï¼Œåˆå§‹åŒ–é…ç½®ä¿¡æ¯ã€‚å¯ä»¥ç†è§£ä¸ºè¯¥å±‚ç®¡ç†äº†æ•´ä¸ªdubboçš„é…ç½® proxy æœåŠ¡ä»£ç†å±‚ï¼šåœ¨dubboä¸­ï¼Œæ— è®ºæä¾›è€…è¿˜æ˜¯æ¶ˆè´¹è€…ï¼Œæ¡†æ¶éƒ½ä¼šç”Ÿæˆä¸€ä¸ªä»£ç†ç±»ï¼Œæ•´ä¸ªè¿‡ç¨‹å¯¹ä¸Šå±‚æ˜¯é€æ˜çš„ã€‚å½“è°ƒç”¨ä¸€ä¸ªè¿œç¨‹æ¥å£æ—¶ï¼Œçœ‹èµ·æ¥å°±åƒæ˜¯è°ƒç”¨äº†ä¸€ä¸ªæœ¬åœ°æ¥å£ä¸€æ ·ï¼Œä»£ç†å±‚ä¼šè‡ªåŠ¨åšè¿œç¨‹è°ƒç”¨å¹¶è¿”å›ç»“æœï¼Œå³è®©ä¸šåŠ¡å±‚å¯¹è¿œç¨‹è°ƒç”¨å®Œå…¨æ— æ„ŸçŸ¥ registry æ³¨å†Œä¸­å¿ƒå±‚ï¼šè´Ÿè´£dubboæ¡†æ¶çš„æœåŠ¡æ³¨å†Œä¸å‘ç°ã€‚å½“æœ‰æ–°çš„æœåŠ¡åŠ å…¥æˆ–æ—§æœåŠ¡ä¸‹çº¿æ—¶ï¼Œæ³¨å†Œä¸­å¿ƒéƒ½ä¼šæ„ŸçŸ¥å¹¶é€šçŸ¥ç»™æ‰€æœ‰è®¢é˜…æ–¹ cluster é›†ç¾¤å®¹é”™å±‚ï¼šæä¾›å¤šç§å®¹é”™ç­–ç•¥ã€å°è£…å¤šä¸ªæä¾›è€…çš„è·¯ç”±åŠè´Ÿè½½å‡è¡¡ï¼Œå¹¶æ¡¥æ¥æ³¨å†Œä¸­å¿ƒï¼Œä»¥ Invoker ä¸ºä¸­å¿ƒï¼Œæ‰©å±•æ¥å£ä¸º Cluster, Directory, Router, LoadBalanceä»¥åŠMock monitor ç›‘æ§å±‚ï¼šRPC è°ƒç”¨æ¬¡æ•°å’Œè°ƒç”¨æ—¶é—´ç›‘æ§ç­‰ protocol è¿œç¨‹è°ƒç”¨å±‚ï¼šå°è£…RPCè°ƒç”¨å…·ä½“è¿‡ç¨‹ï¼Œä»¥ Invocation, Result ä¸ºä¸­å¿ƒï¼Œæ˜¯ Invoker æš´éœ²å’Œå¼•ç”¨çš„ä¸»åŠŸèƒ½å…¥å£ï¼Œå®ƒè´Ÿè´£ Invoker çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚ exchange ä¿¡æ¯äº¤æ¢å±‚ï¼šå»ºç«‹Request-Responseæ¨¡å‹ï¼Œå°è£…è¯·æ±‚å“åº”æ¨¡å¼ï¼Œä»¥ Request, Response ä¸ºä¸­å¿ƒ transport ç½‘ç»œä¼ è¾“å±‚ï¼šæŠŠç½‘ç»œä¼ è¾“æŠ½è±¡ä¸ºç»Ÿä¸€æ¥å£ï¼Œä»¥ Message ä¸ºä¸­å¿ƒï¼Œå¦‚Minaå’ŒNettyè™½ç„¶æ¥å£ä¸ä¸€æ ·ï¼Œä½†æ˜¯Dubboåœ¨å®ƒä»¬ä¸Šé¢å°è£…äº†ç»Ÿä¸€çš„æ¥å£ã€‚ç”¨æˆ·å¯ä»¥æ ¹æ®å…¶æ‰©å±•æ¥å£æ·»åŠ æ›´å¤šçš„ç½‘ç»œä¼ è¾“æ–¹å¼ã€‚ serialize åºåˆ—åŒ–å±‚ï¼šå¦‚æœæ•°æ®è¦é€šè¿‡ç½‘ç»œè¿›è¡Œä¼ è¾“ï¼Œåˆ™éœ€è¦å…ˆåšåºåˆ—åŒ–ï¼Œè½¬æˆäºŒè¿›åˆ¶æµã€‚åºåˆ—åŒ–å±‚è´Ÿè´£ç®¡ç†æ•´ä¸ªæ¡†æ¶ç½‘ç»œä¼ è¾“æ—¶çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–å·¥ä½œ å…³ç³»è¯´æ˜ åœ¨ RPC ä¸­ï¼ŒProtocol æ˜¯æ ¸å¿ƒå±‚ï¼Œä¹Ÿå°±æ˜¯åªè¦æœ‰ Protocol + Invoker + Exporter å°±å¯ä»¥å®Œæˆéé€æ˜çš„ RPC è°ƒç”¨ï¼Œç„¶ååœ¨ Invoker çš„ä¸»è¿‡ç¨‹ä¸Š Filter æ‹¦æˆªç‚¹ã€‚ å›¾ä¸­çš„ Consumer å’Œ Provider æ˜¯æŠ½è±¡æ¦‚å¿µï¼Œåªæ˜¯æƒ³è®©çœ‹å›¾è€…æ›´ç›´è§‚çš„äº†è§£å“ªäº›ç±»åˆ†å±äºå®¢æˆ·ç«¯ä¸æœåŠ¡å™¨ç«¯ï¼Œä¸ç”¨ Client å’Œ Server çš„åŸå› æ˜¯ Dubbo åœ¨å¾ˆå¤šåœºæ™¯ä¸‹éƒ½ä½¿ç”¨ Provider, Consumer, Registry, Monitor åˆ’åˆ†é€»è¾‘æ‹“æ™®èŠ‚ç‚¹ï¼Œä¿æŒç»Ÿä¸€æ¦‚å¿µã€‚ è€Œ Cluster æ˜¯å¤–å›´æ¦‚å¿µï¼Œæ‰€ä»¥ Cluster çš„ç›®çš„æ˜¯å°†å¤šä¸ª Invoker ä¼ªè£…æˆä¸€ä¸ª Invokerï¼Œè¿™æ ·å…¶å®ƒäººåªè¦å…³æ³¨ Protocol å±‚ Invoker å³å¯ï¼ŒåŠ ä¸Š Cluster æˆ–è€…å»æ‰ Cluster å¯¹å…¶å®ƒå±‚éƒ½ä¸ä¼šé€ æˆå½±å“ï¼Œå› ä¸ºåªæœ‰ä¸€ä¸ªæä¾›è€…æ—¶ï¼Œæ˜¯ä¸éœ€è¦ Cluster çš„ã€‚ Proxy å±‚å°è£…äº†æ‰€æœ‰æ¥å£çš„é€æ˜åŒ–ä»£ç†ï¼Œè€Œåœ¨å…¶å®ƒå±‚éƒ½ä»¥ Invoker ä¸ºä¸­å¿ƒï¼Œåªæœ‰åˆ°äº†æš´éœ²ç»™ç”¨æˆ·ä½¿ç”¨æ—¶ï¼Œæ‰ç”¨ Proxy å°† Invoker è½¬æˆæ¥å£ï¼Œæˆ–å°†æ¥å£å®ç°è½¬æˆ Invokerï¼Œä¹Ÿå°±æ˜¯å»æ‰ Proxy å±‚ RPC æ˜¯å¯ä»¥ Run çš„ï¼Œåªæ˜¯ä¸é‚£ä¹ˆé€æ˜ï¼Œä¸é‚£ä¹ˆçœ‹èµ·æ¥åƒè°ƒæœ¬åœ°æœåŠ¡ä¸€æ ·è°ƒè¿œç¨‹æœåŠ¡ã€‚ è€ŒRemoting å®ç°æ˜¯ Dubbo åè®®çš„å®ç°ï¼Œå¦‚æœä½ é€‰æ‹© RMI åè®®ï¼Œæ•´ä¸ª Remoting éƒ½ä¸ä¼šç”¨ä¸Šï¼ŒRemoting å†…éƒ¨å†åˆ’ä¸º Transport ä¼ è¾“å±‚å’Œ Exchange ä¿¡æ¯äº¤æ¢å±‚ï¼ŒTransport å±‚åªè´Ÿè´£å•å‘æ¶ˆæ¯ä¼ è¾“ï¼Œæ˜¯å¯¹ Mina, Netty, Grizzly çš„æŠ½è±¡ï¼Œå®ƒä¹Ÿå¯ä»¥æ‰©å±• UDP ä¼ è¾“ï¼Œè€Œ Exchange å±‚æ˜¯åœ¨ä¼ è¾“å±‚ä¹‹ä¸Šå°è£…äº† Request-Response è¯­ä¹‰ã€‚ Registry å’Œ Monitor å®é™…ä¸Šä¸ç®—ä¸€å±‚ï¼Œè€Œæ˜¯ä¸€ä¸ªç‹¬ç«‹çš„èŠ‚ç‚¹ï¼Œåªæ˜¯ä¸ºäº†å…¨å±€æ¦‚è§ˆï¼Œç”¨å±‚çš„æ–¹å¼ç”»åœ¨ä¸€èµ·ã€‚ é¢†åŸŸæ¨¡å‹ Protocol æ˜¯æœåŠ¡åŸŸï¼Œå®ƒæ˜¯ Invoker æš´éœ²å’Œå¼•ç”¨çš„ä¸»åŠŸèƒ½å…¥å£ï¼Œå®ƒè´Ÿè´£ Invoker çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚ Invoker æ˜¯å®ä½“åŸŸï¼Œå®ƒæ˜¯ Dubbo çš„æ ¸å¿ƒæ¨¡å‹ï¼Œå…¶å®ƒæ¨¡å‹éƒ½å‘å®ƒé æ‰°ï¼Œæˆ–è½¬æ¢æˆå®ƒï¼Œå®ƒä»£è¡¨ä¸€ä¸ªå¯æ‰§è¡Œä½“ï¼Œå¯å‘å®ƒå‘èµ· invoke è°ƒç”¨ï¼Œå®ƒæœ‰å¯èƒ½æ˜¯ä¸€ä¸ªæœ¬åœ°çš„å®ç°ï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ªè¿œç¨‹çš„å®ç°ï¼Œä¹Ÿå¯èƒ½ä¸€ä¸ªé›†ç¾¤å®ç°ã€‚ Invocation æ˜¯ä¼šè¯åŸŸï¼Œå®ƒæŒæœ‰è°ƒç”¨è¿‡ç¨‹ä¸­çš„å˜é‡ï¼Œæ¯”å¦‚æ–¹æ³•åï¼Œå‚æ•°ç­‰ã€‚ ç‰¹åˆ«è¯´æ˜: protocolæ˜¯å¯¹æ•°æ®æ ¼å¼çš„ä¸€ç§çº¦å®šï¼Œå®ƒå¯ä»¥æŠŠæˆ‘ä»¬å¯¹æ¥å£çš„é…ç½®ï¼Œæ ¹æ®å…·ä½“çš„åè®®è½¬æ¢æˆä¸åŒçš„Invokerå¯¹è±¡ã€‚ åŸºæœ¬è®¾è®¡åŸåˆ™ Dubbo è‡ªèº«çš„åŠŸèƒ½ä¹Ÿæ˜¯é€šè¿‡æ‰©å±•ç‚¹å®ç°çš„ï¼Œä¹Ÿå°±æ˜¯ Dubbo çš„æ‰€æœ‰åŠŸèƒ½ç‚¹éƒ½å¯è¢«ç”¨æˆ·è‡ªå®šä¹‰æ‰©å±•æ‰€æ›¿æ¢ é‡‡ç”¨ URL ä½œä¸ºé…ç½®ä¿¡æ¯çš„ç»Ÿä¸€æ ¼å¼ï¼Œæ‰€æœ‰æ‰©å±•ç‚¹éƒ½é€šè¿‡ä¼ é€’ URL æºå¸¦é…ç½®ä¿¡æ¯ æºç åˆ†æèŒƒå›´é™¤äº†æ¶æ„å›¾ä¸­çš„Monitoræ¨¡å—ä¸ä¼šè¯¦ç»†åˆ†æï¼Œå…¶å®ƒéƒ½ä¼šè¯¦ç»†åˆ†æã€‚ å°ç»“æœ¬æ–‡ä¸»è¦ç®€å•ä»‹ç»äº†dubboçš„æ€»ä½“æ¶æ„å›¾å’Œæ ¸å¿ƒç»„ä»¶ï¼Œè¿™æ ·åœ¨é˜…è¯»æºç ä¹‹å‰æœ‰æ•´ä½“çš„æ¦‚å¿µã€‚æ›´è¯¦ç»†çš„ä»‹ç»å¯ä»¥å‚è€ƒå®˜ç½‘æ–‡æ¡£ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"Dubboç¤ºä¾‹ - æ³¨è§£é…ç½®","slug":"rpc/Dubboç¬¬ä¸‰ä¾‹","date":"2020-03-05T16:00:00.000Z","updated":"2020-09-01T12:12:42.307Z","comments":false,"path":"posts/7202a9c0/","link":"","permalink":"https://gentryhuang.com/posts/7202a9c0/","excerpt":"","text":"å¿«é€Ÿå¯åŠ¨ä½¿ç”¨æ³¨è§£çš„æ–¹å¼è¿›è¡Œé…ç½® å®šä¹‰æœåŠ¡æ¥å£12345678910package com.alibaba.dubbo.examples.annotation.api;/** * AnnotationService */public interface AnnotationService &#123; String sayHello(String name);&#125; æœåŠ¡æä¾›æ–¹123456789101112131415161718package com.alibaba.dubbo.examples.annotation.impl;import com.alibaba.dubbo.config.annotation.Service;import com.alibaba.dubbo.examples.annotation.api.AnnotationService;/** * AnnotationServiceImplï¼Œæ³¨æ„ï¼Œè¿™é‡Œ @Service æ³¨è§£æ˜¯Dubboçš„æ³¨è§£ï¼Œç”¨æ¥è¿›è¡ŒæœåŠ¡æš´éœ²çš„ */@Servicepublic class AnnotationServiceImpl implements AnnotationService &#123; @Override public String sayHello(String name) &#123; System.out.println(\"async provider received: \" + name); return \"annotation: hello, \" + name; &#125;&#125; æœåŠ¡æä¾›æ–¹å±æ€§é…ç½®12345# dubbo-provider.propertiesdubbo.application.name&#x3D;annotation-providerdubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181dubbo.protocol.name&#x3D;dubbodubbo.protocol.port&#x3D;20880 è¯´æ˜: ä½¿ç”¨dubboæ³¨è§£å½¢å¼ä¸€èˆ¬ç»“åˆå±æ€§é…ç½®ï¼Œç”¨æ¥é…ç½®åº”ç”¨å…±äº«çš„é…ç½®é¡¹ã€‚ æŒ‡å®šæ‰«æè·¯å¾„ï¼Œå¯åŠ¨å®¹å™¨å¹¶æš´éœ²æœåŠ¡12345678910111213141516171819202122232425262728293031323334353637383940package com.alibaba.dubbo.examples.annotation;import com.alibaba.dubbo.config.ProviderConfig;import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;/** * AnnotationProvider * * Java Config + æ³¨è§£çš„æ–¹å¼ */public class AnnotationProvider &#123; public static void main(String[] args) throws Exception &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ProviderConfiguration.class); context.start(); System.in.read(); &#125; @Configuration @EnableDubbo(scanBasePackages = \"com.alibaba.dubbo.examples.annotation.impl\") @PropertySource(\"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-provider.properties\") static public class ProviderConfiguration &#123; /** * è¿™é‡Œé€šè¿‡Java Configæ˜¾ç¤ºç»„è£…å‡ºBeanï¼Œä¼šæ³¨å…¥ç»™DubboæœåŠ¡ï¼Œå³æ ‡æ³¨æœ‰@Serviceçš„ç±»ã€‚å¦‚æœä¸æ˜¾ç¤ºè£…é…ï¼ŒDubboä¼šé»˜è®¤åˆ›å»ºå†…ç½®çš„é…ç½®ç±»å®šä¹‰ï¼Œåˆ›å»ºå†…ç½®çš„é…ç½®ç±»å®šä¹‰çš„å‰ææ˜¯é…ç½®äº†ç›¸å…³çš„å±æ€§ï¼Œå¦åˆ™ä¸ä¼šåˆ›å»ºã€‚å…¶ä»–é…ç½®ç±»ä¼¼ã€‚ */ @Bean public ProviderConfig providerConfig() &#123; ProviderConfig providerConfig = new ProviderConfig(); providerConfig.setTimeout(5000); return providerConfig; &#125; &#125;&#125; æœåŠ¡æ¶ˆè´¹æ–¹123456789101112131415161718192021package com.alibaba.dubbo.examples.annotation.action;import com.alibaba.dubbo.config.annotation.Reference;import com.alibaba.dubbo.examples.annotation.api.AnnotationService;import org.springframework.stereotype.Component;/** * AnnotationActionï¼Œæ³¨æ„ï¼Œ@Referenceæ³¨è§£ç”¨æ¥å¼•ç”¨æœåŠ¡ */@Component(\"annotationAction\")public class AnnotationAction &#123; @Reference private AnnotationService annotationService; public String doSayHello(String name) &#123; return annotationService.sayHello(name); &#125;&#125; æœåŠ¡æ¶ˆè´¹æ–¹å±æ€§é…ç½®1234# dubbo-consumer.propertiesdubbo.application.name&#x3D;annotation-consumerdubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181dubbo.consumer.timeout&#x3D;3000 è¯´æ˜: ä½¿ç”¨dubboæ³¨è§£å½¢å¼ä¸€èˆ¬ç»“åˆå±æ€§é…ç½®ï¼Œç”¨æ¥é…ç½®åº”ç”¨å…±äº«çš„é…ç½®é¡¹ã€‚ æ‰«æè·¯å¾„ï¼Œå¯åŠ¨å®¹å™¨å¹¶è°ƒç”¨æœåŠ¡123456789101112131415161718192021222324252627282930313233343536373839404142package com.alibaba.dubbo.examples.annotation;import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;import com.alibaba.dubbo.examples.annotation.action.AnnotationAction;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;/** * AnnotationConsumer */public class AnnotationConsumer &#123; public static void main(String[] args) throws Exception &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConsumerConfiguration.class); context.start(); final AnnotationAction annotationAction = (AnnotationAction) context.getBean(\"annotationAction\"); String hello = annotationAction.doSayHello(\"world\"); System.out.println(\"result :\" + hello); System.in.read(); &#125; @Configuration @EnableDubbo(scanBasePackages = \"com.alibaba.dubbo.examples.annotation.action\") @PropertySource(\"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-consumer.properties\") @ComponentScan(value = &#123;\"com.alibaba.dubbo.examples.annotation.action\"&#125;) static public class ConsumerConfiguration &#123; /** * è¿™é‡Œé€šè¿‡Java Configæ˜¾ç¤ºç»„è£…å‡ºBeanï¼Œä¼šæ³¨å…¥ç»™DubboæœåŠ¡ï¼Œå³æ ‡æ³¨æœ‰@Referenceçš„ç±»ã€‚å¦‚æœä¸æ˜¾ç¤ºè£…é…ï¼ŒDubboä¼šé»˜è®¤åˆ›å»ºå†…ç½®çš„é…ç½®ç±»å®šä¹‰ï¼Œåˆ›å»ºå†…ç½®çš„é…ç½®ç±»å®šä¹‰çš„å‰ææ˜¯é…ç½®äº†ç›¸å…³çš„å±æ€§ï¼Œå¦åˆ™ä¸ä¼šåˆ›å»ºã€‚å…¶ä»–é…ç½®ç±»ä¼¼ã€‚ */ @Bean public ConsumerConfig consumerConfig() &#123; ConsumerConfig consumerConfig = new ConsumerConfig(); consumerConfig.setTimeout(3000); return consumerConfig; &#125; &#125;&#125; å°ç»“æ³¨è§£å®ç°ä½¿ä»£ç æ›´æ•´æ´ï¼Œå¼€å‘æ•ˆç‡æ›´é«˜ï¼Œéšç€æ³¨è§£å’Œé…ç½®åŒ–çš„ç››è¡Œï¼Œxmlçš„æ–¹å¼ä¼šæ¸æ¸åœ°æ·¡å‡ºèˆå°ã€‚ä½†ä½¿ç”¨æ³¨è§£å¯¹å¼€æ”¾è€…çš„è¦æ±‚æ›´é«˜ï¼Œå…·ä½“çš„dubboæ³¨è§£å¦‚ä½•ä¸Springèåˆï¼Œåœ¨åé¢çš„ç« èŠ‚ä¸­ä¼šè¿›è¡Œè¯´æ˜ã€‚ä½¿ç”¨æ³¨è§£çš„æ–¹å¼ï¼Œé…ç½®å¯¹è±¡çš„åˆ›å»ºåŠé…ç½®å¯¹è±¡å±æ€§è®¾ç½®ä¹Ÿéƒ½æ˜¯Springå®Œæˆçš„ï¼Œæ³¨æ„è¿™é‡ŒSpringå®Œæˆé…ç½®å±æ€§åœ°è®¾ç½®æ˜¯æŒ‡å¯åŠ¨åŠ è½½çš„é…ç½®å±æ€§ï¼Œå¦‚ä¸Šé¢ä¾‹å­ä¸­çš„@PropertySourceæ³¨è§£å¼•å…¥çš„é…ç½®æ–‡ä»¶å†…å®¹ï¼Œæ­¤å¤–@Serviceã€@Referenceæ³¨è§£ä¸­çš„å±æ€§Springä¼šè‡ªåŠ¨ç»‘å®šåˆ°é…ç½®å¯¹è±¡ä¸­ï¼Œè‡³äºç³»ç»Ÿå‚æ•°ã€dubbo.propertiesä¸­çš„é…ç½®å‚æ•°ç­‰æ˜¯dubboæ¡†æ¶è‡ªåŠ¨åŠ è½½å¹¶é…ç½®çš„ï¼Œæˆ‘ä»¬å¯åœ¨æœåŠ¡æš´éœ²å’ŒæœåŠ¡å¼•ç”¨ä¸­çœ‹åˆ°å…·ä½“çš„è¿‡ç¨‹ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"Dubboç¤ºä¾‹ - XMLé…ç½®","slug":"rpc/Dubboç¬¬äºŒä¾‹","date":"2020-03-03T16:00:00.000Z","updated":"2020-08-15T15:30:22.534Z","comments":false,"path":"posts/3f1c0a92/","link":"","permalink":"https://gentryhuang.com/posts/3f1c0a92/","excerpt":"","text":"å¿«é€Ÿå¯åŠ¨ä½¿ç”¨xmlçš„æ–¹å¼è¿›è¡Œé…ç½®ï¼Œè¯¦ç»†é…ç½®é¡¹ï¼šé…ç½®å‚è€ƒæ‰‹å†Œ å®šä¹‰æœåŠ¡æ¥å£12345package com.alibaba.dubbo.demo;public interface DemoService &#123; String sayHello(String name);&#125; æœåŠ¡æä¾›æ–¹å®ç°æ¥å£12345678910111213141516package com.alibaba.dubbo.demo.provider;import com.alibaba.dubbo.demo.DemoService;import com.alibaba.dubbo.rpc.RpcContext;import java.text.SimpleDateFormat;import java.util.Date;public class DemoServiceImpl implements DemoService &#123; @Override public String sayHello(String name) &#123; System.out.println(\"[\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()) + \"] Hello \" + name + \", request from consumer: \" + RpcContext.getContext().getRemoteAddress()); return \"Hello \" + name + \", response from provider: \" + RpcContext.getContext().getLocalAddress(); &#125;&#125; æœåŠ¡æä¾›æ–¹æœåŠ¡æš´éœ²é…ç½®1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- æä¾›æ–¹åº”ç”¨ä¿¡æ¯ï¼Œç”¨äºè®¡ç®—ä¾èµ–å…³ç³» --&gt; &lt;dubbo:application name=\"demo-provider\" owner=\"gentryhuang\"/&gt; &lt;!-- ä½¿ç”¨zookeeperæ³¨å†Œä¸­å¿ƒæš´éœ²æœåŠ¡åœ°å€ --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- ç”¨dubboåè®®åœ¨20880ç«¯å£æš´éœ²æœåŠ¡ --&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!-- å£°æ˜éœ€è¦æš´éœ²çš„æœåŠ¡æ¥å£ --&gt; &lt;bean id=\"demoService\" class=\"com.alibaba.dubbo.demo.provider.DemoServiceImpl\"/&gt; &lt;!-- å’Œæœ¬åœ°beanä¸€æ ·å®ç°æœåŠ¡ --&gt; &lt;dubbo:service interface=\"com.alibaba.dubbo.demo.DemoService\" ref=\"demoService\"/&gt;&lt;/beans&gt; å¯åŠ¨Springå®¹å™¨ï¼Œè¿›è¡ŒæœåŠ¡æš´éœ²12345678910111213package com.alibaba.dubbo.demo.provider;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Provider &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;\"META-INF/spring/dubbo-demo-provider.xml\"&#125;); context.start(); System.in.read(); // press any key to exit &#125;&#125; æœåŠ¡æ¶ˆè´¹è€…å¼•ç”¨æœåŠ¡é…ç½®1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- æ¶ˆè´¹æ–¹åº”ç”¨åï¼Œç”¨äºè®¡ç®—ä¾èµ–å…³ç³»ï¼Œä¸æ˜¯åŒ¹é…æ¡ä»¶ï¼Œä¸è¦ä¸æä¾›æ–¹ä¸€æ · --&gt; &lt;dubbo:application name=\"demo-consumer\"/&gt; &lt;!-- ä½¿ç”¨zookeeperæ³¨å†Œä¸­å¿ƒæš´éœ²å‘ç°æœåŠ¡åœ°å€ --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- ç”Ÿæˆè¿œç¨‹æœåŠ¡ä»£ç†ï¼Œå¯ä»¥å’Œæœ¬åœ°beanä¸€æ ·ä½¿ç”¨demoService --&gt; &lt;dubbo:reference id=\"demoService\" check=\"false\" interface=\"com.alibaba.dubbo.demo.DemoService\"/&gt;&lt;/beans&gt; åŠ è½½Springé…ç½®ï¼Œå¹¶è°ƒç”¨è¿œç¨‹æœåŠ¡123456789101112131415161718192021222324package com.alibaba.dubbo.demo.consumer;import com.alibaba.dubbo.demo.DemoService;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Consumer &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;\"META-INF/spring/dubbo-demo-consumer.xml\"&#125;); context.start(); DemoService demoService = (DemoService) context.getBean(\"demoService\"); // get remote service proxy while (true) &#123; try &#123; Thread.sleep(5000); String hello = demoService.sayHello(\"world\"); // call remote method System.out.println(hello); // get result &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125; &#125;&#125; å°ç»“dubboè‡ªå®šä¹‰äº†å¾ˆå¤šçš„xmlæ ‡ç­¾ï¼Œè¿™äº›æ ‡ç­¾å°±å¯¹åº”äº†APIé…ç½®ä¸­çš„é…ç½®å¯¹è±¡ï¼Œæ ‡ç­¾çš„å±æ€§å°±å¯¹åº”é…ç½®å¯¹è±¡çš„å±æ€§ï¼ŒAPIçš„æ–¹å¼æ˜¯æ‰‹åŠ¨åˆ›å»ºé…ç½®å¯¹è±¡å¹¶è®¾ç½®å±æ€§å€¼ï¼Œxmlçš„æ–¹å¼æ˜¯åˆ›å»ºé…ç½®å¯¹è±¡å’Œè®¾ç½®å±æ€§å€¼éƒ½äº¤ç»™Springæ¥å®Œæˆï¼Œæ³¨æ„DubboBeanDefinitionParserè®¾ç½®çš„å±æ€§å€¼ä¸åŒ…æ‹¬ç³»ç»Ÿå‚æ•°ã€dubbo.propertiesç­‰ï¼Œè€Œæ˜¯xmlä¸­é…ç½®å¯¹è±¡çš„å±æ€§ã€‚è¿™äº›æ ‡ç­¾æ˜¯æ€ä¹ˆå’Œpringèåˆçš„åœ¨springè‡ªå®šä¹‰æ ‡ç­¾ä¸­å·²ç»ä»‹ç»äº†å®ç°åŸç†ï¼Œåœ¨åé¢çš„dubboé…ç½®è§£æä¸­ä¼šç»§ç»­è¯´æ˜ã€‚æ›´å¤šçš„é…ç½®è¯·å‚è€ƒï¼šé…ç½®å‚è€ƒæ‰‹å†Œã€‚ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­æˆ‘ä»¬ä»‹ç»ä½¿ç”¨æ³¨è§£çš„æ–¹å¼è¿›è¡Œé…ç½®,è¿™ç§æ–¹å¼æ›´ç®€æ´ï¼Œæ•ˆç‡æ›´é«˜ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"Dubboç¤ºä¾‹ - APIé…ç½®","slug":"rpc/Dubboç¬¬ä¸€ä¾‹","date":"2020-03-02T16:00:00.000Z","updated":"2020-08-15T08:43:51.063Z","comments":false,"path":"posts/f0ae64a/","link":"","permalink":"https://gentryhuang.com/posts/f0ae64a/","excerpt":"","text":"å¿«é€Ÿå¯åŠ¨ä½¿ç”¨APIçš„æ–¹å¼è¿›è¡Œå¯åŠ¨ã€è°ƒç”¨ã€‚API å±æ€§ä¸é…ç½®é¡¹ä¸€å¯¹ä¸€ï¼Œå„å±æ€§å«ä¹‰ï¼Œè¯·å‚è§ï¼šé…ç½®å‚è€ƒæ‰‹å†Œï¼Œæ¯”å¦‚ï¼šApplicationConfig.setName(â€œxxxâ€) å¯¹åº” &lt;dubbo:application name=â€xxxâ€ /&gt; å®šä¹‰æœåŠ¡æ¥å£1234567891011121314151617package com.code.resorce.api;/** * DemoService * * @author shunhua * @since 2020/03/03 * &lt;p&gt; * descï¼š */public interface DemoService &#123; /** * @return */ String hello();&#125; æœåŠ¡æä¾›æ–¹å®ç°æ¥å£123456789101112131415161718package com.code.resource.reading.api;import com.code.resorce.api.DemoService;/** * DemoServiceImpl * * @author shunhua * @since 2020/03/03 * &lt;p&gt; * descï¼š */public class DemoServiceImpl implements DemoService &#123; @Override public String hello() &#123; return \"hello world\"; &#125;&#125; ä½¿ç”¨APIé…ç½®å£°æ˜æš´éœ²æœåŠ¡123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * ApiProvider * * @author shunhua * @since 2020/03/03 * &lt;p&gt; * descï¼š */public class ApiProvider &#123; public static void main(String[] args) throws IOException &#123; // æœåŠ¡å¯¹è±¡ DemoService demoService = new DemoServiceImpl(); // åº”ç”¨é…ç½® ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName(\"api-config-demo-provider\"); // è¿æ¥æ³¨å†Œä¸­å¿ƒé…ç½® RegistryConfig registryConfig = new RegistryConfig(); registryConfig.setAddress(\"zookeeper://127.0.0.1:2181\"); // æœåŠ¡æä¾›è€…åè®®é…ç½® ProtocolConfig protocolConfig = new ProtocolConfig(); protocolConfig.setName(\"dubbo\"); protocolConfig.setPort(20880); //çœç•¥ServiceConfigçš„å…¶å®ƒé…ç½®é¡¹ï¼Œå¦‚Moduleã€Providerã€Monitorç­‰ // æœåŠ¡æä¾›è€…æš´éœ²æœåŠ¡é…ç½®ï¼Œæ³¨æ„ï¼šServiceConfigä¸ºé‡å¯¹è±¡ï¼Œå†…éƒ¨å°è£…äº†ä¸æ³¨å†Œä¸­å¿ƒçš„è¿æ¥ï¼Œä»¥åŠå¼€å¯æœåŠ¡ç«¯å£ï¼Œè¯·è‡ªè¡Œç¼“å­˜ï¼Œå¦åˆ™å¯èƒ½é€ æˆå†…å­˜å’Œè¿æ¥æ³„æ¼ ServiceConfig&lt;DemoService&gt; serviceConfig = new ServiceConfig&lt;DemoService&gt;(); serviceConfig.setApplication(applicationConfig); serviceConfig.setRegistry(registryConfig); serviceConfig.setProtocol(protocolConfig); serviceConfig.setInterface(DemoService.class); serviceConfig.setRef(demoService); // æš´éœ²åŠæ³¨å†ŒæœåŠ¡ serviceConfig.export(); // é˜»ä¸»çº¿ç¨‹ï¼Œé˜²æ­¢æœåŠ¡å…³é—­ï¼Œç”¨äºæ¶ˆè´¹è€…çš„è°ƒç”¨ System.in.read(); &#125;&#125; ä½¿ç”¨APIé…ç½®æœåŠ¡å¼•ç”¨123456789101112131415161718192021222324252627282930313233343536373839/** * ApiConsumer * * @author shunhua * @since 2020/03/03 * &lt;p&gt; * descï¼š */public class ApiConsumer &#123; public static void main(String[] args) throws InterruptedException &#123; // å½“å‰åº”ç”¨é…ç½® ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName(\"api-config-demo-provider\"); // è¿æ¥æ³¨å†Œä¸­å¿ƒé…ç½® RegistryConfig registryConfig = new RegistryConfig(); registryConfig.setAddress(\"zookeeper://127.0.0.1:2181\"); // çœç•¥ReferenceConfigçš„å…¶å®ƒé…ç½®é¡¹ï¼Œå¦‚ Moduleã€Consumerã€Monitorç­‰ // å¼•ç”¨è¿œç¨‹æœåŠ¡ï¼Œæ³¨æ„ï¼šReferenceConfigä¸ºé‡å¯¹è±¡ï¼Œå†…éƒ¨å°è£…äº†ä¸æ³¨å†Œä¸­å¿ƒçš„è¿æ¥ï¼Œä»¥åŠä¸æœåŠ¡æä¾›æ–¹çš„è¿æ¥ï¼Œè¯·è‡ªè¡Œç¼“å­˜ï¼Œå¦åˆ™å¯èƒ½é€ æˆå†…å­˜å’Œè¿æ¥æ³„æ¼ ReferenceConfig&lt;DemoService&gt; referenceConfig = new ReferenceConfig&lt;DemoService&gt;(); referenceConfig.setApplication(applicationConfig); referenceConfig.setRegistry(registryConfig); referenceConfig.setInterface(DemoService.class); // è·å–ä»£ç†å¯¹è±¡ DemoService demoService = referenceConfig.get(); while (true) &#123; String ping = demoService.sayHello(\"ping\"); System.out.println(ping); Thread.sleep(3000); &#125; &#125;&#125; å°ç»“ä½¿ç”¨APIç¡¬ç¼–ç çš„æ–¹å¼ç®€å•ã€ç›´è§‚ï¼Œæ— éœ€å…³æ³¨å…¶å®ƒç»†èŠ‚ï¼ˆå¦‚ä¸éœ€è¦å…³å¿ƒå’ŒSpringæ•´åˆçš„ç»†èŠ‚ï¼‰ï¼Œè®©ä½¿ç”¨è€…æ›´å®¹å™¨ç†è§£dubboçš„å„ä¸ªç»„ä»¶åŠå…¶ä¹‹é—´çš„è”ç³»ï¼Œç¼–å†™æœåŠ¡æä¾›è€…ä¸æ¶ˆè´¹è€…æ›´åŠ å®¹æ˜“ã€‚é»˜è®¤æƒ…å†µä¸‹dubboæ¡†æ¶åªéœ€è¦ä¾èµ–Nettyé€šä¿¡æ¡†æ¶å°±å¯ä»¥å®ç°RPCè°ƒç”¨ï¼Œæ³¨å†Œä¸­å¿ƒä¹Ÿå¯ä»¥ä¸éœ€è¦ï¼Œå³åªè¦æœ‰æœåŠ¡æä¾›è€…ã€æœåŠ¡æ¶ˆè´¹è€… ä»¥åŠ æ¶èµ·æ¶ˆè´¹è€…è¿æ¥åˆ°æä¾›è€…çš„é€šä¿¡æ¡¥æ¢å³å¯å®ç°ä¸€ä¸ªå®Œæ•´çš„RPCè°ƒç”¨ã€‚ è™½ç„¶ä½¿ç”¨APIçš„æ–¹å¼ç®€å•æ˜“æ‡‚ï¼Œä½†æ˜¯å¯¹äºåº”ç”¨ã€æœåŠ¡çš„ç®¡ç†å°±éœ€è¦å¾ˆå¤§çš„æˆæœ¬ï¼Œå¯¹äºæ¯ä¸ªåº”ç”¨ã€æœåŠ¡éƒ½éœ€ç¼–å†™å¤§é‡é‡å¤çš„ä»£ç ï¼Œå¹¶ä¸”æ˜¯ç¡¬ç¼–ç ï¼Œæ˜¾ç„¶æ˜¯ä¸åˆç†çš„ã€‚Springæœ¬èº«çš„ä¸€å¤§ç‰¹æ€§å°±æ˜¯ä¾èµ–ç®¡ç†ï¼Œè€Œæˆ‘ä»¬è¿™äº›APIä¸­çš„é…ç½®æ‰¿è½½å¯¹è±¡å®Œå…¨å¯ä»¥äº¤ç»™Springæ¥ç®¡ç†ï¼Œè¿™æ ·å°±å®ç°äº†é…ç½®åŒ–ï¼Œè™½ç„¶å¼•å…¥äº†Springè¿™ä¸ªç¬¬ä¸‰æ–¹æ¡†æ¶ï¼Œä½†æ˜¯æ˜¯éå¸¸åˆç†çš„ï¼Œæ¯•ç«ŸSpringæ˜¯ä¸»æµã€‚ä¸‹ä¸€ç¯‡æ–‡ç« æˆ‘ä»¬ä½¿ç”¨Springçš„xmlé…ç½®æ–¹å¼å®ç°RPCè°ƒç”¨ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"Springè‡ªå®šä¹‰æ ‡ç­¾","slug":"rpc/Springè‡ªå®šä¹‰æ ‡ç­¾","date":"2020-03-01T16:00:00.000Z","updated":"2020-09-03T01:33:46.285Z","comments":false,"path":"posts/eee3e639/","link":"","permalink":"https://gentryhuang.com/posts/eee3e639/","excerpt":"","text":"springè‡ªå®šä¹‰æ ‡ç­¾Springé™¤äº†å¾ˆå¤šå†…ç½®çš„xmlæ ‡ç­¾å¤–ï¼Œè¿˜æ”¯æŒè‡ªå®šä¹‰xmlæ ‡ç­¾ï¼Œå¼€å‘è€…åªéœ€è¦æŒ‰ç…§Springçš„çº¦å®šè§„åˆ™å°±å¯ä»¥å®ç°è‡ªå®šä¹‰æ ‡ç­¾ï¼Œè¿™æ ·å¼€å‘è€…å°±å¯ä»¥æŠŠè‡ªå®šä¹‰çš„Beanäº¤ç»™Springç®¡ç†ã€‚è‡ªå®šä¹‰æ ‡ç­¾åŒ…ç»“æ„å¦‚ä¸‹ï¼š è‡ªå®šä¹‰æ ‡ç­¾çš„è§„åˆ™ç¼–å†™æ¨¡å‹1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.code.resource.reading.xml.schema.model;/** * Hero * * @author shunhua * @since 2020/03/02 * &lt;p&gt; * descï¼š */public class Hero &#123; /** * name */ private String name; /** * age */ private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Hero&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; å®šä¹‰æ¨¡å‹çš„xsdæ–‡ä»¶12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xsd:schema xmlns=\"http://gentryhuang.site/schema/people\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" targetNamespace=\"http://gentryhuang.com/schema/people\"&gt; &lt;!-- å®šä¹‰å…ƒç´ çš„å¤æ‚ç±»å‹ --&gt; &lt;xsd:complexType name=\"elementComplexType\"&gt; &lt;!-- å®šä¹‰æ¨¡å‹ç±»ä¸­çš„å±æ€§ --&gt; &lt;xsd:attribute name=\"name\" type=\"xsd:string\"&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;&lt;![CDATA[ The element name. ]]&gt;&lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;/xsd:attribute&gt; &lt;xsd:attribute name=\"age\" type=\"xsd:int\"&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;&lt;![CDATA[ The element age. ]]&gt;&lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;/xsd:attribute&gt; &lt;/xsd:complexType&gt; &lt;!-- å®šä¹‰åœ¨xmlæ–‡ä»¶ä¸­ç”¨åˆ°çš„å…ƒç´ åç§° --&gt; &lt;xsd:element name=\"hero\" type=\"elementComplexType\"&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;&lt;![CDATA[ å®šä¹‰æ ‡ç­¾ ]]&gt;&lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;/xsd:element&gt;&lt;/xsd:schema&gt; è¯´æ˜: è¯¥æ–‡ä»¶è¦æ”¾åœ¨ resourcesçš„META-INFç›®å½•ä¸‹ã€‚è¯¥æ–‡ä»¶æ˜¯ç”¨æ¥çº¦æŸä½¿ç”¨xmlé…ç½®æ—¶çš„æ ‡ç­¾å’Œå¯¹åº”çš„å±æ€§ã€‚ ç¼–å†™spring.schemasæ–‡ä»¶1http\\:&#x2F;&#x2F;gentryhuang.com&#x2F;schema&#x2F;people&#x2F;hero.xsd&#x3D;META-INF&#x2F;hero.xsd è¯´æ˜: http://gentryhuang.com/schema/people å°±æ˜¯æ¨¡å‹å¯¹åº”çš„xsdä¸­çš„targetNamespaceçš„å€¼ï¼Œå®ƒæŒ‡å®šäº†çº¦æŸæ–‡ä»¶çš„å…·ä½“è·¯å¾„ã€‚ ç¼–å†™BeanDefinitionParser12345678910111213141516171819202122232425262728293031323334353637383940414243package com.code.resource.reading.xml.schema;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.RootBeanDefinition;import org.springframework.beans.factory.xml.BeanDefinitionParser;import org.springframework.beans.factory.xml.ParserContext;import org.w3c.dom.Element;/** * HeroBeanDefinitionParser * * @author shunhua * @since 2020/03/02 * &lt;p&gt; * descï¼š */public class HeroBeanDefinitionParser implements BeanDefinitionParser &#123; /** * æ ‡ç­¾å¯¹åº”çš„ç±» */ private final Class&lt;?&gt; beanClass; public HeroBeanDefinitionParser(Class&lt;?&gt; beanClass) &#123; this.beanClass = beanClass; &#125; @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; RootBeanDefinition beanDefinition = new RootBeanDefinition(); beanDefinition.setBeanClass(beanClass); beanDefinition.setLazyInit(false); beanDefinition.getPropertyValues().add(\"name\",element.getAttribute(\"name\")); beanDefinition.getPropertyValues().add(\"age\",element.getAttribute(\"age\")); // è·å–Beanå®šä¹‰æ³¨å†Œè¡¨ BeanDefinitionRegistry registry = parserContext.getRegistry(); // æ³¨å†ŒBean registry.registerBeanDefinition(\"hero\",beanDefinition); return beanDefinition; &#125;&#125; è¯´æ˜: ç”¨æ¥è§£æè‡ªå®šä¹‰çš„xmlæ ‡ç­¾ ç¼–å†™å‘½åç©ºé—´å¤„ç†å™¨123456789101112131415161718192021222324package com.code.resource.reading.xml.schema;import com.code.resource.reading.xml.schema.model.Hero;import org.springframework.beans.factory.xml.NamespaceHandlerSupport;/** * HeroNamespaceHandler * * @author shunhua * @since 2020/03/02 * &lt;p&gt; * descï¼š */public class HeroNamespaceHandler extends NamespaceHandlerSupport &#123; /** * å®šä¹‰äº†&lt;xsd:element/&gt;å¯¹åº”çš„BeanDefinitionParser */ @Override public void init() &#123; registerBeanDefinitionParser(\"hero\",new HeroBeanDefinitionParser(Hero.class)); &#125;&#125; è¯´æ˜:ä¸€èˆ¬æƒ…å†µä¸‹ ä¸€ä¸ª&lt;xsd:element/&gt; å¯¹åº”ä¸€ä¸ªBeanDefinitionParser ç¼–å†™spring.handlersæ–‡ä»¶1http\\:&#x2F;&#x2F;gentryhuang.com&#x2F;schema&#x2F;people&#x3D;com.code.resource.reading.xml.schema.HeroNamespaceHandler è¯´æ˜: è¿™æ˜¯ä¸€ä¸ªé”®å€¼å¯¹ï¼Œkeyæ˜¯xsdæ–‡ä»¶ä¸­çš„ targetNamespaceï¼Œè¯¥æ–‡ä»¶æŒ‡æ˜äº†ä½¿ç”¨å“ªä¸ªç±»æ¥è§£æè‡ªå®šä¹‰çš„æ ‡ç­¾ã€‚ ä½¿ç”¨springçš„è‡ªå®šä¹‰æ ‡ç­¾12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:people=\"http://gentryhuang.com/schema/people\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://gentryhuang.com/schema/people http://gentryhuang.com/schema/people/hero.xsd\"&gt; &lt;!-- 1 xmlns:peopleçš„å€¼æ˜¯xsdæ–‡ä»¶ä¸­çš„targetNamespace 2 xmlns:hero å¯ä»¥å†™æˆxmlns:xxx,æ­¤æ—¶æ ‡ç­¾å‰ç¼€ä¹Ÿè¦æ˜¯ &lt;xxx:hero/&gt; --&gt; &lt;people:hero name=\"hlb\" age=\"18\"/&gt;&lt;/beans&gt; æµ‹è¯•123456789101112131415161718192021package com.code.resource.reading.xml.schema;import com.code.resource.reading.xml.schema.model.Hero;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Client * * @author shunhua * @since 2020/03/02 * &lt;p&gt; * descï¼š */public class Client &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"hero.xml\"); Hero hero = (Hero) applicationContext.getBean(\"hero\"); System.out.println(hero); &#125;&#125; å°ç»“springåœ¨è§£æåˆ°è‡ªå®šä¹‰çš„namespaceæ ‡ç­¾æ—¶ï¼Œæ¯”å¦‚ &lt;people:hero /&gt;ï¼Œä¼šæŸ¥æ‰¾å¯¹åº”çš„spring.schemaså’Œspring.handlersæ–‡ä»¶ï¼Œé€šè¿‡spring.schemasæ–‡ä»¶ç¡®å®šéœ€è¦åŠ è½½çš„æ ‡ç­¾åŠå±æ€§ï¼Œç„¶åä¼šè§¦å‘spring.handlersæ–‡ä»¶ä¸­æŒ‡å®šçš„ç±»æ¥è¿›è¡Œåˆå§‹åŒ–å’Œè§£æã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"},{"name":"Spring","slug":"Spring","permalink":"https://gentryhuang.com/tags/Spring/"}]},{"title":"åˆè¯†RPC","slug":"rpc/åˆè¯†RPC","date":"2020-02-29T16:00:00.000Z","updated":"2021-03-09T09:08:49.501Z","comments":false,"path":"posts/626d9676/","link":"","permalink":"https://gentryhuang.com/posts/626d9676/","excerpt":"","text":"åŸºæœ¬æ¦‚å¿µRPCï¼ˆRemote Procedure Callï¼‰è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼Œç®€å•æ¥è¯´å°±æ˜¯ä¸€ä¸ªèŠ‚ç‚¹è¯·æ±‚å¦ä¸€ä¸ªèŠ‚ç‚¹æä¾›çš„æœåŠ¡ï¼Œåƒæœ¬åœ°æ–¹æ³•è°ƒç”¨ä¸€æ ·è°ƒç”¨è¿œç¨‹çš„æœåŠ¡ã€‚è¯¦ç»†è¯´æ˜ï¼šè¯·æ±‚æ–¹æ²¡æœ‰æœåŠ¡å®ç°çš„ç»†èŠ‚ï¼Œæ‰§è¡Œç›®æ ‡è¡Œä¸ºè¿˜æ˜¯æœåŠ¡æä¾›çš„èŠ‚ç‚¹ã€‚è¯·æ±‚æœåŠ¡çš„èŠ‚ç‚¹å’ŒæœåŠ¡æä¾›çš„èŠ‚ç‚¹ä»¥æŸç§æ–¹å¼è¿›è¡Œé€šä¿¡ï¼Œè¯·æ±‚æ–¹æŠŠè¡Œä¸ºåŠè¡Œä¸ºå‚æ•°ä¼ é€’ç»™æœåŠ¡æä¾›æ–¹ï¼ŒæœåŠ¡æä¾›æ–¹ä¼šæ ¹æ®è¯·æ±‚æ–¹ä¼ é€’çš„æ•°æ®æ‰¾åˆ°å¯¹åº”çš„æœåŠ¡å®ç°ç„¶åæ‰§è¡Œç›®æ ‡è¡Œä¸ºï¼Œæœ€åå†æŠŠæ‰§è¡Œç»“æœè¿”å›ç»™è¯·æ±‚æ–¹ã€‚ æœ¬åœ°è¿‡ç¨‹è°ƒç”¨å‘èµ·è¯·æ±‚å’Œå“åº”ç»“æœéƒ½åœ¨åŒä¸€ä¸ªæœåŠ¡èŠ‚ç‚¹ä¸Šï¼Œåœ¨Javaä¸­å°±æ˜¯åŒä¸€ä¸ªJVMä¸­çš„æ–¹æ³•è°ƒç”¨è¿‡ç¨‹ã€‚ è¿œç¨‹è¿‡ç¨‹è°ƒç”¨è¯·æ±‚çš„å‘èµ·è€…å’Œè¯·æ±‚çš„å¤„ç†è€…ä¸åœ¨åŒä¸€ä¸ªèŠ‚ç‚¹ä¸Šï¼Œå®ƒä»¬ä¹‹é—´éœ€è¦è¿›è¡Œç½‘ç»œé€šä¿¡æ‰èƒ½å®Œæˆè¯·æ±‚å’Œå“åº”ã€‚ ç®€å•RPCå®ç°è¯´æ˜: ä¾‹å­æ˜¯ä½¿ç”¨æ¢é£å¤§ä½¬çš„ æŠ€æœ¯åšå®¢ ä¸­çš„æ¡ˆä¾‹ æœåŠ¡æ¥å£åŠå®ç°12345678910111213141516171819202122232425262728293031package com.alibaba.study.rpc.service;/** * HelloService */public interface HelloService &#123; /** * æœåŠ¡æ–¹æ³• * * @param name * @return */ String hello(String name);&#125;---package com.alibaba.study.rpc.service.impl;import com.alibaba.study.rpc.service.HelloService;/** * HelloServiceImpl */public class HelloServiceImpl implements HelloService &#123; @Override public String hello(String name) &#123; return \"Hello \" + name; &#125;&#125; RPCæ¡†æ¶123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177package com.alibaba.study.rpc.framework;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.net.ServerSocket;import java.net.Socket;/** * RpcFramework */public class RpcFramework &#123; /** * æš´éœ²æœåŠ¡ * * @param service æœåŠ¡å®ç° * @param port æœåŠ¡ç«¯å£ * @throws Exception */ public static void export(final Object service, int port) throws Exception &#123; if (service == null) &#123; throw new IllegalArgumentException(\"service instance == null\"); &#125; if (port &lt;= 0 || port &gt; 65535) &#123; throw new IllegalArgumentException(\"Invalid port \" + port); &#125; System.out.println(\"Export service \" + service.getClass().getName() + \" on port \" + port); // ä»¥æŒ‡å®šç«¯å£åˆ›å»ºServerSocket ServerSocket server = new ServerSocket(port); for (; ; ) &#123; try &#123; // ç­‰å¾…æ¥æ”¶è¯·æ±‚ final Socket socket = server.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; try &#123; // è·å–è¯·æ±‚çš„æ•°æ®æµ ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); try &#123; // è·å–å®¢æˆ·ç«¯è¯·æ±‚çš„æ–¹æ³•å String methodName = input.readUTF(); // è·å–å®¢æˆ·ç«¯è¯·æ±‚çš„å‚æ•°ç±»å‹åˆ—è¡¨ Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject(); // è·å–å®¢æˆ·ç«¯è¯·æ±‚çš„å‚æ•°åˆ—è¡¨ Object[] arguments = (Object[]) input.readObject(); // åˆ›å»ºå¯¹è±¡è¾“å‡ºæµå¯¹è±¡ï¼Œç”¨äºå“åº”ç»“æœç»™å®¢æˆ·ç«¯ ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); try &#123; // é€šè¿‡åå°„ï¼Œè·å–æœåŠ¡æ¥å£æŒ‡å®šçš„æ–¹æ³• Method method = service.getClass().getMethod(methodName, parameterTypes); // åå°„è°ƒç”¨ Object result = method.invoke(service, arguments); // å°†ç»“æœå“åº”ç»™å®¢æˆ·ç«¯ output.writeObject(result); &#125; catch (Throwable t) &#123; output.writeObject(t); &#125; finally &#123; output.close(); &#125; &#125; finally &#123; input.close(); &#125; &#125; finally &#123; socket.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * å¼•ç”¨æœåŠ¡ * * @param &lt;T&gt; æ¥å£æ³›å‹ * @param interfaceClass æ¥å£ç±»å‹ * @param host æœåŠ¡å™¨ä¸»æœºå * @param port æœåŠ¡å™¨ç«¯å£ * @return è¿œç¨‹æœåŠ¡ * @throws Exception */ @SuppressWarnings(\"unchecked\") public static &lt;T&gt; T refer(final Class&lt;T&gt; interfaceClass, final String host, final int port) throws Exception &#123; if (interfaceClass == null) &#123; throw new IllegalArgumentException(\"Interface class == null\"); &#125; if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException(\"The \" + interfaceClass.getName() + \" must be interface class!\"); &#125; if (host == null || host.length() == 0) &#123; throw new IllegalArgumentException(\"Host == null!\"); &#125; if (port &lt;= 0 || port &gt; 65535) &#123; throw new IllegalArgumentException(\"Invalid port \" + port); &#125; System.out.println(\"Get remote service \" + interfaceClass.getName() + \" from server \" + host + \":\" + port); /** * ä½¿ç”¨JDKçš„åŠ¨æ€ä»£ç†åˆ›å»ºæ¥å£çš„ä»£ç†å¯¹è±¡ * è¯´æ˜ï¼š * åœ¨ InvocationHandler#invokeæ–¹æ³•å†…éƒ¨å®ç°Socketä¸ServerSocketçš„é€šä¿¡ã€‚å½“ä½¿ç”¨ä»£ç†å¯¹è±¡è°ƒç”¨æ–¹æ³•æ—¶ï¼Œå†…éƒ¨ä½¿ç”¨Socketè¿›è¡Œé€šä¿¡ï¼Œç„¶åæŠŠé€šä¿¡çš„ç»“æœè¿”å›ã€‚ */ return (T) Proxy.newProxyInstance( interfaceClass.getClassLoader(), new Class&lt;?&gt;[]&#123;interfaceClass&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable &#123; // åˆ›å»ºSocketï¼Œç”¨äºè¿æ¥ServerSocket Socket socket = new Socket(host, port); try &#123; // åˆ›å»ºç”¨äºå‘é€æ•°æ®åˆ°ServerSocketçš„è¾“å‡ºæµ ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); try &#123; //--------------------- æ•°æ®å¥‘çº¦ ----------------------------/ // æ–¹æ³•å output.writeUTF(method.getName()); // å‚æ•°ç±»å‹ output.writeObject(method.getParameterTypes()); // å‚æ•°å€¼ output.writeObject(arguments); //------------------------ æ•°æ®å¥‘çº¦ --------------------------/ // åˆ›å»ºç”¨äºæ¥æ”¶ServerSocketçš„è¾“å…¥æµ ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); try &#123; // è¯»å–ServerSocketå“åº”çš„æ•°æ® Object result = input.readObject(); if (result instanceof Throwable) &#123; throw (Throwable) result; &#125; // è¿”å›ç»“æœ return result; &#125; finally &#123; input.close(); &#125; &#125; finally &#123; output.close(); &#125; &#125; finally &#123; socket.close(); &#125; &#125; &#125;); &#125;&#125; æœåŠ¡æš´éœ²1234567891011121314151617package com.alibaba.study.rpc.provider;import com.alibaba.study.rpc.framework.RpcFramework;import com.alibaba.study.rpc.service.HelloService;import com.alibaba.study.rpc.service.impl.HelloServiceImpl;/** * RpcProvider */public class RpcProvider &#123; public static void main(String[] args) throws Exception &#123; // æœåŠ¡å®ç° HelloService service = new HelloServiceImpl(); // æš´éœ²æœåŠ¡ RpcFramework.export(service, 1234); &#125;&#125; å¼•ç”¨æœåŠ¡1234567891011121314151617181920package com.alibaba.study.rpc.consumer;import com.alibaba.study.rpc.framework.RpcFramework;import com.alibaba.study.rpc.service.HelloService;/** * RpcConsumer */public class RpcConsumer &#123; public static void main(String[] args) throws Exception &#123; // å¼•ç”¨æœåŠ¡ã€ä»£ç†å¯¹è±¡ã€‘ HelloService service = RpcFramework.refer(HelloService.class, \"127.0.0.1\", 1234); while (true) &#123; String hello = service.hello(\"World\"); System.out.println(hello); Thread.sleep(1000); &#125; &#125;&#125; å°ç»“è¿™ä¸ªä¾‹å­ä¸­ï¼Œé€šä¿¡æ˜¯ä½¿ç”¨åŒæ­¥é˜»å¡çš„Socketæ¥å®ç°çš„ï¼Œé‡‡ç”¨ç«¯å¯¹ç«¯çš„æ–¹å¼ã€‚è¿œç¨‹è°ƒç”¨ä½¿ç”¨çš„æ˜¯JDKçš„åŠ¨æ€ä»£ç†ï¼Œåœ¨invokeæ–¹æ³•ä¸­å®ç°ç½‘ç»œé€šä¿¡ã€‚å‚æ•°åºåˆ—åŒ–ä½¿ç”¨çš„æ˜¯JDKçš„ObjectStreamã€‚ä¸€ä¸ªå®Œå–„çš„RPCæ¡†æ¶å…¶å®å°±æ˜¯åœ¨è¿™ä¾‹å­çš„åŸºç¡€ä¸Šè¿›è¡Œå¤šæ–¹ä½æ‰©å±•å’Œæ”¹è¿›ã€‚æ¯”å¦‚ï¼Œç½‘ç»œé€šä¿¡å¯ä»¥ä½¿ç”¨æ€§èƒ½æ›´å¥½çš„NIOæ¡†æ¶Nettyï¼ŒåŠ¨æ€ä»£ç†å¯ä»¥ä½¿ç”¨javaassistå­—èŠ‚ç ç”Ÿæˆæ–¹å¼[æ³¨æ„ï¼šä¸æ˜¯javaassistæä¾›çš„åŠ¨æ€ä»£ç†æ¥å£ï¼Œè¯¥æ¥å£æ¯”JDKè‡ªå¸¦çš„è¿˜æ…¢]ï¼Œåºåˆ—åŒ–æ–¹å¼å¯ä»¥é‡‡ç”¨fastjsonã€hession2ä»¥åŠkryoç­‰æŠ€æœ¯ã€‚å¦‚æœæœåŠ¡æ•°é‡è¾¾åˆ°ä¸€å®šè§„æ¨¡ï¼Œå¯ä»¥å¼•è¿›æ³¨å†Œä¸­å¿ƒè¿›è¡ŒæœåŠ¡çš„æ²»ç†ã€‚èŠ‚ç‚¹é—´çš„é€šä¿¡æ–¹å¼å¯ä»¥æœ‰å¤šç§ï¼Œå› æ­¤å¯ä»¥æ‰©å±•å¤šåè®®ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œæ€§èƒ½å’Œå¥å£®æ€§ä¹Ÿæ˜¯ä¸€ä¸ªä¼˜ç§€çš„RPCæ¡†æ¶æ‰€å¿…é¡»çš„ï¼Œå¦‚é›†ç¾¤å®¹é”™ã€è´Ÿè½½å‡è¡¡ã€é‡è¯•æœºåˆ¶ã€æœåŠ¡é™çº§â€¦è¿™äº›éƒ½ä¼šåœ¨åé¢åˆ†æçš„Dubboæ¡†æ¶ä¸­å¾—åˆ°å¾ˆå¥½çš„ä½“ç°ã€‚","categories":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"}],"tags":[{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"}]},{"title":"å‘½ä»¤æ¨¡å¼","slug":"design_pattern/behaviour_type/å‘½ä»¤æ¨¡å¼","date":"2019-10-04T16:00:00.000Z","updated":"2020-08-09T09:26:57.923Z","comments":true,"path":"posts/78134e07/","link":"","permalink":"https://gentryhuang.com/posts/78134e07/","excerpt":"","text":"å®šä¹‰å‘½ä»¤æ¨¡å¼åˆå«æŒ‡ä»¤æ¨¡å¼ï¼Œæ˜¯å°†â€œè¯·æ±‚â€å°è£…æˆå¯¹è±¡ï¼Œä»¥ä¾¿ä½¿ç”¨ä¸åŒçš„è¯·æ±‚ã€‚æˆ‘ä»¬å¯ä»¥æŠŠä¸åŒçš„è¯·æ±‚å°è£…æˆä¸åŒè¯·æ±‚å¯¹è±¡ï¼Œå¯¹äºæ¥æ”¶è€…æ¥è¯´è¿™äº›ç±»å‹éƒ½èƒ½è¯†åˆ«ï¼Œç„¶åæ ¹æ®ä¸åŒçš„è¯·æ±‚å¯¹è±¡æ‰§è¡Œä¸åŒçš„è¡Œä¸ºã€‚ è¯´æ˜å‘½ä»¤æ¨¡å¼è§£å†³äº†åº”ç”¨ç¨‹åºä¸­å¯¹è±¡çš„èŒè´£ä»¥åŠå®ƒä»¬ä¹‹é—´çš„é€šä¿¡æ–¹å¼ï¼Œå‘½ä»¤æ¨¡å¼å¯ä»¥ä½¿å‘½ä»¤å‘é€è€…å’Œæ¥æ”¶è€…å®Œå…¨è§£è€¦ï¼Œå‘é€è€…å’Œæ¥æ”¶è€…ä¹‹é—´æ²¡æœ‰ç›´æ¥çš„å¼•ç”¨å…³ç³»ã€‚å‘é€å‘½ä»¤çš„å¯¹è±¡åªçŸ¥é“å¦‚ä½•ä¸‹å‘½ä»¤ï¼Œä¸éœ€è¦çŸ¥é“å¦‚ä½•å®Œæˆå‘½ä»¤ã€‚ ç±»å‹è¡Œä¸ºå‹ ä½¿ç”¨åœºæ™¯121. è¯·æ±‚è°ƒç”¨è€…å’Œè¯·æ±‚æ¥æ”¶è€…éœ€è¦è§£è€¦ï¼Œä½¿å¾—è°ƒç”¨è€…å’Œæ¥æ”¶è€…ä¸ç›´æ¥äº¤äº’2. éœ€è¦æŠ½è±¡å‡ºç­‰å¾…æ‰§è¡Œçš„è¡Œä¸º ä¼˜ç‚¹1231. é™ä½è€¦åˆ - é€šè¿‡å‘½ä»¤æ¨¡å¼æŠŠè¯·æ±‚çš„å‘é€è€…å’Œè¯·æ±‚çš„æ¥æ”¶è€…è¿›è¡Œè§£è€¦2. å®¹æ˜“æ‰©å±•æ–°å‘½ä»¤æˆ–è€…ä¸€ç»„å‘½ä»¤ ç¼ºç‚¹12å‘½ä»¤çš„æ— é™æ‰©å±•ä¼šå¢åŠ ç±»çš„æ•°é‡ï¼Œæé«˜ç³»ç»Ÿå®ç°å¤æ‚åº¦ - é’ˆå¯¹æ¯ä¸€ä¸ªå‘½ä»¤æˆ‘ä»¬éƒ½è¦è®¾è®¡å¹¶å¼€å‘ä¸€ä¸ªå…·ä½“çš„å‘½ä»¤ç±» ç›¸å…³çš„è®¾è®¡æ¨¡å¼å‘½ä»¤æ¨¡å¼å’Œå¤‡å¿˜å½•æ¨¡å¼ 1å¯ä»¥æŠŠä¸¤è€…ç»“åˆä½¿ç”¨ï¼Œä½¿ç”¨å¤‡å¿˜å½•æ¨¡å¼ä¿å­˜å‘½ä»¤çš„å†å²è®°å½•ï¼Œè¿™æ ·å¯ä»¥è°ƒç”¨ä¹‹å‰çš„å‘½ä»¤ ç®€å•éœ€æ±‚ä¸€åˆ›ä¸šå…¬å¸ä¸ºäº†æŠ¢å å¸‚åœºï¼Œè€æ¿å¯¹å¼€å‘éƒ¨å‰åä¸‹è¾¾äº†ä¸¤ä¸ªå‘½ä»¤ï¼Œå…ˆä½¿ç”¨å•ä¾‹æ¶æ„å¿«é€Ÿå¼€å‘å‡ºäº§å“ï¼Œç­‰åˆ°æŠ¢å äº†å¸‚åœºåå†æ‰©å¤§è§„æ¨¡æŠŠå•ä½“ç»“æ„æ‹†æˆå¾®æœåŠ¡æ¶æ„ã€‚ å‘½ä»¤æ¨¡å¼æ¼”ç»ƒ æŠŠå‘½ä»¤æŠ½è±¡æˆå¯¹è±¡ï¼Œè¿™æ˜¯å‘½ä»¤æ¨¡å¼å®ç°çš„æ ¸å¿ƒ 1å‘½ä»¤æ‰©å±•å¾ˆå®¹æ˜“ï¼Œå¢åŠ å‘½ä»¤åªéœ€å°è£…ä¸€ä¸ªå‘½ä»¤ç±»ã€‚å¦‚æœæœ‰å‘½ä»¤è¡Œä¸ºä½“æ ¹æ®æƒ…å†µä¿®æ”¹å‘½ä»¤è¡Œä¸ºä½“ã€‚ å‘½ä»¤è¡Œä¸ºä½“ 1æ¯ä¸ªå‘½ä»¤æ‰§è¡Œçš„å…·ä½“è¡Œä¸ºåœ¨è¡Œä¸ºä½“ä¸­ï¼Œä½†ä¸æ˜¯å¿…é¡»çš„ï¼Œä¹Ÿå¯ä»¥ä¸è¦è¡Œä¸ºä½“ï¼Œè®©å‘½ä»¤æ‰§è¡Œå˜å¾—æ›´çµæ´»ã€‚ 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.command;import lombok.extern.slf4j.Slf4j;/** * Project é¡¹ç›® * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class Project &#123; /** * é¡¹ç›®åç§° */ private String name; public Project(String name)&#123; this.name = name; &#125; /** * ä½¿ç”¨å•ä½“æ¶æ„å¼€å‘é¡¹ç›® */ public void monomer()&#123; log.info(String.format(\"%sé¡¹ç›®ä½¿ç”¨å•ä½“æ¶æ„å¼€å‘\",this.name)); &#125; /** * ä½¿ç”¨å¾®æœåŠ¡æ¶æ„å¼€å‘é¡¹ç›® */ public void microservice()&#123; log.info(String.format(\"%sé¡¹ç›®ä½¿ç”¨å¾®æœåŠ¡æ¶æ„å¼€å‘\",this.name)); &#125;&#125; å‘½ä»¤æ¥å£ 1234567891011121314package com.design.pattern.command;/** * Command å‘½ä»¤æ¥å£ * * @author shunhua * @date 2019-10-04 */public interface Command &#123; /** * æ‰§è¡Œå‘½ä»¤ */ void execute();&#125; å•ä½“æ¶æ„å¼€å‘å‘½ä»¤ 123456789101112131415161718192021222324252627282930package com.design.pattern.command;/** * MonomerCommand å•ä½“æ¶æ„å¼€å‘å‘½ä»¤ç±»ï¼Œæ‰§è¡Œçš„æ˜¯å•ä½“æ¶æ„å¼€å‘ * * @author shunhua * @date 2019-10-04 */public class MonomerCommand implements Command &#123; /** * ç»„åˆï¼Œå‘½ä»¤å¯¹åº”çš„è¡Œä¸ºä½“ (éå¿…é¡»çš„ï¼Œå‘½ä»¤çš„è¡Œä¸ºå¯ä»¥æ ¹æ®å…·ä½“ä¸šåŠ¡ç¼–å†™) */ private Project project; /** * æ„é€ æ–¹æ³• * @param project */ public MonomerCommand(Project project)&#123; this.project = project; &#125; /** * æ‰§è¡Œå‘½ä»¤ */ @Override public void execute() &#123; project.monomer(); &#125;&#125; å¾®æœåŠ¡æ¶æ„å¼€å‘å‘½ä»¤ 12345678910111213141516171819202122232425262728293031package com.design.pattern.command;/** * MicroserviceCommand å¾®æœåŠ¡æ¶æ„å¼€å‘å‘½ä»¤ç±»ï¼Œæ‰§è¡Œçš„æ˜¯å¾®æœåŠ¡æ¶æ„å¼€å‘ * * @author shunhua * @date 2019-10-04 */public class MicroserviceCommand implements Command &#123; /** * ç»„åˆï¼Œå‘½ä»¤å¯¹åº”çš„è¡Œä¸ºä½“ (éå¿…é¡»çš„ï¼Œå‘½ä»¤çš„è¡Œä¸ºå¯ä»¥æ ¹æ®å…·ä½“ä¸šåŠ¡ç¼–å†™) */ private Project project; /** * æ„é€ æ–¹æ³• * @param project */ public MicroserviceCommand(Project project)&#123; this.project = project; &#125; /** * æ‰§è¡Œå‘½ä»¤ */ @Override public void execute() &#123; project.microservice(); &#125;&#125; å‘½ä»¤æ¥æ”¶è€… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.design.pattern.command;import java.util.ArrayList;import java.util.List;/** * Staff å‘½ä»¤æ‰§è¡Œè€… * * @author shunhua * @date 2019-10-04 */public class Staff &#123; /** * å‘½ä»¤é›†åˆï¼Œå¯ä»¥æ¥æ”¶å¤šä¸ªå‘½ä»¤ */ private List&lt;Command&gt; commands = new ArrayList&lt;&gt;(); /** * æ¥æ”¶å‘½ä»¤ * @param command */ public void addCommand(Command command)&#123; commands.add(command); &#125; /** * ç§»é™¤å‘½ä»¤ * @param command */ public void removeCommand(Command command)&#123; commands.remove(command); &#125; /** * æ‰§è¡ŒæŒ‡å®šçš„å * @param command */ public void execureCommand(Command command)&#123; command.execute(); &#125; /** * æ‰§è¡Œå‘½ä»¤é›† */ public void executeCommandList()&#123; this.commands.stream().forEach(Command::execute); commands.clear(); &#125;&#125; åº”ç”¨å±‚ 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.command;import org.junit.Test;/** * Boss å‘½ä»¤çš„ä¸‹è¾¾è€… * * @author shunhua * @date 2019-10-04 */public class Boss &#123; @Test public void test() throws InterruptedException &#123; // åˆ›å»ºå‘½ä»¤çš„è¡Œä¸ºä½“ Project projectDevelopment = new Project(\"å¸¦ä½ é£\"); // åˆ›å»ºå‘½ä»¤å¯¹è±¡(è€æ¿ä¸‹è¾¾å‘½ä»¤) MicroserviceCommand microserviceCommand = new MicroserviceCommand(projectDevelopment); MonomerCommand monomerCommand = new MonomerCommand(projectDevelopment); System.out.println(\"//-----------------------åˆ†åˆ«æ‰§è¡Œå‘½ä»¤---------------------------/\"); // å‘˜å·¥æ¥æ”¶å¹¶æ‰§è¡Œå‘½ä»¤ Staff staff = new Staff(); staff.execureCommand(microserviceCommand); staff.execureCommand(monomerCommand); Thread.sleep(2000); System.out.println(\"//-----------------------ç»Ÿä¸€æ‰§è¡Œå‘½ä»¤é›†-------------------------/\"); // å‘˜å·¥æ¥æ”¶å¤šä¸ªå‘½ä»¤,ç»Ÿä¸€æ‰§è¡Œ staff.addCommand(microserviceCommand); staff.addCommand(monomerCommand); staff.executeCommandList(); &#125;&#125; å‘½ä»¤æ¨¡å¼åœ¨æºç ä¸­çš„ä½¿ç”¨Runnableæ¥å£çš„å®ç°ç±» 1Runnableå¯ä»¥çœ‹æˆä¸€ä¸ªæŠ½è±¡çš„å‘½ä»¤ï¼Œå®ƒçš„å®ç°å¯ä»¥ç†è§£ä¸ºå…·ä½“çš„å‘½ä»¤å®ç°","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"çŠ¶æ€æ¨¡å¼","slug":"design_pattern/behaviour_type/çŠ¶æ€æ¨¡å¼","date":"2019-10-04T16:00:00.000Z","updated":"2020-08-09T09:28:21.142Z","comments":true,"path":"posts/8acb1976/","link":"","permalink":"https://gentryhuang.com/posts/8acb1976/","excerpt":"","text":"å®šä¹‰å…è®¸ä¸€ä¸ªå¯¹è±¡åœ¨å…¶å†…éƒ¨çŠ¶æ€æ”¹å˜æ—¶ï¼Œæ”¹å˜å®ƒçš„è¡Œä¸ºï¼Œå¦‚æœè¡Œä¸ºä¸éœ€è¦æ”¹å˜å°±ä¸è¦æ”¹å˜ã€‚ä¸€èˆ¬è¿™ä¸ªå­˜åœ¨å¤šä¸ªçŠ¶æ€çš„å¯¹è±¡æ˜¯ä¸€ä¸ªâ€œä¸Šä¸‹æ–‡â€ã€‚ ç±»å‹è¡Œä¸ºå‹ ä½¿ç”¨åœºæ™¯1ä¸€ä¸ªå¯¹è±¡å­˜åœ¨å¤šä¸ªçŠ¶æ€ï¼ˆä¸åŒçŠ¶æ€ä¸‹è¡Œä¸ºä¸åŒï¼‰ï¼Œä¸”çŠ¶æ€å¯ç›¸äº’è½¬æ¢ ä¼˜ç‚¹12341. å°†ä¸åŒçš„çŠ¶æ€éš”ç¦» - æ¯ä¸ªçŠ¶æ€éƒ½æ˜¯ä¸€ä¸ªç±»2. æŠŠå„ç§çŠ¶æ€çš„è½¬æ¢é€»è¾‘åˆ†å¸ƒåˆ°Stateçš„å­ç±»ä¸­ï¼Œå‡å°‘ç›¸äº’é—´ä¾èµ– 3. å¢åŠ æ–°çš„çŠ¶æ€éå¸¸ç®€å•ï¼ˆä¹Ÿå°±å¢åŠ ä¸€ä¸ªçŠ¶æ€ç±»ï¼Œå¦‚æœè¿˜è¦æ»¡è¶³ç›¸äº’è½¬æ¢ï¼Œå…¶ä»–å·²æœ‰çš„çŠ¶æ€å†…éƒ¨ä¹Ÿéœ€è¦ä¿®æ”¹ï¼‰ ç¼ºç‚¹1çŠ¶æ€å¤šçš„ä¸šåŠ¡åœºæ™¯å¯¼è‡´ç±»æ•°ç›®å¢åŠ ï¼Œç³»ç»Ÿå˜å¾—å¤æ‚ ç›¸å…³çš„è®¾è®¡æ¨¡å¼çŠ¶æ€æ¨¡å¼å’Œäº«å…ƒæ¨¡å¼ 1å®ƒä»¬æœ‰æ—¶å¯ä»¥é…åˆä½¿ç”¨ ç®€å•éœ€æ±‚æ’­æ”¾è§†é¢‘çš„æ—¶å€™ï¼Œæœ‰æ’­æ”¾çŠ¶æ€ã€å¿«è¿›æ’­æ”¾çŠ¶æ€ã€æš‚åœçŠ¶æ€ä»¥åŠåœæ­¢çŠ¶æ€ï¼Œè¿™äº›çŠ¶æ€å¤§éƒ½å¯ä»¥ç›¸äº’è½¬æ¢ã€‚å½“çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶å¯¹åº”çš„æ’­æ”¾è¡Œä¸ºä¹Ÿå‘ç”Ÿäº†æ”¹å˜ã€‚ çŠ¶æ€çˆ¶ç±» 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.state;import lombok.Setter;/** * VideoState è§†é¢‘çŠ¶æ€ * * @author shunhua * @date 2019-10-05 */@Setterpublic abstract class VideoState &#123; /** * è§†é¢‘èµ„æºä¸Šä¸‹æ–‡ */ protected VideoContext videoContext; /** * æ’­æ”¾ */ public abstract void play(); /** * å¿«è¿› */ public abstract void speed(); /** * æš‚åœ */ public abstract void pause(); /** * åœæ­¢ */ public abstract void stop(); &#125; æ’­æ”¾çŠ¶æ€ç±» 123456789101112131415161718192021222324252627282930313233343536373839404142package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;/** * PlayState è§†é¢‘æ’­æ”¾çŠ¶æ€ * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class PlayState extends VideoState &#123; @Override public void play() &#123; log.info(\"è§†é¢‘æ­£å¸¸æ’­æ”¾çŠ¶æ€\"); &#125; /** * å¯åˆ‡æ¢å¿«è¿› */ @Override public void speed() &#123; super.videoContext.setVideoState(VideoContext.SPEED_STATE); &#125; /** * å¯åˆ‡æ¢æš‚åœ */ @Override public void pause() &#123; super.videoContext.setVideoState(VideoContext.PAUSE_STATE); &#125; /** * å¯åˆ‡æ¢åœæ­¢ */ @Override public void stop() &#123; super.videoContext.setVideoState(VideoContext.STOP_STATE); &#125;&#125; æš‚åœæ’­æ”¾çŠ¶æ€ç±» 123456789101112131415161718192021222324252627282930313233package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;/** * PauseState è§†é¢‘æš‚åœçŠ¶æ€ * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class PauseState extends VideoState &#123; @Override public void play() &#123; super.videoContext.setVideoState(VideoContext.PLAY_STATE); &#125; @Override public void speed() &#123; super.videoContext.setVideoState(VideoContext.SPEED_STATE); &#125; @Override public void pause() &#123; log.info(\"è§†é¢‘æš‚åœæ’­æ”¾çŠ¶æ€\"); &#125; @Override public void stop() &#123; super.videoContext.setVideoState(VideoContext.STOP_STATE); &#125;&#125; å¿«è¿›æ’­æ”¾çŠ¶æ€ç±» 123456789101112131415161718192021222324252627282930313233package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;/** * SpeedState è§†é¢‘åŠ é€ŸçŠ¶æ€ * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class SpeedState extends VideoState &#123; @Override public void play() &#123; super.videoContext.setVideoState(VideoContext.PLAY_STATE); &#125; @Override public void speed() &#123; log.info(\"è§†é¢‘å¿«è¿›æ’­æ”¾çŠ¶æ€\"); &#125; @Override public void pause() &#123; super.videoContext.setVideoState(VideoContext.PAUSE_STATE); &#125; @Override public void stop() &#123; super.videoContext.setVideoState(VideoContext.STOP_STATE); &#125;&#125; åœæ­¢çŠ¶æ€ç±» 123456789101112131415161718192021222324252627282930313233package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;/** * StopState è§†é¢‘åœæ­¢çŠ¶æ€ * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class StopState extends VideoState &#123; @Override public void play() &#123; super.videoContext.setVideoState(VideoContext.PLAY_STATE); &#125; @Override public void speed() &#123; log.info(\"åœæ­¢çŠ¶æ€ä¸èƒ½å¿«è¿›\"); &#125; @Override public void pause() &#123; log.info(\"åœæ­¢çŠ¶æ€ä¸èƒ½æš‚åœ\"); &#125; @Override public void stop() &#123; log.info(\"è§†é¢‘åœæ­¢æ’­æ”¾çŠ¶æ€\"); &#125;&#125; çŠ¶æ€å¯¹åº”çš„ä¸Šä¸‹æ–‡ 123456789101112131415161718192021222324252627282930313233package com.design.pattern.state;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class Client &#123; @Test public void test()&#123; // å£°æ˜ä¸€ä¸ªä¸Šä¸‹æ–‡ VideoContext videoContext = new VideoContext(); videoContext.setVideoState(new PlayState()); log.info(\"å½“å‰çŠ¶æ€ï¼š\" + videoContext.getVideoState().getClass().getSimpleName()); videoContext.pause(); log.info(\"å½“å‰çŠ¶æ€ï¼š\" + videoContext.getVideoState().getClass().getSimpleName()); videoContext.speed(); log.info(\"å½“å‰çŠ¶æ€ï¼š\" + videoContext.getVideoState().getClass().getSimpleName()); videoContext.stop(); log.info(\"å½“å‰çŠ¶æ€ï¼š\" + videoContext.getVideoState().getClass().getSimpleName()); &#125;&#125; çŠ¶æ€æ¨¡å¼åœ¨æºç ä¸­çš„ä½¿ç”¨ çŠ¶æ€æ¨¡å¼å’Œä¸šåŠ¡åœºæ™¯æ›´ç´§å¯†ç›¸å…³ï¼Œæ¯”å¦‚ç”µå•†ä¸­è®¢å•çš„çŠ¶æ€ã€æ ¹æ®ä¸šåŠ¡è®¾ç½®çŠ¶æ€æœºã€åŠå…¬ç³»ç»Ÿæµç¨‹çš„çŠ¶æ€ç­‰ï¼Œæºç ä¸­ç›¸å¯¹å¾ˆå°‘ä½¿ç”¨","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"è®¿é—®è€…æ¨¡å¼","slug":"design_pattern/behaviour_type/è®¿é—®è€…æ¨¡å¼","date":"2019-10-04T16:00:00.000Z","updated":"2020-08-09T09:30:13.914Z","comments":true,"path":"posts/64b51ed9/","link":"","permalink":"https://gentryhuang.com/posts/64b51ed9/","excerpt":"","text":"å®šä¹‰å°è£…ä½œç”¨äºæŸæ•°æ®ç»“æ„(å¦‚List/Set/Mapç­‰)ä¸­çš„å„å…ƒç´ çš„æ“ä½œã€‚å¯ä»¥åœ¨ä¸æ”¹å˜å„å…ƒç´ çš„ç±»çš„å‰æä¸‹ï¼Œå®šä¹‰ä½œç”¨äºè¿™äº›å…ƒç´ çš„æ“ä½œã€‚å³å½“è®¿é—®æŸä¸ªèµ„æºæ—¶ï¼Œä¸å»ä¿®æ”¹èµ„æºæœ¬èº«è€Œæ˜¯å®šä¹‰è®¿é—®èµ„æºçš„æ“ä½œ ç±»å‹è¡Œä¸ºå‹ ä½¿ç”¨åœºæ™¯121. ä¸€ä¸ªæ•°æ®ç»“æ„å¦‚ï¼ˆList&#x2F;Set&#x2F;Mapç­‰ï¼‰åŒ…å«å¾ˆå¤šç±»å‹å¯¹è±¡2. æ•°æ®ç»“æ„äºæ•°æ®æ“ä½œåˆ†ç¦» ä¼˜ç‚¹1å¢åŠ æ–°çš„æ“ä½œå¾ˆå®¹æ˜“ï¼Œå³å¢åŠ ä¸€ä¸ªæ–°çš„è®¿é—®è€… ç¼ºç‚¹1231. å¢åŠ æ–°çš„æ•°æ®ç»“æ„å›°éš¾ï¼Œéœ€è¦ä¿®æ”¹çš„åœ°æ–¹æ¯”è¾ƒå¤š2. å…·ä½“å…ƒç´ å˜æ›´æ¯”è¾ƒéº»çƒ¦ - å¢åŠ æˆ–è€…åˆ é™¤å…ƒç´ é‡Œé¢çš„å±æ€§éƒ½ç®—å˜æ›´ ç›¸å…³çš„è®¾è®¡æ¨¡å¼è®¿é—®è€…æ¨¡å¼å’Œè¿­ä»£å™¨æ¨¡å¼ 121. å®ƒä»¬éƒ½æ˜¯åœ¨æŸç§æ•°æ®ç»“æ„ä¸Šè¿›è¡Œå¤„ç†2. è®¿é—®è€…æ¨¡å¼ä¸»è¦å¯¹ä¿å­˜åœ¨æ•°æ®ç»“æ„ä¸­çš„å…ƒç´ è¿›è¡ŒæŸç§ç‰¹å®šçš„å¤„ç†ï¼Œè¿­ä»£å™¨ç”¨äºé€ä¸ªéå†ä¿å­˜åœ¨æ•°æ®ç»“æ„ä¸­çš„ä¸€äº›å…ƒç´  ç®€å•éœ€æ±‚ç½‘ç»œè¯¾ç¨‹æœ‰å…è´¹çš„ä¹Ÿæœ‰ä»˜è´¹çš„ï¼Œå…è´¹çš„è¯¾ç¨‹æ™®é€šç”¨æˆ·éƒ½å¯ä»¥è®¿é—®ï¼Œä»˜è´¹çš„è¯¾ç¨‹éœ€è¦è´­ä¹°ç§°ä¸ºVipç”¨æˆ·æ‰èƒ½è®¿é—®ã€‚ç›¸åŒçš„èµ„æºä¸åŒçš„ç”¨æˆ·èº«ä»½ï¼Œè®¿é—®çš„ç»“æœä¸åŒ è®¿é—®è€…æ¨¡å¼æ¼”ç»ƒ å½“è®¿é—®æŸä¸ªèµ„æºæ—¶ï¼Œä¸å»ä¿®æ”¹èµ„æºæœ¬èº«è€Œæ˜¯å®šä¹‰è®¿é—®èµ„æºçš„æ“ä½œã€‚ç›¸åŒçš„èµ„æºä¸åŒçš„è®¿é—®èº«ä»½ï¼Œäº§ç”Ÿä¸åŒçš„æ“ä½œè¡Œä¸º æŠ½è±¡è¯¾ç¨‹èµ„æº 12345678910111213141516171819202122232425262728package com.design.pattern.visitor;import lombok.Getter;import lombok.Setter;/** * Course è¢«è®¿é—®çš„èµ„æº * * ä¸æ”¹å˜Course,è€Œæ˜¯å®šä¹‰è®¿é—®Courseçš„æ“ä½œï¼Œè¿™é‡Œä½“ç°åœ¨IVisitorçš„æ–¹æ³•ä¸Š * * @author shunhua * @date 2019-10-05 */@Getter@Setterpublic abstract class Course &#123; /** * è¯¾ç¨‹åç§° */ private String name; /** * æ¥å—è®¿é—® æŠŠè®¿é—®è€…ä¼ å…¥ * @param visitor */ public abstract void accept(IVisitor visitor); &#125; å…è´¹è¯¾ç¨‹èµ„æº 12345678910111213141516171819package com.design.pattern.visitor;/** * FreeCourse * * @author shunhua * @date 2019-10-05 */public class FreeCourse extends Course &#123; /** * æ¥å—è®¿é—® * @param visitor */ @Override public void accept(IVisitor visitor) &#123; visitor.visit(this); &#125;&#125; ä»˜è´¹è¯¾ç¨‹èµ„æº 12345678910111213141516171819202122232425262728package com.design.pattern.visitor;import lombok.Getter;import lombok.Setter;/** * PayCourse * * @author shunhua * @date 2019-10-05 */@Getter@Setterpublic class PayCourse extends Course &#123; /** * ä»·æ ¼ */ private int price; /** * æ¥å—è®¿é—® * @param visitor */ @Override public void accept(IVisitor visitor) &#123; visitor.visit(this); &#125;&#125; è®¿é—®è€…æŠ½è±¡ 12345678910111213141516171819202122232425package com.design.pattern.visitor;/** * IVisitor è®¿é—®æ¥å£ * * è¿™é‡Œå®šä¹‰äº†è®¿é—®èµ„æºçš„æ“ä½œï¼Œå…·ä½“çš„è®¿é—®ç»†èŠ‚ä½“ç°åœ¨å®ç°ç±»ä¸­ï¼Œä¸åŒçš„å®ç°ç±»å¯¹ç›¸åŒçš„èµ„æºäº§ç”Ÿä¸åŒçš„æ“ä½œè¡Œä¸ºï¼Œè¿™æ˜¯è®¿é—®è€…çš„æ ¸å¿ƒ * * @author shunhua * @date 2019-10-05 */public interface IVisitor &#123; /** * è®¿é—®å…è´¹è¯¾ç¨‹ * @param freeCourse */ void visit(FreeCourse freeCourse); /** * è®¿é—®ä»˜è´¹è¯¾ç¨‹ * @param payCourse */ void visit(PayCourse payCourse);&#125; æ™®é€šè®¿é—®è€… 12345678910111213141516171819202122232425262728293031package com.design.pattern.visitor;import lombok.extern.slf4j.Slf4j;/** * GeneralVisitor æ™®é€šè®¿é—®è€… * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class GeneralVisitor implements IVisitor &#123; /** * è®¿é—®å…è´¹è¯¾ç¨‹ * @param freeCourse */ @Override public void visit(FreeCourse freeCourse) &#123; log.info(\"å…è´¹è¯¾ç¨‹åï¼š\" + freeCourse.getName()); &#125; /** * è®¿é—®ä»˜è´¹è¯¾ç¨‹ * @param payCourse */ @Override public void visit(PayCourse payCourse) &#123; log.info(\"è¿™æ˜¯ä»˜è´¹è¯¾ç¨‹ï¼Œä½ è¿˜æ²¡æœ‰è´­ä¹°ï¼Œæ²¡æœ‰è®¿é—®æƒé™\"); &#125;&#125; Vipè®¿é—®è€… 12345678910111213141516171819202122232425262728293031package com.design.pattern.visitor;import lombok.extern.slf4j.Slf4j;/** * VipVisitor Vipè®¿é—®è€… * * @author shunhua * @date 2019-10-05 */@Slf4jpublic class VipVisitor implements IVisitor&#123; /** * è®¿é—®å…è´¹è¯¾ç¨‹ * @param freeCourse */ @Override public void visit(FreeCourse freeCourse) &#123; log.info(\"å…è´¹è¯¾ç¨‹åï¼š\" + freeCourse.getName()); &#125; /** * è®¿é—®ä»˜è´¹è¯¾ç¨‹ * @param payCourse */ @Override public void visit(PayCourse payCourse) &#123; log.info(\"ä»˜è´¹è¯¾ç¨‹åï¼š\" + payCourse.getName() + \" ä»·æ ¼ä¸ºï¼š\" + payCourse.getPrice()); &#125;&#125; å®¢æˆ·ç«¯ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.design.pattern.visitor;import org.junit.Test;import java.util.ArrayList;import java.util.List;/** * Client * * @author shunhua * @date 2019-10-05 */public class Client &#123; @Test public void test()&#123; List&lt;Course&gt; courseList = new ArrayList&lt;&gt;(); FreeCourse freeCourse = new FreeCourse(); freeCourse.setName(\"è¿™æ˜¯ä¸€ä¸ªå…è´¹çš„è¯¾ç¨‹\"); PayCourse payCourse = new PayCourse(); payCourse.setName(\"è¿™æ˜¯ä¸€ä¸ªä»˜è´¹çš„è¯¾ç¨‹\"); payCourse.setPrice(300); courseList.add(freeCourse); courseList.add(payCourse); // æ™®é€šè®¿é—®è€… GeneralVisitor generalVisitor = new GeneralVisitor(); // Vipç”¨æˆ· VipVisitor vipVisitor = new VipVisitor(); System.out.println(\"//----------æ™®é€šè®¿é—®è€…----------------/\"); courseList.stream().forEach(course -&gt; &#123; course.accept(generalVisitor); &#125;); System.out.println(\"//----------vipç”¨æˆ·------------------/\"); courseList.stream().forEach(course -&gt; &#123; course.accept(vipVisitor); &#125;); &#125;&#125; è®¿é—®è€…æ¨¡å¼åœ¨æºç ä¸­çš„ä½¿ç”¨FileVisitor 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package java.nio.file;import java.nio.file.attribute.BasicFileAttributes;import java.io.IOException;import java.util.Objects;/** * èµ„æºæ˜¯æ–‡ä»¶ * * @since 1.7 */public class SimpleFileVisitor&lt;T&gt; implements FileVisitor&lt;T&gt; &#123; /** * Initializes a new instance of this class. */ protected SimpleFileVisitor() &#123; &#125; /** * Invoked for a directory before entries in the directory are visited. * * &lt;p&gt; Unless overridden, this method returns &#123;@link FileVisitResult#CONTINUE * CONTINUE&#125;. */ @Override public FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException &#123; Objects.requireNonNull(dir); Objects.requireNonNull(attrs); return FileVisitResult.CONTINUE; &#125; /** * Invoked for a file in a directory. * * &lt;p&gt; Unless overridden, this method returns &#123;@link FileVisitResult#CONTINUE * CONTINUE&#125;. */ @Override public FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException &#123; Objects.requireNonNull(file); Objects.requireNonNull(attrs); return FileVisitResult.CONTINUE; &#125; /** * Invoked for a file that could not be visited. * * &lt;p&gt; Unless overridden, this method re-throws the I/O exception that prevented * the file from being visited. */ @Override public FileVisitResult visitFileFailed(T file, IOException exc) throws IOException &#123; Objects.requireNonNull(file); throw exc; &#125; /** * Invoked for a directory after entries in the directory, and all of their * descendants, have been visited. * * &lt;p&gt; Unless overridden, this method returns &#123;@link FileVisitResult#CONTINUE * CONTINUE&#125; if the directory iteration completes without an I/O exception; * otherwise this method re-throws the I/O exception that caused the iteration * of the directory to terminate prematurely. */ @Override public FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException &#123; Objects.requireNonNull(dir); if (exc != null) throw exc; return FileVisitResult.CONTINUE; &#125;&#125; BeanDefinitionVisitor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package org.springframework.beans.factory.config;import java.util.LinkedHashMap;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Set;import org.springframework.beans.MutablePropertyValues;import org.springframework.beans.PropertyValue;import org.springframework.lang.Nullable;import org.springframework.util.Assert;import org.springframework.util.ObjectUtils;import org.springframework.util.StringValueResolver;/** * èµ„æºï¼šBeançš„å®šä¹‰ * * @author Juergen Hoeller * @author Sam Brannen * @since 1.2 * @see BeanDefinition * @see BeanDefinition#getPropertyValues * @see BeanDefinition#getConstructorArgumentValues * @see PropertyPlaceholderConfigurer */public class BeanDefinitionVisitor &#123; @Nullable private StringValueResolver valueResolver; /** * Create a new BeanDefinitionVisitor, applying the specified * value resolver to all bean metadata values. * @param valueResolver the StringValueResolver to apply */ public BeanDefinitionVisitor(StringValueResolver valueResolver) &#123; Assert.notNull(valueResolver, \"StringValueResolver must not be null\"); this.valueResolver = valueResolver; &#125; /** * Create a new BeanDefinitionVisitor for subclassing. * Subclasses need to override the &#123;@link #resolveStringValue&#125; method. */ protected BeanDefinitionVisitor() &#123; &#125; /** * Traverse the given BeanDefinition object and the MutablePropertyValues * and ConstructorArgumentValues contained in them. * @param beanDefinition the BeanDefinition object to traverse * @see #resolveStringValue(String) */ public void visitBeanDefinition(BeanDefinition beanDefinition) &#123; visitParentName(beanDefinition); visitBeanClassName(beanDefinition); visitFactoryBeanName(beanDefinition); visitFactoryMethodName(beanDefinition); visitScope(beanDefinition); if (beanDefinition.hasPropertyValues()) &#123; visitPropertyValues(beanDefinition.getPropertyValues()); &#125; if (beanDefinition.hasConstructorArgumentValues()) &#123; ConstructorArgumentValues cas = beanDefinition.getConstructorArgumentValues(); visitIndexedArgumentValues(cas.getIndexedArgumentValues()); visitGenericArgumentValues(cas.getGenericArgumentValues()); &#125; &#125; &#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"ä¸­ä»‹è€…æ¨¡å¼","slug":"design_pattern/behaviour_type/ä¸­ä»‹è€…æ¨¡å¼","date":"2019-10-03T16:00:00.000Z","updated":"2020-08-09T09:26:26.731Z","comments":true,"path":"posts/d036071c/","link":"","permalink":"https://gentryhuang.com/posts/d036071c/","excerpt":"","text":"å®šä¹‰å®šä¹‰äº†ä¸€ä¸ªå°è£…ä¸€ç»„å¯¹è±¡å¦‚ä½•äº¤äº’çš„å¯¹è±¡ï¼ˆè¿™ä¸ªå¯¹è±¡ç”¨æ¥åè°ƒè¿™ä¸€ç»„å¯¹è±¡ï¼ˆâ€œåŒäº‹ç±»â€ï¼‰ï¼‰ã€‚é€šè¿‡ä½¿å¯¹è±¡æ˜ç¡®åœ°ç›¸äº’å¼•ç”¨æ¥ä¿ƒè¿›æ¾æ•£è€¦åˆï¼Œå¹¶å…è®¸ç‹¬ç«‹åœ°æ”¹å˜å®ƒä»¬çš„äº¤äº’ã€‚ ç±»å‹è¡Œä¸ºå‹ é€‚ç”¨åœºæ™¯121. ç³»ç»Ÿä¸­å¯¹è±¡ä¹‹é—´å­˜åœ¨å¤æ‚çš„å¼•ç”¨å…³ç³»ï¼Œäº§ç”Ÿçš„ç›¸äº’ä¾èµ–å…³ç³»ç»“æ„æ··ä¹±éš¾ä»¥ç†è§£ï¼Œä½¿ç”¨ä¸­ä»‹è€…è¿›è¡Œåè°ƒ2. äº¤äº’çš„å…¬å…±è¡Œä¸ºï¼Œå¦‚æœéœ€è¦æ”¹å˜è¡Œä¸ºåˆ™å¯ä»¥å¢åŠ æ–°çš„ä¸­ä»‹è€…ç±» ä¼˜ç‚¹121. å°†ä¸€å¯¹å¤šè½¬åŒ–æˆäº†ä¸€å¯¹ä¸€ã€é™ä½ç¨‹åºå¤æ‚åº¦2. ç±»ä¹‹é—´çš„è§£è€¦ ç¼ºç‚¹1ä¸­ä»‹è€…è¿‡å¤šï¼Œå¯¼è‡´ç³»ç»Ÿå¤æ‚ ç›¸å…³çš„è®¾è®¡æ¨¡å¼ä¸­ä»‹è€…æ¨¡å¼å’Œè§‚å¯Ÿè€…æ¨¡å¼ 1ä¸¤è€…æœ‰æ—¶ç»“åˆä½¿ç”¨ï¼Œä½¿ç”¨è§‚å¯Ÿè€…æ¨¡å¼å®ç°ä¸­ä»‹è€…æ¨¡å¼ä¸­è§’è‰²é—´çš„é€šä¿¡ ç®€å•éœ€æ±‚å…¬å¸çš„å‘˜å·¥ä¹‹é—´å‘é€å…¬æœ‰æ¶ˆæ¯ï¼Œä½¿ç”¨å·¥ä½œç¾¤ç»Ÿä¸€å‘é€ï¼Œä¸éœ€è¦å‘é€è€…é€ä¸€å‘ç»™å…¶ä»–å‘˜å·¥ ä¸­ä»‹è€…æ¨¡å¼æ¼”ç»ƒ ä¸­ä»‹è€… 12345678910111213141516171819202122232425package com.design.pattern.mediator;import lombok.extern.slf4j.Slf4j;import java.util.Date;/** * WorkGroup ä¸­ä»‹è€… - å·¥ä½œç¾¤ * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class WorkGroup &#123; /** * ä¸­ä»‹è€…æ˜¾ç¤ºå‘˜å·¥å‘é€çš„æ¶ˆæ¯ * @param worker * @param msg */ public static void showMsg(Worker worker, String msg)&#123; log.info(String.format(\"%s ã€%sã€‘: %s\",new Date().toString(),worker.getName(),msg)); &#125;&#125; å‚ä¸äº¤äº’çš„å¯¹è±¡ç±» 123456789101112131415161718192021222324252627package com.design.pattern.mediator;import lombok.AllArgsConstructor;import lombok.Data;/** * Worker å‘˜å·¥ é€šå¸¸ç§°ä¸ºâ€œåŒäº‹ç±»â€ * * @author shunhua * @date 2019-10-04 */@Data@AllArgsConstructorpublic class Worker &#123; /** * èŠ±å */ private String name; /** * å‘˜å·¥åªå’Œä¸­ä»‹è€…ï¼ˆå·¥ä½œç¾¤ï¼‰æ‰“äº¤é“ï¼Œè¿™æ˜¯ä¸­ä»‹è€…æ¨¡å¼çš„æ ¸å¿ƒ * @param msg */ public void sendMsg(String msg)&#123; WorkGroup.showMsg(this,msg); &#125;&#125; åº”ç”¨å±‚ 12345678910111213141516171819202122232425package com.design.pattern.mediator;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-04 */public class Client &#123; @Test public void test()&#123; Worker worker = new Worker(\"èˆœå\"); Worker worker1= new Worker(\"é«˜æ–¯æ—\"); worker1.sendMsg(\"å°ä¼™å­ï¼Œå°±ä½ è¿˜æƒ³å­¦æˆ‘çš„Javaï¼ï¼ï¼\"); worker.sendMsg(\"æœ‰å¥è¯ä¸çŸ¥å½“è®²ä¸å½“è®²ï¼Ÿ\"); &#125;&#125; ä¸­ä»‹è€…æ¨¡å¼åœ¨æºç ä¸­çš„ä½¿ç”¨Timer 1Timeræ˜¯ä¸€ä¸ªä¸­ä»‹è€…ï¼Œå®ƒåè°ƒTimerTaskä»»åŠ¡ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package java.util;import java.util.Date;import java.util.concurrent.atomic.AtomicInteger;public class Timer &#123; /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they're obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); /** * Timerä¸­æœ‰å¤šä¸ªscheduleé‡è½½æ–¹æ³•ï¼Œé‡Œé¢éƒ½è°ƒç”¨äº†schedæ–¹æ³• */ public void schedule(TimerTask task, long delay) &#123; if (delay &lt; 0) throw new IllegalArgumentException(\"Negative delay.\"); sched(task, System.currentTimeMillis()+delay, 0); &#125; /** * * Timeræ˜¯ä¸€ä¸ªä¸­ä»‹è€…ï¼Œé€šè¿‡schedæ–¹æ³•ç»Ÿä¸€åè°ƒTimerTask * * @param task è¢«åè°ƒçš„å¯¹è±¡ * @param time * @param period */ private void sched(TimerTask task, long time, long period) &#123; if (time &lt; 0) throw new IllegalArgumentException(\"Illegal execution time.\"); // Constrain value of period sufficiently to prevent numeric // overflow while still being effectively infinitely large. if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1)) period &gt;&gt;= 1; synchronized(queue) &#123; if (!thread.newTasksMayBeScheduled) throw new IllegalStateException(\"Timer already cancelled.\"); synchronized(task.lock) &#123; if (task.state != TimerTask.VIRGIN) throw new IllegalStateException( \"Task already scheduled or cancelled\"); task.nextExecutionTime = time; task.period = period; task.state = TimerTask.SCHEDULED; &#125; queue.add(task); if (queue.getMin() == task) queue.notify(); &#125; &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"å¤‡å¿˜å½•æ¨¡å¼","slug":"design_pattern/behaviour_type/å¤‡å¿˜å½•æ¨¡å¼","date":"2019-10-03T16:00:00.000Z","updated":"2020-08-09T09:27:24.516Z","comments":true,"path":"posts/c3176455/","link":"","permalink":"https://gentryhuang.com/posts/c3176455/","excerpt":"","text":"å®šä¹‰ä¿å­˜ä¸€ä¸ªå¯¹è±¡çš„æŸä¸ªçŠ¶æ€ï¼Œä»¥ä¾¿åœ¨é€‚å½“çš„æ—¶å€™æ¢å¤å¯¹è±¡ã€‚è¿™é‡Œçš„çŠ¶æ€å¯ä»¥ç†è§£ä¸ºå¯¹è±¡çš„ä¸€ä¸ªå¿«ç…§ã€‚ ç±»å‹è¡Œä¸ºå‹ é€‚ç”¨åœºæ™¯121 ä¿å­˜åŠæ¢å¤æ•°æ®ç›¸å…³ä¸šåŠ¡åœºæ™¯2 åæ‚”çš„æ—¶å€™ï¼Œå³æƒ³æ¢å¤åˆ°ä¹‹å‰çš„çŠ¶æ€ ä¼˜ç‚¹121 ä¸ºç”¨æˆ·æä¾›ä¸€ç§å¯æ¢å¤æœºåˆ¶2 å­˜æ¡£ä¿¡æ¯çš„å°è£… ç¼ºç‚¹12èµ„æºå ç”¨ - å¦‚æœæš‚å­˜çš„å¯¹è±¡æ¯”è¾ƒå¤šï¼Œè€Œä¸”å¯¹è±¡çš„å±æ€§ä¹Ÿæ¯”è¾ƒå¤šï¼Œé‚£ä¹ˆè‚¯å®šä¼šå¯¹èµ„æºé€ æˆä¸€å®šçš„æ¶ˆè€—ï¼Œå ç”¨å¤§é‡çš„èµ„æºã€‚ ç›¸å…³çš„è®¾è®¡æ¨¡å¼å¤‡å¿˜å½•æ¨¡å¼å’ŒçŠ¶æ€æ¨¡å¼ 1å¤‡å¿˜å½•æ¨¡å¼ä¸­æ˜¯ç”¨å®ä¾‹æ¥è¡¨ç¤ºçŠ¶æ€çš„ï¼Œæˆ‘ä»¬å­˜æ¡£çš„æ˜¯ä¸€ä¸ªå¯¹è±¡å®ä¾‹ã€‚çŠ¶æ€æ¨¡å¼ä¸­æ˜¯ä½¿ç”¨ç±»æ¥è¡¨ç¤ºçŠ¶æ€ã€‚ ç®€å•éœ€æ±‚åœ¨å†™æ–‡æ¡£æ—¶ï¼Œé—´æ–­æ€§åœ°ä¿å­˜ï¼Œç„¶åå¯ä»¥æ’¤é”€å›é€€åˆ°ä¸Šä¸€ä¸ªç‰ˆæœ¬ å¤‡å¿˜å½•æ¨¡å¼æ¼”ç»ƒ æ–‡ç«  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.design.pattern.memento;import lombok.AllArgsConstructor;import lombok.Data;import java.io.Serializable;/** * Article æ–‡ç«  * * @author shunhua * @date 2019-10-04 */@Data@AllArgsConstructorpublic class Article implements Serializable &#123; private static final long serialVersionUID = -321234774998152556L; /** * æ–‡ç« æ ‡é¢˜ */ private String title; /** * æ–‡ç« å†…å®¹ */ private String content; /** * å›¾ç‰‡ */ private String img; /** * æŠŠæ–‡ç« ä¿å­˜èµ·æ¥ * @return */ public ArticleMemento saveToMemento()&#123; ArticleMemento articleMemento = new ArticleMemento(this.title,this.content,this.img); return articleMemento; &#125; /** * æŠŠä¿å­˜çš„æ–‡ç« æ ‡é¢˜ã€å†…å®¹ä»¥åŠå›¾ç‰‡å›é€€å›æ¥ * @param articleMemento */ public void undoFromMemento(ArticleMemento articleMemento)&#123; this.title = articleMemento.getTitle(); this.content = articleMemento.getContent(); this.img = articleMemento.getImg(); &#125;&#125; æ–‡ç« å¿«ç…§ 123456789101112131415161718192021222324252627282930package com.design.pattern.memento;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.ToString;/** * ArticleMemento æ–‡ç« å¿«ç…§,å¯¹äºå¿«ç…§ä¸éœ€è¦Setteræ–¹æ³•ï¼Œåªç”¨äºä¿å­˜ * * @author shunhua * @date 2019-10-04 */@Getter@ToString@AllArgsConstructorpublic class ArticleMemento &#123; /** * æ ‡é¢˜ */ private String title; /** * å†…å®¹ */ private String content; /** * å›¾ç‰‡ */ private String img;&#125; æ–‡ç« å¿«ç…§æš‚å­˜ç®¡ç† 12345678910111213141516171819202122232425262728293031323334package com.design.pattern.memento;import java.util.Stack;/** * ArticleMementoManager æ–‡ç« å¿«ç…§ç®¡ç†è€… * * @author shunhua * @date 2019-10-04 */public class ArticleMementoManager &#123; /** * ä¿å­˜ æ–‡ç« å¿«ç…§ çš„æ ˆï¼Œåœ¨å›é€€çš„æ—¶å€™å›é€€çš„æ˜¯æœ€æ–°çš„çŠ¶æ€ */ private final Stack&lt;ArticleMemento&gt; ARTICLE_MEMENTO_STACK = new Stack&lt;&gt;(); /** * è·å–æ–‡ç« å¿«ç…§ * @return */ public ArticleMemento getMemento()&#123; ArticleMemento articleMemento = ARTICLE_MEMENTO_STACK.pop(); return articleMemento; &#125; /** * æŠŠæ–‡ç« ä¿å­˜ä¸ºå¿«ç…§ * @param articleMemento */ public void addMemento(ArticleMemento articleMemento)&#123; ARTICLE_MEMENTO_STACK.push(articleMemento); &#125;&#125; å¤‡å¿˜å½•æ¨¡å¼åœ¨æºç ä¸­çš„ä½¿ç”¨spring-webflowä¸­çš„ä½¿ç”¨ 123456789101112131415161718192021222324252627282930313233343536373839package org.springframework.binding.message;import java.io.Serializable;import org.springframework.context.MessageSource;/** * A message context whose internal state can be managed by an external care-taker. State management employs the GOF * Memento pattern. This context can produce a serializable memento representing its internal state at any time. A * care-taker can then use that memento at a later time to restore any context instance to a previous state. * * @author Keith Donald */public interface StateManageableMessageContext extends MessageContext &#123; /** * å­˜æ¡£ * Create a serializable memento, or token representing a snapshot of the internal state of this message context. * @return the messages memento */ Serializable createMessagesMemento(); /** * å›é€€ * Set the state of this context from the memento provided. After this call, the messages in this context will match * what is encapsulated inside the memento. Any previous state will be overridden. * @param messagesMemento the messages memento */ void restoreMessages(Serializable messagesMemento); /** * Configure the message source used to resolve messages added to this context. May be set at any time to change how * coded messages are resolved. * @param messageSource the message source * @see MessageContext#addMessage(MessageResolver) */ void setMessageSource(MessageSource messageSource);&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"è´£ä»»é“¾æ¨¡å¼","slug":"design_pattern/behaviour_type/è´£ä»»é“¾æ¨¡å¼","date":"2019-10-03T16:00:00.000Z","updated":"2020-08-09T09:30:40.577Z","comments":true,"path":"posts/6208627e/","link":"","permalink":"https://gentryhuang.com/posts/6208627e/","excerpt":"","text":"å®šä¹‰è´£ä»»é“¾æ¨¡å¼åˆå«èŒè´£é“¾æ¨¡å¼ã€‚ä¸ºè¯·æ±‚åˆ›å»ºä¸€ä¸ªæ¥æ”¶æ­¤æ¬¡è¯·æ±‚çš„å¯¹è±¡çš„é“¾ï¼Œè¿™ä¸ªé“¾æ¡ç”±å¤šä¸ªå¯¹è±¡ç»„æˆã€‚ ç±»å‹è¡Œä¸ºå‹ é€‚ç”¨åœºæ™¯1ä¸€ä¸ªè¯·æ±‚çš„å¤„ç†éœ€è¦é“¾ä¸­ä¸€ä¸ªæˆ–å¤šä¸ªåä½œå¤„ç† ä¼˜ç‚¹1231.è¯·æ±‚çš„å‘é€è€…å’Œæ¥æ”¶è€…ï¼ˆè¯·æ±‚çš„å¤„ç†è€…ï¼‰è§£è€¦ 2.è´£ä»»é“¾å¯ä»¥åŠ¨æ€ç»„åˆ3.è´£ä»»é“¾æ–¹ä¾¿æ‰©å±•å’Œæ”¶ç¼©ï¼ˆå¢åŠ æˆ–å‡å°‘å¤„ç†å¯¹è±¡ï¼‰ ç¼ºç‚¹121. è´£ä»»é“¾å¤ªé•¿æˆ–è€…å¤„ç†æ—¶é—´è¿‡é•¿ä¼šå½±å“æ€§èƒ½2. è´£ä»»é“¾æœ‰å¯èƒ½è¿‡å¤š ç›¸å…³çš„è®¾è®¡æ¨¡å¼è´£ä»»é“¾æ¨¡å¼å’ŒçŠ¶æ€æ¨¡å¼ 1è´£ä»»é“¾æ¨¡å¼ä¸­å„ä¸ªå¯¹è±¡ä¸ä¼šæŒ‡å®šä¸‹ä¸€ä¸ªå¤„ç†å¯¹è±¡æ˜¯è°ï¼Œåªæœ‰åœ¨å®¢æˆ·ç«¯è®¾å®šé“¾æ¡ä¸­çš„é¡ºåºä»¥åŠå…ƒç´ ç›´åˆ°è¢«æŸä¸ªå…ƒç´ å¤„ç†æˆ–æ•´æ¡é“¾ç»“æŸã€‚çŠ¶æ€æ¨¡å¼æ˜¯è®©æ¯ä¸ªçŠ¶æ€å¯¹è±¡çŸ¥é“è‡ªå·±ä¸‹ä¸€ä¸ªå¤„ç†çš„å¯¹è±¡æ˜¯è°ï¼Œåœ¨ç¼–è¯‘æ—¶å°±è®¾å®šå¥½äº†ã€‚ ç®€å•éœ€æ±‚åœ¨æ³¨å†Œç½‘ç«™çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦æä¾›ç”¨æˆ·åã€é‚®ç®±ä»¥åŠå¯†ç ï¼Œç½‘ç«™ä¼šæœ‰ä¸€ä¸ªæ ¡éªŒæµç¨‹ï¼Œåˆ†åˆ«å¯¹ç”¨æˆ·åã€é‚®ç®±ä»¥åŠå¯†ç è¿›è¡Œæ ¡éªŒï¼Œå¦‚æœä»»ä½•ä¸€ä¸ªæ­¥éª¤æ²¡æœ‰é€šè¿‡å°±ä¸èƒ½æ³¨å†Œï¼Œåªæœ‰å…¨éƒ¨æ ¡éªŒé€šè¿‡æ‰èƒ½å®Œæˆæ³¨å†Œã€‚ è´£ä»»é“¾æ¨¡å¼æ¼”ç»ƒ è´£ä»»é“¾çš„æ„å»ºæ˜¯ç”±å®¢æˆ·ç«¯å†³å®šçš„ï¼Œè´£ä»»é“¾çš„å…¥å£ä¹Ÿæ˜¯å®¢æˆ·ç«¯å†³å®šçš„ å¾…å¤„ç†çš„å¯¹è±¡ 12345678910111213141516171819202122232425262728package com.design.pattern.chain;import lombok.AllArgsConstructor;import lombok.Data;/** * User å¾…æ ¡éªŒçš„ç”¨æˆ· * * @author shunhua * @date 2019-10-04 */@Data@AllArgsConstructorpublic class User &#123; /** * ç”¨æˆ·å */ private String name; /** * é‚®ç®± */ private String email; /** * å¯†ç  */ private String password;&#125; å¤„ç†å™¨çˆ¶ç±» 1234567891011121314151617181920212223242526272829303132package com.design.pattern.chain;/** * Handler è´£ä»»é“¾æ¨¡å¼çš„æ ¸å¿ƒ * * æ³¨æ„ï¼šæ„é€ è´£ä»»é“¾æ˜¯å®¢æˆ·ç«¯çš„ä»»åŠ¡,å¹¶ä¸”å…¥å£ä¹Ÿæ˜¯å®¢æˆ·å•é€‰æ‹©çš„ * * @author shunhua * @date 2019-10-04 */public abstract class Handler &#123; /** * ä¸€ä¸ªè‡ªå·±ç±»å‹çš„å¯¹è±¡ï¼Œä¸€èˆ¬æ˜¯å­ç±»å¯¹è±¡ */ protected Handler handler; /** * è®¾ç½®ä¸‹ä¸€ä¸ªå¤„ç†å™¨ * @param handler */ public void setNextHandler(Handler handler)&#123; this.handler = handler; &#125; /** * äº¤ç»™å­ç±»å®ç°ï¼Œç”¨æ¥æ ¡éªŒç”¨æˆ·ä¿¡æ¯æ˜¯å¦ç¬¦åˆ * @param user */ protected abstract void handle(User user);&#125; åç§°å¤„ç†å™¨ 1234567891011121314151617181920212223242526272829303132333435package com.design.pattern.chain;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.util.ObjectUtils;/** * NameHandler ç”¨æˆ·åå¤„ç†å™¨ * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class NameHandler extends Handler &#123; /** * æ ¡éªŒç”¨æˆ·å * @param user */ @Override protected void handle(User user) &#123; if(StringUtils.isNotBlank(user.getName()))&#123; log.info(\"ç”¨æˆ·åç¬¦åˆè¦æ±‚\"); // å¦‚æœæœ‰ä¸‹ä¸€ä¸ªæ ¡éªŒå™¨å°±ç»§ç»­æ‰§è¡Œï¼Œæ³¨æ„è¿™ä¸ªé“¾çš„é¡ºåºæ˜¯ç”±å®¢æˆ·ç«¯å†³å®šçš„ if(!ObjectUtils.isEmpty(super.handler))&#123; super.handler.handle(user); return; &#125;else &#123; log.info(\"å®Œæˆæ³¨å†Œ\"); &#125; return; &#125; log.info(\"ç”¨æˆ·åæ ¡éªŒä¸é€šè¿‡ï¼Œç»“æŸæ ¡éªŒ\"); &#125;&#125; é‚®ç®±å¤„ç†å™¨ 123456789101112131415161718192021222324252627282930package com.design.pattern.chain;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.util.ObjectUtils;/** * EmailHandler é‚®ç®±æ ¡éªŒå™¨ * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class EmailHandler extends Handler&#123; @Override protected void handle(User user) &#123; if(StringUtils.isNotBlank(user.getEmail()))&#123; log.info(\"é‚®ç®±ç¬¦åˆè¦æ±‚\"); if(!ObjectUtils.isEmpty(super.handler))&#123; super.handler.handle(user); return; &#125;else &#123; log.info(\"å®Œæˆæ³¨å†Œ\"); &#125; return; &#125; log.info(\"é‚®ç®±éªŒè¯ä¸é€šè¿‡ï¼ŒéªŒè¯ç»“æŸ\"); &#125;&#125; å¯†ç å¤„ç†å™¨ 123456789101112131415161718192021222324252627282930package com.design.pattern.chain;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.util.ObjectUtils;/** * PasswordHandler å¯†ç éªŒè¯å™¨ * * @author shunhua * @date 2019-10-04 */@Slf4jpublic class PasswordHandler extends Handler &#123; @Override protected void handle(User user) &#123; if(StringUtils.isNotBlank(user.getPassword()) &amp;&amp; user.getPassword().length() &gt;5)&#123; log.info(\"å¯†ç ç¬¦åˆè¦æ±‚\"); if(!ObjectUtils.isEmpty(super.handler))&#123; super.handler.handle(user); return; &#125;else &#123; log.info(\"å®Œæˆæ³¨å†Œ\"); &#125; return; &#125; log.info(\"å¯†ç éªŒè¯ä¸é€šè¿‡ï¼ŒéªŒè¯ç»“æŸ\"); &#125;&#125; å®¢æˆ·ç«¯ 12345678910111213141516171819202122232425262728293031323334353637package com.design.pattern.chain;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-04 */public class Client &#123; @Test public void test()&#123; // åˆ›å»ºå¾…éªŒè¯çš„ç”¨æˆ· User user = new User(\"shunhua\",\"gentryhuang.xw@gmail.com\",\"123456\"); // å§“åéªŒè¯å™¨ NameHandler nameHandler = new NameHandler(); // é‚®ç®±éªŒè¯å™¨ EmailHandler emailHandler = new EmailHandler(); // å¯†ç éªŒè¯å™¨ PasswordHandler passwordHandler = new PasswordHandler(); /** * æ³¨æ„ï¼šæ„é€ è´£ä»»é“¾æ˜¯å®¢æˆ·ç«¯å†³å®šçš„ * * æ„å»ºè´£ä»»é“¾ : NameHandler -&gt; EmailHandler -&gt; PasswordHandler */ nameHandler.setNextHandler(emailHandler); emailHandler.setNextHandler(passwordHandler); /** * å¤„ç†è¯·æ±‚å…¥å£ */ nameHandler.handle(user); &#125;&#125; è´£ä»»é“¾åœ¨æºç ä¸­çš„ä½¿ç”¨è¿‡æ»¤å™¨-Filter 123456789101112131415161718192021222324252627282930313233// ä»¥OncePerRequestFilterä¸ºä¾‹public abstract class OncePerRequestFilter extends GenericFilterBean &#123; public static final String ALREADY_FILTERED_SUFFIX = \".FILTERED\"; public OncePerRequestFilter() &#123; &#125; public final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (request instanceof HttpServletRequest &amp;&amp; response instanceof HttpServletResponse) &#123; HttpServletRequest httpRequest = (HttpServletRequest)request; HttpServletResponse httpResponse = (HttpServletResponse)response; String alreadyFilteredAttributeName = this.getAlreadyFilteredAttributeName(); boolean hasAlreadyFilteredAttribute = request.getAttribute(alreadyFilteredAttributeName) != null; if (!hasAlreadyFilteredAttribute &amp;&amp; !this.skipDispatch(httpRequest) &amp;&amp; !this.shouldNotFilter(httpRequest)) &#123; request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE); try &#123; this.doFilterInternal(httpRequest, httpResponse, filterChain); &#125; finally &#123; request.removeAttribute(alreadyFilteredAttributeName); &#125; &#125; else &#123; // å¾…ä¸‹ä¸€ä¸ªè¿‡æ»¤å™¨å¤„ç† filterChain.doFilter(request, response); &#125; &#125; else &#123; throw new ServletException(\"OncePerRequestFilter just supports HTTP requests\"); &#125; &#125; // ... &#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"ä»£ç†æ¨¡å¼","slug":"design_pattern/structure_type/ä»£ç†æ¨¡å¼","date":"2019-10-02T16:00:00.000Z","updated":"2020-09-30T07:05:03.261Z","comments":true,"path":"posts/7b510e10/","link":"","permalink":"https://gentryhuang.com/posts/7b510e10/","excerpt":"","text":"å®šä¹‰ä¸ºå…¶ä»–å¯¹è±¡æä¾›ä¸€ç§ä»£ç†ï¼Œä»¥æ§åˆ¶å¯¹è¿™ä¸ªå¯¹è±¡çš„è®¿é—®ã€‚ä»£ç†å¯¹è±¡åœ¨å®¢æˆ·ç«¯å’Œç›®æ ‡å¯¹è±¡ä¹‹é—´èµ·åˆ°ä¸­ä»‹çš„ä½œç”¨ã€‚ ä¸¾ä¾‹ï¼šç§Ÿæˆ¿å­ï¼Œç›®æ ‡å¯¹è±¡ä»£è¡¨æˆ¿ä¸œï¼Œå®¢æˆ·ç«¯ä»£è¡¨ç”¨æˆ·ï¼Œæˆ¿å±‹ä¸­ä»‹ä»£è¡¨ä¸­ä»‹ã€‚æˆ¿å±‹ä¸­ä»‹èµ·åˆ°ä»£ç†çš„ä½œç”¨ï¼Œç­¾åˆåŒå’Œç¼´çº³æ°´ç”µè´¹ç›´æ¥æ‰¾ä¸­ä»‹å°±å¯ä»¥äº†ï¼Œä¸éœ€è¦å’Œæˆ¿ä¸œç›´æ¥æ¥è§¦ï¼Œå³ä¸­ä»‹ä»£ç†æˆ¿ä¸œã€‚ ç±»å‹ç»“æ„å‹ ä½¿ç”¨åœºæ™¯12â—† ä¿æŠ¤ç›®æ ‡å¯¹è±¡â—† å¢å¼ºç›®æ ‡å¯¹è±¡ ä¼˜ç‚¹1234â—† ä»£ç†æ¨¡å¼èƒ½å°†ä»£ç†å¯¹è±¡ä¸çœŸå®è¢«è°ƒç”¨çš„ç›®æ ‡å¯¹è±¡åˆ†ç¦»â—† ä¸€å®šç¨‹åº¦ä¸Šé™ä½äº†ç³»ç»Ÿçš„è€¦åˆåº¦ï¼Œæ‰©å±•æ€§å¥½â—† ä¿æŠ¤ç›®æ ‡å¯¹è±¡â—† åœ¨ä¸ä¿®æ”¹ç›®æ ‡ç±»çš„å‰æä¸‹ï¼Œå¢å¼ºç›®æ ‡å¯¹è±¡ ç¼ºç‚¹123â—† ä»£ç†æ¨¡å¼ä¼šé€ æˆç³»ç»Ÿè®¾è®¡ä¸­ç±»çš„æ•°ç›®å¢åŠ â—† åœ¨å®¢æˆ·ç«¯å’Œç›®æ ‡å¯¹è±¡å¢åŠ ä¸€ä¸ªä»£ç†å¯¹è±¡ï¼Œä¼šé€ æˆè¯·æ±‚å¤„ç†é€Ÿåº¦å˜æ…¢â—† å¢åŠ ç³»ç»Ÿçš„å¤æ‚åº¦ æ‰©å±• æ ¹æ®ä»£ç†å¯¹è±¡ä¸ç›®æ ‡å¯¹è±¡ä»£ç†å…³ç³»çš„åˆ›å»ºæ—¶æœºçš„ä¸åŒï¼Œå¯ä»¥åˆ†ä¸ºé™æ€ä»£ç†å’ŒåŠ¨æ€ä»£ç†ã€‚åŠ¨æ€ä»£ç†åˆæ ¹æ®å®ç°æŠ€æœ¯çš„ä¸åŒåˆ†ä¸ºJDKçš„ProxyåŠ¨æ€ä»£ç†å’ŒCGLIBåŠ¨æ€ä»£ç†ã€‚ é™æ€ä»£ç† 1é™æ€ä»£ç†å°±æ˜¯åœ¨ä»£ç ä¸­æŒ‡å®šæ˜¾å¼çš„ä»£ç†,åœ¨ç¼–è¯‘ä¹‹å‰ä»£ç†å…³ç³»å°±å·²ç»ç¡®å®šäº†ã€‚åœ¨ä»£ç†ç±»ä¸­å¯¹åŒåçš„æ–¹æ³•è¿›è¡ŒåŒ…è£…ï¼Œç”¨æˆ·é€šè¿‡å¯¹ä»£ç†ç±»çš„è¢«åŒ…è£…è¿‡çš„æ–¹æ³•æ¥è°ƒç”¨ç›®æ ‡å¯¹è±¡çš„ä¸šåŠ¡æ–¹æ³•ï¼ŒåŒæ—¶å¯¹ç›®æ ‡å¯¹è±¡çš„ä¸šåŠ¡æ–¹æ³•è¿›è¡Œå¢å¼ºã€‚ JDKåŠ¨æ€ä»£ç† 1jdkçš„åŠ¨æ€ä»£ç†æ˜¯é€šè¿‡æ¥å£ä¸­çš„æ–¹æ³•åå¯¹åœ¨åŠ¨æ€ç”Ÿæˆçš„ä»£ç†ç±»ä¸­ï¼Œè°ƒç”¨ä¸šåŠ¡å®ç°ç±»çš„åŒåæ–¹æ³•ã€‚æ³¨æ„:å¿…é¡»æ˜¯æ¥å£,å› ä¸ºjdkåº•å±‚å…ˆåˆ›å»ºä¸€ä¸ªä»£ç†ç±»ï¼Œç„¶åå†åˆ›å»ºä»£ç†ç±»çš„å®ä¾‹ï¼Œå®ƒçš„ç±»å‹æ˜¯æ¥å£ç±»å‹ï¼Œä¸æ˜¯ç›®æ ‡ç±»çš„ç±»å‹ã€‚JDKåŠ¨æ€ä»£ç†åº•å±‚ä¹Ÿæ˜¯ä½¿ç”¨çš„å­—èŠ‚ç æŠ€æœ¯ã€‚ CGLIBä»£ç† 1cglibæ˜¯é€šè¿‡ç»§æ‰¿æ¥å®ç°çš„ï¼Œç”Ÿæˆçš„ä»£ç†ç±»æ˜¯ä¸šåŠ¡ç±»çš„å­ç±»ï¼Œé€šè¿‡é‡å†™ä¸šåŠ¡æ–¹æ³•æ‰§è¡Œä»£ç†ã€‚ä½¿ç”¨CGLibè¿›è¡Œä»£ç†æ—¶ä¸€å®šè¦æ³¨æ„finalä¿®æ”¹çš„ç±»å’Œæ–¹æ³•ä»¥åŠæ˜¯å¦æœ‰æ— å‚æ„é€ å™¨ã€‚CGLibåº•å±‚ä½¿ç”¨asmå­—èŠ‚ç ç”Ÿæˆçš„ã€‚ ä»£ç†æ¨¡å¼ç›¸å…³çš„è®¾è®¡æ¨¡å¼ä»£ç†æ¨¡å¼å’Œè£…é¥°è€…æ¨¡å¼ 1ç›®çš„ä¸åŒï¼Œè£…é¥°è€…æ¨¡å¼æ˜¯ä¸ºå¯¹è±¡åŠ ä¸Šè¡Œä¸ºï¼Œè€Œä»£ç†æ¨¡å¼æ˜¯æ§åˆ¶è®¿é—®ï¼Œä»£ç†æ¨¡å¼æ›´åŠ å…³æ³¨é€šè¿‡æ§åˆ¶ä»£ç†äººçš„æ–¹å¼æ¥å¢å¼ºç›®æ ‡å¯¹è±¡ã€‚å¢å¼ºå¯¹è±¡çš„æ–¹å¼ä¸€èˆ¬æ˜¯å¢å¼ºå¯¹è±¡çš„æŸäº›è¡Œä¸ºã€‚ ä»£ç†æ¨¡å¼å’Œé€‚é…å™¨æ¨¡å¼ 1é€‚é…å™¨æ¨¡å¼ä¸»è¦æ”¹å˜æ‰€è¦è€ƒè™‘å¯¹è±¡çš„æ¥å£ï¼Œä»£ç†æ¨¡å¼ä¸å¯ä»¥æ”¹å˜æ‰€ä»£ç†ç±»çš„æ¥å£ã€‚ ä»£ç†æ¨¡å¼æ¼”ç»ƒé™æ€ä»£ç† é™æ€ä»£ç†çš„ä»£ç†ç±»æ˜¯æ‰‹åŠ¨ç¼–å†™çš„ï¼Œä»£ç†å…³ç³»åœ¨ç¼–è¯‘ä¹‹å‰å°±ç¡®ç«‹äº†ã€‚é€šå¸¸ç›®æ ‡å¯¹è±¡åœ¨ä»£ç†ç±»ä¸­åˆ›å»ºã€‚ ç›®æ ‡ç±»æ¥å£ 1234567891011121314package com.design.pattern.proxy.staticproxy;/** * IRentalHouseService * * @author shunhua * @date 2019-10-03 */public interface IRentalHouseService &#123; /** * ç§Ÿæˆ¿æ–¹æ³• */ void rent();&#125; ç›®æ ‡ç±» 123456789101112131415161718192021222324package com.design.pattern.proxy.jdkproxy;import com.design.pattern.proxy.staticproxy.IRentalHouseService;import lombok.extern.slf4j.Slf4j;/** *RentalHouseServiceImpl * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseService implements IRentalHouseService &#123; /** * å‡ºç§Ÿæˆ¿å­ï¼Œç›®æ ‡æ–¹æ³• * @return */ @Override public void rent()&#123; log.info(\"1800/æœˆï¼Œ2å®¤1å…1å¨1å«ï¼\"); &#125;&#125; ä»£ç†ç±» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.design.pattern.proxy.staticproxy;import lombok.extern.slf4j.Slf4j;/** * RentalHouseServiceProxy ä»£ç†ç±» * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceProxy &#123; /** * ä»£ç†å¯¹è±¡éœ€è¦ç›®æ ‡å¯¹è±¡ */ private RentalHouseService rentalHouseService; /** * æ„é€ æ–¹æ³• */ public RentalHouseServiceProxy()&#123; rentalHouseService = new RentalHouseService(); &#125; /** * ä»£ç†æ–¹æ³• */ public void rent()&#123; dialNumber(); rentalHouseService.rent(); signContract(); &#125; /** * éœ€è¦æˆ¿ç§Ÿè¯·è”ç³»æˆ‘ï¼Œç›®æ ‡æ–¹æ³•çš„å‰ç½®æ–¹æ³• */ private void dialNumber() &#123; log.info(\"éœ€è¦ç§Ÿæˆ¿è¯·è‡´ç”µï¼š123456\"); &#125; /** * ç­¾åˆåŒï¼Œç›®æ ‡æ–¹æ³•çš„åç½®æ–¹æ³• */ private void signContract() &#123; log.info(\"æˆ¿å­è¿˜æ»¡æ„å°±å¯ä»¥ç­¾åˆåŒäº†ï¼\"); &#125;&#125; åº”ç”¨å±‚ 1234567891011121314151617181920package com.design.pattern.proxy.staticproxy;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-03 */public class Client &#123; @Test public void test()&#123; // ç§Ÿæˆ¿ç›´æ¥æ‰¾ä»£ç† RentalHouseServiceProxy proxy = new RentalHouseServiceProxy(); proxy.rent(); &#125;&#125; jdkåŠ¨æ€ä»£ç† jdkåŠ¨æ€ä»£ç†ç”¨äºç›®æ ‡ç±»æœ‰æ¥å£çš„æƒ…å†µã€‚ä»£ç†ç±»ä¸æ˜¯æ‰‹åŠ¨åˆ›å»ºï¼Œè€Œæ˜¯ç¨‹åºè¿è¡Œæ—¶åŠ¨æ€ç”Ÿæˆã€‚æœ‰æ—¶ç›®æ ‡å¯¹è±¡éœ€è¦åœ¨å®¢æˆ·ç«¯ä¸­åˆ›å»ºï¼Œè¿™æ ·æƒ…å†µä¸‹ä¸èƒ½å¤Ÿä¿æŠ¤å’Œéšè—ç›®æ ‡å¯¹è±¡ï¼Œåªæ˜¯å¢å¼ºäº†ç›®æ ‡æ–¹æ³•åŠŸèƒ½ã€‚ä»£ç†ç±»çš„åç§°ç”±ä¸‰éƒ¨åˆ†æ„æˆï¼š$ + Proxy + æ•°å­—ï¼Œæ•°å­—è¡¨ç¤ºå½“å‰JDKçš„Proxyæ‰€ç”Ÿæˆçš„ä»£ç†ç±»çš„ç´¢å¼•ï¼Œç´¢å¼•ä»0å¼€å§‹è®¡æ•°ã€‚ ç›®æ ‡ç±»æ¥å£ 1234567891011121314package com.design.pattern.proxy.jdkproxy;/** * IRentalHouseService * * @author shunhua * @date 2019-10-03 */public interface IRentalHouseService &#123; /** * ç§Ÿæˆ¿æ–¹æ³• */ void rent();&#125; ç›®æ ‡ç±» 123456789101112131415161718192021222324package com.design.pattern.proxy.jdkproxy;import com.design.pattern.proxy.staticproxy.IRentalHouseService;import lombok.extern.slf4j.Slf4j;/** * RentalHouseServiceImpl ç›®æ ‡ç±» * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceImpl implements IRentalHouseService &#123; /** * å‡ºç§Ÿæˆ¿å­ï¼Œç›®æ ‡æ–¹æ³• * @return */ @Override public void rent()&#123; log.info(\"1800/æœˆï¼Œ2å®¤1å…1å¨1å«ï¼\"); &#125;&#125; InvocationHandlerå®ç° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.design.pattern.proxy.jdkproxy;import lombok.extern.slf4j.Slf4j;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * RentalHouseServiceProxy * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceProxy implements InvocationHandler &#123; private IRentalHouseService target; public RentalHouseServiceProxy(IRentalHouseService target) &#123; this.target = target; &#125; /** * å½“æ‰§è¡Œä»£ç†å¯¹è±¡çš„ä»£ç†æ–¹æ³•æ—¶ï¼Œä»£ç†æ–¹æ³•ä¼šè°ƒç”¨è¯¥invoke() * * @param proxy ä»£ç†å¯¹è±¡ * @param method ç›®æ ‡æ–¹æ³• * @param args ç›®æ ‡æ–¹æ³•çš„å‚æ•°åˆ—è¡¨ * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // è°ƒç”¨ç›®æ ‡æ–¹æ³•å‰ dialNumber(); // æ‰§è¡Œç›®æ ‡æ–¹æ³• Object result = method.invoke(target, args); // è°ƒç”¨ç›®æ ‡æ–¹æ³•å signContract(); return result; &#125; /** * éœ€è¦æˆ¿ç§Ÿè¯·è”ç³»æˆ‘ï¼Œç›®æ ‡æ–¹æ³•çš„å‰ç½®æ–¹æ³• */ private void dialNumber() &#123; log.info(\"éœ€è¦ç§Ÿæˆ¿è¯·è‡´ç”µï¼š123456\"); &#125; /** * ç­¾åˆåŒï¼Œç›®æ ‡æ–¹æ³•çš„åç½®æ–¹æ³• */ private void signContract() &#123; log.info(\"æˆ¿å­è¿˜æ»¡æ„å°±å¯ä»¥ç­¾åˆåŒäº†ï¼\"); &#125;&#125; å®¢æˆ·ç«¯ 123456789101112131415161718192021222324252627282930313233package com.design.pattern.proxy.jdkproxy;import org.junit.Test;import java.lang.reflect.Proxy;/** * Client * * @author shunhua * @date 2019-10-04 */public class Client &#123; @Test public void test()&#123; // åˆ›å»ºç›®æ ‡å¯¹è±¡ IRentalHouseService target = new RentalHouseServiceImpl(); // åˆ›å»ºä»£ç†å¯¹è±¡ï¼ˆæ¥å£å®ç°ç±»çš„ä»£ç†å¯¹è±¡ï¼‰ IRentalHouseService proxy = (IRentalHouseService) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new RentalHouseServiceProxy(target) ); /** * è°ƒç”¨ä»£ç†å¯¹è±¡çš„ä»£ç†æ–¹æ³•,æ³¨æ„å½“è°ƒç”¨ä»£ç†å¯¹è±¡çš„ä»£ç†æ–¹æ³•æ—¶ï¼ŒInvocationHandlerçš„invokeæ–¹æ³•ä¼šè¢«è‡ªåŠ¨è°ƒç”¨ */ proxy.rent(); &#125;&#125; CGLIBåŠ¨æ€ä»£ç† CGLIBçš„åº•å±‚æ˜¯é€šè¿‡ä½¿ç”¨å­—èŠ‚ç å¤„ç†æ¡†æ¶ASMæ¥è½¬æ¢å­—èŠ‚ç å¹¶ç”Ÿæˆæ–°çš„ç±»ï¼Œä»£ç†çš„ç›®æ ‡ç±»å¯ä»¥æ²¡æœ‰å®ç°æ¥å£ï¼Œä¹Ÿå¯ä»¥æœ‰å®ç°çš„æ¥å£ã€‚CGLIBä½¿ç”¨å­ç±»æ‰©å±•çˆ¶ç±»çš„æ–¹å¼æ¥ç”Ÿæˆä»£ç†å¯¹è±¡ï¼Œå³CGLIBä¼šåŠ¨æ€ç”Ÿæˆç›®æ ‡ç±»çš„å­ç±»ä½œä¸ºä»£ç†ç±»ï¼Œå¹¶åˆ›å»ºå…¶å¯¹è±¡å³ä»£ç†å¯¹è±¡ã€‚ ç›®æ ‡ç±» 123456789101112131415161718192021222324package com.design.pattern.proxy.cglibproxy;import com.design.pattern.proxy.staticproxy.IRentalHouseService;import lombok.extern.slf4j.Slf4j;/** * RentalHouseServiceImpl ç›®æ ‡ç±» * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceImpl implements IRentalHouseService &#123; /** * å‡ºç§Ÿæˆ¿å­ï¼Œç›®æ ‡æ–¹æ³• * @return */ @Override public void rent()&#123; log.info(\"1800/æœˆï¼Œ2å®¤1å…1å¨1å«ï¼\"); &#125;&#125; MethodInterceptorçš„å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.design.pattern.proxy.cglibproxy;import lombok.extern.slf4j.Slf4j;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * RentalHouseServiceProxy * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class RentalHouseServiceProxy implements MethodInterceptor &#123; /** * * @param o ä»£ç†å¯¹è±¡ * @param method ç›®æ ‡æ–¹æ³• * @param objects ç›®æ ‡æ–¹æ³•å‚æ•°åˆ—è¡¨ * @param methodProxy ç›®æ ‡æ–¹æ³•çš„ä»£ç†å¯¹è±¡ * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return null; &#125; /** * éœ€è¦æˆ¿ç§Ÿè¯·è”ç³»æˆ‘ï¼Œç›®æ ‡æ–¹æ³•çš„å‰ç½®æ–¹æ³• */ private void dialNumber() &#123; log.info(\"éœ€è¦ç§Ÿæˆ¿è¯·è‡´ç”µï¼š123456\"); &#125; /** * ç­¾åˆåŒï¼Œç›®æ ‡æ–¹æ³•çš„åç½®æ–¹æ³• */ private void signContract() &#123; log.info(\"æˆ¿å­è¿˜æ»¡æ„å°±å¯ä»¥ç­¾åˆåŒäº†ï¼\"); &#125;&#125; ç”Ÿæˆä»£ç†ç±»çš„é€»è¾‘ç±» 1234567891011121314151617181920212223242526272829303132333435package com.design.pattern.proxy.cglibproxy;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;/** * CglibProxy æ‰‹åŠ¨åˆ›å»º * * @author shunhua * @date 2019-10-04 */public class CglibProxy &#123; /** * åˆ›å»ºCglibçš„ä»£ç†å¯¹è±¡ * * @param targetClass ç›®æ ‡ç±» * @param callBack å§”æ‰˜ç±»å¯¹è±¡ * @return */ public static IRentalHouseService createCglibProxy(Class targetClass, MethodInterceptor callBack)&#123; // åˆ›å»ºå¢å¼ºå…¶ Enhancer enhancer = new Enhancer(); // æŒ‡å®šç›®æ ‡ç±» enhancer.setSuperclass(targetClass); // è®¾ç½®å›è°ƒæ¥å£ enhancer.setCallback(callBack); // åˆ›å»ºå¹¶è¿”å›ä»£ç†å¯¹è±¡ï¼Œå³ç›®æ ‡ç±»çš„å­ç±»å¯¹è±¡ return (IRentalHouseService) enhancer.create(); &#125;&#125; å®¢æˆ·ç«¯ 12345678910111213141516171819202122232425262728293031package com.design.pattern.proxy.cglibproxy;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-04 */public class Client &#123; @Test public void test() &#123; // åˆ›å»ºç›®æ ‡å¯¹è±¡ IRentalHouseService target = new RentalHouseServiceImpl(); // åˆ›å»ºå§”æ‰˜å¯¹è±¡ RentalHouseServiceProxy rentalHouseServiceProxy = new RentalHouseServiceProxy(); // åˆ›å»ºä»£ç†å¯¹è±¡ï¼ˆæ¥å£å®ç°ç±»çš„ä»£ç†å¯¹è±¡ï¼‰ IRentalHouseService cglibProxy = CglibProxy.createCglibProxy(target.getClass(), rentalHouseServiceProxy); /** * è°ƒç”¨ä»£ç†å¯¹è±¡çš„ä»£ç†æ–¹æ³•,æ³¨æ„å½“è°ƒç”¨ä»£ç†å¯¹è±¡çš„ä»£ç†æ–¹æ³•æ—¶ï¼ŒInvocationHandlerçš„invokeæ–¹æ³•ä¼šè¢«è‡ªåŠ¨è°ƒç”¨ */ cglibProxy.rent(); &#125;&#125; ä»£ç†æ¨¡å¼åœ¨æºç ä¸­çš„ä½¿ç”¨jdkä¸­çš„åº”ç”¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490package java.lang.reflect;import java.lang.ref.WeakReference;import java.security.AccessController;import java.security.PrivilegedAction;import java.util.Arrays;import java.util.IdentityHashMap;import java.util.Map;import java.util.Objects;import java.util.concurrent.atomic.AtomicLong;import java.util.function.BiFunction;import sun.misc.ProxyGenerator;import sun.misc.VM;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;import sun.reflect.misc.ReflectUtil;import sun.security.util.SecurityConstants;public class Proxy implements java.io.Serializable &#123; private static final long serialVersionUID = -2222568056686623797L; /** parameter types of a proxy class constructor */ private static final Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;; /** * a cache of proxy classes */ private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory()); /** * the invocation handler for this proxy instance. * @serial */ protected InvocationHandler h; /** * Prohibits instantiation. */ private Proxy() &#123; &#125; /** * Constructs a new &#123;@code Proxy&#125; instance from a subclass * (typically, a dynamic proxy class) with the specified value * for its invocation handler. * * @param h the invocation handler for this proxy instance * * @throws NullPointerException if the given invocation handler, &#123;@code h&#125;, * is &#123;@code null&#125;. */ protected Proxy(InvocationHandler h) &#123; Objects.requireNonNull(h); this.h = h; &#125; @CallerSensitive public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) throws IllegalArgumentException &#123; final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; return getProxyClass0(loader, intfs); &#125; /* * Check permissions required to create a Proxy class. * * To define a proxy class, it performs the access checks as in * Class.forName (VM will invoke ClassLoader.checkPackageAccess): * 1. \"getClassLoader\" permission check if loader == null * 2. checkPackageAccess on the interfaces it implements * * To get a constructor and new instance of a proxy class, it performs * the package access check on the interfaces it implements * as in Class.getConstructor. * * If an interface is non-public, the proxy class must be defined by * the defining loader of the interface. If the caller's class loader * is not the same as the defining loader of the interface, the VM * will throw IllegalAccessError when the generated proxy class is * being defined via the defineClass0 method. */ private static void checkProxyAccess(Class&lt;?&gt; caller, ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; ClassLoader ccl = caller.getClassLoader(); if (VM.isSystemDomainLoader(loader) &amp;&amp; !VM.isSystemDomainLoader(ccl)) &#123; sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION); &#125; ReflectUtil.checkProxyPackageAccess(ccl, interfaces); &#125; &#125; /** * ç”Ÿæˆä»£ç†ç±»çš„æ ¸å¿ƒæ–¹æ³• */ private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(\"interface limit exceeded\"); &#125; // å¦‚æœç¼“å­˜ä¸­æœ‰å¯¹åº”çš„ä»£ç†ç±»å°±ç›´æ¥è·å–ï¼Œæ²¡æœ‰å°±åˆ›å»ºç„¶åæ”¾å…¥ç¼“å­˜ return proxyClassCache.get(loader, interfaces); &#125; /* * a key used for proxy class with 0 implemented interfaces */ private static final Object key0 = new Object(); /* * Key1 and Key2 are optimized for the common use of dynamic proxies * that implement 1 or 2 interfaces. */ /* * a key used for proxy class with 1 implemented interface */ private static final class Key1 extends WeakReference&lt;Class&lt;?&gt;&gt; &#123; private final int hash; Key1(Class&lt;?&gt; intf) &#123; super(intf); this.hash = intf.hashCode(); &#125; @Override public int hashCode() &#123; return hash; &#125; @Override public boolean equals(Object obj) &#123; Class&lt;?&gt; intf; return this == obj || obj != null &amp;&amp; obj.getClass() == Key1.class &amp;&amp; (intf = get()) != null &amp;&amp; intf == ((Key1) obj).get(); &#125; &#125; /* * a key used for proxy class with 2 implemented interfaces */ private static final class Key2 extends WeakReference&lt;Class&lt;?&gt;&gt; &#123; private final int hash; private final WeakReference&lt;Class&lt;?&gt;&gt; ref2; Key2(Class&lt;?&gt; intf1, Class&lt;?&gt; intf2) &#123; super(intf1); hash = 31 * intf1.hashCode() + intf2.hashCode(); ref2 = new WeakReference&lt;Class&lt;?&gt;&gt;(intf2); &#125; @Override public int hashCode() &#123; return hash; &#125; @Override public boolean equals(Object obj) &#123; Class&lt;?&gt; intf1, intf2; return this == obj || obj != null &amp;&amp; obj.getClass() == Key2.class &amp;&amp; (intf1 = get()) != null &amp;&amp; intf1 == ((Key2) obj).get() &amp;&amp; (intf2 = ref2.get()) != null &amp;&amp; intf2 == ((Key2) obj).ref2.get(); &#125; &#125; /* * a key used for proxy class with any number of implemented interfaces * (used here for 3 or more only) */ private static final class KeyX &#123; private final int hash; private final WeakReference&lt;Class&lt;?&gt;&gt;[] refs; @SuppressWarnings(\"unchecked\") KeyX(Class&lt;?&gt;[] interfaces) &#123; hash = Arrays.hashCode(interfaces); refs = (WeakReference&lt;Class&lt;?&gt;&gt;[])new WeakReference&lt;?&gt;[interfaces.length]; for (int i = 0; i &lt; interfaces.length; i++) &#123; refs[i] = new WeakReference&lt;&gt;(interfaces[i]); &#125; &#125; @Override public int hashCode() &#123; return hash; &#125; @Override public boolean equals(Object obj) &#123; return this == obj || obj != null &amp;&amp; obj.getClass() == KeyX.class &amp;&amp; equals(refs, ((KeyX) obj).refs); &#125; private static boolean equals(WeakReference&lt;Class&lt;?&gt;&gt;[] refs1, WeakReference&lt;Class&lt;?&gt;&gt;[] refs2) &#123; if (refs1.length != refs2.length) &#123; return false; &#125; for (int i = 0; i &lt; refs1.length; i++) &#123; Class&lt;?&gt; intf = refs1[i].get(); if (intf == null || intf != refs2[i].get()) &#123; return false; &#125; &#125; return true; &#125; &#125; /** * A function that maps an array of interfaces to an optimal key where * Class objects representing interfaces are weakly referenced. */ private static final class KeyFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Object&gt; &#123; @Override public Object apply(ClassLoader classLoader, Class&lt;?&gt;[] interfaces) &#123; switch (interfaces.length) &#123; case 1: return new Key1(interfaces[0]); // the most frequent case 2: return new Key2(interfaces[0], interfaces[1]); case 0: return key0; default: return new KeyX(interfaces); &#125; &#125; &#125; /** * A factory function that generates, defines and returns the proxy class given * the ClassLoader and array of interfaces. */ private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; // prefix for all proxy class names private static final String proxyClassNamePrefix = \"$Proxy\"; // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + \" is not visible from class loader\"); &#125; /* * Verify that the Class object actually represents an * interface. */ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + \" is not an interface\"); &#125; /* * Verify that this interface is not a duplicate. */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( \"repeated interface: \" + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( \"non-public interfaces from different packages\"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\"; &#125; /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125; &#125; // è¯¥æ–¹æ³•æœ€ç»ˆè¿”å›ä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼ˆç›®æ ‡å¯¹è±¡ï¼‰ @CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * ç”Ÿæˆä»£ç†ç±»çš„æ ¸å¿ƒæ–¹æ³• */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; private static void checkNewProxyPermission(Class&lt;?&gt; caller, Class&lt;?&gt; proxyClass) &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; if (ReflectUtil.isNonPublicProxyClass(proxyClass)) &#123; ClassLoader ccl = caller.getClassLoader(); ClassLoader pcl = proxyClass.getClassLoader(); // do permission check if the caller is in a different runtime package // of the proxy class int n = proxyClass.getName().lastIndexOf('.'); String pkg = (n == -1) ? \"\" : proxyClass.getName().substring(0, n); n = caller.getName().lastIndexOf('.'); String callerPkg = (n == -1) ? \"\" : caller.getName().substring(0, n); if (pcl != ccl || !pkg.equals(callerPkg)) &#123; sm.checkPermission(new ReflectPermission(\"newProxyInPackage.\" + pkg)); &#125; &#125; &#125; &#125; /** * Returns true if and only if the specified class was dynamically * generated to be a proxy class using the &#123;@code getProxyClass&#125; * method or the &#123;@code newProxyInstance&#125; method. * * &lt;p&gt;The reliability of this method is important for the ability * to use it to make security decisions, so its implementation should * not just test if the class in question extends &#123;@code Proxy&#125;. * * @param cl the class to test * @return &#123;@code true&#125; if the class is a proxy class and * &#123;@code false&#125; otherwise * @throws NullPointerException if &#123;@code cl&#125; is &#123;@code null&#125; */ public static boolean isProxyClass(Class&lt;?&gt; cl) &#123; return Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl); &#125; /** * Returns the invocation handler for the specified proxy instance. * * @param proxy the proxy instance to return the invocation handler for * @return the invocation handler for the proxy instance * @throws IllegalArgumentException if the argument is not a * proxy instance * @throws SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present * and the caller's class loader is not the same as or an * ancestor of the class loader for the invocation handler * and invocation of &#123;@link SecurityManager#checkPackageAccess * s.checkPackageAccess()&#125; denies access to the invocation * handler's class. */ @CallerSensitive public static InvocationHandler getInvocationHandler(Object proxy) throws IllegalArgumentException &#123; /* * Verify that the object is actually a proxy instance. */ if (!isProxyClass(proxy.getClass())) &#123; throw new IllegalArgumentException(\"not a proxy instance\"); &#125; final Proxy p = (Proxy) proxy; final InvocationHandler ih = p.h; if (System.getSecurityManager() != null) &#123; Class&lt;?&gt; ihClass = ih.getClass(); Class&lt;?&gt; caller = Reflection.getCallerClass(); if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), ihClass.getClassLoader())) &#123; ReflectUtil.checkPackageAccess(ihClass); &#125; &#125; return ih; &#125; private static native Class&lt;?&gt; defineClass0(ClassLoader loader, String name, byte[] b, int off, int len);&#125; Springä¸­çš„åº”ç”¨12345678910111213141516public class ProxyFactoryBean extends ProxyCreatorSupport implements FactoryBean&lt;Object&gt;, BeanClassLoaderAware, BeanFactoryAware &#123; //å¦‚æœä¸å£°æ˜ï¼Œé»˜è®¤å•ä¾‹å¯¹è±¡ï¼Œæ³¨è§£å£°æ˜å¤šä¾‹ï¼Œåˆ™å£°æ˜å¤šä¾‹å¯¹è±¡ public Object getObject() throws BeansException &#123; this.initializeAdvisorChain(); if (this.isSingleton()) &#123; return this.getSingletonInstance(); &#125; else &#123; if (this.targetName == null) &#123; this.logger.warn(\"Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the 'targetName' property.\"); &#125; return this.newPrototypeInstance(); &#125; &#125;&#125; 12JdkDynamicAopProxy:å¯¹jdkåŠ¨æ€ä»£ç†çš„å°è£…CglibAopProxy:å¯¹ç±»è¿›è¡Œä»£ç†å¢å¼º MyBatisä¸­çš„åº”ç”¨1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package org.apache.ibatis.binding;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import org.apache.ibatis.session.SqlSession;/** * @author Lasse Voss */public class MapperProxyFactory&lt;T&gt; &#123; private final Class&lt;T&gt; mapperInterface; private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;&gt;(); public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; public Map&lt;Method, MapperMethod&gt; getMethodCache() &#123; return methodCache; &#125; @SuppressWarnings(\"unchecked\") protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; // ç”Ÿæˆä¸€ä¸ªä»£ç†å¯¹è±¡å¹¶è¿”å› return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;,); &#125; public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); &#125;&#125;/** * MapperProxyä»£ç†ç±»çš„ä¿¡æ¯ */public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable &#123; private static final long serialVersionUID = -6424540398559729838L; private final SqlSession sqlSession; private final Class&lt;T&gt; mapperInterface; private final Map&lt;Method, MapperMethod&gt; methodCache; public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) &#123; this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; this.methodCache = methodCache; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, args); &#125; else if (isDefaultMethod(method)) &#123; return invokeDefaultMethod(proxy, method, args); &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; final MapperMethod mapperMethod = cachedMapperMethod(method); return mapperMethod.execute(sqlSession, args); &#125; private MapperMethod cachedMapperMethod(Method method) &#123; return methodCache.computeIfAbsent(method, k -&gt; new MapperMethod(mapperInterface, method, sqlSession.getConfiguration())); &#125; // ... ç­‰ç­‰ ï½","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"è§£é‡Šå™¨æ¨¡å¼","slug":"design_pattern/behaviour_type/è§£é‡Šå™¨æ¨¡å¼","date":"2019-10-01T16:00:00.000Z","updated":"2020-08-09T09:29:48.704Z","comments":true,"path":"posts/30cf0cd2/","link":"","permalink":"https://gentryhuang.com/posts/30cf0cd2/","excerpt":"","text":"å®šä¹‰ç»™å®šä¸€ä¸ªè¯­è¨€ï¼Œå®šä¹‰å®ƒçš„æ–‡æ³•ï¼ˆè¯­æ³•ï¼‰çš„ä¸€ç§è¡¨ç¤ºï¼Œå¹¶å®šä¹‰ä¸€ä¸ªè§£é‡Šå™¨ï¼Œè¿™ä¸ªè§£é‡Šå™¨ä½¿ç”¨è¯¥è¡¨ç¤ºæ¥è§£é‡Šè¯­è¨€ä¸­çš„å¥å­ã€‚å³ ä¸ºäº†è§£é‡Šä¸€ç§è¯­è¨€ï¼ˆè¯­è¨€çš„è¯­æ³•ï¼‰ï¼Œè€Œä¸ºè¯­è¨€åˆ›å»ºçš„è§£é‡Šå™¨ ç±»å‹è¡Œä¸ºå‹ é€‚ç”¨åœºæ™¯1åœ¨å¤„ç†æ—¥å¿—çš„æ—¶å€™ï¼Œç”±äºå¤šä¸ªæœåŠ¡äº§ç”Ÿçš„æ—¥å¿—æ ¼å¼ä¸ä¸€å®šç»Ÿä¸€ï¼Œä½†æ˜¯æ•°æ®é‡Œé¢çš„è¦ç´ æ˜¯ç›¸åŒçš„ï¼Œè¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ç¨‹åºæ¥è§£å†³è¯¥é—®é¢˜ï¼Œè€Œè¿™ä¸ªç¨‹åºæˆ‘ä»¬å°±å¯ä»¥ç†è§£ä¸ºè§£é‡Šå™¨ï¼Œåªä¸è¿‡å¯ä»¥è§£é‡Šä¸åŒæ—¥å¿—æ ¼å¼ã€‚åœ¨å®é™…é¡¹ç›®ä¸­è§£é‡Šå™¨æ¨¡å¼ä½¿ç”¨çš„æ¯”è¾ƒå°‘ï¼Œå¤šä½¿ç”¨å¼€æºåŒ…ã€‚ ä¼˜ç‚¹1è¯­æ³•ç”±å¾ˆå¤šç±»è¡¨ç¤ºï¼Œå®¹æ˜“æ”¹å˜åŠæ‰©å±•æ­¤â€œè¯­è¨€â€ï¼ˆæ¶‰åŠçš„ä»£ç è¿˜ä¸è¶³ä»¥è¯´æ˜æ˜¯ç§è¯­è¨€ï¼‰ ç¼ºç‚¹1å½“è¯­æ³•è§„åˆ™æ•°ç›®å¤ªå¤šæ—¶ï¼Œå¢åŠ äº†ç³»ç»Ÿå¤æ‚åº¦ ç®€å•éœ€æ±‚è‡ªå®šä¹‰ä¸€å¥—å¯ä»¥åŠ æ³•ã€ä¹˜æ³•çš„è¯­æ³•ï¼Œä½¿ç”¨æ ˆæ¥è¡¨ç¤ºï¼Œè¿™å’Œæ—¥å¸¸çš„åŠ æ³•å’Œä¹˜æ³•æ˜¯ä¸ä¸€æ ·çš„ã€‚ç„¶åå®šä¹‰åŠ æ³•å’Œä¹˜æ³•è§£é‡Šå™¨ï¼Œè§£é‡Šå¯¹åº”çš„è¡¨è¾¾å¼ç„¶åæ‹¿åˆ°æœ€ç»ˆçš„ç»“æœã€‚ è§£é‡Šå™¨æ¨¡å¼æ¼”ç»ƒ è§£é‡Šå™¨æ¥å£ 123456789101112131415package com.design.pattern.interpreter;/** * Interpreter è§£é‡Šæ¥å£ * * @author shunhua * @date 2019-10-02 */public interface Interpreter &#123; /** * è§£é‡Šæ–¹æ³• * @return */ int interpret();&#125; åŠ æ³•è§£é‡Šå™¨ 123456789101112131415161718192021222324252627282930313233343536373839package com.design.pattern.interpreter;/** * AddInterpreter åŠ æ³•è§£é‡Šå™¨ * * @author shunhua * @date 2019-10-02 */public class AddInterpreter implements Interpreter &#123; /** * å®ƒä»¬çš„æ–¹æ³•è¿”å›å€¼ä½œä¸ºåŠ æ•°å’Œè¢«åŠ æ•° */ private Interpreter firstExpression,secondeExpression; /** * åŠ æ³•éœ€è¦ åŠ æ•°å’Œè¢«åŠ æ•° * @param firstExpression * @param secondeExpression */ public AddInterpreter(Interpreter firstExpression,Interpreter secondeExpression)&#123; this.firstExpression = firstExpression; this.secondeExpression = secondeExpression; &#125; /** * è¿”å›ä¸¤ä¸ªè¡¨è¾¾å¼ç»“æœçš„å’Œ * @return */ @Override public int interpret() &#123; return this.firstExpression.interpret() + this.secondeExpression.interpret(); &#125; @Override public String toString() &#123; return \"+\"; &#125;&#125; ä¹˜æ³•è§£é‡Šå™¨ 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.interpreter;/** * MultiInterpreter ä¹˜æ³•è§£é‡Šå™¨ * * @author shunhua * @date 2019-10-02 */public class MultiInterpreter implements Interpreter &#123; /** * å®ƒä»¬çš„è¡¨è¾¾å¼ç»“æœä½œä¸ºä¹˜æ•°å’Œè¢«ä¹˜é™¤æ•° */ private Interpreter firstExpression,secondExpression; /** * ä¹˜æ³•éœ€è¦ ä¹˜æ•°å’Œè¢«ä¹˜æ•° * @param firstExpression * @param secondExpression */ public MultiInterpreter(Interpreter firstExpression,Interpreter secondExpression)&#123; this.firstExpression = firstExpression; this.secondExpression = secondExpression; &#125; /** * ä¹˜æ³•è§£é‡Šå™¨çš„è§£é‡Šæ–¹æ³• * @return */ @Override public int interpret() &#123; return this.firstExpression.interpret() * this.secondExpression.interpret(); &#125; @Override public String toString() &#123; return \"*\"; &#125;&#125; è¡¨è¾¾å¼å¤„ç†è§£é‡Šå™¨ 1234567891011121314151617181920212223242526272829303132333435363738394041// æ³¨æ„è¿™ä¸ªè§£é‡Šå™¨å°±æ˜¯ç®€å•è½¬æ¢æ•°æ®çš„package com.design.pattern.interpreter;/** * NumberInterpreter è¡¨è¾¾å¼å¤„ç†è§£é‡Šå™¨ * * @author shunhua * @date 2019-10-02 */public class NumberInterpreter implements Interpreter &#123; /** * è¡¨è¾¾å¼è¦è¿”å›çš„å€¼ */ private int number; /** * æ•°å€¼æ„é€ å™¨ * @param number */ public NumberInterpreter(int number)&#123; this.number = number; &#125; /** * å­—ç¬¦ä¸²è½¬æ¢æ„é€ å™¨ * @param number */ public NumberInterpreter(String number)&#123; this.number = Integer.parseInt(number); &#125; /** * è§£é‡Šæ–¹æ³• * @return */ @Override public int interpret() &#123; return this.number; &#125;&#125; å°è£…è§£é‡Šå™¨çš„å¤„ç†ç±»â€“æš´éœ²ç»™ç”¨æˆ·çš„è§£é‡Šå™¨ï¼ˆå®ƒå†…éƒ¨æ˜¯å¯¹å‡ ä¸ªè§£é‡Šå™¨çš„å°è£…ï¼‰ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.design.pattern.interpreter;import lombok.extern.slf4j.Slf4j;import java.util.Arrays;import java.util.Stack;/** * ExpressionParse * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class ExpressionParse &#123; /** * å®šä¹‰ä¸€ä¸ªæ ˆï¼Œè¿™é‡Œæ˜¯è§£é‡Šå™¨ç±»å‹æ ˆ */ private Stack&lt;Interpreter&gt; stack = new Stack&lt;&gt;(); public int parse(String str)&#123; String[] strItemArray = str.split(\" \"); Arrays.stream(strItemArray).forEach(symbol -&gt;&#123; // ä¸æ˜¯è¿ç®—ç¬¦ï¼Œéœ€è¦å…¥æ ˆ if(!OperatorUtil.isOperator(symbol))&#123; Interpreter numberExpression = new NumberInterpreter(symbol); stack.push(numberExpression); log.info(String.format(\"å…¥æ ˆï¼š%d\",numberExpression.interpret())); &#125;else &#123; // æ˜¯è¿ç®—ç¬¦ï¼Œå¯ä»¥è¿›è¡Œè®¡ç®— Interpreter firstExpression = stack.pop(); Interpreter secondExpression = stack.pop(); log.info(String.format(\"å‡ºæ ˆï¼š %d å’Œ %d\",firstExpression.interpret(),secondExpression.interpret())); Interpreter operator = OperatorUtil.getExpressionObject(firstExpression,secondExpression,symbol); log.info(String.format(\"è§£é‡Šå™¨ç±»å‹ï¼š%s\",operator.toString())); int result = operator.interpret(); NumberInterpreter resultExpression = new NumberInterpreter(result); stack.push(resultExpression); log.info(String.format(\"é˜¶æ®µç»“æœå…¥æ ˆï¼š %d\",resultExpression.interpret())); &#125; &#125;); int result = stack.pop().interpret(); return result; &#125;&#125; å·¥å…·ç±» 1234567891011121314151617181920212223242526272829303132333435package com.design.pattern.interpreter;/** * OperatorUtil * * @author shunhua * @date 2019-10-02 */public class OperatorUtil &#123; /** * æ˜¯å¦å¯æ“ä½œ * @param symbol * @return */ public static boolean isOperator(String symbol)&#123; return \"+\".equals(symbol) || \"*\".equals(symbol); &#125; /** * ä½¿ç”¨è§£é‡Šå™¨è¿›è¡Œè§£é‡Šï¼Œè¡¨è¾¾å¼çš„ç»“æœ * @param firstExpression * @param secondExpression * @param symbol * @return */ public static Interpreter getExpressionObject(Interpreter firstExpression,Interpreter secondExpression,String symbol)&#123; if(\"+\".equals(symbol))&#123; return new AddInterpreter(firstExpression,secondExpression); &#125; else if (\"*\".equals(symbol))&#123; return new MultiInterpreter(firstExpression,secondExpression); &#125; return null; &#125;&#125; åº”ç”¨ 12345678910111213141516171819202122232425package com.design.pattern.interpreter;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class Client &#123; @Test public void test()&#123; // è¾“å…¥è¡¨è¾¾å¼ String inputStr = \"18 70 12 + *\"; // å¯¹è¡¨è¾¾å¼è¿›è¡Œè§£é‡Š ExpressionParse expressionParse = new ExpressionParse(); int result = expressionParse.parse(inputStr); log.info(\"æœ€ç»ˆè§£é‡Šç»“æœï¼š\" + result); &#125;&#125; è§£é‡Šå™¨æ¨¡å¼åœ¨æºç ä¸­çš„ä½¿ç”¨java.util.regex.Pattern 1æ­£åˆ™è¡¨è¾¾å¼å°±æ˜¯ä¸€ç§è¯­æ³•ï¼Œé€šè¿‡jdkä¸­çš„æ­£åˆ™è§£é‡Šå™¨æŠŠå®ƒè§£é‡Šå‡ºæ¥ 123456789101112131415161718192021222324252627282930package com.design.pattern.interpreter;import lombok.extern.slf4j.Slf4j;import org.junit.Test;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * PatternTest * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class PatternTest &#123; @Test public void test()&#123; String str = \"china\"; String patternStr = \"\\\\s+\" + str + \"\\\\s+\"; // æ­£åˆ™è§£é‡Šå™¨ï¼Œè§£é‡Šæ­£åˆ™è¡¨è¾¾å¼ Pattern pattern = Pattern.compile(patternStr); String content = \" china becames more and more beautiful! \"; Matcher matcher = pattern.matcher(content); if (matcher.find()) &#123; String content_new = matcher.replaceAll(\"China \"); log.info(String.format(\"old: %s, new: %s\",content,content_new)); &#125; &#125;&#125; Springçš„ELè§£é‡Šå™¨ 1Elè¡¨è¾¾å¼æ˜¯ä¸€ç§è¯­æ³•ï¼Œé€šè¿‡Springçš„è§£é‡Šå™¨å»è§£é‡Š 12345678910111213141516171819202122232425262728293031package com.design.pattern.interpreter.resource;import lombok.extern.slf4j.Slf4j;import org.junit.Test;import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;/** * SpelParserTest * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class SpelParserTest &#123; /** * ä½¿ç”¨Springçš„è¯­è¨€è§£é‡Šå™¨(ExpressionParser) è§£é‡ŠSpringçš„ELï¼ˆè§£é‡Šè¯­è¨€ï¼‰è¡¨è¾¾å¼ */ @Test public void test() &#123; // åˆ›å»ºSpringçš„è¯­è¨€è§£é‡Šå™¨ ExpressionParser parser = new SpelExpressionParser(); // ä½¿ç”¨è§£é‡Šè§£æSpringçš„Elè¡¨è¾¾å¼ Expression expression = parser.parseExpression(\"2 * 100 * 10 + 19\"); // å–å‡ºç»“æœ int result = (Integer) expression.getValue(); log.info(\"è§£é‡Šåçš„ç»“æœï¼š\" + result); &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"è§‚å¯Ÿè€…æ¨¡å¼","slug":"design_pattern/behaviour_type/è§‚å¯Ÿè€…æ¨¡å¼","date":"2019-10-01T16:00:00.000Z","updated":"2020-08-09T09:29:21.271Z","comments":true,"path":"posts/9a246216/","link":"","permalink":"https://gentryhuang.com/posts/9a246216/","excerpt":"","text":"å®šä¹‰å®šä¹‰äº†å¯¹è±¡ä¹‹é—´çš„ä¸€å¯¹å¤šä¾èµ–ï¼Œè®©å¤šä¸ªè§‚å¯Ÿè€…å¯¹è±¡åŒæ—¶ç›‘å¬æŸä¸€ä¸ªä¸»é¢˜å¯¹è±¡ï¼Œå½“ä¸»é¢˜å¯¹è±¡å‘ç”Ÿå˜åŒ–æ—¶ï¼Œå®ƒçš„æ‰€æœ‰ä¾èµ–è€…ï¼ˆè§‚å¯Ÿè€…ï¼‰éƒ½ä¼šæ”¶åˆ°é€šçŸ¥å¹¶æ›´æ–°ã€‚ ç±»å‹è¡Œä¸ºå‹ é€‚ç”¨åœºæ™¯1å…³è”è¡Œä¸ºåœºæ™¯ï¼Œå»ºç«‹ä¸€å¥—è§¦å‘æœºåˆ¶ã€‚å¦‚ï¼šæ³¨æŸä¸ªäº§å“çš„ä»·æ ¼ï¼Œç„¶åè¿›è¡Œé€šçŸ¥ï¼Œå…¶ä¸­ä»·æ ¼çš„å˜åŠ¨å¯èƒ½ä¼šå½±å“ä¸€æ¡é“¾ï¼Œå°±åƒæ˜¯ä¸€ä¸ªè§¦å‘é“¾æ¡ã€‚è¿™æ ·å°±å¯ä»¥ä½¿ç”¨è§‚å¯Ÿè€…æ¨¡å¼åˆ›å»ºä¸€ä¸ªç§é“¾å¼å‘æœºåˆ¶ã€‚ ä¼˜ç‚¹12341. è§‚å¯Ÿè€…å’Œè¢«è§‚å¯Ÿè€…ä¹‹é—´å»ºç«‹ä¸€ä¸ªæŠ½è±¡çš„è€¦åˆ - å› ä¸ºæ˜¯æŠ½è±¡çš„è€¦åˆå…³ç³»ï¼Œä¸ç®¡æ˜¯å¢åŠ è§‚å¯Ÿè€…è¿˜æ˜¯è¢«è§‚å¯Ÿè€…éƒ½å¾ˆå®¹æ˜“æ‰©å±•2. æ”¯æŒå¹¿æ’­é€šä¿¡ - ç±»ä¼¼æ¶ˆæ¯å¹¿æ’­ï¼Œéœ€è¦ç›‘å¬ä¸»é¢˜çš„åªéœ€è¦æ³¨å†Œå°±å¯ä»¥äº† ç¼ºç‚¹123451. è§‚å¯Ÿè€…ä¹‹é—´æœ‰è¿‡å¤šçš„ç»†èŠ‚ä¾èµ–ã€æé«˜äº†æ—¶é—´æ¶ˆè€—åŠç¨‹åºå¤æ‚åº¦ - è¿‡å¤šçš„ä¾èµ–ï¼šè§¦å‘æœºåˆ¶å’Œè§¦å‘é“¾æ¡ - æé«˜äº†æ—¶é—´æ¶ˆè€—åŠç¨‹åºå¤æ‚åº¦ï¼šå¦‚æœä¸€ä¸ªè¢«è§‚å¯Ÿå¯¹è±¡æœ‰å¤šä¸ªç›´æ¥æˆ–é—´æ¥è§‚å¯Ÿè€…ï¼Œä¸€æ—¦è¢«è§‚å¯Ÿè€…å˜åŒ–ï¼Œç„¶åå‘å‡ºé€šçŸ¥ï¼Œå°†æ‰€æœ‰è§‚å¯Ÿè€…éƒ½é€šçŸ¥åˆ°ä¼šèŠ±è´¹ä¸€äº›æ—¶é—´2. ä½¿ç”¨è¦å¾—å½“ï¼Œé¿å…å¾ªç¯è°ƒç”¨ - å¦‚æœåœ¨è§‚å¯Ÿè€…å’Œè¢«è§‚å¯Ÿè€…ä¹‹é—´æœ‰å¾ªç¯ä¾èµ–çš„è¯ï¼Œè¢«è§‚å¯Ÿè€…ï¼ˆä¸»é¢˜å¯¹è±¡ï¼‰ä¼šè§¦å‘å®ƒä»¬ä¹‹é—´è¿›è¡Œå¾ªç¯è°ƒç”¨ï¼Œè¿™æ ·ä¼šå¯¼è‡´ç³»ç»Ÿå´©æºƒ ç®€å•éœ€æ±‚å­¦ç”Ÿåœ¨å­¦ä¹ è¯¾ç¨‹çš„æ—¶å€™å¯èƒ½ä¼šæå‡ºé—®é¢˜ï¼Œè€Œè€å¸ˆåˆ™æ˜¯å…³æ³¨è‡ªå·±çš„è¯¾ç¨‹ï¼Œæœ‰å­¦ç”Ÿæå‡ºè‡ªå·±è¯¾ç¨‹çš„é—®é¢˜å°±ç»™å‡ºè§£ç­” è§‚å¯Ÿè€…æ¨¡å¼æ¼”ç»ƒ è¢«è§‚å¯Ÿè€…éœ€è¦ç»§æ‰¿çš„ç±» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package java.util;/** * @since JDK1.0 */public class Observable &#123; private boolean changed = false; private Vector&lt;Observer&gt; obs; /** Construct an Observable with zero Observers. */ public Observable() &#123; obs = new Vector&lt;&gt;(); &#125; /** * * åœ¨è§‚å¯Ÿè€…åˆ—è¡¨ä¸­å¢åŠ ä¸€ä¸ªè§‚å¯Ÿè€… * * @param o è¦æ·»åŠ çš„è§‚å¯Ÿè€…å¯¹è±¡ * @throws NullPointerException å¦‚æœå‚æ•°ä¼ å…¥nullä¼šæŠ›å‡ºå¼‚å¸¸ */ public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; /** * ä»è§‚å¯Ÿè€…åˆ—è¡¨ä¸­åˆ é™¤æŒ‡å®šçš„è§‚å¯Ÿè€… * * @param o è¦è¢«ç§»å‡ºçš„è§‚å¯Ÿè€… å‡ºå…¥ä¸ºnullä¸ä¼šæŠ›å‡ºå¼‚å¸¸ */ public synchronized void deleteObserver(Observer o) &#123; obs.removeElement(o); &#125; /** * é€šçŸ¥è§‚å¯Ÿè€…ä»¬ï¼Œä¸»é¢˜å¯¹è±¡ï¼ˆè¢«è§‚å¯Ÿè€…å‘ç”Ÿäº†æ”¹å˜ï¼‰ï¼Œè¯¥æ–¹æ³•ä¸ä¼ å‚æ•°ç»™è§‚å¯Ÿè€…ä»¬ */ public void notifyObservers() &#123; notifyObservers(null); &#125; /** * é€šçŸ¥è§‚å¯Ÿè€…ä»¬ï¼Œä¸»é¢˜å¯¹è±¡ï¼ˆè¢«è§‚å¯Ÿè€…å‘ç”Ÿäº†æ”¹å˜ï¼‰ï¼Œè¯¥æ–¹æ³•ä¼ å‚æ•°ç»™è§‚å¯Ÿè€…ä»¬ */ public void notifyObservers(Object arg) &#123; /* * a temporary array buffer, used as a snapshot of the state of * current Observers. */ Object[] arrLocal; synchronized (this) &#123; /* * åœ¨é€šçŸ¥è§‚å¯Ÿè€…ä»¬ä¹‹å‰ä¼šå…ˆæ ¡éªŒæ ‡è¯†ä¸»é¢˜å¯¹è±¡ï¼ˆè¢«è§‚å¯Ÿè€…ï¼‰æ”¹å˜çš„å±æ€§ï¼Œå¦‚æœæ²¡æœ‰æ”¹å˜å°±ç›´æ¥è¿”å›ä¸è¿›è¡Œé€šçŸ¥ */ if (!changed) return; arrLocal = obs.toArray(); clearChanged(); &#125; for (int i = arrLocal.length-1; i&gt;=0; i--) // é€šè¿‡è°ƒç”¨è§‚å¯Ÿè€…çš„updateæ–¹æ³•é€šçŸ¥è§‚å¯Ÿè€…ï¼Œä¼šæŠŠå½“å‰ä¸»é¢˜å¯¹è±¡ï¼ˆè¢«è§‚å¯Ÿè€…å¯¹è±¡ï¼‰ä¼ ç»™è§‚å¯Ÿè€… ((Observer)arrLocal[i]).update(this, arg); &#125; /** * æ¸…é™¤è§‚å¯Ÿè€…åˆ—è¡¨ */ public synchronized void deleteObservers() &#123; obs.removeAllElements(); &#125; /** * è°ƒç”¨è¿™ä¸ªæ–¹æ³•å°±æ˜¯è¯´æ˜äº†ä¸»é¢˜å¯¹è±¡ï¼ˆè¢«è§‚å¯Ÿè€…å‘ç”Ÿäº†æ”¹å˜ï¼‰ï¼Œè®¾ç½®æ ‡è¯†å¯¹è±¡ä¸ºtrue */ protected synchronized void setChanged() &#123; changed = true; &#125; /** * * è°ƒç”¨è¿™ä¸ªæ–¹æ³•è¯´æ˜ä¸»é¢˜å¯¹è±¡ï¼ˆè¢«è§‚å¯Ÿè€…ï¼‰å·²ç»ä¸å†æ”¹å˜äº†æˆ–è€…è¦é€šçŸ¥çš„è§‚å¯Ÿè€…éƒ½é€šçŸ¥å®Œäº†ã€‚è¿™ä¸ªæ–¹æ³•ä¼šåœ¨è°ƒç”¨notifyObserversæ–¹æ³•è‡ªåŠ¨è°ƒç”¨ */ protected synchronized void clearChanged() &#123; changed = false; &#125; /** * è·å–ä¸»é¢˜å¯¹è±¡æ˜¯å¦æ”¹å˜çš„æ ‡è¯† */ public synchronized boolean hasChanged() &#123; return changed; &#125; /** * è¿”å›å…³æ³¨ä¸»é¢˜å¯¹è±¡çš„è§‚å¯Ÿçš„ä¸ªæ•° * * @return the number of observers of this object. */ public synchronized int countObservers() &#123; return obs.size(); &#125;&#125; è§‚å¯Ÿè€…éœ€è¦å®ç°çš„æ¥å£ 123456789101112package java.util;/** * @since JDK1.0 */public interface Observer &#123; /** * * å½“è®¢é˜…çš„ä¸»é¢˜å¯¹è±¡ï¼ˆè¢«è§‚å¯Ÿè€…ï¼‰å‘ç”Ÿæ”¹å˜æ—¶ï¼Œä¼šé€šè¿‡è°ƒç”¨ notifyObserversæ–¹æ³•æ¥é€šçŸ¥æ‰€æœ‰è®¾è®¡åˆ°çš„è§‚å¯Ÿè€…ï¼Œå°±æ˜¯é€šè¿‡è°ƒç”¨è§‚å¯Ÿè€…çš„updateæ–¹æ³•è¿›è¡Œé€šçŸ¥çš„ */ void update(Observable o, Object arg);&#125; ä¸»é¢˜ç±»ï¼ˆè¢«è§‚å¯Ÿè€…ï¼‰ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.design.pattern.observer;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.util.ArrayList;import java.util.List;import java.util.Observable;/** * Course * 1 å®ƒä¸‹é¢æœ‰é—®é¢˜ï¼ŒCourseå±äºè¢«è§‚å¯Ÿè€…ï¼Œä¹Ÿå°±æ˜¯ä¸»é¢˜å¯¹è±¡ * 2 ä½œä¸ºè¢«è§‚å¯Ÿè€…å¿…é¡»ç»§æ‰¿Observableç±»ï¼Œæ ‡å¿—æ˜¯å¯è§‚å¯Ÿçš„ * * @author shunhua * @date 2019-10-02 */@Data@Slf4jpublic class Course extends Observable &#123; /** * è¯¾ç¨‹å */ private String name; /** * è¯¾ç¨‹å¯¹åº”çš„é—®é¢˜åˆ—è¡¨ */ private List&lt;Question&gt; questions = new ArrayList&lt;&gt;(); public Course(String name) &#123; this.name = name; &#125; public void addQuestion(Question question) &#123; questions.add(question); &#125; /** * ä¸»é¢˜æ”¹å˜æ–¹æ³• * * @param course */ public void produceQuestion(Course course) &#123; questions.stream().forEach(question -&gt; &#123; log.info(String.format(\"%såœ¨%sæå‡ºäº†é—®é¢˜\", question.getUserName(), course.getName())); /** * è°ƒç”¨çˆ¶ç±»Observabelä¸­çš„setChangedæ–¹æ³•ï¼ŒæŠŠchangedæ ‡è¯†è®¾ç½®ä¸ºtrue,è¡¨ç¤ºä¸»é¢˜å¯¹è±¡å‘ç”Ÿäº†æ”¹å˜,æ­¤æ—¶è§‚å¯Ÿè€…å’Œè¢«è§‚å¯Ÿè€…ä¹‹é—´è¿›è¡Œé€šä¿¡ */ setChanged(); /** * é€šçŸ¥è§‚å¯Ÿè€… */ notifyObservers(question); &#125; ); &#125;&#125; è§‚å¯Ÿè€… 123456789101112131415161718192021222324252627282930313233343536373839package com.design.pattern.observer;import lombok.AllArgsConstructor;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.util.Observable;import java.util.Observer;/** * Teacher * * 1 è§‚å¯Ÿçš„æ˜¯è¯¾ç¨‹ï¼Œè€Œä¸æ˜¯é—®é¢˜ï¼Œé—®é¢˜å±äºè¯¾ç¨‹ ã€‚ Teacherå±äºè§‚å¯Ÿè€… * 2 å¿…é¡»å®ç°Observeræ¥å£ï¼Œè¡¨ç¤ºå®ƒæ˜¯ä¸€ä¸ªè§‚å¯Ÿè€… * * @author shunhua * @date 2019-10-02 */@Data@AllArgsConstructor@Slf4jpublic class Teacher implements Observer &#123; /** * è€å¸ˆåç§° */ private String name; /** * * @param o è¢«è§‚å¯Ÿå¯¹è±¡ * @param arg è¢«è§‚å¯Ÿè€…çš„notifyObserversæ–¹æ³•ä¼ é€’è¿‡æ¥çš„å¯¹è±¡ */ @Override public void update(Observable o, Object arg) &#123; Course course = (Course) o; Question question = (Question) arg; log.info(String.format(\"%sè¯¾ç¨‹è¢«%såŒå­¦æå‡º%sçš„é—®é¢˜ï¼Œéœ€è¦%sè§£ç­”\",course.getName(),question.getUserName(),question.getQuestionContent(),name)); &#125;&#125; åº”ç”¨è¾…åŠ©ç±» 1234567891011121314151617181920212223package com.design.pattern.observer;import lombok.Builder;import lombok.Data;/** * Question * * @author shunhua * @date 2019-10-02 */@Data@Builderpublic class Question &#123; /** * é—®é¢˜æé—®è€…åç§° */ private String userName; /** * å…·ä½“é—®é¢˜ */ private String questionContent;&#125; åº”ç”¨å±‚ 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.observer;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-10-02 */public class Client &#123; @Test public void test()&#123; Course course = new Course(\"ã€ŠJavaä»å…¥é—¨åˆ°æ”¾å¼ƒã€‹\"); Teacher teacher = new Teacher(\"Javaå­¦é™¢è€å¸ˆ\"); Teacher teacher1 = new Teacher(\"é¼“åŠ±å¸ˆ\"); // ä¸ºè¯¾ç¨‹æ·»åŠ è§‚å¯Ÿè€… course.addObserver(teacher); course.addObserver(teacher1); // æ·»åŠ è¯¾ç¨‹çš„é—®é¢˜ course.addQuestion(Question.builder() .userName(\"gentryhuang\") .questionContent(\"Javaå­¦ä¸å®Œï¼Œéœ€è¦æ”¾å¼ƒå—ï¼Ÿ\") .build()); course.addQuestion(Question.builder() .userName(\"xw\") .questionContent(\"å¿«çœ‹ï¼Œåˆä¸€ä¸ªå­¦Javaçš„è½¬è¡Œäº†ï¼Œè¦è·‘è·¯å—ï¼Ÿ\") .build()); // ä¸»é¢˜å¯¹è±¡å‘ç”Ÿå˜åŒ–ï¼ˆæœ‰é—®é¢˜æå‡ºäº†ï¼‰ course.produceQuestion(course); &#125;&#125; è§‚å¯Ÿè€…æ¨¡å¼æºç è§£æç›‘å¬å™¨å®ç°æ–¹æ¡ˆå°±æ˜¯è§‚å¯Ÿè€…æ¨¡å¼å®ç°çš„ä¸€ç§ Guavaä¸­è§‚å¯Ÿè€…æ¨¡å¼çš„ä½¿ç”¨ ä½¿ç”¨@Subscribeè¿›è¡Œæ–¹æ³•æ ‡æ³¨ 12345678910111213141516171819package com.design.pattern.observer.guava;import com.google.common.eventbus.Subscribe;import lombok.extern.slf4j.Slf4j;/** * GuavaEvent * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class GuavaEvent &#123; @Subscribe public void subscribe(String event)&#123; log.info(\"æ‰§è¡Œsubscribeæ–¹æ³•ï¼Œä¼ å…¥å‚æ•°æ˜¯ï¼š\" + event); &#125;&#125; åœ¨åº”ç”¨å±‚æŠŠè®¢é˜…è€…è¿›è¡Œæ³¨å†Œ 12345678910111213141516171819202122232425262728293031323334package com.design.pattern.observer.guava;import com.google.common.eventbus.EventBus;import org.junit.Test;/** * GuavaEventTest * * @author shunhua * @date 2019-10-02 */public class GuavaEventTest &#123; @Test public void test() &#123; /** * Guavaå®ç°è§‚å¯Ÿè€…æ¨¡å¼çš„æ ¸å¿ƒç±» */ EventBus eventBus = new EventBus(); /** * GuavaEventä¸­æœ‰ä½¿ç”¨@Subscribeæ³¨è§£æ ‡æ³¨çš„æ–¹æ³• */ GuavaEvent guavaEvent = new GuavaEvent(); /** * GuavaEventçš„@Subscribeæ ‡æ³¨çš„æ–¹æ³• åŠ å…¥åˆ°è§‚å¯Ÿè€…æ¨¡å¼ä¸­ï¼Œä½œä¸ºè®¢é˜…è€…å³è§‚å¯Ÿè€… */ eventBus.register(guavaEvent); /** * è°ƒç”¨EventBusçš„postæ–¹æ³•ä¼šå›è°ƒSubscribeæ ‡æ³¨çš„æ–¹æ³• */ eventBus.post(\"postçš„å†…å®¹\"); &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"å•ä¾‹æ¨¡å¼","slug":"design_pattern/creation_type/å•ä¾‹æ¨¡å¼","date":"2019-10-01T16:00:00.000Z","updated":"2020-07-04T16:28:45.963Z","comments":true,"path":"posts/f1601c3e/","link":"","permalink":"https://gentryhuang.com/posts/f1601c3e/","excerpt":"","text":"å•ä¾‹æ¨¡å¼å®šä¹‰ä¿è¯ä¸€ä¸ªç±»ä»…æœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›ä¸€ä¸ªå…¨å±€è®¿é—®ç‚¹ã€‚ ç±»å‹åˆ›å»ºå‹ é€‚ç”¨åœºæ™¯12æƒ³ç¡®ä¿ä»»ä½•æƒ…å†µä¸‹éƒ½ç»å¯¹åªæœ‰ä¸€ä¸ªå®ä¾‹ - æ•°æ®åº“è¿æ¥æ± ã€çº¿ç¨‹æ± ä»¥åŠè®¡æ•°å™¨ç­‰ ä¼˜ç‚¹1234561. åœ¨å†…å­˜é‡Œåªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå‡å°‘äº†å†…å­˜å¼€é”€ - ç‰¹åˆ«æ˜¯ä¸€ä¸ªå¯¹è±¡é¢‘ç¹çš„åˆ›å»ºå’Œé”€æ¯ï¼Œè€Œä¸”åœ¨åˆ›å»ºå’Œé”€æ¯æ—¶æ€§èƒ½åˆä¸èƒ½å¾ˆå¥½çš„ä¼˜åŒ–2. å¯ä»¥é¿å…å¯¹èµ„æºçš„å¤šé‡å ç”¨ - å¦‚å¯¹ä¸€ä¸ªæ–‡ä»¶è¿›è¡Œå†™æ“ä½œï¼Œç”±äºåªæœ‰ä¸€ä¸ªå®ä¾‹å­˜åœ¨å†…å­˜ä¸­ï¼Œå¯ä»¥é¿å…å¯¹åŒä¸€ä¸ªèµ„æºæ–‡ä»¶åŒæ—¶å†™æ“ä½œ3. è®¾ç½®å…¨å±€è®¿é—®ç‚¹ï¼Œä¸¥æ ¼æ§åˆ¶è®¿é—® - å¯¹å¤–æ§åˆ¶åˆ›å»ºçš„å…¥å£ ç¼ºç‚¹1æ²¡æœ‰æ¥å£ï¼Œæ‰©å±•å›°éš¾ï¼Œæƒ³è¦æ‰©å±•éœ€è¦ä¿®æ”¹æºä»£ç  æ‹“å±•ç‚¹1234567891011121. ç§æœ‰æ„é€ å™¨ - ä¸ºäº†ç¦æ­¢ä»å•ä¾‹ç±»å¤–éƒ¨è°ƒç”¨æ„é€ å‡½æ•°åˆ›å»ºå¯¹è±¡ï¼Œä¸ºäº†è¾¾åˆ°ç›®çš„å¿…é¡»è®¾ç½®æ„é€ å‡½æ•°ä¸ºç§æœ‰çš„2. çº¿ç¨‹å®‰å…¨ - çº¿ç¨‹å®‰å…¨åœ¨å•ä¾‹æ¨¡å¼è®¾è®¡çš„è¿‡ç¨‹ä¸­éå¸¸é‡è¦3. å»¶è¿ŸåŠ è½½ - å»¶æ—¶åˆ›å»ºå¯¹è±¡4. åºåˆ—åŒ–å’Œååºåˆ—åŒ–å®‰å…¨ - å¯¹äºå•ä¾‹å¯¹è±¡ä¸€æ—¦åºåˆ—åŒ–å’Œååºåˆ—åŒ–ï¼Œå°±ä¼šå¯¹å•ä¾‹è¿›è¡Œç ´å5. åå°„ - å•ä¾‹æ¨¡å¼ä¹Ÿè¦é˜²æ­¢åå°„æ”»å‡»6. åŒé‡æ£€é”æœºåˆ¶7. å•ä¾‹é™æ€å†…éƒ¨ç±»çš„å®ç°æ–¹æ¡ˆ å•ä¾‹æ¨¡å¼ç›¸å…³çš„è®¾è®¡æ¨¡å¼å•ä¾‹æ¨¡å¼å’Œå·¥å‚æ¨¡å¼ 1åœ¨ä¸€äº›ä¸šåŠ¡åœºæ™¯ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå·¥å‚ç±»è®¾ç½®ä¸ºå•ä¾‹çš„ å•ä¾‹æ¨¡å¼å’Œäº«å…ƒæ¨¡å¼ 1åœ¨ä¸€äº›ä¸šåŠ¡åœºæ™¯ä¸­ï¼Œè¦ç®¡ç†å¾ˆå¤šå•ä¾‹å¯¹è±¡ï¼Œé€šè¿‡äº«å…ƒæ¨¡å¼å’Œå•ä¾‹æ¨¡å¼ç»“åˆæ¥å®Œæˆå•ä¾‹å¯¹è±¡çš„è·å–ï¼Œåœ¨è¿™ç§ç»“åˆåœºæ™¯ä¸‹ï¼Œäº«å…ƒæ¨¡å¼çš„åº”ç”¨å°±ç±»ä¼¼äºå•ä¾‹å¯¹è±¡çš„ä¸€ä¸ªå·¥å‚ï¼Œåªä¸è¿‡ä¼šè·å–å·²ç»åˆ›å»ºå¥½çš„å¯¹è±¡è€Œä¸ä¼šé‡æ–°åˆ›å»ºæ–°çš„å¯¹è±¡ã€‚ å•ä¾‹æ¨¡å¼ç±»å‹æ‡’æ±‰å¼å•ä¾‹æ¨¡å¼-éå®‰å…¨ 1234567891011121314151617181920212223242526272829303132333435363738394041package com.design.pattern.singleton.lazynosafe;/** * LazyDoubleCheckSingleton æ‡’æ±‰å¼-çº¿ç¨‹ä¸å®‰å…¨ * * @author shunhua * @date 2019-10-02 */public class LazySingleton &#123; /** * å®šä¹‰LazySingletonå±æ€§ */ private static LazySingleton lazySingleton = null; /** * æŒ‡å®šæ„é€ æ–¹æ³•æ˜¯ç§æœ‰çš„ */ private LazySingleton()&#123;&#125; /** * å…¨å±€æ§åˆ¶ç‚¹ * @return */ public static LazySingleton getInstance()&#123; /** * åœ¨æ²¡æœ‰æ–­ç‚¹å¹²é¢„çš„æƒ…å†µä¸‹ï¼Œå¤šçº¿ç¨‹æ‰§è¡Œå’ŒCPUåˆ†é…æœ‰å…³ã€‚ä¸ºäº†æ›´æ¸…æ¥šçš„è§‚çœ‹å¤šçº¿ç¨‹æ‰§è¡Œï¼Œå¯ä»¥ä½¿ç”¨å¤šçº¿ç¨‹debugæ¥è¾¾åˆ°æ§åˆ¶å¤šä¸ªçº¿ç¨‹çš„ç›®çš„ * * åœ¨å¤šçº¿ç¨‹ä¸‹æœ‰ä»¥ä¸‹å‡ ç§å¯èƒ½ï¼Œè¿™é‡Œä»¥ä¸¤ä¸ªçº¿ç¨‹è§£é‡Šï¼Œçº¿ç¨‹Aå’Œçº¿ç¨‹B * * 1 å½“çº¿ç¨‹Bèµ°åˆ°if(lazySingleton == null)æ—¶ï¼Œçº¿ç¨‹Aå·²ç»æ‰§è¡Œåˆ›å»ºå¥½äº†å¯¹è±¡ï¼Œæ­¤æ—¶çº¿ç¨‹Bç›´æ¥è¿”å›çº¿ç¨‹Aåˆ›å»ºçš„å¯¹è±¡ * 2 å½“çº¿ç¨‹Bèµ°åˆ°if(lazySingleton == null)æ—¶ï¼Œçº¿ç¨‹Aè¿˜æ²¡æœ‰åˆ›å»ºå¥½å¯¹è±¡å³LazySingletonä»ç„¶ä¸ºç©ºï¼Œç´§æ¥ç€çº¿ç¨‹Bçš„ifåˆ¤æ–­é€šè¿‡ï¼Œå½“Aåˆ›å»ºå®Œå¯¹è±¡å‡†å¤‡è¿”å›lazySingletonå³æ‰§è¡Œreturn lazySingletonæ—¶ï¼Œçº¿ç¨‹Båˆ›å»ºå¥½äº†å¯¹è±¡å¹¶èµ‹å€¼ç»™lazySingletonï¼Œæ­¤æ—¶lazySingletonå˜é‡çš„å€¼æ˜¯çº¿ç¨‹Båˆ›å»ºçš„å¯¹è±¡å¼•ç”¨ï¼Œä¼šè¦†ç›–çº¿ç¨‹Aåˆ›å»ºçš„å¯¹è±¡å¯¹åº”çš„å¼•ç”¨ï¼Œæœ€ç»ˆçº¿ç¨‹Aå’Œçº¿ç¨‹Bè¿”å›çš„è™½ç„¶æ˜¯æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ï¼ˆçº¿ç¨‹Båˆ›å»ºçš„ï¼‰çš„å¼•ç”¨ï¼Œä½†æ˜¯å®è´¨ä¸Šå¯¹è±¡å·²ç»åˆ›å»ºäº†ä¸¤æ¬¡ã€‚ * 3 å½“çº¿ç¨‹Bèµ°åˆ°if(lazySingleton == null)æ—¶ï¼Œçº¿ç¨‹Aè¿˜æ²¡æœ‰åˆ›å»ºå¥½å¯¹è±¡å³LazySingletonä»ç„¶ä¸ºç©ºï¼Œä»…æ¥ç€çº¿ç¨‹Bçš„ifåˆ¤æ–­é€šè¿‡ï¼Œçº¿ç¨‹Aåœ¨çº¿ç¨‹Båˆ›å»ºå¯¹è±¡ä¹‹å‰è¿”å›äº†ï¼Œé‚£ä¹ˆæœ€ç»ˆçº¿ç¨‹Aå’Œçº¿ç¨‹Béƒ½ä¼šåˆ›å»ºå¯¹è±¡ï¼Œå¹¶ä¸”è¿”å›çš„å¯¹è±¡å¼•ç”¨ä¸ä¼šç›¸åŒï¼Œå®ƒä»¬æŒ‡å‘å„è‡ªåˆ›å»ºçš„å¯¹è±¡ã€‚ * */ if(lazySingleton == null)&#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125; 123456789101112131415161718192021package com.design.pattern.singleton.lazynosafe;import lombok.extern.slf4j.Slf4j;/** * MyThread å®ç°Runnableæ¥å£ï¼Œå®ç°å¤šçº¿ç¨‹ * * @author shunhua * @date 2019-10-02 */@Slf4jpublic class MyThread implements Runnable &#123; @Override public void run() &#123; // è·å–ç›®æ ‡å¯¹è±¡ LazySingleton lazySingleton = LazySingleton.getInstance(); // æ‰“å°å½“å‰æ‰§è¡Œçš„çº¿ç¨‹ä¿¡æ¯å’Œç›®æ ‡å¯¹è±¡ä¿¡æ¯ log.info(Thread.currentThread().getName() +\" \"+ lazySingleton); &#125;&#125; æ‡’æ±‰å¼å•ä¾‹æ¨¡å¼å®‰å…¨-é”ç²’åº¦è¾ƒå¤§ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.design.pattern.singleton.lazysafebutlockisbig;/** * LazyDoubleCheckSingleton æ‡’æ±‰å¼-çº¿ç¨‹å®‰å…¨ä½†æ˜¯é”çš„ç²’åº¦å¤ªå¤§ * * @author shunhua * @date 2019-10-02 */public class LazySingleton &#123; /** * å®šä¹‰LazySingletonå±æ€§ */ private static LazySingleton lazySingleton = null; /** * æŒ‡å®šæ„é€ æ–¹æ³•æ˜¯ç§æœ‰çš„ */ private LazySingleton()&#123;&#125; /** * å…¨å±€æ§åˆ¶ç‚¹ * * synchronizeåŠ é”çš„ä½ç½®ä¸åŒï¼Œçº¿ç¨‹æŒæœ‰çš„å¯¹è±¡ä¹Ÿä¼šä¸åŒ * 1 åŠ åœ¨é™æ€æ–¹æ³•ä¸Šï¼ŒæŒæœ‰çš„æ˜¯ç±»çš„classæ–‡ä»¶ï¼Œå³å½“å‰ç±» * 2 åŠ åœ¨éé™æ€æ–¹æ³•ä¸Šï¼ŒæŒæœ‰çš„æ˜¯å †å†…å­˜ä¸­çš„å¯¹è±¡ï¼Œå³æ‰§è¡Œå½“å‰æ–¹æ³•çš„å¯¹è±¡ * * @return */ public synchronized static LazySingleton getInstance()&#123; /** * synchronizeåŠ é”åœ¨é™æ€æ–¹æ³•ä¸Šç­‰åŒäºé”ä»£ç å—æ—¶LazySingleton.classä½œä¸ºæŒæœ‰å¯¹è±¡ï¼š * * public static LazyDoubleCheckSingleton getInstance()&#123; * synchronized(LazyDoubleCheckSingleton.class)&#123; * if (lazySingleton == null) &#123; * lazySingleton = new LazyDoubleCheckSingleton(); * &#125; * &#125; * return lazySingleton; * &#125; */ if(lazySingleton == null)&#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125; æ‡’æ±‰å¼å•ä¾‹æ¨¡å¼-åŒé‡æ£€é” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.design.pattern.singleton.lazysafedoublecheck;/** * LazyDoubleCheckSingleton åŒé‡æ£€é”ï¼Œå…¼é¡¾äº†æ€§èƒ½å’Œçº¿ç¨‹å®‰å…¨ * * @author shunhua * @date 2019-10-03 */public class LazyDoubleCheckSingleton &#123; /** * å®šä¹‰LazySingletonå±æ€§ ,è¿™é‡ŒåŠ volatileå…³é”®å­—é˜²æ­¢æŒ‡ä»¤é‡æ’åºå’Œå†…å­˜å¯è§ */ private volatile static LazyDoubleCheckSingleton lazySingleton = null; /** * æŒ‡å®šæ„é€ æ–¹æ³•æ˜¯ç§æœ‰çš„ */ private LazyDoubleCheckSingleton()&#123;&#125; /** * å…¨å±€æ§åˆ¶ç‚¹ * * åŒé‡æ£€é”æŒ‡çš„å°±æ˜¯ä¸¤æ¬¡åˆ¤æ–­ * * @return */ public static LazyDoubleCheckSingleton getInstance()&#123; /** * 1 è¿™ä¸€å±‚ifåˆ¤æ–­å¦‚æœä¸ä½¿ç”¨ä¹Ÿèƒ½ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œä½†æ˜¯é”çš„ç²’åº¦åˆå›åˆ°äº†å¤§ç²’åº¦ç‰ˆæœ¬ã€‚ä½¿ç”¨è¿™ä¸€å±‚åˆ¤æ–­æ˜¯ä¸ºäº†ç¼©å°synchronizedé”çš„ç²’åº¦ * 2 å¼•å…¥äº†è¿™ä¸€å±‚ä¼šå¢åŠ ä¸€ä¸ªéšæ‚£-ç”±äºæŒ‡ä»¤é‡æ’åºï¼Œèµ°åˆ°è¯¥å±‚ifåˆ¤æ–­lazySingletonå¯èƒ½ç¡®å®ä¸ä¸ºç©ºï¼Œä½†æ˜¯å®ƒæŒ‡å‘çš„å¯¹è±¡å¯èƒ½è¿˜æ²¡æœ‰åˆå§‹åŒ–å®Œæˆï¼Œå½“ä½¿ç”¨è¿™ä¸ªå¯¹è±¡çš„æ—¶å€™å¯èƒ½ä¼šå¯¼è‡´ç³»ç»Ÿå¼‚å¸¸ */ if(lazySingleton == null)&#123; /** * åŠ é” */ synchronized (LazyDoubleCheckSingleton.class)&#123; /** * è¿™ä¸€å±‚ifå¿…é¡»è¦æœ‰ï¼Œå› ä¸ºsynchronizedé”çš„ç²’åº¦å°äº†ï¼Œä¸æ˜¯æ•´ä¸ªæ–¹æ³•ï¼Œå½“å‡ºç°çº¿ç¨‹è¿›å…¥ç¬¬ä¸€ä¸ªifå—ä¸­ä½†è¢«é˜»å¡åœ¨åŒæ­¥ä»£ç å—å¤–æ—¶ï¼ˆåˆ«çš„çº¿ç¨‹æ‹¿åˆ°äº†é”åœ¨é‡Œé¢åˆ›å»ºå¯¹è±¡ï¼‰ï¼Œ * å¦‚æœä¸åŠ è¯¥ifåˆ¤æ–­è¯¥çº¿ç¨‹è¿˜ä¼šåˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œè€Œä¸ä¼šç›´æ¥è¿”å›å·²ç»åˆ›å»ºå¥½çš„å¯¹è±¡çš„å¼•ç”¨ã€‚ */ if(lazySingleton == null)&#123; /** LazyDoubleCheckSingleton = new LazyDoubleCheckSingleton() JVMä¸»è¦åšçš„äº‹ç²—ç•¥æ­¥éª¤å¦‚ä¸‹ï¼š * * 1. åœ¨å †ç©ºé—´é‡Œåˆ†é…å†…å­˜ç»™è¿™ä¸ªå¯¹è±¡ * 2. æ‰§è¡Œæ„é€ æ–¹æ³•è¿›è¡Œåˆå§‹åŒ–ï¼Œæ³¨æ„æ­¤åˆå§‹åŒ–ä¸æ˜¯ç±»åŠ è½½è¿‡ç¨‹ä¸­çš„åˆå§‹åŒ– * 3. è®¾ç½®lazySingletonæŒ‡å‘åˆ†é…å¥½çš„å†…å­˜åœ°å€ * æ³¨æ„ï¼šåœ¨æ²¡æœ‰å¤„ç†æŒ‡ä»¤é‡æ’åºçš„æƒ…å†µä¸‹2ã€3ä¸¤æ­¥ç”±äºé‡æ’åºå¯èƒ½æ­¥éª¤ä¼šå€’ç½®ï¼ˆå› ä¸ºJavaè¯­è¨€è§„èŒƒï¼Œå…è®¸é‚£äº›åœ¨å•çº¿ç¨‹å†…ä¸ä¼šæ”¹å˜å•çº¿ç¨‹ç¨‹åºæ‰§è¡Œç»“æœçš„é‡æ’åºï¼Œå› ä¸ºæœ‰çš„é‡æ’åºå¯ä»¥æé«˜ç¨‹åºæ‰§è¡Œæ€§èƒ½ ï¼‰ï¼Œè¿™ä¼šå¯èƒ½ä¼šé€ æˆçº¿ç¨‹æ‹¿åˆ°çš„å¼•ç”¨æŒ‡å‘çš„æ˜¯ä¸€ä¸ªè¿˜æ²¡æœ‰åˆå§‹åŒ–å®Œæˆçš„å¯¹è±¡ï¼Œè™½ç„¶ä¸ä¸ºç©ºä½†å®ƒè¿˜æ²¡æœ‰æ‰§è¡Œæ„é€ æ–¹æ³•ï¼Œå¦‚æœæ°å·§æ„é€ æ–¹æ³•é‡Œé¢éœ€è¦å¯¹æŸäº›å‚æ•°è¿›è¡Œåˆå§‹åŒ–ï¼Œå½“ä½¿ç”¨è¿™ä¸ªå¯¹è±¡è¿˜æ²¡æœ‰åˆå§‹åŒ–çš„å‚æ•°æ—¶ä¼šå¯¼è‡´ç³»ç»Ÿå¼‚å¸¸ * * è¯¦ç»†çš„æ­¥éª¤å¦‚ä¸‹ï¼š * 1. å½“é‡åˆ°newæŒ‡ä»¤æ—¶ï¼Œä¼šå…ˆæ£€æŸ¥è¿™ä¸ªæŒ‡å®šçš„å‚æ•°ä¹Ÿå°±æ˜¯LazyDoubleCheckSingletonèƒ½å¦åœ¨å¸¸é‡æ± ä¸­å®šä½åˆ°è¯¥ç±»çš„ç¬¦å·å¼•ç”¨ï¼Œå¹¶ä¸”æ£€æŸ¥è¿™ä¸ªç¬¦å·å¼•ç”¨ä»£è¡¨çš„ç±»æ˜¯å¦å·²ç»æ‰§è¡Œè¿‡ç±»çš„åŠ è½½ï¼ˆåŠ è½½ã€è§£æã€å‡†å¤‡å’Œåˆå§‹åŒ–ï¼‰ï¼Œå¦‚æœæ²¡æœ‰å°±æ‰§è¡Œä¸‹ä¸€æ­¥ï¼Œå¦‚æœæ‰§è¡Œäº†æ¥ç€è™šæ‹Ÿæœºä¸ºæ–°ç”Ÿå¯¹è±¡åˆ†é…å†…å­˜ï¼ˆæ­¤æ—¶ä»è™šæ‹Ÿæœºçš„è§†è§’æ¥è¯´ä¸€ä¸ªæ–°å¯¹è±¡å·²ç»äº§ç”Ÿäº†ï¼‰ï¼Œç´§æ¥ç€æ‰§è¡ŒnewæŒ‡ä»¤æ‰§è¡Œä¹‹åçš„è°ƒç”¨&lt;init&gt;æ–¹æ³•ã€‚ * 2. åŠ è½½ ï¼ˆ1 é€šè¿‡ç±»çš„å…¨é™å®šåè·å–å®šä¹‰æ­¤ç±»çš„äºŒè¿›åˆ¶å­—èŠ‚æµ 2 å°†è¿™ä¸ªå­—èŠ‚æµä»£è¡¨çš„é™æ€å­˜å‚¨ç»“æ„è½¬åŒ–ä¸ºæ–¹æ³•åŒºçš„è¿è¡Œæ—¶æ•°æ®ç»“æ„å³Classä¸­çš„å¸¸é‡æ± è¿›å…¥æ–¹æ³•åŒºçš„è¿è¡Œæ—¶å¸¸é‡æ± ä¸­ 3 åœ¨æ–¹æ³•åŒºç”Ÿæˆä¸€ä¸ªä»£è¡¨è¿™ä¸ªç±»çš„Classå¯¹è±¡ï¼‰ * 3. éªŒè¯ ï¼ˆç¡®ä¿Classæ–‡ä»¶çš„å­—èŠ‚æµä¸­åŒ…å«çš„ä¿¡æ¯ç¬¦åˆå½“å‰è™šæ‹Ÿæœºçš„è¦æ±‚ï¼Œç¡®ä¿è™šæ‹Ÿæœºè‡ªèº«å®‰å…¨ï¼‰ * 4. å‡†å¤‡ ï¼ˆåœ¨æ–¹æ³•åŒºä¸­ä¸ºç±»å˜é‡åˆ†é…å†…å­˜å¹¶è®¾ç½®ç±»å˜é‡åˆå§‹å€¼ï¼‰ * 5. è§£æ ï¼ˆå¯èƒ½ä¼šå‘ç”Ÿï¼Œå› ä¸ºå®ƒä¹Ÿå¯èƒ½å‘ç”Ÿåœ¨åˆå§‹åŒ–é˜¶æ®µä¹‹åã€‚ ä¸»è¦ä½œç”¨å°±æ˜¯å°†å¸¸é‡æ± ä¸­çš„ç¬¦å·å¼•ç”¨æ›¿æ¢ä¸ºç›´æ¥å¼•ç”¨ï¼‰ * 6. åˆå§‹åŒ– ï¼ˆè¿™æ˜¯ç±»åŠ è½½è¿‡ç¨‹çš„æœ€åä¸€æ­¥ï¼Œä¸»è¦å°±æ˜¯æ‰§è¡Œç±»æ„é€ å™¨&lt;clinit&gt;æ–¹æ³•ï¼Œåˆå§‹åŒ–ç±»å˜é‡ï¼‰ * * æœ€åï¼šè®¾ç½®lazySingletonæŒ‡å‘åˆ†é…å¥½çš„å†…å­˜åœ°å€ */ lazySingleton = new LazyDoubleCheckSingleton(); &#125; &#125; &#125; return lazySingleton; &#125;&#125; æšä¸¾å¼å•ä¾‹æ¨¡å¼ 12345678910111213141516171819202122232425262728293031323334353637383940package com.design.pattern.singleton.enuminstance;/** * EnumInstance ä½¿ç”¨æšä¸¾çš„æ–¹å¼å®ç°å•ä¾‹æ¨¡å¼ * * 1. æšä¸¾å®é™…ä¸Šæ˜¯ä¸€ä¸ªç»§æ‰¿Enumçš„è¢«finalä¿®é¥°çš„ç±»ï¼Œå®ƒçš„æ„é€ æ–¹æ³•ï¼ˆåªæœ‰æœ‰å‚æ„é€ æ–¹æ³•ï¼‰ä¹Ÿæ˜¯ç§æœ‰çš„ã€‚å…¶ä¸­æšä¸¾å¸¸é‡ä¹Ÿæ˜¯static finalçš„ï¼Œå¹¶ä¸”åœ¨staticä»£ç å—ä¸­å®ä¾‹åŒ–ï¼ˆå’Œæ¶æ±‰å¼å¾ˆåƒï¼‰ * 2. æšä¸¾å®ç°çš„å•ä¾‹é˜²æ­¢äº†åºåˆ—åŒ–æ”»å‡»ï¼ˆreadObjectæ–¹æ³•æ‰§è¡Œè·å–çš„å¯¹è±¡æ˜¯å·²ç»å­˜åœ¨çš„æšä¸¾å¸¸é‡ï¼‰å’Œåå°„æ”»å‡»ï¼ˆæšä¸¾ç±»çš„æ„é€ å‡½æ•°ä¼šåˆ¤æ–­ï¼Œå¦‚æœé€šè¿‡åå°„è°ƒç”¨å°±æŠ›å‡ºå¼‚å¸¸ï¼‰ä»¥åŠçº¿ç¨‹å®‰å…¨ * 3. æ¨èä½¿ç”¨æšä¸¾å®ç°å•ä¾‹ * * @author shunhua * @date 2019-10-03 */public enum EnumInstance &#123; /** * æšä¸¾å¸¸é‡ */ INSTANCE; /** * æšä¸¾çš„æˆå‘˜å˜é‡ */ private Object data; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; /** * æš´éœ²ç»™å¤–éƒ¨çš„å…¨å±€ç‚¹ * * @return */ public static EnumInstance getInstance() &#123; return INSTANCE; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.design.pattern.singleton.enuminstance;import lombok.extern.slf4j.Slf4j;import java.io.*;import java.lang.reflect.Constructor;/** * EnumInstanceTest * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class EnumInstanceTest &#123; public static void main(String[] args) &#123; EnumInstance instance = EnumInstance.getInstance(); instance.setData(new Object()); try &#123; //------------------ æšä¸¾å®ç°çš„å•ä¾‹ï¼Œæ˜¯ä¸å—åºåˆ—åŒ–ç ´åçš„å½±å“---------------------/ File file = new File(\"singleton\"); // ä½¿ç”¨ObjectOutputStreamå¯¹è±¡è¾“å‡ºæµï¼ŒæŠŠå•ä¾‹å¯¹è±¡å†™å…¥æ–‡ä»¶ä¸­ã€‚æ³¨æ„æ–‡ä»¶çš„åç¼€åå¸¦ä¸å¸¦éƒ½è¡Œã€‚å¦‚æœä¸æŒ‡å®šæ–‡ä»¶çš„è·¯å¾„ï¼Œå°±é»˜è®¤ä½¿ç”¨å½“å‰å·¥ç¨‹çš„ç›®å½•ä½œä¸ºè·¯å¾„ ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file)); // å°†å•ä¾‹å¯¹è±¡å†™å…¥æ–‡ä»¶ä¸­ objectOutputStream.writeObject(instance); // ä½¿ç”¨ObjectInputStreamå¯¹è±¡è¾“å…¥æµï¼ŒæŠŠæ–‡ä»¶ä¸­çš„å•ä¾‹å¯¹è±¡è¯»åˆ°å†…å­˜ä¸­ ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file)); EnumInstance newInstance = (EnumInstance) objectInputStream.readObject(); /** readObjectæ–¹æ³•è°ƒç”¨çš„æ ¸å¿ƒæ–¹æ³•ï¼šè¿™ä¸ªé€»è¾‘ä¿è¯äº†å–å‡ºçš„æšä¸¾å¯¹è±¡çš„å”¯ä¸€æ€§ private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException &#123; if (bin.readByte() != TC_ENUM) &#123; throw new InternalError(); &#125; ObjectStreamClass desc = readClassDesc(false); if (!desc.isEnum()) &#123; throw new InvalidClassException(\"non-enum class: \" + desc); &#125; int enumHandle = handles.assign(unshared ? unsharedMarker : null); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) &#123; handles.markException(enumHandle, resolveEx); &#125; // è·å–æšä¸¾å¯¹è±¡çš„åç§°ï¼Œè¿™ä¸ªæ˜¯å”¯ä¸€çš„ï¼Œå®ƒå¯¹åº”ä¸€ä¸ªæšä¸¾å¸¸é‡ String name = readString(false); Enum&lt;?&gt; result = null; // è·å–æšä¸¾å¯¹è±¡çš„Class Class&lt;?&gt; cl = desc.forClass(); if (cl != null) &#123; try &#123; // é€šè¿‡æšä¸¾å¯¹è±¡çš„Classå’Œæšä¸¾å¯¹è±¡çš„åç§°è·å–å¯¹åº”çš„æšä¸¾å¸¸é‡ï¼Œæ²¡æœ‰åˆ›å»ºæ–°çš„å¯¹è±¡ @SuppressWarnings(\"unchecked\") Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name); result = en; &#125; catch (IllegalArgumentException ex) &#123; throw (IOException) new InvalidObjectException( \"enum constant \" + name + \" does not exist in \" + cl).initCause(ex); &#125; if (!unshared) &#123; handles.setObject(enumHandle, result); &#125; &#125; handles.finish(enumHandle); passHandle = enumHandle; return result; &#125; */ log.info(\"instance: \" + instance); log.info(\"newInstance: \" + newInstance); log.info(String.format(\"instance [%s] newInstance\", instance == newInstance)); System.out.println(\"------------------------------------------\"); log.info(\"instance: \" + instance.getData()); log.info(\"newInstance: \" + newInstance.getData()); log.info(String.format(\"instance.data [%s] newInstance.data\", instance.getData() == newInstance.getData())); //-------------------------- æšä¸¾å®ç°çš„å•ä¾‹,ä¸å—åå°„ç ´åçš„å½±å“ï¼Œ ----------------/ Class enumClass = EnumInstance.class; Constructor constructor = enumClass.getDeclaredConstructor(); constructor.setAccessible(true); /** * é€šè¿‡åå°„è°ƒç”¨æšä¸¾çš„æ„é€ å™¨ï¼ˆæ„é€ å™¨åªæœ‰æœ‰å‚æ„é€ ï¼‰ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œé˜²æ­¢äº†åå°„æ”»å‡» */ &#125; catch (Exception e) &#123; log.info(e.getMessage()); &#125; &#125;&#125; å®¹å™¨å•ä¾‹æ¨¡å¼ 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.design.pattern.singleton.containersingleton;import org.apache.commons.lang3.StringUtils;import org.springframework.util.ObjectUtils;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * ContainerSingleton å®¹å™¨å•ä¾‹æ¨¡å¼ * * ç»Ÿä¸€ç®¡ç†å¤šä¸ªå®ä¾‹ï¼ŒèŠ‚çœèµ„æº * * @author shunhua * @date 2019-10-03 */public class ContainerSingleton &#123; /** * å­˜æ”¾å¯¹è±¡ï¼Œç›¸å½“äºä¸€ä¸ªç¼“å­˜ */ private static Map&lt;String,Object&gt; SINGLETON_MAP = new ConcurrentHashMap&lt;&gt;(); /** * å¤šçº¿ç¨‹æƒ…å†µä¸‹ä¸å®‰å…¨ï¼Œå¯èƒ½å¯¼è‡´å€¼çš„è¦†ç›– * @param key * @param instance */ public static void putInstance(String key,Object instance)&#123; if(StringUtils.isNotBlank(key) &amp;&amp; !ObjectUtils.isEmpty(instance))&#123; if(!SINGLETON_MAP.containsKey(key))&#123; SINGLETON_MAP.put(key,instance); &#125; &#125; &#125; /** * è·å–å¯¹è±¡ * @param key * @return */ public static Object getInstance(String key)&#123; return SINGLETON_MAP.get(key); &#125;&#125; é¥¿æ±‰å¼å•ä¾‹æ¨¡å¼ 1234567891011121314151617181920212223242526272829303132333435363738394041package com.design.pattern.singleton.hungry;/** * HungrySingleton é¥¿æ±‰å¼ * &lt;p&gt; * 1 ä¼˜ç‚¹ * å†™æ³•ç®€å•ï¼Œç±»åŠ è½½ï¼ˆä¸¥æ ¼æ¥è¯´æ˜¯ç±»åŠ è½½è¿‡ç¨‹çš„åˆå§‹åŒ–é˜¶æ®µä»¥åŠè°ƒç”¨æ„é€ å‡½æ•°ï¼‰çš„æ—¶å€™å°±å®Œæˆäº†å¯¹è±¡çš„åˆ›å»ºï¼Œé¿å…äº†çº¿ç¨‹åŒæ­¥é—®é¢˜ * 2 ç¼ºç‚¹ * ç±»åŠ è½½çš„æ—¶å€™å°±å®Œæˆäº†å¯¹è±¡çš„åˆ›å»ºï¼Œæ²¡æœ‰å»¶è¿Ÿæ•ˆæœï¼Œå¦‚æœç±»çš„å¯¹è±¡ä»å§‹è‡³ç»ˆéƒ½æ²¡æœ‰ç”¨è¿‡ï¼Œæˆ–è€…åªæ˜¯æƒ³è·å–ç±»çš„æŸä¸ªç±»å˜é‡ï¼Œé‚£ä¹ˆè¿˜æ˜¯ä¼šåˆ›å»ºå¯¹è±¡ï¼Œè¿™æ— ç–‘é€ æˆäº†å†…å­˜çš„æµªè´¹ * * * @author shunhua * @date 2019-10-03 */public class HungrySingleton &#123; /** * ç§æœ‰æ„é€ å‡½æ•° */ private HungrySingleton() &#123; &#125; /** * å£°æ˜ä¸ºfinalçš„å˜é‡å¿…é¡»åœ¨ç±»åŠ è½½å®Œæˆæ—¶ï¼ˆå‡†ç¡®çš„æ˜¯ç±»åŠ è½½åˆå§‹åŒ–çš„æ—¶å€™ï¼Œsingletonå°±éœ€è¦è¢«èµ‹å€¼å³HungrySingletonå¯¹è±¡çš„å¼•ç”¨ï¼‰å°±å·²ç»èµ‹å€¼ */ // private final static HungrySingleton singleton = new HungrySingleton(); private final static HungrySingleton singleton; static &#123; singleton = new HungrySingleton(); &#125; /** * å…¨å±€è®¿é—®ç‚¹ * @return */ public static HungrySingleton getInstance() &#123; return singleton; &#125;&#125; ç ´åé¥¿æ±‰å¼å•ä¾‹-æ–¹å¼1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.design.pattern.singleton.reflectattackresolve;/** * HungrySingleton é¥¿æ±‰å¼ * &lt;p&gt; * 1 ä¼˜ç‚¹ * å†™æ³•ç®€å•ï¼Œç±»åŠ è½½ï¼ˆä¸¥æ ¼æ¥è¯´æ˜¯ç±»åŠ è½½è¿‡ç¨‹çš„åˆå§‹åŒ–é˜¶æ®µä»¥åŠè°ƒç”¨æ„é€ å‡½æ•°ï¼‰çš„æ—¶å€™å°±å®Œæˆäº†å¯¹è±¡çš„åˆ›å»ºï¼Œé¿å…äº†çº¿ç¨‹åŒæ­¥é—®é¢˜ * 2 ç¼ºç‚¹ * ç±»åŠ è½½çš„æ—¶å€™å°±å®Œæˆäº†å¯¹è±¡çš„åˆ›å»ºï¼Œæ²¡æœ‰å»¶è¿Ÿæ•ˆæœï¼Œå¦‚æœç±»çš„å¯¹è±¡ä»å§‹è‡³ç»ˆéƒ½æ²¡æœ‰ç”¨è¿‡ï¼Œæˆ–è€…åªæ˜¯æƒ³è·å–ç±»çš„æŸä¸ªç±»å˜é‡ï¼Œé‚£ä¹ˆè¿˜æ˜¯ä¼šåˆ›å»ºå¯¹è±¡ï¼Œè¿™æ— ç–‘é€ æˆäº†å†…å­˜çš„æµªè´¹ * * * @author shunhua * @date 2019-10-03 */public class HungrySingleton &#123; // private final static HungrySingleton singleton = new HungrySingleton(); private final static HungrySingleton singleton; /** * ç§æœ‰æ„é€ å‡½æ•° */ private HungrySingleton() &#123; if(singleton == null)&#123; System.out.println(\"è°ƒç”¨æ„é€ æ–¹æ³•åœ¨èµ‹å€¼å¼•ç”¨ç»™singletonä¹‹å‰ï¼Œè¿™æ˜¯æŒ‡ä»¤é‡æ’åºå¸¦æ¥çš„å¯èƒ½\"); &#125;else &#123; System.out.println(\"è°ƒç”¨æ„é€ æ–¹æ³•åœ¨èµ‹å€¼å¼•ç”¨ç»™singletonä¹‹åï¼Œè¿™æ˜¯æŒ‡ä»¤é‡æ’åºå¸¦æ¥çš„å¯èƒ½\"); &#125; &#125; /** * å£°æ˜ä¸ºfinalçš„å˜é‡å¿…é¡»åœ¨ç±»åŠ è½½å®Œæˆæ—¶ï¼ˆå‡†ç¡®çš„æ˜¯ç±»åŠ è½½åˆå§‹åŒ–çš„æ—¶å€™ï¼Œsingletonå°±éœ€è¦è¢«èµ‹å€¼å³HungrySingletonå¯¹è±¡çš„å¼•ç”¨ï¼‰å°±å·²ç»èµ‹å€¼ */ static &#123; singleton = new HungrySingleton(); &#125; /** * å…¨å±€è®¿é—®ç‚¹ * @return */ public static HungrySingleton getInstance() &#123; return singleton; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.design.pattern.singleton.reflectattackresolve;import lombok.extern.slf4j.Slf4j;import java.lang.reflect.Constructor;/** * HungrySingletonTest * * åå°„ç ´åå•ä¾‹æ¨¡å¼ä¸å®¹æ˜“å½»åº•é˜»æ­¢ï¼Œæ²¡æœ‰ç‰¹åˆ«å¥½çš„æ–¹å¼ã€‚ * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class HungrySingletonTest &#123; /** * å¯¹äºåœ¨ç±»åŠ è½½çš„æ•´ä¸ªè¿‡ç¨‹å®ä¾‹å°±èƒ½åˆ›å»ºå¥½çš„å•ä¾‹æ¨¡å¼ï¼ˆæ¶æ±‰å¼ã€é™æ€å†…éƒ¨ç±»ï¼‰ï¼Œä¸ºäº†é˜²æ­¢åå°„æ”»å‡»ï¼Œå¯ä»¥åœ¨æ„é€ æ–¹æ³•ä¸­è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœæ˜¯é€šè¿‡åå°„åˆ›å»ºå¯¹è±¡å°±æŠ›å‡ºå¼‚å¸¸ * * * @param args */ public static void main(String[] args) &#123; try &#123; // è·å–hungrySingletonçš„Classå¯¹è±¡ Class objectClass = HungrySingleton.class; // é€šè¿‡å…¨å±€è®¿é—®ç‚¹æ‹¿åˆ°å•ä¾‹å¯¹è±¡ HungrySingleton instance = HungrySingleton.getInstance(); // è·å–å£°æ˜çš„æ„é€ å™¨ Constructor constructor = objectClass.getDeclaredConstructor(); // å¼ºåˆ¶è®¾ç½®å£°æ˜çš„æ„é€ å™¨æ˜¯å¯ä»¥è®¿é—®çš„ constructor.setAccessible(true); // é€šè¿‡æ„é€ å™¨åå°„åˆ›å»ºå¯¹è±¡ HungrySingleton newInstance = (HungrySingleton) constructor.newInstance(); log.info(\"instance: \" + instance); log.info(\"newInstanceï¼š \" + newInstance); log.info(String.format(\"instance [%s] newInstance\",instance == newInstance)); &#125;catch (Exception e)&#123; log.info(e.getMessage()); &#125; &#125;&#125; ç ´åé¥¿æ±‰å¼å•ä¾‹-æ–¹å¼2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.design.pattern.singleton.serializationdestroysingleton;import java.io.Serializable;/** * HungrySingleton é¥¿æ±‰å¼ * &lt;p&gt; * 1 ä¼˜ç‚¹ * å†™æ³•ç®€å•ï¼Œç±»åŠ è½½ï¼ˆä¸¥æ ¼æ¥è¯´æ˜¯ç±»åŠ è½½è¿‡ç¨‹çš„åˆå§‹åŒ–é˜¶æ®µä»¥åŠè°ƒç”¨æ„é€ å‡½æ•°ï¼‰çš„æ—¶å€™å°±å®Œæˆäº†å¯¹è±¡çš„åˆ›å»ºï¼Œé¿å…äº†çº¿ç¨‹åŒæ­¥é—®é¢˜ * 2 ç¼ºç‚¹ * ç±»åŠ è½½çš„æ—¶å€™å°±å®Œæˆäº†å¯¹è±¡çš„åˆ›å»ºï¼Œæ²¡æœ‰å»¶è¿Ÿæ•ˆæœï¼Œå¦‚æœç±»çš„å¯¹è±¡ä»å§‹è‡³ç»ˆéƒ½æ²¡æœ‰ç”¨è¿‡ï¼Œæˆ–è€…åªæ˜¯æƒ³è·å–ç±»çš„æŸä¸ªç±»å˜é‡ï¼Œé‚£ä¹ˆè¿˜æ˜¯ä¼šåˆ›å»ºå¯¹è±¡ï¼Œè¿™æ— ç–‘é€ æˆäº†å†…å­˜çš„æµªè´¹ * 3 å®ç°Serializableï¼Œä¸ºäº†å®ç°åºåˆ—åŒ– * * @author shunhua * @date 2019-10-03 */public class HungrySingleton implements Serializable &#123; private static final long serialVersionUID = 1136799709809340054L; /** * ç§æœ‰æ„é€ å‡½æ•° */ private HungrySingleton() &#123; &#125; /** * å£°æ˜ä¸ºfinalçš„å˜é‡å¿…é¡»åœ¨ç±»åŠ è½½å®Œæˆæ—¶ï¼ˆå‡†ç¡®çš„æ˜¯ç±»åŠ è½½åˆå§‹åŒ–çš„æ—¶å€™ï¼Œsingletonå°±éœ€è¦è¢«èµ‹å€¼å³HungrySingletonå¯¹è±¡çš„å¼•ç”¨ï¼‰å°±å·²ç»èµ‹å€¼ */ // private final static HungrySingleton singleton = new HungrySingleton(); private final static HungrySingleton singleton; static &#123; singleton = new HungrySingleton(); &#125; /** * å…¨å±€è®¿é—®ç‚¹ * @return */ public static HungrySingleton getInstance() &#123; return singleton; &#125; /** * 1. å¯¹äºä½¿ç”¨åºåˆ—åŒ–å’Œååºåˆ—åŒ–äº§ç”Ÿæ–°çš„å®ä¾‹çš„æ–¹å¼ç ´åäº†å•ä¾‹ï¼Œå¯ä»¥åœ¨ç±»ä¸­å¢åŠ readResolve()æ–¹æ³•æ¥é¢„é˜²ï¼ŒreadResolveï¼ˆï¼‰æ–¹æ³•è¿”å›å•ä¾‹å¯¹è±¡å³å¯ * 2. è¿™æ˜¯ååºåˆ—åŒ–æœºåˆ¶å†³å®šçš„ï¼Œåœ¨ååºåˆ—åŒ–çš„æ—¶å€™ä¼šåˆ¤æ–­ç±»å¦‚æœå®ç°äº†Serializableæˆ–è€…Externalizableæ¥å£åˆåŒ…å«readResolve()æ–¹æ³•çš„è¯ï¼Œä¼šç›´æ¥ * è°ƒç”¨readResolveï¼ˆï¼‰æ–¹æ³•æ¥è·å–å®ä¾‹ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒreadObjectæ–¹æ³•åº•å±‚ä¼šå…ˆé€šè¿‡åå°„åˆ›å»ºä¸€ä¸ªæ–°çš„å•ä¾‹å®ä¾‹ï¼Œç„¶åå†é€šè¿‡åå°„è°ƒç”¨readResolveæ–¹ * æ³•è·å–å•ä¾‹å¯¹è±¡ã€‚å³è™½ç„¶æœ€åé€šè¿‡readResolveæ‹¿åˆ°çš„æ˜¯å·²ç»åˆ›å»ºå¥½çš„å¯¹è±¡ï¼Œä½†æœ¬è´¨ä¸Šè¿˜æ˜¯é€šè¿‡åå°„åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œåªæ˜¯è¿™ä¸ªæ–°çš„å¯¹è±¡æ˜¯ç”¨æ¥è°ƒç”¨readResolveæ–¹æ³• * è¿”å›å•ä¾‹å¯¹è±¡è€Œå·²ã€‚ * * * @return */ public Object readResolve()&#123; return singleton; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.design.pattern.singleton.serializationdestroysingleton;import lombok.extern.slf4j.Slf4j;import java.io.*;/** * HungrySingletonTest * * @author shunhua * @date 2019-10-03 */@Slf4jpublic class HungrySingletonTest &#123; public static void main(String[] args) &#123; HungrySingleton instance = HungrySingleton.getInstance(); try &#123; File file = new File(\"singleton\"); // ä½¿ç”¨ObjectOutputStreamå¯¹è±¡è¾“å‡ºæµï¼ŒæŠŠå•ä¾‹å¯¹è±¡å†™å…¥æ–‡ä»¶ä¸­ã€‚æ³¨æ„æ–‡ä»¶çš„åç¼€åå¸¦ä¸å¸¦éƒ½è¡Œã€‚å¦‚æœä¸æŒ‡å®šæ–‡ä»¶çš„è·¯å¾„ï¼Œå°±é»˜è®¤ä½¿ç”¨å½“å‰å·¥ç¨‹çš„ç›®å½•ä½œä¸ºè·¯å¾„ ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file)); // å°†å•ä¾‹å¯¹è±¡å†™å…¥æ–‡ä»¶ä¸­ objectOutputStream.writeObject(instance); // ä½¿ç”¨ObjectInputStreamå¯¹è±¡è¾“å…¥æµï¼ŒæŠŠæ–‡ä»¶ä¸­çš„å•ä¾‹å¯¹è±¡è¯»åˆ°å†…å­˜ä¸­ ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file)); /** * * å¦‚æœHungrySingletonç±»å®ç°äº†Serializableæˆ–è€…Externalizableæ¥å£ï¼Œé‚£ä¹ˆreadObjectæ–¹æ³•åº•å±‚ä¼šä½¿ç”¨åå°„ï¼Œè°ƒç”¨ObjectStreamClass#newInstanceæ–¹æ³•åˆ›å»ºä¸€ä¸ªæ–°çš„å•ä¾‹å¯¹è±¡, * è¿™ä¸ªå•ä¾‹å¯¹è±¡æ˜¯ä¸ºäº†è°ƒç”¨å®ƒå¯¹åº”çš„ç±»ä¸­çš„readResolveæ–¹æ³•ï¼Œå¦‚æœæ²¡æœ‰å®ç°é‚£ä¸¤ä¸ªæ¥å£ä¸­çš„ä»»ä½•ä¸€ä¸ªå°±ä¼šè¿”å›nullã€‚å³æ¥ç€ä¼šåˆ¤æ–­è¿™ä¸ªæ–°åˆ›å»ºçš„å•ä¾‹å¯¹è±¡ä¸­æœ‰æ²¡æœ‰readResolveæ–¹æ³•ï¼Œå¦‚æœ * æœ‰å°±ä¼šé€šè¿‡åå°„è°ƒç”¨è¿™ä¸ªreadResolveæ–¹æ³•ï¼Œæœ€ç»ˆreadObjectæ–¹æ³•è¿”å›çš„æ˜¯readResolveæ–¹æ³•è¿”å›çš„å¯¹è±¡ * */ HungrySingleton newInstance = (HungrySingleton) objectInputStream.readObject(); log.info(\"instance: \" + instance); log.info(\"newInstance: \" + newInstance); log.info(String.format(\"instance [%s] newInstance\", instance == newInstance)); &#125; catch (Exception e) &#123; &#125; &#125;&#125; é™æ€å†…éƒ¨ç±»çš„å•ä¾‹æ¨¡å¼ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.design.pattern.singleton.staticinnerclass;/** * StaticInnerClassSingleton é™æ€å†…éƒ¨ç±»çš„å•ä¾‹æ¨¡å¼ ï¼Œä½¿ç”¨é™æ€å†…éƒ¨ç±»ä¹Ÿæ˜¯åšå»¶è¿Ÿåˆå§‹åŒ–å•ä¾‹å¯¹è±¡ï¼Œæ¥é™ä½å•ä¾‹å®ä¾‹çš„å¼€é”€å³åœ¨éœ€è¦çš„æ—¶å€™æ‰è¿›è¡Œåˆå§‹åŒ– * * @author shunhua * @date 2019-10-03 */public class StaticInnerClassSingleton &#123; /** * ç§æœ‰æ„é€ å™¨ä¸èƒ½å°‘ï¼Œé˜²æ­¢å¤–éƒ¨åˆ›å»ºå¯¹è±¡ï¼Œè®©å¤–éƒ¨åªèƒ½é€šè¿‡å…¨å±€è®¿é—®ç‚¹æ‹¿åˆ°å•ä¾‹å¯¹è±¡ */ private StaticInnerClassSingleton()&#123;&#125; /** * 1. è¿™ä¸ªé™æ€å†…éƒ¨ç±»è¦å£°æ˜ä¸ºç§æœ‰çš„ï¼Œå› ä¸ºåˆ›å»ºå¯¹è±¡åœ¨å®ƒé‡Œé¢ï¼Œä¸èƒ½è®©å¤–é¢è®¿é—®å®ƒ * 2. å¦‚æœç±»æ²¡æœ‰åˆå§‹åŒ–ï¼Œéœ€è¦ç±»ç«‹å³åˆå§‹åŒ–çš„å¸¸è§æƒ…å†µï¼š * ï¼ˆ1ï¼‰new ä¸€ä¸ªå¯¹è±¡ * ï¼ˆ2ï¼‰ç±»ä¸­å£°æ˜çš„é™æ€æ–¹æ³•è¢«è°ƒç”¨ * ï¼ˆ3ï¼‰ç±»ä¸­å£°æ˜çš„ä¸€ä¸ªé™æ€æˆå‘˜è¢«èµ‹å€¼ * ï¼ˆ4ï¼‰ç±»ä¸­å£°æ˜çš„ä¸€ä¸ªé™æ€æˆå‘˜è¢«ä½¿ç”¨ï¼Œå¹¶ä¸”è¿™ä¸ªæˆå‘˜ä¸æ˜¯ä¸€ä¸ªå¸¸é‡ï¼ˆè¢«finalä¿®é¥°ï¼Œå·²åœ¨ç¼–è¯‘æœŸæŠŠç»“æœæ”¾å…¥å¸¸é‡æ± ä¸­çš„é™æ€å­—æ®µï¼‰ * ï¼ˆ5ï¼‰å¯¹ç±»è¿›è¡Œåå°„è°ƒç”¨ * ï¼ˆ6ï¼‰ä½œä¸ºçˆ¶ç±»ï¼ˆåŒ…æ‹¬æ¥å£ï¼‰ï¼Œå…¶å­ç±»è¢«åˆå§‹åŒ–äº†ï¼Œé‚£ä¹ˆçˆ¶ç±»éœ€è¦å…ˆåˆå§‹åŒ– * ï¼ˆ7ï¼‰æ‰§è¡Œçš„ä¸»ç±»ï¼ˆåŒ…å«mainæ–¹æ³•çš„ç±»ï¼‰ * * 3.ä½¿ç”¨é™æ€å†…éƒ¨ç±»åˆ›å»ºå•ä¾‹å¯¹è±¡åˆ©ç”¨äº†ç±»åŠ è½½è¿‡ç¨‹ä¸­çš„åˆå§‹åŒ–é˜¶æ®µçš„ç‰¹æ€§ï¼š * è™šæ‹Ÿæœºä¼šä¿è¯ä¸€ä¸ªç±»çš„ç±»æ„é€ å™¨&lt;clinit&gt;æ–¹æ³•åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­è¢«æ­£ç¡®åœ°åŠ ç±»çš„å¯¹è±¡åˆå§‹åŒ–é”ï¼ˆè¿™æ˜¯JVMå¸®æˆ‘ä»¬è‡ªåŠ¨å®Œæˆçš„ï¼‰ã€åŒæ­¥ï¼Œå¦‚æœå¤šä¸ªçº¿ç¨‹åŒæ—¶å»åˆå§‹åŒ–ä¸€ä¸ªç±»ï¼Œ * é‚£ä¹ˆåªä¼šæœ‰ä¸€ä¸ªçº¿ç¨‹å»æ‰§è¡Œè¿™ä¸ªç±»çš„ç±»æ„é€ å™¨æ–¹æ³•&lt;clinit&gt;ï¼Œå…¶ä»–çº¿ç¨‹éƒ½éœ€è¦é˜»å¡ç­‰å¾…ï¼Œç›´åˆ°æ´»åŠ¨çº¿ç¨‹æ‰§è¡Œ&lt;clinit&gt;æ–¹æ³•å®Œæ¯•ã€‚ * å› æ­¤ï¼Œå³ä½¿åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹æ‰§è¡Œ private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton()è¯­å¥ * ä¹Ÿä¸éœ€è¦å…³å¿ƒæŒ‡ä»¤é‡æ’åºçš„æƒ…å†µï¼Œå› ä¸ºåˆå§‹åŒ–é˜¶æ®µåœ¨å¯¹ç±»å˜é‡èµ‹å€¼çš„æ—¶å€™åªä¼šæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥æ‰§è¡Œ&lt;clinit&gt;æ–¹æ³•ï¼Œè€Œå•çº¿ç¨‹æ‰§è¡Œçš„æƒ…å†µä¸‹ï¼ŒæŒ‡ä»¤æ˜¯å¦é‡æ’åºæ˜¯æ²¡æœ‰å½±å“çš„ã€‚ */ private static class InnerClass &#123; /** * 1. åˆå§‹åŒ–æ—¶ï¼Œéœ€è¦staticInnerClassSingletonèµ‹å€¼ï¼Œå³ new StaticInnerClassSingleton()ä¼šè¢«æ‰§è¡Œã€‚è¿™äº›éƒ½æ˜¯&lt;clinit&gt;æ–¹æ³•æ‰§è¡Œçš„ç»“æœï¼Œè€Œ&lt;clinit&gt;æ–¹æ³•åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹åªä¼šæœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œï¼Œå³ä½¿è¿™ä¸ªæ–¹æ³•å†…éƒ¨æ¶‰åŠé‡æ’åºä¹Ÿå…³ç³»ã€‚ * 2. æ´»è·ƒçº¿ç¨‹åˆå§‹åŒ–ç±»ï¼ˆæ‰§è¡Œ&lt;clinit&gt;æ–¹æ³•ï¼‰å,ç±»å·²ç»åˆå§‹åŒ–å®Œæˆï¼Œä¸ä¼šå†è¿›è¡Œåˆå§‹åŒ–ï¼Œå…¶ä»–çº¿ç¨‹ç›´æ¥è®¿é—®ç±»æˆå‘˜å³å¯ */ private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton(); &#125; /** * å…¨å±€è®¿é—®ç‚¹ * * å½“æ‰§è¡ŒgetInstanceæ–¹æ³•æ—¶å°±å»è°ƒç”¨InnerClasså†…éƒ¨ç±»é‡Œé¢çš„staticInnerClassSingletonå®ä¾‹ï¼Œæ­¤æ—¶InnerClasså†…éƒ¨ç±»ä¼šè¢«åŠ è½½åˆ°å†…å­˜é‡Œï¼Œåœ¨ç±»åŠ è½½çš„æ—¶å€™å°±åˆ›å»ºå¯¹è±¡ï¼Œå’Œé¥¿æ±‰å¼ä¸€ä¸ªé“ç†ï¼Œä¿è¯äº†åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œ * è€Œä¸”åœ¨è°ƒç”¨getInstanceæ–¹æ³•æ—¶æ‰è¿›è¡Œå•ä¾‹çš„åˆ›å»ºï¼Œåˆå…·æœ‰æ‡’æ±‰å¼çš„éƒ¨åˆ†ç‰¹æ€§ã€‚ * @return */ public static StaticInnerClassSingleton getInstance() &#123; /** * å¤–éƒ¨è®¿é—®getInstanceè¿™ä¸ªå…¨å±€è®¿é—®ç‚¹æ—¶ï¼Œä¼šé—´æ¥è®¿é—®InnerClassçš„é™æ€æˆå‘˜ï¼Œè¿™ä¼šå¯¼è‡´é™æ€å†…éƒ¨ç±»è¢«åˆå§‹åŒ– */ return InnerClass.staticInnerClassSingleton; &#125;&#125; å•ä¾‹æ¨¡å¼åœ¨æºç ä¸­çš„ä½¿ç”¨jdk-RunTime 12345678910111213141516171819202122232425262728293031package java.lang;import java.io.*;import java.util.StringTokenizer;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;/** * Every Java application has a single instance of class * &lt;code&gt;Runtime&lt;/code&gt; that allows the application to interface with * the environment in which the application is running. The current * runtime can be obtained from the &lt;code&gt;getRuntime&lt;/code&gt; method. * &lt;p&gt; * An application cannot create its own instance of this class. * * @author unascribed * @see java.lang.Runtime#getRuntime() * @since JDK1.0 */public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() &#123; return currentRuntime; &#125; private Runtime() &#123;&#125; // ... çœç•¥å…¶ä»–æ–¹æ³•&#125; Spring-AbstractFactoryBean 12345678910111213141516171819202122232425262728@Overridepublic final T getObject() throws Exception &#123; if (isSingleton()) &#123; return (this.initialized ? this.singletonInstance : getEarlySingletonInstance()); &#125; else &#123; return createInstance(); &#125;&#125;/** * Determine an 'early singleton' instance, exposed in case of a * circular reference. Not called in a non-circular scenario. */@SuppressWarnings(\"unchecked\")private T getEarlySingletonInstance() throws Exception &#123; Class&lt;?&gt;[] ifcs = getEarlySingletonInterfaces(); if (ifcs == null) &#123; throw new FactoryBeanNotInitializedException( getClass().getName() + \" does not support circular references\"); &#125; if (this.earlySingletonInstance == null) &#123; this.earlySingletonInstance = (T) Proxy.newProxyInstance( this.beanClassLoader, ifcs, new EarlySingletonInvocationHandler()); &#125; return this.earlySingletonInstance;&#125; MyBatis-ErrorContext 12345678910111213141516171819202122232425262728293031323334public class ErrorContext &#123; private static final String LINE_SEPARATOR = System.getProperty(\"line.separator\",\"\\n\"); // åŸºäºThreadLocalçš„å•ä¾‹æ¨¡å¼ï¼Œå®ƒä¸æ˜¯æ•´ä¸ªåº”ç”¨å…¨å±€å”¯ä¸€è€Œæ˜¯çº¿ç¨‹çº§åˆ«å”¯ä¸€ï¼Œä¿è¯äº†æ¯ä¸ªçº¿ç¨‹å„è‡ªçš„é”™è¯¯ä¸Šä¸‹æ–‡ private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal&lt;&gt;(); private ErrorContext stored; private String resource; private String activity; private String object; private String message; private String sql; private Throwable cause; /** * ç§æœ‰æ„é€ å™¨ */ private ErrorContext() &#123; &#125; /** * æ¯ä¸ªçº¿ç¨‹è·å–å„è‡ªçš„å¯¹è±¡ * @return */ public static ErrorContext instance() &#123; ErrorContext context = LOCAL.get(); if (context == null) &#123; context = new ErrorContext(); LOCAL.set(context); &#125; return context; &#125; // ... ç­‰ç­‰&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"ç­–ç•¥æ¨¡å¼","slug":"design_pattern/behaviour_type/ç­–ç•¥æ¨¡å¼","date":"2019-09-27T16:00:00.000Z","updated":"2020-08-09T09:28:54.518Z","comments":true,"path":"posts/72e3b671/","link":"","permalink":"https://gentryhuang.com/posts/72e3b671/","excerpt":"","text":"å®šä¹‰å®šä¹‰äº†ç®—æ³•å®¶æ—ï¼Œåˆ†åˆ«å°è£…èµ·æ¥ï¼Œè®©å®ƒä»¬ä¹‹é—´å¯ä»¥äº’ç›¸æ›¿æ¢ï¼Œæ­¤æ¨¡å¼è®©ç®—æ³•çš„å˜åŒ–ä¸ä¼šå½±å“åˆ°ä½¿ç”¨ç®—æ³•çš„ç”¨æˆ·ã€‚å³æŠŠä¸åŒçš„ç®—æ³•å°è£…åˆ°ä¸åŒçš„ç±»é‡Œé¢ï¼Œè®©å®ƒä»¬ä¹‹é—´å¯ä»¥ç›¸äº’æ›¿æ¢ï¼Œ åº”ç”¨å±‚ä¸ä¼šå—åˆ°å½±å“ã€‚ ç±»å‹è¡Œä¸ºå‹ ä½¿ç”¨åœºæ™¯12341 ç³»ç»Ÿæœ‰å¾ˆå¤šç±»ï¼Œè€Œä»–ä»¬çš„åŒºåˆ«ä»…ä»…åœ¨äºå®ƒä»¬çš„è¡Œä¸ºä¸åŒ - ä½¿ç”¨ç­–ç•¥æ¨¡å¼å°±å¯ä»¥åŠ¨æ€åœ°è®©ä¸€ä¸ªå¯¹è±¡åœ¨å¤šä¸ªè¡Œä¸ºä¸­é€‰æ‹©ä¸€ç§è¡Œä¸ºï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬æŠŠè¿™ä¸ªå¯¹è±¡ä¸åŒçš„è¡Œä¸ºæ”¾åˆ°ä¸åŒçš„ç±»é‡Œé¢ï¼Œè€Œæ¯ä¸€ç§è¡Œä¸ºå¯¹åº”ç€ä¸€ç§ç­–ç•¥2 ä¸€ä¸ªç³»ç»Ÿéœ€è¦åŠ¨æ€åœ°åœ¨å‡ ç§ç®—æ³•ä¸­é€‰æ‹©ä¸€ç§ - è¿™é‡Œç®—æ³•å°±æ˜¯ç­–ç•¥ï¼Œç­–ç•¥é‡Œé¢å°è£…çš„å°±æ˜¯ä¸€ç³»åˆ—é€»è¾‘ä»¥åŠè®¡ç®—æ–¹å¼ ä¼˜ç‚¹1234561 ç¬¦åˆå¼€é—­åŸåˆ™ - ç­–ç•¥æ¨¡å¼æä¾›äº†å¯¹å¼€é—­åŸåˆ™çš„å®Œç¾æ”¯æŒï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸ä¿®æ”¹åŸæœ‰ç³»ç»Ÿçš„åŸºç¡€ä¸Šé€‰æ‹©å…·ä½“çš„è¡Œä¸º2 é¿å…ä½¿ç”¨å¤šé‡æ¡ä»¶è½¬ç§»è¯­å¥ - å¤§é‡çš„if...else, switchã€‚ æˆ‘ä»¬æŠŠå…·ä½“çš„ç­–ç•¥è¡Œä¸ºåˆ†ç¦»ä¸ºä¸€ä¸ªä¸€ä¸ªçš„å•ç‹¬çš„ç±»æ¥æ›¿æ¢if...elseé‡Œé¢çš„é€»è¾‘ï¼Œè¿™æ ·å†™ä¹Ÿå¯ä»¥é™ä½ä»£ç çš„è€¦åˆ3 æé«˜ç®—æ³•çš„ä¿å¯†æ€§å’Œå®‰å…¨æ€§ - åœ¨ä½¿ç”¨çš„æ—¶å€™æˆ‘ä»¬åªçŸ¥é“ç­–ç•¥çš„åŠŸèƒ½ï¼Œä¸éœ€è¦çŸ¥é“å…·ä½“çš„ç»†èŠ‚ã€‚åœ¨å…·ä½“çš„ç­–ç•¥ç±»ä¸­å°è£…äº†ä¸åŒçš„è¡Œä¸ºå’Œç®—æ³•ä»¥åŠç›¸å…³çš„æ•°æ®ç»“æ„ï¼Œå¯¹äºåº”ç”¨å±‚æ¥è¯´ï¼Œæ˜¯ä¸éœ€è¦çŸ¥é“å†…éƒ¨çš„ç»†èŠ‚çš„ã€‚æ¯”å¦‚ä½¿ç”¨Dubboçš„æœåŠ¡æä¾›è€…ï¼Œä¸éœ€è¦çŸ¥é“å†…éƒ¨é€»è¾‘çš„ç»†èŠ‚ã€‚ ç¼ºç‚¹121 åº”ç”¨å±‚å¿…é¡»çŸ¥é“æ‰€æœ‰çš„ç­–ç•¥ç±»ï¼Œå¹¶è‡ªè¡Œå†³å®šä½¿ç”¨å“ªä¸€ä¸ªç­–ç•¥ç±»2 äº§ç”Ÿå¾ˆå¤šç­–ç•¥ç±» ç­–ç•¥æ¨¡å¼ç›¸å…³çš„è®¾è®¡æ¨¡å¼ç­–ç•¥æ¨¡å¼å’Œå·¥å‚æ¨¡å¼ 121 å·¥å‚æ¨¡å¼æ˜¯åˆ›å»ºå‹çš„è®¾è®¡æ¨¡å¼ï¼Œç­–ç•¥æ¨¡å¼æ˜¯è¡Œä¸ºå‹çš„è®¾è®¡æ¨¡å¼2 å·¥å‚æ¨¡å¼æ¥å—æŒ‡ä»¤ï¼Œåˆ›å»ºç¬¦åˆè¦æ±‚çš„å¯¹è±¡ã€‚ç­–ç•¥æ¨¡å¼æ¥å—åˆ›å»ºå¥½çš„å¯¹è±¡ï¼Œä»è€Œå®ç°ä¸åŒçš„è¡Œä¸º ç­–ç•¥æ¨¡å¼å’ŒçŠ¶æ€æ¨¡å¼ 121 ä½¿ç”¨ç­–ç•¥æ¨¡å¼çš„æ—¶å€™ï¼Œåº”ç”¨å±‚éœ€è¦çŸ¥é“åº”è¯¥é€‰æ‹©å“ªä¸€ç§ç­–ç•¥ã€‚åœ¨ä½¿ç”¨çŠ¶æ€æ¨¡å¼çš„æ—¶å€™ï¼Œåº”ç”¨å±‚æ˜¯ä¸éœ€è¦å…³å¿ƒå…·ä½“çš„çŠ¶æ€ï¼Œè¿™äº›çŠ¶æ€ä¼šè‡ªåŠ¨è½¬æ¢2 å¦‚æœç³»ç»Ÿä¸­æŸä¸ªç±»çš„å¯¹è±¡å­˜åœ¨å¤šç§çŠ¶æ€ï¼Œä¸åŒçŠ¶æ€ä¸‹è¡Œä¸ºåˆæœ‰å·®å¼‚ï¼Œè€Œä¸”è¿™äº›çŠ¶æ€å¯ä»¥å‘ç”Ÿè½¬æ¢æ—¶å¯ä»¥ä½¿ç”¨çŠ¶æ€æ¨¡å¼ã€‚å¦‚æœç³»ç»Ÿä¸­æŸä¸ªç±»çš„æŸç§è¡Œä¸ºå­˜åœ¨å¤šç§å®ç°æ–¹å¼ï¼Œå¦‚ä¿ƒé”€æ˜¯ä¸ªè¡Œä¸ºï¼Œè¿™ç§è¡Œä¸ºå°±æœ‰å¤šç§å®ç°æ–¹å¼ï¼Œè¿™ç§æƒ…å†µä¸‹åº”è¯¥ä½¿ç”¨ç­–ç•¥æ¨¡å¼ã€‚ ç®€å•éœ€æ±‚å½“å½“ç½‘åœ¨åŒåä¸€æˆ–è€…618çš„æ—¶å€™ä¼šæœ‰å¾ˆå¤šçš„ä¿ƒé”€æ´»åŠ¨ï¼Œä¿ƒé”€æ˜¯ä¹¦ç±çš„ä¸€ä¸ªè¡Œä¸ºï¼Œè¿™ä¸ªä¿ƒé”€è¡Œä¸ºæœ‰å¤šç§å®ç°ã€‚ ç­–ç•¥æ¨¡å¼æ¼”ç»ƒæœ€åŸºæœ¬çš„ä½¿ç”¨ ç­–ç•¥çˆ¶ç±»å‹ï¼ˆè¿™é‡Œæ˜¯æ¥å£çš„æ–¹å¼ï¼‰ 12345678910111213package com.design.pattern.strategy.base;/** * PromotionStrategy ä¿ƒé”€ç­–ç•¥çˆ¶ç±»å‹ * @author shunhua * @date 2019-09-28 */public interface PromotionStrategy &#123; /** * è¿›è¡Œä¿ƒé”€ */ void doPromotion();&#125; å…·ä½“ç­–ç•¥å®ä¾‹ å‘ç°ç­–ç•¥ 123456789101112131415161718192021package com.design.pattern.strategy.base;import lombok.extern.slf4j.Slf4j;/** * FanXianPromotionStrategy è¿”ç°ï¼ˆæ”¯ä»˜é‡‘é¢è¾¾åˆ°ä¸€å®šæ•°é¢è¿›è¡Œè¿”ç°åˆ°è´¦å·ï¼‰ç­–ç•¥ * * @author shunhua * @date 2019-09-28 */@Slf4jpublic class FanXianPromotionStrategy implements PromotionStrategy &#123; /** * ä¿ƒé”€ */ @Override public void doPromotion() &#123; log.info(\"è¿”ç°ä¿ƒé”€ï¼Œè¿”å›çš„é‡‘é¢å­˜æ”¾åˆ°è´¦å·çš„ä½™é¢ä¸­\"); &#125;&#125; ç«‹å‡ä¼˜æƒ ç­–ç•¥ 123456789101112131415161718192021package com.design.pattern.strategy.base;import lombok.extern.slf4j.Slf4j;/** * LiJianPromotionStrategy ç«‹å‡ï¼ˆä¸‹å•ç«‹å‡ä¸€å®šçš„é‡‘é¢ï¼‰ç­–ç•¥ * * @author shunhua * @date 2019-09-28 */@Slf4jpublic class LiJianPromotionStrategy implements PromotionStrategy &#123; /** * ä¿ƒé”€ */ @Override public void doPromotion() &#123; log.info(\"ç«‹å‡ä¿ƒé”€ï¼Œä¹¦ç±çš„ä»·æ ¼ç›´æ¥å‡å»ç«‹å‡æ´»åŠ¨è®¾ç½®çš„ä»·æ ¼\"); &#125;&#125; æ»¡å‡ç­–ç•¥ 123456789101112131415161718192021package com.design.pattern.strategy.base;import lombok.extern.slf4j.Slf4j;/** * ManJianPromotionStrategy æ»¡å‡ï¼ˆå½“æ”¯ä»˜é‡‘é¢è¾¾åˆ°è§„å®šçš„æœ€ä½æ•°å°±è¿›è¡Œä¼˜æƒ ï¼‰ç­–ç•¥ * * @author shunhua * @date 2019-09-28 */@Slf4jpublic class ManJianPromotionStrategy implements PromotionStrategy &#123; /** * ä¿ƒé”€ */ @Override public void doPromotion() &#123; log.info(\"æ»¡å‡ä¿ƒé”€ï¼Œæ»¡200å‡50\"); &#125;&#125; ç­–ç•¥åŒ…è£…ç±» 1234567891011121314151617181920212223242526package com.design.pattern.strategy.base;/** * PromotionActivity ä¿ƒé”€æ´»åŠ¨ï¼ŒåŒ…è£…ï¼ˆä½¿ç”¨ï¼‰ç­–ç•¥æ¨¡å¼ * * @author shunhua * @date 2019-09-28 */public class PromotionActivity &#123; /** * ä¿ƒé”€ç­–ç•¥ */ private PromotionStrategy promotionStrategy; public PromotionActivity(PromotionStrategy promotionStrategy)&#123; this.promotionStrategy = promotionStrategy; &#125; /** * æ‰§è¡Œå…·ä½“çš„ä¿ƒé”€ç­–ç•¥ */ public void execute()&#123; promotionStrategy.doPromotion(); &#125;&#125; åº”ç”¨å±‚ 12345678910111213141516171819202122232425262728293031package com.design.pattern.strategy.base;import com.design.pattern.strategy.base.FanXianPromotionStrategy;import com.design.pattern.strategy.base.ManJianPromotionStrategy;import com.design.pattern.strategy.base.PromotionActivity;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-28 */public class Client &#123; @Test public void test()&#123; /** * 618æ»¡å‡æ´»åŠ¨ç­–ç•¥ */ PromotionActivity activity618 = new PromotionActivity(new ManJianPromotionStrategy()); /** * åŒ11 è¿”ç°æ´»åŠ¨ç­–ç•¥ */ PromotionActivity activity11 = new PromotionActivity(new FanXianPromotionStrategy()); activity618.execute(); activity11.execute(); &#125;&#125; å°ç»“ 1è¿™æ˜¯ç­–ç•¥æ¨¡å¼çš„ç®€å•ä½¿ç”¨ï¼Œæ•´ä½“ä¸Šæ‰©å±•æ€§æ¯”è¾ƒå¥½ï¼Œæƒ³å¢åŠ ç­–ç•¥å¾ˆæ–¹ä¾¿ã€‚ åŸºæœ¬ä½¿ç”¨æ¼”è¿›åº”ç”¨å±‚ 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.strategy.v1;import org.junit.Test;import org.springframework.util.ObjectUtils;/** * Client * * @author shunhua * @date 2019-09-28 */public class Client &#123; @Test public void test()&#123; PromotionActivity activity ; // åº”ç”¨å±‚å‚æ•° String promotion = \"FANXIAN\"; switch (promotion)&#123; case \"FANXIAN\" : activity = new PromotionActivity(new FanXianPromotionStrategy()); break; case \"LIJIAN\": activity = new PromotionActivity(new LiJianPromotionStrategy()); break; case \"MANJIAN\": activity = new PromotionActivity(new ManJianPromotionStrategy()); break; default: activity = null; &#125; if(!ObjectUtils.isEmpty(activity))&#123; activity.execute(); &#125; &#125;&#125; å°ç»“ 12è¿™ç§æ–¹å¼å’Œåº”ç”¨äº¤äº’å®¹æ˜“ä½¿ä»£ç è¿‡äºè‡ƒè‚¿ï¼Œå› ä¸ºæ¯æ¬¡éœ€è¦çš„æ—¶å€™éƒ½ä¼šåˆ›å»ºç­–ç•¥å¯¹è±¡å’ŒåŒ…è£…ç­–ç•¥çš„å¯¹è±¡ï¼Œå¹¶ä¸”è¿‡å¤šçš„é€‰æ‹©åˆ¤æ–­ï¼Œæ•´ä¸ªä»£ç çœ‹èµ·æ¥ä¸ä¼˜é›…ã€‚ ä¼˜åŒ–åç‰ˆæœ¬ç­–ç•¥å·¥å‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.design.pattern.strategy.v2;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * PromotionStrategyFactory ä¿ƒé”€ç­–ç•¥å·¥å‚ * * @author shunhua * @date 2019-09-28 */public class PromotionStrategyFactory &#123; /** * ç­–ç•¥é›†åˆ */ private final static Map&lt;String,PromotionStrategy&gt; PROMOTION_STRATEGY_MAP = new ConcurrentHashMap&lt;&gt;(); /** * ç±»åŠ è½½çš„æ—¶å€™å°±å¼€å§‹åˆ›å»ºå¯¹è±¡ */ static &#123; PROMOTION_STRATEGY_MAP.put(PromotionKey.LIJIAN_STRATEGY,new LiJianPromotionStrategy()); PROMOTION_STRATEGY_MAP.put(PromotionKey.FANXIAN_STRATEGY,new FanXianPromotionStrategy()); PROMOTION_STRATEGY_MAP.put(PromotionKey.MANJIAN_STRATEGY,new ManJianPromotionStrategy()); &#125; /** * å•ä¾‹çš„ */ private PromotionStrategyFactory()&#123;&#125; /** * æ ¹æ®ç­–ç•¥æ¨¡å¼åè·å–å¯¹åº”çš„ç­–ç•¥ * @param strategy * @return */ public static PromotionStrategy getPromotionStrategy(String strategy)&#123; return PROMOTION_STRATEGY_MAP.get(strategy); &#125; private interface PromotionKey&#123; /** * ç«‹å‡ç­–ç•¥ */ String LIJIAN_STRATEGY = \"LIJIAN\"; /** * æ»¡å‡ç­–ç•¥ */ String MANJIAN_STRATEGY = \"LIJIAN\"; /** * è¿”ç°ç­–ç•¥ */ String FANXIAN_STRATEGY = \"FANXIAN\"; &#125;&#125; åº”ç”¨å±‚ 123456789101112131415161718192021222324package com.design.pattern.strategy.v2;import org.junit.Test;import org.springframework.util.ObjectUtils;/** * Client * * @author shunhua * @date 2019-09-28 */public class Client &#123; @Test public void test()&#123; // åº”ç”¨å±‚å‚æ•° String promotion = \"FANXIAN\"; // ä½¿ç”¨å·¥å‚æ¨¡å¼ PromotionActivity activity = new PromotionActivity(PromotionStrategyFactory.getPromotionStrategy(promotion)); if(!ObjectUtils.isEmpty(activity))&#123; activity.execute(); &#125; &#125;&#125; å°ç»“ 121. ä½¿ç”¨ç­–ç•¥å·¥å‚é˜²æ­¢ç­–ç•¥å¯¹è±¡é¢‘ç¹åˆ›å»º2. ç­–ç•¥æ¨¡å¼å¸¸å¸¸ç»“åˆå•ä¾‹ã€å·¥å‚ä»¥åŠäº«å…ƒæ¨¡å¼ç­‰ä½¿ç”¨ ç­–ç•¥æ¨¡å¼æºç è§£æjdkçš„Comparator 1Comparatorå°±æ˜¯ä¸€ä¸ªæ¯”è¾ƒç­–ç•¥æ¥å£ï¼Œå®ƒæœ‰å¾ˆå¤šçš„å®ç°ï¼Œä¹Ÿæ”¯æŒè‡ªå®šä¹‰ç­–ç•¥ï¼Œè¿™äº›ç­–ç•¥å®ç°å°±æ˜¯ä¸€ä¸ªä¸ªç­–ç•¥ã€‚ 12345678910111213141516171819 /** * æ’åºä¼šæ ¹æ®å…·ä½“çš„æ’åºç­–ç•¥æ‰§è¡Œ * @since 1.8 */@SuppressWarnings(\"unchecked\")public static &lt;T&gt; void parallelSort(T[] a, Comparator&lt;? super T&gt; cmp) &#123; if (cmp == null) cmp = NaturalOrder.INSTANCE; int n = a.length, p, g; if (n &lt;= MIN_ARRAY_SORT_GRAN || (p = ForkJoinPool.getCommonPoolParallelism()) == 1) TimSort.sort(a, 0, n, cmp, null, 0, 0); else new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt; (null, a, (T[])Array.newInstance(a.getClass().getComponentType(), n), 0, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ? MIN_ARRAY_SORT_GRAN : g, cmp).invoke(); &#125; Springçš„Resource 1Resourceæ˜¯èµ„æºè®¿é—®æ¥å£ï¼Œå®ƒå°±æ˜¯ä¸€ä¸ªèµ„æºè®¿é—®ç›¸å…³çš„ç­–ç•¥æ¥å£ï¼Œå®ƒæœ‰å¾ˆå¤šçš„å®ç°ç±»ï¼Œä¹Ÿå°±æ„å‘³ç€æœ‰å¾ˆå¤šè®¿é—®èµ„æºçš„ç­–ç•¥ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.springframework.core.io;import java.io.File;import java.io.IOException;import java.net.URI;import java.net.URL;import java.nio.channels.Channels;import java.nio.channels.ReadableByteChannel;import org.springframework.lang.Nullable;public interface Resource extends InputStreamSource &#123; boolean exists(); default boolean isReadable() &#123; return this.exists(); &#125; default boolean isOpen() &#123; return false; &#125; default boolean isFile() &#123; return false; &#125; URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; default ReadableByteChannel readableChannel() throws IOException &#123; return Channels.newChannel(this.getInputStream()); &#125; long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String var1) throws IOException; @Nullable String getFilename(); String getDescription();&#125; Springçš„InstantiationStrategy 1Springåˆå§‹åŒ–ç­–ç•¥æ¥å£ï¼Œå®ƒçš„å®ç°ç±»ï¼šSimpleInstantiationStrategyå’ŒCglibSubclassingInstantiationStrategyåˆå§‹åŒ–ç­–ç•¥","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"æ¨¡ç‰ˆæ–¹æ³•æ¨¡å¼","slug":"design_pattern/behaviour_type/æ¨¡ç‰ˆæ–¹æ³•æ¨¡å¼","date":"2019-09-26T16:00:00.000Z","updated":"2020-08-09T09:27:55.252Z","comments":true,"path":"posts/5029c2a3/","link":"","permalink":"https://gentryhuang.com/posts/5029c2a3/","excerpt":"","text":"å®šä¹‰å®šä¹‰äº†ä¸€ä¸ªç®—æ³•çš„éª¨æ¶ï¼Œå¹¶å…è®¸å­ç±»ä¸ºä¸€ä¸ªæˆ–å¤šä¸ªæ­¥éª¤æä¾›å®ç°ã€‚æ¨¡ç‰ˆæ–¹æ³•ä½¿å¾—å­ç±»å¯ä»¥åœ¨ä¸æ”¹å˜ç®—æ³•ç»“æ„çš„æƒ…å†µä¸‹ï¼Œé‡æ–°å®šä¹‰ç®—æ³•çš„æŸäº›æ­¥éª¤ã€‚ ç±»å‹è¡Œä¸ºå‹ ä½¿ç”¨åœºæ™¯12â—† å„å­ç±»ä¸­å…¬å…±çš„è¡Œä¸ºè¢«æå–å‡ºæ¥å¹¶é›†ä¸­åˆ°ä¸€ä¸ªå…¬å…±çˆ¶ç±»ä¸­ï¼Œä»è€Œé¿å…ä»£ç é‡å¤â—† ä¸€æ¬¡æ€§å®ç°ä¸€ä¸ªç®—æ³•çš„ä¸å˜çš„éƒ¨åˆ†ï¼Œå¹¶å°†å¯å˜çš„è¡Œä¸ºç•™ç»™å­ç±»æ¥å®ç° ä¼˜ç‚¹123â—†æé«˜å¤ç”¨æ€§ï¼ˆå°†ç›¸åŒä»£ç éƒ¨åˆ†æ”¾åˆ°æŠ½è±¡çˆ¶ç±»ä¸­ï¼‰â—†æé«˜æ‰©å±•æ€§â—†ç¬¦åˆå¼€é—­åŸåˆ™ ç¼ºç‚¹123â—†ç»§æ‰¿å…³ç³»è‡ªèº«ç¼ºç‚¹ï¼Œå¦‚æœçˆ¶ç±»æ·»åŠ æ–°çš„æŠ½è±¡æ–¹æ³•ï¼Œæ‰€æœ‰å­ç±»éƒ½è¦æ”¹ä¸€éâ—†ç±»æ•°ç›®å¢åŠ â—†å¢åŠ äº†ç³»ç»Ÿå®ç°çš„å¤æ‚åº¦ æ¨¡ç‰ˆæ–¹æ³•æ‰©å±• æ¨¡ç‰ˆæ–¹æ³•ä¸­æœ‰ä¸€ä¸ªå®šä¹‰ï¼šé’©å­æ–¹æ³•ã€‚å®ƒæä¾›äº†ç¼ºçœçš„è¡Œä¸ºï¼Œå­ç±»å¯ä»¥åœ¨å¿…è¦æ—¶è¿›è¡Œæ‰©å±•ï¼Œåˆ©ç”¨å®ƒå’Œçˆ¶ç±»äº¤äº’ã€‚å³æ„é€ æ–¹æ³•æ˜¯è¿™ä¸ªæ¨¡ç‰ˆå¯¹å­ç±»æ›´è¿›ä¸€æ­¥çš„å¼€æ”¾ä»¥åŠæ‰©å±•ã€‚ ç›¸å…³çš„è®¾è®¡æ¨¡å¼æ¨¡ç‰ˆæ–¹æ³•æ¨¡å¼å’Œå·¥å‚æ–¹æ³•æ¨¡å¼ å·¥å‚æ–¹æ³•æ˜¯æ¨¡ç‰ˆæ–¹æ³•çš„ä¸€ç§ç‰¹æ®Šå®ç° æ¨¡ç‰ˆæ–¹æ³•æ¨¡å¼å’Œç­–ç•¥æ¨¡å¼ æ¨¡ç‰ˆæ–¹æ³•æ¨¡å¼ä¸æ”¹å˜ç®—æ³•æµç¨‹ï¼Œç­–ç•¥æ¨¡å¼å¯ä»¥æ”¹å˜ç®—æ³•æµç¨‹ï¼Œå¹¶ä¸”ç­–ç•¥æ–¹æ³•ä¹‹é—´æ˜¯å¯ä»¥ç›¸äº’æ›¿æ¢çš„ã€‚ç­–ç•¥æ¨¡å¼çš„ç›®çš„æ˜¯ä½¿ä¸åŒçš„ç®—æ³•å¯ä»¥ç›¸äº’æ›¿æ¢ï¼Œå¹¶ä¸”ä¸å½±å“åº”ç”¨å±‚å®¢æˆ·ç«¯çš„ä½¿ç”¨ã€‚æ¨¡æ¿æ–¹æ³•æ¨¡å¼æ˜¯é’ˆå¯¹å®šä¹‰ä¸€ä¸ªç®—æ³•çš„æµç¨‹ï¼Œå°†ä¸€äº›ä¸å¤ªä¸€æ ·çš„å…·ä½“æ­¥éª¤äº¤ç»™å­ç±»å»å®ç°ã€‚ ç®€å•éœ€æ±‚æŸæœºæ„è¦åˆ¶ä½œä¸€é—¨è¯¾ç¨‹ï¼Œåˆ¶ä½œè¿™ä¸ªè¯¾ç¨‹éœ€è¦ä¸€å®šçš„æ­¥éª¤ï¼Œç”±äºè¯¾ç¨‹çš„ç§ç±»ä¸åŒå¯èƒ½æŸä¸ªæ­¥éª¤ä¸åŒï¼Œä½†æ˜¯æ•´ä½“æ­¥éª¤éƒ½æ˜¯ä¸€è‡´çš„ã€‚ æ¨¡ç‰ˆæ–¹æ³•æ¼”ç»ƒ æŠ½è±¡è¯¾ç¨‹ç±» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.design.pattern.template;import lombok.extern.slf4j.Slf4j;/** * Course è¯¾ç¨‹æŠ½è±¡ç±» * * @author shunhua * @date 2019-09-27 */@Slf4jpublic abstract class Course &#123; /** * æ¨¡ç‰ˆæ–¹æ³• å®šä¹‰æµç¨‹çš„ * 1 è¯¥æ–¹æ³•çš„æµç¨‹æ˜¯å›ºå®šçš„ï¼Œæœ‰äº›æ­¥éª¤çš„ç»†èŠ‚å¯èƒ½å› å­ç±»ä¸åŒ * 2 è¯¥æ–¹æ³•å¿…é¡»ç”³æ˜ä¸ºfinalï¼Œå­ç±»ä¸èƒ½é‡å†™ã€‚ */ protected final void makeCourse()&#123; // åˆ¶ä½œPPT makePPT(); // åˆ¶ä½œè§†é¢‘ makeVideo(); // é€šè¿‡æ„é€ æ–¹æ³•å®ç°æ‰€éœ€é€»è¾‘ if(needMakeArticle())&#123; // ç¼–å†™æ‰‹ç¨¿ makeArticle(); &#125; // æ‰“åŒ…è¯¾ç¨‹ä¸Šçº¿ packageCourse(); &#125; /** * åˆ¶ä½œPPTæ˜¯å…±æœ‰çš„æ–¹æ³•ï¼Œå› æ­¤æ˜¯å›ºå®šçš„ï¼Œå­ç±»ä¸éœ€è¦æœ‰è‡ªå·±çš„å®ç° */ final void makePPT()&#123; log.info(\"åˆ¶ä½œppt\"); &#125; /** * åˆ¶ä½œè§†é¢‘æ˜¯å…±æœ‰çš„æ–¹æ³•ï¼Œå› æ­¤æ˜¯å›ºå®šçš„ï¼Œå­ç±»ä¸éœ€è¦æœ‰è‡ªå·±çš„å®ç° */ final void makeVideo()&#123; log.info(\"åˆ¶ä½œè§†é¢‘\"); &#125; /** * ç¼–å†™æ‰‹è®°ï¼Œè¿™ä¸ªæ˜¯å›ºå®šçš„ä¸éœ€è¦ä¹‹ç±»æœ‰è‡ªå·±çš„å®ç°ï¼Œä¸è¿‡å®ƒä¸ä¸€å®šæ˜¯å…±æœ‰çš„ï¼Œéœ€è¦çœ‹æƒ…å†µ */ final void makeArticle()&#123; log.info(\"ç¼–å†™æ‰‹è®°\"); &#125; /** * é’©å­æ–¹æ³• å­ç±»å¯ä»¥é‡å†™ç”¨æ¥è·Ÿçˆ¶ç±»äº¤äº’çš„ã€‚é»˜è®¤æ˜¯falseï¼Œä¸éœ€è¦æ‰‹è®° */ protected boolean needMakeArticle()&#123; return false; &#125; /** * æ‰“åŒ…è¯¾ç¨‹çš„æ–¹æ³•ï¼Œä¸åŒçš„è¯¾ç¨‹å¯èƒ½åŒ…è£…çš„ä¸ä¸€æ ·ï¼Œæ ¹æ®å­ç±»æƒ…å†µé‡å†™ */ abstract void packageCourse();&#125; è¯¾ç¨‹ç±»1 123456789101112131415161718192021package com.design.pattern.template;import lombok.extern.slf4j.Slf4j;/** * FECourse * * @author shunhua * @date 2019-09-27 */@Slf4jpublic class FECourse extends Course &#123; /** * é‡å†™æ‰“åŒ…è¯¾ç¨‹çš„æ–¹æ³• */ @Override void packageCourse() &#123; log.info(\"æä¾›å‰ç«¯è¯¾ç¨‹çš„æºä»£ç å’Œå›¾ç‰‡ç´ æ\"); &#125;&#125; è¯¾ç¨‹ç±»2 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.template;import lombok.extern.slf4j.Slf4j;/** * JvmCource * * @author shunhua * @date 2019-09-27 */@Slf4jpublic class JvmCource extends Course &#123; private boolean flag = Boolean.FALSE; /** * é€šè¿‡æ„é€ æ–¹æ³•è®¾ç½®é’©å­æ–¹æ³•çš„å‚æ•°ï¼ŒæŠŠé’©å­æ–¹æ³•å¼€æ”¾ç»™å®¢æˆ·ç«¯æ›´åŠ çµæ´» * * @param flag */ public JvmCource(boolean flag)&#123; this.flag = flag; &#125; @Override void packageCourse() &#123; log.info(\"Jvmè¯¾ç¨‹æä¾›è°ƒä¼˜å·¥å…·è½¯ä»¶åŒ…\"); &#125; /** * ä½¿ç”¨é’©å­æ–¹æ³•æ¥å’Œçˆ¶ç±»äº¤äº’ï¼Œå¢åŠ è‡ªå·±çš„é€»è¾‘ * @return */ @Override protected boolean needMakeArticle() &#123; return flag; &#125;&#125; å®¢æˆ·ç«¯ 1234567891011121314151617181920212223package com.design.pattern.template;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-27 */public class Client &#123; @Test public void test()&#123; Course jvmCourse = new JvmCource(Boolean.TRUE); jvmCourse.makeCourse(); Course feCourse = new FECourse(); feCourse.makeCourse(); &#125;&#125; æ¨¡ç‰ˆæ–¹æ³•æ¨¡å¼æºç è§£æAbstractList(çˆ¶)-ArrayList(å­)AbstractList 1234567public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;//getæ–¹æ³•ä¸ºæŠ½è±¡æ–¹æ³•ï¼Œå®Œå…¨äº¤ç»™å­ç±»å»å®ç°abstract public E get(int index);&#125; ArrayList 12345678910public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;//å­ç±»æ¥å®ç°getæ–¹æ³• public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125;&#125; åŒç†ï¼šAbstractSetã€AbstractMapåŒæ ·é‡‡ç”¨äº†æ¨¡ç‰ˆæ–¹æ³•æ¨¡å¼ HttpServlet1æˆ‘ä»¬ä¸€èˆ¬ç»§æ‰¿HttpServletï¼Œç„¶åé‡å†™doGetæˆ–è€…doPostç­‰doXxxæ–¹æ³•ï¼ŒHttpServletä¸­å®šä¹‰äº†ä¸€å¥—æ¨¡ç‰ˆï¼Œåªè¦è¦†å†™è¿™äº›æ–¹æ³•å³å¯ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod();if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn't support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125;&#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp);&#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(\"http.method_not_implemented\"); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);&#125; &#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"è¿­ä»£å™¨æ¨¡å¼","slug":"design_pattern/behaviour_type/è¿­ä»£å™¨æ¨¡å¼","date":"2019-09-26T16:00:00.000Z","updated":"2020-08-09T09:31:35.235Z","comments":true,"path":"posts/9055d217/","link":"","permalink":"https://gentryhuang.com/posts/9055d217/","excerpt":"","text":"å®šä¹‰æä¾›ä¸€ç§æ–¹æ³•ï¼Œé¡ºåºè®¿é—®ä¸€ä¸ªé›†åˆå¯¹è±¡ä¸­çš„å„ä¸ªå…ƒç´ ï¼Œè€Œåˆä¸æš´éœ²è¯¥å¯¹è±¡çš„å†…éƒ¨ç»†èŠ‚ã€‚ ç±»å‹è¡Œä¸ºå‹ é€‚ç”¨åœºæ™¯121 è®¿é—®ä¸€ä¸ªé›†åˆå¯¹è±¡çš„å†…å®¹è€Œæ— éœ€æš´éœ²å®ƒçš„å†…éƒ¨è¡¨ç¤º2 ä¸ºéå†ä¸åŒçš„é›†åˆç»“æ„æä¾›ä¸€ä¸ªç»Ÿä¸€çš„æ¥å£ ä¼˜ç‚¹1åˆ†ç¦»äº†é›†åˆå¯¹è±¡çš„éå†è¡Œä¸ºï¼Œå› ä¸ºæŠ½è±¡å‡ºäº†è¿­ä»£å™¨æ¥éå†å¯¹è±¡ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡è¿­ä»£å™¨æ¥è®¿é—®é›†åˆå¯¹è±¡å†…éƒ¨å…ƒç´ äº†ã€‚ ç¼ºç‚¹1ç±»çš„ä¸ªæ•°æˆå¯¹å¢åŠ ï¼Œç”±äºè¿­ä»£å™¨æ¨¡å¼æ˜¯å°†å­˜å‚¨æ•°æ®å’Œéå†æ•°æ®è¿™ä¸ªä¸¤ä¸ªèŒè´£è¿›è¡Œåˆ†ç¦»ï¼Œæ‰€ä»¥å½“æ–°å‡ºç°ä¸€ç§é›†åˆç±»å°±éœ€è¦å¢åŠ ä¸€ç§æ–°çš„å¯¹åº”çš„è¿­ä»£å™¨ã€‚è¿™æ ·ç±»çš„ä¸ªæ•°å¢åŠ ï¼Œè¿™åœ¨ä¸€å®šç¨‹åº¦ä¸Šå¢åŠ äº†ç³»ç»Ÿçš„å¤æ‚æ€§ã€‚ è¿­ä»£å™¨ç›¸å…³çš„è®¾è®¡æ¨¡å¼è¿­ä»£å™¨æ¨¡å¼å’Œè®¿é—®è€…æ¨¡å¼ 121 è¿™ä¸¤è€…éƒ½æ˜¯è¿­ä»£åœ°è®¿é—®é›†åˆå¯¹è±¡ä¸­çš„å„ä¸ªå…ƒç´ 2 è®¿é—®è€…æ¨¡å¼ä¸­æ‰©å±•å¼€æ”¾çš„éƒ¨åˆ†åœ¨ä½œç”¨äºå¯¹è±¡çš„æ“ä½œä¸Šï¼Œè€Œåœ¨è¿­ä»£å™¨æ¨¡å¼ä¸­æ‰©å±•å¼€æ”¾çš„éƒ¨åˆ†æ˜¯åœ¨é›†åˆå¯¹è±¡çš„ç§ç±»ä¸Š è¯´æ˜è¿­ä»£å™¨æ¨¡å¼åœ¨æ—¥å¸¸å¼€å‘ä¸­ä¸€èˆ¬ä¸ä¼šè‡ªå·±å†™ï¼Œé™¤éæˆ‘ä»¬å®šä¹‰è‡ªå·±çš„æ•°æ®ç»“æ„ï¼Œç„¶åä¸ºè¿™ä¸ªæ•°æ®ç»“æ„å®ç°å¯¹åº”çš„è¿­ä»£å™¨ã€‚ ç®€å•éœ€æ±‚è¯¾ç¨‹çš„å¢åŠ å’Œåˆ é™¤ä»¥åŠè¿­ä»£è¯¥è¯¾ç¨‹é›† è¿­ä»£å™¨æ¨¡å¼æ¼”ç»ƒs å®ä½“ç±» 1234567891011121314151617181920package com.design.pattern.iterator.v2;import lombok.AllArgsConstructor;import lombok.Data;/** * Course ç›¸å½“äºé›†åˆä¸­çš„å…ƒç´  * * @author shunhua * @date 2019-09-27 */@Data@AllArgsConstructorpublic class Course &#123; /** * è¯¾ç¨‹çš„åå­— */ private String name;&#125; é›†åˆç±» 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.design.pattern.iterator.v2;import java.util.ArrayList;import java.util.List;/** * MyCollection * * @author shunhua * @date 2019-09-27 */public class MyCollection&lt;T&gt; &#123; /** * å…ƒç´ é›†åˆ */ private final List&lt;T&gt; list = new ArrayList&lt;&gt;(); /** * å¢åŠ å…ƒç´  * @param item */ public void add(T item)&#123; list.add(item); &#125; /** * ç§»å‡ºå…ƒç´  */ public void remove(T item)&#123; this.list.remove(item); &#125; /** * åˆ é™¤æ‰€æœ‰å…ƒç´  */ public void removeAll()&#123; this.list.removeAll(list); &#125; /** * è·å–è¿­ä»£å™¨ï¼Œæ³¨æ„éœ€è¦æŠŠå®ä½“å¯¹è±¡åˆ—è¡¨ä¼ ç»™è¿­ä»£å™¨ * @return */ public MyIterator iterator()&#123; return new MyIterator(list); &#125;&#125; è¿­ä»£å™¨ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.design.pattern.iterator.v2;import java.util.List;/** * MyIterator * * @author shunhua * @date 2019-09-27 */public class MyIterator&lt;T&gt; &#123; /** * é›†åˆ */ private List&lt;T&gt; list ; /** * æ¸¸æ ‡ */ private int position; /** * é›†åˆä¸­çš„å…ƒç´  */ private T item; public MyIterator(List&lt;T&gt; list)&#123; this.list = list; &#125; /** * æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªå…ƒç´  * @return */ public boolean hasNext()&#123; if( this.position &lt; list.size())&#123; return true; &#125; return false; &#125; /** * è¿­ä»£å…ƒç´  * @return */ public T next()&#123; T item = list.get(position); position ++; return item; &#125;&#125; åº”ç”¨å±‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.design.pattern.iterator.v2;import com.design.pattern.iterator.v1.Course;import com.design.pattern.iterator.v1.CourseHandler;import com.design.pattern.iterator.v1.CourseHandlerImpl;import com.design.pattern.iterator.v1.CourseIterator;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-27 */@Slf4jpublic class Client &#123; @Test public void test() &#123; Course course1 = new Course(\"Javaä»å…¥é—¨åˆ°æ”¾å¼ƒ\"); Course course2 = new Course(\"MySqlä»åˆ åº“åˆ°è·‘è·¯\"); Course course3 = new Course(\"Pythonä»å…¥é—¨åˆ°ç²¾é€š\"); MyCollection&lt;Course&gt; collection = new MyCollection(); collection.add(course1); collection.add(course2); collection.add(course3); log.info(\"----------è¯¾ç¨‹åˆ—è¡¨-------------\"); printCourses(collection); collection.remove(course1); log.info(\"----------åˆ é™¤æ“ä½œä¹‹åçš„è¯¾ç¨‹---- \"); printCourses(collection); &#125; private void printCourses(MyCollection collection) &#123; MyIterator iterator = collection.iterator(); while (iterator.hasNext()) &#123; Course course = (Course) iterator.next(); log.info(course.toString()); &#125; &#125;&#125; è¿­ä»£å™¨æ¨¡å¼æºç è§£æArrayListçš„è¿­ä»£å™¨ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** ArrayListçš„å†…éƒ¨ç±»å®ç°äº†Iterator * An optimized version of AbstractList.Itr */private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"ç»„åˆæ¨¡å¼","slug":"design_pattern/structure_type/ç»„åˆæ¨¡å¼","date":"2019-09-23T16:00:00.000Z","updated":"2020-08-09T09:36:05.220Z","comments":true,"path":"posts/df879792/","link":"","permalink":"https://gentryhuang.com/posts/df879792/","excerpt":"","text":"å®šä¹‰å°†å¯¹è±¡ç»„åˆæˆæ ‘å½¢ç»“æ„ä»¥è¡¨ç¤ºâ€œéƒ¨åˆ†-æ•´ä½“â€çš„å±‚æ¬¡ç»“æ„ã€‚ä½œç”¨æ˜¯ä½¿å®¢æˆ·ç«¯å¯¹å•ä¸ªå¯¹è±¡å’Œç»„åˆå¯¹è±¡ä¿æŒä¸€è‡´çš„æ–¹å¼å¤„ç†ã€‚ç»„åˆæ¨¡å¼å°±æ˜¯å°†å¤šä¸ªå¯¹è±¡ç»„åˆæˆä¸€ä¸ªå¯¹è±¡ï¼ˆè¿™äº›å¯¹è±¡å…·æœ‰ç›¸åŒçš„ç±»å‹ï¼Œä½¿ç”¨å®ƒä»¬çš„çˆ¶ç±»å‹ä½œä¸ºç»Ÿä¸€çš„å¯¹è±¡ä¾›å®¢æˆ·ç«¯è®¿é—®ï¼‰ï¼Œç®€åŒ–äº†å¯¹å¤šä¸ªå¯¹è±¡çš„è®¿é—® ç±»å‹ç»“æ„å‹ ä½¿ç”¨åœºæ™¯121. å¸Œæœ›å®¢æˆ·ç«¯å¯ä»¥å¿½ç•¥ç»„åˆå¯¹è±¡ä¸å•ä¸ªå¯¹è±¡çš„å·®å¼‚æ—¶2. å¤„ç†ä¸€ä¸ªæ ‘å½¢ç»“æ„æ—¶ ä¼˜ç‚¹1234â—†æ¸…æ¥šåœ°å®šä¹‰äº†åˆ†å±‚æ¬¡çš„å¤æ‚å¯¹è±¡ï¼Œè¡¨ç¤ºå¯¹è±¡çš„å…¨éƒ¨æˆ–éƒ¨åˆ†å±‚æ¬¡â—†è®©å®¢æˆ·ç«¯å¿½ç•¥äº†å±‚æ¬¡çš„å·®å¼‚ï¼Œæ–¹ä¾¿å¯¹æ•´ä¸ªå±‚æ¬¡ç»“æ„è¿›è¡Œæ§åˆ¶â—†ç®€åŒ–å®¢æˆ·ç«¯ä»£ç â—†ç¬¦åˆå¼€é—­åŸåˆ™ ç¼ºç‚¹121. é™åˆ¶ç±»å‹æ—¶ä¼šè¾ƒä¸ºå¤æ‚ï¼Œå› ä¸ºå®ƒä»¬éƒ½å…·æœ‰ç›¸åŒçš„çˆ¶ç±»å‹2. ä½¿è®¾è®¡å˜å¾—æ›´åŠ æŠ½è±¡ ç›¸å…³çš„è®¾è®¡æ¨¡å¼ç»„åˆæ¨¡å¼å’Œè®¿é—®è€…æ¨¡å¼ å¯ä»¥ç”¨è®¿é—®æ¨¡å¼è®¿é—®ç»„åˆæ¨¡å¼çš„é€’å½’ç»“æ„ ç®€å•éœ€æ±‚è¯¾ç¨‹åˆ†ä¸ºä¸åŒçš„ç±»å‹ï¼Œæ¯ä¸€ç§ç±»å‹å¯¹åº”ä¸€ä¸ªè¯¾ç¨‹ç›®å½•ï¼Œè¯¾ç¨‹ç›®å½•ä¸‹åˆæœ‰å¾ˆå¤šçš„è¯¾ç¨‹ï¼Œè¦æ±‚æ‰“å°å‡ºè¯¾ç¨‹çš„ç»“æ„ ç»„åˆæ¨¡å¼çš„æ¼”ç»ƒ 1æˆ‘ä»¬å¯ä»¥é€šè¿‡è¡Œä¸ºæ–¹æ³•è¿›è¡Œè¯†åˆ«ç»„åˆæ¨¡å¼ï¼Œç»„åˆæ¨¡å¼æ˜¯å°†ç›¸åŒçš„æŠ½è±¡ç±»ç±»å‹æˆ–è€…æ¥å£ç±»å‹è½¬ä¸ºç›¸åŒçš„æ ‘çŠ¶ç»“æ„ï¼Œä½¿ç”¨æŠ½è±¡ä½œä¸ºè®¿é—®çš„å…¥å£ã€‚å¶å­å¯¹è±¡ï¼ˆå•ä¸ªå¯¹è±¡ï¼‰å’Œç»„åˆå¥½çš„å¯¹è±¡ï¼ˆåŒ…å«å¶å­å¯¹è±¡çš„é›†åˆï¼‰éƒ½è¦ç»§æ‰¿æˆ–å®ç°ç›¸åŒçš„çˆ¶ç±»ï¼Œè¿™æ ·ç»„åˆæ¨¡å¼æ‰èƒ½å°†å®ƒä»¬è¿›è¡Œç»Ÿä¸€å¤„ç†ã€‚ ç»Ÿä¸€æŠ½è±¡ç±» 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.design.pattern.composite;/** * 1. æ–¹æ³•ä¸­çš„æŠ›å‡ºå¼‚å¸¸å¤„ç†ï¼Œæ˜¯ä½“ç°æ–¹æ³•ä¸èƒ½è¢«ä½¿ç”¨ï¼Œå› ä¸ºè¯¾ç¨‹å’Œè¯¾ç¨‹ç›®å½•ä½¿ç”¨çš„æ–¹æ³•ä¸åŒ * 2. è¯¾ç¨‹å’Œè¯¾ç¨‹ç›®å½•ä½¿ç”¨ç»Ÿä¸€ç±»å‹ä¾›å®¢æˆ·ç«¯è®¿é—® * @author shunhua * @date 2019-09-24 */public abstract class CourseComponet &#123; /** * æ‰©å±•è¯¾ç¨‹ç›®å½• * @param courseComponet */ public void addCatalog(CourseComponet courseComponet)&#123; throw new UnsupportedOperationException(\"ä¸æ”¯æŒæ·»åŠ è¯¾ç¨‹ç›®å½•æ“ä½œ\"); &#125; /** * åˆ é™¤è¯¾ç¨‹ç›®å½• * @param courseComponet */ public void removeCatalog(CourseComponet courseComponet)&#123; throw new UnsupportedOperationException(\"ä¸æ”¯æŒåˆ é™¤è¯¾ç¨‹ç›®å½•æ“ä½œ\"); &#125; /** * è·å–è¯¾ç¨‹åç§° * @param courseComponet * @return */ public String getName(CourseComponet courseComponet)&#123; throw new UnsupportedOperationException(\"ä¸æ”¯æŒè·å–è¯¾ç¨‹åç§°æ“ä½œ\"); &#125; /** * è·å–è¯¾ç¨‹ä»·æ ¼ * @param courseComponet * @return */ public double getPrice(CourseComponet courseComponet)&#123; throw new UnsupportedOperationException(\"ä¸æ”¯æŒè·å–è¯¾ç¨‹ä»·æ ¼æ“ä½œ\"); &#125; /** * æ‰“å°ä¿¡æ¯ */ public void print()&#123; throw new UnsupportedOperationException(\"ä¸æ”¯æŒæ‰“å°æ“ä½œ\"); &#125;&#125; è¯¾ç¨‹ç±» 1234567891011121314151617181920212223242526272829303132333435363738394041package com.design.pattern.composite;import lombok.extern.slf4j.Slf4j;&#x2F;** * Course è¯¾ç¨‹ç±» * * @author shunhua * @date 2019-09-24 *&#x2F;@Slf4jpublic class Course extends CourseComponet &#123; &#x2F;** * è¯¾ç¨‹å *&#x2F; private String courseName; &#x2F;** * è¯¾ç¨‹ä»·æ ¼ *&#x2F; private double price; public Course(String courseName, double price) &#123; this.courseName &#x3D; courseName; this.price &#x3D; price; &#125; @Override public String getName(CourseComponet courseComponet) &#123; return this.courseName; &#125; @Override public double getPrice(CourseComponet courseComponet) &#123; return this.price; &#125; @Override public void print() &#123; log.info(&quot;è¯¾ç¨‹åï¼š&quot; + courseName + &quot;, è¯¾ç¨‹ä»·æ ¼ï¼š&quot; + price); &#125;&#125; è¯¾ç¨‹ç›®å½•ç±» 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.design.pattern.composite;import lombok.extern.slf4j.Slf4j;import java.util.ArrayList;import java.util.List;/** * CourseCatalog è¯¾ç¨‹ç›®å½•ç±» * * @author shunhua * @date 2019-09-24 */@Slf4jpublic class CourseCatalog extends CourseComponet &#123; /** * è¯¾ç¨‹ç›®å½•ä¸‹çš„è¯¾ç¨‹é›†åˆ ï¼Œè¿™é‡Œä½¿ç”¨ç»Ÿä¸€æŠ½è±¡ç±»å‹è¡¨ç¤ºï¼Œè¿™é‡Œå°±ç»„åˆäº†è¯¾ç¨‹å¯¹è±¡ */ private List&lt;CourseComponet&gt; items = new ArrayList&lt;&gt;(); /** * è¯¾ç¨‹ç›®å½•å */ private String catalogName; public CourseCatalog(String catalogName)&#123; this.catalogName = catalogName; &#125; /** * ä¸ºè¯¾ç¨‹ç›®å½•æ·»åŠ è¯¾ç¨‹ * @param courseComponet */ @Override public void addCatalog(CourseComponet courseComponet) &#123; this.items.add(courseComponet); &#125; /** * åˆ é™¤è¯¾ç¨‹ç›®å½•ä¸­çš„è¯¾ç¨‹ * @param courseComponet */ @Override public void removeCatalog(CourseComponet courseComponet) &#123; this.items.remove(courseComponet); &#125; @Override public String getName(CourseComponet courseComponet) &#123; return this.catalogName; &#125; /** * æ‰“å°ç›®å½•ä»¥åŠç›®å½•ä¸‹çš„è¯¾ç¨‹ */ @Override public void print() &#123; log.info(catalogName); for(CourseComponet courseComponet : items)&#123; courseComponet.print(); &#125; &#125;&#125; å®¢æˆ·ç«¯ 123456789101112131415161718192021222324252627282930313233package com.design.pattern.composite;import org.junit.Test;&#x2F;** * Client è¯¾ç¨‹ç›®å½•å’Œè¯¾ç¨‹ï¼Œå¯¹å®¢æˆ·ç«¯æ¥è¯´éƒ½æ˜¯ä¸€ä¸ªç±»å‹çš„å¯¹è±¡ * * @author shunhua * @date 2019-09-24 *&#x2F;public class Client &#123; @Test public void test()&#123; CourseComponet catalog &#x3D; new CourseCatalog(&quot;è¯¾ç¨‹é¡¶çº§ç›®å½•&quot;); CourseComponet linuxCourse &#x3D; new Course(&quot;é¸Ÿå“¥ç§æˆ¿èœ&quot;,80); CourseComponet gitCourse &#x3D; new Course(&quot;Gitæƒå¨æŒ‡å—&quot;,120); CourseComponet javaCatalog &#x3D; new CourseCatalog(&quot;Javaè¯¾ç¨‹ç›®å½•&quot;); CourseComponet spring &#x3D; new Course(&quot;Springå®æˆ˜&quot;,70); CourseComponet mybatis &#x3D; new Course(&quot;MyBatisæŠ€æœ¯å†…å¹•&quot;,60); javaCatalog.addCatalog(spring); javaCatalog.addCatalog(mybatis); catalog.addCatalog(linuxCourse); catalog.addCatalog(gitCourse); catalog.addCatalog(javaCatalog); &#x2F;&#x2F; æ‰“å°è¯¾ç¨‹ç›®å½•ä»¥åŠç›®å½•ä¸‹çš„è¯¾ç¨‹åˆ—è¡¨ catalog.print(); &#125;&#125; ç»„åˆæ¨¡å¼æºç è§£æjdkæºç ä¹‹HashMap 1234567891011121314151617181920212223242526272829303132public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; /** * æ–¹æ³•çš„å…¥å‚æ˜¯Mapç±»å‹ï¼Œä½¿ç”¨Mapç±»å‹ä½œä¸ºç»Ÿä¸€çš„æ¥æ”¶å‚æ•°ï¼Œä¸éœ€è¦å…³æ³¨ä»»ä½•ä¹‹ç±»å‹çš„å¯¹è±¡ */ public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; if (table == EMPTY_TABLE) &#123; inflateTable((int) Math.max(numKeysToBeAdded * loadFactor, threshold)); &#125; if (numKeysToBeAdded &gt; threshold) &#123; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); &#125; for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue()); &#125;&#125; jdkæºç ä¹‹ArrayList 1234567891011/** * æ–¹æ³•çš„å…¥å‚ä½¿ç”¨ç»Ÿä¸€çš„çˆ¶ç±»å‹Collectionï¼Œå®¢æˆ·ç«¯ä¸éœ€è¦å…³æ³¨å…·ä½“çš„å­ç±»å‹å¯¹è±¡ */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; MyBatisæºç ä¹‹SqlNode 12MyBatisçš„sqlè¯­å¥ä¼šè¢«è§£ææˆä¸åŒçš„SqlNodeç±»å‹çš„å¯¹è±¡ï¼Œè¿™äº›å¯¹è±¡éƒ½å®ç°äº†SqlNodeã€‚å…¶ä¸­MixedSqlNodeæ˜¯è”ç³»ä¸åŒçš„SqlNodeçš„ä¸€ä¸ªæ ¸å¿ƒå¯¹è±¡ï¼Œç»„åˆæ¨¡å¼å¯ä»¥ç»Ÿä¸€å¤„ç†çš„å®ƒä»¬ã€‚ 12345678910111213141516171819202122package org.apache.ibatis.scripting.xmltags;import java.util.List;public class MixedSqlNode implements SqlNode &#123; /** * SqlNodeä¸åŒå®ç°çš„é›†åˆ */ private final List&lt;SqlNode&gt; contents; public MixedSqlNode(List&lt;SqlNode&gt; contents) &#123; this.contents = contents; &#125; @Override public boolean apply(DynamicContext context) &#123; for (SqlNode sqlNode : contents) &#123; sqlNode.apply(context); &#125; return true; &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"äº«å…ƒæ¨¡å¼","slug":"design_pattern/structure_type/äº«å…ƒæ¨¡å¼","date":"2019-09-22T16:00:00.000Z","updated":"2020-08-09T09:33:14.983Z","comments":true,"path":"posts/e19da94a/","link":"","permalink":"https://gentryhuang.com/posts/e19da94a/","excerpt":"","text":"å®šä¹‰æä¾›äº†å‡å°‘å¯¹è±¡æ•°é‡ä»è€Œæ”¹å–„åº”ç”¨çš„å¯¹è±¡ç»“æ„çš„æ–¹å¼ã€‚è¿ç”¨å…±äº«æŠ€æœ¯æœ‰æ•ˆåœ°æ”¯æŒå¤§é‡ç»†ç²’åº¦çš„å¯¹è±¡ã€‚å³å‡å°‘åˆ›å»ºå¯¹è±¡çš„æ•°é‡ï¼Œå…±äº«å¯¹è±¡ï¼Œä»è€Œå‡å°‘å†…å­˜çš„å ç”¨å¹¶ä¸”æé«˜æ€§èƒ½ ã€‚æ³¨æ„ï¼šäº«å…ƒæ¨¡å¼é‡è¦çš„å°±æ˜¯å…±äº«ã€‚ ç±»å‹ç»“æ„å‹ åº”ç”¨åœºæ™¯1234â—† å¸¸å¸¸åº”ç”¨äºç³»ç»Ÿåº•å±‚çš„å¼€å‘ï¼Œä»¥ä¾¿è§£å†³ç³»ç»Ÿçš„æ€§èƒ½é—®é¢˜ å¦‚Stringç±»å‹å°±æ˜¯ä½¿ç”¨äº†äº«å…ƒæ¨¡å¼ï¼ŒStringå¯¹è±¡å­˜åœ¨å³è¿”å›ï¼Œæ²¡æœ‰å°±åˆ›å»ºç„¶åæ”¾å…¥åˆ°å­—ç¬¦ä¸²å¸¸é‡æ± ä¸­ã€‚å†æ¯”å¦‚æ•°æ®åº“è¿æ¥æ± ï¼Œé‡Œé¢éƒ½æ˜¯åˆ›å»ºå¥½çš„æ•°æ®åº“è¿æ¥ï¼Œéœ€è¦çš„æ—¶å€™æ‹¿æ¥ç”¨ä¸éœ€è¦çš„æ—¶å€™å½’è¿˜å›å»ã€‚å³ç³»ç»Ÿä¸­å¦‚æœæœ‰å¤§é‡çš„å¯¹è±¡ï¼Œå¯èƒ½ä¼šé€ æˆå†…å­˜æº¢å‡ºï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå…±åŒçš„éƒ¨åˆ†æŠ½è±¡å‡ºæ¥ï¼Œæœ‰ç›¸åŒçš„ä¸šåŠ¡è¯·æ±‚ï¼Œåˆ™è¿”å›åœ¨å†…å­˜ä¸­çš„å·²æœ‰å¯¹è±¡ï¼Œé¿å…é‡æ–°åˆ›å»ºâ—† ç³»ç»Ÿæœ‰å¤§é‡ç›¸ä¼¼å¯¹è±¡ã€éœ€è¦ç¼“å†²æ± çš„åœºæ™¯ æŸä¸ªå¯¹è±¡çš„å¤ç”¨åº¦è¶Šé«˜ï¼Œè¶Šå€¾å‘äºä½¿ç”¨äº«å…ƒæ¨¡å¼ ä¼˜ç‚¹12â—†å‡å°‘å¯¹è±¡çš„åˆ›å»ºï¼Œé™ä½å†…å­˜ä¸­å¯¹è±¡çš„æ•°é‡ï¼Œé™ä½ç³»ç»Ÿçš„å†…å­˜ï¼Œæé«˜æ•ˆç‡â—†å‡å°‘å†…å­˜ä¹‹å¤–çš„å…¶ä»–èµ„æºå ç”¨(æ—¶é—´èµ„æºã€æ–‡ä»¶å¥æŸ„ã€çª—å£å¥æŸ„ç­‰) ç¼ºç‚¹1234â—†å…³æ³¨å†…&#x2F;å¤–éƒ¨çŠ¶æ€ã€å…³æ³¨çº¿ç¨‹å®‰å…¨é—®é¢˜ æˆ‘ä»¬ä½¿ç”¨å…±äº«æ¨¡å¼çš„æ—¶å€™ï¼Œå¤§éƒ½æ˜¯ä½¿ç”¨hashMapï¼Œä¸ä¼šç”¨HashTableï¼ˆå› ä¸ºhashTableä¼šç”±äºåŒæ­¥é”é€ æˆæ•ˆç‡è¿‡ä½ï¼Œè¿™æ ·å¾—ä¸å¿å¤±ï¼‰ï¼Œè¿™æ ·å°±éœ€è¦åœ¨æœ‰äº›åœºæ™¯ä¸‹å…³æ³¨çº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚åŒæ—¶è¿˜è¦å…³æ³¨å†…ã€å¤–éƒ¨çŠ¶æ€ã€‚â—†ä½¿ç³»ç»Ÿã€ç¨‹åºçš„é€»è¾‘å¤æ‚åŒ– ä½¿ç”¨äº†äº«å…ƒå¯¹è±¡æé«˜äº†ç³»ç»Ÿçš„å¤æ‚åº¦ï¼Œè¿˜è¦åˆ†ç¦»å†…å¤–ä¸çŠ¶æ€ï¼Œå¹¶ä¸”å¤–éƒ¨çŠ¶æ€ä¸åº”è¯¥éšç€å†…éƒ¨çŠ¶æ€çš„å˜åŒ–è€Œå˜åŒ–ï¼Œå¦åˆ™ç³»ç»Ÿå°±æ··ä¹±äº†ã€‚ æ‰©å±•å†…éƒ¨çŠ¶æ€ 1åœ¨äº«å…ƒæ¨¡å¼å†…éƒ¨å¹¶ä¸”ä¸ä¼šéšç€ç¯å¢ƒæ”¹å˜è€Œæ”¹å˜çš„å…±äº«éƒ¨åˆ†ï¼›æ— è®ºå¤–éƒ¨ç¯å¢ƒå¦‚ä½•å˜åŒ–ï¼Œæˆ‘éƒ½ä¸å˜ï¼Œå¹¶ä¸”è¯¥çŠ¶æ€åœ¨äº«å…ƒæ¨¡å¼å†…éƒ¨ã€‚å¯ç†è§£ä¸ºæ˜¯äº«å…ƒå¯¹è±¡çš„ä¸€ä¸ªå±æ€§ï¼Œè¿™ä¸ªå±æ€§ä¸ä¼šä¸å¤–éƒ¨äº¤äº’ã€‚ å¤–éƒ¨çŠ¶æ€ 1éšç€ç¯å¢ƒæ”¹å˜è€Œæ”¹å˜çš„å°±æ˜¯å¤–éƒ¨çŠ¶æ€ï¼Œè¿™ç§çŠ¶æ€æ˜¯ä¸å¯ä»¥å…±äº«çš„çŠ¶æ€ï¼Œå¹¶ä¸”è®°å½•åœ¨äº«å…ƒæ¨¡å¼çš„å¤–éƒ¨ã€‚å¯ç†è§£ä¸ºäº«å…ƒå¯¹è±¡çš„ä¸€ä¸ªå¯ä»¥å’Œå¤–ç•Œäº¤äº’çš„å±æ€§ï¼Œå®ƒä¼šéšæ—¶å‘ç”Ÿæ”¹å˜ã€‚ ç›¸å…³è®¾è®¡æ¨¡å¼äº«å…ƒæ¨¡å¼å’Œä»£ç†æ¨¡å¼ 1ä»£ç†æ¨¡å¼æ˜¯ä»£ç†ä¸€ä¸ªç±»ï¼Œå¦‚æœç”Ÿæˆè¿™ä¸ªä»£ç†ç±»èŠ±çš„èµ„æºå’Œæ—¶é—´æ¯”è¾ƒå¤šï¼Œå¯ä»¥ä½¿ç”¨äº«å…ƒæ¨¡å¼å¤„ç†è¿™ä¸ªç±»çš„é€Ÿåº¦ äº«å…ƒæ¨¡å¼å’Œå•ä¾‹æ¨¡å¼ 1å®¹å™¨å•ä¾‹æ˜¯ä¸¤ç§æ–¹å¼çš„ä¸€ç§ç»“åˆã€‚äº«å…ƒæ¨¡å¼æ˜¯ä¸€ç§å¤ç”¨å¯¹è±¡çš„æ€æƒ³ ç®€å•éœ€æ±‚å¹´ç»ˆäº†ï¼Œç ”å‘éƒ¨é—¨Leaderå¯èƒ½éœ€è¦å¤šæ¬¡åœ°å»æ±‡æŠ¥å·¥ä½œæƒ…å†µï¼Œå·²ç»æœ‰æŠ¥å‘Šç»“æœçš„å°±ä¸éœ€è¦å†æ•´ç†æŠ¥å‘Šäº†ï¼Œç›´æ¥æ‹¿åˆ°æŠ¥å‘Šå°±å¯ä»¥å»æ±‡æŠ¥äº†ã€‚æ²¡æœ‰åšè¿‡æ±‡æŠ¥çš„å°±éœ€è¦å…ˆæ•´ç†æŠ¥å‘Šã€‚ äº«å…ƒæ¨¡å¼æ¼”ç»ƒ æŠ¥å‘Š 1234567891011121314151617181920212223242526272829303132333435363738package com.design.pattern.flyweight;import lombok.Data;import lombok.extern.slf4j.Slf4j;/** * Presentation æŠ¥å‘Šç±» * * @author shunhua * @date 2019-09-23 */@Data@Slf4jpublic class Presentation &#123; /** * æŠ¥å‘Šç›¸å…³éƒ¨é—¨ */ private String department; /** * æ±‡æŠ¥å†…å®¹ */ private String content; /** * é€šè¿‡å¤–éƒ¨çŠ¶æ€å±æ€§è¿›è¡Œæ„é€  * @param department */ public Presentation(String department)&#123; this.department = department; &#125; /** * æŠ¥å‘Šå†…å®¹ */ public void report() &#123; log.info(content); &#125;&#125; æŠ¥å‘Šå·¥å‚ 1234567891011121314151617181920212223242526272829303132333435363738394041package com.design.pattern.flyweight;import lombok.extern.slf4j.Slf4j;import org.springframework.util.ObjectUtils;import java.util.HashMap;import java.util.Map;/** * PresentationFactory æŠ¥å‘Šå·¥å‚ * * @author shunhua * @date 2019-09-23 */@Slf4jpublic class PresentationFactory &#123; /** * æ­¤å¤„åº”ç”¨äº† finalä¿®é¥° å¼•ç”¨æˆå‘˜å˜é‡ï¼Œå¼•ç”¨å¯¹è±¡çš„å†…å®¹å¯ä»¥ä¿®æ”¹ï¼Œä½†æ˜¯å¼•ç”¨åœ°å€ä¸å¯ä»¥ä¿®æ”¹ã€‚è¿™é‡Œä½œä¸ºæŠ¥å‘Šæ± ã€‚ */ private static final Map&lt;String,Presentation&gt; PRESENTATION_MAP = new HashMap&lt;&gt;(16); /** * è¿™é‡Œä¸è€ƒè™‘å®‰å…¨é—®é¢˜ * @param department * @return */ public static Presentation getPresentation(String department)&#123; // å…ˆä»æŠ¥å‘Šæ± ä¸­è·å– Presentation leaderPresentation = PRESENTATION_MAP.get(department); // æŠ¥å‘Šæ± ä¸­æ²¡æœ‰å†åˆ›å»ºä¸€ä¸ªï¼Œç„¶åæ”¾åˆ°æŠ¥å‘Šæ± ä¸­ if(ObjectUtils.isEmpty(leaderPresentation))&#123; leaderPresentation = new Presentation(department); log.info(\"----------- æŠ¥å‘Šæ± ä¸­æ²¡æœ‰éœ€å…ˆåˆ›å»º----------\"); PRESENTATION_MAP.put(department,leaderPresentation); leaderPresentation.setContent(\"éƒ¨é—¨ï¼š\" + department +\" æ±‡æŠ¥...\"); leaderPresentation.report(); &#125; return leaderPresentation; &#125;&#125; å®¢æˆ·ç«¯ 12345678910111213141516171819202122package com.design.pattern.flyweight;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-23 */public class Client &#123; private final String presentation[] = &#123;\"ä¸šåŠ¡éƒ¨\",\"ç ”å‘éƒ¨\",\"ç®¡ç†éƒ¨\"&#125;; @Test public void test()&#123; for(int i = 0; i &lt; 20; i++)&#123; String department = presentation[(int)(Math.random() * presentation.length)]; Presentation leaderPresentation = PresentationFactory.getPresentation(department); leaderPresentation.report(); &#125; &#125;&#125; äº«å…ƒæ¨¡å¼æºç è§£æInteger 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public final class Integer extends Number implements Comparable&lt;Integer&gt; &#123; /** * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * å¦‚æœä¼ å…¥çš„æ•°å€¼åœ¨ç¼“å­˜çš„-127å’Œ128ä¹‹é—´ï¼Œé‚£ä¹ˆéƒ½ä¼šåœ¨cacheä¸­ï¼Œå¦åˆ™çš„è¯ï¼Œä¼šnewå‡ºæ–°çš„å¯¹è±¡ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ100==100ä¸ºtrueï¼Œ1000==1000ä¸ºfalse * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */ public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125;/** åªè¦åœ¨-128-127ï¼Œä½¿ç”¨ == åˆ¤æ–­æ˜¯å¯ä»¥çš„ï¼Œä¸å†è¿™ä¸ªèŒƒå›´å°±ä¸èƒ½ä½¿ç”¨==,éœ€è¦ä½¿ç”¨equqls * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * */ private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125; &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"é€‚é…å™¨æ¨¡å¼","slug":"design_pattern/structure_type/é€‚é…å™¨æ¨¡å¼","date":"2019-09-20T16:00:00.000Z","updated":"2020-11-15T09:00:02.919Z","comments":true,"path":"posts/f5c535ea/","link":"","permalink":"https://gentryhuang.com/posts/f5c535ea/","excerpt":"","text":"å®šä¹‰ä½¿åŸæœ¬æ¥å£ä¸å…¼å®¹çš„ç±»ï¼ˆå®ƒä»¬çš„æ¥å£ä¸åŒï¼‰å¯ä»¥ä¸€èµ·å·¥ä½œï¼ˆä½¿ç”¨åŒä¸€æ¥å£äº†ï¼‰ã€‚ ç±»å‹ç»“æ„å‹ åº”ç”¨åœºæ™¯12â—†å·²ç»å­˜åœ¨çš„ç±»ï¼Œå®ƒçš„æ–¹æ³•å’Œéœ€æ±‚ä¸åŒ¹é…æ—¶â—†ä¸æ˜¯è½¯ä»¶è®¾è®¡é˜¶æ®µè€ƒè™‘çš„è®¾è®¡æ¨¡å¼ï¼Œæ˜¯éšç€è½¯ä»¶ç»´æŠ¤ï¼Œç”±äºä¸åŒäº§å“ã€ä¸åŒå‚å®¶é€ æˆåŠŸèƒ½ç±»ä¼¼è€Œæ¥å£ä¸ç›¸åŒæƒ…å†µä¸‹çš„è§£å†³æ–¹æ¡ˆï¼Œæ˜¯è½¯ä»¶ç»´æŠ¤é˜¶æ®µéœ€è¦è€ƒè™‘çš„äº‹æƒ… ä¼˜ç‚¹123â—†èƒ½æé«˜ç±»çš„é€æ˜æ€§å’Œå¤ç”¨ï¼Œç°æœ‰çš„ç±»å¤ç”¨ä½†ä¸éœ€è¦æ”¹å˜ï¼Œè§£å†³äº†ç°æœ‰ç±»å’Œç›®æ ‡ç±»ä¸åŒ¹é…çš„é—®é¢˜â—†ç›®æ ‡ç±»å’Œé€‚é…å™¨ç±»è§£è€¦ï¼Œæé«˜ç¨‹åºæ‰©å±•æ€§â—†ç¬¦åˆå¼€é—­åŸåˆ™ï¼Œå…·ä½“çš„æ“ä½œéƒ½åœ¨é€‚é…è€…ä¸­ï¼Œå®¢æˆ·ç«¯åªçŸ¥é“é€‚é…è€…ï¼Œæ‰©å±•åªéœ€å¯¹é€‚é…è€…æ‰©å±•å³å¯ ç¼ºç‚¹12â—†é€‚é…å™¨ç¼–å†™è¿‡ç¨‹éœ€è¦å…¨é¢è€ƒè™‘ï¼Œå¯èƒ½ä¼šå¢åŠ ç³»ç»Ÿçš„å¤æ‚æ€§â—†å¢åŠ ç³»ç»Ÿä»£ç å¯è¯»çš„éš¾åº¦ï¼Œå¦‚æˆ‘ä»¬è°ƒç”¨çš„æ˜¯Aæ¥å£å®ç°ï¼Œå…¶å®å†…éƒ¨å·²ç»è¢«é€‚é…æˆäº†Bæ¥å£çš„å®ç° æ‰©å±•12â—†å¯¹è±¡é€‚é…å™¨ï¼ˆç¬¦åˆç»„åˆå¤ç”¨åŸåˆ™ï¼Œå¹¶ä¸”ä½¿ç”¨å§”æ‰˜æœºåˆ¶ï¼‰â—†ç±»é€‚é…å™¨ï¼ˆé€šè¿‡ç±»ç»§æ‰¿å®ç°ï¼‰ ç›¸å…³çš„è®¾è®¡æ¨¡å¼é€‚é…å™¨æ¨¡å¼å’Œå¤–è§‚æ¨¡å¼ 123a éƒ½æ˜¯ç°æœ‰ç±»ç°å­˜ç³»ç»Ÿçš„å°è£…ï¼Œå‰è€…å¤ç”¨åŸæœ‰çš„æ¥å£ï¼Œåè€…å®šä¹‰äº†æ–°çš„æ¥å£b å‰è€…ä½¿åŸæœ‰çš„ä¸¤ä¸ªæ¥å£ååŒå·¥ä½œï¼Œåè€…åœ¨ç°æœ‰çš„ç³»ç»Ÿä¸­æä¾›ä¸€ä¸ªæ›´ä¸ºæ–¹ä¾¿çš„è®¿é—®å…¥å£c é€‚é…åŠ›åº¦ä¸åŒï¼Œåè€…é€‚é…æ•´ä¸ªå­ç³»ç»Ÿ é€‚é…å™¨æ¨¡å¼æ¼”ç»ƒ1ç±»é€‚é…å™¨é€šè¿‡ ç»§æ‰¿å…³ç³» è¾¾åˆ°é€‚é…çš„ç›®çš„ï¼Œè€Œå¯¹è±¡é€‚é…å™¨é€šè¿‡ ç»„åˆ è¾¾åˆ°é€‚é…ç›®çš„ ç±»é€‚é…å™¨æ¨¡å¼ è¢«é€‚é…è€… 12345678910111213141516171819package com.design.pattern.adapter.classadapter;import lombok.extern.slf4j.Slf4j;/** * Adaptee è¢«é€‚é…è€… * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class Adaptee &#123; /** * é€‚é…æ–¹æ³•ï¼Œæƒ³è¦å’Œç›®æ ‡ç±»ä¸€èµ·å·¥ä½œ */ public void adaptee()&#123; log.info(\"è¢«é€‚é…è€…...run\"); &#125;&#125; é€‚é…å™¨ï¼ˆé€‚é…è€…ï¼‰ 1234567891011121314151617181920212223package com.design.pattern.adapter.classadapter;import lombok.extern.slf4j.Slf4j;/** * Adapter * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class Adapter extends Adaptee implements Target &#123; /** * 1ã€é€‚é…è€…åªæ˜¯å®ç°ç›®æ ‡ç±»çš„æ¥å£ï¼Œå¹¶ä¸”ç»§æ‰¿è¢«é€‚é…ç±»ï¼Œè¿™æ ·ä½¿å¾—è¢«é€‚é…ç±»æ‹¥æœ‰ç›®æ ‡ç±»ç›¸å®¹çš„æ¥å£ * 2ã€åœ¨é€‚é…å™¨å®ç°ç›®æ ‡æ¥å£çš„æ–¹æ³•ä¸­è°ƒç”¨çˆ¶ç±»è¢«é€‚é…è€…çš„æ–¹æ³•ï¼Œè¿™æ ·å°±å¯ä»¥ç›´æ¥ä½¿ç”¨è¢«é€‚é…è€…çš„èƒ½åŠ› */ @Override public void run() &#123; // TODO è¿™é‡Œå¯ä»¥æ·»åŠ å…¶ä»–çš„æ“ä½œ log.info(\"é€‚é…å™¨...run\"); super.adaptee(); &#125;&#125; ç›®æ ‡æ¥å£ 1234567891011121314package com.design.pattern.adapter.classadapter;/** * Target ç›®æ ‡ç±»æ¥å£ * * @author shunhua * @date 2019-09-21 */public interface Target &#123; /** * ç›®æ ‡æ“ä½œ */ void run();&#125; ç›®æ ‡ç±» 123456789101112131415161718package com.design.pattern.adapter.classadapter;import lombok.extern.slf4j.Slf4j;/** * CurrTarget ç›®æ ‡æ¥å£çš„å®ç°ç±»ï¼Œå¯çœå»ï¼Œåªæ˜¯ä½œæ¯”è¾ƒ * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class CurrTarget implements Target &#123; @Override public void run() &#123; log.info(\"ç›®æ ‡...run\"); &#125;&#125; å®¢æˆ·ç«¯ 12345678910111213141516171819202122232425package com.design.pattern.adapter.classadapter;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-21 */public class Client &#123; @Test public void test()&#123; // ç›®æ ‡ç±»çš„æ“ä½œ Target target = new CurrTarget(); // ç›®æ ‡ç±»çš„æ–¹æ³• target.run(); // è¢«é€‚é…è€…é€šè¿‡é€‚é…å™¨è¿›è¡Œé€‚é…ï¼Œå¯ä»¥å’Œç›®æ ‡ç±»ä¸€èµ·å·¥ä½œ target = new Adapter(); // é€‚é…è€…çš„æ–¹æ³•ï¼Œå†…éƒ¨æ˜¯è¢«é€‚é…è€…çš„æ–¹æ³• target.run(); &#125;&#125; å¯¹è±¡é€‚é…æ¨¡å¼ è¢«é€‚é…è€… 12345678910111213141516171819package com.design.pattern.adapter.objectadapter;import lombok.extern.slf4j.Slf4j;/** * Adaptee è¢«é€‚é…è€… * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class Adaptee &#123; /** * é€‚é…æ–¹æ³•ï¼Œæƒ³è¦å’Œç›®æ ‡ç±»ä¸€èµ·å·¥ä½œ */ public void adaptee()&#123; log.info(\"è¢«é€‚é…è€…...run\"); &#125;&#125; é€‚é…å™¨ï¼ˆé€‚é…è€…ï¼‰ 12345678910111213141516171819202122232425262728package com.design.pattern.adapter.objectadapter;import lombok.extern.slf4j.Slf4j;/** * Adapter * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class Adapter implements Target &#123; /** * é€šè¿‡ç»„åˆ ï¼ˆä¹Ÿå¯ä»¥é€šè¿‡æ³¨å…¥çš„æ–¹å¼ä»£æ›¿ new å¯¹è±¡çš„æ–¹å¼ï¼Œè¿™æ ·æ–¹å¼æ›´å¸¸ç”¨ï¼‰ */ private Adaptee adaptee = new Adaptee(); /** * 1 é€‚é…å™¨æ˜¯å®ç°äº†ç›®æ ‡ç±»çš„æ¥å£ï¼Œä¸ºäº†æ˜¯è¢«é€‚é…è€…å’Œç›®æ ‡ç±»æ‹¥æœ‰åŒä¸€æ¥å£ * 2 é€šè¿‡ç»„åˆçš„æ–¹æ³•ï¼Œç›´æ¥åœ¨é€‚é…å™¨å®ç°ç›®æ ‡æ¥å£çš„æ–¹æ³•ä¸­è°ƒç”¨è¢«é€‚é…è€…å®ä¾‹çš„æ–¹æ³• */ @Override public void run() &#123; // TODO å¯ä»¥æ ¹æ®å…·ä½“ä¸šåŠ¡å¢åŠ å…¶ä»–çš„æ“ä½œ log.info(\"é€‚é…å™¨...run\"); adaptee.adaptee(); &#125;&#125; ç›®æ ‡æ¥å£ 1234567891011121314package com.design.pattern.adapter.objectadapter;/** * Target ç›®æ ‡ç±»æ¥å£ * * @author shunhua * @date 2019-09-21 */public interface Target &#123; /** * ç›®æ ‡æ“ä½œ */ void run();&#125; ç›®æ ‡ç±» 12345678910111213141516171819package com.design.pattern.adapter.objectadapter;;import lombok.extern.slf4j.Slf4j;/** * CurrTarget ç›®æ ‡æ¥å£çš„å®ç°ç±»ï¼Œå¯çœå»ï¼Œåªæ˜¯ä½œæ¯”è¾ƒ * * @author shunhua * @date 2019-09-21 */@Slf4jpublic class CurrTarget implements Target &#123; @Override public void run() &#123; log.info(\"ç›®æ ‡...run\"); &#125;&#125; å®¢æˆ·ç«¯ 12345678910111213141516171819202122232425package com.design.pattern.adapter.objectadapter;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-22 */public class Client &#123; @Test public void test()&#123; // ç›®æ ‡ç±» Target target = new CurrTarget(); target.run(); // é€šè¿‡é€‚é…å™¨æŠŠè¢«é€‚é…è€…è½¬æ¢æˆç›®æ ‡æ¥å£ç±»å‹ target = new Adapter(); // è°ƒç”¨é€‚é…å™¨å®ç°ç›®æ ‡æ¥å£çš„æ–¹æ³•ï¼Œå†…éƒ¨è°ƒç”¨çš„æ˜¯è¢«é€‚é…è€…çš„æ–¹æ³• target.run(); &#125;&#125; ç®€å•éœ€æ±‚1æ‰‹æœºç”µæºé€‚é…å™¨å¯ä»¥æŠŠ220väº¤æµç”µè½¬åŒ–ä¸º5vç›´æµç”µ ç›®æ ‡æ¥å£-5vç›´æµç”µ 123456789101112131415package com.design.pattern.adapter.demand;/** * DC5V ç›®æ ‡ç”µå‹ * * @author shunhua * @date 2019-09-22 */public interface DC5V &#123; /** * 5Vç›´æµç”µ * @return */ int outPutDC5V();&#125; éœ€è¦è¢«é€‚é…çš„ç±»-220väº¤æµç”µ 123456789101112131415161718192021package com.design.pattern.adapter.demand;import lombok.extern.slf4j.Slf4j;/** * AC220V éœ€è¦è¢«é€‚é…çš„ç”µå‹ * * @author shunhua * @date 2019-09-22 */@Slf4jpublic class AC220V &#123; /** * 220Väº¤æµç”µ * @return */ public int outputAC220V()&#123; return 220; &#125;&#125; å˜å‹å™¨-é€‚é…å™¨ 1234567891011121314151617181920212223242526package com.design.pattern.adapter.demand;import lombok.extern.slf4j.Slf4j;/** * PowerAdapter ç”µæºé€‚é…å™¨ * * @author shunhua * @date 2019-09-22 */@Slf4jpublic class PowerAdapter implements DC5V &#123; /** * é€šè¿‡ç»„åˆçš„æ–¹å¼ */ private AC220V ac220V = new AC220V(); @Override public int outPutDC5V() &#123; int ac = ac220V.outputAC220V(); int target = ac/44; // å˜å‹å¤„ç† log.info(String.format(\"é€‚é…å™¨å¤„ç†åï¼Œ%dVç”µå‹å˜ä¸º%dV\",220,target)); return 5; &#125;&#125; å®¢æˆ·ç«¯ 12345678910111213141516171819package com.design.pattern.adapter.demand;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-22 */public class Client &#123; @Test public void test() &#123; DC5V dc5V = new PowerAdapter(); // é€šè¿‡PowerAdapteré€‚é…ï¼ŒæŠŠ220Väº¤æµè½¬ä¸º5Vç›´æµç”µ dc5V.outPutDC5V(); &#125;&#125; æºç è§£æ12åœ¨SpringMVCä¸­ï¼Œå‰ç«¯æ§åˆ¶å™¨æ¥åˆ°è¯·æ±‚åä¼šé€šè¿‡å¤„ç†å™¨æ˜ å°„å™¨æ‰¾å¤„ç†å™¨ï¼Œç„¶åè¿”å›ä¸€ä¸ªå¤„ç†å™¨æ‰§è¡Œé“¾ï¼Œæ¥ç€é€šè¿‡åŒ¹é…å¤„ç†å™¨é€‚é…å™¨æ¥ç¡®å®šå“ªä¸€ä¸ªå¤„ç†å™¨é€‚é…å™¨å¯ä»¥é€‚é…å½“å‰çš„å¤„ç†å™¨ï¼Œç¡®å®šåæ‰§è¡Œå¤„ç†æ–¹æ³•ï¼Œç„¶åè¿”å›ModelAndViewã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // æ‰¾åˆ°å¤„ç†å™¨å¯¹åº”çš„å¤„ç†å™¨é€‚é…å™¨ HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // å®é™…è°ƒç”¨å¤„ç†å™¨ï¼Œç„¶åè¿”å›ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125; &#125; // å¤„ç†å™¨æ˜ å°„å™¨æ‰¾å¤„ç†å™¨é€»è¾‘ï¼ˆè¿”å›å¤„ç†å™¨æ‰§è¡Œé“¾ï¼ŒåŒ…å«äº†å¤„ç†å™¨ï¼‰/** * Return the HandlerExecutionChain for this request. * &lt;p&gt;Tries all handler mappings in order. * @param request current HTTP request * @return the HandlerExecutionChain, or &#123;@code null&#125; if no handler could be found */ @Nullable protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; &#125; return null; &#125; // åŒ¹é…åˆé€‚çš„å¤„ç†å™¨é€‚é…å™¨é€»è¾‘ /** * Return the HandlerAdapter for this handler object. * @param handler the handler object to find an adapter for * @throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error. */ protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; if (this.handlerAdapters != null) &#123; for (HandlerAdapter adapter : this.handlerAdapters) &#123; if (adapter.supports(handler)) &#123; return adapter; &#125; &#125; &#125; throw new ServletException(\"No adapter for handler [\" + handler + \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\"); &#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"æ¡¥æ¥æ¨¡å¼","slug":"design_pattern/structure_type/æ¡¥æ¥æ¨¡å¼","date":"2019-09-20T16:00:00.000Z","updated":"2020-08-09T09:35:41.268Z","comments":true,"path":"posts/563268dc/","link":"","permalink":"https://gentryhuang.com/posts/563268dc/","excerpt":"","text":"å®šä¹‰å°†æŠ½è±¡éƒ¨åˆ†ä¸å®ƒçš„å…·ä½“å®ç°éƒ¨åˆ†åˆ†ç¦»å¼€æ¥ï¼Œä½¿å®ƒä»¬éƒ½å¯ä»¥ç‹¬ç«‹åœ°å˜åŒ–ï¼ˆè¿™åœ¨ä¸€å®šç¨‹åº¦ä¸Šå®ç°è§£è€¦ï¼‰ã€‚æ¡¥æ¥æ¨¡å¼å°†ç»§æ‰¿å…³ç³»è½¬åŒ–æˆå…³è”å…³ç³»ï¼Œå®ƒé™ä½äº†ç±»ä¸ç±»ä¹‹é—´çš„è€¦åˆåº¦ï¼Œå‡å°‘äº†ç³»ç»Ÿä¸­ç±»çš„æ•°é‡ï¼Œé˜²æ­¢ç±»çˆ†ç‚¸ã€‚ä»å®ƒçš„å‘½åå¯ä»¥çœ‹å‡ºï¼Œbridgeæ˜¯æ¡¥æ¢çš„æ„æ€ï¼Œ å°†æ¡¥ä¸¤è¾¹è”ç³»èµ·æ¥ã€‚ç›®çš„å°±æ˜¯æŠŠä¸¤ä¸ªä¸åŒçš„ç±»ä¹‹é—´å»ºç«‹è”ç³»ï¼Œè€Œä¸¤ä¸ªç±»ä¹‹é—´å»ºç«‹è”ç³»çš„æ–¹å¼æœ‰å¾ˆå¤šï¼Œè€Œæ¡¥æ¥æ¨¡å¼æ˜¯é€šè¿‡ç»„åˆçš„æ–¹å¼å»ºç«‹ä¸¤ä¸ªä¸åŒç±»ä¹‹é—´çš„å…³ç³»ï¼Œè€Œä¸æ˜¯ç»§æ‰¿ã€‚è¿™ä¹Ÿç¬¦åˆåˆæˆå¤ç”¨åŸåˆ™ï¼šä¼˜å…ˆé€šè¿‡ç»„åˆçš„æ–¹å¼å»ºç«‹ä¸¤ä¸ªç±»ä¹‹é—´è”ç³»ï¼Œè€Œä¸æ˜¯ç»§æ‰¿ï¼Œç»§æ‰¿è¿‡å¤šä¼šå‘ç”Ÿç±»çˆ†ç‚¸çš„æƒ…å†µã€‚è¯´æ˜ä¸€ç‚¹:è¿™é‡Œè¯´çš„æŠ½è±¡éƒ¨åˆ†å’Œå…·ä½“å®ç°éƒ¨åˆ†ï¼Œå¹¶ä¸å±€é™ä¸€ä¸ªæ˜¯æŠ½è±¡çš„ï¼Œå¦ä¸€ä¸ªæ˜¯å…·ä½“çš„å®ç°ï¼Œè¿™åªæ˜¯ä»æ¦‚å¿µä¸Šå»å®šä¹‰ã€‚ 1å°†æŠ½è±¡éƒ¨åˆ†ä¸å®ƒçš„å…·ä½“å®ç°éƒ¨åˆ†åˆ†ç¦»ï¼Œå…¶å®è¿™å¹¶ä¸æ˜¯å°†æŠ½è±¡ç±»ä¸ä»–çš„æ´¾ç”Ÿç±»åˆ†ç¦»ï¼Œè€Œæ˜¯æŠ½è±¡ç±»å’Œå®ƒçš„æ´¾ç”Ÿç±»ç”¨æ¥å®ç°è‡ªå·±çš„å¯¹è±¡ã€‚æˆ–è€…è¯´åœ¨ä¸€ä¸ªç³»ç»Ÿçš„æŠ½è±¡åŒ–å’Œå®ç°åŒ–ä¹‹é—´ä½¿ç”¨å…³è”å…³ç³»ï¼ˆç»„åˆæˆ–è€…èšåˆå…³ç³»ï¼‰è€Œä¸æ˜¯ç»§æ‰¿å…³ç³»ï¼Œä»è€Œä½¿ä¸¤è€…å¯ä»¥ç›¸å¯¹ç‹¬ç«‹åœ°å˜åŒ–ã€‚ ç±»å‹ç»“æ„å‹ é€‚ç”¨åœºæ™¯ æŠ½è±¡å’Œå…·ä½“å®ç°ä¹‹é—´å¢åŠ æ›´å¤šçš„çµæ´»æ€§ 1ä½¿ç”¨æ¡¥æ¥æ¨¡å¼å°±å¯ä»¥é¿å…åœ¨è¿™ä¸¤ä¸ªå±‚æ¬¡ä¹‹é—´å»ºç«‹é™æ€çš„ç»§æ‰¿å…³ç³»ï¼Œè€Œæ˜¯å»ºç«‹å…³è”å…³ç³»ã€‚æ­¤å¤–ï¼ŒæŠ½è±¡éƒ¨åˆ†å’Œå…·ä½“å®ç°éƒ¨åˆ†ï¼Œå®ƒä»¬éƒ½å¯ä»¥åˆ†åˆ«é€šè¿‡ç»§æ‰¿å…³ç³»ç‹¬ç«‹æ‰©å±•ï¼Œå¹¶ä¸”äº’ä¸å½±å“ï¼Œå°±å¯ä»¥åŠ¨æ€åœ°å°†ä¸€ä¸ªæŠ½è±¡åŒ–å­ç±»çš„å¯¹è±¡å’Œä¸€ä¸ªå…·ä½“å®ç°åŒ–å­ç±»çš„å¯¹è±¡è¿›è¡Œç»„åˆï¼Œè¿™æ ·å°±æŠŠæŠ½è±¡åŒ–è§’è‰²å’Œå…·ä½“å®ç°åŒ–è§’è‰²å®ç°äº†è§£è€¦ã€‚ ä¸€ä¸ªç±»å­˜åœ¨ä¸¤ä¸ªï¼ˆæˆ–å¤šä¸ªï¼‰ç‹¬ç«‹å˜åŒ–çš„ç»´åº¦ï¼Œä¸”è¿™ä¸¤ä¸ªï¼ˆæˆ–å¤šä¸ªï¼‰ç»´åº¦éƒ½éœ€è¦ç‹¬ç«‹è¿›è¡Œæ‰©å±• 1æŠ½è±¡çš„éƒ¨åˆ†å¯ä»¥ç‹¬ç«‹æ‰©å±•ï¼Œå…·ä½“å®ç°ä¹Ÿå¯ä»¥ç‹¬ç«‹æ‰©å±• ä¸å¸Œæœ›ä½¿ç”¨ç»§æ‰¿ï¼Œæˆ–å› ä¸ºå¤šå±‚ç»§æ‰¿å¯¼è‡´ç³»ç»Ÿç±»çš„ä¸ªæ•°å‰§å¢ ä¼˜ç‚¹ åˆ†ç¦»æŠ½è±¡éƒ¨åˆ†åŠå…¶å…·ä½“å®ç°éƒ¨åˆ† 1å› ä¸ºæ¡¥æ¥æ¨¡å¼ä½¿ç”¨äº†ç»„åˆï¼Œä½¿ç”¨å¯¹è±¡é—´çš„å…³è”å…³ç³»ï¼Œæ¥è§£è€¦äº†æŠ½è±¡å’Œå…·ä½“å®ç°ä¹‹é—´çš„å›ºæœ‰ç»‘å®šå…³ç³»ï¼Œä½¿æŠ½è±¡å’Œå®ç°å¯ä»¥æ²¿ç€å„è‡ªçš„ç»´åº¦è¿›è¡Œæ‰©å±•ã€å˜åŒ–ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒæŠ½è±¡å’Œå®ç°ä¸åœ¨åŒä¸€ä¸ªç»§æ‰¿å±‚æ¬¡ç»“æ„ä¸­ï¼Œä»è€Œé€šè¿‡ç»„åˆæ¥è·å¾—å¤šç»´åº¦çš„ç»„åˆå¯¹è±¡ã€‚ æé«˜äº†ç³»ç»Ÿçš„å¯æ‰©å±•æ€§ 1åœ¨ä¸¤ä¸ªå˜åŒ–ç»´åº¦ä¸­ï¼Œæ‰©å±•ä»»æ„ä¸€ä¸ªç»´åº¦éƒ½ä¸éœ€è¦ä¿®æ”¹åŸæœ‰çš„ç³»ç»Ÿ ç¬¦åˆå¼€é—­åŸåˆ™ ç¬¦åˆåˆæˆå¤ç”¨åŸåˆ™ ç¼ºç‚¹ å¢åŠ äº†ç³»ç»Ÿçš„ç†è§£ä¸è®¾è®¡éš¾åº¦ 1ç”±äºç±»ä¹‹é—´çš„å…³ç³»å»ºç«‹åœ¨æŠ½è±¡å±‚ï¼Œè¦æ±‚æˆ‘ä»¬åœ¨ç¼–ç çš„æ—¶å€™ï¼Œä¸€å¼€å§‹å°±è¦é’ˆå¯¹æŠ½è±¡å±‚è¿›è¡Œè®¾è®¡å’Œç¼–ç¨‹ éœ€è¦æ­£ç¡®åœ°è¯†åˆ«å‡ºç³»ç»Ÿä¸­ä¸¤ä¸ªç‹¬ç«‹å˜åŒ–çš„ç»´åº¦ ç›¸å…³è®¾è®¡æ¨¡å¼ ç»„åˆæ¨¡å¼ 1ç»„åˆæ¨¡å¼æ›´å¼ºè°ƒçš„æ˜¯éƒ¨åˆ†å’Œæ•´ä½“é—´çš„ç»„åˆï¼Œè€Œæ¡¥æ¥æ¨¡å¼å¼ºè°ƒçš„æ˜¯å¹³è¡Œçº§åˆ«ä¸Šä¸åŒç±»çš„ç»„åˆ é€‚é…å™¨æ¨¡å¼ 1é€‚é…å™¨æ¨¡å¼å’Œæ¡¥æ¥æ¨¡å¼éƒ½æ˜¯ä¸ºäº†è®©ä¸¤ä¸ªä¸œè¥¿é…åˆå·¥ä½œï¼Œä½†å®ƒä»¬ä¸¤ä¸ªçš„ç›®çš„ä¸ä¸€æ ·ï¼Œé€‚é…å™¨æ¨¡å¼æ˜¯æ”¹å˜å·²æœ‰çš„æ¥å£ï¼Œè®©å®ƒä»¬ä¹‹é—´å¯ä»¥ç›¸äº’é…åˆï¼Œè€Œæ¡¥æ¥æ¨¡å¼æ˜¯åˆ†ç¦»æŠ½è±¡å’Œå…·ä½“å®ç°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé€‚é…å™¨æ¨¡å¼å¯ä»¥æŠŠåŠŸèƒ½ä¸Šç›¸ä¼¼ä½†æ˜¯æ¥å£ä¸åŒçš„ç±»é€‚é…èµ·æ¥ï¼Œè€Œæ¡¥æ¥æ¨¡å¼æ˜¯æŠŠç±»çš„æŠ½è±¡å’Œç±»çš„å…·ä½“å®ç°åˆ†ç¦»å¼€ï¼Œç„¶ååœ¨æ­¤åŸºç¡€ä¸Šä½¿è¿™äº›å±‚æ¬¡ç»“æ„ç»“åˆèµ·æ¥ã€‚ å…³é”®ä¸€ç‚¹æ¡¥æ¥æ¨¡å¼é‡è¦çš„å°±æ˜¯æŠŠæŠ½è±¡å’Œå…·ä½“å®ç°åˆ†ç¦»å¼€ï¼Œä¸­é—´é€šè¿‡ç»„åˆæ¥æ­å»ºå®ƒä»¬ä¹‹é—´çš„æ¡¥æ¢ æ¡ˆä¾‹åˆ†æ åœºæ™¯ 121ï¼‰æœ‰ä¸¤ä¸ªé“¶è¡Œï¼Œåˆ†åˆ«æ˜¯ABCå’ŒICBCé“¶è¡Œï¼ŒåŒæ—¶æœ‰ä¸¤ä¸ªè´¦å·ï¼Œåˆ†åˆ«æ˜¯å®šæœŸè´¦å·å’Œæ´»æœŸè´¦å·ã€‚2ï¼‰ä½¿ç”¨æ¡¥æ¥æ¨¡å¼å¯ä»¥ è®©å®ç°ï¼ˆè¿™é‡Œå°±æ˜¯è´¦å·å…·ä½“å®ç°ï¼‰å’ŒæŠ½è±¡ï¼ˆè¿™é‡Œå°±æ˜¯æŠ½è±¡çš„é“¶è¡Œç±»ï¼‰åˆ†ç¦»ï¼Œé“¶è¡Œå±æ€§å¢åŠ ä¿®æ”¹é“¶è¡Œç±»å³å¯ï¼Œè´¦å·ç±»å±æ€§å¢åŠ ä¿®æ”¹è´¦å·ç±»å³å¯ã€‚é€»è¾‘æ¸…æ™°ï¼ŒåŒæ—¶ä¹Ÿè§£å†³äº†ä¸Šè¿°ç±»çˆ†ç‚¸çš„æƒ…å†µã€‚ ç¼–ç  è´¦å·æ¥å£ Account 12345678910public interface Account &#123; /** * å¼€æˆ· */ Account openAccount(); /** * å¼€æˆ·ç±»å‹ */ void showAccountType();&#125; â€‹ è´¦å·çš„ä¸¤ä¸ªå®ç°ç±» SavingAccountå’Œ DepositAccount 1234567891011121314151617181920212223242526public class SavingAccount implements Account &#123; @Override public Account openAccount() &#123; System.out.println(\"SavingAccount--å¼€æ´»æœŸè´¦å·\"); return new SavingAccount(); &#125; @Override public void showAccountType() &#123; System.out.println(\"SavingAccount--è¿™æ˜¯ä¸€ä¸ªæ´»æœŸè´¦å·\"); &#125;&#125;-----public class DepositAccount implements Account &#123; @Override public Account openAccount() &#123; System.out.println(\"DepositAccount--å¼€å®šæœŸè´¦å·\"); return new DepositAccount(); &#125; @Override public void showAccountType() &#123; System.out.println(\"DepositAccouont--è¿™æ˜¯ä¸€ä¸ªå®šæœŸè´¦å·\"); &#125;&#125; â€‹ é“¶è¡ŒæŠ½è±¡ç±» Bank 123456789101112131415161718192021222324252627public abstract class Bank &#123; /** * è¿™é‡Œè¦å†™æˆä¸€ä¸ªæŠ½è±¡çš„ï¼Œå› ä¸ºè¦æŠŠAccountå¼•å…¥åˆ°Banké‡Œé¢ï¼Œé€š * è¿‡è¿™ç§ç»„åˆçš„æ–¹å¼ï¼ŒæŠŠAccountçš„è¡Œä¸ºäº¤ç»™Bankçš„å­ç±»æ¥å®ç°ï¼Œå³ * Bankè¿™ä¸ªæŠ½è±¡ç±»ä¸­çš„æŸä¸ªè¡Œä¸ºè¦å§”æ‰˜ç»™Accountè¿™ä¸ªæ¥å£çš„å®ç°ï¼Œ * æŠ½è±¡å’Œå…·ä½“çš„å®ç°åˆ†ç¦»æŒ‡å®šçš„å°±æ˜¯è¿™ç§æƒ…å†µã€‚ */ /** * è¦äº¤ç»™å­ç±»ï¼Œå£°æ˜ä¸ºprotectedï¼Œè¿™æ ·åªæœ‰å­ç±»èƒ½å¤Ÿæ‹¿åˆ° */ protected Account account; /** * é€šè¿‡æ„é€ å™¨æŠŠAccountä¼ è¿‡æ¥ï¼Œä¹Ÿå¯ä»¥é€šè¿‡setteræ³¨å…¥çš„æ–¹å¼èµ‹å€¼ */ public Bank(Account account)&#123; this.account = account; &#125; /** * è¿™ä¸ªæ–¹æ³•è¦å‚ç…§Accountæ¥å£ä¸­çš„æ–¹æ³•ï¼Œå› ä¸ºBanké‡Œé¢çš„å…·ä½“æ–¹æ³•è¦å§”æ‰˜ç»™Accounté‡Œé¢ * çš„openAccountæ–¹æ³•ï¼Œä½†è¿™é‡Œé¢æ–¹æ³•åä¸è¦æ±‚ä¸€å®šä¸€è‡´ */ abstract Account openAccount();&#125; â€‹ é“¶è¡ŒæŠ½è±¡ç±»çš„å­ç±» ABCBankå’ŒICBCBank 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ABCBank extends Bank &#123; /** * æ„é€ çš„æ—¶å€™ä¼ å…¥çš„æ˜¯å“ªä¸ªAccountå°±è¿”å›å“ªä¸€ä¸ªAccount(openAccountæ–¹æ³•) * @param account */ public ABCBank(Account account) &#123; super(account); &#125; /** * è¿™é‡Œè¿”å›çš„å°±æ˜¯çˆ¶ç±»ä¸­çš„Account * @return */ @Override Account openAccount() &#123; System.out.println(\"ABCBank--å¼€æˆ·ä¸­å›½å†œä¸šé“¶è¡Œè´¦å·\"); // å¾ˆé‡è¦ï¼Œè¦ä½¿ç”¨çˆ¶ç±»é‡Œç»„åˆè¿›æ¥çš„Accountï¼Œä¸ç„¶æ¡¥æ¥æ¨¡å¼å°±æ²¡ä»€ä¹ˆæ„ä¹‰äº† account.openAccount(); return account; &#125;&#125;---public class ICBCBank extends Bank &#123; /** * æ„é€ çš„æ—¶å€™ä¼ å…¥çš„æ˜¯å“ªä¸ªAccountå°±è¿”å›å“ªä¸€ä¸ªAccount(openAccountæ–¹æ³•) * @param account */ public ICBCBank(Account account) &#123; super(account); &#125; /** * è¿™é‡Œè¿”å›çš„å°±æ˜¯çˆ¶ç±»ä¸­çš„Account * @return */ @Override Account openAccount() &#123; System.out.println(\"ICBC--å¼€æˆ·ä¸­å›½å·¥å•†é“¶è¡Œè´¦å·\"); // å¾ˆé‡è¦ï¼Œè¦ä½¿ç”¨çˆ¶ç±»é‡Œç»„åˆè¿›æ¥çš„Accountï¼Œä¸ç„¶æ¡¥æ¥æ¨¡å¼å°±æ²¡ä»€ä¹ˆæ„ä¹‰äº† account.openAccount(); return account; &#125;&#125; å•å…ƒæµ‹è¯• TestDemo 1234567891011121314151617181920212223242526272829public class TestDemo &#123; public static void main(String[] args) &#123; // ICBCBank-DepositAccount Bank icbcBank = new ICBCBank(new DepositAccount()); Account icbcAccount = icbcBank.openAccount(); System.out.println(\"**************************\"); icbcAccount.showAccountType(); System.out.println(\"--------------------------\"); // ICBCBank-SavingAccount Bank icbcBank2 = new ICBCBank(new SavingAccount()); Account icbcAccount2 = icbcBank2.openAccount(); System.out.println(\"**************************\"); icbcAccount2.showAccountType(); System.out.println(\"--------------------------\"); // ABCBank-DepositAccount Bank abcBank2 = new ABCBank(new DepositAccount()); Account abcAccount2 = abcBank2.openAccount(); System.out.println(\"**************************\"); abcAccount2.showAccountType(); System.out.println(\"--------------------------\"); // ABCBank-SavingAccount Bank abcBank = new ABCBank(new SavingAccount()); Account abcAccount = abcBank.openAccount(); System.out.println(\"**************************\"); abcAccount.showAccountType(); &#125;&#125; æ€»ç»“ é€šè¿‡æ¡¥æ¥æ¨¡å¼ï¼ŒæŠŠå®ç°éƒ¨åˆ†Accountï¼ˆAccountçš„å…·ä½“å®ç°ç±»ï¼‰å’ŒæŠ½è±¡éƒ¨åˆ†Bankï¼ˆBankæŠ½è±¡ç±»ï¼‰è¿›è¡Œäº†æ¡¥æ¥ï¼Œä½¿ç”¨ç»„åˆä½œä¸ºä¸€æ ¹çº¿è¿æ¥å®ƒä»¬ã€‚å½“ç„¶ä¹Ÿæœ‰èšåˆçš„æ–¹å¼å®ç°æ¡¥æ¥ã€‚ æ¡¥æ¥æ¨¡å¼åœ¨JDKæºç ä¸­çš„åº”ç”¨å®ç°éƒ¨åˆ†1java.sql.Driveræ¥å£çš„å®ç°ï¼š å¦‚MySQLçš„Driverï¼ŒOracleçš„Driver Driveræ¥å£ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package java.sql;import java.util.logging.Logger;/** * The interface that every driver class must implement. * &lt;P&gt;The Java SQL framework allows for multiple database drivers. * * &lt;P&gt;Each driver should supply a class that implements * the Driver interface. * * &lt;P&gt;The DriverManager will try to load as many drivers as it can * find and then for any given connection request, it will ask each * driver in turn to try to connect to the target URL. * * &lt;P&gt;It is strongly recommended that each Driver class should be * small and standalone so that the Driver class can be loaded and * queried without bringing in vast quantities of supporting code. * * &lt;P&gt;When a Driver class is loaded, it should create an instance of * itself and register it with the DriverManager. This means that a * user can load and register a driver by calling: * &lt;p&gt; * &#123;@code Class.forName(\"foo.bah.Driver\")&#125; * &lt;p&gt; * A JDBC driver may create a &#123;@linkplain DriverAction&#125; implementation in order * to receive notifications when &#123;@linkplain DriverManager#deregisterDriver&#125; has * been called. * @see DriverManager * @see Connection * @see DriverAction */public interface Driver &#123; Connection connect(String url, java.util.Properties info) throws SQLException; boolean acceptsURL(String url) throws SQLException; DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info) throws SQLException; int getMajorVersion(); int getMinorVersion(); boolean jdbcCompliant(); public Logger getParentLogger() throws SQLFeatureNotSupportedException;&#125; Driveræ¥å£çš„MySqlé©±åŠ¨å®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142package com.mysql.cj.jdbc;import java.sql.SQLException;/** * The Java SQL framework allows for multiple database drivers. Each driver should supply a class that implements the Driver interface * * &lt;p&gt; * The DriverManager will try to load as many drivers as it can find and then for any given connection request, it will ask each driver in turn to try to * connect to the target URL. * * &lt;p&gt; * It is strongly recommended that each Driver class should be small and standalone so that the Driver class can be loaded and queried without bringing in vast * quantities of supporting code. * * &lt;p&gt; * When a Driver class is loaded, it should create an instance of itself and register it with the DriverManager. This means that a user can load and register a * driver by doing Class.forName(\"foo.bah.Driver\") */public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; // // Register ourselves with the DriverManager // static &#123; try &#123; // æŠŠé©±åŠ¨æ³¨å†Œåˆ°DriverManagerä¸­ java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125; &#125; /** * Construct a new driver and register it with DriverManager * * @throws SQLException * if a database error occurs. */ public Driver() throws SQLException &#123; // Required for Class.forName().newInstance() &#125;&#125; æŠ½è±¡éƒ¨åˆ†1java.sql.DriverManagerè¿™ä¸ªç±»ä½œä¸ºæŠ½è±¡éƒ¨åˆ†ï¼Œå®ƒå¹¶ä¸æ˜¯æŠ½è±¡ç±»ã€‚å†æ¬¡è¯´æ˜ï¼ŒæŠ½è±¡éƒ¨åˆ†å¹¶ä¸ä¸€å®šå°±æ˜¯æŠ½è±¡ç±»æˆ–æ¥å£ï¼Œåªæ˜¯ä»æ¡¥æ¥æ¨¡å¼æ•´ä½“çœ‹ï¼ŒæŠŠå®ƒåˆ†ä¸ºä¸¤å¤§éƒ¨åˆ†ã€‚registeredDriversä½œä¸ºå®ç°éƒ¨åˆ†ç»„åˆåˆ°æŠ½è±¡éƒ¨åˆ†ã€‚ DriverInfoå®ç°éƒ¨åˆ†çš„çˆ¶ç±»å‹æ¥å£Driveråªæ˜¯ä½œä¸ºDriverInfoçš„ä¸€ä¸ªå±æ€§ 123456789101112131415161718192021222324252627282930class DriverInfo &#123; final Driver driver; DriverAction da; DriverInfo(Driver driver, DriverAction action) &#123; this.driver = driver; da = action; &#125; @Override public boolean equals(Object other) &#123; return (other instanceof DriverInfo) &amp;&amp; this.driver == ((DriverInfo) other).driver; &#125; @Override public int hashCode() &#123; return driver.hashCode(); &#125; @Override public String toString() &#123; return (\"driver[className=\" + driver + \"]\"); &#125; DriverAction action() &#123; return da; &#125;&#125; DriverManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209 package java.sql; import java.util.Iterator; import java.util.ServiceLoader; import java.security.AccessController; import java.security.PrivilegedAction; import java.util.concurrent.CopyOnWriteArrayList; import sun.reflect.CallerSensitive; import sun.reflect.Reflection; /** * @see Driver * @see Connection */ public class DriverManager &#123; // æ³¨å†Œ JDBC driver çš„åˆ—è¡¨ private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;(); private static volatile int loginTimeout = 0; private static volatile java.io.PrintWriter logWriter = null; private static volatile java.io.PrintStream logStream = null; // Used in println() to synchronize logWriter private final static Object logSync = new Object(); /* Prevent the DriverManager class from being instantiated. */ private DriverManager()&#123;&#125; /** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the &#123;@code ServiceLoader&#125; mechanism */ static &#123; loadInitialDrivers(); println(\"JDBC DriverManager initialized\"); &#125; /** * The &lt;code&gt;SQLPermission&lt;/code&gt; constant that allows the * setting of the logging stream. * @since 1.3 */ final static SQLPermission SET_LOG_PERMISSION = new SQLPermission(\"setLog\"); /** * The &#123;@code SQLPermission&#125; constant that allows the * un-register a registered JDBC driver. * @since 1.8 */ final static SQLPermission DEREGISTER_DRIVER_PERMISSION = new SQLPermission(\"deregisterDriver\"); //--------------------------JDBC 2.0----------------------------- /** * Retrieves the log writer. * * The &lt;code&gt;getLogWriter&lt;/code&gt; and &lt;code&gt;setLogWriter&lt;/code&gt; * methods should be used instead * of the &lt;code&gt;get/setlogStream&lt;/code&gt; methods, which are deprecated. * @return a &lt;code&gt;java.io.PrintWriter&lt;/code&gt; object * @see #setLogWriter * @since 1.2 */ public static java.io.PrintWriter getLogWriter() &#123; return logWriter; &#125; public static void setLogWriter(java.io.PrintWriter out) &#123; SecurityManager sec = System.getSecurityManager(); if (sec != null) &#123; sec.checkPermission(SET_LOG_PERMISSION); &#125; logStream = null; logWriter = out; &#125; @CallerSensitive public static Connection getConnection(String url, java.util.Properties info) throws SQLException &#123; return (getConnection(url, info, Reflection.getCallerClass())); &#125; @CallerSensitive public static Connection getConnection(String url, String user, String password) throws SQLException &#123; java.util.Properties info = new java.util.Properties(); if (user != null) &#123; info.put(\"user\", user); &#125; if (password != null) &#123; info.put(\"password\", password); &#125; return (getConnection(url, info, Reflection.getCallerClass())); &#125; @CallerSensitive public static Connection getConnection(String url) throws SQLException &#123; java.util.Properties info = new java.util.Properties(); return (getConnection(url, info, Reflection.getCallerClass())); &#125; /** * Attempts to locate a driver that understands the given URL. * The &lt;code&gt;DriverManager&lt;/code&gt; attempts to select an appropriate driver from * the set of registered JDBC drivers. * * @param url a database URL of the form * &lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt; * @return a &lt;code&gt;Driver&lt;/code&gt; object representing a driver * that can connect to the given URL * @exception SQLException if a database access error occurs */ @CallerSensitive public static Driver getDriver(String url) throws SQLException &#123; println(\"DriverManager.getDriver(\\\"\" + url + \"\\\")\"); Class&lt;?&gt; callerClass = Reflection.getCallerClass(); for (DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerClass)) &#123; try &#123; if(aDriver.driver.acceptsURL(url)) &#123; // Success! println(\"getDriver returning \" + aDriver.driver.getClass().getName()); return (aDriver.driver); &#125; &#125; catch(SQLException sqe) &#123; // Drop through and try the next driver. &#125; &#125; else &#123; println(\" skipping: \" + aDriver.driver.getClass().getName()); &#125; &#125; println(\"getDriver: no suitable driver\"); throw new SQLException(\"No suitable driver\", \"08001\"); &#125; /** * Registers the given driver with the &#123;@code DriverManager&#125;. * A newly-loaded driver class should call * the method &#123;@code registerDriver&#125; to make itself * known to the &#123;@code DriverManager&#125;. If the driver is currently * registered, no action is taken. * * @param driver the new JDBC Driver that is to be registered with the * &#123;@code DriverManager&#125; * @exception SQLException if a database access error occurs * @exception NullPointerException if &#123;@code driver&#125; is null */ public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException &#123; registerDriver(driver, null); &#125; /** * Registers the given driver with the &#123;@code DriverManager&#125;. * A newly-loaded driver class should call * the method &#123;@code registerDriver&#125; to make itself * known to the &#123;@code DriverManager&#125;. If the driver is currently * registered, no action is taken. * * @param driver the new JDBC Driver that is to be registered with the * &#123;@code DriverManager&#125; * @param da the &#123;@code DriverAction&#125; implementation to be used when * &#123;@code DriverManager#deregisterDriver&#125; is called * @exception SQLException if a database access error occurs * @exception NullPointerException if &#123;@code driver&#125; is null * @since 1.8 */ public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException &#123; /* Register the driver if it has not already been added to our list */ if(driver != null) &#123; registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); &#125; else &#123; // This is for compatibility with the original DriverManager throw new NullPointerException(); &#125; println(\"registerDriver: \" + driver); &#125;&#125; â€‹ â€‹ â€‹ â€‹ â€‹","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"è£…é¥°è€…æ¨¡å¼","slug":"design_pattern/structure_type/è£…é¥°è€…æ¨¡å¼","date":"2019-09-18T16:00:00.000Z","updated":"2020-08-09T09:37:50.231Z","comments":true,"path":"posts/a708a60d/","link":"","permalink":"https://gentryhuang.com/posts/a708a60d/","excerpt":"","text":"å®šä¹‰åœ¨ä¸æ”¹å˜åŸæœ‰å¯¹è±¡çš„åŸºç¡€ä¸Šï¼Œå°†åŠŸèƒ½é™„åŠ åˆ°å¯¹è±¡ä¸Šã€‚æä¾›äº†æ¯”ç»§æ‰¿æ›´æœ‰å¼¹æ€§çš„æ›¿ä»£æ–¹æ¡ˆï¼ˆæ‰©å±•åŸæœ‰å¯¹è±¡åŠŸèƒ½ï¼‰ã€‚ ç±»å‹ç»“æ„å‹ åº”ç”¨åœºæ™¯12â—†æ‰©å±•ä¸€ä¸ªç±»çš„åŠŸèƒ½æˆ–ç»™ä¸€ä¸ªç±»æ·»åŠ é™„åŠ èŒè´£â—†åŠ¨æ€çš„ç»™ä¸€ä¸ªå¯¹è±¡æ·»åŠ åŠŸèƒ½ï¼Œè¿™äº›åŠŸèƒ½å¯ä»¥å†åŠ¨æ€çš„æ’¤é”€ ä¼˜ç‚¹123â—†ç»§æ‰¿çš„æœ‰åŠ›è¡¥å……ï¼Œæ¯”ç»§æ‰¿çµæ´»ï¼Œä¸æ”¹å˜åŸæœ‰å¯¹è±¡çš„æƒ…å†µä¸‹ç»™ä¸€ä¸ªå¯¹è±¡æ‰©å±•åŠŸèƒ½ã€‚ä¸€èˆ¬æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç»§æ‰¿å®ç°åŠŸèƒ½çš„æ‰©å±•ï¼Œå¦‚æœéœ€è¦æ‰©å±•çš„åŠŸèƒ½ç§ç±»ç¹å¤šï¼Œé‚£ä¹ˆåŠ¿å¿…ä¼šç”Ÿæˆå¾ˆå¤šå­ç±»ï¼Œè¿™æ— ç–‘å¢åŠ äº†ç³»ç»Ÿçš„å¤æ‚æ€§ã€‚å¹¶ä¸”ä½¿ç”¨ç»§æ‰¿éœ€è¦æå‰é¢„çŸ¥å“ªäº›åŠŸèƒ½ï¼Œå› ä¸ºç»§æ‰¿å…³ç³»åœ¨ç¼–è¯‘çš„æ—¶å€™å°±ç¡®å®šäº†ã€‚è€Œè£…é¥°è€…æ¨¡å¼å¯ä»¥åŠ¨æ€åœ°åŠ å…¥ã€‚å…¶å®è£…é¥°è€…æ¨¡å¼ä¹Ÿæ˜¯å»ºç«‹åœ¨ç»§æ‰¿çš„å…³ç³»åŸºç¡€ä¹‹ä¸Šçš„ï¼Œæ³¨æ„ï¼Œè¿™ä¸æ„å‘³ç€å°±ä¸ä½¿ç”¨ç»§æ‰¿äº†ï¼Œç»§æ‰¿ä¹Ÿæ˜¯æ‰©å±•å½¢å¼ä¹‹ä¸€ï¼Œåªæ˜¯æŸäº›æ—¶å€™ä¸ä¸€å®šèƒ½è¾¾åˆ°å¼¹æ€§è®¾è®¡çš„æœ€ä½³æ–¹å¼ã€‚â—†é€šè¿‡ä½¿ç”¨ä¸åŒè£…é¥°ç±»ä»¥åŠè¿™äº›è£…é¥°ç±»çš„æ’åˆ—ç»„åˆï¼Œå¯ä»¥å®ç°ä¸åŒæ•ˆæœâ—†ç¬¦åˆå¼€é—­åŸåˆ™ï¼Œè£…é¥°è€…å’Œè¢«è£…é¥°è€…å¯ä»¥ç‹¬ç«‹å˜åŒ–ï¼ŒåŸæœ‰çš„ä»£ç ä¸éœ€è¦æ”¹å˜ã€‚å…¶å®è£…é¥°è€…åšçš„æ˜¯æŠŠè£…é¥°åŠŸèƒ½ä»ç±»ä¸­ç§»å‡ºå»ï¼Œè¿™æ ·ç®€åŒ–äº†åŸæ¥è¢«è£…é¥°çš„ç±»ï¼ŒåŒæ—¶æŠŠç±»çš„æ ¸å¿ƒèŒè´£å’Œè£…é¥°åŠŸèƒ½åŒºåˆ†å¼€ã€‚ ç¼ºç‚¹12â—†ä¼šå‡ºç°æ›´å¤šçš„ä»£ç ï¼Œæ›´å¤šçš„ç±»ï¼Œå¢åŠ ç¨‹åºå¤æ‚æ€§ã€‚è£…é¥°è€…æ¨¡å¼å¯èƒ½ä¼šæ¯”ç»§æ‰¿æ–¹å¼çš„ä½¿ç”¨çš„ç±»è¦å°‘ï¼Œä½†æ˜¯å¯¹è±¡å¾ˆå¤šï¼Œå¹¶ä¸”è¿™äº›å¯¹è±¡ç±»å‹æ˜¯ä¸€æ ·çš„ï¼Œå› ä¸ºè£…é¥°è€…ä¼šç»§æ‰¿è¢«è£…é¥°ç±»ï¼Œè€Œè¢«è£…é¥°ç±»åˆæœ‰å…·ä½“çš„å®ä½“ï¼Œè¿™äº›å®ä½“å¯¹è±¡ç±»å‹åˆä¸€æ ·ï¼Œæ‰€æœ‰æ’æŸ¥é—®é¢˜å¢åŠ äº†éš¾åº¦ã€‚â—†åŠ¨æ€è£…é¥°æ—¶ï¼Œå¤šå±‚è£…é¥°æ—¶ä¼šæ›´å¤æ‚ å…³è”çš„è®¾è®¡æ¨¡å¼è£…é¥°è€…æ¨¡å¼å’Œä»£ç†æ¨¡å¼ 121 è£…é¥°è€…æ¨¡å¼å…³æ³¨åŠ¨æ€åœ°æ·»åŠ æ–¹æ³•ï¼Œä»£ç†æ¨¡å¼å…³æ³¨äºæ§åˆ¶å¯¹å¯¹è±¡çš„è®¿é—®2 ä»£ç†æ¨¡å¼ä¸­çš„ä»£ç†ç±»å¯ä»¥å¯¹å®ƒçš„å®¢æˆ·éšè—ä¸€ä¸ªå¯¹è±¡çš„å…·ä½“ä¿¡æ¯ï¼Œé€šå¸¸åœ¨ä½¿ç”¨ä»£ç†æ¨¡å¼çš„æ—¶å€™å¸¸å¸¸åœ¨ä»£ç†ç±»ä¸­åˆ›å»ºä¸€ä¸ªå¯¹è±¡çš„å®ä¾‹ï¼Œè£…é¥°è€…æ¨¡å¼é€šå¸¸æŠŠåŸå§‹å¯¹è±¡ä½œä¸ºä¸€ä¸ªå‚æ•°ä¼ å…¥è£…é¥°è€…çš„æ„é€ å™¨ï¼Œè¿™æ˜¯ä½¿ç”¨ä¸Šçš„ä¸åŒã€‚ è£…é¥°è€…æ¨¡å¼å’Œé€‚é…å™¨æ¨¡å¼ 1231 ä¸¤è€…éƒ½æ˜¯åŒ…è£…è€…æ¨¡å¼2 è£…é¥°è€…å’Œè¢«è£…é¥°è€…å¯ä»¥å®ç°ç›¸åŒçš„æ¥å£æˆ–è€…è£…é¥°è€…æ˜¯è¢«è£…é¥°è€…çš„å­ç±»3 é€‚é…å™¨å’Œè¢«é€‚é…çš„ç±»æœ‰ä¸åŒçš„æ¥å£ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯éƒ¨åˆ†æ¥å£æ˜¯é‡åˆçš„ ç®€å•éœ€æ±‚ä¹°ç…é¥¼çš„æ—¶å€™å¯ä»¥æ ¹æ®è‡ªèº«æƒ…å†µè¦æ±‚åŠ é¸¡è›‹æˆ–è€…é¦™è‚ ï¼Œå–ç…é¥¼çš„æ ¹æ®éœ€æ±‚å»åšç…é¥¼ã€‚ è£…é¥°è€…æ¨¡å¼æ¼”ç»ƒéè£…é¥°è€…æ¨¡å¼12éœ€æ±‚ï¼šåŠ ä¸€ä¸ªé¸¡è›‹åŠ ä¸€å…ƒï¼Œä¸€ä¸ªç«è…¿ä¸¤å…ƒï¼Œç°åœ¨aä¹°ä¸€ä¸ªç…é¥¼ï¼Œbä¹°åŠ è›‹çš„ç…é¥¼ï¼Œcä¹°åŠ è‚ çš„ç…é¥¼æ–¹æ¡ˆï¼šé€šè¿‡å †ç§¯ç±»å®Œæˆéœ€æ±‚ï¼Œä½†æ˜¯é¢å¯¹ä¼—å¤šçš„éœ€æ±‚ä¼šç±»çˆ†ç‚¸çš„ã€‚ ç…é¥¼ç±» 12345678910111213141516171819202122232425package com.design.pattern.decorator.v1;/** * BatterCake ç…é¥¼ç±» * * @author shunhua * @date 2019-09-19 */public class BatterCake &#123; /** * è·å–é£Ÿå“æè¿° * @return */ public String getDesc()&#123; return \"ç…é¥¼\"; &#125; /** * é£Ÿå“å•ä»· * @return */ public int cost()&#123; return 5; &#125;&#125; é¸¡è›‹ç…é¥¼ç±» 1234567891011121314151617181920package com.design.pattern.decorator.v1;/** * BatterCakeWithEgg åŠ é¸¡è›‹çš„ç…é¥¼ * * @author shunhua * @date 2019-09-19 */public class BatterCakeWithEgg extends BatterCake &#123; @Override public String getDesc() &#123; return super.getDesc() + \" åŠ ä¸€ä¸ªé¸¡è›‹\"; &#125; @Override public int cost() &#123; return super.cost() + 1; &#125;&#125; é¦™è‚ ç…é¥¼ç±» 12345678910111213141516171819package com.design.pattern.decorator.v1;/** * BatterCakeWithSausage åŠ é¦™è‚ çš„ç…é¥¼ * * @author shunhua * @date 2019-09-19 */public class BatterCakeWithSausage extends BatterCake &#123; @Override public String getDesc() &#123; return super.getDesc() + \" åŠ ä¸€ä¸ªé¦™è‚ \"; &#125; @Override public int cost() &#123; return super.cost() + 2; &#125;&#125; å®¢æˆ·ç«¯ 1234567891011121314151617181920212223242526272829package com.design.pattern.decorator.v1;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-19 */@Slf4jpublic class Client &#123; @Test public void test()&#123; // ç…é¥¼ BatterCake batterCake = new BatterCake(); log.info(batterCake.getDesc() + \"é”€å”®ä»·æ ¼ä¸º \" + batterCake.cost()); // é¸¡è›‹ç…é¥¼ BatterCakeWithEgg batterCakeWithEgg = new BatterCakeWithEgg(); log.info(batterCakeWithEgg.getDesc() + \"é”€å”®ä»·æ ¼ä¸º \" + batterCakeWithEgg.cost()); // é¦™è‚ ç…é¥¼ BatterCakeWithSausage batterCakeWithSausage = new BatterCakeWithSausage(); log.info(batterCakeWithSausage.getDesc() + \"é”€å”®ä»·æ ¼ä¸º \" + batterCakeWithEgg.cost()); &#125;&#125; è£…é¥°è€…æ¨¡å¼12éœ€æ±‚ï¼šç°åœ¨è‚ å’Œè›‹éšæœºï¼Œa åŠ 2è›‹2è‚  båŠ 1è›‹2è‚ æ–¹æ¡ˆï¼šä½¿ç”¨è£…é¥°ç±»æ·»åŠ åŠŸèƒ½ï¼Œä¸ºç…é¥¼åŠ é¸¡è›‹ã€åŠ é¦™è‚  è¦æ±‚ï¼š æ‰€è°“è£…é¥°è€…æ¨¡å¼ï¼Œé€šç”¨åšæ³•è¦æœ‰æŠ½è±¡çš„å®ä½“ç±»å’Œç¡®å®šçš„å®ä½“ç±»ï¼ŒåŒæ—¶è¦æœ‰æŠ½è±¡çš„è£…é¥°è€…å’Œç¡®å®šçš„è£…é¥°è€…ã€‚ç°åœ¨å®ä½“ç±»æ˜¯ç…é¥¼ï¼Œè£…é¥°è€…æ˜¯é¸¡è›‹å’Œé¦™è‚ ã€‚ å…³è”ï¼š ç…é¥¼å®ä½“ç±»ç»§æ‰¿ç…é¥¼æŠ½è±¡ç±»ï¼Œè£…é¥°è€…æŠ½è±¡ç±»ä¹Ÿç»§æ‰¿ç…é¥¼æŠ½è±¡ç±»ï¼Œé€šè¿‡å®ƒä»¬çš„çˆ¶ç±»ç»„åˆæ¥è¾¾åˆ°ç…é¥¼å®ä½“ç±»å’Œè£…é¥°è€…æŠ½è±¡ç±»çš„å…³ç³» æŠ½è±¡ç…é¥¼ç±» 123456789101112131415161718192021package com.design.pattern.decorator.v2;/** * AbstractBatterCake æŠ½è±¡ç…é¥¼ç±»ï¼ˆä¹Ÿå¯ä»¥æ˜¯æ¥å£ï¼‰ * * @author shunhua * @date 2019-09-19 */public abstract class AbstractBatterCake &#123; /** * é£Ÿå“æè¿° * @return */ public abstract String getDesc(); /** * ä»·æ ¼ * @return */ public abstract int cost();&#125; ç…é¥¼ç±» 1234567891011121314151617181920package com.design.pattern.decorator.v2;/** * BatterCake å®ä½“ç…é¥¼ç±» * * @author shunhua * @date 2019-09-19 */public class BatterCake extends AbstractBatterCake &#123; @Override public String getDesc() &#123; return \"ç…é¥¼\"; &#125; @Override public int cost() &#123; return 5; &#125;&#125; æŠ½è±¡è£…é¥°ç±» 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.decorator.v2;/** * * è£…é¥°è€…åŒæ ·ç»§æ‰¿ æŠ½è±¡ç…é¥¼ç±»ï¼Œè¿™æ˜¯ä¸ºäº†æ–¹ä¾¿ ï¼Œå’Œç…é¥¼ç±»äº¤äº’ * * å¦‚æœä¸ç”¨æ„é€ å™¨çš„æ–¹å¼ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨setæ–¹å¼ * * @author shunhua * @date 2019-09-19 */public abstract class AbstractDecorator extends AbstractBatterCake &#123; /** * å®šä¹‰ç…é¥¼å±æ€§ï¼Œç”¨äºæ³¨å…¥ */ private AbstractBatterCake batterCake; public AbstractDecorator(AbstractBatterCake batterCake)&#123; this.batterCake = batterCake; &#125; @Override public String getDesc() &#123; return batterCake.getDesc(); &#125; @Override public int cost() &#123; return batterCake.cost(); &#125; /** * è£…é¥°è€…å®ä½“ç±»ç‰¹æœ‰æ“ä½œ */ protected abstract void handle();&#125; é¸¡è›‹è£…é¥°ç±» 1234567891011121314151617181920212223242526272829303132package com.design.pattern.decorator.v2;import lombok.extern.slf4j.Slf4j;/** * EggDecorator * * @author shunhua * @date 2019-09-19 */@Slf4jpublic class EggDecorator extends AbstractDecorator &#123; public EggDecorator(AbstractBatterCake batterCake) &#123; super(batterCake); &#125; @Override public String getDesc() &#123; return super.getDesc() + \" åŠ ä¸€ä¸ªé¸¡è›‹\"; &#125; @Override public int cost() &#123; return super.cost() + 1; &#125; @Override protected void handle() &#123; log.info(\"é¸¡è›‹è£…é¥°è€…ç‰¹æœ‰çš„å¤„ç†\"); &#125;&#125; é¦™è‚ è£…é¥°ç±» 1234567891011121314151617181920212223242526272829303132package com.design.pattern.decorator.v2;import lombok.extern.slf4j.Slf4j;/** * SauseDecorator * * @author shunhua * @date 2019-09-19 */@Slf4jpublic class SauseDecorator extends AbstractDecorator &#123; public SauseDecorator(AbstractBatterCake batterCake) &#123; super(batterCake); &#125; @Override public String getDesc() &#123; return super.getDesc() + \" åŠ ä¸€ä¸ªé¦™è‚ \"; &#125; @Override public int cost() &#123; return super.cost() + 2; &#125; @Override protected void handle() &#123; log.info(\"é¦™è‚ è£…é¥°è€…ç‰¹æœ‰çš„å¤„ç†æ–¹å¼\"); &#125;&#125; å®¢æˆ·ç«¯ 1234567891011121314151617181920212223242526272829package com.design.pattern.decorator.v2;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-19 */@Slf4jpublic class Client &#123; @Test public void test()&#123; AbstractBatterCake batterCake; // è£…é¥°ç…é¥¼ batterCake = new BatterCake(); // é¸¡è›‹è£…é¥° batterCake = new EggDecorator(batterCake); batterCake = new EggDecorator(batterCake); ((EggDecorator) batterCake).handle(); // é¦™è‚ è£…é¥° batterCake = new SauseDecorator(batterCake); ((SauseDecorator) batterCake).handle(); log.info(batterCake.getDesc() + \" ä¸€å…±å–äº†\" + batterCake.cost() + \"å…ƒ\"); &#125;&#125; è£…é¥°è€…æ¨¡å¼åœ¨æºç ä¸­çš„ä½¿ç”¨BufferedReader 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class BufferedReader extends Reader &#123; private Reader in; private char cb[]; private int nChars, nextChar; // todo çœç•¥ /** * å¯¹Readerç±»å‹çš„ å®ä¾‹è¿›è¡ŒåŒ…è£… */ public BufferedReader(Reader in, int sz) &#123; super(in); if (sz &lt;= 0) throw new IllegalArgumentException(\"Buffer size &lt;= 0\"); this.in = in; cb = new char[sz]; nextChar = nChars = 0; &#125; /** * Creates a buffering character-input stream that uses a default-sized * input buffer. * * @param in A Reader */ public BufferedReader(Reader in) &#123; this(in, defaultCharBufferSize); &#125; /** * è¿™é‡Œä½¿ç”¨Reader ç±»å‹å¯¹è±¡è¿›è¡Œæ“ä½œ */ private void fill() throws IOException &#123; int dst; if (markedChar &lt;= UNMARKED) &#123; /* No mark */ dst = 0; &#125; else &#123; /* Marked */ int delta = nextChar - markedChar; if (delta &gt;= readAheadLimit) &#123; /* Gone past read-ahead limit: Invalidate mark */ markedChar = INVALIDATED; readAheadLimit = 0; dst = 0; &#125; else &#123; if (readAheadLimit &lt;= cb.length) &#123; /* Shuffle in the current buffer */ System.arraycopy(cb, markedChar, cb, 0, delta); markedChar = 0; dst = delta; &#125; else &#123; /* Reallocate buffer to accommodate read-ahead limit */ char ncb[] = new char[readAheadLimit]; System.arraycopy(cb, markedChar, ncb, 0, delta); cb = ncb; markedChar = 0; dst = delta; &#125; nextChar = nChars = delta; &#125; &#125; int n; do &#123; n = in.read(cb, dst, cb.length - dst); &#125; while (n == 0); if (n &gt; 0) &#123; nChars = dst + n; nextChar = dst; &#125; &#125;&#125;/** * æ³¨æ„Readeræ˜¯æŠ½è±¡çš„ */public abstract class Reader implements Readable, Closeable &#123; // todo çœç•¥&#125; InputStreamç±»å‹ä½œä¸ºè¢«è£…é¥°ç±»å‹ï¼Œå®ƒçš„è£…é¥°è€…æœ‰å¾ˆå¤šï¼Œå¦‚ä¸Šå›¾ä¸­åˆ—å‡ºFilerInputStreamã€BufferedInputStreamä»¥åŠLineInputStreamã€‚åœ¨è£…é¥°è€…å†…éƒ¨æœ¬è´¨ä¸Šéƒ½æ˜¯ä½¿ç”¨InputStreamçš„å®ä¾‹æ“ä½œçš„ã€‚ BufferedInputStream 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class BufferedInputStream extends FilterInputStream &#123; private static int DEFAULT_BUFFER_SIZE = 8192; private static int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8; protected volatile byte buf[]; private static final AtomicReferenceFieldUpdater&lt;BufferedInputStream, byte[]&gt; bufUpdater = AtomicReferenceFieldUpdater.newUpdater (BufferedInputStream.class, byte[].class, \"buf\"); protected int count; protected int pos; protected int markpos = -1; protected int marklimit; private InputStream getInIfOpen() throws IOException &#123; InputStream input = in; if (input == null) throw new IOException(\"Stream closed\"); return input; &#125; /** * å¯¹InputStreamç±»å‹è¿›è¡ŒåŒ…è£… */ public BufferedInputStream(InputStream in) &#123; this(in, DEFAULT_BUFFER_SIZE); &#125; /** * å¯¹InputStreamç±»å‹è¿›è¡ŒåŒ…è£… */ public BufferedInputStream(InputStream in, int size) &#123; super(in); if (size &lt;= 0) &#123; throw new IllegalArgumentException(\"Buffer size &lt;= 0\"); &#125; buf = new byte[size]; &#125;&#125; Servletçš„HttpServletRequestWrapper HttpServletRequestWrapperç»§æ‰¿äº†ServletRequestWrapperä¹Ÿå®ç°äº†HttpServletRequest,å®ƒä»¬çš„å…¬å…±çˆ¶ç±»æ˜¯ServletRequest. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * HttpServletRequestWrapperè£…é¥°ç±» */public class HttpServletRequestWrapper extends ServletRequestWrapper implements HttpServletRequest &#123; /** * å¯¹HttpServletRequestè¿›è¡Œè£…é¥°ï¼ŒServletRequestWrapperæŠ½è±¡çš„è£…é¥°è€…ä¹Ÿå¯¹HttpServletRequestçš„çˆ¶ç±»è¿›è¡Œè£…é¥° */ public HttpServletRequestWrapper(HttpServletRequest request) &#123; super(request); &#125; private HttpServletRequest _getHttpServletRequest() &#123; return (HttpServletRequest) super.getRequest(); &#125; /** * The default behavior of this method is to return getAuthType() * on the wrapped request object. */ public String getAuthType() &#123; return this._getHttpServletRequest().getAuthType(); &#125; /** * The default behavior of this method is to return getCookies() * on the wrapped request object. */ public Cookie[] getCookies() &#123; return this._getHttpServletRequest().getCookies(); &#125; /** * The default behavior of this method is to return getDateHeader(String name) * on the wrapped request object. */ public long getDateHeader(String name) &#123; return this._getHttpServletRequest().getDateHeader(name); &#125;&#125;/*** ServletRequestWrapperè£…é¥°ç±»*/public class ServletRequestWrapper implements ServletRequest &#123; private ServletRequest request; /** * Creates a ServletRequest adaptor wrapping the given request object. * @throws java.lang.IllegalArgumentException if the request is null */ public ServletRequestWrapper(ServletRequest request) &#123; if (request == null) &#123; throw new IllegalArgumentException(\"Request cannot be null\"); &#125; this.request = request; &#125; /** * Return the wrapped request object. */ public ServletRequest getRequest() &#123; return this.request; &#125; /** * Sets the request object being wrapped. * @throws java.lang.IllegalArgumentException if the request is null. */ public void setRequest(ServletRequest request) &#123; if (request == null) &#123; throw new IllegalArgumentException(\"Request cannot be null\"); &#125; this.request = request; &#125; /** * * The default behavior of this method is to call getAttribute(String name) * on the wrapped request object. */ public Object getAttribute(String name) &#123; return this.request.getAttribute(name); &#125; /** * The default behavior of this method is to return getAttributeNames() * on the wrapped request object. */ public Enumeration getAttributeNames() &#123; return this.request.getAttributeNames(); &#125; &#125; MyBatisçš„FifoCache MyBatisçš„Cacheæ¨¡å—ä¸­ä½¿ç”¨å¤§é‡çš„è£…é¥°è€…æ¨¡å¼ï¼Œåœ¨decoratorsåŒ…ä¸‹éƒ½æ˜¯çš„ï¼Œä¸‹é¢åˆ—ä¸¾æœ€è¿‘æœ€å°‘ä½¿ç”¨ç­–ç•¥çš„è£…é¥°ç±»ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839/*** lruç®—æ³• æœ€è¿‘æœ€å°‘ä½¿ç”¨*/public class LruCache implements Cache &#123; private final Cache delegate; private Map&lt;Object, Object&gt; keyMap; private Object eldestKey; public LruCache(Cache delegate) &#123; this.delegate = delegate; setSize(1024); &#125; @Override public String getId() &#123; return delegate.getId(); &#125; @Override public int getSize() &#123; return delegate.getSize(); &#125; public void setSize(final int size) &#123; keyMap = new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) &#123; private static final long serialVersionUID = 4267176411845948333L; @Override protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) &#123; boolean tooBig = size() &gt; size; if (tooBig) &#123; eldestKey = eldest.getKey(); &#125; return tooBig; &#125; &#125;; &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"å¤–è§‚æ¨¡å¼","slug":"design_pattern/structure_type/å¤–è§‚æ¨¡å¼","date":"2019-09-16T16:00:00.000Z","updated":"2020-08-09T09:34:58.171Z","comments":true,"path":"posts/f7de8aa8/","link":"","permalink":"https://gentryhuang.com/posts/f7de8aa8/","excerpt":"","text":"å®šä¹‰åˆå«é—¨é¢æ¨¡å¼ï¼Œæä¾›äº†ä¸€ä¸ªç»Ÿä¸€çš„æ¥å£ï¼Œç”¨æ¥è®¿é—®å­ç³»ç»Ÿä¸­çš„ä¸€ç¾¤æ¥å£ã€‚å¤–è§‚æ¨¡å¼å®šä¹‰äº†ä¸€ä¸ªé«˜å±‚æ¥å£ï¼Œè®©å­ç³»ç»Ÿæ›´å®¹æ˜“ä½¿ç”¨ã€‚ ç±»å‹ç»“æ„å‹ ä½¿ç”¨åœºæ™¯ å­ç³»ç»Ÿè¶Šæ¥è¶Šå¤æ‚ï¼Œå¢åŠ å¤–è§‚æ¨¡å¼æä¾›ç®€å•è°ƒç”¨æ¥å£ æ„å»ºå¤šå±‚ç³»ç»Ÿç»“æ„ï¼Œåˆ©ç”¨å¤–è§‚å¯¹è±¡ä½œä¸ºæ¯å±‚çš„å…¥å£ï¼Œç®€åŒ–å±‚é—´è°ƒç”¨ ä¼˜ç‚¹1234â—†ç®€åŒ–äº†è°ƒç”¨è¿‡ç¨‹ï¼Œæ— éœ€äº†è§£æ·±å…¥å­ç³»ç»Ÿï¼Œé˜²æ­¢å¸¦æ¥é£é™©(å°†å­ç³»ç»Ÿé›†æˆåˆ°ä¸€èµ·ï¼Œä¸å»ä¿®æ”¹å­ç³»ç»Ÿ)ã€‚â—†å‡å°‘ç³»ç»Ÿä¾èµ–ã€æ¾æ•£è€¦åˆï¼ˆå®¢æˆ·ç«¯ä¸å­ç³»ç»Ÿï¼‰â—†æ›´å¥½çš„åˆ’åˆ†è®¿é—®å±‚æ¬¡â—†ç¬¦åˆè¿ªç±³ç‰¹æ³•åˆ™ï¼Œå³æœ€å°‘çŸ¥é“åŸåˆ™ ç¼ºç‚¹12â—†å¢åŠ å­ç³»ç»Ÿã€æ‰©å±•å­ç³»ç»Ÿè¡Œä¸ºå®¹æ˜“å¼•å…¥é£é™©â—†å¢åŠ å­ç³»ç»Ÿã€æ‰©å±•å­ç³»ç»Ÿè¡Œä¸ºä¸ç¬¦åˆå¼€é—­åŸåˆ™ ç›¸å…³è”è®¾è®¡æ¨¡å¼å¯¹æ¯”å¤–è§‚æ¨¡å¼å’Œä¸­ä»‹è€…æ¨¡å¼ 1å‰è€…å…³æ³¨å¤–ç•Œå’Œå­ç³»ç»Ÿçš„äº¤äº’ï¼Œåè€…å…³æ³¨å­ç³»ç»Ÿå†…éƒ¨çš„äº¤äº’ å¤–è§‚æ¨¡å¼å’Œå•ä¾‹æ¨¡å¼ 1å¤–è§‚æ¨¡å¼å’Œå•ä¾‹æ¨¡å¼å¯ä»¥ç»“åˆä½¿ç”¨,é€šå¸¸æŠŠå¤–è§‚æ¨¡å¼ä¸­çš„å¤–è§‚åšæˆå•ä¾‹çš„ å¤–è§‚æ¨¡å¼å’ŒæŠ½è±¡å·¥å‚æ¨¡å¼ 1å‰è€…å¯ä»¥é€šè¿‡åè€…è·å–å­ç³»ç»Ÿçš„å®ä¾‹ï¼Œå­ç³»ç»Ÿå¯ä»¥ç»å†…éƒ¨å¯¹å¤–è§‚ç±»è¿›è¡Œå±è”½ ç®€å•éœ€æ±‚ æŸç½‘ç«™æœ‰ç§¯åˆ†å…‘æ¢ç¤¼ç‰©çš„åŠŸèƒ½ï¼Œè®¾è®¡çš„æ—¶å€™éœ€è¦æ ¡éªŒä¸‰æ­¥ï¼š a èµ„æ ¼æ ¡éªŒç³»ç»Ÿï¼Œæ˜¯æœ¨æœ¨ç½‘ä¼šå‘˜ã€‚ b ç§¯åˆ†ç³»ç»Ÿï¼Œè¯¥ç³»ç»Ÿæ”¾çš„æ˜¯å„ä¸ªç§¯åˆ†çš„è·å–æ”¯å‡ºï¼Œéœ€è¦æ‹¿å‡ºè¯¥ç”¨æˆ·ç›®å‰çš„ç§¯åˆ†å’Œè¯¥ç¤¼ç‰©æ‰€éœ€è¦çš„ç§¯åˆ†è¿›è¡Œå¯¹æ¯” c ç‰©æµç³»ç»Ÿï¼Œå¦‚æœæ»¡è¶³abï¼Œåˆ™è¿”å›æˆåŠŸï¼Œå¹¶è¿”å›ä¸€ä¸ªè®¢å•å·ã€‚ å…³æ³¨ç‚¹ï¼š åº”ç”¨å±‚æ— éœ€çŸ¥é“èµ„æ ¼æ ¡éªŒç±»ç­‰å…¶ä»–å­ç³»ç»Ÿçš„ç±» å¤–è§‚æ¨¡å¼æ¼”ç»ƒ 121. åº”ç”¨å±‚ä¸å…³å¿ƒå­ç³»ç»Ÿï¼Œåº”ç”¨å±‚åªå’Œå¤–è§‚ç±»é€šä¿¡ï¼Œå­ç³»ç»Ÿåªå’Œå¤–è§‚ç±»é€šä¿¡2. å¦‚æœæ‰©å±•å­ç³»ç»Ÿçš„ï¼Œä½¿ç”¨å®ä½“å¤–è§‚ç±»çš„è¯ï¼Œä¸ç¬¦åˆå¼€é—­åŸåˆ™ï¼Œå¦‚æœä½¿ç”¨æŠ½è±¡å¤–è§‚ç±»æˆ–è€…å¤–è§‚æ¥å£ï¼Œç„¶åç”¨å®ä½“ç»§æ‰¿æˆ–å®ç°çš„è¯ï¼Œç¬¦åˆå¼€é—­åŸåˆ™ã€‚ä¸»è¦çœ‹å¤–è§‚å¯¹åº”çš„å­ç³»ç»Ÿç¾¤æ˜¯å¦å˜æ›´é¢‘ç¹ï¼Œä¸é¢‘ç¹å¯ä»¥ä½¿ç”¨å®ä½“å¤–è§‚ï¼Œè¿™æ ·æ›´ç®€å•ã€‚ å®ä½“ç±» 1234567891011121314151617181920package com.design.pattern.facade;import lombok.AllArgsConstructor;import lombok.Data;/** * PointsGift ç§¯åˆ†å…‘æ¢ç¤¼ç‰© * * @author shunhua * @date 2019-09-17 */@Data@AllArgsConstructorpublic class PointsGift &#123; /** * ç¤¼ç‰©åç§° */ private String name;&#125; èµ„æ ¼éªŒè¯ç³»ç»Ÿç±» 1234567891011121314151617181920212223package com.design.pattern.facade;import lombok.extern.slf4j.Slf4j;/** * QualifyService æ ¡éªŒç³»ç»Ÿ * * @author shunhua * @date 2019-09-17 */@Slf4jpublic class QualifyService &#123; /** * æ ¡éªŒé€»è¾‘ï¼Œç§¯åˆ†æ˜¯å¦å¤Ÿ * @param pointsGift * @return */ public boolean isAvailable(PointsGift pointsGift)&#123; log.info(pointsGift.getName() + \"ç§¯åˆ†é€šè¿‡\"); return true; &#125;&#125; ç§¯åˆ†ç³»ç»Ÿç±» 1234567891011121314151617181920212223package com.design.pattern.facade;import lombok.extern.slf4j.Slf4j;&#x2F;** * PointsPaymentService ç§¯åˆ†æ”¯ä»˜ * * @author shunhua * @date 2019-09-17 *&#x2F;@Slf4jpublic class PointsPaymentService &#123; &#x2F;** * ç§¯åˆ†å…‘æ¢ç¤¼ç‰© * @param pointsGift * @return *&#x2F; public boolean pay(PointsGift pointsGift)&#123; log.info(&quot;æ”¯ä»˜&quot; + pointsGift.getName() + &quot;ç§¯åˆ†æˆåŠŸ&quot;); return true; &#125;&#125; ç‰©æµç³»ç»Ÿç±» 1234567891011121314151617181920212223package com.design.pattern.facade;import lombok.extern.slf4j.Slf4j;/** * ShippingService * * @author shunhua * @date 2019-09-17 */@Slf4jpublic class ShippingService &#123; /** * ç‰©æµç³»ç»Ÿå¯¹æ¥ * @param pointsGift * @return */ public String shipGift(PointsGift pointsGift)&#123; log.info(pointsGift.getName() + \"è¿›å…¥ç‰©æµç³»ç»Ÿ\"); return \"123456\"; &#125;&#125; å®¢æˆ·ç«¯ 1234567891011121314151617181920package com.design.pattern.facade;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-17 */public class Client &#123; @Test public void test()&#123; PointsGift pointsGift = new PointsGift(\"æœºæ¢°é”®ç›˜\"); GiftExchangeService giftExchangeService = new GiftExchangeService(); giftExchangeService.giftExchange(pointsGift); &#125;&#125; å¤–è§‚æ¨¡å¼åœ¨æºç ä¸­çš„ä½¿ç”¨Spring-jdbc 1Springå¯¹åŸç”Ÿçš„JDBCè¿›è¡Œäº†å°è£…ï¼Œæˆ‘ä»¬åªéœ€è¦è®¿é—®Springæä¾›çš„æ¥å£æ–¹æ³•å°±å¯ä»¥è¾¾åˆ°ç›®çš„ã€‚ MyBatisçš„Configuration 123456/** Configuration#newMetaObjectæ–¹æ³•åº•å±‚ä¹Ÿæ˜¯å¯¹ä¸€äº›åˆ—é€»è¾‘çš„å°è£…ï¼Œæˆ‘ä»¬åªéœ€è¦è°ƒç”¨newMetaObjectå³å¯ï¼Œä¸éœ€å…³ç³»å†…éƒ¨ã€‚ * å¦‚æœéœ€è¦ä¿®æ”¹å†…éƒ¨é€»è¾‘ï¼Œè¿™å¤–è§‚æ¥å£æ˜¯ä¸éœ€è¦æ”¹å˜çš„ */public MetaObject newMetaObject(Object object) &#123; return MetaObject.forObject(object, objectFactory, objectWrapperFactory, reflectorFactory); &#125; Tomcatæºç  12341. Tomcatä¸­å¤§é‡ä½¿ç”¨äº†å¤–è§‚æ¨¡å¼ï¼Œå¦‚RequestFacadeã€ResponseFacadeç­‰ã€‚2. RequestFacade implements HttpServletRequestï¼ŒRequest implements HttpServletRequestï¼ŒRequestä½¿ç”¨äº†RequestFacadeåŒ…è£…äº† è‡ªå·±ã€‚Request#getRequeståœ¨è·å–HttpServletRequestæ—¶ï¼Œè¿”å›çš„å…¶å®æ˜¯RequestFacadeï¼Œä¹‹åç”¨è¿™ä¸ªè¿”å›çš„å¯¹è±¡å®Œæˆçš„æ“ä½œéƒ½æ˜¯RequestFacade æ¥å®Œæˆçš„ã€‚","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"åŸå‹æ¨¡å¼","slug":"design_pattern/creation_type/åŸå‹æ¨¡å¼","date":"2019-09-15T16:00:00.000Z","updated":"2020-07-04T16:28:45.962Z","comments":true,"path":"posts/91ad9ce3/","link":"","permalink":"https://gentryhuang.com/posts/91ad9ce3/","excerpt":"","text":"å®šä¹‰åŸå‹å®ä¾‹æŒ‡å®šåˆ›å»ºå¯¹è±¡çš„ç§ç±»ï¼Œå¹¶ä¸”é€šè¿‡æ‹·è´è¿™äº›åŸå‹åˆ›å»ºæ–°çš„å¯¹è±¡ã€‚å¯ä»¥ç†è§£ä¸ºå…‹éš†æ–¹æ³•å…‹éš†å¯¹è±¡ã€‚ ç‰¹ç‚¹ä¸éœ€è¦çŸ¥é“ä»»ä½•åˆ›å»ºçš„ç»†èŠ‚ï¼Œä¸è°ƒç”¨æ„é€ å‡½æ•° ç±»å‹åˆ›å»ºå‹ é€‚ç”¨åœºæ™¯1234â—†ç±»åˆå§‹åŒ–æ¶ˆè€—è¾ƒå¤šèµ„æºâ—†newäº§ç”Ÿçš„ä¸€ä¸ªå¯¹è±¡éœ€è¦éå¸¸ç¹ççš„è¿‡ç¨‹ï¼ˆæ•°æ®å‡†å¤‡ã€è®¿é—®æƒé™ç­‰ï¼‰â—†æ„é€ å‡½æ•°æ¯”è¾ƒå¤æ‚â—†å¾ªç¯ä½“ä¸­ç”Ÿäº§å¤§é‡å¯¹è±¡æ—¶ ä¼˜ç‚¹ åŸå‹æ¨¡å¼æ€§èƒ½æ¯”ç›´æ¥newä¸€ä¸ªå¯¹è±¡æ€§èƒ½é«˜ ç®€åŒ–åˆ›å»ºå¯¹è±¡çš„è¿‡ç¨‹ ç¼ºç‚¹ å¿…é¡»é…å¤‡å…‹éš†æ–¹æ³•ï¼ˆé‡å†™Objectçš„cloneæ–¹æ³•ï¼Œå¦åˆ™ä¸ä¼šç”Ÿæ•ˆï¼Œå…‹éš†ä¹Ÿæ˜¯åŸå‹æ¨¡å¼çš„æ ¸å¿ƒï¼‰ å¯¹å…‹éš†å¤æ‚å¯¹è±¡æˆ–å¯¹å…‹éš†å‡ºçš„å¯¹è±¡è¿›è¡Œå¤æ‚æ”¹é€ æ—¶ï¼Œå®¹æ˜“å¼•å…¥é£é™© å¯¹å¤æ‚å¯¹è±¡çš„æ·±æ‹·è´ã€æµ…æ‹·è´è¦è¿ç”¨å¾—å½“ æ‰©å±•æ·±å…‹éš†1åˆ›å»ºä¸€ä¸ªæ–°å¯¹è±¡ï¼Œæœ¬ä½“å¯¹è±¡çš„å¼•ç”¨ç±»å‹å±æ€§éœ€è¦è¿›è¡Œæ·±å…‹éš†ï¼Œè¿™æ ·å®ƒå°±ä¸ä¼šå†æŒ‡å‘åŸæœ‰å¯¹è±¡åœ°å€ã€‚ æµ…å…‹éš†1åˆ›å»ºä¸€ä¸ªæ–°å¯¹è±¡ï¼Œæ–°å¯¹è±¡çš„å±æ€§å’ŒåŸæ¥å¯¹è±¡å®Œå…¨ç›¸åŒï¼Œå¯¹äºéåŸºæœ¬ç±»å‹å±æ€§ï¼Œä»æŒ‡å‘åŸæœ‰å±æ€§æ‰€æŒ‡å‘çš„å¯¹è±¡çš„å†…å­˜åœ°å€ã€‚ å°ç»“1æ·±æµ…å…‹éš†éƒ½ä¼šåœ¨å †ä¸­æ–°åˆ†é…ä¸€å—åŒºåŸŸï¼Œå®ƒç”¨æ¥æŒ‡å‘æœ¬ä½“ï¼ŒåŒºåˆ«åœ¨äºå¯¹è±¡å±æ€§å¼•ç”¨çš„å¯¹è±¡æ˜¯å¦éœ€è¦è¿›è¡Œå…‹éš†ï¼ˆé€’å½’æ€§çš„ï¼‰ ç®€å•éœ€æ±‚æŸä¸ªå¯¹è±¡åˆ›å»ºçš„æ—¶å€™ç›¸å¯¹æ¯”è¾ƒæ¶ˆè€—èµ„æºï¼Œä½†æ˜¯è¿™ä¸ªå¯¹è±¡åˆä¸å¾—ä¸åˆ›å»ºå¤šæ¬¡ï¼Œè¿™æ—¶å¯ä»¥ä½¿ç”¨åŸå‹æ¨¡å¼ã€‚åŸå‹æ¨¡å¼æ˜¯åœ¨å†…å­˜ä¸­è¿›è¡ŒäºŒè¿›åˆ¶å­—èŠ‚æµçš„æ‹·è´ï¼Œæ¯”newä¸€ä¸ªå¯¹è±¡æ€§èƒ½å¥½å¾ˆå¤š åŸå‹æ¨¡å¼å®è·µä½¿ç”¨åŸå‹æ¨¡å¼ä¹‹å‰é‚®ä»¶ç±» 12345678910111213141516171819202122232425package com.design.pattern.prototype;import lombok.Data;/** * Mail * * @author shunhua * @date 2019-09-16 */@Datapublic class Mail &#123; /** * é‚®ä»¶å */ private String name; /** * é‚®ä»¶åœ°å€ */ private String address; /** * é‚®ä»¶å†…å®¹ */ private String content;&#125; é‚®ä»¶å·¥å…·ç±» 123456789101112131415161718192021222324252627282930package com.design.pattern.prototype;import lombok.extern.slf4j.Slf4j;import java.text.MessageFormat;/** * MailUtil * * @author shunhua * @date 2019-09-16 */@Slf4jpublic class MailUtil &#123; /** * å‘é€é‚®ä»¶ * é‡ç‚¹ï¼š å ä½ç¬¦èµ‹å€¼çš„å®ç° * @param mail */ public static void sendMail(Mail mail)&#123; String content = \"å‘&#123;0&#125;,é‚®ä»¶åœ°å€:&#123;1&#125;,é‚®ä»¶å†…å®¹ï¼š&#123;2&#125;å‘é€é‚®ä»¶\"; log.info(MessageFormat.format(content,mail.getName(),mail.getAddress(),mail.getContent())); &#125; /** * ä¿å­˜é‚®ä»¶çš„æ¨¡ç‰ˆå†…å®¹ * @param mail */ public static void mailTemplate(Mail mail)&#123; log.info(\"é‚®ä»¶çš„æ¨¡ç‰ˆå†…å®¹ï¼š\" + mail.getContent()); &#125;&#125; å®¢æˆ·ç«¯ 12345678910111213141516171819202122232425package com.design.pattern.prototype;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-16 */public class Client &#123; @Test public void test()&#123; Mail mail = new Mail(); mail.setContent(\"é‚®ä»¶æ¨¡ç‰ˆ\"); for(int i = 0; i &lt; 10; i++)&#123; mail.setName(\"å§“å\" + i); mail.setAddress(\"å§“å\" + i + \"@\" + \"gmail.com\"); mail.setContent(\"ä½ æ”¶åˆ°ä¸€å°é‚®ä»¶\"); MailUtil.sendMail(mail); &#125; MailUtil.mailTemplate(mail); &#125;&#125; ä½¿ç”¨åŸå‹æ¨¡å¼é»˜è®¤æ–¹å¼ï¼ˆæµ…æ‹·è´ï¼‰é‚®ä»¶ç±» 123456789101112131415161718192021222324252627282930313233343536package com.design.pattern.prototype;import lombok.Data;/** * Mail æƒ³è¦èƒ½è¢«å…‹éš†éœ€è¦å®ç°Cloneableæ¥å£ * * @author shunhua * @date 2019-09-16 */@Datapublic class Mail implements Cloneable &#123; /** * é‚®ä»¶å */ private String name; /** * é‚®ä»¶åœ°å€ */ private String address; /** * é‚®ä»¶å†…å®¹ */ private String content; /** * é‡å†™å…‹éš†æ–¹æ³• * @return * @throws CloneNotSupportedException */ @Override protected Object clone() throws CloneNotSupportedException &#123; System.out.println(\"å…‹éš†Mail...\"); return super.clone(); &#125;&#125; é‚®ä»¶å·¥å…·ç±» 12345678910111213141516171819202122232425262728293031package com.design.pattern.prototype;import lombok.extern.slf4j.Slf4j;import java.text.MessageFormat;/** * MailUtil * * @author shunhua * @date 2019-09-16 */@Slf4jpublic class MailUtil &#123; /** * å‘é€é‚®ä»¶ * @param mail */ public static void sendMail(Mail mail)&#123; String content = \"å‘&#123;0&#125;,é‚®ä»¶åœ°å€:&#123;1&#125;,é‚®ä»¶å†…å®¹ï¼š&#123;2&#125;å‘é€é‚®ä»¶\"; log.info(MessageFormat.format(content,mail.getName(),mail.getAddress(),mail.getContent())); &#125; /** * ä¿å­˜é‚®ä»¶çš„æ¨¡ç‰ˆå†…å®¹ * @param mail */ public static void mailTemplate(Mail mail)&#123; log.info(\"é‚®ä»¶çš„æ¨¡ç‰ˆå†…å®¹ï¼š\" + mail.getContent()); &#125;&#125; å®¢æˆ·ç«¯ 12345678910111213141516171819202122232425262728package com.design.pattern.prototype;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-16 */public class Client &#123; @Test public void test() throws CloneNotSupportedException &#123; Mail mail = new Mail(); mail.setContent(\"é‚®ä»¶æ¨¡ç‰ˆ\"); for(int i = 0; i &lt; 10; i++)&#123; /** éœ€è¦åˆ›å»ºå¤šä¸ªMailå¯¹è±¡,æ³¨æ„ä¸ä¼šè°ƒç”¨Mailçš„æ„é€ æ–¹æ³•ï¼Œè€Œæ˜¯è°ƒç”¨äº†Mailä¸­çš„cloneæ–¹æ³• **/ Mail mailTemp = (Mail) mail.clone(); mailTemp.setName(\"å§“å\" + i); mailTemp.setAddress(\"å§“å\" + i + \"@\" + \"gmail.com\"); mailTemp.setContent(\"ä½ æ”¶åˆ°ä¸€å°é‚®ä»¶\"); MailUtil.sendMail(mailTemp); &#125; // å¾—åˆ°åŸå§‹çš„é‚®ä»¶æ¨¡ç‰ˆ MailUtil.mailTemplate(mail); &#125;&#125; ä½¿ç”¨åŸå‹æ¨¡å¼é»˜è®¤æ–¹å¼ï¼ˆæ·±æ‹·è´ï¼‰12345678å¯¹äºè¢«å…‹éš†çš„ç›®æ ‡å¯¹è±¡ä¸­æœ‰å¼•ç”¨ç±»å‹çš„å±æ€§æ—¶ï¼Œå¦‚æœä¸å¯¹è¯¥å¼•ç”¨ç±»å‹çš„å±æ€§è¿›è¡Œå…‹éš†å¤„ç†ï¼Œé‚£ä¹ˆè¯¥å±æ€§å¯¹äºç›®æ ‡å¯¹è±¡å’Œå…‹éš†å¾—åˆ°çš„æ–°å¯¹è±¡éƒ½æ˜¯åŒä¸€ä¸ªï¼Œè¿™å¾ˆå®¹æ˜“å¼•èµ·é—®é¢˜ï¼Œä¸€å®šè¦æ³¨æ„ã€‚è¿™æ ·æƒ…å†µï¼Œåªéœ€è¦å¯¹è¿™ä¸ªå±æ€§è¿›è¡Œæµ…æ‹·è´å¤„ç†å³å¯è§£å†³ã€‚@Override protected Object clone() throws CloneNotSupportedException &#123; Mail mail = (Mail) super.clone(); //æ·±å…‹éš† mail.date = (Date) pig.date.clone(); return mail; &#125; åŸå‹æ¨¡å¼æ‰©å±•å®ä½“ç±» 1234567891011/** * ä¸€ç§å¸¸ç”¨çš„åŸå‹æ¨¡å¼ * é€šè¿‡æŠ½è±¡ç±»æ¥å®ç°åŸå‹æ¨¡å¼ */public abstract class A implements Cloneable&#123; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; ç»§æ‰¿ç±» 123456789101112131415/** * ç»§æ‰¿Aç±»ï¼Œç›´æ¥è°ƒç”¨cloneæ¥å£ */public class B extends A&#123; public static void main(String [] args)&#123; B b = new B(); try &#123; b.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); System.out.println(\"å¤„ç†å¼‚å¸¸\"); &#125; &#125;&#125; å…‹éš†ç ´åå•ä¾‹123å…‹éš†ç ´åå•ä¾‹çš„æ ¹æœ¬åŸå› æ˜¯ï¼Œé€šè¿‡åå°„æš´åŠ›è°ƒç”¨å•ä¾‹ç±»ä¸­çš„cloneæ–¹æ³•ï¼Œè¿™æ ·å°±ä¼šå¾—åˆ°ä¸€ä¸ªæ–°å¯¹è±¡ï¼Œå•ä¾‹ä¹Ÿå°±å˜æˆäº†å¤šä¾‹ã€‚é˜²æ­¢å…‹éš†ç ´åå•ä¾‹ï¼Œåªéœ€è¦è®©å•ä¾‹ç±»ä¸å®ç°å…‹éš†æ¥å£å³å¯ï¼Œæˆ–è€…å®ç°äº†å…‹éš†æ¥å£ä½†æ˜¯å…‹éš†æ–¹æ³•è¿”å›çš„ä»ç„¶æ˜¯åŒä¸€å¯¹è±¡ï¼Œè€Œä¸æ˜¯å¤„ç†å…‹éš†ã€‚ åŸå‹æ¨¡å¼åœ¨æºç ä¸­çš„ä½¿ç”¨1å¯ä»¥é€šè¿‡è§‚å¯ŸCloneableæ¥å£çš„ä½¿ç”¨ï¼Œå°±å¯ä»¥è¿½è¸ªåŸå‹æ¨¡å¼æ˜¯æ€æ ·ä½¿ç”¨çš„ æºç è§£æ1(Object) 12//native è°ƒç”¨éjavaä»£ç æ¥å£ protected native Object clone() throws CloneNotSupportedException; æºç è§£æ2(ArrayListå®ç°å…‹éš†) 1234567891011121314151617181920212223public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;/** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */ public Object clone() &#123; try &#123; @SuppressWarnings(\"unchecked\") ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125;&#125; æºç è§£æ3(MyBatisçš„cacheKey) 12345678910111213141516171819package org.apache.ibatis.cache;import java.io.Serializable;import java.lang.reflect.Array;import java.util.ArrayList;import java.util.List;/** * @author Clinton Begin */public class CacheKey implements Cloneable, Serializable &#123; @Override public CacheKey clone() throws CloneNotSupportedException &#123; CacheKey clonedCacheKey = (CacheKey) super.clone(); clonedCacheKey.updateList = new ArrayList&lt;Object&gt;(updateList); return clonedCacheKey; &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"å»ºé€ è€…æ¨¡å¼","slug":"design_pattern/creation_type/å»ºé€ è€…æ¨¡å¼","date":"2019-09-11T14:33:47.000Z","updated":"2020-08-09T09:16:58.216Z","comments":true,"path":"posts/fe816c3c/","link":"","permalink":"https://gentryhuang.com/posts/fe816c3c/","excerpt":"","text":"å®šä¹‰ å°†ä¸€ä¸ªå¤æ‚å¯¹è±¡çš„æ„å»ºä¸å®ƒçš„è¡¨ç¤ºåˆ†ç¦»ï¼Œä½¿å¾—åŒæ ·çš„æ„å»ºè¿‡ç¨‹å¯ä»¥åˆ›å»ºä¸åŒçš„è¡¨ç¤ºã€‚ç”¨æˆ·åªéœ€æŒ‡å®šéœ€è¦å»ºé€ çš„ç±»å‹å°±å¯ä»¥å¾—åˆ°å®ƒä»¬ï¼Œå»ºé€ è¿‡ç¨‹åŠç»†èŠ‚ä¸éœ€è¦çŸ¥é“ã€‚ ç±»å‹ åˆ›å»ºå‹ é€‚ç”¨åœºæ™¯ å¦‚æœä¸€ä¸ªå¯¹è±¡æœ‰éå¸¸å¤æ‚çš„å†…éƒ¨ç»“æ„ï¼ˆå¾ˆå¤šå±æ€§ï¼‰ æƒ³æŠŠå¤æ‚å¯¹è±¡çš„åˆ›å»ºå’Œä½¿ç”¨åˆ†ç¦»ä¼˜ç‚¹ å°è£…æ€§å¥½ï¼Œåˆ›å»ºå’Œä½¿ç”¨åˆ†ç¦» æ‰©å±•æ€§å¥½ã€å»ºé€ ç±»ä¹‹é—´ç‹¬ç«‹ã€ä¸€å®šç¨‹åº¦ä¸Šè§£è€¦ ç¼ºç‚¹ äº§ç”Ÿå¤šä½™çš„Builderå¯¹è±¡ äº§å“å†…éƒ¨å‘ç”Ÿå˜åŒ–ï¼Œå»ºé€ è€…éƒ½éœ€è¦ä¿®æ”¹ï¼Œæˆæœ¬è¾ƒå¤§ å»ºé€ è€…æ¨¡å¼å’Œå·¥å‚æ¨¡å¼æ¯”è¾ƒ å»ºé€ è€…æ¨¡å¼æ›´æ³¨é‡æ–¹æ³•çš„è°ƒç”¨é¡ºåºï¼Œè€Œå·¥å‚æ¨¡å¼æ›´æ³¨é‡ç”Ÿäº§äº§å“ åˆ›å»ºå¯¹è±¡çš„ç²’åº¦ä¸åŒï¼Œå»ºé€ è€…æ¨¡å¼å¯ä»¥åˆ›å»ºå¤æ‚çš„äº§å“ï¼Œæœ‰å„ç§å¤æ‚çš„éƒ¨ä»¶ç»„æˆã€‚è€Œå·¥ç¨‹æ¨¡å¼åˆ›å»ºå‡ºæ¥çš„éƒ½å‡ ä¹ä¸€ä¸ªæ ·å­ å·¥å‚æ¨¡å¼æ³¨é‡æŠŠäº§å“åˆ›å»ºå‡ºæ¥ï¼Œè€Œå»ºé€ è€…ä¸ä»…è¦åˆ›å»ºå‡ºäº§å“ï¼Œè¿˜è¦çŸ¥é“äº§å“æœ‰å“ªäº›éƒ¨ä»¶ç»„æˆçš„ ç®€å•éœ€æ±‚è¯´æ˜ æœ‰ä¸€ä¸ªè¯¾ç¨‹éœ€è¦ä¸Šçº¿åœ¨ç½‘ç«™ï¼Œè¿™ä¸ªè¯¾ç¨‹éœ€è¦æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼šè¯¾ç¨‹åã€è¯¾ç¨‹çš„è¯¾ä»¶èµ„æºä»¥åŠè§†é¢‘èµ„æºï¼Œåªæœ‰è¿™ä¸ªä¸‰ä¸ªç»„ä»¶æœ‰äº† æ‰èƒ½ç»„è£…æˆä¸Šçº¿çš„è¯¾ç¨‹ã€‚è¿™é‡Œåœ¨åˆ›å»ºè¯¾æ—¶ï¼Œéœ€è¦æœ‰é¡ºåºçš„æ‰§è¡Œï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªç¬¦åˆè¦æ±‚çš„è¯¾ç¨‹ã€‚ v1 é€šè¿‡ä¸­é—´ç±»å®ç°umlç±»å›¾ è¯¾ç¨‹ç±» 1234567891011121314151617181920212223242526package com.design.pattern.builder;import lombok.Data;/** * Course * * @author shunhua * @date 2019-09-11 */@Datapublic class Course &#123; /** * è¯¾ç¨‹å */ private String name; /** * è¯¾ç¨‹èµ„æ–™ */ private String source; /** * è¯¾ç¨‹è§†é¢‘ */ private String video;&#125; å»ºé€ è€…æŠ½è±¡ç±» 123456789101112131415161718192021222324252627282930313233package com.design.pattern.builder;/** * CourseBuilder * * @author shunhua * @date 2019-09-11 */public abstract class CourseBuilder &#123; /** * å»ºé€ è¯¾ç¨‹å * @param name */ public abstract void buildName(String name); /** * å»ºé€ è¯¾ç¨‹èµ„æ–™ * @param source */ public abstract void buildSource(String source); /** * å»ºé€ è¯¾ç¨‹è§†é¢‘ * @param video */ public abstract void buildVideo(String video); /** * æ„å»ºè¯¾ç¨‹ * @return */ public abstract Course buildCourse();&#125; å»ºé€ è€…å®ç°ç±» 1234567891011121314151617181920212223242526272829303132package com.design.pattern.builder;/** * ActualCourseBuilder çœŸæ­£çš„è¯¾ç¨‹åˆ›å»ºè€… * * @author shunhua * @date 2019-09-11 */public class ActualCourseBuilder extends CourseBuilder&#123; private Course course = new Course(); @Override public void buildName(String name) &#123; course.setName(name); &#125; @Override public void buildSource(String source) &#123; course.setSource(source); &#125; @Override public void buildVideo(String video) &#123; course.setVideo(video); &#125; @Override public Course buildCourse() &#123; return course; &#125;&#125; åŠ©æ•™ï¼ˆå¯¹è¯¾ç¨‹è¿›è¡Œç»„è£…ï¼‰ 12345678910111213141516171819202122232425262728293031package com.design.pattern.builder;/** * Assistant è¯¾ç¨‹åŠ©æ•™ * * @author shunhua * @date 2019-09-11 */public class Assistant &#123; private CourseBuilder courseBuilder; public void setCourseBuilder(CourseBuilder courseBuilder)&#123; this.courseBuilder = courseBuilder; &#125; /** * è¯¾ç¨‹åŠ©æ•™ ç»„è£…è¯¾ç¨‹ * @param name * @param source * @param video * @return */ public Course buildCourse(String name,String source,String video)&#123; this.courseBuilder.buildName(name); this.courseBuilder.buildSource(source); this.courseBuilder.buildVideo(video); return this.courseBuilder.buildCourse(); &#125;&#125; å®¢æˆ·ç«¯ 1234567891011121314151617181920212223package com.design.pattern.builder;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-11 */@Slf4jpublic class Client &#123; @Test public void test()&#123; CourseBuilder courseBuilder = new ActualCourseBuilder(); Assistant assistant = new Assistant(); assistant.setCourseBuilder(courseBuilder); Course course = assistant.buildCourse(\"Javaè¿›é˜¶\",\"ppt\",\"Javaè¿›é˜¶è§†é¢‘\"); log.info(course.toString()); &#125;&#125; v2 é™æ€å†…éƒ¨ç±»æ¼”ç»ƒå»ºé€ è€…æ¨¡å¼ï¼ˆé“¾å¼è°ƒç”¨ï¼‰umlç±»å›¾ 1é™æ€å†…éƒ¨ç±»builderæœ‰3ä¸ªå±æ€§ï¼Œè¯¾ç¨‹ç±»æœ‰ç›¸åŒçš„3ä¸ªå±æ€§ï¼Œé“¾å¼è°ƒç”¨çš„æ—¶å€™ï¼Œç»™builderå…¨éƒ¨æˆ–è€…éƒ¨åˆ†èµ‹å€¼ï¼Œbuildçš„æ—¶å€™ï¼ŒæŠŠbuilderå¯¹è±¡ä¼ é€åˆ°courseï¼Œcourseè·å–åˆ°builderçš„å±æ€§ï¼Œç„¶åè¿”å›è¿™ä¸ªcourseï¼› Courseç±» 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.design.pattern.builder.v2;import lombok.Data;/** * Course * * @author shunhua * @date 2019-09-11 */@Datapublic class Course &#123; /** * è¯¾ç¨‹å */ private String name; /** * è¯¾ç¨‹èµ„æ–™ */ private String source; /** * è¯¾ç¨‹è§†é¢‘ */ private String video; public Course(CourseBuilder courseBuilder)&#123; this.name = courseBuilder.name; this.source = courseBuilder.source; this.video = courseBuilder.video; &#125; /** * æŠŠå®ä½“ç±»ä¸å¯¹åº”çš„åˆ›å»ºç±»å†™åœ¨ä¸€èµ·ï¼Œè¿™ç§ä½¿ç”¨æ›´å¸¸è§,ä½¿ç”¨é“¾å¼è°ƒç”¨ */ public static class CourseBuilder &#123; /** * è¯¾ç¨‹å */ private String name; /** * è¯¾ç¨‹èµ„æ–™ */ private String source; /** * è¯¾ç¨‹è§†é¢‘ */ private String video; public CourseBuilder buildName(String name) &#123; this.name = name; return this; &#125; public CourseBuilder buildSource(String source) &#123; this.source = source; return this; &#125; public CourseBuilder buildVideo(String video) &#123; this.video = video; return this; &#125; /** * * @return */ public Course build()&#123; return new Course(this); &#125; &#125;&#125; å®¢æˆ·ç«¯ 1234567891011121314151617181920212223package com.design.pattern.builder.v2;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-11 */@Slf4jpublic class Client &#123; @Test public void test()&#123; Course course = new Course.CourseBuilder() .buildName(\"javaè¿›é˜¶\") .buildSource(\"pptè¯¾ä»¶\") .buildVideo(\"javaè¿›é˜¶è§†é¢‘\") .build(); log.info(course.toString()); &#125;&#125; å»ºé€ è€…æ¨¡å¼åœ¨æºç ä¸­çš„ä½¿ç”¨jdkçš„StringBuilderå’ŒStringBuffer12345678910111213// å¦‚StringBuilderçš„appendæ–¹æ³• @Override public StringBuilder append(String str) &#123; super.append(str); return this; &#125;// å¦‚StringBufferçš„appendæ–¹æ³• @Override public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this; &#125; MyBatisçš„SqlSessionFactoryBuilder1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123; try &#123; // XMLé…ç½®çš„builder æ¥åˆ›å»º Configuration XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); // parseæ–¹æ³•åˆ›å»ºConfiguration ï¼ŒSqlSessionFactoryBuilderçš„buildæ–¹æ³•åˆ›å»ºSqlSessionFactory return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; inputStream.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; // public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125; // XMLConfigBuilder#parse public Configuration parse() &#123; if (parsed) &#123; throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\"); &#125; parsed = true; parseConfiguration(parser.evalNode(\"/configuration\")); return configuration; &#125; private void parseConfiguration(XNode root) &#123; try &#123; Properties settings = settingsAsPropertiess(root.evalNode(\"settings\")); //issue #117 read properties first propertiesElement(root.evalNode(\"properties\")); loadCustomVfs(settings); typeAliasesElement(root.evalNode(\"typeAliases\")); pluginElement(root.evalNode(\"plugins\")); objectFactoryElement(root.evalNode(\"objectFactory\")); objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\")); reflectorFactoryElement(root.evalNode(\"reflectorFactory\")); settingsElement(settings); // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode(\"environments\")); databaseIdProviderElement(root.evalNode(\"databaseIdProvider\")); typeHandlerElement(root.evalNode(\"typeHandlers\")); mapperElement(root.evalNode(\"mappers\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e); &#125; &#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"æŠ½è±¡å·¥å‚","slug":"design_pattern/creation_type/æŠ½è±¡å·¥å‚","date":"2019-09-09T16:00:00.000Z","updated":"2020-09-04T06:07:24.449Z","comments":true,"path":"posts/df11d265/","link":"","permalink":"https://gentryhuang.com/posts/df11d265/","excerpt":"","text":"å®šä¹‰ æŠ½è±¡å·¥å‚æ¨¡å¼æä¾›ä¸€ä¸ªåˆ›å»ºä¸€ç³»åˆ—ç›¸å…³æˆ–ç›¸äº’ä¾èµ–å¯¹è±¡çš„çš„æ¥å£ã€‚æ— é¡»æŒ‡å®šå®ƒä»¬å…·ä½“çš„ç±»ã€‚ ç±»å‹ åˆ›å»ºå‹ ä½¿ç”¨åœºæ™¯ å®¢æˆ·ç«¯ï¼ˆåº”ç”¨å±‚ï¼‰ä¸ä¾èµ–äºäº§å“å®ä¾‹å¦‚ä½•è¢«åˆ›å»ºã€å®ç°ç­‰ç»†èŠ‚ å¼ºè°ƒä¸€ç³»åˆ—ç›¸å…³çš„äº§å“å¯¹è±¡ï¼ˆå±äºåŒä¸€äº§å“æ—ï¼‰ä¸€èµ·ä½¿ç”¨åˆ›å»ºå¯¹è±¡éœ€è¦å¤§é‡é‡å¤çš„ä»£ç  æä¾›ä¸€ä¸ªäº§å“ç±»çš„åº“ï¼Œæ‰€æœ‰çš„äº§å“ä»¥åŒæ ·çš„æ¥å£å‡ºç°ï¼Œä»è€Œä½¿å®¢æˆ·ç«¯ä¸ä¾èµ–äºå…·ä½“å®ç°ã€‚ ä¼˜ç‚¹ åº”ç”¨å±‚ä»£ç ä¸å’Œå…·ä½“çš„äº§å“å‘ç”Ÿä¾èµ–ï¼Œåªå’Œå…·ä½“çš„äº§å“æ—å·¥å‚å‘ç”Ÿä¾èµ–å…³ç³»ï¼Œä½è€¦åˆï¼Œé«˜å†…èš ä»å…·ä½“çš„äº§å“å·¥å‚å–å‡ºæ¥çš„è‚¯å®šæ˜¯åŒä¸€äº§å“æ—ï¼Œå¼€å‘çš„æ—¶å€™é€»è¾‘æ¸…æ™° å¯¹äºäº§å“æ—æ¥è¯´ï¼Œç¬¦åˆå¼€é—­åŸåˆ™ï¼Œå¢åŠ æ–°çš„äº§å“æ—çš„æ—¶å€™ï¼Œå¯¹æ‰©å±•å¼€æ”¾ ç¼ºç‚¹ è§„å®šäº†æ‰€æœ‰å¯èƒ½è¢«åˆ›å»ºçš„äº§å“é›†åˆï¼Œäº§å“æ—ä¸­æ‰©å±•æ–°çš„äº§å“å›°éš¾ï¼Œéœ€è¦ä¿®æ”¹æŠ½è±¡å·¥ç¨‹çš„æ¥å£ã€‚å¢åŠ äº†ç³»ç»Ÿçš„æŠ½è±¡æ€§å’Œç†è§£éš¾åº¦ã€‚ ä¸ºä½•æœ‰äº§å“æ—çš„ä¸šåŠ¡åœºæ™¯å®œç”¨æŠ½è±¡å·¥å‚è®¾è®¡æ¨¡å¼ï¼Ÿè€Œä¸æ˜¯å·¥å‚è®¾è®¡æ¨¡å¼ å¦‚æœä½¿ç”¨å·¥å‚è®¾è®¡æ¨¡å¼ï¼Œå¯èƒ½ä¼šå› ä¸ºå·¥å‚ç±»å¤ªå¤šè€Œäº§ç”Ÿç±»çˆ†ç‚¸çš„ç°è±¡ äº§å“æ—å’Œäº§å“ç­‰çº§ å·¥å‚æ–¹æ³•é’ˆå¯¹çš„å°±æ˜¯äº§å“ç­‰çº§ç»“æ„ï¼Œå®ƒå¤„ç†çš„å°±æ˜¯åŒä¸€ç±»å‹äº§å“ï¼ˆå¦‚ï¼šäº§å“ç±»å‹éƒ½æ˜¯å†°ç®±ä½†æ˜¯æœ‰ä¸åŒå“ç‰Œï¼‰ æŠ½è±¡å·¥å‚é’ˆå¯¹çš„å°±æ˜¯äº§å“æ—ï¼Œå®ƒå¤„ç†çš„å°±æ˜¯ä¸€ç³»åˆ—äº§å“ï¼ˆå¦‚ï¼šæµ·å°”æ——ä¸‹ä¸åŒçš„äº§å“ï¼‰ ç®€å•åœºæ™¯è¯´æ˜ ä¸€ä¸ªè¯¾ç¨‹ä¸ä»…è¦æœ‰è§†é¢‘èµ„æ–™ï¼Œè¿˜éœ€è¦æœ‰å¯¹åº”çš„ç¬”è®°,è¿™æ ·ä¸¤è€…éƒ½å­˜åœ¨æ‰æ˜¯ä¸€é—¨è¯¾ç¨‹ã€‚ æŠ½è±¡å·¥å‚æ¼”ç»ƒ ç¬”è®° 1234567891011121314package com.design.pattern.abstractfactory;/** * Article * * @author shunhua * @date 2019-09-10 */public abstract class Article &#123; /** * ç”Ÿäº§ç¬”è®°çš„æ–¹æ³• */ public abstract void produce();&#125; javaç¬”è®° 123456789101112131415161718package com.design.pattern.abstractfactory;import lombok.extern.slf4j.Slf4j;/** * JavaArticle * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class JavaArticle extends Article &#123; @Override public void produce() &#123; log.info(\"ç”Ÿäº§Javaç¬”è®°\"); &#125;&#125; pythonç¬”è®° 123456789101112131415161718package com.design.pattern.abstractfactory;import lombok.extern.slf4j.Slf4j;/** * PythonArticle * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class PythonArticle extends Article &#123; @Override public void produce() &#123; log.info(\"ç”Ÿäº§pythonç¬”è®°\"); &#125;&#125; è§†é¢‘èµ„æº 1234567891011121314package com.design.pattern.abstractfactory;/** * Video * * @author shunhua * @date 2019-09-10 */public abstract class Video &#123; /** * ç”Ÿäº§è§†é¢‘çš„æŠ½è±¡æ–¹æ³• */ public abstract void produce();&#125; Javaè§†é¢‘èµ„æº 123456789101112131415161718package com.design.pattern.abstractfactory;import lombok.extern.slf4j.Slf4j;/** * JavaVideo * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class JavaVideo extends Video &#123; @Override public void produce() &#123; log.info(\"ç”ŸæˆJavaè§†é¢‘èµ„æº\"); &#125;&#125; pythonè§†é¢‘èµ„æº 123456789101112131415161718package com.design.pattern.abstractfactory;import lombok.extern.slf4j.Slf4j;/** * PythonVideo * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class PythonVideo extends Video &#123; @Override public void produce() &#123; log.info(\"ç”Ÿäº§pythonè§†é¢‘\"); &#125;&#125; è¯¾ç¨‹å·¥å‚ï¼ˆäº§å“æ—å·¥å‚ï¼‰ 1234567891011121314151617181920package com.design.pattern.abstractfactory;/** * CourseFactory * * @author shunhua * @date 2019-09-10 */public interface CourseFactory &#123; /** * ç”Ÿäº§è§†é¢‘ * @return */ Video getVideo(); /** * ç”Ÿäº§ç¬”è®° * @return */ Article getArticle();&#125; Javaè¯¾ç¨‹å·¥å‚ 1234567891011121314151617181920package com.design.pattern.abstractfactory;/** * JavaCourseFactory * * @author shunhua * @date 2019-09-10 */public class JavaCourseFactory implements CourseFactory &#123; @Override public Video getVideo() &#123; return new JavaVideo(); &#125; @Override public Article getArticle() &#123; return new JavaArticle(); &#125;&#125; Pythonè¯¾ç¨‹å·¥å‚ 1234567891011121314151617181920package com.design.pattern.abstractfactory;/** * PythonCourseFactory * * @author shunhua * @date 2019-09-10 */public class PythonCourseFactory implements CourseFactory&#123; @Override public Video getVideo() &#123; return new PythonVideo(); &#125; @Override public Article getArticle() &#123; return new PythonArticle(); &#125;&#125; å®¢æˆ·ç«¯ 123456789101112131415161718192021package com.design.pattern.abstractfactory;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-10 */public class Client &#123; @Test public void test()&#123; CourseFactory courseFactory = new JavaCourseFactory(); Video video = courseFactory.getVideo(); Article article = courseFactory.getArticle(); video.produce(); article.produce(); &#125;&#125; æŠ½è±¡å·¥å‚åœ¨æºç ä¸­çš„ä½¿ç”¨æºç è§£æConnectionçš„ä¸¤ä¸ªæ–¹æ³•å±æ€§åŒä¸€ä¸ªäº§å“æ—ï¼Œè¿™æ˜¯ä¸€ä¸ªçˆ¶ç±» 1234567891011121314151617181920// mysqlå’Œoracleè·å–çš„æ˜¯åŒä¸€äº§å“æ—ä¸‹çš„statementå’ŒåŒä¸€äº§å“æ—ä¸‹çš„preparestatementpublic interface Connection extends Wrapper, AutoCloseable &#123; Statement createStatement() throws SQLException; PreparedStatement prepareStatement(String sql) throws SQLException; // ... &#125; // executeQueryæ–¹æ³•å’ŒexecureUpdateæ–¹æ³•å±äºåŒä¸€ä¸ªäº§å“æ—public interface Statement extends Wrapper, AutoCloseable &#123; ResultSet executeQuery(String sql) throws SQLException; int executeUpdate(String sql) throws SQLException; &#125; MyBatisçš„SqlSessionæºç è§£æjava.sql.Connection/java.sql.Statement/org.apache.ibatis.session.SqlSessionFactoryç­‰ æ¥å£å°±æ˜¯ä¸€ä¸ªæŠ½è±¡å·¥å‚ï¼ˆä»åŒä¸€ä¸ªæŠ½è±¡å·¥å‚ä¸­è¿”å›çš„äº§å“ä¸€å®šå±äºåŒä¸€ä¸ªäº§å“æ—ï¼‰å®ƒé‡Œé¢æœ‰å¤šä¸ªå·¥å‚æ–¹æ³•ï¼Œå®ƒçš„å®ç°ç±»é€šè¿‡å®ç°ä¸åŒçš„å·¥å‚æ–¹æ³•ï¼Œæ¥åˆ›å»ºå‡ºä¸åŒçš„äº§å“ã€‚ SqlSessionFactory 12345678910111213141516171819202122232425package org.apache.ibatis.session;import java.sql.Connection;/** * Creates an &#123;@link SqlSession&#125; out of a connection or a DataSource * * @author Clinton Begin */public interface SqlSessionFactory &#123; SqlSession openSession(); SqlSession openSession(boolean autoCommit); SqlSession openSession(Connection connection); SqlSession openSession(TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType); SqlSession openSession(ExecutorType execType, boolean autoCommit); SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType, Connection connection); Configuration getConfiguration();&#125; SqlSessionFactoryå­ç±» SqlSessionManagerSqlSessionFactoryå­ç±» DefaultSqlSessionFactory","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"å·¥å‚æ–¹æ³•","slug":"design_pattern/creation_type/å·¥å‚æ–¹æ³•","date":"2019-09-08T16:00:00.000Z","updated":"2020-09-04T06:09:12.309Z","comments":true,"path":"posts/a778ad08/","link":"","permalink":"https://gentryhuang.com/posts/a778ad08/","excerpt":"","text":"å®šä¹‰ å®šä¹‰ä¸€ä¸ªåˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼ˆæŠ½è±¡æ–¹æ³•ï¼‰ï¼Œè®©å®ç°è¿™ä¸ªæ¥å£çš„ç±»ï¼ˆå®ç°æŠ½è±¡æ–¹æ³•ï¼‰æ¥å†³å®šå®ä¾‹åŒ–å“ªä¸ªç±»ï¼Œå·¥å‚æ–¹æ³•è®©ç±»çš„å®ä¾‹åŒ–æ¨è¿Ÿåˆ°å­ç±»ä¸­è¿›è¡Œï¼Œå³é€šè¿‡å­ç±»å®ç°æŠ½è±¡æ–¹æ³•æ¥åˆ›å»ºå¯¹è±¡ã€‚ å·¥å‚æ–¹æ³•å°±æ˜¯ç”¨æ¥è§£å†³åŒä¸€äº§å“ç­‰çº§çš„ä¸šåŠ¡æŠ½è±¡é—®é¢˜ã€‚å·¥å‚åˆ›å»ºå¯¹è±¡ç”¨çš„ï¼Œæ–¹æ³•é€šè¿‡å­ç±»å®ç°æ–¹æ³•æ¥åˆ›å»ºå¯¹è±¡ã€‚ ç±»å‹ åˆ›å»ºå‹ ä½¿ç”¨åœºæ™¯ åˆ›å»ºå¯¹è±¡éœ€è¦å¤§é‡çš„é‡å¤ä»£ç  å®¢æˆ·ç«¯ï¼ˆåº”ç”¨å±‚ï¼‰ä¸ä¾èµ–äºäº§å“ç±»å®ä¾‹å¦‚ä½•è¢«åˆ›å»ºã€å®ç°ç­‰ç»†èŠ‚ ä¸€ä¸ªç±»é€šè¿‡å…¶å­ç±»æ¥æŒ‡å®šåˆ›å»ºå“ªä¸ªå¯¹è±¡ä¼˜ç‚¹ç”¨æˆ·åªéœ€è¦å…³å¿ƒæ‰€éœ€äº§å“å¯¹åº”çš„å·¥å‚ï¼Œæ— é¡»å…³å¿ƒåˆ›å»ºç»†èŠ‚ã€‚åŠ å…¥æ–°çš„äº§å“ç¬¦åˆå¼€é—­åŸåˆ™ï¼Œæé«˜äº†å¯æ‰©å±•æ€§ã€‚ç¼ºç‚¹å®ç°ç±»çš„ä¸ªæ•°å®¹æ˜“è¿‡å¤šï¼ˆå¢åŠ æ–°äº§å“çš„æ—¶å€™ï¼Œä¸ä»…éœ€è¦ç¼–å†™æ–°çš„äº§å“ç±»è¿˜éœ€è¦ç¼–å†™å¯¹åº”çš„å·¥å‚ç±»ï¼Œå› æ­¤ç±»çš„ä¸ªæ•°å¢åŠ ï¼‰ã€å¢åŠ å¤æ‚åº¦ã€‚å·¥å‚æ–¹æ³•æœ¬èº«ä½¿ç”¨äº†æŠ½è±¡ï¼Œæˆ‘ä»¬éœ€è¦å¼•å…¥æŠ½è±¡å±‚ï¼Œå¦‚æœæƒ³è¦åŠ¨æ€åˆ›å»ºå¯èƒ½è¿˜ä¼šä½¿ç”¨åå°„æŠ€æœ¯ï¼Œè¿™éƒ½å¢åŠ äº†ç³»ç»Ÿçš„æŠ½è±¡æ€§å’Œç†è§£éš¾åº¦äº§å“ç­‰çº§å’Œäº§å“æ— å·¥å‚æ–¹æ³•æ˜¯ä¸ºäº†å†³ç»åŒä¸€äº§å“ç­‰çº§çš„ä¸šåŠ¡æŠ½è±¡é—®é¢˜ï¼ŒæŠ½è±¡å·¥å‚æ˜¯ä¸ºäº†è§£å†³åŒä¸€äº§å“æ—çš„é—®é¢˜ äº§å“ç­‰çº§ç›¸åŒç±»å‹çš„äº§å“ä¸ºåŒä¸€äº§å“ç­‰çº§ï¼Œå¦‚ï¼šæ±½è½¦æœ‰å¤§ä¼—ã€é•¿å®‰ã€å¥¥è¿ªç­‰ï¼Œå®ƒä»¬å±äºåŒä¸€äº§å“ç­‰çº§ äº§å“æ—ä¸åŒç±»å‹çš„äº§å“ï¼Œå¦‚é•¿å®‰æ±½è½¦ã€é•¿å®‰æ‘©æ‰˜ã€é•¿å®‰è‡ªè¡Œè½¦ å·¥å‚æ–¹æ³•æ¼”ç»ƒ Foodç±» 1234567891011121314package com.design.pattern.factorymethod;/** * ç›¸åŒç±»å‹çš„äº§å“å±äºåŒä¸€äº§å“ç­‰çº§ï¼Œæ— è®ºæ˜¯é¢åŒ…è¿˜æ˜¯æ²™æ‹‰ï¼Œå®ƒä»¬éƒ½æ˜¯åŒä¸€ä¸ªç­‰çº§ï¼Œè¿™é‡Œæ˜¯Food * * @author shunhua * @date 2019-09-09 */public abstract class Food &#123; /** * ç”Ÿäº§äº§å“æ–¹æ³• */ public abstract void produce();&#125; é¢åŒ…ç±» 123456789101112131415161718192021package com.design.pattern.factorymethod;import lombok.Data;import lombok.ToString;import lombok.extern.slf4j.Slf4j;/** * Bread * * @author shunhua * @date 2019-09-09 */@Slf4j@ToStringpublic class Bread extends Food &#123; @Override public void produce() &#123; log.info(\"ç”Ÿäº§é¢åŒ…!\"); &#125;&#125; æ²™æ‹‰ç±» 1234567891011121314151617181920package com.design.pattern.factorymethod;import lombok.ToString;import lombok.extern.slf4j.Slf4j;/** * Salad * * @author shunhua * @date 2019-09-09 */@Slf4j@ToStringpublic class Salad extends Food &#123; @Override public void produce() &#123; log.info(\"ç”Ÿæˆæ²™æ‹‰!\"); &#125;&#125; æŠ½è±¡å·¥å‚ 123456789101112131415package com.design.pattern.factorymethod;/** * å·¥å‚æ–¹æ³•,å­ç±»ç»§æ‰¿å³å¯ * è¿™é‡Œä½¿ç”¨æŠ½è±¡ç±»ä¸»è¦è€ƒè™‘åˆ°åœ¨ç±»ä¸­æœ‰äº›æ˜¯å·²çŸ¥çš„ï¼Œä½¿ç”¨æŠ½è±¡ç±»åˆé€‚ã€‚å¦‚æœå…¨éƒ½æ˜¯æœªçŸ¥çš„ä½¿ç”¨æ¥å£æ¯”è¾ƒåˆé€‚ã€‚ * @author shunhua * @date 2019-09-09 */public abstract class FoodFactory &#123; /** * å·¥å‚æ–¹æ³•ï¼Œèµ·åˆ°è§„çº¦çš„ä½œç”¨ï¼Œå¹¶ä¸ç”Ÿäº§å…·ä½“çš„äº§å“ï¼Œå…·ä½“äº§å“çš„ç”Ÿæˆç”±å…¶å®ç°å®Œæˆ * @return */ public abstract Food createFood();&#125; å­å·¥å‚ç±»-é¢åŒ…å·¥å‚ 12345678910111213141516171819package com.design.pattern.factorymethod;/** * BreadFactory åªç”Ÿäº§Bread * * @author shunhua * @date 2019-09-10 */public class BreadFactory extends FoodFactory &#123; /** * ç”Ÿäº§é¢åŒ…çš„å·¥å‚æ–¹æ³• * @return */ @Override public Food createFood() &#123; return new Bread(); &#125;&#125; å­å·¥å‚ç±»-æ²™æ‹‰å·¥å‚ 123456789101112131415161718package com.design.pattern.factorymethod;/** * SaladFactory åªç”Ÿäº§Salad * * @author shunhua * @date 2019-09-10 */public class SaladFactory extends FoodFactory &#123; /** * ç”Ÿäº§é¢åŒ…çš„å·¥å‚æ–¹æ³• * @return */ @Override public Food createFood() &#123; return new Salad(); &#125;&#125; å®¢æˆ·ç«¯ 12345678910111213141516171819202122232425262728package com.design.pattern.factorymethod;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-10 */@Slf4jpublic class Client &#123; @Test public void test()&#123; // é¢åŒ…å·¥å‚æ–¹æ³• FoodFactory breadFactory = new BreadFactory(); Food bread = breadFactory.createFood(); log.info(String.valueOf(bread)); // æ²™æ‹‰å·¥å‚æ–¹æ³• FoodFactory saladFactory = new SaladFactory(); Food salad = saladFactory.createFood(); log.info(String.valueOf(salad)); &#125;&#125; å·¥å‚æ–¹æ³•åœ¨æºç ä¸­çš„ä½¿ç”¨Collectionçš„Iteratorè§£æCollectionæ¥å£ç›¸å½“äºæŠ½è±¡å·¥å‚ï¼ˆå› ä¸ºå®ƒå¤„ç†çš„æ˜¯ç­‰çº§ç»„é—®é¢˜å³å¤šä¸ªç±»å‹çš„äº§å“ï¼‰ï¼Œå…¶ä¸­å®ƒé‡Œé¢çš„Iterator iterator()æ–¹æ³•ç›¸å½“äºå·¥å‚æ–¹æ³•ã€‚ArrayListå®ç°äº†è¿™ä¸ªæ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸ºArrayListç”Ÿäº§Itrï¼ŒItræ˜¯Iteratorç±»å‹ã€‚è¿˜æœ‰ILoggerFactoryå’ŒLoggeräº§å“æ—å¯¹åº”çš„å·¥å‚æ–¹æ³•çš„ä½¿ç”¨ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"åˆæˆå¤ç”¨åŸåˆ™","slug":"design_pattern/principle/åˆæˆå¤ç”¨åŸåˆ™","date":"2019-09-04T16:00:00.000Z","updated":"2020-07-04T13:42:18.872Z","comments":true,"path":"posts/b91a199d/","link":"","permalink":"https://gentryhuang.com/posts/b91a199d/","excerpt":"","text":"ç»§æ‰¿å…³ç³»çš„é€‰æ‹© ç»§æ‰¿å…³ç³»æ˜¯is açš„å…³ç³»ï¼Œæ‰€ä»¥çœ‹æ˜¯å¦æœ‰ç»§æ‰¿å…³ç³»ï¼Œé€šå¸¸è¦çœ‹å­ç±»å’Œçˆ¶ç±»å…±ç”¨çš„æ–¹æ³•ï¼Œå­ç±»æ˜¯å¦èƒ½å¤Ÿå®ç°çˆ¶ç±»çš„æ–¹æ³• èµ·å åˆæˆå¤ç”¨åŸåˆ™ï¼Œç»„åˆå¤ç”¨åŸåˆ™ï¼Œèšåˆå¤ç”¨åŸåˆ™ å®šä¹‰ å°½é‡ä½¿ç”¨ç»„åˆï¼Œèšåˆï¼Œè€Œä¸æ˜¯ç»§æ‰¿å…³ç³»è¾¾åˆ°å¤ç”¨è½¯ä»¶çš„ç›®çš„ ç»„åˆèšåˆï¼ˆé»‘ç®±å¤ç”¨ï¼‰ ä¼˜ç‚¹é™ä½è€¦åˆï¼Œæé«˜ç³»ç»Ÿçš„çµæ´»æ€§ã€‚ä½¿ä¸€ä¸ªç±»çš„å˜åŒ–å¯¹å…¶ä»–ç±»é€ æˆçš„å½±å“è¾ƒå° ç¼ºç‚¹ä¼šç”Ÿæˆè¾ƒå¤šçš„å¯¹è±¡è¿›è¡Œç®¡ç† ç»§æ‰¿ï¼ˆç™½ç®±å¤ç”¨ï¼‰ ä¼˜ç‚¹æ–°çš„æ‰©å±•æ€§å®¹æ˜“å®ç°ï¼Œä¿®æ”¹å’Œæ‰©å±•ç›¸å¯¹å®¹æ˜“ ç¼ºç‚¹çˆ¶ç±»çš„æ–¹æ³•ä¾µå…¥æ€§çš„å¸¦ç»™å­ç±»ï¼Œçˆ¶ç±»æ–¹æ³•çš„æ”¹å˜ï¼Œå­ç±»ä¹Ÿå¿…é¡»æ”¹å˜ï¼Œç›¸æ¯”è€¦åˆè¾ƒé«˜ ç»„åˆèšåˆåŒºåˆ«å…³ç³»å¼ºå¼±ï¼Œç»„åˆå¼ºï¼Œèšåˆå¼±","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"é‡Œæ°æ›¿æ¢åŸåˆ™","slug":"design_pattern/principle/é‡Œæ°æ›¿æ¢åŸåˆ™","date":"2019-09-03T16:00:00.000Z","updated":"2020-07-04T13:42:18.873Z","comments":true,"path":"posts/3d1cbe69/","link":"","permalink":"https://gentryhuang.com/posts/3d1cbe69/","excerpt":"","text":"å®šä¹‰ å¦‚æœå¯¹æ¯ä¸€ä¸ªç±»å‹ä¸ºT1çš„å¯¹è±¡o1ï¼Œéƒ½æœ‰ç±»å‹ä¸ºT2çš„å¯¹è±¡o2ï¼Œä½¿å¾—ä»¥T1å®šä¹‰çš„æ‰€æœ‰ç¨‹åºPåœ¨æ‰€æœ‰çš„å¯¹è±¡o1éƒ½æ›¿æ¢æˆo2æ—¶ï¼Œç¨‹åºPçš„è¡Œä¸ºæ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œé‚£ä¹ˆç±»å‹T2æ˜¯ç±»å‹T1çš„å­ç±»å‹ã€‚ å®šä¹‰æ‰©å±• ä¸€ä¸ªè½¯ä»¶å®ä½“å¦‚æœé€‚ç”¨ä¸€ä¸ªçˆ¶ç±»çš„è¯ï¼Œé‚£ä¸€å®šé€‚ç”¨äºå…¶å­ç±»ï¼Œæ‰€æœ‰å¼•ç”¨çˆ¶ç±»çš„åœ°æ–¹å¿…é¡»èƒ½é€æ˜åœ°ä½¿ç”¨å…¶å­ç±»çš„å¯¹è±¡ï¼Œå­ç±»å¯¹è±¡èƒ½å¤Ÿæ›¿æ¢çˆ¶ç±»å¯¹è±¡ï¼Œè€Œç¨‹åºé€»è¾‘ä¸å˜ã€‚ï¼ˆåå¯¹å­ç±»é‡å†™çˆ¶ç±»ï¼‰ ç‰¹ç‚¹123456789â—†å¼•ç”³æ„ä¹‰ï¼šå­ç±»å¯ä»¥æ‰©å±•çˆ¶ç±»çš„åŠŸèƒ½ï¼Œä½†ä¸èƒ½æ”¹å˜çˆ¶ç±»åŸæœ‰çš„åŠŸèƒ½ã€‚â—†å«ä¹‰1ï¼šå­ç±»å¯ä»¥å®ç°çˆ¶ç±»çš„æŠ½è±¡æ–¹æ³•ï¼Œä½†ä¸èƒ½è¦†ç›–çˆ¶ç±»çš„éæŠ½è±¡æ–¹æ³•ã€‚â—†å«ä¹‰2ï¼šå­ç±»ä¸­å¯ä»¥å¢åŠ è‡ªå·±ç‰¹æœ‰çš„æ–¹æ³•ã€‚â—†å«ä¹‰3ï¼šå½“å­ç±»çš„æ–¹æ³•é‡è½½çˆ¶ç±»çš„æ–¹æ³•æ—¶ï¼Œæ–¹æ³•çš„å‰ç½®æ¡ä»¶ï¼ˆå³æ–¹æ³•çš„è¾“å…¥&#x2F;å…¥å‚ï¼‰è¦æ¯”çˆ¶ç±»æ–¹æ³•çš„è¾“å…¥å‚æ•°æ›´å®½æ¾ã€‚ï¼ˆå…¥å‚å®½æ¾ï¼‰â—†å«ä¹‰4ï¼šå½“å­ç±»çš„æ–¹æ³•å®ç°çˆ¶ç±»çš„æ–¹æ³•æ—¶ï¼ˆé‡å†™&#x2F;é‡è½½æˆ–å®ç°æŠ½è±¡æ–¹æ³•ï¼‰ï¼Œæ–¹æ³•çš„åç½®æ¡ä»¶ï¼ˆå³æ–¹æ³•çš„è¾“å‡º&#x2F;è¿”å›å€¼ï¼‰è¦æ¯”çˆ¶ç±»æ›´ä¸¥æ ¼æˆ–ç›¸ç­‰ã€‚ï¼ˆå‡ºå‚ä¸¥è°¨ï¼‰ï¼ˆå‰ä¸¤æ¡ï¼Œçº¦å®šå­ç±»æœ€å¥½ä¸è¦é‡å†™çˆ¶ç±»çš„æ–¹æ³•ï¼Œå¦‚æœä¸€å®šè¦é‡å†™çš„è¯ï¼Œå¯ä»¥ä½¿ç”¨ç»„åˆèšåˆç­‰æ–¹æ³•å®ç°ï¼‰ï¼ˆåä¸¤æ¡,çº¦å®šäº†å­å•Šé‡è½½æˆ–å®ç°çˆ¶ç±»æ–¹æ³•çš„æ¡ä»¶ï¼‰ ä¼˜ç‚¹ çº¦æŸäº†ç»§æ‰¿æ³›æ»¥ï¼Œå¾ˆå¤šéå­ç±»çˆ¶ç±»å…³ç³»çš„ç±»ï¼Œæ²¡å¿…è¦ä½¿ç”¨ç»§æ‰¿å…³ç³» åŠ å¼ºç¨‹åºçš„å¯ç»´æŠ¤æ€§ï¼Œé™ä½éœ€æ±‚å˜æ›´æ—¶å¼•èµ·çš„é£é™© codingé‡Œæ°æ›¿æ¢åŸåˆ™ç»§æ‰¿å…³ç³»åˆ¤åˆ«ï¼ˆæ˜¯å¦æ˜¯çœŸæ­£æ„ä¹‰çš„ç»§æ‰¿ï¼‰1å­ç±»è¡Œä¸ºè§„åˆ™åº”ä¸çˆ¶ç±»è¡Œä¸ºè§„åˆ™ä¸€è‡´ï¼Œå¦‚æœå­ç±»è¾¾ä¸åˆ°è¿™ä¸€ç‚¹ï¼Œåˆ™ä¼šè¿èƒŒé‡Œæ°æ›¿æ¢åŸåˆ™ï¼Œè¿èƒŒé‡Œæ°æ›¿æ¢åŸåˆ™ä¼šæ€æ ·ï¼Ÿç»§æ‰¿é€»è¾‘æ··ä¹±ï¼Œä»£ç ä¸ä¾¿äºç»´æŠ¤ å…¥å‚æ§åˆ¶1é‡è½½çš„æ—¶å€™å…¥å‚è¦æ›´åŠ å®½æ¾ï¼Œå¯ä»¥ä¸å¼•èµ·é€»è¾‘æ··ä¹± çˆ¶ç±» 1234567import java.util.HashMap;public class Base &#123; public void method(HashMap hashMap)&#123; System.out.println(\"æ‰§è¡Œçˆ¶ç±»HashMapæ–¹æ³•\"); &#125;&#125; å­ç±» 12345678910111213141516171819import java.util.HashMap;import java.util.Map;public class Child extends Base&#123; // @Override // public void method(HashMap hashMap) &#123; // System.out.println(\"æ‰§è¡Œå­ç±»çš„HashMapæ–¹æ³•\"); // &#125; /** * å­ç±»é‡è½½ * é‡è½½çš„æ—¶å€™å…¥å‚ Mapæ¯” Hashmapå®½æ¾ï¼Œæ­¤æ—¶æ‰§è¡Œçš„æ—¶å€™ä¼šæ‰§è¡Œçˆ¶ç±»ï¼Œä¸æ‰§è¡Œé‡è½½çš„ç±» * @param Map */ public void method(Map Map) &#123; System.out.println(\"æ‰§è¡Œå­ç±»Mapæ–¹æ³•\"); &#125;&#125; å‡ºå‚æ§åˆ¶1å­ç±»çš„å‡ºå‚å¦‚æœåŒ…å«çˆ¶ç±»ï¼Œä¼šç›´æ¥æŠ¥é”™ çˆ¶ç±» 12345678910111213package com.design.pattern.principle.liskovSubstitutation.outputmethod;import java.util.Map;/** * Base * * @author shunhua * @date 2019-09-15 */public abstract class Base &#123; public abstract Map method();&#125; å­ç±» 12345678910111213141516171819202122232425262728293031package com.design.pattern.principle.liskovSubstitutation.outputmethod;import java.util.HashMap;import java.util.Map;/** * Child * * @author shunhua * @date 2019-09-15 */public class Child extends Base &#123; /** * å­ç±»çš„å‡ºå‚å¦‚æœåŒ…å«çˆ¶ç±»ï¼Œä¼šç›´æ¥æŠ¥é”™ã€‚ * @return */ /* @Override public Object method() &#123; return null; &#125;*/ /** * çˆ¶ç±»çš„å‡ºå‚åŒ…å«å­ç±»çš„å‡ºå‚æ˜¯å¯ä»¥çš„ * @return */ @Override public HashMap method()&#123; return new HashMap(2); &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"è¿ªç±³ç‰¹æ³•åˆ™","slug":"design_pattern/principle/è¿ªç±³ç‰¹æ³•åˆ™","date":"2019-09-02T16:00:00.000Z","updated":"2020-07-04T13:42:18.870Z","comments":true,"path":"posts/ebdadec7/","link":"","permalink":"https://gentryhuang.com/posts/ebdadec7/","excerpt":"","text":"å®šä¹‰ è¿ªç±³ç‰¹æ³•åˆ™ä¹Ÿå«æœ€å°‘çŸ¥é“åŸåˆ™,ä¸€ä¸ªå¯¹è±¡åº”è¯¥å¯¹å…¶ä»–å¯¹è±¡ä¿æŒæœ€å°‘çš„äº†è§£ï¼ˆæ¯”å¦‚åŒ…çš„æƒé™ï¼Œä¿®é¥°çš„å…³é”®å­—ï¼‰ã€‚å°½é‡é™ä½ç±»ä¸ç±»ä¹‹é—´çš„è€¦åˆã€‚ ä¼˜ç‚¹ é™ä½ç±»ä¹‹é—´çš„è€¦åˆã€‚ å¼ºè°ƒ åªå…³å¿ƒå‡ºç°åœ¨æˆå‘˜å˜é‡ã€æ–¹æ³•çš„å…¥å‚å’Œå‡ºå‚ä¸­çš„ç±»ï¼Œä¸å…³å¿ƒæ–¹æ³•ä½“å†…éƒ¨çš„ç±»ã€‚ ç®€å•éœ€æ±‚è¯´æ˜ å…¬å¸è€æ¿æƒ³äº†è§£æŸä¸ªä¸šåŠ¡ç»„çš„é¡¹ç›®æƒ…å†µï¼Œè€æ¿ç›´æ¥æ‰¾åˆ°TeamLeaderï¼Œä¸éœ€è¦å…³å¿ƒé¡¹ç›®ç»„å…¶ä»–æˆå‘˜ã€‚è€ŒTeamLeaderéœ€è¦è®©ç»„å†… æŸä¸ªæˆå‘˜è¿›è¡Œæ•´ç†èµ„æ–™ï¼Œç„¶äº¤ç»™è‡ªå·±ï¼Œè‡ªå·±å†äº¤ç»™è€æ¿ã€‚ codingè¿ªç±³ç‰¹æ³•åˆ™åä¾‹è€æ¿ç±» 123456789101112131415161718import java.util.ArrayList;import java.util.List;/** * æ­¤å¤„è®¾è®¡ä¸åˆç†ï¼Œåªè®¿é—®æœ‹å‹ç±»ï¼ˆæˆå‘˜å˜é‡ä¸­çš„ç±»ï¼Œè¾“å…¥ä¸­å‡ºç°çš„ç±»ï¼Œè¾“å‡ºä¸­å‡ºç°çš„ç±»ï¼‰ * æˆå‘˜æ–¹æ³•ä¸­çš„ç±»ä¸éœ€è¦å¼•å…¥(Member) */public class Boss &#123; public void findMembers()&#123; TeamLeader leader = new TeamLeader(); List&lt;Member&gt; list = new ArrayList&lt;Member&gt;(); for(int i= 0;i&lt;10;i++)&#123; list.add(new Member()); &#125; leader.countMember(list); &#125;&#125; ä¸»ç®¡ç±» 12345678import java.util.List;@Slf4jpublic class TeamLeader &#123; public void countMember(List list)&#123; log.info(\"å½“å‰é¡¹ç›®ç»„çš„æˆå‘˜æ•°ï¼š\"+list.size()); &#125;&#125; é¡¹ç›®ç»„æˆå‘˜ç±» 12345678910111213public class Member &#123; // ..&#125;``` **åº”ç”¨ç±»**```javapublic class Client&#123; public static void main(String[] args)&#123; Boss boss = new Boss(); boss.findMembers(); &#125;&#125; è¿ªç±³ç‰¹æ³•åˆ™æ­£ä¾‹è€æ¿ç±» 1234567891011121314151617package com.design.pattern.principle.demeter;/** * Boss * * @author shunhua * @date 2019-09-03 */public class Boss &#123; /** * å¯¹Memberä¸éœ€è¦è§ï¼Œåªå…³å¿ƒTeamLeader * @param teamLeader */ public void findProject(TeamLeader teamLeader)&#123; teamLeader.findProject(); &#125;&#125; ä¸»ç®¡ç±» 1234567891011121314151617181920package com.design.pattern.principle.demeter;import lombok.extern.slf4j.Slf4j;/** * TeamLeader * * @author shunhua * @date 2019-09-03 */@Slf4jpublic class TeamLeader &#123; /** * å…³æ³¨Member */ public void findProject()&#123; Member member = new Member(); log.info(String.valueOf(member)); &#125;&#125; æˆå‘˜ç±» 1234567891011package com.design.pattern.principle.demeter;/** * Member * * @author shunhua * @date 2019-09-03 */public class Member &#123; // ..&#125; åº”ç”¨ 12345678910111213141516171819202122package com.design.pattern.principle;import com.design.pattern.principle.demeter.Boss;import com.design.pattern.principle.demeter.TeamLeader;import org.junit.Test;/** * DemeterTest * * @author shunhua * @date 2019-09-03 */public class DemeterTest &#123; @Test public void test()&#123; Boss boss = new Boss(); TeamLeader teamLeader = new TeamLeader(); boss.findProject(teamLeader); &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"æ¥å£éš”ç¦»åŸåˆ™","slug":"design_pattern/principle/æ¥å£éš”ç¦»åŸåˆ™","date":"2019-09-02T16:00:00.000Z","updated":"2020-07-04T13:42:18.871Z","comments":true,"path":"posts/e0ec8882/","link":"","permalink":"https://gentryhuang.com/posts/e0ec8882/","excerpt":"","text":"å®šä¹‰ ç”¨å¤šä¸ªä¸“é—¨çš„æ¥å£ï¼Œè€Œä¸ä½¿ç”¨å•ä¸€çš„æ€»æ¥å£ï¼Œå®¢æˆ·ç«¯ä¸åº”è¯¥ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£ã€‚ æ³¨æ„ç‚¹ ä¸€ä¸ªç±»å¯¹ä¸€ä¸ªç±»çš„ä¾èµ–åº”è¯¥å»ºç«‹åœ¨æœ€å°çš„æ¥å£ä¸Šï¼ˆè¿™é‡Œçš„ç±»æ˜¯æ³›æŒ‡ï¼Œä¹Ÿä»£è¡¨æ¥å£ï¼‰ã€‚ å»ºç«‹å•ä¸€æ¥å£ï¼Œä¸è¦å»ºç«‹åºå¤§è‡ƒè‚¿çš„æ¥å£ å°½é‡ç»†åŒ–æ¥å£ï¼Œæ¥å£ä¸­çš„æ–¹æ³•å°½é‡å°‘ æ³¨æ„é€‚åº¦åŸåˆ™ï¼Œä¸€å®šè¦é€‚åº¦ï¼Œè™½ç„¶æ¥å£ä¸­çš„æ–¹æ³•å°½é‡å°‘ï¼Œä½†æ˜¯ä¹Ÿè¦æœ‰é™åº¦ã€‚ä¼˜ç‚¹ç¬¦åˆæˆ‘ä»¬å¸¸è¯´çš„é«˜å†…èšä½è€¦åˆçš„è®¾è®¡æ€æƒ³ï¼Œä»è€Œä½¿å¾—ç±»å…·æœ‰å¾ˆå¥½çš„å¯è¯»æ€§ã€å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚å’Œå•ä¸€èŒè´£åŸåˆ™æ¯”è¾ƒå•ä¸€èŒè´£åŸåˆ™æŒ‡çš„æ˜¯ç±»ã€æ¥å£å’Œæ–¹æ³•çš„èŒè´£æ˜¯å•ä¸€çš„ï¼Œå¼ºè°ƒçš„æ˜¯èŒè´£ï¼Œå¦‚æœèŒè´£æ˜¯å•ä¸€çš„é‚£ä¹ˆåœ¨ç±»æˆ–è€…æ¥å£ä¸­å…·æœ‰å¤šä¸ªæ–¹æ³•éƒ½æ˜¯å¯ä»¥çš„ï¼Œå› ä¸ºå®ƒä»¬éƒ½æ˜¯ä¸€ç±»çš„ï¼Œæ¯”å¦‚å«å£°ï¼Œä¸åŒçš„åŠ¨ç‰©æœ‰ä¸åŒçš„å«ã€‚æ¥å£éš”ç¦»åŸåˆ™æ³¨é‡åœ°æ˜¯å¯¹æ¥å£ä¾èµ–çš„éš”ç¦»ã€‚ç®€å•éœ€æ±‚è¯´æ˜ä½¿ç”¨ç»Ÿä¸€çš„æ¥å£å®šä¹‰å¤šä¸ªåŠŸèƒ½çš„æ–¹æ³•ï¼Œä½†æ˜¯æœ‰çš„å®ç°ä¸ä¸€å®šä¼šå…¨éƒ¨ç”¨åˆ°ï¼Œæœ€å¥½æ˜¯å°†è¿™ä¸ªç»Ÿä¸€çš„æ¥å£æ ¹æ®ä¸åŒçš„ç»´åº¦è¿›è¡Œæ‹†åˆ†æˆå¤šä¸ªæ¥å£ï¼Œå®ç°æ ¹æ®éœ€è¦è¿›è¡Œæ¥å£çš„å®ç°ã€‚ codingæ¥å£éš”ç¦»åŸåˆ™åä¾‹æ¥å£ 12345public interface IAnimalAction &#123; void eat(); void fly(); void swim();&#125; ç‹—å®ç°ç±» 1234567891011121314151617181920public class DogCaseOne implements IAnimalAction&#123; @Override public void eat() &#123; &#125; /** * æ³¨ï¼šè¿™é‡Œæ˜¯ç©ºæ–¹æ³•ï¼Œç‹—ä¸ä¼šé£ï¼Œæ‰€ä»¥æ˜æ˜¾è®¾è®¡çš„ä¸åˆç†ï¼Œæœ€å¥½ä¸è¦æœ‰å¤ªå¤šçš„ç©ºæ–¹æ³• */ @Override public void fly() &#123; &#125; @Override public void swim() &#123; &#125;&#125; é¸Ÿå®ç°ç±» 12345678910111213141516171819public class LarkCaseOne implements IAnimalAction&#123; @Override public void eat() &#123; &#125; @Override public void fly() &#123; &#125; /** * å¾ˆæ˜æ˜¾ï¼Œç™¾çµé¸Ÿä¸ä¼šæ¸¸æ³³ï¼Œæ­¤å¤„ä¸ºç©ºæ–¹æ³•ï¼Œè®¾è®¡ä¸åˆç† */ @Override public void swim() &#123; &#125;&#125; æ¥å£éš”ç¦»åŸåˆ™æ­£ä¾‹åƒä¸œè¥¿æ¥å£ 123456public interface IEat&#123; /** * åƒä¸œè¥¿ */ void eat();&#125; é£ç¿”æ¥å£ 123456public interface IFly&#123; /** * é£ç¿” */ void fly();&#125; æ¸¸æ³³æ¥å£ 123456public interface ISwim&#123; /** * æ¸¸æ³³ */ void swim();&#125; ç‹—å®ç°ç±» 123456789101112131415/** * ç‹—åªç”¨å®ç° åƒå’Œæ¸¸æ³³æ–¹æ³•å³å¯ */@Slf4jpublic class DogCaseTwo implements IEat,ISwim&#123; @Override public void eat() &#123; log.info(\"ç‹—åƒä¸œè¥¿!\"); &#125; @Override public void swim() &#123; log.info(\"ç‹—æ¸¸æ³³\"); &#125;&#125; é¸Ÿå®ç°ç±» 123456789101112131415/** * é¸Ÿå®ç° åƒå’Œé£æ–¹æ³•å³å¯ */@Slf4jpublic class LarkCaseTwo implements IEat,IFly&#123; @Override public void eat() &#123; log.info(\"é¸Ÿåƒä¸œè¥¿\"); &#125; @Override public void fly() &#123; log.info(\"é¸Ÿé£ç¿”\"); &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"ä¾èµ–å€’ç½®åŸåˆ™","slug":"design_pattern/principle/ä¾èµ–å€’ç½®åŸåˆ™","date":"2019-09-01T16:00:00.000Z","updated":"2020-07-04T13:42:18.866Z","comments":true,"path":"posts/91021fa8/","link":"","permalink":"https://gentryhuang.com/posts/91021fa8/","excerpt":"","text":"å®šä¹‰ é«˜å±‚æ¨¡å—ä¸åº”è¯¥ä¾èµ–ä½å±‚æ¨¡å—ï¼ŒäºŒè€…éƒ½åº”è¯¥ä¾èµ–å…¶æŠ½è±¡ã€‚ ä¼˜ç‚¹ å¯ä»¥å‡å°‘ç±»é—´çš„è€¦åˆæ€§ã€æé«˜ç³»ç»Ÿç¨³å®šæ€§ï¼Œå¢å¼ºä»£ç å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ï¼Œå¯é™ä½ä¿®æ”¹ç¨‹åºé€ æˆçš„é£é™©ã€‚ ç»†èŠ‚æè¿° æŠ½è±¡ä¸åº”è¯¥ä¾èµ–ç»†èŠ‚ï¼Œç»†èŠ‚åº”è¯¥ä¾èµ–æŠ½è±¡ã€‚é’ˆå¯¹æ¥å£ç¼–ç¨‹è€Œä¸è¦é’ˆå¯¹å®ç°ç¼–ç¨‹ã€‚ ç®€å•éœ€æ±‚è¯´æ˜ æŸåŒå­¦æƒ³è¦å­¦ä¹ æŸä¸€è¯¾ç¨‹ï¼Œæœ€ç®€å•çš„æ–¹å¼ç›´æ¥åœ¨Personä¸­ç¼–å†™ä¸€ä¸ªæ–¹æ³•å³å¯ï¼Œä½†æ˜¯å¦‚æœä»¥åæƒ³è¦å­¦ä¹ å…¶ä»–è¯¾ç¨‹å°± éœ€è¦ä¿®æ”¹Personç±»ã€‚ä¸ºäº†è§£è€¦ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè¯¾ç¨‹æŠ½è±¡å‡ºå»ï¼Œé«˜å±‚å¯¹åº•å±‚çš„ä¾èµ–ï¼Œè¿™æ ·Personä¾èµ–çš„å°±æ˜¯æŠ½è±¡ï¼Œæˆ‘ ä»¬é’ˆå¯¹æ¥å£ç¼–ç¨‹ï¼Œè€Œä¸æ˜¯é’ˆå¯¹å®ç°ç¼–ç¨‹ã€‚ codingéé¢å‘æŠ½è±¡ç¼–ç¨‹12345678910111213141516171819202122232425ç¼ºç‚¹ï¼šåº”ç”¨ä¾èµ–å…·ä½“çš„å®ç°ï¼Œå¯¹äºåç»­éœ€æ±‚å˜æ›´æ›´åŠ ä¸é€‚ç”¨&#96;&#96;&#96; **å®ä½“ç±»**&#96;&#96;&#96;javapackage com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;&#x2F;** * Person * * @author shunhua * @date 2019-09-02 *&#x2F;@Slf4jpublic class Person &#123; public void learnJavaCourse()&#123; log.info(&quot;å­¦ä¹ Javaè¯¾ç¨‹&quot;); &#125; public void learnPythonCourse()&#123; log.info(&quot;å­¦ä¹ Pythonè¯¾ç¨‹&quot;); &#125;&#125; åº”ç”¨ 12345678910111213141516171819202122package com.design.pattern.principle;import com.design.pattern.principle.dependenceinversion.PythonCourse;import com.design.pattern.principle.dependenceinversion.JavaCourse;import com.design.pattern.principle.dependenceinversion.Person;import org.junit.Test;/** * DependeceinversionTest * * @author shunhua * @date 2019-09-02 */public class DependeceinversionTest &#123; @Test public void test()&#123; Person person = new Person(); person.studyJava(); person.studyPython(); &#125;&#125; é¢å‘æ¥å£ç¼–ç¨‹1è¿™é‡Œä½¿ç”¨æ¥å£æ–¹æ³•ä¼ å‚çš„æ–¹å¼ è¯¾ç¨‹æ¥å£ 1234567891011121314package com.design.pattern.principle.dependenceinversion;/** * ICourse * * @author shunhua * @date 2019-09-02 */public interface ICourse &#123; /** * å­¦ä¹ è¯¾ç¨‹ */ void learnCourse();&#125; Javaè¯¾ç¨‹ 123456789101112131415161718package com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;/** * JavaCourse * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class JavaCourse implements ICourse &#123; @Override public void learnCourse() &#123; log.info(\"gentryhuang is learning java\"); &#125;&#125; Pythonè¯¾ç¨‹ 123456789101112131415161718package com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;/** * PythonCourse * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class PythonCourse implements ICourse &#123; @Override public void learnCourse() &#123; log.info(\"gentryhuang is learning python\"); &#125;&#125; å®ä½“ 1234567891011121314151617package com.design.pattern.principle.dependenceinversion;import lombok.extern.slf4j.Slf4j;/** * Person * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class Person &#123; public void learnCource(ICourse course)&#123; course.learnCourse(); &#125;&#125; åº”ç”¨ 123456789101112131415161718192021package com.design.pattern.principle;import com.design.pattern.principle.dependenceinversion.PythonCourse;import com.design.pattern.principle.dependenceinversion.JavaCourse;import com.design.pattern.principle.dependenceinversion.Person;import org.junit.Test;/** * DependeceinversionTest * * @author shunhua * @date 2019-09-02 */public class DependeceinversionTest &#123; @Test public void test()&#123; Person person = new Person(); person.learnCource(new JavaCourse()); person.learnCource(new PythonCourse()); &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"å•ä¸€èŒè´£åŸåˆ™","slug":"design_pattern/principle/å•ä¸€èŒè´£åŸåˆ™","date":"2019-09-01T16:00:00.000Z","updated":"2020-07-04T13:42:18.868Z","comments":true,"path":"posts/46a1bcf2/","link":"","permalink":"https://gentryhuang.com/posts/46a1bcf2/","excerpt":"","text":"å®šä¹‰ ä¸è¦å­˜åœ¨å¤šäºä¸€ä¸ªå¯¼è‡´ç±»å˜æ›´çš„åŸå› ã€‚ä½“ç°åœ¨ä¸€ä¸ªç±»/æ¥å£/æ–¹æ³•åªè´Ÿè´£ä¸€é¡¹èŒè´£ã€‚ ä¼˜ç‚¹ é™ä½ç±»çš„å¤æ‚åº¦ã€æé«˜ç±»çš„å¯è¯»æ€§ï¼Œæé«˜ç³»ç»Ÿçš„å¯ç»´æŠ¤æ€§ï¼Œé™ä½å˜æ›´å¼•èµ·çš„é£é™©ã€‚ è¯¦è§£ åœ¨ç±»çš„çº§åˆ«ä¸Šï¼Œå¯ä»¥å®šä¹‰ä¸åŒçš„ç±»å®ç°ä¸åŒçš„åŠŸèƒ½ï¼Œåœ¨æ¥å£çº§åˆ«ä¸Šï¼Œå¯ä»¥æ ¹æ®åŠŸèƒ½æŠ½è±¡å‡ºä¸åŒçš„æ¥å£ï¼Œç„¶åæŒ‰éœ€è¦å®ç°ä¸€ä¸ªæˆ–å¤šä¸ªæ¥å£ã€‚æ–¹æ³•çº§åˆ«ä¸Šï¼Œå¯ä»¥åšåˆ°ä¸åŒçš„æ–¹æ³•å®ç°ä¸åŒçš„æ“ä½œã€‚ è¦ç‚¹è®²è§£12341. å®é™…åº”ç”¨ä¸­ï¼Œç±»ä¸é‡‡ç”¨å•ä¸€èŒè´£ï¼Œæ¥å£å’Œæ–¹æ³•é‡‡ç”¨å•ä¸€èŒè´£ã€‚2. å®šä¹‰ï¼šå•ä¸€èŒè´£è§„å®š ä¸€ä¸ªç±»ï¼Œæ¥å£æˆ–è€…æ–¹æ³•ï¼Œåªæœ‰ä¸€ä¸ªå˜åŒ–çš„åŸå› 3. ä¼˜ç‚¹ï¼šé™ä½ç±»çš„å¤æ‚æ€§ï¼Œæé«˜å¯è¯»æ€§ï¼Œç»´æŠ¤æ—¶é£é™©é™ä½4. å®é™…åº”ç”¨ï¼Œå—ä¾èµ–ï¼Œç»„åˆï¼Œèšåˆè¿™äº›å…³ç³»å½±å“ï¼ŒåŒæ—¶å—æ§äºé¡¹ç›®è§„æ¨¡ï¼Œé¡¹ç›®å‘¨æœŸï¼ŒæŠ€æœ¯äººå‘˜æ°´å¹³ï¼Œå¯¹è¿›åº¦æŠŠæ§ç­‰å½±å“ã€‚åº”é€‚å½“çš„åº”ç”¨å•ä¸€èŒè´£åŸåˆ™ ç®€å•éœ€æ±‚è¯´æ˜ å®Œæˆä¸åŒåŠŸèƒ½ï¼Œå¹¶ä¸”ä½¿è®¾è®¡æ¨¡å—å…·æœ‰å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚å¯ä»¥ä½¿ç”¨ä¸åŒçš„ç±»æˆ–æ¥å£æˆ–æ–¹æ³•å»å®ŒæˆæŸä¸€ç±»åŠŸèƒ½ï¼Œè¿™æ ·å°±æ˜¾å¾—å•ä¸€ï¼Œå…·æœ‰é’ˆå¯¹æ€§ã€‚ ç±»çš„å•ä¸€èŒè´£åŸåˆ™å®ä½“ç±»1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.design.pattern.principle.singleresponsibility;import lombok.extern.slf4j.Slf4j;/** * WalkBird * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class WalkBird &#123; public void moveMode(String birdName)&#123; log.info(birdName + \"é™†åœ°å¥”è·‘\"); &#125;&#125;``` **å®ä½“ç±»2**```javapackage com.design.pattern.principle.singleresponsibility;import lombok.extern.slf4j.Slf4j;/** * FlyBird * * @author shunhua * @date 2019-09-02 */@Slf4jpublic class FlyBird &#123; public void moveMode(String birdName)&#123; log.info(birdName + \"ç”¨ç¿…è†€é£\"); &#125;&#125;``` **åº”ç”¨**```javapublic class Client &#123; public static void main(String[] args) &#123; WalkBird walkBird = new WalkBird(); walkBird.birdMove(\"é¸µé¸Ÿ\"); FlyBird flyBird = new FlyBird(); flyBird.birdMove(\"å¤§é›\"); &#125;&#125;``` ### æ¥å£çš„å•ä¸€èŒè´£**æ¥å£1**```java/** * è¿™ä¸ªæ¥å£å’Œè·å–å†…å®¹çš„æ¥å£æœ‰å…ˆåé¡ºåºï¼Œåªæœ‰å¼€å§‹å­¦ä¹ ï¼Œæ‰èƒ½è·å–å†…å®¹ï¼Œå¦‚æœé€€å‡ºå­¦ä¹ ï¼Œå°±ä¸èƒ½åœ¨è·å–å†…å®¹äº†ï¼Œ * ç”±äºèŒè´£ä¸åŒï¼Œæ‰€ä»¥è®¾è®¡ä¸¤ä¸ªæ¥å£ç¬¦åˆå•ä¸€èŒè´£åŸåˆ™ */public interface IcourseAction &#123; void beginStudy(); void quitStudy();&#125; æ¥å£2 1234567/** * æ³¨ï¼Œæœ¬æ¥å£ä¸»è¦æ˜¯è·å–è¯¾ç¨‹çš„å†…å®¹ */public interface IcourseContent &#123; String getCourseText();//è·å–è¯¾ç¨‹æ–‡æœ¬å†…å®¹ byte[] getCourseVideo();//è·å–è¯¾ç¨‹çš„è§†é¢‘&#125; å®ä½“ç±» 12345678910111213141516171819202122@Slf4jpublic class Course implements IcourseAction,IcourseContent&#123; @Override public void beginStudy() &#123; log.info(\"å¼€å§‹å­¦ä¹ !\"); &#125; @Override public void quitStudy() &#123; log.info(\"å­¦ä¹ å®Œæˆï¼\"); &#125; @Override public String getCourseText() &#123; return \"Java èµ„æ–™\"; &#125; @Override public byte[] getCourseVideo() &#123; return new byte[0]; &#125;&#125; æ–¹æ³•çš„å•ä¸€èŒè´£12345678910111213141516171819202122232425public class Method &#123; /** * å•ä¸€èŒè´£åŸåˆ™ï¼Œä¿®æ”¹ç”¨æˆ·çš„åç§° * @return */ public String updateUserName()&#123; return \"\"; &#125; /** * å•ä¸€èŒè´£åŸåˆ™,ä¿®æ”¹ç”¨æˆ·çš„å¯†ç  * @return */ public String updateUserPassWord()&#123; return \"\"; &#125; /** * ä¸ç¬¦åˆå•ä¸€èŒè´£ * @return */ public String updateUserInfo(String userId,String gender)&#123; return \" \"; &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"å¼€é—­åŸåˆ™","slug":"design_pattern/principle/å¼€é—­åŸåˆ™","date":"2019-08-31T16:00:00.000Z","updated":"2020-07-04T13:42:18.869Z","comments":true,"path":"posts/f50731fc/","link":"","permalink":"https://gentryhuang.com/posts/f50731fc/","excerpt":"","text":"å®šä¹‰ ä¸€ä¸ªè½¯ä»¶å®ä½“å¦‚ç±»ã€æ¨¡å—å’Œå‡½æ•°åº”è¯¥å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ã€‚ å¼ºè°ƒçš„æ˜¯ç”¨æŠ½è±¡æ„å»ºæ¡†æ¶ï¼Œç”¨å®ç°æ‰©å±•ç»†èŠ‚ã€‚ æ ¸å¿ƒæ€æƒ³ é¢å‘æŠ½è±¡ç¼–ç¨‹ï¼Œå› ä¸ºæŠ½è±¡æ˜¯ç¨³å®šçš„ã€‚ ç†è§£ ä¸æ”¹å˜åŸå…ˆçš„ä¸šåŠ¡é€»è¾‘ï¼Œæ–°å¢çš„åŠŸèƒ½ç‚¹é€šè¿‡é‡å†™å¤ç”¨çš„æ–¹æ³•è¿›è¡Œç¼–ç¨‹ã€‚ ä¼˜ç‚¹ æé«˜è½¯ä»¶ç³»ç»Ÿçš„å¯å¤ç”¨æ€§ä»¥åŠå¯ç»´æŠ¤æ€§ ç®€å•éœ€æ±‚è¯´æ˜ è½¯ä»¶å®ä½“ICourseï¼Œä»¥åŠå®ƒçš„å®ç°JavaCourceå®ç°äº†åŸºæœ¬åŠŸèƒ½ï¼Œå¦‚éœ€è¦é¢å¤–çš„åŠŸèƒ½å¯ä»¥å¯¹JavaCourseè¿›è¡Œæ‰©å±•å³ç»§æ‰¿æ¥æ·»åŠ ï¼Œ è¿™æ ·åœ¨ä¸ä¿®æ”¹åº•å±‚çš„ICourseå’ŒJavaCourseçš„å‰æä¸‹ï¼Œåšåˆ°åŠŸèƒ½çš„æ·»åŠ ã€‚å³ï¼Œè¶ŠåŸºå±‚çš„æ¨¡å—å½±å“èŒƒå›´è¶Šå¤§ï¼Œè¶Šé«˜å±‚çš„æ¨¡å—å½±å“ èŒƒå›´è¾ƒå°ï¼Œæ€»ä½“å®ç°äº†å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ï¼Œè¿™æ ·å°±å¯ä»¥æœ‰æ•ˆè§£å†³å½±å“èŒƒå›´ã€‚ codingv1 åŸºç±»1éœ€æ±‚ï¼šæ‰“å°å‡ºåŸä»·ä»¥åŠè¯¾ç¨‹å…¶ä»–ä¿¡æ¯ æ¥å£ 12345678910111213141516171819202122232425package com.design.pattern.principle.openclose;/** * ICourse * * @author shunhua * @date 2019-09-01 */public interface ICourse &#123; /** * è·å–è¯¾ç¨‹id * @return */ Integer getId(); /** * è·å–è¯¾ç¨‹åç§° * @return */ String getName(); /** * è·å–è¯¾ç¨‹ä»·æ ¼ * @return */ Double getPrice();&#125; å®ä½“ç±» 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.design.pattern.principle.openclose;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * JavaCourse * * @author shunhua * @date 2019-09-01 */@AllArgsConstructor@NoArgsConstructor@Datapublic class JavaCourse implements ICourse &#123; /** * è¯¾ç¨‹id */ private Integer id; /** * è¯¾ç¨‹åç§° */ private String name; /** * è¯¾ç¨‹ä»·æ ¼ */ private Double price; @Override public Integer getId() &#123; return this.id; &#125; @Override public String getName() &#123; return this.name; &#125; @Override public Double getPrice() &#123; return this.price; &#125;&#125; åº”ç”¨ 123456789101112131415161718192021222324252627package com.design.pattern.principle;import com.design.pattern.principle.openclose.ICourse;import com.design.pattern.principle.openclose.JavaCourse;import com.design.pattern.principle.openclose.JavaDiscountCourse;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * OpencloseTest * * @author shunhua * @date 2019-09-01 */@Slf4jpublic class OpencloseTest &#123; @Test public void testBase()&#123; ICourse javaCourse = new JavaCourse(100,\"Javaä»å…¥é—¨åˆ°æ”¾å¼ƒ\",200d); log.info(String.format(\"è¯¾ç¨‹id: %d,è¯¾ç¨‹å: %s, è¯¾ç¨‹ä»·æ ¼ï¼š%f\", javaCourse.getId(), javaCourse.getName(), javaCourse.getPrice()) ); &#125;&#125; v21éœ€æ±‚ï¼šæ‰“å°å‡ºåŸä»·å’ŒæŠ˜æ‰£åçš„ä»·æ ¼ä»¥åŠè¯¾ç¨‹å…¶ä»–ä¿¡æ¯ï¼ˆæ¥å£ä¸åº”è¯¥éšæ„å‘ç”Ÿå˜åŒ–ï¼Œé¢å‘æ¥å£ç¼–ç¨‹ï¼‰ æ¥å£ 12345678910111213141516171819202122232425package com.design.pattern.principle.openclose;/** * ICourse * * @author shunhua * @date 2019-09-01 */public interface ICourse &#123; /** * è·å–è¯¾ç¨‹id * @return */ Integer getId(); /** * è·å–è¯¾ç¨‹åç§° * @return */ String getName(); /** * è·å–è¯¾ç¨‹ä»·æ ¼ * @return */ Double getPrice();&#125; å®ä½“ç±» 1234567891011121314151617181920212223242526272829303132package com.design.pattern.principle.openclose;/** * JavaDiscountCourse * * @author shunhua * @date 2019-09-01 */public class JavaDiscountCourse extends JavaCourse &#123; public JavaDiscountCourse(Integer id, String name, Double price) &#123; super(id, name, price); &#125; /** * è·å–æŠ˜æ‰£ä»· * @return */ @Override public Double getPrice() &#123; return super.getPrice() * 0.8; &#125; /** * è·å–åŸä»· * @return */ public Double getOriginPrice()&#123; return super.getPrice(); &#125;&#125; åº”ç”¨ 123456789101112131415161718192021222324252627282930313233343536373839package com.design.pattern.principle;import com.design.pattern.principle.openclose.ICourse;import com.design.pattern.principle.openclose.JavaCourse;import com.design.pattern.principle.openclose.JavaDiscountCourse;import lombok.extern.slf4j.Slf4j;import org.junit.Test;/** * OpencloseTest * * @author shunhua * @date 2019-09-01 */@Slf4jpublic class OpencloseTest &#123; @Test public void testBase()&#123; ICourse javaCourse = new JavaCourse(100,\"Javaä»å…¥é—¨åˆ°æ”¾å¼ƒ\",200d); log.info(String.format(\"è¯¾ç¨‹id: %d,è¯¾ç¨‹å: %s, è¯¾ç¨‹ä»·æ ¼ï¼š%f\", javaCourse.getId(), javaCourse.getName(), javaCourse.getPrice()) ); &#125; @Test public void testEx()&#123; ICourse javaCource = new JavaDiscountCourse(100,\"javaä»å…¥é—¨åˆ°æ”¾å¼ƒ\",200d); log.info(String.format(\"è¯¾ç¨‹id: %d,è¯¾ç¨‹å: %s, è¯¾ç¨‹åŸä»·ï¼š%fï¼Œè¯¾ç¨‹æŠ˜æ‰£ä»·æ ¼ï¼š%f\", javaCource.getId(), javaCource.getName(), ((JavaDiscountCourse) javaCource).getOriginPrice(), javaCource.getPrice()) ); &#125;&#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"ç®€å•å·¥å‚","slug":"design_pattern/other_type/ç®€å•å·¥å‚","date":"2019-08-28T16:00:00.000Z","updated":"2020-08-09T09:24:21.833Z","comments":true,"path":"posts/90fd4bf3/","link":"","permalink":"https://gentryhuang.com/posts/90fd4bf3/","excerpt":"","text":"å®šä¹‰ ç”±ä¸€ä¸ªå·¥å‚å¯¹è±¡å†³å®šåˆ›å»ºå‡ºå“ªä¸€ç§äº§å“ç±»çš„å®ä¾‹ ç±»å‹ åˆ›å»ºå‹ï¼Œä½†ä¸å±äºGOF23ç§è®¾è®¡æ¨¡å¼ã€‚ç®€å•å·¥å‚æ¨¡å¼ä¸¥æ ¼æ„ä¹‰ä¸Šè¯´å¹¶ä¸æ˜¯ä¸€ç§è®¾è®¡æ¨¡å¼ï¼Œå®ƒæ˜¯ä¸€ç§ç¼–ç ä¸Šçš„é£æ ¼å’Œä¹ æƒ¯ ä½¿ç”¨åœºæ™¯ å·¥å‚ç±»è´Ÿè´£åˆ›å»ºçš„å¯¹è±¡æ¯”è¾ƒå°‘ å®¢æˆ·ç«¯ï¼ˆåº”ç”¨å±‚ï¼‰åªçŸ¥é“ä¼ å…¥å·¥å‚ç±»çš„å‚æ•°ï¼Œå¯¹äºå¦‚ä½•åˆ›å»ºå¯¹è±¡ï¼ˆé€»è¾‘ï¼‰ä¸å…³å¿ƒä¼˜ç‚¹åªéœ€è¦ä¼ å…¥ä¸€ä¸ªæ­£ç¡®çš„å‚æ•°ï¼Œå°±å¯ä»¥è·å–æ‰€éœ€è¦çš„å¯¹è±¡è€Œæ— é¡»çŸ¥é“å…¶åˆ›å»ºç»†èŠ‚ç¼ºç‚¹ç®€å•å·¥å‚ç±»çš„èŒè´£ç›¸å¯¹è¿‡é‡ï¼Œå¢åŠ æ–°çš„äº§å“éœ€è¦ä¿®æ”¹å·¥å‚ç±»çš„åˆ¤æ–­é€»è¾‘ï¼Œè¿èƒŒäº†å¼€é—­åŸåˆ™ã€‚ codingæœªä½¿ç”¨ç®€å•å·¥å‚æ¨¡å¼çš„ä»£ç çˆ¶ç±» 12345678910111213public abstract class Video&#123; public abstract void printVideo();&#125;``` **å­ç±»JavaVideo**```java@Slf4jpublic class JavaVideo extends Video&#123; @Override public void printVideo() &#123; log.info(\"å½•åˆ¶javaè§†é¢‘\"); &#125;&#125; å­ç±»PythonVideo 1234567@Slf4jpublic class PythonVideo extends Video&#123; @Override public void printVideo() &#123; log.info(\"å½•åˆ¶pythonè§†é¢‘\"); &#125;&#125; åº”ç”¨ 1234567public class client&#123; @Test public void test()&#123; Video video = new JavaVideo(); video.printVideo(); &#125;&#125; ä½¿ç”¨ç®€å•å·¥å‚æ¨¡å¼ å·¥å‚ç±» 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.design.pattern.simplefactory;/** * ç®€å•å·¥å‚ * * @author shunhua * @date 2019-09-09 */public class FoodFactory &#123; /** * éšç€è¦äº§å“å¢å¤šï¼Œä»¥ä¸‹é€»è¾‘å¿…é¡»è¦ä¿®æ”¹ * @param type è¿™é‡Œä½¿ç”¨å­—ç¬¦ä¸²æ ¹æ®ç±»å‹è¿›è¡Œåˆ›å»ºä¸åŒçš„å®ä¾‹ * @return */ public Food createFood(String type)&#123; if(\"salad\".equalsIgnoreCase(type))&#123; return new Salad(); &#125;else if(\"bread\".equalsIgnoreCase(type))&#123; return new Bread(); &#125; return null; &#125; /** * * @param c è¿™é‡Œä½¿ç”¨åå°„åˆ›å»ºä¸åŒçš„å®ä¾‹ * @return */ public Food createFood(Class c)&#123; Food food = null; try &#123; food = (Food) Class.forName(c.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return food; &#125;&#125; çˆ¶ç±» 1234567891011121314package com.design.pattern.simplefactory;/** * Food * * @author shunhua * @date 2019-09-09 */public abstract class Food &#123; /** * ç”Ÿäº§äº§å“æ–¹æ³• */ public abstract void produce();&#125; å­ç±»é¢åŒ… 123456789101112131415161718package com.design.pattern.simplefactory;import lombok.extern.slf4j.Slf4j;/** * Bread * * @author shunhua * @date 2019-09-09 */@Slf4jpublic class Bread extends Food &#123; @Override public void produce() &#123; log.info(\"ç”Ÿäº§é¢åŒ…!\"); &#125;&#125; å­ç±»æ²™æ‹‰ 123456789101112131415161718package com.design.pattern.simplefactory;import lombok.extern.slf4j.Slf4j;/** * Salad * * @author shunhua * @date 2019-09-09 */@Slf4jpublic class Salad extends Food &#123; @Override public void produce() &#123; log.info(\"ç”Ÿæˆæ²™æ‹‰!\"); &#125;&#125; å®¢æˆ·ç«¯ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.design.pattern.simplefactory;import com.common.base.ObjectUtils;import com.design.pattern.simplefactory.Bread;import com.design.pattern.simplefactory.Food;import com.design.pattern.simplefactory.FoodFactory;import com.design.pattern.simplefactory.Salad;import org.junit.Test;/** * Client * * @author shunhua * @date 2019-09-09 */public class Client &#123; /* éç®€å•å·¥å‚æ¨¡å¼ @Test public void simpleFactoryBefore()&#123; // è¿™é‡Œéœ€è¦ä¾èµ–å…·ä½“çš„ç”Ÿäº§ç±» Food food = new Bread(); Food food1 = new Salad(); food.produce(); food1.produce(); &#125;*/ /* @Test public void simpleFactoryByType()&#123; // åˆ›å»ºä¸€ä¸ªç®€å•å·¥å‚ FoodFactory factory = new FoodFactory(); // ç”±å·¥å‚åˆ›å»ºå®ä¾‹å¯¹è±¡ Food food = factory.createFood(\"salad\"); food.produce(); &#125; */ @Test public void simpleFactoryByClass()&#123; FoodFactory factory = new FoodFactory(); Food food = factory.createFood(Bread.class); if(ObjectUtils.isNotNull(food))&#123; food.produce(); &#125; &#125;&#125; ç®€å•å·¥å‚åœ¨æºç ä¸­çš„ä½¿ç”¨jdkçš„Calendaræºç è§£æ123456789101112131415161718192021222324252627282930313233343536373839404142434445// è¿™é‡Œä½¿ç”¨çš„æ˜¯é™æ€æ–¹æ³•ï¼Œå› ä¸ºä¸éœ€è¦å†é€šè¿‡ç»§æ‰¿è¿›è¡Œæ‰©å±•ã€‚å¦‚éœ€æ‰©å±•å°±ä¸ä½¿ç”¨staticå…³é”®å­—public static Calendar getInstance(TimeZone zone, Locale aLocale)&#123; return createCalendar(zone, aLocale); &#125; private static Calendar createCalendar(TimeZone zone, Locale aLocale) &#123; CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale).getCalendarProvider(); if (provider != null) &#123; try &#123; return provider.getInstance(zone, aLocale); &#125; catch (IllegalArgumentException iae) &#123; // fall back to the default instantiation &#125; &#125; Calendar cal = null; if (aLocale.hasExtensions()) &#123; String caltype = aLocale.getUnicodeLocaleType(\"ca\"); if (caltype != null) &#123; // æ ¹æ®ä¸åŒçš„ç±»å‹åˆ›å»ºæ—¥æœŸå¯¹è±¡ switch (caltype) &#123; case \"buddhist\": cal = new BuddhistCalendar(zone, aLocale); break; case \"japanese\": cal = new JapaneseImperialCalendar(zone, aLocale); break; case \"gregory\": cal = new GregorianCalendar(zone, aLocale); break; &#125; &#125; &#125; if (cal == null) &#123; if (aLocale.getLanguage() == \"th\" &amp;&amp; aLocale.getCountry() == \"TH\") &#123; cal = new BuddhistCalendar(zone, aLocale); &#125; else if (aLocale.getVariant() == \"JP\" &amp;&amp; aLocale.getLanguage() == \"ja\" &amp;&amp; aLocale.getCountry() == \"JP\") &#123; cal = new JapaneseImperialCalendar(zone, aLocale); &#125; else &#123; cal = new GregorianCalendar(zone, aLocale); &#125; &#125; return cal; &#125; DriverManageræºç è§£æï¼ˆé€šè¿‡classForNameè·å–ï¼‰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public static Connection getConnection(String url, java.util.Properties info) throws SQLException &#123; // Gets the classloader of the code that called this method, may // be null. ClassLoader callerCL = DriverManager.getCallerClassLoader(); return (getConnection(url, info, callerCL)); &#125;// Worker method called by the public getConnection() methods. private static Connection getConnection( String url, java.util.Properties info, ClassLoader callerCL) throws SQLException &#123; java.util.Vector drivers = null; /* * When callerCl is null, we should check the application's * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if(callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; if(url == null) &#123; throw new SQLException(\"The url cannot be null\", \"08001\"); &#125; println(\"DriverManager.getConnection(\\\"\" + url + \"\\\")\"); if (!initialized) &#123; initialize(); &#125; synchronized (DriverManager.class)&#123; // use the readcopy of drivers drivers = readDrivers; &#125; // Walk through the loaded drivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for (int i = 0; i &lt; drivers.size(); i++) &#123; DriverInfo di = (DriverInfo)drivers.elementAt(i); // If the caller does not have permission to load the driver then // skip it. if ( getCallerClass(callerCL, di.driverClassName ) != di.driverClass ) &#123; println(\" skipping: \" + di); continue; &#125; try &#123; println(\" trying \" + di); Connection result = di.driver.connect(url, info); if (result != null) &#123; // Success! println(\"getConnection returning \" + di); return (result); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; // if we got here nobody could connect. if (reason != null) &#123; println(\"getConnection failed: \" + reason); throw reason; &#125; println(\"getConnection: no suitable driver found for \"+ url); throw new SQLException(\"No suitable driver found for \"+ url, \"08001\"); &#125;","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"umlåŸºç¡€","slug":"design_pattern/uml","date":"2019-08-27T16:00:00.000Z","updated":"2020-08-09T09:14:31.577Z","comments":true,"path":"posts/cadc5d6c/","link":"","permalink":"https://gentryhuang.com/posts/cadc5d6c/","excerpt":"","text":"å®šä¹‰ç»Ÿä¸€å»ºæ¨¡è¯­è¨€ï¼ˆç¼©å†™UMLï¼‰ï¼Œéä¸“åˆ©çš„ç¬¬ä¸‰ä»£å»ºæ¨¡å’Œè§„çº¦è¯­è¨€ ç‰¹ç‚¹ UMLæ˜¯ä¸€ç§å¼€æ”¾çš„æ–¹æ³• UMLç”¨äºè¯´æ˜ã€å¯è§†åŒ–ã€æ„å»ºå’Œç¼–å†™ä¸€ä¸ªæ­£åœ¨å¼€å‘çš„é¢å‘å¯¹è±¡çš„ã€è½¯ä»¶å¯†é›†ç³»ç»Ÿçš„åˆ¶å“çš„å¼€æ”¾æ–¹æ³• UMLå±•ç°äº†ä¸€ç³»åˆ—æœ€ä½³å·¥ç¨‹çš„å®è·µï¼Œè¿™äº›æœ€ä½³å®è·µåœ¨å¯¹å¤§è§„æ¨¡ï¼Œå¤æ‚ç³»ç»Ÿè¿›è¡Œå»ºæ¨¡æ–¹é¢ï¼Œç‰¹åˆ«æ˜¯åœ¨è½¯ä»¶æ¶æ„å±‚é¢å·²ç»è¢«éªŒè¯æœ‰æ•ˆ UMLåˆ†ç±» ç»“æ„å¼å›¾å½¢ å¼ºè°ƒçš„æ˜¯ç³»ç»Ÿå¼çš„å»ºæ¨¡ï¼Œå…·ä½“åŒ…å«é™æ€å›¾ï¼ˆç±»å›¾ã€å¯¹è±¡å›¾ã€åŒ…å›¾ï¼‰ã€å®ç°å›¾ï¼ˆç»„ä»¶å›¾ã€éƒ¨ç½²å›¾ï¼‰ã€å‰–é¢å›¾ä»¥åŠå¤åˆç»“æ„å›¾ è¡Œä¸ºå¼å›¾å½¢ å¼ºè°ƒç³»ç»Ÿæ¨¡å‹ä¸­è§¦å‘çš„äº‹ä»¶ï¼Œå…·ä½“åŒ…å«æ´»åŠ¨å›¾ã€çŠ¶æ€å›¾ä»¥åŠç”¨ä¾‹å›¾ äº¤äº’å¼å›¾å½¢ å±äºè¡Œä¸ºå¼å›¾å½¢å­é›†åˆï¼Œå¼ºè°ƒç³»ç»Ÿæ¨¡å‹ä¸­èµ„æºæµç¨‹ã€‚å…·ä½“åŒ…å«é€šä¿¡å›¾ã€äº¤äº’æ¦‚å¿µå›¾ã€æ—¶åºå›¾ ä»¥åŠæ—¶é—´å›¾ â€‹ UMLç±»å›¾ç”¨äºè¡¨ç¤ºç±»ã€æ¥å£ã€å®ä¾‹ç­‰ä¹‹é—´ç›¸äº’çš„é™æ€å…³ç³»ã€‚è™½ç„¶åå­—å«ç±»å›¾ï¼Œä½†ç±»å›¾ä¸­å¹¶ä¸åªæœ‰ç±»ï¼Œè¿˜å¯èƒ½åŒ…æ‹¬æƒé™ã€å±æ€§ã€æ–¹æ³•ç­‰ UMLè®°å¿†æ–¹å¼12341. umlç®­å¤´ï¼šä»å­ç±»æŒ‡å‘çˆ¶ç±»ï¼Œåªæœ‰çŸ¥é“å¯¹æ–¹ä¿¡æ¯æ—¶æ‰èƒ½æŒ‡å‘å¯¹æ–¹æ–¹å‘2. ç©ºå¿ƒä¸‰è§’ç®­å¤´ï¼šç»§æ‰¿æˆ–å®ç°ï¼Œå®çº¿-ç»§æ‰¿ï¼šç§¯æçš„ï¼Œå¼ºå…³è”ï¼Œå…³è”ï¼Œé€šå¸¸ä¸€ä¸ªç±»ä¸­æœ‰ä¸€ä¸ªç±»çš„å¯¹è±¡åšå±æ€§ï¼›è™šçº¿-å®ç°ï¼šæ¶ˆæçš„ï¼Œå¼±å…³è”ï¼Œä¾èµ–3. ç©ºå¿ƒè±å½¢ï¼šèšåˆï¼Œï¼ˆæ³¨ï¼šå¯ä»¥çœ‹ä½œä¸€ä¸ªç›˜å­ï¼Œå¯ä»¥æ”¾å¾ˆå¤šç›¸åŒçš„ä¸œè¥¿ï¼ˆç®­å¤´æ–¹å‘æ‰€æŒ‡çš„ç±»ï¼‰ï¼Œèšåœ¨ä¸€èµ·ã€‚æ˜¯has açš„å…³ç³»ï¼‰å¼±å…³è”4. å®å¿ƒè±å½¢ï¼šç»„åˆï¼Œï¼ˆæ³¨ï¼šä»£è¡¨å™¨çš¿é‡Œæœ‰å®ä½“ç»“æ„å­˜åœ¨ï¼Œç»„åˆèµ·æ¥æˆä¸ºä¸€ä¸ªã€‚æ˜¯contains-açš„å…³ç³»ï¼‰å¼ºå…³è” umlç®­å¤´ï¼šä»å­ç±»æŒ‡å‘çˆ¶ç±»ï¼Œå®šä¹‰å­ç±»æ—¶éœ€è¦é€šè¿‡extendså…³é”®å­—æŒ‡å®šçˆ¶ç±»ï¼Œåªæœ‰çŸ¥é“å¯¹æ–¹ä¿¡æ¯æ—¶æ‰èƒ½æŒ‡å‘å¯¹æ–¹æ–¹å‘ å®çº¿-ç»§æ‰¿ | è™šçº¿-å®ç° â€‹ ç©ºå¿ƒè±å½¢-èšåˆ å®å¿ƒè±å½¢-ç»„åˆ ç»„åˆå…³ç³»ä¸­å¸¸è§çš„æ•°å­—è¡¨è¾¾ 123456â—†å¸¸è§æ•°å­—è¡¨è¾¾åŠå«ä¹‰ï¼Œå‡è®¾æœ‰Aç±»å’ŒBç±»ï¼Œæ•°å­—æ ‡è®°åœ¨Aç±»ä¾§â—†0..1ï¼š0æˆ–1ä¸ªå®ä¾‹ åœ¨ç³»ç»ŸæŸä¸€æ—¶åˆ»ï¼Œbçš„å®ä¾‹å¯ä»¥ä¸0ä¸ªæˆ–1ä¸ªAå®ä¾‹ç›¸å…³â—†0..*ï¼š0æˆ–å¤šä¸ªå®ä¾‹ åœ¨ç³»ç»ŸæŸä¸€æ—¶åˆ»ï¼Œbçš„å®ä¾‹å¯ä»¥ä¸0ä¸ªæˆ–å¤šä¸ªAå®ä¾‹ç›¸å…³â—†1..1ï¼š1ä¸ªå®ä¾‹. bçš„å®ä¾‹å¯ä»¥å’Œ1ä¸ªAå®ä¾‹ç›¸å…³â—†1åªèƒ½æœ‰ä¸€ä¸ªå®ä¾‹. bçš„å®ä¾‹å¯ä»¥å’Œ1ä¸ªAå®ä¾‹ç›¸å…³â—†1..*ï¼šè‡³å°‘æœ‰ä¸€ä¸ªå®ä¾‹. bå®ä¾‹å¯ä»¥ä¸ä¸€ä¸ªæˆ–å¤šä¸ªAå®ä¾‹ç›¸å…³ UMLæ—¶åºå›¾ æ˜¯æ˜¾ç¤ºå¯¹è±¡ä¹‹é—´äº¤äº’çš„å›¾ï¼Œè¿™äº›å¯¹è±¡æ˜¯æŒ‰ç…§æ—¶é—´é¡ºåºæ’åˆ—çš„ æ—¶åºå›¾ä¸­ åŒ…å«çš„å»ºæ¨¡å…ƒç´  å¯¹è±¡ï¼ˆActorï¼‰ã€ç”Ÿå‘½çº¿ï¼ˆlifelineï¼‰ã€æ§åˆ¶ç„¦ç‚¹ï¼ˆFocus of controlï¼‰ã€æ¶ˆæ¯ï¼ˆMessageï¼‰ç­‰ æ—¶åºå›¾ç¤ºä¾‹ 12345678910111213ç«–çº¿ä»£è¡¨ç”Ÿå‘½çº¿å¯¹è±¡ï¼šcï¼šclient ï¼Œsï¼šserverï¼Œdï¼šdevice ä»£è¡¨å®ä¾‹æ¶ˆæ¯ï¼šç®­å¤´ä»£è¡¨çš„å…ƒç´ (open,workç­‰)ç«–çŸ©å½¢ä»£è¡¨å®ä¾‹å¤„äºæŸç§æ´»åŠ¨ä¸­ï¼Œå®çº¿å®å¿ƒç®­å¤´ï¼šä»£è¡¨æ–¹æ³•è°ƒç”¨ï¼ŒåŒæ­¥è°ƒç”¨å®çº¿éå®å¿ƒç®­å¤´ï¼šä»£è¡¨å¼‚æ­¥è°ƒç”¨è™šçº¿ï¼šä»£è¡¨è¿”å› UMLç±»å›¾è®²è§£123456789101112131415+ å…¬å…±æ–¹æ³•- privateæƒé™# protectedæƒé™ åŒ…å†…å’ŒåŒ…å¤–ç»§æ‰¿çš„å­ç±»éƒ½èƒ½å¼•ç”¨~ defaultæƒé™ï¼ˆåŒ…æƒé™ï¼‰åªæœ‰åŒ…å†…èƒ½å¼•ç”¨ä¸‹åˆ’çº¿ é™æ€ Staticæ–œä½“ æŠ½è±¡ç±»ï¼ˆæˆ–æŠ½è±¡æ–¹æ³•ï¼‰ï¼ˆåŒ…å«æŠ½è±¡æ–¹æ³•çš„å¿…æ˜¯æŠ½è±¡ç±»ï¼‰ï¼ˆç±»å’Œè‡³å°‘ä¸€ä¸ªæ–¹æ³•éƒ½æ˜¯æ–œä½“ï¼‰æ–¹æ³• å¯ä»¥å¸¦å‚ï¼Œå¯ä»¥ä¸å¸¦å‚ è¿”å›å€¼å†™åˆ°å†’å·åè¾¹ï¼Œvoidä¸ç”¨åŠ  UMLæ•´ä½“è®²è§£12345678910è®¾è®¡æ¨¡å¼ä¸­çš„å¯¹è±¡å…³ç³»: ä¾èµ–å…³ç³» è™šçº¿ç®­å¤´ï¼Œç®­å¤´æ–¹å‘æŒ‡å‘è¢«ä¾èµ–çš„éƒ¨åˆ† ç»„åˆå…³ç³» å®å¿ƒè±å½¢ èšåˆå…³ç³» ç©ºå¿ƒè±å½¢ï¼ˆæƒ³è±¡æˆç›˜å­ï¼Œç››ä¸œè¥¿ï¼Œç›˜å­çš„å¤šï¼Œå¦ä¸€æ–¹å°‘ï¼‰ å…³è”å…³ç³» å®çº¿ç®­å¤´ï¼Œç®­å¤´æŒ‡å‘è¢«å…³è”çš„éƒ¨åˆ† ç±»ä¸ç±»çš„è¿æ¥ï¼Œï¼ˆå®ƒä½¿ä¸€ä¸ªç±»çŸ¥é“å¦ä¸€ä¸ªç±»çš„å±æ€§å’Œæ–¹æ³•ï¼Œå…³è”å…³ ç³»ä¸€èˆ¬ç”¨æˆå‘˜å˜é‡å®ç°ï¼‰ ç»§æ‰¿ ç©ºå¿ƒä¸‰è§’å½¢å®çº¿ å®ç° ç©ºå¿ƒä¸‰è§’å½¢è™šçº¿æ³¨æ„ï¼š å®ç°æ¥å£æœ‰ä¸¤ç§æ–¹å¼ï¼Œä¸€ç§æ˜¯æ£’æ£’ç³–çš„å½¢å¼ï¼Œå¦ä¸€ç§æ˜¯è™šçº¿ç©ºå¿ƒä¸‰è§’å½¢çš„æ–¹å¼ UMLä¸­éƒ¨åˆ†å¯¹æ¯”1234567891.1 å…³è”å’Œä¾èµ–çš„å¯¹æ¯”å…³è”æ˜¯aç±»ä¸­å­˜åœ¨bç±»å¯¹è±¡ï¼Œä¼é¹…ç±»ä¸­æœ‰æ°”å€™ç±»çš„å±æ€§ä¾èµ–æ˜¯aç±»æˆå‘˜æ–¹æ³•ä¸­æœ‰bç±»çš„å±æ€§ï¼ŒåŠ¨ç‰©æ–°é™ˆä»£è°¢æ–¹æ³•ä¸­æœ‰æ°´å’Œç©ºæ°”çš„å±æ€§ï¼Œåªæœ‰è°ƒè¿™ä¸ªæ–¹æ³•çš„æ—¶å€™ï¼Œæ‰å¯èƒ½ä¸´æ—¶ç”¨ä¸€ä¸‹1.2 ç»„åˆå’Œèšåˆçš„å¯¹æ¯”ç»„åˆæœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸï¼Œé¸Ÿæœ‰ç¿…è†€ï¼Œé¸Ÿæ­»äº†ï¼Œç¿…è†€ä¸å¤å­˜åœ¨å¤§é›ç¾¤æœ‰å¤§é›ï¼Œä¸€åªå¤§é›æŒ‚äº†ï¼Œå¤§é›ç¾¤ä¸ä¼šæ¶ˆå¤±1.3 ç»§æ‰¿å’Œå®ç°çš„å¯¹å®çº¿ï¼šç»§æ‰¿è™šçº¿ï¼šå®ç°","categories":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"Redis","slug":"Redis","permalink":"https://gentryhuang.com/categories/Redis/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/categories/RPC/"},{"name":"JDK","slug":"JDK","permalink":"https://gentryhuang.com/categories/JDK/"},{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Redisæ•°æ®ç»“æ„","slug":"Redisæ•°æ®ç»“æ„","permalink":"https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Dubbo","slug":"Dubbo","permalink":"https://gentryhuang.com/tags/Dubbo/"},{"name":"ä»£ç†","slug":"ä»£ç†","permalink":"https://gentryhuang.com/tags/%E4%BB%A3%E7%90%86/"},{"name":"JUC","slug":"JUC","permalink":"https://gentryhuang.com/tags/JUC/"},{"name":"AQS","slug":"AQS","permalink":"https://gentryhuang.com/tags/AQS/"},{"name":"Spring","slug":"Spring","permalink":"https://gentryhuang.com/tags/Spring/"},{"name":"Protocol","slug":"Protocol","permalink":"https://gentryhuang.com/tags/Protocol/"},{"name":"Filter","slug":"Filter","permalink":"https://gentryhuang.com/tags/Filter/"},{"name":"Mina","slug":"Mina","permalink":"https://gentryhuang.com/tags/Mina/"},{"name":"Netty","slug":"Netty","permalink":"https://gentryhuang.com/tags/Netty/"},{"name":"Javassist","slug":"Javassist","permalink":"https://gentryhuang.com/tags/Javassist/"},{"name":"Redis","slug":"Redis","permalink":"https://gentryhuang.com/tags/Redis/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://gentryhuang.com/tags/Zookeeper/"},{"name":"RPC","slug":"RPC","permalink":"https://gentryhuang.com/tags/RPC/"},{"name":"SPI","slug":"SPI","permalink":"https://gentryhuang.com/tags/SPI/"},{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","permalink":"https://gentryhuang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}