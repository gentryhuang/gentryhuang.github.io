<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>AQS 原理分析 - Condition实现原理 | gentryhuang的博客</title>
  <meta name="description" content="概述在 JUC 之前，Java 实现等待&#x2F;通知模式是通过定义在 Object 中的一组监视器方法 wait方法、notify()以及 notifyAll() 与 synchronized 关键配合完成。在 JUC 中单独提供了一套等待&#x2F;通知模式的实现方式，具体实现是 Condition 接口与 Lock 接口配合完成。 Condition 接口提供了类似 Object 的监视器方法，但该接口中定义">
<meta property="og:type" content="article">
<meta property="og:title" content="AQS 原理分析 - Condition实现原理">
<meta property="og:url" content="https://gentryhuang.com/posts/40e44c1f/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="概述在 JUC 之前，Java 实现等待&#x2F;通知模式是通过定义在 Object 中的一组监视器方法 wait方法、notify()以及 notifyAll() 与 synchronized 关键配合完成。在 JUC 中单独提供了一套等待&#x2F;通知模式的实现方式，具体实现是 Condition 接口与 Lock 接口配合完成。 Condition 接口提供了类似 Object 的监视器方法，但该接口中定义">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gentryhuang.com/posts/40e44c1f/concurrent-condition-process.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/40e44c1f/concurrent-condition-method.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/40e44c1f/concurrent-condition-await-process.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/40e44c1f/concurrent-condition-Interrupt-signal.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/40e44c1f/concurrent-condition-signal.jpg">
<meta property="article:published_time" content="2020-10-26T13:45:45.000Z">
<meta property="article:modified_time" content="2020-12-29T02:56:55.778Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="JUC">
<meta property="article:tag" content="AQS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gentryhuang.com/posts/40e44c1f/concurrent-condition-process.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/40e44c1f/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            
            <p>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次</p>
            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">37</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AQS/" rel="tag">AQS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a><span class="tag-list-count">33</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/" rel="tag">JDK</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUC/" rel="tag">JUC</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javassist/" rel="tag">Javassist</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mina/" rel="tag">Mina</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/" rel="tag">RPC</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">Redis数据结构</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPI/" rel="tag">SPI</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/" rel="tag">Zookeeper</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">32</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.14px;">AQS</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/JDK/" style="font-size: 13.57px;">JDK</a> <a href="/tags/JUC/" style="font-size: 13.43px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.29px;">Javassist</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/RPC/" style="font-size: 13.71px;">RPC</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.14px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.29px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.29px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.86px;">设计模式</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/9e3a7d05/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/9e3a7d05/" class="title">并发 - 线程池工具类</a>
              </p>
              <p class="item-date">
                <time datetime="2020-12-09T16:00:00.000Z" itemprop="datePublished">2020-12-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/d7cef21d/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/d7cef21d/" class="title">并发 - 线程池</a>
              </p>
              <p class="item-date">
                <time datetime="2020-12-02T16:00:00.000Z" itemprop="datePublished">2020-12-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/37f29896/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/37f29896/" class="title">并发 - Java并发工具类</a>
              </p>
              <p class="item-date">
                <time datetime="2020-11-05T16:00:00.000Z" itemprop="datePublished">2020-11-06</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/40e44c1f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/40e44c1f/" class="title">AQS 原理分析 - Condition实现原理</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-26T13:45:45.000Z" itemprop="datePublished">2020-10-26</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/2362a8ea/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/2362a8ea/" class="title">Redis原理 - 链表</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-20T11:33:59.000Z" itemprop="datePublished">2020-10-20</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#场景"><span class="toc-number">2.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实现原理"><span class="toc-number">3.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码解析"><span class="toc-number">4.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Condition"><span class="toc-number">4.1.</span> <span class="toc-text">Condition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConditionObject"><span class="toc-number">4.2.</span> <span class="toc-text">ConditionObject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#等待"><span class="toc-number">4.3.</span> <span class="toc-text">等待</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#addConditionWaiter"><span class="toc-number">4.3.1.</span> <span class="toc-text">addConditionWaiter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlinkCancelledWaiters"><span class="toc-number">4.3.2.</span> <span class="toc-text">unlinkCancelledWaiters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fullyRelease"><span class="toc-number">4.3.3.</span> <span class="toc-text">fullyRelease</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#等待转入同步队列"><span class="toc-number">4.3.4.</span> <span class="toc-text">等待转入同步队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isOnSyncQueue"><span class="toc-number">4.3.5.</span> <span class="toc-text">isOnSyncQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#checkInterruptWhileWaiting"><span class="toc-number">4.3.6.</span> <span class="toc-text">checkInterruptWhileWaiting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transferAfterCancelledWait"><span class="toc-number">4.3.7.</span> <span class="toc-text">transferAfterCancelledWait</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通知"><span class="toc-number">4.4.</span> <span class="toc-text">通知</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通知单个节点"><span class="toc-number">4.4.1.</span> <span class="toc-text">通知单个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通知所有节点"><span class="toc-number">4.4.2.</span> <span class="toc-text">通知所有节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加入同步队列"><span class="toc-number">4.4.3.</span> <span class="toc-text">加入同步队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从等待中醒来"><span class="toc-number">4.5.</span> <span class="toc-text">从等待中醒来</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#检查中断模式"><span class="toc-number">4.5.1.</span> <span class="toc-text">检查中断模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#竞争同步状态"><span class="toc-number">4.5.2.</span> <span class="toc-text">竞争同步状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理中断"><span class="toc-number">4.5.3.</span> <span class="toc-text">处理中断</span></a></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-concurrent/aqs-condition" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      AQS 原理分析 - Condition实现原理
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/40e44c1f/" class="article-date">
	  <time datetime="2020-10-26T13:45:45.000Z" itemprop="datePublished">2020-10-26</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/JDK/">JDK</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/AQS/" rel="tag">AQS</a>, <a class="article-tag-link" href="/tags/JUC/" rel="tag">JUC</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/40e44c1f/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 7.7k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 29(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 JUC 之前，Java 实现等待/通知模式是通过定义在 Object 中的一组监视器方法 <code>wait方法</code>、<code>notify()</code>以及 <code>notifyAll()</code> 与 <code>synchronized</code> 关键配合完成。在 JUC 中单独提供了一套等待/通知模式的实现方式，具体实现是 <code>Condition</code> 接口与 <code>Lock</code> 接口配合完成。</p>
<p><code>Condition</code> 接口提供了类似 Object 的监视器方法，但该接口中定义的方法功能上更强大。比如，<code>Condition</code> 支持响应/不响应中断以及等待超时等接口。</p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>生产者-消费者是 Condition 其中的一个经典使用场景，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notFull Condition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notEmpty Condition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组，大小为 100</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分别为添加的下标、移除的下标和数组当前数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产</span></span><br><span class="line"><span class="comment">     * 如果数组满了，则添加线程进入等待状态，直到有空位才能生产</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x item</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 元素数量等于数组长度，线程等待</span></span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加元素</span></span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="comment">// 添加下标 putptr 递增，和移除的下标 takeptr 对应。</span></span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 数组元素个数递增</span></span><br><span class="line">            ++count;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生产后通知消费</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费</span></span><br><span class="line"><span class="comment">     * 如果数组为空，则消费线程进入等待状态，直到数组中有元素才能继续消费</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> item</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 数组为空，线程等待</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出元素</span></span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="comment">// 移除下标递增</span></span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 数组元素个数递减</span></span><br><span class="line">            --count;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消费后通知生产</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述示例中，BoundedBuffer 实现了生产者-消费者模式，下面进行简单概述：</strong></p>
<ol>
<li>使用 Condition 时先获取相应的 Lock 锁，和 Object 类中的方法类似，需要先获取某个对象的监视器锁才能执行等待、通知方法。</li>
<li>生产和消费方法中判断数组状态使用的是 while 自旋而非 if 判断，目的是防止过早或意外的通知，当且仅当条件满足才能从 await() 返回。</li>
</ol>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>Condition 结合 Lock 实现的等待通知机制包括两部分内容即等待和通知，分别依赖单向链表和双向链表。Condition 接口的实现类是 AQS 内部类 ConditionObject，它内部维护的队列称为条件队列，基于单向链表实现。Lock 是基于 AQS 实现的，它内部维护的队列称为同步队列，基于双向链表实现。Condition 对象是由 Lock 对象创建出来的，并且一个 Lock 对象可以创建多个 Condition 对象，每个 Condition 对象共享 Lock 这个外部资源。</p>
<p>获取到同步状态（锁）的线程调用 <code>await</code> 方法进行等待时，会先将自己打包成一个节点并加入到对应的条件队列中，加入成功后会<strong>完全释放同步状态</strong>，释放同步状态成功后会在该条件队列的尾部等待，于此同时该线程在同步队列中的节点也会被移除。在某个 Condition 上（条件队列）等待的线程节点被<code>signal</code> 或 <code>signalAll</code> 后，对应的线程节点会被转到外部类的同步队列中，这意味着该节点有了竞争同步状态的机会，线程需要获取到同步状态才能继续后续的逻辑。需要说明的是，一个锁对象可以同时创建 N 个 Condition 对象（对应 N 个条件队列），这表明获取到同步状态的线程可以有选择地加入条件队列并在该队列中等待，其它获取到同步状态的线程可以有选择地唤醒某个条件队列中的等待的线程。但不管有多少个条件队列，竞争同步状态的线程节点需要统一转到外部类的同步队列中，也就是 Lock 维护的双向链表，此后就是竞争同步状态的逻辑了。</p>
<p>下图简单描述了 Condition 的工作原理：</p>
<p><img src="/posts/40e44c1f/concurrent-condition-process.jpg" alt></p>
<p>以上就是 Condition 实现的等待-通知机制。需要说明的是，上述描述没有涉及过多的细节，如异常流的处理。接下来我们通过对代码层面的解析来全面了解 Condition 的机制。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p><img src="/posts/40e44c1f/concurrent-condition-method.jpg" alt></p>
<p>Condition 接口中定义的方法和 Object 中的监视器方法类似，区别在于前者支持响应中断和超时等待。下面对该接口中定义的方法进行简单说明：</p>
<ol>
<li><strong>void await() throws InterruptedException 方法</strong><blockquote>
<p>响应中断的等待方法，线程进入条件队列挂起，直到被通知或中断。</p>
</blockquote>
</li>
<li><strong>void awaitUninterruptibly() 方法</strong><blockquote>
<p>不响应中断的等待方法，不会抛出中断异常，仅仅复位中断标志，线程进入条件队列挂起，直到被通知或中断。</p>
</blockquote>
</li>
<li><strong>long awaitNanos(long nanosTimeout) throws InterruptedException 方法</strong><blockquote>
<p>在 await() 基础上增加了超时功能，线程进入条件队列挂起直到被通知、中断或超时，如果在 nanosTimeout 内返回，那么返回值就是 nanosTimeout - 实际耗时，如果返回值是 0 或者负数，表示超时了。</p>
</blockquote>
</li>
<li><strong>boolean awaitUntil(Date deadline) throws InterruptedException 方法</strong><blockquote>
<p>在 await() 基础上增加了超时功能，线程进入条件队列挂起直到被通知、中断或者到某个时间。如果没有到指定时间就通知，返回 true，否则表示超时。</p>
</blockquote>
</li>
<li><strong>boolean await(long time, TimeUnit unit) throws InterruptedException 方法</strong><blockquote>
<p>和 awaitUntil(Date deadline) 方法几乎一致，前者是绝对时间，后者是时间粒度。</p>
</blockquote>
</li>
<li><strong>void signal() 方法</strong><blockquote>
<p>将条件队列中的头节点转到同步队列中，以等待竞争同步状态。</p>
</blockquote>
</li>
<li><strong>void signalAll() 方法</strong><blockquote>
<p>将条件队列中的所有节点依次转到同步队列中，以等待竞争同步状态。此时条件队列进入下一个周期。</p>
</blockquote>
</li>
</ol>
<p>在 JUC 中 Condition 主要基于 <code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 实现的，在语义中就是我们说的锁概念，而锁又是基于 AQS 实现的。总的来说，Condition 依赖 Lock，Lock 实现是基于 AQS 的。下面以 <code>ReentrantLock</code> 作为 Condition 的实现进行说明。</p>
<h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2><p><code>ConditionObject</code>实现了 Condition 接口，同时作为<code>AbstractQueuedSynchronizer</code>的内部类，因为 Condition 的操作需要获取到同步状态，因此其实现类作为<code>AbstractQueuedSynchronizer</code>的内部类是比较合理的，这意味着<code>ConditionObject</code>可以访问外部资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractQueuedSynchronizer</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件队列 - 头节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件队列 - 尾节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 ConditionObject 对象内部维护了一个基于单向链表的条件队列，该队列是 Condition 实现等待-通知机制的关键。既然是链表，其中的节点定义是什么呢？ConditionObject 没有重新定义链表节点，而是直接使用外部类 AbstractQueuedSynchronizer 定义的 Node ，这也是合理的。下面我们简单看下该 Node 的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractQueuedSynchronizer</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 共享类型节点，表明节点在共享模式下等待</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 独占类型节点，表明节点在独占模式下等待</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态 - 取消（线程已经取消）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态 - 通知（后继线程需要被唤醒）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态 - 条件等待（线程在 Condition 上等待）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态 - 传播（无条件向后传播唤醒动作）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态，初始值为 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步队列中使用，前驱节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步队列中使用，后继节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 节点中封装的线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件队列中使用，后置节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>条件队列和同步队列共同使用上述的 <strong>Node</strong> 节点构建队列，区别在于前者底层数据结构是双向链表，节点的维护使用 <strong>prev</strong> 和 <strong>next</strong> 属性，后者底层数据结构是单向链表，节点维护使用 <strong>nextWaiter</strong> 属性，两者中的节点等待状态都是使用 <strong>waitStatus</strong> 属性。</p>
<p><code>ReentrantLock</code> 对象和 <code>ReentrantReadWriteLock</code> 对象可以创建多个 ConditionObject 对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面对 <code>ReentrantLock</code> 和 <code>ConditionObject</code> 的关联关系进行说明：</strong></p>
<ol>
<li>ConditionObject 维护的条件队列和 ReentrantLock 维护的同步队列的节点都是 Node 的实例，条件队列的线程节点需要移动到同步队列中以参与竞争同步状态。</li>
<li>ReentrantLock 对象与 ConditionObject 对象的比例关系为： 1 : N ，每个 ConditionObject 都能直接访问 ReentrantLock 这个外部类资源。</li>
<li>一个同步队列对应 N 个条件队列，同步队列中的线程（获取到同步状态）可以选择性地进入不同的条件队列进行等待，而多个条件队列中的线程节点要参与竞争同步状态就需要进入同一个同步队列。</li>
</ol>
<p>接下来对等待和通知的核心代码进行分析，根据主要流程分别说明。</p>
<h2 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h2><p><code>ConditionObject</code> 中实现了几种不同功能的等待方法，在介绍 <code>Condition</code> 接口时已经详细说明，下面先对 <code>await()</code> 的方法实现进行分析。</p>
<p>当获取同步状态的线程调用 <code>await()</code> 方法时，相当于同步队列的头节点中的线程（获取了同步状态的节点）进入到 Condition 的条件队列中，完全释放同步状态后同步队列将会移除该线程对应的节点。</p>
<p><img src="/posts/40e44c1f/concurrent-condition-await-process.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 响应中断</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 将当前线程封装到节点中，并将节点加入到条件队列尾部</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 保存并完全释放同步状态，注意是完全释放，因为允许可重入锁。如果没有持锁会抛出异常，也就是释放同步状态失败</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="comment">// 记录中断模式</span></span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *3. 判断上述加入到条件队列的线程节点是否被移动到了同步队列中，不在则挂起线程（曾经获取到锁的线程）。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 循环结束的条件：</span></span><br><span class="line"><span class="comment">         * 1. 其它线程调用 signal/signalAll 方法，将当前线程节点移动到同步队列中，节点对应的线程将会在竞争同步状态的过程被前驱节点唤醒。</span></span><br><span class="line"><span class="comment">         * 2. 其它线程中断了当前线程，当前线程会自行尝试进入同步队列中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 挂起线程，直到被唤醒或被中断</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 检测中断模式：</span></span><br><span class="line"><span class="comment">             * 在线程从 park 中返回时，需要判断是被唤醒返回还是被中断返回。</span></span><br><span class="line"><span class="comment">             * 1). 如果线程没有被中断，则返回 0，此时需要重试循环继续判断当前线程节点是否在同步队列中。</span></span><br><span class="line"><span class="comment">             * 2). 如果线程被中断</span></span><br><span class="line"><span class="comment">             *   - 中断发生在被唤醒之前，当前线程（线程节点）会尝试自行进入同步队列并返回 THROW_IE，后续需要抛出中断异常。todo</span></span><br><span class="line"><span class="comment">             *   - 中断发生在被唤醒之后，即当前线程（线程节点）尝试自行进入同步队列失败（说明其它线程调用过了 signal/signalAll 唤醒线程并尝试将线程节点转到同步队列），</span></span><br><span class="line"><span class="comment">             *     返回 REINTERRUPT ，后续需要重新中断线程，向后传递中断标志。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 醒来后，被移动到同步队列的节点 node 重新尝试获取同步状态成功，且获取同步状态的过程中如果被中断，接着判断中断模式非 THROW_IE 的情况会更新为 REINTERRUPT</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 清理取消节点。正常情况下 signal/signalAll 将节点转到同步队列的同时会将节点的 nextWaiter 置空，这里主要对自行进入到同步队列中的节点进行处理。</span></span><br><span class="line">        <span class="comment">// 1） 中断模式为 THROW_IE 的情况下 nextWaiter 不会被置空，且等待状态为 0 ，这种情况下节点应该从条件队列中移除。</span></span><br><span class="line">        <span class="comment">// 2） fullyRelease 方法出现异常，nextWaiter 不会被置空，且等待状态为 CANCELLED，清理任务会由后继的节点完成。</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">            <span class="comment">// 清理条件队列中取消的节点（重组链表）</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 如果线程发生过中断则根据 THROW_IE 或 REINTERRUPT 分别抛出异常或者重新中断。 todo 最终都要抛出异常还获取个球球的锁</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面对上述整个等待流程进行概述：</strong></p>
<ol>
<li>将获取到同步状态的线程封装到节点中并加入到条件队列。</li>
<li>完全释放同步状态，并记录获取到的同步状态，为后面重新竞争同步状态做准备。</li>
<li>在条件队列中等待被唤醒，或者被中断。</li>
<li>再次竞争挂起等待前的同步状态。</li>
<li>对中断情况的处理，抛出异常或重新中断线程以复位中断标志。</li>
</ol>
<p>以上对整个等待流程进行了总体描述，下面对其中的分支流进行说明。</p>
<h3 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h3><p>将当前线程封装到节点中，然后加入到当前 Condition 对象维护的条件队列的尾部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 条件队列尾节点</span></span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选出条件队列中有效尾节点。这里主要处理 fullyRelease 方法出现异常的情况。</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 如果需要，清理条件队列中取消的节点（重组链表）</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 重读尾节点，可能为 null</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点封装当前线程，节点状态为 CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化条件队列，firstWaiter 更新为当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点加入到条件队列尾</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新条件队列尾指针指向</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="comment">// 返回当前线程关联的节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述节点加入到条件队列过程中涉及到清理无效节点的逻辑，该逻辑由 <code>unlinkCancelledWaiters()</code> 方法完成，下面我们来分析该方法。</p>
<h3 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters"></a>unlinkCancelledWaiters</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从首节点开始进行节点检测</span></span><br><span class="line">            Node t = firstWaiter;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录上一个非取消状态节点，参照节点是当前遍历节点</span></span><br><span class="line">            Node trail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 保存当前节点的下一个节点，在当前节点处于取消状态时进行替换</span></span><br><span class="line">                Node next = t.nextWaiter;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果节点的等待状态不是 CONDITION，表明这个节点被取消了。</span></span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                    <span class="comment">// 取消状态的节点要断开和链表的关联</span></span><br><span class="line">                    t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 重组链表，保证链条为空或者所有节点都是非取消状态</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * trail == null，表明 next 之前的节点的等待状态均为取消状态，此时更新 firstWaiter 引用指向</span></span><br><span class="line"><span class="comment">                     * trail != null，表明 next 之前有节点的等待状态为 CONDITION ，此时只需 trail.nextWaiter 指向 next 节点</span></span><br><span class="line"><span class="comment">                     * 注意：</span></span><br><span class="line"><span class="comment">                     * 1 firstWaiter 一定指向链表第一个非取消节点，或者为 null</span></span><br><span class="line"><span class="comment">                     * 2 trail 第一次赋值一定和 firstWaiter 一样的值</span></span><br><span class="line"><span class="comment">                     * 3 firstWaiter 一旦被赋予非 null 的值后就不会再变动，后续的节点连接就看 trail 的表演：</span></span><br><span class="line"><span class="comment">                     *   - 如果当前节点是取消节点，就 trail.nextWaiter 指向 next 节点</span></span><br><span class="line"><span class="comment">                     *   - 如果当前节点是非取消节点，trail 跟着节点走</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                        firstWaiter = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        trail.nextWaiter = next;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前节点没有后继则遍历结束，此时当前节点是无效节点，因此将 lastWaiter 回退即更新为上一个非取消节点</span></span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                        lastWaiter = trail;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前节点处于等待状态</span></span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    trail = t;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下一个节点</span></span><br><span class="line">                t = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>unlinkCancelledWaiters() 方法用于清理取消节点，重新构造链表，主要处理因中断自行加入同步队列和释放同步状态异常的情况。<strong>取消节点的定义是线程节点挂起时被中断或释放同步状态失败。</strong></p>
<p>线程节点加入到条件队列后就可以执行完全释放同步状态操作。</p>
<h3 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease"></a>fullyRelease</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取同步状态（拿到同步状态的线程）</span></span><br><span class="line">            <span class="keyword">int</span> savedState = getState();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放指定数量的同步状态</span></span><br><span class="line">            <span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync.tryRelease ，没有持有锁会抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 返回同步状态，释放之前的值</span></span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放同步状态失败，需要将节点状态设置为取消状态，后续会被清理</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法用于完全释放同步状态，属于 <code>AbstractQueuedSynchronizer</code> 中定义的方法，上文也提到 <code>ConditionObject</code> 是 <code>AbstractQueuedSynchronizer</code> 的内部类，因此可以共享外部资源。注意，该方法是完全释放同步状态，一般情况下为了避免死锁的产生，锁的实现上一般支持重入功能。</p>
<p>需要特别说明的是，如果线程没有获取到同步状态就执行 <code>await()</code> 方法，该线程关联的节点能进入到条件队列中，但是进入条件队列后需要调用 <code>fullyRelease</code> 方法执行同步状态释放逻辑，由于没有获取到同步状态在执行到 <code>ReentrantLock.tryRelease</code> 方法时会抛出异常，进而 finally 块中将节点状态进行更新 <code>node.waitStatus = Node.CANCELLED</code> ，这个已经入队到条件队列的节点会被<strong>后续节点</strong>清理出去，也即执行 <code>unlinkCancelledWaiters</code> 方法。</p>
<p>释放持有的同步状态后会进入自旋等待逻辑，该过程会对通知和中断进行不同的处理。</p>
<h3 id="等待转入同步队列"><a href="#等待转入同步队列" class="headerlink" title="等待转入同步队列"></a>等待转入同步队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">   <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挂起线程，直到被唤醒或被中断</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检测中断模式：</span></span><br><span class="line"><span class="comment">         * 在线程从 park 中返回时，需要判断是被唤醒返回还是被中断返回。</span></span><br><span class="line"><span class="comment">         * 1. 如果线程没有被中断，则返回 0，此时需要重试循环继续判断当前线程节点是否在同步队列中。</span></span><br><span class="line"><span class="comment">         * 2. 如果线程被中断</span></span><br><span class="line"><span class="comment">         *   - 中断发生在被唤醒之前，当前线程（线程节点）会尝试自行进入同步队列并返回 THROW_IE，后续需要抛出中断异常。</span></span><br><span class="line"><span class="comment">         *   - 中断发生在被唤醒之后，即当前线程（线程节点）尝试自行进入同步队列失败（说明其它线程调用过了 signal/signalAll 唤醒线程并尝试将线程节点转到同步队列），</span></span><br><span class="line"><span class="comment">         *     返回 REINTERRUPT ，后续需要重新中断线程，向后传递中断标志，由后续代码去处理中断。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">          <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>以上自旋等待逻辑主要包括两部分工作，检查节点是否在同步队列中和处理中断。下面我们分别来看这两个逻辑。</p>
<h3 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h3><p>检查节点是否已经转到同步队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractQueuedSynchronizer</span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 同步队列中的节点状态可能为 0、SIGNAL = -1、PROPAGATE = -3、CANCELLED = 1，但不会是 CONDITION = -2</span></span><br><span class="line"><span class="comment">         * 2 node.prev 仅会在节点获取同步状态后，调用 setHead 方法将自己设为头结点时被设置为 null，所以只要节点在同步队列中，node.prev 一定不会为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 条件队列中节点是使用 nextWaiter 指向后继节点，next 均为 null 。同步队列中节点是使用 next 指向后继节点。</span></span><br><span class="line"><span class="comment">         * 2 node.next != null 代表当前节点 node 一定在同步队列中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * node.next == null 也不能说明节点 node 一定不在同步队列中，因为同步队列入队方法不是同步的而是自旋方式，</span></span><br><span class="line"><span class="comment">         * 是先设置 node.prev，后设置 node.next，CAS 失败时 node 可能已经在同步队列上了，所以这里还需要进一步查找。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从同步队列尾部开始搜索，查找是否存在 node 节点。</span></span><br><span class="line"><span class="comment">     * 为什么不从头开始搜索，因为节点的 prev 可能会为 null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if present</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t == node)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            t = t.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="checkInterruptWhileWaiting"><a href="#checkInterruptWhileWaiting" class="headerlink" title="checkInterruptWhileWaiting"></a>checkInterruptWhileWaiting</h3><p>检查在线程挂起期间是否发生中断，若发生中断则需要进行特殊处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                 (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                 <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法逻辑如下：</strong></p>
<blockquote>
<ol>
<li>线程未被中断，则返回 0</li>
<li>线程被中断且自行入同步队列成功，则返回 THROW_IE，这种情况下后续需要抛出中断异常</li>
<li>线程被中断且未能自行入同步队列（其它线程已经执行 signal/signalAll 方法，节点状态已被更改），则返回 REINTERRUPT ，这种情况下后续需要重新中断线程以恢复中断标志</li>
</ol>
</blockquote>
<h3 id="transferAfterCancelledWait"><a href="#transferAfterCancelledWait" class="headerlink" title="transferAfterCancelledWait"></a>transferAfterCancelledWait</h3><p>取消等待（中断）后的转移节点操作，即线程被中断优先尝试自行加入同步队列，如果在中断之前已经执行过加入操作就等待加入同步队列完成。</p>
<p><img src="/posts/40e44c1f/concurrent-condition-Interrupt-signal.jpg" alt></p>
<p><strong>注意：</strong></p>
<ol>
<li><strong>由于中断尝试自行加入同步队列的线程节点并没有与条件队列断开连接，该节点会在后续的逻辑中进行清除。</strong></li>
<li><strong>即使发生了中断，节点依然会转到到同步队列中。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 中断如果发生在 节点被转到同步队列前，应该尝试自行将节点转到同步队列中，并返回 true</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">           <span class="comment">// 将节点转到同步队列中</span></span><br><span class="line">           enq(node);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 如果上面的CAS失败，则表明已经有线程调用 signal/signalAll 方法更新过节点状态（CONDITION -&gt; 0 ），并调用 enq 方法尝试将节点转到同步队列中。</span></span><br><span class="line"><span class="comment">         * 2. 这里使用 while 进行判断节点是否已经在同步队列上的原因是，signal/signalAll 方法可能仅设置了等待状态，还没有完成将线程节点转到同步队列中，所以这里用自旋的</span></span><br><span class="line"><span class="comment">         * 方式等待线程节点加入到同步队列，否则会影响后续重新获取同步状态（调用 acquireQueued() 方法，该方法需要线程节点入同步队列才能调用，否则会抛出np异常）。这种情况表明了中断发生在节点被转移到同步队列期间。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">           <span class="comment">// 让出 CPU</span></span><br><span class="line">           Thread.yield();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 中断在节点被转到同步队列期间或之后发生，返回 false</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断中断发生的时机：</strong></p>
<blockquote>
<ol>
<li>中断在节点被转到同步队列前发生，此时返回 true</li>
<li>中断在节点被转到同步队列过程或之后发生，此时返回 false</li>
</ol>
</blockquote>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>在解析通知源码之前我们先回到线程挂起等待源码处，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">   <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 挂起线程，直到被唤醒或被中断</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 有中断情况，进进行处理</span></span><br><span class="line">       <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>线程释放同步状态成功后会挂起等待其它线程唤醒自己（同步队列中的线程节点），或者被其它线程中断。关于线程挂起等待时被中断的处理逻辑前文已经解析，主要是确保被中断的线程也能加入到同步队列中。</p>
<p><img src="/posts/40e44c1f/concurrent-condition-signal.jpg" alt></p>
<p><strong>下面对通知流程进行说明：</strong></p>
<ol>
<li>将条件队列中头节点转到同步队列中。</li>
<li>根据情况决定是否唤醒对应的线程，不唤醒则在同步队列中等待，唤醒则准备竞争同步状态。</li>
</ol>
<p>下面我们解析正常通知逻辑。</p>
<h3 id="通知单个节点"><a href="#通知单个节点" class="headerlink" title="通知单个节点"></a>通知单个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将条件队列中的头节点转到同步队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查线程是否获取了独占锁，未获取独占锁调用 signal 方法是不合法的</span></span><br><span class="line">         <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 条件队列的头节点</span></span><br><span class="line">         Node first = firstWaiter;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将条件队列的头节点转到同步队列中</span></span><br><span class="line">         <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="comment">// 因为条件队列的 firstWaiter 要出队转到同步队列中，因此使用 firstWaiter 后继节点占领 firstWaiter。</span></span><br><span class="line">            <span class="keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">// 只有一个节点的话，尾节点指向设置为 null</span></span><br><span class="line">              lastWaiter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 断开 first 与条件队列的连接</span></span><br><span class="line">              first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 transferForSignal 方法将节点移到同步队列中，如果转到同步队列失败，则对后面的节点进行操作，依次类推</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="通知所有节点"><a href="#通知所有节点" class="headerlink" title="通知所有节点"></a>通知所有节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 检查线程是否获取了独占锁，未获取独占锁调用 signalAll 方法是不合法的</span></span><br><span class="line">   <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 条件队列的头节点</span></span><br><span class="line">     Node first = firstWaiter;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">          doSignalAll(first);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 置空条件队列的头、尾指针，因为当前队列元素要全部出队，避免将新入队的节点误唤醒</span></span><br><span class="line">     lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将条件队列中所有的节点都转到同步队列中。</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">         </span><br><span class="line">          Node next = first.nextWaiter;      </span><br><span class="line">          <span class="comment">// 将节点从条件队列中移除</span></span><br><span class="line">          first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// 将节点转到同步队列中</span></span><br><span class="line">          transferForSignal(first);</span><br><span class="line">             </span><br><span class="line">          first = next;</span><br><span class="line">         &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h3 id="加入同步队列"><a href="#加入同步队列" class="headerlink" title="加入同步队列"></a>加入同步队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果更新节点的等待状态由 CONDITION 到 0 失败，则说明该节点已经被取消，也就不需要再转到同步队列中了。</span></span><br><span class="line"><span class="comment">     * 由于整个 signal /signalAll 都需要拿到锁才能执行，因此这里不存在线程竞争的问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 enq 方法将 node 加入到同步队列中尾，并返回 node 的前驱节点</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1 如果前驱节点的等待状态 ws &gt; 0，说明前驱节点已经被取消了，此时应该唤醒 node 对应的线程去尝试获取同步状态，准确的应该是先找大哥，找大哥过程会剔除它的无效前驱节点。</span></span><br><span class="line"><span class="comment">     *    注意，这里只是入队并没有执行剔除取消节点的逻辑，虽然AQS唤醒操作支持从尾节点向前寻找最前的有效节点并唤醒，但还是应该主动唤醒 node 对应的线程，以更新大哥节点。</span></span><br><span class="line"><span class="comment">     * 2 如果前驱节点的等待状态 ws &lt;= 0 ，通过 CAS 操作将 node 的前驱节点 p 的等待状态设置为 SIGNAL，当节点 p 释放同步状态后会唤醒它的后继节点 node。</span></span><br><span class="line"><span class="comment">     *   如果 CAS 设置失败（可能节点 p 在次期间被取消了），则应该立即唤醒 node 节点对应的线程，原因和 1 一致。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加入同步队列主要逻辑如下：</strong></p>
<ol>
<li>由于执行 signal/signalAll 方法需要持有同步状态，因此 transferForSignal 方法是不存在并发问题的。</li>
<li>对条件队列中的非 CONDITION 状态的节点不执行转入同步队列操作。</li>
<li>将符合条件的节点加入到同步队列中，并返回前驱节点。</li>
<li>正常情况下不会执行 <code>LockSupport.unpark(node.thread)</code> 唤醒线程，而是节点进入同步队列然后方法返回 true，transferForSignal 方法结束。</li>
<li>同步队列中 node 的前驱节点取消等待，或者 CAS 等待状态失败，需要唤醒线程，这个属于异常流。</li>
</ol>
<p>注意，执行 <code>signal</code> 或 <code>signalAll</code> 方法仅仅让线程节点具备竞争同步状态的机会，确切地说是将条件队列的节点移动到同步队列中，仅此而已。至于能不能获取到同步状态需要看具体竞争结果，要知道不仅条件队列中线程节点阻塞等待，同步队列中可能也有大量的线程节点在等待唤醒，况且条件队列中的线程节点需要移动到同步队列中才有资格参与同步状态的竞争。</p>
<p>通过下面的伪代码可以推演出多种可能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认使用的是非公平锁，意味着即使同步队列中有等待唤醒的节点，锁还是有可能被其它线程获取。</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// business</span></span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// business</span></span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从等待中醒来"><a href="#从等待中醒来" class="headerlink" title="从等待中醒来"></a>从等待中醒来</h2><p>线程节点移动到同步队列后被唤醒，线程从等待中醒来，继续从 <code>LockSupport.park(this)</code> 向后执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">   <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 挂起线程，直到被唤醒或被中断</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 检测中断模式</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h3 id="检查中断模式"><a href="#检查中断模式" class="headerlink" title="检查中断模式"></a>检查中断模式</h3><p>线程从挂起返回后会检查中断状态，检查中断逻辑前文已经说明，这里不再重复介绍。</p>
<p>以下情况会使 <code>LockSupport.park(this)</code> 返回：</p>
<ol>
<li>线程节点被同步队列中其它节点唤醒，不仅仅是它的前驱节点，还可能是头节点（头节点线程进行 signal 时，线程节点的前驱节点取消了或更新前驱节点状态失败）。</li>
<li>线程在挂起时被中断。</li>
<li>假唤醒，和 Object.wait() 类似。</li>
</ol>
<h3 id="竞争同步状态"><a href="#竞争同步状态" class="headerlink" title="竞争同步状态"></a>竞争同步状态</h3><p>线程节点转入同步队列后，就可以尝试竞争同步状态了，注意预获取同步状态是之前释放锁前的值，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//醒来后，被移动到同步队列的节点 node 重新尝试获取同步状态成功，且获取同步状态的过程中如果被中断，接着判断中断模式非 THROW_IE 的情况会更新为 REINTERRUPT</span></span><br><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></table></figure>

<p>这里回到了竞争同步状态的逻辑，获取到同步状态则继续向后执行，也意味着可以从 <strong>await</strong> 方法返回，没能获取到同步状态则继续在同步队列中等待。</p>
<h3 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">     <span class="comment">// 中断线程，复位中断标志</span></span><br><span class="line">     selfInterrupt();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>await() 方法返回之前会对中断进行处理，因为它支持响应中断，关于中断模式前文已经说明，会对被中断的线程进行特殊处理，保证被中断的线程也要转到同步队列中。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/40e44c1f/" title="AQS 原理分析 - Condition实现原理" target="_blank" rel="external">https://gentryhuang.com/posts/40e44c1f/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/37f29896/" title="并发 - Java并发工具类"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/2362a8ea/" title="Redis原理 - 链表"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2020 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>