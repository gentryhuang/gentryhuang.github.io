<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>并发 - ReentrantReadWriteLock | gentryhuang的博客</title>
  <meta name="description" content="前言独占锁（排它锁）在同一时刻只允许一个线程进行访问，如 并发 - ReentrantLock 一文中介绍的 ReentrantLock 就是一个独占锁。而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其它写线程都会被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，不仅保证了写操作对读操作的可见性，还使得并发性相比一般的排它锁有更大提升。在读多写少的情">
<meta property="og:type" content="article">
<meta property="og:title" content="并发 - ReentrantReadWriteLock">
<meta property="og:url" content="https://gentryhuang.com/posts/f3292e6c/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="前言独占锁（排它锁）在同一时刻只允许一个线程进行访问，如 并发 - ReentrantLock 一文中介绍的 ReentrantLock 就是一个独占锁。而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其它写线程都会被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，不仅保证了写操作对读操作的可见性，还使得并发性相比一般的排它锁有更大提升。在读多写少的情">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gentryhuang.com/posts/f3292e6c/read-write-lock-state.png">
<meta property="og:image" content="https://gentryhuang.com/posts/f3292e6c/read-write-lock-uml.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/f3292e6c/read-write-lock-combination.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/f3292e6c/reentrant-read-write-lock-summary.jpg">
<meta property="article:published_time" content="2021-07-10T12:46:36.000Z">
<meta property="article:modified_time" content="2021-08-21T09:32:21.368Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="JUC">
<meta property="article:tag" content="AQS">
<meta property="article:tag" content="Lock">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gentryhuang.com/posts/f3292e6c/read-write-lock-state.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/f3292e6c/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.38px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.75px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.13px;">I/O</a> <a href="/tags/JUC/" style="font-size: 13.5px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.25px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.13px;">Lock</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.25px;">Protocol</a> <a href="/tags/RPC/" style="font-size: 13.63px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.13px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.25px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.25px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.88px;">设计模式</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/1d01ceec/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a>
              </p>
              <p class="item-title">
                <a href="/posts/1d01ceec/" class="title">时间轮算法 - HashedWheelTimer</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-24T02:06:24.000Z" itemprop="datePublished">2021-07-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/f3292e6c/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/f3292e6c/" class="title">并发 - ReentrantReadWriteLock</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-10T12:46:36.000Z" itemprop="datePublished">2021-07-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/19fe4bc5/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/19fe4bc5/" class="title">Redis原理 - Redis主流程</a>
              </p>
              <p class="item-date">
                <time datetime="2021-06-24T06:59:01.000Z" itemprop="datePublished">2021-06-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/b25f5b99/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a>
              </p>
              <p class="item-title">
                <a href="/posts/b25f5b99/" class="title">网络通信 - IO多路复用</a>
              </p>
              <p class="item-date">
                <time datetime="2021-06-12T02:43:23.000Z" itemprop="datePublished">2021-06-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/51fff883/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a>
              </p>
              <p class="item-title">
                <a href="/posts/51fff883/" class="title">网络通信 - IO模型</a>
              </p>
              <p class="item-date">
                <time datetime="2021-06-05T07:36:47.000Z" itemprop="datePublished">2021-06-05</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#场景"><span class="toc-number">2.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">3.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#读写状态"><span class="toc-number">4.</span> <span class="toc-text">读写状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码分析"><span class="toc-number">5.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#代码结构"><span class="toc-number">5.1.</span> <span class="toc-text">代码结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sync"><span class="toc-number">5.1.1.</span> <span class="toc-text">Sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非公平-Sync"><span class="toc-number">5.1.2.</span> <span class="toc-text">非公平 Sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公平-Sync"><span class="toc-number">5.1.3.</span> <span class="toc-text">公平 Sync</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读锁"><span class="toc-number">5.2.</span> <span class="toc-text">读锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">5.2.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取读锁"><span class="toc-number">5.2.2.</span> <span class="toc-text">获取读锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fullTryAcquireShared"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">fullTryAcquireShared</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#释放读锁"><span class="toc-number">5.2.3.</span> <span class="toc-text">释放读锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写锁"><span class="toc-number">5.3.</span> <span class="toc-text">写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性-1"><span class="toc-number">5.3.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取写锁"><span class="toc-number">5.3.2.</span> <span class="toc-text">获取写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#释放写锁"><span class="toc-number">5.3.3.</span> <span class="toc-text">释放写锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁降级"><span class="toc-number">5.4.</span> <span class="toc-text">锁降级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">6.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-concurrent/ReentrantReadWriteLock" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      并发 - ReentrantReadWriteLock
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/f3292e6c/" class="article-date">
	  <time datetime="2021-07-10T12:46:36.000Z" itemprop="datePublished">2021-07-10</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/JDK/">JDK</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/AQS/" rel="tag">AQS</a>, <a class="article-tag-link" href="/tags/JUC/" rel="tag">JUC</a>, <a class="article-tag-link" href="/tags/Lock/" rel="tag">Lock</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/f3292e6c/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 8.7k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 33(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>独占锁（排它锁）在同一时刻只允许一个线程进行访问，如 <a href="https://gentryhuang.com/posts/dd0ffc6a/">并发 - ReentrantLock</a> 一文中介绍的 <code>ReentrantLock</code> 就是一个独占锁。而读写锁在同一时刻可以允许多个<strong>读线程</strong>访问，但是在写线程访问时，所有的读线程和其它写线程都会被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，<strong>通过分离读锁和写锁，不仅保证了写操作对读操作的可见性，还使得并发性相比一般的排它锁有更大提升</strong>。在读多写少的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>读写锁除了保证写操作对读操作的可见性以及并发性的提升之外，<strong>读写锁还能够简化读写交互场景的编码实现</strong>。对于一个共享的缓存数据，一般都是读多写少，但是写操作完成之后的更新需要对后续的读操作可见，这样做的目的是使读操作能读取到正确的数据。使用读写锁实现这样的功能，只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取时，后续其它线程的读写操作都会被阻塞，写锁释放之后，所有操作才会继续执行。相比于使用<strong>等待-通知机制</strong>，更加简单化。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java 并发包提供读写锁的实现是 <strong>ReentrantReadWriteLock</strong> ，它支持以下特性：</p>
<ul>
<li><strong>公平性选择：</strong>支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平</li>
<li><strong>重入性：</strong>支持锁重入，包括读锁和写锁</li>
<li><strong>锁降级：</strong>同一个线程获取的写锁能够降级为读锁，反之不行。遵循获取写锁、获取读锁、释放写锁、释放读锁</li>
</ul>
<h1 id="读写状态"><a href="#读写状态" class="headerlink" title="读写状态"></a>读写状态</h1><p>读写锁 <code>ReentrantReadWriteLock</code> 同样是基于 AQS 实现的锁功能，而读写状态就是 AQS 的同步状态。在 <code>ReentrantLock</code> 中同步状态表示锁被一个线程持有的次数，而读写锁需要在同步状态上维护多个读线程和一个写线程的信息，这就使得<strong>同步状态的设计成为读写锁实现的关键</strong>。由于同步状态 <code>state</code> 是一个整型变量，4 个字节 32 位，因此读写锁将该变量切分成了两部分，高 16 位表示读，低 16 位表示写，划分方式如下图所示：</p>
<p><img src="/posts/f3292e6c/read-write-lock-state.png" alt></p>
<p>上图中的同步状态表示一个线程已经获取了写锁且重入了 2 次，同时也连续获取了两次读锁。<strong>读写锁是通过位运算来确定读和写各自的状态的</strong>。下面对状态的变化过程进行说明。</p>
<p><strong>假设当前同步状态 state 的值为 S</strong></p>
<ul>
<li>获取写状态<blockquote>
<p>S &amp; (1 &lt;&lt; 16 -1) -&gt; 将高16位全部抹去</p>
</blockquote>
</li>
<li>获取读状态<blockquote>
<p>S&gt;&gt;&gt;16 -&gt; 无符号补0，右移16位</p>
</blockquote>
</li>
<li>更新操作<blockquote>
<p>写状态增加 1 时 -&gt; S + 1<br>读状态增加 1 时 -&gt; S + (1&lt;&lt;16)，也就是 S + 0x00010000</p>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong>读写锁 <code>ReentrantReadWriteLock</code> 虽然使用同步状态 <code>state</code> 的高低位来表示读写状态，但是同步队列依然是共用一个。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><strong>ReentrantReadWriteLock 的类继承关系类图如下:</strong><br><img src="/posts/f3292e6c/read-write-lock-uml.jpg" alt></p>
<p>由继承关系图可知，读写锁 ReentrantReadWriteLock 是通过内部类 Sync 继承 AQS 来行使同步器的职能。由于该读写锁支持公平和非公平模式，因此通过继承内部类 Sync 的方式定义了非公平模式的 NonfairSync 和公平模式的 FairSync 。读写锁的实现依赖组合的 Sync ，也就是说 ReadLock 和 WriteLock 获取和释放锁的功能是交给 Sync 去实现的，公平模式下使用 FairSync ，非公平模式下使用 NonfairSync 。</p>
<p><strong>读写锁 ReentrantReadWriteLock 组合关系如下图所示：</strong><br><img src="/posts/f3292e6c/read-write-lock-combination.jpg" alt></p>
<p><strong>ReentrantReadWriteLock 分为读锁 ReadLock 和写锁 WriteLock 。读锁是共享锁，可被多个线程同时占有；写锁是独占锁，同时只能有一个线程占有，且写锁被线程占有后其它线程既不能获取读锁也不能获取写锁，但占有写锁的线程可以在不释放写锁的情况下继续获取读锁，这是锁降级的特点。</strong></p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6992448646407690164L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取写锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> writerLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取读锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readerLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync 继承自 AQS ,执行所有同步机制</span></span><br><span class="line"><span class="comment">     * 根据 ReentrantReadWriteLock 构造函数传入的布尔值决定要构造哪一种 Sync 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认创建非公平的 ReentrantReadWriteLock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的公平策略创建 ReentrantReadWriteLock</span></span><br><span class="line"><span class="comment">     * 说明：创建 ReentrantReadWriteLock 对象同时，会依次创建对应模式的 AQS 对象、读锁对象、写锁对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair 公平策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类 Sync ，继承 AQS</span></span><br><span class="line"><span class="comment">     * 1 具体子类包括：非公平模式 NonfairSync 和 公平模式 FairSync</span></span><br><span class="line"><span class="comment">     * 2 实现 AQS 中的独占和共享模式的两对方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平版本的 Sync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平版本的 Sync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span>  </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用外层的 ReentrantReadWriteLock 的 AQS 管理同步状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用外层的 ReentrantReadWriteLock 的 AQS 管理同步状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过前文分析的 <code>ReentrantReadWriteLock</code> UML 类图和相关的组合关系图，不难发现与上述代码结构是一一对应的。下面我们依次对读锁和写锁依赖的 AQS 相关实现进行介绍，理解了相关的实现后也就基本理解了读写锁的实现。</p>
<h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 静态内部类 Sync ，继承 AQS</span></span><br><span class="line"><span class="comment">    * 具体子类包括：非公平模式 NonfairSync 和 公平模式 FairSync</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将同步状态 state 分为两段：高 16 位用于共享模式；低 16 位用于独占模式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 读锁的值操作单位</span></span><br><span class="line">       <span class="comment">// 由于高 16 位用于读锁，因此每次操作基于 1 左移 16 位的值，也就是从高 16 位的末尾进行计算</span></span><br><span class="line">       <span class="comment">// 即，同步状态 state 加减 1 &lt;&lt; 16 =&gt; 1 00000000 00000000</span></span><br><span class="line">       <span class="comment">// 写锁是低 16 位，直接对同步状态 state 加减</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 锁持有次数溢出的阈值，即 2^16 -1</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 独占模式掩码，即 1 &lt;&lt; 16 -1 =&gt; 11111111 11111111</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取 c 的高 16 位的值，代表读锁的获取次数，包括重入</span></span><br><span class="line"><span class="comment">        * 注意：该值是所有线程获取次数总和，包括每个线程重入情况</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取 c 的低 16 位的值，代表写锁的重入次数（写锁是独占模式）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//----------------------- 🌟线程读锁计数器 --------------------/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 用于记录每个线程持有的读锁次数(包括读锁重入)</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 线程持有读锁次数</span></span><br><span class="line">           <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ThreadLocal 的子类，保存线程变量副本 HoldCounter</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 初始化 HoldCounter</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 当前线程读锁计数器</span></span><br><span class="line">       <span class="comment">// 说明：使用 ThreadLocal 来记录当前线程持有的读锁次数</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 最后获取读锁的线程读锁计数器</span></span><br><span class="line">       <span class="comment">// 说明：缓存最后一个获取读锁的线程持有读锁的次数，这里不是全局的概念，所以不管哪个线程获取到读锁后，就把这个值占为已用</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 首个获取读锁的线程(并且其未释放读锁)读锁计数器</span></span><br><span class="line">       <span class="comment">// 说明：</span></span><br><span class="line">       <span class="comment">// 1 这里不是全局的概念，该值被设置的条件是，当获取读锁时此时读锁没有线程持有。等这个 firstReader 代表的线程释放掉读锁以后，会有新的线程占用这个属性，也就是这个"第一个"是动态的。</span></span><br><span class="line">       <span class="comment">// 2 在读锁不产生竞争的情况下，记录读锁重入次数是非常方便的</span></span><br><span class="line">       <span class="comment">// 3 如果一个线程使用了 firstReader，那么它就不需要占用 cachedHoldCounter 变量了</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//-------------------- 线程读锁计数器🌟 --------------------/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 构造方法中初始化</span></span><br><span class="line">       Sync() &#123;</span><br><span class="line">           <span class="comment">// 初始化 readHolds 这个 ThreadLocal 属性</span></span><br><span class="line">           readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">           <span class="comment">// 为了保证 readHolds 的内存可见性</span></span><br><span class="line">           setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取读锁是否需要阻塞，交给子类实现</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取写锁是否需要阻塞，交给子类实现</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略获取和释放同步状态方法对，即获取和释放读锁/写锁方法。</span></span><br><span class="line">       <span class="comment">// 在分析读锁和写锁时结合分析，这里先不展示源码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承 AQS 的静态内部类 Sync 负责读锁 ReadLock 和写锁 WriteLock 的获取与释放工作，对读写锁 ReentrantReadWriteLock 的公平和非公平支持交给了两个子类实现。下面对 Sync 中的属性和抽象方法进行介绍，这些属作为最基础的数据支持读写锁的运行与统计。</p>
<p><strong>同步状态</strong></p>
<blockquote>
<ul>
<li>读写锁将 int 类型的同步状态 state 同时赋予两种语义，高 16 位表示读锁的持有次数，包括线程重入锁的情况。获取到读锁一次：<code>state + (1&lt;&lt;16)</code>，释放掉读锁一次：<code>state - (1&lt;&lt;16)</code>；</li>
<li>低 16 位表示写锁的获取次数，因为写锁是独占锁，同时只能被一个线程获取，因此它代表的重入次数。获取写锁一次：<code>state + 1</code>，释放写锁一次：<code>state -1</code> 。</li>
</ul>
</blockquote>
<p><strong>线程读锁计数器</strong></p>
<blockquote>
<ol>
<li>每个线程都需要记录获取的读锁次数，这样才能知道到底是不是读锁重入。注意，判断读锁重入和写锁重入完全不一样。写锁属于独占锁，同一时刻写锁只能一个线程持有，因此同步状态的低 16 位的值就是该线程持有写锁的次数（包括重入）；读锁属于共享锁，同一时刻允许多个线程持有，而同步状态的高 16 位的值是所有线程持有的总次数（包括各个线程重入），因此不能借助同步状态得出各个读线程持有读锁的次数，也就不能判断是否读锁重入，因此需要线程读锁计数器来辅助完成该诉求。</li>
<li>读写锁使用 ThreadLocal<HoldCounter> 维护每个线程读锁计数器，这样就能识别出哪个线程持有多少次读锁，进而可以判断线程是否是读锁重入以及线程持有读锁的次数。此外，读写锁基于性能考虑，又引入 <strong>“首个线程读锁计数器”</strong> 和 <strong>“最后线程读锁计数器”</strong>。其实 <code>ThreadLocal&lt;HoldCounter&gt; readHolds</code> 完全可以完成计数，只是 ThreadLocal 内部基于 Map 来查询的，相比直接使用变量记录线程读锁计数信息性能要差了那么一丢丢，不过这两个计数器只能记录一个线程持读锁信息，并且是动态变化的，提升性能的依据是尽可能先用这两个计数器，然后才使用通用的 <code>ThreadLocal&lt;HoldCounter&gt; readHolds</code> 记录线程读锁信息。</HoldCounter></li>
<li><strong>“首个线程读锁计数器”</strong> 是使用 <strong>firstReader</strong> 和 <strong>firstReaderHoldCount</strong> 两个属性组合而成的。<strong>“最后线程读锁计数器”</strong> 是使用 <code>HoldCounter</code> 类型的 <strong>cachedHoldCounter</strong> 属性表示。</li>
</ol>
</blockquote>
<p><strong>读写公平策略</strong></p>
<blockquote>
<p>读写锁 ReentrantReadWriteLock 具体分为读锁 ReadLock 和写锁 WriteLock ，在公平和非公平模式下读锁和写锁的表现不同，因此将具体的实现交给公平和非公平子类实现。</p>
</blockquote>
<h3 id="非公平-Sync"><a href="#非公平-Sync" class="headerlink" title="非公平 Sync"></a>非公平 Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+--- ReentrantReadWriteLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平版本的 Sync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取写锁是否需要阻塞</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果是非公平模式，那么 lock 的时候就可以直接用去抢锁，抢不到再排队</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取读锁是否需要阻塞</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 判断同步队列中 head 的第一个后继节点是否是来获取写锁的，如果是，就算是非公平模式，也先让该节点获取写锁，避免线程饥饿</span></span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">            <span class="comment">//     final boolean apparentlyFirstQueuedIsExclusive() &#123;</span></span><br><span class="line">            <span class="comment">//        Node h, s;</span></span><br><span class="line">            <span class="comment">//        return (h = head) != null &amp;&amp;</span></span><br><span class="line">            <span class="comment">//            (s = h.next)  != null &amp;&amp;</span></span><br><span class="line">            <span class="comment">//            !s.isShared()         &amp;&amp;</span></span><br><span class="line">            <span class="comment">//            s.thread != null;</span></span><br><span class="line">            <span class="comment">//    &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在非公平模式下，写锁优先尝试抢占锁，抢占失败才会去排队；一般来说，非公平模式下读锁也应该直接尝试抢占锁，但是<strong>写锁被定义了更高的优先级</strong>，读锁会先判断队列中等待的第一个线程节点是否是获取写锁的，如果是就算是非公平模式也先让该节点获取写锁，避免线程饥饿。</p>
<h3 id="公平-Sync"><a href="#公平-Sync" class="headerlink" title="公平 Sync"></a>公平 Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+--- ReentrantReadWriteLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平版本的 Sync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取写锁是否需要阻塞</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 那么如果阻塞队列有线程等待的话，就乖乖去排队</span></span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断读是否要阻塞</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 同步队列中有线程节点在等待</span></span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在公平模式下，无论是写锁还是读锁，都遵循先来后到原则。<strong>需要说明的是，对于读锁的获取，无论是公平还是非公平模式，它都没有抢占的概念，即使是在非公平模式下，还是需要判断同步队列中的第一个线程节点是否是写线程</strong>。</p>
<p>至此，读锁和写锁的前置准备已经完成，下面我们进入到读锁和写锁的源码。</p>
<h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h2><p>读锁内部持有 <code>ReentrantReadWriteLock</code> 中的 Sync 类型的对象，可能是 <code>FairSync</code> 对象，也可能是 <code>NonfairSync</code> 对象，具体由 <code>ReentrantReadWriteLock</code> 构造函数决定。ReadLock 锁获取与释放功能全部委托给 <strong>sync</strong> 对象完成。 </p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--- ReentrantReadWriteLock</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用 AQS 管理同步状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> lock</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取读锁"><a href="#获取读锁" class="headerlink" title="获取读锁"></a>获取读锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">+--- ReadLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 模版方法，获取共享同步状态</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+--- AQS</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试获取读锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+--- Sync</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 模版方法，获取共享同步状态 - 获取读锁</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1 读锁是一个支持重入的共享锁，它能被多个线程同时获取，在没有其它写线程访问时（注意非公平模式下同步队列中首个获取写锁的线程节点的情况），读锁总会被成功地获取，而所做的也只是增加读状态。</span></span><br><span class="line"><span class="comment">     * 2 如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其它线程获取，则进入等待状态。</span></span><br><span class="line"><span class="comment">     * 3 读锁的实现有两部分逻辑，一个是获取读锁，另一个是设置线程的读锁计数器。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取同步状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 exclusiveCount(c) != 0 ，说明有线程持有写锁。如果不是当前线程持有的写锁，那么当前线程获取读锁失败。</span></span><br><span class="line">        <span class="comment">// 由于读写锁的降级，如果当前线程持有写锁，是可以继续获取读锁的</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 读锁的获取次数</span></span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 获取读锁是否需要被阻塞（需要考虑公平与非公平的情况）</span></span><br><span class="line">        <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                <span class="comment">// 判断持有读锁次数是否会溢出 (2^16-1)</span></span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                <span class="comment">// 使用  CAS 是将 state 属性的高 16 位加 1，低 16 位不变，如果成功就代表获取到了读锁</span></span><br><span class="line">                <span class="comment">// c + 1 00000000 00000000</span></span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 进入当前代码区域，表示获取到了读锁。下面的逻辑是记录线程读锁计数器，用于标记当前线程持读锁次数，为判断是否读锁重入以及线程获取读锁次数做基础数据准备 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.1 r == 0 说明当前线程是第一个获取读锁的线程，或者是在它之前的读锁都已经释放了</span></span><br><span class="line">            <span class="comment">// 记录 firstReader 为当前线程，及其持有的读锁数量：1</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5.2 当前线程重入锁，加 1 即可</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5.3 当前线程不是第一个获取读锁，并且已经有其它线程获取了读锁</span></span><br><span class="line">                <span class="comment">// - 使用 readHolds 保存当前线程持有的读锁次数</span></span><br><span class="line">                <span class="comment">// - 将当前线程持有读锁信息更新为 cachedHoldCounter 的值，该变量用于记录最后一个获取读锁的线程持锁信息</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取最后一个获取读锁的线程信息。</span></span><br><span class="line">                Sync.HoldCounter rh = cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 cachedHoldCounter 缓存的不是当前线程，则将当前线程持有读锁信息缓存到 HoldCounter</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// cachedHoldCounter 缓存的是当前线程，但 count 为 0</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将当前线程持有读锁次数 count 加 1</span></span><br><span class="line">                rh.count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// return 大于 0 代表获取到了共享锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进入下面方法，可能是以下三种情况：</span></span><br><span class="line">        <span class="comment">// - compareAndSetState(c, c + SHARED_UNIT) 存在竞争，CAS 失败</span></span><br><span class="line">        <span class="comment">// - 公平模式 FairSync 下同步队列中有其它线程节点在等待锁</span></span><br><span class="line">        <span class="comment">// - 非公平模式 NonFairSync 下，同步队列中第一个线程节点（head.next）是获取写锁的，为了避免写锁饥饿，获取读锁的线程不应该和它竞争</span></span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>读锁获取使用 AQS 的共享模式获取同步状态，整个流程如下：</p>
<ol>
<li>判断写锁是否被其它线程占有（支持锁降级获取读锁），如果被其它线程占有直接获取读锁失败。</li>
<li>根据具体的公平或非公平模式判断获取读锁是否需要阻塞，阻塞的话会进入后续二次确认方法，即判断是否是重入获取读锁，重入获取读锁不需要阻塞。</li>
<li>获取读锁成功后，记录线程读锁计数器。</li>
</ol>
<p><strong>获取读锁的注意事项如下：</strong></p>
<ul>
<li>获取读锁前提条件是写锁没有被其它线程持有，当前线程持有写锁是可以继续获取读锁的，这是读写锁的锁降级特性。</li>
<li>在公平模式下，获取读锁时同步队列中有等待的线程节点，如果此时不是重入获取读锁，那么获取锁失败。</li>
<li>在非公平模式下，获取读锁时同步队列中第一个线程节点是获取写锁的情况，此时如果不是重入获取读锁，那么获取锁失败。写锁被定义更高的优先级。</li>
<li>获取锁成功后，需要记录当前线程读锁计数器。<strong>线程读锁计数器有两个作用，一个是用于判断线程是否是重入读锁，另一个是提供当前线程获取读锁的次数</strong>。</li>
</ul>
<h4 id="fullTryAcquireShared"><a href="#fullTryAcquireShared" class="headerlink" title="fullTryAcquireShared"></a>fullTryAcquireShared</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">+--- Sync</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这段代码与 tryAcquireShared 中的代码在一定程度上是冗余的，但由于没有使用重试和惰性读取保持计数之间的交互使 tryAcquireShared 复杂化，所以总体上更简单。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current 当前线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录线程获取读锁的次数</span></span><br><span class="line">        Sync.HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for 循环</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">// 1 获取同步状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 如果其它线程获取了写锁，那么当前线程是不能获取到读锁的，只能去同步队列中排队</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                <span class="comment">// would cause deadlock.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3 获取读锁应该阻塞，说明同步队列中有其它线程在等待。</span></span><br><span class="line">                <span class="comment">// 注意： 既然是获取读锁应该阻塞，那么进入有什么用呢？ 是用来处理读锁重入的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// firstReader 线程重入锁，暂不做操作，直接执行后面的 CAS</span></span><br><span class="line">                <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 非 firstReader 线程重入锁，则继续判断其它情况重入锁</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 判断是否是 cachedHoldCounter 重入锁，如果也不是，那就是既不是 firstReader 可重入也不是 lastReader 可重入，</span></span><br><span class="line">                        <span class="comment">// 这是只需从 ThreadLocal 取出当前线程持有读锁信息，如果没有占有，则进行兜底操作，让线程去排队</span></span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 那么到 ThreadLocal 中获取当前线程的 HoldCounter</span></span><br><span class="line">                            <span class="comment">// 注意，如果当前线程从来没有初始化过 ThreadLocal 中的值，get() 会执行初始化</span></span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 如果发现 count == 0，也就是说是上一行代码初始化的，之前该线程并没有持有读锁，那么执行 remove 操作清空信息，因为接下来该线程要入队等待了</span></span><br><span class="line">                            <span class="comment">// 然后往下两三行，乖乖排队去</span></span><br><span class="line">                            <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                readHolds.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 非重入，去同步队列中排队</span></span><br><span class="line">                    <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里 CAS 成功，那么就意味着成功获取读锁了</span></span><br><span class="line">            <span class="comment">// 下面需要做的是设置 firstReader 或 cachedHoldCounter，以及 readHolds，记录线程读锁信息</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注意这里 c 是上面的快照，上面修改的不是 c 而是 state</span></span><br><span class="line">                <span class="comment">// 如果发现 sharedCount(c) 等于 0，也就是当前没有线程持有读锁，就将当前线程设置为 firstReader</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果是重 firstReader 重入，直接累加持有读锁的次数即可</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将 cachedHoldCounter 设置为当前线程持有读锁信息，并且使用 ThreadLocal 记录当前线程持有读锁信息</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 累加当前线程持读锁次数</span></span><br><span class="line">                    rh.count++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 更新 cachedHoldCounter 为当前线程持有读锁信息</span></span><br><span class="line">                    cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回大于 0 的数，代表获取到了读锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述方法在一定程度上是对 <code>tryAcquireShared</code> 方法的冗余，主要是对并发获取读锁失败以及重入获取锁的处理。具体作用如下：</strong></p>
<blockquote>
<ol>
<li>tryAcquireShared 方法中 CAS 获取同步状态失败后增加获取读锁成功的机会，尽可能不进入同步队列。</li>
<li>处理 tryAcquireShared 中因获取读锁需要阻塞的情况（上述方法只会处理重入读锁的情况，因为重入读锁不需要阻塞，非重入就需要阻塞，也就是获取读锁再次失败）<ul>
<li>在非公平模式 NonFairSync 情况下，如果同步队列中 head.next 是获取写锁的节点，那么如果该线程不是重入读锁则获取失败，如果是重入读锁则获取成功，因为重入优先级更高。</li>
<li>在公平模式 FairSync 情况下，如果同步队列中有线程节点等待，那么如果不是重入读锁则获取失败，如果是重入读锁则获取成功，同样地，因为重入优先级更高。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="释放读锁"><a href="#释放读锁" class="headerlink" title="释放读锁"></a>释放读锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">+--- ReadLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">+--- AQS</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">+--- Sync</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS模版方法，释放共享同步状态 - 释放读锁</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 读锁的每次释放均减少读状态，减少的值是 1&lt;&lt;16</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 如果当前线程是 firstReader ，说明当前线程是第一个读线程</span></span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 firstReaderHoldCount 等于 1 ，那么本次解锁后就不再持有锁了，需要把 firstReader 置为 null</span></span><br><span class="line">            <span class="comment">// 没有设置 firstReaderHoldCount = 0 ，是因为没必要，其他线程使用的时候自己会重新设置该值</span></span><br><span class="line">            <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                firstReader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                firstReaderHoldCount--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 当前线程不是首个获取读锁的线程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断当前线程是不是最后获取读锁的线程，不是的话要到 ThreadLocal 中取</span></span><br><span class="line">            Sync.HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                rh = readHolds.get();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取计数</span></span><br><span class="line">            <span class="keyword">int</span> count = rh.count;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 将 ThreadLocal remove 掉，防止内存泄漏。因为已经不再持有读锁了</span></span><br><span class="line">                readHolds.remove();</span><br><span class="line">                <span class="comment">// 防止释放锁和获取锁次数不匹配</span></span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// count 减 1</span></span><br><span class="line">            --rh.count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 将同步状态 state 的高 16 位减 1，如果发现读锁和写锁都释放完了，那么唤醒后继的等待线程节点</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取同步状态 state</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// nextc 是 state 高 16 位减 1 后的值</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 nextc == 0，那就是 state 全部 32 位都为 0，也就是读锁和写锁都没有被占有</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="comment">// 释放读锁对读操作没有影响，但是如果现在读锁和写锁都是空闲的，那么释放读锁可能允许等待的写操作继续进行。</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>读锁释放过程比较简单，主要还是对应的两个操作，具体如下：</p>
<ul>
<li>更新当前释放读锁的线程对应的读锁计数器，如果是完全释放锁，则需要销毁对应的读锁计数器。</li>
<li>更新同步状态的高 16 位的值，表示释放读锁。如果是完全释放锁，则当前线程去唤醒同步队列中的线程节点。</li>
</ul>
<h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h2><p>写锁是一个支持重入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p>
<p>写锁内部持有 <code>ReentrantReadWriteLock</code> 中的 Sync 类型的对象，可能是 <code>FairSync</code> 对象，也可能是 <code>NonfairSync</code> 对象，具体由 <code>ReentrantReadWriteLock</code> 构造函数决定。ReadLock 锁获取与释放功能全部委托给 <strong>sync</strong> 对象完成。 </p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--- ReentrantReadWriteLock</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁</span></span><br><span class="line"><span class="comment">     * 1 写锁是独占锁</span></span><br><span class="line"><span class="comment">     * 2 如果有读锁被占用，写锁获取要进入同步队列中等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取写锁"><a href="#获取写锁" class="headerlink" title="获取写锁"></a>获取写锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">+--- WriteLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+--- AQS</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+--- Sync</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 模版方法，获取独占同步状态 - 获取写锁</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1 该方法除了重入条件（当前线程是获取了写锁的线程）之外，增加了一个读锁是否存在的判断。</span></span><br><span class="line"><span class="comment">     * 2 如果存在读锁，则写锁不能被获取，原因在于，读写锁要确保写锁的操作对读锁可见，如果允许读锁在已经被获取的情况下对写锁的获取，</span></span><br><span class="line"><span class="comment">     * 那么正在运行的其它读线程就无法感知到当前写线程的操作。因此，只有等待其它读线程都释放了读锁，写锁才能被当前线程获取。</span></span><br><span class="line"><span class="comment">     * 3 写锁一旦被获取，则其它读写线程的后续访问都被阻塞。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取同步状态 state</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 根据 state 获取写锁的持有次数</span></span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4  c != 0 表示要么有线程持有读锁，要么有线程持有写锁</span></span><br><span class="line">        <span class="comment">// 由于该方法是获取写锁，因此下面只能是写锁重入分支（存在持有读锁的情况直接失败）</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c != 0 &amp;&amp; w == 0: 写锁可用，但是有线程持有读锁(也可能是自己持有，但由于不支持锁升级，因此不能获取写锁)</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> ||</span><br><span class="line">                    <span class="comment">// c != 0 &amp;&amp; w !=0 &amp;&amp; current != getExclusiveOwnerThread(): 非重入，其他线程持有写锁</span></span><br><span class="line">                    current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断写锁持有次数是否超过阈值（65535）</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 能到这里的，只可能是写锁重入，更新同步状态即可</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里，此时 state == 0 ，读锁和写锁都没有被获取</span></span><br><span class="line">        <span class="comment">// 5 获取写锁，这里判断是否需要阻塞（这里考虑到公平还是非公平）</span></span><br><span class="line">        <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                <span class="comment">// 不需要阻塞，则更新 state</span></span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 当前线程独占锁</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>写锁获取使用 AQS 的独占模式获取同步状态的流程，整个流程如下：</p>
<ol>
<li>判断读锁是否被线程持有（包括当前线程自身），如果被持有则获取写锁直接失败。</li>
<li>判断是否是重入获取写锁，如果不是直接获取写锁失败。</li>
<li>根据具体的公平或非公平模式判断获取写锁是否需要阻塞，如果不需要阻塞则尝试获取写锁，成功后当前线程独占锁。</li>
</ol>
<h3 id="释放写锁"><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+--- WriteLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+-- AQS</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">+--- Sync</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 模版方法，释放独占同步状态 - 释放写锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> releases</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  当前线程是否占有锁，否则没有资格尝试释放写锁</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算同步状态剩余值</span></span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写锁重入次数是否为 0 ，为 0 表示可以释放</span></span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完全释放</span></span><br><span class="line">        <span class="keyword">if</span> (free)</span><br><span class="line">            <span class="comment">// 清空独占线程</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 state</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>写锁的释放与 <code>ReentrantLock</code> 的释放过程基本类似，每次释放均减少写状态，当写状态为 0 时表示写锁可以被释放。</p>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>ReentrantReadWriteLock 锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。<strong>锁降级是指持有写锁的线程在不释放写锁的同时，再获取到读锁，随后释放写锁，最后释放读锁</strong>。</p>
<p><strong>锁降级示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line"> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">volatile</span> Boolean updateFlag = Boolean.FALSE;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取缓存，一旦缓存被修改破坏，需要更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取读锁，该方法主要是读取缓存数据</span></span><br><span class="line">        readLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共享数据发生改变，需要重新计算缓存数据</span></span><br><span class="line">        <span class="keyword">if</span> (updateFlag) &#123;</span><br><span class="line">            <span class="comment">// 必须先释放掉读锁，后续加写锁更新缓存</span></span><br><span class="line">            readLock.unlock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 获取写锁，用于只有一个线程更新缓存</span></span><br><span class="line">            writeLock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (updateFlag) &#123;</span><br><span class="line">                    <span class="comment">// 更新缓存值</span></span><br><span class="line">                    cacheData = caculateCacheData();</span><br><span class="line">                    updateFlag = Boolean.FALSE;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 获取读锁</span></span><br><span class="line">                readLock.lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 3 释放写锁</span></span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以上 1、2、3 步完成锁降级，即写锁降级为读锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用缓存</span></span><br><span class="line">            System.out.println(<span class="string">"print cache: "</span> + cacheData);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中，缓存数据可用时，每个线程只需获取读锁然后访问，数据访问完成后释放读锁。但当共享的缓存数据被破坏，此时所有访问 processData 方法的线程都能感知到，但只有一个线程能够获取写锁然后更新缓存，其它线程都会被阻塞。当线程更新完缓存数据后，会接着获取读锁，随后才会释放写锁，完成锁的降级。</p>
<p>锁降级中的读锁获取是否有必要？答案是必要的，主要是为了保证数据的可见性。如果线程计算完缓存后没有获取读锁而是直接释放掉了写锁，那么此时如果存在另一个线程 t 获取了写锁并修改了缓存，那么当前线程就无法感知线程 t 的数据更新。如果当前线程在释放掉写锁前获取读取，也就是遵循锁降级的步骤，则线程 t 就无法获取写锁，直到当前线程访问数据并释放掉读锁后，线程 t 才能有机会获取写锁更新缓存数据。</p>
<p><strong>注意:</strong> ReentrantReadWriteLock 不支持锁升级，即持有读锁时再获取写锁，随后释放读锁。不支持的目的是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新数据，则其更新对其它获取到读锁的线程是不可见的。此外，是为了避免发生死锁，试想一个线程先获取读锁，然后再获取写锁，那么该线程会由于获取写锁失败进入同步队列中等待，可能之后就不会被唤醒了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>ReentrantReadWriteLock 读写锁正如其名，具体分为读锁和写锁。无论是读锁还是写锁，整个获取与释放锁的流程都是交给实现 AQS 的 Sync 类型的对象完成，准确来说是公平 Sync 或者非公平 Sync 对象。对于读锁和写锁的语义，是将同步状态 <code>state</code> 划分为高低位，高 16 位表示读锁状态，低 16 位表示写锁状态。写锁的获取和释放锁类似重入锁 <code>ReentrantLock</code> 过程，唯一不同的是写锁需要考虑读锁的占有情况。读锁的获取和释放比较复杂，复杂的主要原因是读锁允许多个线程同时获取且支持可重入，此时同步状态的高 16 位的值没办法表示各个线程持有读锁的情况，因此读写锁新增了<strong>线程读锁计数器</strong>的概念，有了这个概念就可以很轻松判断读线程重入锁的情况以及实时获取当前线程持有读锁的次数。</p>
<p><img src="/posts/f3292e6c/reentrant-read-write-lock-summary.jpg" alt></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/f3292e6c/" title="并发 - ReentrantReadWriteLock" target="_blank" rel="external">https://gentryhuang.com/posts/f3292e6c/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/1d01ceec/" title="时间轮算法 - HashedWheelTimer"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/19fe4bc5/" title="Redis原理 - Redis主流程"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2021 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>