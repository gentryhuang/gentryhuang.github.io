<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Dubbo源码分析 - 编解码器 | gentryhuang的博客</title>
  <meta name="description" content="前言在 远程通信模块总览 和 网络传输层 中分别介绍了编解码的顶级接口 Codec2 和 Codec ，并对抽象实现类 AbstractCodec 以及 Transport 层的 TransportCodec 进行了介绍。本篇文章将介绍 Exchange 层和 Protocol 层相关的编解码器实现。 概述编解码器主要实现对消息的编码和解码，解决粘包和拆包等问题，是在序列化之上封装的一层逻辑。编码">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo源码分析 - 编解码器">
<meta property="og:url" content="https://gentryhuang.com/posts/61d79ae/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="前言在 远程通信模块总览 和 网络传输层 中分别介绍了编解码的顶级接口 Codec2 和 Codec ，并对抽象实现类 AbstractCodec 以及 Transport 层的 TransportCodec 进行了介绍。本篇文章将介绍 Exchange 层和 Protocol 层相关的编解码器实现。 概述编解码器主要实现对消息的编码和解码，解决粘包和拆包等问题，是在序列化之上封装的一层逻辑。编码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gentryhuang.com/posts/61d79ae/dubbo-remoting-exchange-codec-hierarchy.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/61d79ae/dubbo-remoting-exchange-codec.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/61d79ae/dubbo-remoting-tcp-ip-protocol.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/61d79ae/dubbo-tcp-package.png">
<meta property="article:published_time" content="2020-06-28T16:00:00.000Z">
<meta property="article:modified_time" content="2020-12-23T06:02:35.192Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="Dubbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gentryhuang.com/posts/61d79ae/dubbo-remoting-exchange-codec-hierarchy.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/61d79ae/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            
            <p>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次</p>
            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">37</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a><span class="tag-list-count">33</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/" rel="tag">JDK</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUC/" rel="tag">JUC</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javassist/" rel="tag">Javassist</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mina/" rel="tag">Mina</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/" rel="tag">RPC</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">Redis数据结构</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPI/" rel="tag">SPI</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/" rel="tag">Zookeeper</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">32</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/JDK/" style="font-size: 13.5px;">JDK</a> <a href="/tags/JUC/" style="font-size: 13.33px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.33px;">Javassist</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/RPC/" style="font-size: 13.67px;">RPC</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.17px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.33px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.83px;">设计模式</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/9e3a7d05/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/9e3a7d05/" class="title">并发 - 线程池工具类</a>
              </p>
              <p class="item-date">
                <time datetime="2020-12-09T16:00:00.000Z" itemprop="datePublished">2020-12-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/d7cef21d/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/d7cef21d/" class="title">并发 - 线程池</a>
              </p>
              <p class="item-date">
                <time datetime="2020-12-02T16:00:00.000Z" itemprop="datePublished">2020-12-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/2362a8ea/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/2362a8ea/" class="title">Redis原理 - 链表</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-20T11:33:59.000Z" itemprop="datePublished">2020-10-20</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/aa1d8127/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/aa1d8127/" class="title">Redis原理 - 简单动态字符串</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-18T11:00:50.000Z" itemprop="datePublished">2020-10-18</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/37f29896/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/37f29896/" class="title">并发 - Java并发工具类</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-05T16:00:00.000Z" itemprop="datePublished">2020-10-06</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dubbo-协议"><span class="toc-number">3.</span> <span class="toc-text">Dubbo 协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#拆包粘包问题"><span class="toc-number">4.</span> <span class="toc-text">拆包粘包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#发生原因"><span class="toc-number">4.1.</span> <span class="toc-text">发生原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决方案"><span class="toc-number">4.2.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo-协议解决方案"><span class="toc-number">4.3.</span> <span class="toc-text">Dubbo 协议解决方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ExchangeCodec"><span class="toc-number">5.</span> <span class="toc-text">ExchangeCodec</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#属性"><span class="toc-number">5.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编码处理"><span class="toc-number">5.2.</span> <span class="toc-text">编码处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#请求消息编码"><span class="toc-number">5.2.1.</span> <span class="toc-text">请求消息编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事件序列化"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">事件序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#请求消息序列化"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">请求消息序列化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应编码"><span class="toc-number">5.2.2.</span> <span class="toc-text">响应编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#心跳响应序列化"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">心跳响应序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#响应数据序列化"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">响应数据序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解码处理"><span class="toc-number">5.3.</span> <span class="toc-text">解码处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#消息解码"><span class="toc-number">5.3.1.</span> <span class="toc-text">消息解码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DubboCodec"><span class="toc-number">6.</span> <span class="toc-text">DubboCodec</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#属性-1"><span class="toc-number">6.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编码消息体"><span class="toc-number">6.2.</span> <span class="toc-text">编码消息体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编码请求消息体"><span class="toc-number">6.2.1.</span> <span class="toc-text">编码请求消息体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编码响应消息体"><span class="toc-number">6.2.2.</span> <span class="toc-text">编码响应消息体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解码消息体"><span class="toc-number">6.3.</span> <span class="toc-text">解码消息体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解码请求体"><span class="toc-number">6.3.1.</span> <span class="toc-text">解码请求体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解码响应体"><span class="toc-number">6.3.2.</span> <span class="toc-text">解码响应体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DecodeableRpcInvocation"><span class="toc-number">7.</span> <span class="toc-text">DecodeableRpcInvocation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#属性-2"><span class="toc-number">7.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解码"><span class="toc-number">7.2.</span> <span class="toc-text">解码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DecodeableRpcResult"><span class="toc-number">8.</span> <span class="toc-text">DecodeableRpcResult</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#属性-3"><span class="toc-number">8.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解码-1"><span class="toc-number">8.2.</span> <span class="toc-text">解码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DubboCountCodec"><span class="toc-number">9.</span> <span class="toc-text">DubboCountCodec</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-rpc/编解码器" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Dubbo源码分析 - 编解码器
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/61d79ae/" class="article-date">
	  <time datetime="2020-06-28T16:00:00.000Z" itemprop="datePublished">2020-06-29</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/RPC/">RPC</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Dubbo/" rel="tag">Dubbo</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/61d79ae/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 8k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 35(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://gentryhuang.com/posts/95ab077/#%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8">远程通信模块总览</a> 和 <a href="https://gentryhuang.com/posts/53cd7ee7/#%E7%BC%96%E8%A7%A3%E7%A0%81">网络传输层</a> 中分别介绍了编解码的顶级接口 <strong>Codec2</strong> 和 <strong>Codec</strong> ，并对抽象实现类 <strong>AbstractCodec</strong> 以及 Transport 层的 <strong>TransportCodec</strong> 进行了介绍。本篇文章将介绍 Exchange 层和 Protocol 层相关的编解码器实现。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>编解码器主要实现对消息的编码和解码，解决粘包和拆包等问题，是在序列化之上封装的一层逻辑。编码器继承体系如下图所示：</p>
<p><img src="/posts/61d79ae/dubbo-remoting-exchange-codec-hierarchy.jpg" alt></p>
<p>在介绍编解码器之前，我们需要先对 Dubbo 协议进行说明，脱离了 Dubbo 协议编解码器是没有意义的。</p>
<h1 id="Dubbo-协议"><a href="#Dubbo-协议" class="headerlink" title="Dubbo 协议"></a>Dubbo 协议</h1><p><img src="/posts/61d79ae/dubbo-remoting-exchange-codec.jpg" alt></p>
<p>Dubbo 协议设计参考了现有的 TCP/IP 协议，一次 RPC 调用包括协议头和协议体两部分。下面对 Dubbo 协议内容进行详细说明：</p>
<table>
<thead>
<tr>
<th>偏移比特位</th>
<th>表述</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0 ～ 7 位和 8 ～ 15 位</td>
<td>Magic High 和 Magic Low</td>
<td>分别是魔数高位和魔数低位，都是固定值，<strong>可以通过这 2 个 Byte 判断一个数据包是否为 Dubbo 协议</strong></td>
</tr>
<tr>
<td>16 位</td>
<td>Req/Res</td>
<td>数据包类型，标识当前消息是请求还是响应。<strong>0 - Response，1 - Request</strong></td>
</tr>
<tr>
<td>17 位</td>
<td>2Way</td>
<td>标识当前消息是单向还是双向，仅在第 16 位被设为 1（请求）时有效，<strong>0 - 单向，1 - 双向</strong></td>
</tr>
<tr>
<td>18 位</td>
<td>Event</td>
<td>标识当前消息是否为事件消息。0 - 请求或响应包，1 - 事件消息</td>
</tr>
<tr>
<td>19 ～ 23 位</td>
<td>Serialization ID</td>
<td>序列化器编号，标识当前消息使用哪一种序列化算法。如 2 - Hessian2Serialization  …</td>
</tr>
<tr>
<td>24 ～ 31 位</td>
<td>Status</td>
<td>记录响应的状态，仅在第 16 位被设为 0（响应）时有效。如 20 - OK  …</td>
</tr>
<tr>
<td>32 ～ 95 位</td>
<td>RPC Request ID</td>
<td>请求编号，用于记录请求的唯一标识，用来将请求和响应做关联，类型为 long</td>
</tr>
<tr>
<td>96 ～ 127 位</td>
<td>Data Length</td>
<td>序列化后的消息体长度，该值按字节计数，类型位 int</td>
</tr>
<tr>
<td>128 ～</td>
<td>Body Content</td>
<td>消息体内容，即请求包或响应包通过特定序列化算法序列化后的结果</td>
</tr>
</tbody></table>
<p>Dubbo 协议中前 128 位是协议头，之后的内容是消息体，而协议头就是通过 ExchangeCodec 实现编解码的。在消息体中，客户端侧严格按照序列化顺序写入消息，服务端侧会遵循相同的顺序读取消息。</p>
<p><strong>TCP/IP 协议内容如下图所示：</strong></p>
<p><img src="/posts/61d79ae/dubbo-remoting-tcp-ip-protocol.jpg" alt></p>
<h1 id="拆包粘包问题"><a href="#拆包粘包问题" class="headerlink" title="拆包粘包问题"></a>拆包粘包问题</h1><p>TCP 通讯协议是面向流的，包和包之间没有界限。TCP 为了提高性能，发送端会根据缓冲区实际情况进行划分，一个完整的包可能会拆分成多个包进行发送，也可能把多个小包封装成一个大的数据包发送。同理，接收端也会维护缓冲区。这就是 TCP 拆包和粘包。</p>
<p><img src="/posts/61d79ae/dubbo-tcp-package.png" alt></p>
<p><a href="https://www.jianshu.com/p/c1e8fd150042" target="_blank" rel="noopener">图片来源</a></p>
<h2 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h2><ul>
<li>应用程序写入的数据大于缓冲区大小，会发生拆包。</li>
<li>应用程序写入的数据于缓冲区大小，会发生粘包。</li>
<li>接收端不及时读取缓冲区数据，会发生粘包。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>由于 TCP 通讯协议是面向流的，无法分区包的界限，解决拆包粘包问题本质上就是解决包界限的问题。</p>
<ul>
<li><p>固定长度</p>
<blockquote>
<p>设置定长消息，消息长度不够补充相关默认值，如空格等，接收方每次读取既定长度的内容作为一条完整消息。该方式的缺点是浪费了部分存储空间和带宽。</p>
</blockquote>
</li>
<li><p>特殊分隔符</p>
<blockquote>
<p>设置数据包的边界，如添加特定符号（回车、换行符号），接收方通过这个边界就可以将不同的数据包拆分开。</p>
</blockquote>
</li>
<li><p>消息头 + 固定长度</p>
<blockquote>
<p>把消息数据分成消息头和消息体，消息头带消息体的长度，接收方根据消息头中的长度解析数据。</p>
</blockquote>
</li>
</ul>
<h2 id="Dubbo-协议解决方案"><a href="#Dubbo-协议解决方案" class="headerlink" title="Dubbo 协议解决方案"></a>Dubbo 协议解决方案</h2><p>Dubbo 协议使用<strong>消息头 + 固定长度</strong>的方式处理粘包和拆包问题。消息头存储消息开始标识及消息长度，接收端获取消息头的时候解析出消息长度，然后根据该长度向后读取消息内容。也就是使用编解码处理消息头，使用序列化和反序列化处理消息体。</p>
<h1 id="ExchangeCodec"><a href="#ExchangeCodec" class="headerlink" title="ExchangeCodec"></a>ExchangeCodec</h1><p>ExchangeCodec 基继承了 TelnetCodec 类，是信息交换编解码器，关于 TelnetCodec 在本篇文章中暂不展开介绍。该编解码器只处理 Dubbo 协议头，DubboCodec 通过继承的方式在 ExchangeCodec 基础上添加了解析 Dubbo 消息体的功能。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+--- ExchangeCodec</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议头的字节数: 16Bytes = 128 Bits</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEADER_LENGTH = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议头前16位，分为 MAGIC_HIGH 和 MAGIC_LOW 2个字节。是个固定值，标志着一个数据包是否是 Dubbo 协议</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 11011010 10111011</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> MAGIC = (<span class="keyword">short</span>) <span class="number">0xdabb</span>; <span class="comment">// -9541</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 魔数高位</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 11011010</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> MAGIC_HIGH = Bytes.short2bytes(MAGIC)[<span class="number">0</span>]; <span class="comment">// -38</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 魔数低位</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 10111011</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> MAGIC_LOW = Bytes.short2bytes(MAGIC)[<span class="number">1</span>]; <span class="comment">// -69</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标识是请求还是响应 1 为request请求  0 为响应</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 10000000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> FLAG_REQUEST = (<span class="keyword">byte</span>) <span class="number">0x80</span>; <span class="comment">// -128</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标识是双向传输还是单向传输 1 为双向传输 0 为是单向传输</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 01000000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> FLAG_TWOWAY = (<span class="keyword">byte</span>) <span class="number">0x40</span>; <span class="comment">// 64</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标示是否为事件： 0 - 当前数据包是请求或响应包，1 - 当前数据包是心跳包</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 00100000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> FLAG_EVENT = (<span class="keyword">byte</span>) <span class="number">0x20</span>; <span class="comment">// 32</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于获取序列化类型 ID的掩码。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 00011111</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERIALIZATION_MASK = <span class="number">0x1f</span>; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>

<p>Dubbo 协议头中每一位的值要么直接是上述属性的值，要么是上述属性位运算后的值。</p>
<h2 id="编码处理"><a href="#编码处理" class="headerlink" title="编码处理"></a>编码处理</h2><p>Dubbo 中的编码器主要用于将 Java 对象编码成字节流返回给对端，该过程涉及两部分事情，一个是构造协议头，另一个是对消息体进行序列化处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- ExchangeCodec</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码 - 请求头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel Dubbo 底层 Channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer  Dubbo 底层 Buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg     出站消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 对请求对象进行编码</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">            encodeRequest(channel, buffer, (Request) msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对响应对象进行编码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">            encodeResponse(channel, buffer, (Response) msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交给父类(Telnet)处理， 编码Telnet命令的结果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.encode(channel, buffer, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ExchangeCodec 的 encode() 方法中会根据需要编码的消息类型进行分类，下面我们依次来看对请求对象和响应对象的编码，关于编码 Telnet 命令暂不说明。</p>
<h3 id="请求消息编码"><a href="#请求消息编码" class="headerlink" title="请求消息编码"></a>请求消息编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">+--- ExchangeCodec</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequest</span><span class="params">(Channel channel, ChannelBuffer buffer, Request req)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取序列化方式，如果没有配置，默认是 hessian2</span></span><br><span class="line">        Serialization serialization = getSerialization(channel);</span><br><span class="line">        <span class="comment">// 创建协议头字节数组，长度为16</span></span><br><span class="line">        <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[HEADER_LENGTH];</span><br><span class="line">        <span class="comment">// 设置魔数，占用2个字节: [0-7] -&gt; 魔数高位 -38，【8-15】 -&gt; 魔数低位 -69</span></span><br><span class="line">        Bytes.short2bytes(MAGIC, header);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置数据包类型（Request/Response，0 - Response  1- Request）[16]   和序列化器编号 [19,23]</span></span><br><span class="line">        header[<span class="number">2</span>] = (<span class="keyword">byte</span>) (FLAG_REQUEST | serialization.getContentTypeId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置通信方式 (twoWay)，即是双向传输还是单向，0 - 单向调用，1 - 双向调用 [17]</span></span><br><span class="line">        <span class="keyword">if</span> (req.isTwoWay()) &#123;</span><br><span class="line">            header[<span class="number">2</span>] |= FLAG_TWOWAY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否为事件（event）[18]</span></span><br><span class="line">        <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">            header[<span class="number">2</span>] |= FLAG_EVENT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置请求编号，8个字节，从第5个字节开始设置 [32 - 95] 请求 id 编号，Long 型。</span></span><br><span class="line">        <span class="comment">// 注意，字节数组的第4个字节[27- 31]没有设置值，因为status 状态，Request没有，Response才有</span></span><br><span class="line">        Bytes.long2bytes(req.getId(), header, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 buffer 当前的写位置</span></span><br><span class="line">        <span class="keyword">int</span> savedWriteIndex = buffer.writerIndex();</span><br><span class="line">        <span class="comment">// 更新 writerIndex，为协议头预留 16 个字节的空间</span></span><br><span class="line">        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取序列化器，如 Hessian2ObjectOutput</span></span><br><span class="line">        ChannelBufferOutputStream bos = <span class="keyword">new</span> ChannelBufferOutputStream(buffer);</span><br><span class="line">        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对事件进行序列化</span></span><br><span class="line">        <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">            encodeEventData(channel, out, req.getData());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对普通请求的数据进行序列化，即将req.data（一般是RpcInvocation） 写入到输出流out中，ChannelBufferOutputStream进行接收，然后存储到ChannelBuffer。</span></span><br><span class="line">            encodeRequestData(channel, out, req.getData(), req.getVersion());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.flushBuffer();</span><br><span class="line">        <span class="keyword">if</span> (out <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) out).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        bos.flush();</span><br><span class="line">        bos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照字节计数请求的数据序列化后大小，是否超过消息上限。默认最大为 8M，可以通过 payload 参数配置。</span></span><br><span class="line">        <span class="keyword">int</span> len = bos.writtenBytes();</span><br><span class="line">        <span class="comment">// 可能会抛出异常，即使抛出异常也无需复位 buffer，每一个请求挂载的 ChannelBuffer 都是新建的。</span></span><br><span class="line">        checkPayload(channel, len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 消息体长度写入到消息头中 [96 - 127]。这也是为什么 ChannelBuffer 要先写入消息体的原因。</span></span><br><span class="line">        Bytes.int2bytes(len, header, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备</span></span><br><span class="line">        buffer.writerIndex(savedWriteIndex);</span><br><span class="line">        <span class="comment">// 从 savedWriteIndex 下标处写入消息头</span></span><br><span class="line">        buffer.writeBytes(header);</span><br><span class="line">        <span class="comment">// 调整 ChannelBuffer 写入位置，即writerIndex = 原写下标 + 消息头长度 + 消息体长度</span></span><br><span class="line">        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>理解了 Dubbo 的协议后上面的代码就非常简单了。该方法主要逻辑是编码协议头，并且对事件和普通请求消息分别做处理，encodeEventData() 方法没有什么逻辑处理，直接将事件写入到输出流 out 中，encodeRequestData() 方法是对普通请求数据的处理，其实就是对 <strong>RpcInvocation</strong> 调用进行编码，DubboCode 对 encodeRequestData() 方法进行了重写，主要为了实现对 <strong>RpcInvocation</strong> 和 <strong>RpcResult</strong> 作为消息体的编码处理，在 DubboCode 中会详细说明该方法。</p>
<h4 id="事件序列化"><a href="#事件序列化" class="headerlink" title="事件序列化"></a>事件序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--- ExchangeCodec</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">encodeEventData</span><span class="params">(Channel channel, ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        encodeEventData(out, data);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">encodeEventData</span><span class="params">(ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeObject(data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="请求消息序列化"><a href="#请求消息序列化" class="headerlink" title="请求消息序列化"></a>请求消息序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--- ExchangeCodec</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequestData</span><span class="params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        encodeRequestData(out, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequestData</span><span class="params">(ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeObject(data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="响应编码"><a href="#响应编码" class="headerlink" title="响应编码"></a>响应编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">+--- ExchangeCodec</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeResponse</span><span class="params">(Channel channel, ChannelBuffer buffer, Response res)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取写的位置</span></span><br><span class="line">        <span class="keyword">int</span> savedWriteIndex = buffer.writerIndex();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取序列化器</span></span><br><span class="line">            Serialization serialization = getSerialization(channel);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建消息头字节数组，长度为16</span></span><br><span class="line">            <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[HEADER_LENGTH];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置魔数，占2个字节 [0-15]</span></span><br><span class="line">            Bytes.short2bytes(MAGIC, header);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置序列化器编号,占header第3个字节的后5位 [19 -23]</span></span><br><span class="line">            header[<span class="number">2</span>] = serialization.getContentTypeId();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果心跳数据包，就设置header第3个字节的第3位 [18]</span></span><br><span class="line">            <span class="keyword">if</span> (res.isHeartbeat()) &#123;</span><br><span class="line">                header[<span class="number">2</span>] |= FLAG_EVENT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置响应状态，占1个字节 ，[24-31]</span></span><br><span class="line">            <span class="keyword">byte</span> status = res.getStatus();</span><br><span class="line">            header[<span class="number">3</span>] = status;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置请求编号，注意Response中的id就是Request的编号，占8个字节 [32-95]</span></span><br><span class="line">            Bytes.long2bytes(res.getId(), header, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 writerIndex，为消息头预留 16 个字节的空间</span></span><br><span class="line">            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);</span><br><span class="line">            ChannelBufferOutputStream bos = <span class="keyword">new</span> ChannelBufferOutputStream(buffer);</span><br><span class="line">            ObjectOutput out = serialization.serialize(channel.getUrl(), bos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 编码响应数据或错误信息</span></span><br><span class="line">            <span class="keyword">if</span> (status == Response.OK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res.isHeartbeat()) &#123;</span><br><span class="line">                    <span class="comment">// 对心跳响应结果进行序列化</span></span><br><span class="line">                    encodeHeartbeatData(channel, out, res.getResult());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 对响应消息进行序列化，res.getResult() 一般是 Result 对象</span></span><br><span class="line">                    encodeResponseData(channel, out, res.getResult(), res.getVersion());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 对错误信息进行序列化</span></span><br><span class="line">                out.writeUTF(res.getErrorMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            out.flushBuffer();</span><br><span class="line">            <span class="keyword">if</span> (out <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">                ((Cleanable) out).cleanup();</span><br><span class="line">            &#125;</span><br><span class="line">            bos.flush();</span><br><span class="line">            bos.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取消息体长度</span></span><br><span class="line">            <span class="keyword">int</span> len = bos.writtenBytes();</span><br><span class="line">            <span class="comment">// 校验消息长度有没有超出当前设置的上限</span></span><br><span class="line">            checkPayload(channel, len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将消息体长度写入到消息头中，占4个字节  [96-127]</span></span><br><span class="line">            Bytes.int2bytes(len, header, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备</span></span><br><span class="line">            buffer.writerIndex(savedWriteIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 savedWriteIndex 下标处写入消息头</span></span><br><span class="line">            buffer.writeBytes(header);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度</span></span><br><span class="line">            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// clear buffer 复位 buffer</span></span><br><span class="line">            buffer.writerIndex(savedWriteIndex);</span><br><span class="line">            <span class="comment">// send error message to Consumer, otherwise, Consumer will wait till timeout. // 注意和编码请求的不同</span></span><br><span class="line">            <span class="keyword">if</span> (!res.isEvent() &amp;&amp; res.getStatus() != Response.BAD_RESPONSE) &#123;</span><br><span class="line">                Response r = <span class="keyword">new</span> Response(res.getId(), res.getVersion());</span><br><span class="line">                r.setStatus(Response.BAD_RESPONSE);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 消息内容过大</span></span><br><span class="line">                <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ExceedPayloadLimitException) &#123;</span><br><span class="line">                    logger.warn(t.getMessage(), t);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        r.setErrorMessage(t.getMessage());</span><br><span class="line">                        channel.send(r);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"Failed to send bad_response info back: "</span> + t.getMessage() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// FIXME log error message in Codec and handle in caught() of IoHanndler?</span></span><br><span class="line">                    logger.warn(<span class="string">"Fail to encode response: "</span> + res + <span class="string">", send bad_response info instead, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        r.setErrorMessage(<span class="string">"Failed to send response: "</span> + res + <span class="string">", cause: "</span> + StringUtils.toString(t));</span><br><span class="line">                        channel.send(r);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"Failed to send bad_response info back: "</span> + res + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rethrow exception</span></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>encodeResponse() 方法编码响应的方式与 encodeRequest() 方法编码请求的方式类似，区别点如下:</strong></p>
<ol>
<li>编码响应会在协议头中 <strong>status</strong> 保存响应的状态码，编码请求是不具备的。</li>
<li>编码响应不会对 <strong>2Way</strong> 进行处理，只有是请求包时才会设置。</li>
<li>编码响应会对异常进行处理专门处理<ul>
<li>复位 ChannelBuffer，防止缓冲区中数据错乱。</li>
<li>将异常响应返回给对端，防止对端只有等待超时才能返回，尽量避免无效等待。</li>
<li>对异常进行细分，且将异常信息转成字符串防止对端无法正常反序列化异常对象。</li>
</ul>
</li>
</ol>
<p>此外，编码响应和编码请求类似，对心跳响应的处理也是直接写入到 <strong>out</strong> 流中，而对响应的编码 <strong>encodeResponseData()</strong> 方法也被 DubboCodec 进行了重写。</p>
<h4 id="心跳响应序列化"><a href="#心跳响应序列化" class="headerlink" title="心跳响应序列化"></a>心跳响应序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- ExchangeCodec</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeHeartbeatData</span><span class="params">(Channel channel, ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        encodeHeartbeatData(out, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeHeartbeatData</span><span class="params">(ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        encodeEventData(out, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">encodeEventData</span><span class="params">(ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeObject(data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应数据序列化"><a href="#响应数据序列化" class="headerlink" title="响应数据序列化"></a>响应数据序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--- ExchangeCodec</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeResponseData</span><span class="params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        encodeResponseData(out, data);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeResponseData</span><span class="params">(ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeObject(data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解码处理"><a href="#解码处理" class="headerlink" title="解码处理"></a>解码处理</h2><p>Dubbo 的解码器涉及两部分工作，一个是解码协议头，另一个是解码协议体。它是编码的逆过程，会先检查魔数，然后读取协议头和消息的长度，最后根据协议头中的各个标志位进行逻辑处理，以及反序列化消息数据。</p>
<h3 id="消息解码"><a href="#消息解码" class="headerlink" title="消息解码"></a>消息解码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- ExchangeCodec</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 从Buffer 中读取字节数</span></span><br><span class="line">        <span class="keyword">int</span> readable = buffer.readableBytes();</span><br><span class="line">        <span class="comment">// 创建协议头字节数组，优先解析 Dubbo 协议，而不是 Telnet 命令</span></span><br><span class="line">        <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[Math.min(readable, HEADER_LENGTH)];</span><br><span class="line">        <span class="comment">// 从管道中取出header.length个字节</span></span><br><span class="line">        buffer.readBytes(header);</span><br><span class="line">        <span class="comment">// 解码</span></span><br><span class="line">        <span class="keyword">return</span> decode(channel, buffer, readable, header);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意 <strong>buffer.readBytes()</strong> 方法用于从 Channel 中读取出 <strong>header.length</strong> 个字节，可能目前 Channel 中数据不足 16 个字节，也可能大于 16 个字节。下面我们看具体的解码逻辑方法 decode() 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">+--- ExchangeCodec</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer, <span class="keyword">int</span> readable, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过魔数判断是否Dubbo 消息,不是的情况下目前是Telnet 命令行发出的数据包</span></span><br><span class="line">        <span class="keyword">if</span> (readable &gt; <span class="number">0</span> &amp;&amp; header[<span class="number">0</span>] != MAGIC_HIGH || readable &gt; <span class="number">1</span> &amp;&amp; header[<span class="number">1</span>] != MAGIC_LOW) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = header.length;</span><br><span class="line">            <span class="comment">// 如果 header.length &lt; readable 成立，说明 buffer 中数据没有读完，因此需要将数据全部读取出来。因为这不是 Dubbo 协议。</span></span><br><span class="line">            <span class="keyword">if</span> (header.length &lt; readable) &#123;</span><br><span class="line">                header = Bytes.copyOf(header, readable);</span><br><span class="line">                buffer.readBytes(header, length, readable - length);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; header.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class="number">1</span>] == MAGIC_LOW) &#123;</span><br><span class="line">                    buffer.readerIndex(buffer.readerIndex() - header.length + i);</span><br><span class="line">                    header = Bytes.copyOf(header, i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过telnet命令行发送的数据包不包含消息头，所以这里调用TelnetCodec的decode方法对数据包进行解码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.decode(channel, buffer, readable, header);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查可读数据字节数是否少于固定长度 ，若小于则返回需要更多的输入。因为Dubbo协议采用 协议头 + payload  的方式</span></span><br><span class="line">        <span class="keyword">if</span> (readable &lt; HEADER_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从消息头中获取消息体的长度 - [96 - 127]，通过该长度读取消息体。</span></span><br><span class="line">        <span class="keyword">int</span> len = Bytes.bytes2int(header, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测消息体长度是否超出限制，超出则抛出异常</span></span><br><span class="line">        checkPayload(channel, len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测可读的字节数是否小于实际的字节数【消息头 + 消息体 的字节长度和】，如果是则返回需要更多的输入</span></span><br><span class="line">        <span class="keyword">int</span> tt = len + HEADER_LENGTH;</span><br><span class="line">        <span class="keyword">if</span> (readable &lt; tt) &#123;</span><br><span class="line">            <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// limit input stream. 根据消息体长度创建输入流对象</span></span><br><span class="line">        ChannelBufferInputStream is = <span class="keyword">new</span> ChannelBufferInputStream(buffer, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 解析 Header + Body,根据情况，根据具体数据包类型返回 Request 或 Reponse</span></span><br><span class="line">            <span class="keyword">return</span> decodeBody(channel, is, header);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过未读完的流，并打印错误日志</span></span><br><span class="line">            <span class="keyword">if</span> (is.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"Skip input stream "</span> + is.available());</span><br><span class="line">                    &#125;</span><br><span class="line">                    StreamUtils.skipUnusedStream(is);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    logger.warn(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ExchangeCodec 的 decodeBody() 方法被 DubboCodec 重写了，以支持消息体的编解码功能，就不再对 ExchangeCodec 的该方法进行说明。</p>
<p>ExchangeCodec 中的消息解码和消息编码着重点相同，都是对协议头的编码和解码，对消息体的处理都是交给了子类 DubboCodec 来完成的。接下来就对 DubboCodec 的编码码实现进行分析。</p>
<h1 id="DubboCodec"><a href="#DubboCodec" class="headerlink" title="DubboCodec"></a>DubboCodec</h1><p>DubboCodec 是 Protocol 层的编解码器，继承了 Exchange 层的 ExchangeCodec 编解码实现类。ExchangeCodec 基于协议头对 Request 和 Response 的通用解析，Dubbo 协议中 <strong>RpcInvocation</strong> 和 <strong>RpcResult</strong> 作为消息体的处理交给了 DubboCodec 来完成，并且 DubboCodec 还支持参数回调等处理。</p>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboCodec</span> <span class="keyword">extends</span> <span class="title">ExchangeCodec</span> <span class="keyword">implements</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DubboCodec<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"dubbo"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_VERSION = Version.getProtocolVersion();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> RESPONSE_WITH_EXCEPTION = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常响应，有结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> RESPONSE_VALUE = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常响应，无结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> RESPONSE_NULL_VALUE = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常返回包含隐藏参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应结果包含隐藏参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> RESPONSE_VALUE_WITH_ATTACHMENTS = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应空值包含隐藏参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> RESPONSE_NULL_VALUE_WITH_ATTACHMENTS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_OBJECT_ARRAY = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DubboCodec 中的属性主要是对 Dubbo 响应标记的定义，外加默认方法参数及类型。</p>
<h2 id="编码消息体"><a href="#编码消息体" class="headerlink" title="编码消息体"></a>编码消息体</h2><p>DubboCodec 中的编码消息体的方法都是对 ExchangeCodec 方法的重写。</p>
<h3 id="编码请求消息体"><a href="#编码请求消息体" class="headerlink" title="编码请求消息体"></a>编码请求消息体</h3><p>对 ExchangeCodec 的 encodeRequestData() 方法的重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboCodec</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequestData</span><span class="params">(Channel channel, ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        encodeRequestData(channel, out, data, DUBBO_VERSION);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboCoec</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequestData</span><span class="params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 将请求消息转成 RpcInvocation 对象</span></span><br><span class="line">        RpcInvocation inv = (RpcInvocation) data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入 `dubbo` `path` `version`</span></span><br><span class="line">        out.writeUTF(version); <span class="comment">// 写入框架版本</span></span><br><span class="line">        out.writeUTF(inv.getAttachment(Constants.PATH_KEY)); <span class="comment">// 写入调用接口</span></span><br><span class="line">        out.writeUTF(inv.getAttachment(Constants.VERSION_KEY)); <span class="comment">// 写入接口指定的版本，默认为 0.0.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入方法名、参数类型、参数值</span></span><br><span class="line">        out.writeUTF(inv.getMethodName());</span><br><span class="line">        out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法参数，依次写入方法参数值</span></span><br><span class="line">        Object[] args = inv.getArguments();</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 调用 CallbackServiceCodec#encodeInvocationArgument(...) 方法编码参数，主要用于参数回调功能</span></span><br><span class="line">                out.writeObject(encodeInvocationArgument(channel, inv, i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入隐式参数 Map</span></span><br><span class="line">        out.writeObject(inv.getAttachments());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据 Dubbo 协议的格式编码请求体 RpcInvocation，按照顺序依次将所需字段编码成字节流，对应的解码在 <strong>DecodeableRpcInvocation</strong> 对象中。需要注意 <strong>out</strong> 参数，该对象由配置的序列化决定，如配置 <strong>&lt;dubbo:protocol serialization=”fastjson”/&gt;，out 就是 FastJsonObjectOutput</strong>。</p>
<h3 id="编码响应消息体"><a href="#编码响应消息体" class="headerlink" title="编码响应消息体"></a>编码响应消息体</h3><p>对 ExchangeCodec 的 encodeResponseData() 方法的重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboCodec</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeResponseData</span><span class="params">(Channel channel, ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        encodeResponseData(channel, out, data, DUBBO_VERSION);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboCodec</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeResponseData</span><span class="params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将响应转为 Result 对象</span></span><br><span class="line">        Result result = (Result) data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测当前协议版本是否支持隐式参数</span></span><br><span class="line">        <span class="keyword">boolean</span> attach = Version.isSupportResponseAttatchment(version);</span><br><span class="line"></span><br><span class="line">        Throwable th = result.getException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应结果没有异常信息</span></span><br><span class="line">        <span class="keyword">if</span> (th == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 提取正常返回结果</span></span><br><span class="line">            Object ret = result.getValue();</span><br><span class="line">            <span class="comment">// 调用结果为空</span></span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 序列化响应类型</span></span><br><span class="line">                out.writeByte(attach ? RESPONSE_NULL_VALUE_WITH_ATTACHMENTS : RESPONSE_NULL_VALUE);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用结果非空</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 序列化响应类型</span></span><br><span class="line">                out.writeByte(attach ? RESPONSE_VALUE_WITH_ATTACHMENTS : RESPONSE_VALUE);</span><br><span class="line">                <span class="comment">// 序列化调用结果</span></span><br><span class="line">                out.writeObject(ret);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//响应结果有异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 序列化响应类型</span></span><br><span class="line">            out.writeByte(attach ? RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS : RESPONSE_WITH_EXCEPTION);</span><br><span class="line">            <span class="comment">// 序列化异常对象</span></span><br><span class="line">            out.writeObject(th);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前协议版本支持Response带有attachments集合</span></span><br><span class="line">        <span class="keyword">if</span> (attach) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录 Dubbo 协议版本，返回给服务消费端</span></span><br><span class="line">            result.getAttachments().put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 序列化 attachments 集合</span></span><br><span class="line">            out.writeObject(result.getAttachments());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据 Dubbo 协议的格式编码响应体，主要将 Dubbo 响应状态和响应值编码成字节流，对应的解码在 <strong>DecodeableRpcResult</strong> 对象中。<strong>out</strong> 参数注意事项同编码请求消息体。</p>
<h2 id="解码消息体"><a href="#解码消息体" class="headerlink" title="解码消息体"></a>解码消息体</h2><p>对 ExchangeCodec 的 decodeBody() 方法的重写，用于将数据包解析成 Request 和 Response 模型。</p>
<h3 id="解码请求体"><a href="#解码请求体" class="headerlink" title="解码请求体"></a>解码请求体</h3><p>将请求包解析成 Request 模型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboCodec</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decodeBody</span><span class="params">(Channel channel, InputStream is, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 协议头第 3 个字节</span></span><br><span class="line">        <span class="keyword">byte</span> flag = header[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取序列化器编号</span></span><br><span class="line">        <span class="keyword">byte</span> proto = (<span class="keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);</span><br><span class="line">        <span class="comment">//  获得调用编号（请求时生成的一个id，用来标识一次调用）</span></span><br><span class="line">        <span class="keyword">long</span> id = Bytes.bytes2long(header, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Req/Res -&gt; 0 ，即响应包</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="number">0</span>) &#123;</span><br><span class="line">          </span><br><span class="line">           <span class="comment">// 省略解码响应逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Req/Res -&gt; 0 ，即请求包</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建Request</span></span><br><span class="line">            Request req = <span class="keyword">new</span> Request(id);</span><br><span class="line"></span><br><span class="line">            req.setVersion(Version.getProtocolVersion());             </span><br><span class="line">            <span class="comment">// 设置消息单向或双向</span></span><br><span class="line">            req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置消息是否为事件消息</span></span><br><span class="line">            <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置心跳事件到Request对象中</span></span><br><span class="line">                req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object data;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过序列化器编号间接获取输入流</span></span><br><span class="line">                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解码心跳事件，心跳报文没有消息体</span></span><br><span class="line">                <span class="keyword">if</span> (req.isHeartbeat()) &#123;</span><br><span class="line">                    <span class="comment">// 对心跳包进行解码，该方法已经废弃，父类 ExchangeCodec 中的方法</span></span><br><span class="line">                    data = decodeHeartbeatData(channel, in);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 对其他事件数据解码，这里是 readonly 事件</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">                    <span class="comment">// 父类 ExchangeCodec 中的方法</span></span><br><span class="line">                    data = decodeEventData(channel, in);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 解码普通请求</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    DecodeableRpcInvocation inv;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 根据url参数判断，是否在通信框架（如Netty）的IO线程上对消息体进行解码，默认为 true</span></span><br><span class="line">                    <span class="keyword">if</span> (channel.getUrl().getParameter(Constants.DECODE_IN_IO_THREAD_KEY, Constants.DEFAULT_DECODE_IN_IO_THREAD)) &#123;</span><br><span class="line">                        <span class="comment">// 创建可解码的 DecodeableRpcInvocation 对象</span></span><br><span class="line">                        inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req, is, proto);</span><br><span class="line">                        <span class="comment">// 直接调用decode()方法在当前线程，即IO线程上进行解码工作</span></span><br><span class="line">                        inv.decode();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 在 Dubbo ThreadPool 线程上解码，使用 DecodeHandler</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req, <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 并没有解码，延迟到业务线程池中解码</span></span><br><span class="line">                    data = inv;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置data 到 Request 对象中,</span></span><br><span class="line">                req.setData(data);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Decode request failed: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在解码的过程中出现异常，则设置 broken 字段标识请求异常，并将异常对象设置到Request对象中</span></span><br><span class="line">                req.setBroken(<span class="keyword">true</span>);</span><br><span class="line">                req.setData(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> req;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解码响应体"><a href="#解码响应体" class="headerlink" title="解码响应体"></a>解码响应体</h3><p>将响应包解析成 Response 模型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboCodec</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decodeBody</span><span class="params">(Channel channel, InputStream is, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 协议头第 3 个字节</span></span><br><span class="line">        <span class="keyword">byte</span> flag = header[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取序列化器编号</span></span><br><span class="line">        <span class="keyword">byte</span> proto = (<span class="keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);</span><br><span class="line">        <span class="comment">// 获得调用编号（请求时生成的一个id，用来标识一次调用）</span></span><br><span class="line">        <span class="keyword">long</span> id = Bytes.bytes2long(header, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Req/Res -&gt; 0 ，即响应包</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 Response 对象，注意 id </span></span><br><span class="line">            Response res = <span class="keyword">new</span> Response(id); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置心跳事件</span></span><br><span class="line">            <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">                res.setEvent(Response.HEARTBEAT_EVENT);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取并设置响应状态</span></span><br><span class="line">            <span class="keyword">byte</span> status = header[<span class="number">3</span>];</span><br><span class="line">            res.setStatus(status);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过序列化器编号间接获取输入流</span></span><br><span class="line">                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用过程正常</span></span><br><span class="line">                <span class="keyword">if</span> (status == Response.OK) &#123;</span><br><span class="line">                    Object data;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 心跳事件</span></span><br><span class="line">                    <span class="keyword">if</span> (res.isHeartbeat()) &#123;</span><br><span class="line">                        <span class="comment">// 反序列化心跳数据，父类 ExchangeCodec 中的方法</span></span><br><span class="line">                        data = decodeHeartbeatData(channel, in);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 反序列化其他事件数据</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.isEvent()) &#123;</span><br><span class="line">                        data = decodeEventData(channel, in);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 解码普通响应</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        DecodeableRpcResult result;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 根据配置决定是否在当前通信框架（如：Netty）的IO线程上解码，默认true</span></span><br><span class="line">                        <span class="keyword">if</span> (channel.getUrl().getParameter(Constants.DECODE_IN_IO_THREAD_KEY, Constants.DEFAULT_DECODE_IN_IO_THREAD)) &#123;</span><br><span class="line">                            <span class="comment">// 创建 DecodeableRpcResult 对象</span></span><br><span class="line">                            result = <span class="keyword">new</span> DecodeableRpcResult(channel, res, is, (Invocation) getRequestData(id), proto);</span><br><span class="line">                            <span class="comment">// 解码</span></span><br><span class="line">                            result.decode();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 在 Dubbo ThreadPool 线程，解码。会在DecodeHandler中会调用 DecodeableRpcResult#decode()方法</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            result = <span class="keyword">new</span> DecodeableRpcResult(channel, res, <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)), (Invocation) getRequestData(id), proto);</span><br><span class="line">                        &#125;</span><br><span class="line">                        data = result;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 设置 DecodeableRpcResult 对象到 Response 对象中</span></span><br><span class="line">                    res.setResult(data);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 响应状态非 OK，表明调用过程出现了异常</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 反序列化异常信息，并设置到 Response 对象中</span></span><br><span class="line">                    res.setErrorMessage(in.readUTF());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Decode response failed: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解码过程中出现了错误，此时设置 CLIENT_ERROR 状态码到 Response 对象中</span></span><br><span class="line">                res.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">                res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 请求包</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 省略解码请求逻辑           </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="DecodeableRpcInvocation"><a href="#DecodeableRpcInvocation" class="headerlink" title="DecodeableRpcInvocation"></a>DecodeableRpcInvocation</h1><p>DecodeableRpcInvocation 实现了 Codec 和 Decodeable 接口，并且继承了 RpcInvocation 类，是一个可解码的 Invocation 实现类。服务消费方是对 <strong>RpcInvocation</strong> 对象的编码，将所需字段编码成字节流。服务提供方将字节流消息解码成 <strong>DecodeableRpcInvocation</strong> 对象。</p>
<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeableRpcInvocation</span> <span class="keyword">extends</span> <span class="title">RpcInvocation</span> <span class="keyword">implements</span> <span class="title">Codec</span>, <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DecodeableRpcInvocation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 的通道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Serialization 类型编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> serializationType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息字节流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Request request;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经解码完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasDecoded;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可解码 Invocation</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel Dubbo 底层通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is      字节流消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id      序列化编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecodeableRpcInvocation</span><span class="params">(Channel channel, Request request, InputStream is, <span class="keyword">byte</span> id)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(channel, <span class="string">"channel == null"</span>);</span><br><span class="line">        Assert.notNull(request, <span class="string">"request == null"</span>);</span><br><span class="line">        Assert.notNull(is, <span class="string">"inputStream == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        <span class="keyword">this</span>.inputStream = is;</span><br><span class="line">        <span class="keyword">this</span>.serializationType = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">+--- DecodeableRpcInvocation</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="keyword">null</span> &amp;&amp; inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                decode(channel, inputStream);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Decode rpc invocation failed: "</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解码失败，设置失败标志</span></span><br><span class="line">                request.setBroken(<span class="keyword">true</span>);</span><br><span class="line">                request.setData(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                hasDecoded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">+--- DecodeableRpcInvocation</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取序列化方式，然后通过反序列化得到所需的调用信息</span></span><br><span class="line">        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType).deserialize(channel.getUrl(), input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 框架版本</span></span><br><span class="line">        String dubboVersion = in.readUTF();</span><br><span class="line">        request.setVersion(dubboVersion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反序列化得到 `dubbo` `path` `version`，并保存到 attachments 变量中</span></span><br><span class="line">        setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion);</span><br><span class="line">        setAttachment(Constants.PATH_KEY, in.readUTF()); <span class="comment">// 读取调用接口</span></span><br><span class="line">        setAttachment(Constants.VERSION_KEY, in.readUTF()); <span class="comment">// 读取接口指定的版本，默认为 0.0.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反序列化得到调用方法名</span></span><br><span class="line">        setMethodName(in.readUTF());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 参数列表</span></span><br><span class="line">            Object[] args;</span><br><span class="line">            <span class="comment">// 参数类型列表</span></span><br><span class="line">            Class&lt;?&gt;[] pts;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反序列化得到参数类型字符串，如： Ljava/lang/String</span></span><br><span class="line">            String desc = in.readUTF();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (desc.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                pts = DubboCodec.EMPTY_CLASS_ARRAY;</span><br><span class="line">                args = DubboCodec.EMPTY_OBJECT_ARRAY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将 desc 解析为参数类型数组</span></span><br><span class="line">                pts = ReflectUtils.desc2classArray(desc);</span><br><span class="line">                args = <span class="keyword">new</span> Object[pts.length];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 一次读取方法参数值</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 解析运行时参数</span></span><br><span class="line">                        args[i] = in.readObject(pts[i]);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                            log.warn(<span class="string">"Decode argument failed: "</span> + e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置参数类型数组</span></span><br><span class="line">            setParameterTypes(pts);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反序列化得到原 attachments 的内容即隐式参数</span></span><br><span class="line">            Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) in.readObject(Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (map != <span class="keyword">null</span> &amp;&amp; map.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Map&lt;String, String&gt; attachment = getAttachments();</span><br><span class="line">                <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    attachment = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                attachment.putAll(map);</span><br><span class="line">                setAttachments(attachment);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 参数回调用</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                args[i] = decodeInvocationArgument(channel, <span class="keyword">this</span>, pts, i, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置参数列表</span></span><br><span class="line">            setArguments(args);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read invocation data failed."</span>, e));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">                ((Cleanable) in).cleanup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>DecodeableRpcInvocation 是一个支持解码功能的实现类，并不支持编码功能。</p>
<p>在解码请求时，是严格按照写数据顺序来处理的。通过反序列化将诸如 <strong>path</strong>、<strong>version</strong>、<strong>methodName</strong> 以及 <strong>参数列表等信息</strong>解析出来，并设置到对应的字段中，最终得到一个具有完整调用信息的 <strong>DecodeableRpcInvocation</strong> 对象。</p>
<h1 id="DecodeableRpcResult"><a href="#DecodeableRpcResult" class="headerlink" title="DecodeableRpcResult"></a>DecodeableRpcResult</h1><p>DecodeableRpcResult 实现了 Codec 和 Decodeable 接口，且继承了 RpcResult ，可解码的 Result 实现类。和 DecodeableRpcInvocation 类似，服务提供方是对 <strong>Result</strong> 对象的编码，将响应状态和响应结果编码成字节流。服务消费方将响应消息解码成 <strong>DecodeableRpcResult</strong> 对象。</p>
<h2 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeableRpcResult</span> <span class="keyword">extends</span> <span class="title">RpcResult</span> <span class="keyword">implements</span> <span class="title">Codec</span>, <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DecodeableRpcResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 底层通道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Serialization 类型编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> serializationType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Response response;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invocation 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Invocation invocation;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经解码完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasDecoded;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可解码 Result</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel    Dubbo 底层通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response   响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is         字节流响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 调用信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id         序列化编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecodeableRpcResult</span><span class="params">(Channel channel, Response response, InputStream is, Invocation invocation, <span class="keyword">byte</span> id)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(channel, <span class="string">"channel == null"</span>);</span><br><span class="line">        Assert.notNull(response, <span class="string">"response == null"</span>);</span><br><span class="line">        Assert.notNull(is, <span class="string">"inputStream == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.response = response;</span><br><span class="line">        <span class="keyword">this</span>.inputStream = is;</span><br><span class="line">        <span class="keyword">this</span>.invocation = invocation;</span><br><span class="line">        <span class="keyword">this</span>.serializationType = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解码-1"><a href="#解码-1" class="headerlink" title="解码"></a>解码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">+--- DecodeableRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="keyword">null</span> &amp;&amp; inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行反序列化操作</span></span><br><span class="line">                decode(channel, inputStream);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Decode rpc result failed: "</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 反序列化失败，设置 CLIENT_ERROR 状态到 Response 对象中</span></span><br><span class="line">                response.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">                <span class="comment">// 设置异常信息</span></span><br><span class="line">                response.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                hasDecoded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">+--- DecodeableRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过序列化器获取输入流</span></span><br><span class="line">        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType).deserialize(channel.getUrl(), input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化响应类型(编码序列化时设置的)</span></span><br><span class="line">        <span class="keyword">byte</span> flag = in.readByte();</span><br><span class="line">        <span class="comment">// 匹配响应类型</span></span><br><span class="line">        <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">            <span class="comment">// 无返回值</span></span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 有返回值</span></span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Type[] returnType = RpcUtils.getReturnTypes(invocation);</span><br><span class="line">                    <span class="comment">// 设置结果</span></span><br><span class="line">                    setValue(returnType == <span class="keyword">null</span> || returnType.length == <span class="number">0</span> ?</span><br><span class="line">                            in.readObject() :</span><br><span class="line">                            <span class="comment">// 返回结果:Type[]&#123;method.getReturnType(), method.getGenericReturnType()&#125;</span></span><br><span class="line">                            (returnType.length == <span class="number">1</span> ? in.readObject((Class&lt;?&gt;) returnType[<span class="number">0</span>]) : in.readObject((Class&lt;?&gt;) returnType[<span class="number">0</span>], returnType[<span class="number">1</span>])));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有异常</span></span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object obj = in.readObject();</span><br><span class="line">                    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Throwable == <span class="keyword">false</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Response data error, expect Throwable, but get "</span> + obj);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setException((Throwable) obj);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回值为空，且携带了 attachments 集合</span></span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 反序列化 attachments 集合，并存储起来</span></span><br><span class="line">                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回值不为空，且携带了 attachments 集合</span></span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取返回值类型</span></span><br><span class="line">                    Type[] returnType = RpcUtils.getReturnTypes(invocation);</span><br><span class="line">                    <span class="comment">// 反序列化调用结果，并保存起来</span></span><br><span class="line">                    setValue(returnType == <span class="keyword">null</span> || returnType.length == <span class="number">0</span> ? in.readObject() : (returnType.length == <span class="number">1</span> ? in.readObject((Class&lt;?&gt;) returnType[<span class="number">0</span>]) : in.readObject((Class&lt;?&gt;) returnType[<span class="number">0</span>], returnType[<span class="number">1</span>])));</span><br><span class="line">                    <span class="comment">// 反序列化 attachments 集合，并存储起来</span></span><br><span class="line">                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异常对象不为空，且携带了 attachments 集合</span></span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 反序列化异常对象</span></span><br><span class="line">                    Object obj = in.readObject();</span><br><span class="line">                    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Throwable == <span class="keyword">false</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Response data error, expect Throwable, but get "</span> + obj);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置异常对象</span></span><br><span class="line">                    setException((Throwable) obj);</span><br><span class="line">                    <span class="comment">// 反序列化 attachments 集合，并存储起来</span></span><br><span class="line">                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unknown result flag, expect '0' '1' '2', get "</span> + flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) in).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>DecodeableRpcResult 是一个支持解码功能的实现类，同样不支持编码功能。</p>
<p>在解码响应时，通过反序列化将 <strong>result</strong>或<strong>exception</strong> 以及 <strong>attachments</strong> 解析出来，并设置到对应的字段中，最终得到一个完整响应结果的 <strong>DecodeableRpcResult</strong> 对象。</p>
<h1 id="DubboCountCodec"><a href="#DubboCountCodec" class="headerlink" title="DubboCountCodec"></a>DubboCountCodec</h1><p>DubboCountCodec 实现了 Codec2 顶级接口，编解码的任务都是交给 DubboCodec 对象去完成。DubboProtocol 默认指定的编解码器就是 DubboCountCodec，编码任务直接委托给 DubboCodec 处理，解码支持多消息处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboCountCodec</span> <span class="keyword">implements</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo的编解码器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DubboCodec codec = <span class="keyword">new</span> DubboCodec();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码直接委托给 DubboCodec 处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        codec.encode(channel, buffer, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录当前读位置，用于下面计算每条消息的长度</span></span><br><span class="line">        <span class="keyword">int</span> save = buffer.readerIndex();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MultiMessage对象，对多消息的封装，MultiMessageHandler处理器会对该消息进行分发处理。</span></span><br><span class="line">        MultiMessage result = MultiMessage.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环解码消息</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过 DubboCodec 解码一条消息</span></span><br><span class="line">            Object obj = codec.decode(channel, buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 字节数不够，重置读指针，然后结束解析</span></span><br><span class="line">            <span class="keyword">if</span> (Codec2.DecodeResult.NEED_MORE_INPUT == obj) &#123;</span><br><span class="line">                buffer.readerIndex(save);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将成功解码出的消息添加到 MultiMessage 中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 添加结果消息</span></span><br><span class="line">                result.addMessage(obj);</span><br><span class="line">                <span class="comment">// 记录消息长度</span></span><br><span class="line">                logMessageLength(obj, buffer.readerIndex() - save);</span><br><span class="line">                <span class="comment">// 记录当前读位置，用于计算下一条消息的长度</span></span><br><span class="line">                save = buffer.readerIndex();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有解码出消息，则返回NEED_MORE_INPUT错误码</span></span><br><span class="line">        <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Codec2.DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只解码出来一条消息，则直接返回该条消息</span></span><br><span class="line">        <span class="keyword">if</span> (result.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解码出多条消息则将MultiMessage返回</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/61d79ae/" title="Dubbo源码分析 - 编解码器" target="_blank" rel="external">https://gentryhuang.com/posts/61d79ae/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/ef4cfe7a/" title="Dubbo源码分析 - 优雅停机"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/26722deb/" title="Dubbo源码分析 - 信息交换层"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2020 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>