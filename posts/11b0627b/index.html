<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>并发 - JMM | gentryhuang的博客</title>
  <meta name="description" content="前言本篇文章将对 Java 的内存模型（JMM）进行介绍，本质上它是一种编程语言规范，用于尝试统一一个能够在各种处理器架构中为并发提供一致语义的内存模型（不同处理器架构一般具有不同强度的模型）。驱动 Java 内存模型产生的原因有很多，如编译器优化、处理器乱序执行和缓存等，这些因素导致并发程序中有些行为是非法的。因此，在介绍 Java 内存模型之前，我们先对并发编程相关概念进行说明，然后再引出 J">
<meta property="og:type" content="article">
<meta property="og:title" content="并发 - JMM">
<meta property="og:url" content="https://gentryhuang.com/posts/11b0627b/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="前言本篇文章将对 Java 的内存模型（JMM）进行介绍，本质上它是一种编程语言规范，用于尝试统一一个能够在各种处理器架构中为并发提供一致语义的内存模型（不同处理器架构一般具有不同强度的模型）。驱动 Java 内存模型产生的原因有很多，如编译器优化、处理器乱序执行和缓存等，这些因素导致并发程序中有些行为是非法的。因此，在介绍 Java 内存模型之前，我们先对并发编程相关概念进行说明，然后再引出 J">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gentryhuang.com/posts/11b0627b/computer-hardware-memory-architecture.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/11b0627b/cpu-cache-level.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/11b0627b/cpu-command-process.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/11b0627b/computer-hardware-memory-architecture-issue.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/11b0627b/cpu-store-buffer.png">
<meta property="og:image" content="https://gentryhuang.com/posts/11b0627b/cpu-store-buffer-forward.png">
<meta property="og:image" content="https://gentryhuang.com/posts/11b0627b/jmm-model.jpg">
<meta property="og:image" content="https://gentryhuang.com/posts/11b0627b/jmm-cpu-memory-relation.jpg">
<meta property="article:published_time" content="2021-09-20T01:14:12.000Z">
<meta property="article:modified_time" content="2021-09-28T15:55:33.134Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="JMM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gentryhuang.com/posts/11b0627b/computer-hardware-memory-architecture.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/11b0627b/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.38px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.75px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.13px;">I/O</a> <a href="/tags/JMM/" style="font-size: 13px;">JMM</a> <a href="/tags/JUC/" style="font-size: 13.5px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.25px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.13px;">Lock</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.25px;">Protocol</a> <a href="/tags/RPC/" style="font-size: 13.63px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.13px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.25px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.25px;">Spring</a> <a href="/tags/Thread/" style="font-size: 13.13px;">Thread</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.88px;">设计模式</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/11b0627b/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/11b0627b/" class="title">并发 - JMM</a>
              </p>
              <p class="item-date">
                <time datetime="2021-09-20T01:14:12.000Z" itemprop="datePublished">2021-09-20</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/ae5dbc38/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a>
              </p>
              <p class="item-title">
                <a href="/posts/ae5dbc38/" class="title">网络通信 - Reactor模型</a>
              </p>
              <p class="item-date">
                <time datetime="2021-09-12T13:10:23.000Z" itemprop="datePublished">2021-09-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/151f44ae/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/151f44ae/" class="title">并发 - ThreadLocal</a>
              </p>
              <p class="item-date">
                <time datetime="2021-09-03T04:30:12.000Z" itemprop="datePublished">2021-09-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/55ae5a2b/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/55ae5a2b/" class="title">Java基础 - Reference</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-21T02:30:12.000Z" itemprop="datePublished">2021-08-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/dbdf391f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/dbdf391f/" class="title">并发 - Thread</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-14T13:50:21.000Z" itemprop="datePublished">2021-08-14</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#硬件内存架构"><span class="toc-number">2.</span> <span class="toc-text">硬件内存架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#硬件内存组成"><span class="toc-number">2.1.</span> <span class="toc-text">硬件内存组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU优化手段"><span class="toc-number">2.2.</span> <span class="toc-text">CPU优化手段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存"><span class="toc-number">2.2.1.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时指令重排"><span class="toc-number">2.2.2.</span> <span class="toc-text">运行时指令重排</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题"><span class="toc-number">2.3.</span> <span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总线锁"><span class="toc-number">2.3.1.</span> <span class="toc-text">总线锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存一致性协议"><span class="toc-number">2.3.2.</span> <span class="toc-text">缓存一致性协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#专有态-Exclusive"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">专有态(Exclusive)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#共享态-Shared"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">共享态(Shared)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修改态-Modified"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">修改态(Modified)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无效态-Invalid"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">无效态(Invalid)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Store-Buffer"><span class="toc-number">2.3.2.5.</span> <span class="toc-text">Store Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Store-Forward"><span class="toc-number">2.3.2.6.</span> <span class="toc-text">Store Forward</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Invalid-Queue"><span class="toc-number">2.3.2.7.</span> <span class="toc-text">Invalid Queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存屏障"><span class="toc-number">2.3.3.</span> <span class="toc-text">内存屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令重排问题"><span class="toc-number">2.3.4.</span> <span class="toc-text">指令重排问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发"><span class="toc-number">3.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发编程关键问题"><span class="toc-number">3.1.</span> <span class="toc-text">并发编程关键问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发特性"><span class="toc-number">3.2.</span> <span class="toc-text">并发特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可见性"><span class="toc-number">3.2.1.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子性"><span class="toc-number">3.2.2.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序性"><span class="toc-number">3.2.3.</span> <span class="toc-text">有序性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JMM"><span class="toc-number">4.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#细化规范"><span class="toc-number">4.1.</span> <span class="toc-text">细化规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共享变量"><span class="toc-number">4.1.1.</span> <span class="toc-text">共享变量</span></a></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-concurrent/JMM" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      并发 - JMM
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/11b0627b/" class="article-date">
	  <time datetime="2021-09-20T01:14:12.000Z" itemprop="datePublished">2021-09-20</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/JDK/">JDK</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/JMM/" rel="tag">JMM</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/11b0627b/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 6.9k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 24(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章将对 Java 的内存模型（JMM）进行介绍，本质上它是一种编程语言规范，用于尝试统一一个能够在各种处理器架构中为并发提供一致语义的内存模型（不同处理器架构一般具有不同强度的模型）。驱动 Java 内存模型产生的原因有很多，如编译器优化、处理器乱序执行和缓存等，这些因素导致并发程序中有些行为是非法的。因此，在介绍 Java 内存模型之前，我们先对并发编程相关概念进行说明，然后再引出 Java 内存模型。</p>
<h1 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h1><p>了解现代计算机硬件架构对理解 Java 内存模型非常重要，常见的硬件内存架构图如下：</p>
<p><img src="/posts/11b0627b/computer-hardware-memory-architecture.jpg" alt></p>
<p>下面我们重点对硬件内存架构的组成，缓存一致性问题进行介绍。</p>
<h2 id="硬件内存组成"><a href="#硬件内存组成" class="headerlink" title="硬件内存组成"></a>硬件内存组成</h2><p>现代计算机内存架构包括：多CPU、CPU寄存器、CPU缓存以及共享的内存。</p>
<p><strong>多CPU</strong></p>
<blockquote>
<p>现代计算机通常有 2 个或更多 CPU ，其中一些 CPU 可能具有多个核。当只有一个 CPU 时，要运行多个程序（进程）的话，就意味着要经常进行进程上下文切换。尽管单 CPU 是多核，也只是多个处理器核心，其他设备都是共用的，所以多个进程就必然要经常进行进程上下文切换，这个代价是很高的。</p>
</blockquote>
<p><strong>CPU多核</strong></p>
<blockquote>
<p>一个多核的 CPU 也就是一个 CPU 上有多个处理器核心。</p>
</blockquote>
<p><strong>CPU寄存器</strong></p>
<blockquote>
<p>每个 CPU 都包含一组寄存器，它们是 CPU 内存的基础。CPU 在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为 CPU 访问寄存器的速度远大于主存。</p>
</blockquote>
<p><strong>CPU缓存</strong></p>
<blockquote>
<p>每个 CPU 还可能有一个 CPU 缓存存储器层。事实上，大多数现代 CPU 都有一定大小的缓存层，位于 CPU 与主内存间的一种容量较小但速度很高的存储器，但通常不如访问其内部寄存器的速度快。由于 CPU 的速度远高于主内存，CPU 直接从主内存中存取数据要等待一定时间周期。CPU 缓存中保存着 CPU 刚用过或循环使用的一部分数据，当 CPU 再次使用该部分数据时可从缓存中直接获取, 减少了 CPU 的等待时间，提高了系统的效率。</p>
</blockquote>
<p>一些 CPU 可能有多个缓存层，具体如下：</p>
<blockquote>
<ul>
<li><strong>一级缓存(L1 Cache)</strong>: 容量最小，速度最快，每个核独有。针对指令和数据分为数据缓存和指令缓存</li>
<li><strong>二级缓存(L2 Cache)</strong>: 容量比 L1 大，速度比 L1 慢，每个核独有</li>
<li><strong>三级缓存(L3 Cache)</strong>: 容量最大，速度最慢，<strong>多个核共享</strong></li>
</ul>
</blockquote>
<p>由于Cache的容量很小，一般都是充分的利用局部性原理，按<strong>行/块</strong>来和主存进行批量数据交换，以提升数据的访问效率。</p>
<p><strong>内存</strong></p>
<blockquote>
<p>计算机还包含一个主存储区 (RAM)，所有 CPU 都可以访问它。主内存区域通常比 CPU 的高速缓存大得多。</p>
</blockquote>
<p><strong>读取数据</strong></p>
<blockquote>
<ul>
<li><strong>取寄存器中的值</strong>: 只需要一步，直接读取即可。</li>
<li><strong>取L1中的值</strong>: 先锁住<strong>缓存行</strong>，然后取出数据，最后解锁。如果没有锁住说明慢了。</li>
<li><strong>取L2中的值</strong>: 先到 L1 中取，L1 中不存在再到 L2 中取。L2 开始加锁，将 L2 中的数据复制到 L1 ，再执行从 L1 中读取数据的步骤，解锁 L2。</li>
<li><strong>取L3中的值</strong>: 同样地，先将数据由 L3 复制到 L2，然后从 L2 复制到 L1 ，从 L1 读取数据。</li>
</ul>
</blockquote>
<p>CPU 在读取数据时，先在 L1 中寻找，再从 L2 中寻找，再从 L3 中寻找，然后是内存，最后是外存储器。</p>
<h2 id="CPU优化手段"><a href="#CPU优化手段" class="headerlink" title="CPU优化手段"></a>CPU优化手段</h2><p>为了提高程序运行的性能，现代 CPU 在很多方面对程序进行了优化。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>CPU 高速缓存，尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存提高性能。</p>
<p><img src="/posts/11b0627b/cpu-cache-level.jpg" alt></p>
<h3 id="运行时指令重排"><a href="#运行时指令重排" class="headerlink" title="运行时指令重排"></a>运行时指令重排</h3><p>为了提高 CPU 处理性能，CPU 可能会乱序执行。如，当 CPU 写缓存时发现缓存曲块正被其它 CPU 占用，为了提高 CPU 处理性能，可能将后面的读缓存命令优先执行。</p>
<p><img src="/posts/11b0627b/cpu-command-process.jpg" alt></p>
<p>注意，CPU 指令重排并非随意重排，需要遵守 <strong>as-if-serial语义</strong> ，该语义表示：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，运行时和处理器都必须遵守 <strong>as-if-serial 语义</strong>。也就是说，编译器和处理器<strong>不会对存在数据依赖关系的操作做重排序</strong>。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>基于高速缓存很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题-<strong>缓存一致性(CacheCoherence)</strong>。缓存中的数据与主内存的数据并不是实时同步的，各 CPU（或 CPU 核）间缓存的数据也不是实时同步。也就是说，在同一个时间点，各 CPU 所看到同一内存地址的数据的值可能不一致。如，当多个处理器执行的任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，这样不一致的情况如果同步回主内存时以哪个处理为准呢？</p>
<p><img src="/posts/11b0627b/computer-hardware-memory-architecture-issue.jpg" alt></p>
<p>运行在左侧 CPU 上的一个线程将共享对象复制到其 CPU 缓存中，并将其count变量更改为 2。此更改对运行在右侧 CPU 上的其他线程不可见，因为更新的count尚未刷新回主内存.</p>
<h3 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h3><p>所有内存的传输都发生在一条共享的总线上，所有的处理器都会使用该总线。虽然 CPU 缓存各自是独立的，但是主存是共享的，所有的内存访问都要经过总线加锁机制来决定是否可以进行内存的读写，也就是说在同一个指令周期中，只可能有一个 CPU 可以读写内存。</p>
<p>所谓总线锁就是使用处理器提供的一个 <code>LOCK#信号</code> ，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，只有该处理器可以独占共享内存。</p>
<h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>总线锁虽然可以保证缓存数据的一致性，但是它比较粗暴，当某个 CPU 对总线进行加锁后，所有后续其它 CPU 对主存的操作都是阻塞的，这样机制就必定会降低性能。因此，缓存一致性协议出现了，它是硬件程序的产物，用来保证缓存之间可见。</p>
<p>缓存一致性协议有多种，如 <strong>MSI</strong>、<strong>MESI</strong> 等，多数 CPU 厂商对缓存一致性协议进行了实现。下面我们以 <strong>MESI</strong> 协议为例，对其进行介绍。</p>
<p><strong>MESI协议</strong>规定每个缓存行有个状态位，同时定义了下面四个状态：</p>
<h4 id="专有态-Exclusive"><a href="#专有态-Exclusive" class="headerlink" title="专有态(Exclusive)"></a>专有态(Exclusive)</h4><p>锁住的缓存行内容只存在当前 CPU 缓存中且同于主存，不出现于其它缓存中，所以当 CPU 发现自己缓存中的共享数据是<strong>专有态(Exclusive)</strong>时，说明该数据是最新的，可以直接读取。</p>
<p>当缓存行处于<strong>专有态(Exclusive)</strong>时，在任何时刻当有其它 CPU 缓存了该数据时，那么缓存行会由<strong>专有态(Exclusive)</strong>变成<strong>共享态(Shared)</strong>。</p>
<h4 id="共享态-Shared"><a href="#共享态-Shared" class="headerlink" title="共享态(Shared)"></a>共享态(Shared)</h4><p>锁住的缓存行同于主存，且该缓存行可能被多个 CPU 缓存，各个缓存与主内存数据一致，所以当 CPU 发现自己缓存中的共享数据是<strong>共享态(Shared)</strong>时，说明该数据是最新值，可以直接读取。</p>
<p>当缓存行处于<strong>共享态(Shared)</strong>时，当任一个 CPU 修改缓存行时，其它 CPU 中该缓存行变成<strong>无效态(Invalid)</strong>。</p>
<h4 id="修改态-Modified"><a href="#修改态-Modified" class="headerlink" title="修改态(Modified)"></a>修改态(Modified)</h4><p>锁住的缓存行已被修改（脏行），内容已不同于主存。该状态是一个中间状态，缓存行的数据需要在未来某个时间点写回主内存，当被写回主内存之后，该缓存行就会变成专有状态。</p>
<p>当 CPU 对缓存行进行修改时，变为<strong>修改态(Modified)</strong>，并且同时会向其他缓存了该数据的 CPU 缓存发送一条 Invalid 指令，告诉其他缓存自己对数据进行了修改，让它们把数据对应的缓存行置为<strong>无效态(Invalid)</strong>； 当收到其它 CPU 缓存 Invalid 指令的成功响应时，当前 CPU 缓存会就会把数据同步到主存里面去，然后自己的缓存行由<strong>修改态(Modified)</strong>变为<strong>专有态(Exclusive)</strong>，当有其他 CPU 缓存从主存中读取到了最新的数据时，数据状态会变为<strong>共享态(Shared)</strong>。</p>
<h4 id="无效态-Invalid"><a href="#无效态-Invalid" class="headerlink" title="无效态(Invalid)"></a>无效态(Invalid)</h4><p>当缓存行处于<strong>无效态(Invalid)</strong>时，说明对应的数据已经被其它 CPU 修改过了，当前锁住的缓存行无效，必须从主存中重新读取。</p>
<p>无效态(Invalid)是由于收到其它 CPU 发来的 Invalid 指令，收到该指令的 CPU 缓存会把对应的缓存行状态标记为<strong>无效态(Invalid)</strong>，所以当数据处于<strong>无效态(Invalid)</strong>时表示数据已经被别人修改了，当前数据是无效的。</p>
<p>多处理器时，单个 CPU 对缓存中数据进行改动需要通知给其他 CPU 。也就意味着在缓存一致性协议下，CPU 处理要控制自己的读写操作，还要监听（嗅探）其它 CPU 发出的通知，从而保证<strong>最终一致</strong>。</p>
<p>这里需要说明下，MESI协议可以在 CPU 修改数据时向其他 CPU 发送消息，但不会出现两个CPU同时修改数据，进而向其他CPU进行消息通知。这样的并发修改通过缓存锁定机制解决的，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性。只有在数据修改的时候才会需要加缓存锁，修改数据的时候先锁定缓存行，不让其他CPU同时修改，其他CPU读取数据是允许的。缓存是否失效是由缓存一致性协议来处理的，它解决一个 CPU 修改其它 CPU 看不到的问题。缓存锁解决几个 CPU 并发修改的问题。</p>
<p><strong>以下两种情况下处理器会使用总线锁：</strong></p>
<ul>
<li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时</li>
<li>处理器不支持缓存锁定</li>
</ul>
<h4 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h4><p>前文在描述 MESI 协议时，如果对缓存行进行修改需要经历以下过程：</p>
<ol>
<li>某个CPU修改自己缓存的值</li>
<li>修改缓存后通知其它CPU，等待其它CPU响应</li>
<li>收到所有CPU的响应</li>
<li>将缓存中的数据同步到主存</li>
</ol>
<p>可以看到，以上整个过程都是同步的，CPU 发送完通知后必须同步等待所有其它 CPU 的响应，而这个过程中当前 CPU 又无法释放出来，所以为了避免这种 CPU 运算资源的浪费，就需要一种方式来进行优化了，此时 <strong>Store Buffer</strong> 就出来了。</p>
<p><img src="/posts/11b0627b/cpu-store-buffer.png" alt></p>
<p>当 CPU 对某个共享变量修改时，向其他 CPU 发出 Invalid 指令后不同步等待其他 CPU 指令的响应了，而是直接把最新值写入 Store Bufferes 缓冲区里，然后直接可以去干别的事情了，直到所有的 CPU 都对 Invalid 指令响应后，再把共享变量的值从 Store Buffere 里拿出来，然后写入到自己的缓存里同时同步到主存中。</p>
<h4 id="Store-Forward"><a href="#Store-Forward" class="headerlink" title="Store Forward"></a>Store Forward</h4><p>Store Forward 称为存储转发。具体是：当 CPU 读取数据时需要先检查它的 Store Buffer 缓冲区中有没有，如果有则直接读取该缓冲区中的值，没有才会读取自己缓存中的值。解决了 Store Buffer 优化过程中由于只读取缓存导致的缓存脏数据问题。</p>
<p><img src="/posts/11b0627b/cpu-store-buffer-forward.png" alt></p>
<p>至此，Store Buffer 优化提升了 CPU 效率。但由于修改共享变量先是放到了 Store Buffer 中，只有等到其它 CPU 返回 Invalid OK 后才会同步到缓冲和主存。可以看出执行写操作不是立即生效的，对于有相互依赖的共享数据相关指令，可能会出现CPU乱序执行的现象。解决手段是利用<strong>内存屏障</strong>禁用CPU缓存优化，也就是更新数据时必须立即更新到主存（也就是把store buffer里的指令全部执行完）。</p>
<h4 id="Invalid-Queue"><a href="#Invalid-Queue" class="headerlink" title="Invalid Queue"></a>Invalid Queue</h4><p>因为 Store Buffer 空间很小，如果有大量的变量修改，它会存储不下，那么这个时候又回到同步通知的状态。此外，有时候其它 CPU 很繁忙并不能马上进行响应，因此为了避免同步等待响应的时间太长，就为每个 CPU 加一个失效队列，当 Store Buffer 存不下的时候，就把失效通知发送到其它 CPU 的失效队列里，只要队列成功接收到了发送的消息就进行响应（发送 Invalid 指令的 CPU 就可以将修改同步到主存了），等到其他CPU闲下来了就从各自的失效队列里读取消息然后失效掉CPU的缓存数据。</p>
<p>MESI 优化到了 Invalid Queue 阶段，一般来说性能已经很高了，但是在极端的情况下会出现缓存可见性问题。具体来说就是，接收到 Invalid 指令的 CPU 没有来得及处理它的实效队列中的消息，没有及时失效掉对应的缓存行，导致继续使用了本应该失效的缓存数据。这种因为CPU缓存优化而导致后面的指令查看不到前面指令的执行结果，就好像指令之间的执行顺序错乱了一样，这类现象也就是我们俗称的<strong>CPU乱序执行</strong>。解决方法很简单，直接禁用 CPU 缓存优化即可，也就是修改共享数据的指令都同步完成就能保证数据的可见性了，但是这样又会降低整体的性能，这样有点得不偿失，因为毕竟大部分情况下数据都不存在这种共享的问题。不过我们必须要为这种场景提供一种手段来禁用CPU缓存优化，而这种手段同样也是<strong>内存屏障</strong>机制，读取数据时必须读取最新的数据（也就是必须先把失效队列的数据先读取应用完）。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>前文我们说的内存屏障可以同时作用于 Store Buffer 和 Invalidate Queue 。而实际上，对于写操作只需关心 Store Buffer ，读操作只需关心 Invalidate Queue 。因此，大多数 CPU 架构将内存屏障分为了读屏障和写屏障。内存屏障本质上是 CPU 提供的一组指令，不同的操作系统有不同的实现。</p>
<p><strong>读屏障:</strong> 任何读屏障前的读操作都会先于读屏障后的读操作完成，即读屏障指令执行后就能保证后面的读取数据指令一定能读取到最新的数据。<br><strong>写屏障:</strong> 任何写屏障前的写操作都会先于写屏障后的写操作完成，即遇到写屏障指令就必须把该指令之前的所有写入指令执行完毕才可以往下执行，这样就可以让CPU修改的数据及时暴露给其它CPU。<br><strong>全屏障:</strong> 同时包含读屏障和写屏障的作用</p>
<p>实际的 CPU 架构中，可能提供多种内存屏障，常见的如下：</p>
<ul>
<li>LoadLoad: 相当于前面说的读屏障</li>
<li>LoadStore: 任何该屏障前的读操作都会先于该屏障后的写操作完成</li>
<li>StoreLoad: 任何该屏障前的写操作都会先于该屏障后的读操作完成</li>
<li>StoreStore: 相当于前面说的写屏障</li>
</ul>
<p>实现原理都是类似的，如作用于Store Buffer和Invalidate Queue 。</p>
<h3 id="指令重排问题"><a href="#指令重排问题" class="headerlink" title="指令重排问题"></a>指令重排问题</h3><p>CPU 指令重排虽然遵守了 <strong>as-if-serial</strong> 语义，但仅在单 CPU 执行的情况下能保证结果正确。在多核多线程中，指令逻辑无法分辨因果关联，为了更好地利用流水线可能出现<strong>乱序执行</strong>，导致程序运行结果错误。</p>
<p>前文中谈的是内存屏障的可见性功能，它能够让屏障前的操作（读/写）及时执行、刷新，被其它 CPU 看到。而内存屏障还有个功能就是限制指令重排（读/写指令），否则即使内存屏障可以保证可见性，但由于不能保证指令重排，保证可见性意义也不大。</p>
<p>也就是说，内存屏障提供了一套解决CPU缓存优化而导致的顺序性和可见性问题的方案，但是由于不同的硬件系统提供的内存屏障指令可能都不一样，因此像 JAVA 这种高级编程语言就把不同的内存屏障指令统一进行了封装，让开发者不需要关心到系统的底层，而封装这套解决方案的模型就是Java内存模型(Java Memory Model)。</p>
<p>注意，除了运行期间 CPU 的指令重排，编译器在编译期间，可能也对指令进行重排，以使其对CPU更友好。</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>了解了硬件内存架构后，从本小节开始，我们简单聊聊并发。</p>
<h2 id="并发编程关键问题"><a href="#并发编程关键问题" class="headerlink" title="并发编程关键问题"></a>并发编程关键问题</h2><p>在并发编程中需要处理两个关键问题：线程之间如何通信及线程之间如何同步。</p>
<p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种，共享内存和消息传递。共享内存通信机制中，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行<strong>隐式通信</strong>。消息传递通信机制中，线程之间没有公共状态，线程之间必须通过发送消息来<strong>显式通信</strong>。</p>
<p>同步是指程序中用于控制不同线程间操作发生的相对顺序的机制。在共享内存并发模型中，同步是显式进行的，也就是说程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型中，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<p>Java 的并发采用的是<strong>共享内存模型</strong>，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<h2 id="并发特性"><a href="#并发特性" class="headerlink" title="并发特性"></a>并发特性</h2><p>随着 CPU、内存、I/O设备都在不断迭代，不断朝着更快的方向努力的同时，有一个核心矛盾一直存在，那就是这三者的速度差异。为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统和编译程序都做出了贡献，具体体现为：</p>
<ul>
<li>CPU 增加了缓存，以均衡与内存的速度差异。</li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O设备的速度差异。</li>
<li>编译程序优化指令执行次序</li>
</ul>
<p><strong>总结起来就是：</strong>硬件增加缓存、软件增加线程、编译程序优化指令顺序。</p>
<p>以上优化带来好处的同时，也给并发程序埋下了祸根。带来的问题可以总结为：</p>
<ul>
<li>缓存导致可见性问题 </li>
<li>线程切换导致原子性问题 </li>
<li>指令优化导致有序性问题</li>
</ul>
<p>下面我们对以上问题详细说明。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>。</p>
<p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。</p>
<p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存，它们是无法直接通信的。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一个或者多个操作在 CPU 执行的过程中不被中断的特性称为<strong>原子性</strong>。</p>
<p>Java 并发程序都是基于多线程的，自然会涉及到线程切换，切换的时机大多数是在时间片结束的时候。操作系统做任务切换，可以发生在任何一条<strong>CPU 指令</strong>执行完，注意是 CPU 指令而非高级语言中的一条语句，因为高级语言中的一条语句可能包含多条 CPU 指令。<strong>也就是说，CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言级别。因此，很多时候需要我们自己在高级语言层面保证操作的原子性</strong>。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性指的是程序按照代码的先后顺序执行。但编译器、处理器为了优化性能有时会改变程序执行的次序，而这也是导致问题的原因。</p>
<p>缓存、线程、编译优化的目的都是提高程序性能的，但是技术在解决一个问题的同时，可能会带来另外一个问题，所以在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避。</p>
<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>Java 的内存模型（JMM）本质上是一种编程语言规范，屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 Java 程序员呈现了一个一致的内存模型。不同点在于，JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型。JMM 通过定义多项规则对编译器和处理器进行限制，主要围绕原子性、有序性、可见性展开，具体来说包括 <strong>volatitle、synchronized 和 fianl 这三个关键字，以及系列 happens-before 原则</strong>。</p>
<p><strong>注意：</strong>JVM 内存模型和 Java 内存模型是完全不同的两个东西。JVM内存模型是一种内存逻辑划分，便于JVM 管理内存；JMM内存模型是对计算机硬件（处理器模型）的统一抽象，用来屏蔽差异。</p>
<h2 id="细化规范"><a href="#细化规范" class="headerlink" title="细化规范"></a>细化规范</h2><p>JMM 描述了程序的可能行为，程序执行产生的结果都可以由内存模型预测，它决定了在程序的每个点上可以读取什么值（读写是相互的，也就是写了后，读必须要读取到，这就要求写必须刷新到主内存）。既然 JMM 是一种规范，就需要给 JVM 开发者和厂商实现，需要细化规范。</p>
<h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>可以在线程之间共享的内存称为共享内存或堆内存。所有实例字段，静态字段和数组元素都存储在堆内存中。Java 内存模型的抽象示意图如下：</p>
<p><img src="/posts/11b0627b/jmm-model.jpg" alt></p>
<p>JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本，线程对变量的所有操作都必须在本地内存中进行，而不能直接操作主内存中的变量。注意，本地内存是 JMM 的一个抽象概念，并不真实存在。</p>
<p>如果线程 A 与线程 B 之间要通信的话，必须经历以下2个步骤：</p>
<ul>
<li>线程 A 把本地内存中更新过的共享变量刷新到主内存中去。</li>
<li>线程 B 到主内存中去读取线程 A 之前已更新过的共享变量</li>
</ul>
<p>关于主内存与本地内存之间的具体交互，即一个变量如何从主内存拷贝到本地内存、如何从本地内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成。  </p>
<blockquote>
<ol>
<li><strong>lock</strong>：作用于主内存，把变量标识为线程独占状态</li>
<li><strong>unlock</strong>：作用于主内存，解除独占状态</li>
<li><strong>read</strong>：作用主内存，把一个变量的值从主内存传输到线程的本地内存</li>
<li><strong>load</strong>：作用于本地内存，把 read 操作传过来的变量值放入本地内存的变量副本中</li>
<li><strong>use</strong>：作用本地内存，把本地内存当中的一个变量值传给执行引擎</li>
<li><strong>assign</strong>：作用本地内存，把一个从执行引擎接收到的值赋值给本地内存的变量</li>
<li><strong>store</strong>：作用于本地内存的变量，把本地内存的一个变量的值传送到主内存中</li>
<li><strong>write</strong>：作用于主内存的变量，把 store 操作传来的变量的值放入主内存的变量中</li>
</ol>
</blockquote>
<p>如果要把一个变量从主内存中复制到本地内存中，就需要按顺序地执行read和load操作， 如果把变量从本地内存中同步到主内存中，就需要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</p>
<p>如前所述，Java 内存模型和硬件内存架构是不同的。不管是本地内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一 个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。具体如下图所示：</p>
<p><img src="/posts/11b0627b/jmm-cpu-memory-relation.jpg" alt></p>
<p>当对象和变量可以存储在计算机中各种不同的内存区域时，可能会出现某些问题，两个主要问题是：</p>
<ul>
<li>线程更新（写入）共享变量的可见性</li>
<li>读取、检查和写入共享变量时的竞争条件</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/11b0627b/" title="并发 - JMM" target="_blank" rel="external">https://gentryhuang.com/posts/11b0627b/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    
    <li class="next">
      <a href="/posts/ae5dbc38/" title="网络通信 - Reactor模型"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2021 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>