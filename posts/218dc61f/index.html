<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>并发 - ConcurrentHashMap | gentryhuang的博客</title>
  <meta name="description" content="概述HashMap 不是线程安全的，在高并发环境下可能会出现系列问题，如链表成环（JDK1.7)、数据覆盖（JDK1.8)。想要避免 HashMap 的线程安全问题有很多办法，比如改用 HashTable 或者使用 Collections.synchronizedMap() 将 HashMap 包装成线程安全的。虽然这两种方法能解决线程安全问题，但是性能成了一个问题，无论读写操作都会给整个集合加锁">
<meta property="og:type" content="article">
<meta property="og:title" content="并发 - ConcurrentHashMap">
<meta property="og:url" content="https://gentryhuang.com/posts/218dc61f/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="概述HashMap 不是线程安全的，在高并发环境下可能会出现系列问题，如链表成环（JDK1.7)、数据覆盖（JDK1.8)。想要避免 HashMap 的线程安全问题有很多办法，比如改用 HashTable 或者使用 Collections.synchronizedMap() 将 HashMap 包装成线程安全的。虽然这两种方法能解决线程安全问题，但是性能成了一个问题，无论读写操作都会给整个集合加锁">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-1.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-2.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-3.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-4.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-5.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-6.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-7.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-8.png">
<meta property="article:published_time" content="2022-05-14T02:30:35.000Z">
<meta property="article:modified_time" content="2022-06-02T01:42:58.251Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="ConcurrentHashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-1.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/218dc61f/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.png" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.5px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.75px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.13px;">I/O</a> <a href="/tags/JMM/" style="font-size: 13px;">JMM</a> <a href="/tags/JUC/" style="font-size: 13.75px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.25px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.13px;">Lock</a> <a href="/tags/LongAdder/" style="font-size: 13px;">LongAdder</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.25px;">Protocol</a> <a href="/tags/Queue/" style="font-size: 13.38px;">Queue</a> <a href="/tags/RPC/" style="font-size: 13.63px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13.38px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.13px;">Redis数据结构</a> <a href="/tags/SCAN/" style="font-size: 13px;">SCAN</a> <a href="/tags/SPI/" style="font-size: 13.25px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.25px;">Spring</a> <a href="/tags/Thread/" style="font-size: 13.13px;">Thread</a> <a href="/tags/Zookeeper/" style="font-size: 13.13px;">Zookeeper</a> <a href="/tags/cahce/" style="font-size: 13px;">cahce</a> <a href="/tags/false-sharing/" style="font-size: 13px;">false sharing</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 13px;">分布式锁</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.88px;">设计模式</a> <a href="/tags/%E9%99%90%E6%B5%81/" style="font-size: 13px;">限流</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/282602b0/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/282602b0/" class="title">并发 - LongAdder</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-30T02:25:18.000Z" itemprop="datePublished">2022-05-30</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/218dc61f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/218dc61f/" class="title">并发 - ConcurrentHashMap</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-14T02:30:35.000Z" itemprop="datePublished">2022-05-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/9012be3f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/9012be3f/" class="title">并发 - ScheduledThreadPoolExecutor</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-02T01:55:06.000Z" itemprop="datePublished">2022-05-02</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/a16a077e/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/a16a077e/" class="title">并发 - FutureTask</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-22T02:07:06.000Z" itemprop="datePublished">2022-04-22</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/3c450cc6/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/posts/3c450cc6/" class="title">MySQL - 乐观锁和悲观锁</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-10T02:46:59.000Z" itemprop="datePublished">2022-04-10</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-7"><span class="toc-number">2.</span> <span class="toc-text">JDK1.7</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#get-方法"><span class="toc-number">2.1.</span> <span class="toc-text">get 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put-方法"><span class="toc-number">2.2.</span> <span class="toc-text">put 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#size"><span class="toc-number">2.3.</span> <span class="toc-text">size</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-8"><span class="toc-number">3.</span> <span class="toc-text">JDK1.8</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析"><span class="toc-number">3.1.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">3.1.1.</span> <span class="toc-text">属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeCtl"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">sizeCtl</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法"><span class="toc-number">3.1.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put-新增元素"><span class="toc-number">3.1.3.</span> <span class="toc-text">put() - 新增元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initTable-初始化数组"><span class="toc-number">3.1.4.</span> <span class="toc-text">initTable() - 初始化数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addCount-计数并判断扩容"><span class="toc-number">3.1.5.</span> <span class="toc-text">addCount() - 计数并判断扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#记数"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">记数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#初始化计数桶数组"><span class="toc-number">3.1.5.1.1.</span> <span class="toc-text">初始化计数桶数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#扩容计数桶"><span class="toc-number">3.1.5.1.2.</span> <span class="toc-text">扩容计数桶</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#统计元素个数"><span class="toc-number">3.1.5.1.3.</span> <span class="toc-text">统计元素个数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#计数小结"><span class="toc-number">3.1.5.1.4.</span> <span class="toc-text">计数小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#判断扩容"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">判断扩容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tryPresize-扩容或迁移元素"><span class="toc-number">3.1.6.</span> <span class="toc-text">tryPresize() - 扩容或迁移元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transfer-扩容或迁移元素"><span class="toc-number">3.1.7.</span> <span class="toc-text">transfer() - 扩容或迁移元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#helpTransfer-辅助数据迁移"><span class="toc-number">3.1.8.</span> <span class="toc-text">helpTransfer() - 辅助数据迁移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove-删除元素"><span class="toc-number">3.1.9.</span> <span class="toc-text">remove() - 删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-获取元素"><span class="toc-number">3.1.10.</span> <span class="toc-text">get() - 获取元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#浅谈Redis-rehash"><span class="toc-number">3.1.10.1.</span> <span class="toc-text">浅谈Redis rehash</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK1-7-与-JDK1-8的区别"><span class="toc-number">3.2.</span> <span class="toc-text">JDK1.7 与 JDK1.8的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一致性问题"><span class="toc-number">3.3.</span> <span class="toc-text">一致性问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结-1"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#思考"><span class="toc-number">5.</span> <span class="toc-text">思考</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-java-base/集合-ConcurrentHashMap" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      并发 - ConcurrentHashMap
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/218dc61f/" class="article-date">
	  <time datetime="2022-05-14T02:30:35.000Z" itemprop="datePublished">2022-05-14</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/JDK/">JDK</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/ConcurrentHashMap/" rel="tag">ConcurrentHashMap</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/218dc61f/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 17.8k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 71(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HashMap 不是线程安全的，在高并发环境下可能会出现系列问题，如链表成环（JDK1.7)、数据覆盖（JDK1.8)。想要避免 HashMap 的线程安全问题有很多办法，比如改用 HashTable 或者使用 Collections.synchronizedMap() 将 HashMap 包装成线程安全的。虽然这两种方法能解决线程安全问题，但是性能成了一个问题，无论读写操作都会给整个集合加锁，导致同一时间的其他操作阻塞。这个时候 ConcurrentHashMap 就应运而生了，它是基于 HashMap 实现的线程安全的集合。</p>
<p>考虑到 ConcurrentHashMap 在 JDK 不同的版本中实现差异较大，我们先对 JDK 1.7 版本进行简单介绍，然后重点介绍 JDK 1.8 版本中的实现。</p>
<h1 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h1><p>JDK 1.7 对 ConcurrentHashMap 的实现关键是：<strong>HashMap + Segment</strong>。哈希项的结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希桶数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashEntry 的成员变量 value 和 next 是被关键字 volatile 修饰的，也就是说所有线程都可以及时检查到其他线程对这两个变量的改变，因此可以在不加锁的情况下读取到这两个引用的最新值。</p>
<p>Segment 通过继承 ReentrantLock 来进行加锁，通过每次锁住一个 Segment 来降低锁的粒度并保证了每个 Segment 内操作的线程安全性，从而实现全局线程安全。Segment 本身就相当于一个 HashMap 对象，每个 Segment 包含一个 HashEntry 数组。整个 ConcurrentHashMap 的结构如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-1.png" alt></p>
<p>可以看到，ConcurrentHashMap 是一个二级哈希表，桶数组是 Segment 数组，数组中的每个元素对应一个 HashMap 。</p>
<p>ConcurrentHashMap 设计成二级哈希表的目的就是采用<strong>锁分段技术</strong>提高并发度，每个 Segment 各自持有一把锁，Segment 之间互不影响。在保证线程安全的同时降低了锁的粒度，使并发操作效率更高。下面看看 ConcurrentHashMap 并发读写的几种情况：</p>
<ul>
<li>不同 Segment 的并发写入<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-2.png" alt><br> 不同 Segment 的写入是可以并发执行的，因为每个 Segment 持有的锁不是同一个。</li>
<li>同一个 Segment 的并发读写<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-3.png" alt><br> 同一个 Segment 的读写可以并发执行。</li>
<li>同一个 Segment 的并发写入<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-4.png" alt><br> Segment 的写入是需要上锁的，因此对同一个 Segment 的并发写入会被阻塞。</li>
</ul>
<p>了解了 ConcurrentHashMap 并发读写的情况后，下面我们对常见的几个方法的执行流程简单说明。</p>
<h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><ol>
<li>对输入的 key 做 hash 运算得到 hash 值；</li>
<li>通过 hash 值对 Segment 数组定位对应的 Segment 对象；</li>
<li>再次通过 hash 值定位到 Segment 中数组的具体桶；</li>
</ol>
<p>可以看到，计算 key 的 hash 值后，<strong>要进行两次定位</strong>，第一次为了定位这个 key 是属于哪个 Segment；第二次为了定位这个 key 属于 Segment 中数组哪个桶；</p>
<h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><ol>
<li>对输入的 key 做 hash 运算得到 hash 值；</li>
<li>通过 hash 值对 Segment 数组定位对应的 Segment 对象；</li>
<li>获取 Segment 对应的可重入锁；</li>
<li>再次通过 hash 值定位到 Segment 中数组的具体桶；</li>
<li>插入或覆盖 HashEntry 对象；</li>
<li>释放可重入锁；</li>
</ol>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>size 方法是统计 ConcurrentHashMap 中的元素数量，需要把各个 Segment 内的元素数量汇总起来。</p>
<ol>
<li>遍历所有的 Segment；</li>
<li>把 Segment 的元素数量累加起来；</li>
<li>把 Segment 的修改次数累加起来；</li>
<li>判断所有 Segment 的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。</li>
<li>如果尝试次数超过阈值，则对每一个 Segment 加锁，再重新统计。</li>
<li>判断所有 Segment 的总修改次数是否大于上一次的总修改次数，由于已经加锁，次数一定和上次相等。</li>
<li>依次释放 Segment 锁，统计结束；</li>
</ol>
<p><strong>说明：</strong>这里的 size 方法的思想有点类似乐观锁和悲观锁。为了尽量不锁住 Segment ，先乐观地统计元素数量，当尝试一定次数后仍然失败才会加锁统计。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ConcurrentHashMap 的结构图如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-5.png" alt></p>
<br>

<ul>
<li>ConcurrentHashMap 是线程安全的，其读取不需要加锁，通过引入 Segment 将写锁粒度缩小，每个 Segment 中的桶数组就相当于 HashTable；</li>
<li>由于引入了 Segment ，在读取和写入的时候需要做两次映射定位，第一次定位 Segment，第二次定位 Segment 中数组的桶；</li>
<li>到了第二次定位桶的过程，就和 HashMap 是一致的了；</li>
</ul>
<h1 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h1><p>相比 JDK 1.7 使用的 Segment 保证线程安全，JDK 1.8 进行了重写式优化，<strong>取消了 Segment 的设计，取而代之的是通过 CAS 操作和 synchronized 关键字来实现线程安全</strong>。当然，排除线程安全方面，其它的设计和 HashMap 很类似。</p>
<p>ConcurrentHashMap 主要 UML 类图如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-6.png" alt></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>为什么要研究 ConcurrentHashMap 源码？我始终认为知其然知其所以然，才能算得上真正了解一个事物。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Constants -------------- */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量，当两个构造函数中任何一个带参数的函数隐式指定较大的值时使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认容量大小 16，大小必须是 2^N</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶的树化阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶的链表还原阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小树化容量阈值：使用红黑树时最小的表容量。当 HashMap 中的容量 &gt;= 该值时，才允许树形化链表即将链表转成红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sizeCtl 中用于生成标记的位数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以帮助调整大小的最大线程数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 sizeCtl 中记录大小标记的位移，为 16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 节点中的 hash </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span>; <span class="comment">//  ForwardingNode 类型节点的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span>; <span class="comment">// 红黑树的根节点的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// 普通节点哈希的可用位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CPU 的数量，可以限制参与并发扩容的线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储数据的 Node 数组，长度是 2 的幂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用 volatile 来保证每次获取到的都是最新的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一个要使用的表；仅在调整大小时为非空，是个临时数组；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K, V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本计数器值，主要在没有争用时使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个含义，要重点理解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整大小时要拆分的下一个表索引（加一个）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整大小和/或创建 CounterCell 时使用自旋锁（通过 CAS 锁定）。</span></span><br><span class="line"><span class="comment"> * 0：不 busy  1：busy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数单元桶数组。当非空时，大小是 2 的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap 中的属性比较多，属于 HashMap 中的属性就不再说明，下面对核心属性进行说明。</p>
<p><strong>MOVED:</strong> ForwardingNode 类型节点的 hash 值，在数组扩容的过程中如果旧数组的某个桶元素为空或者迁移完毕就会使用 ForwardingNode 对象填充，作为一个标记；<br><strong>baseCount:</strong> 记录元素个数的基本计数器，主要在没有竞争的情况下使用；<br><strong>counterCells:</strong> 元素个数的计数单元桶，在并发环境下将元素个数的记录分摊到不同的计数器上，缓解单个计数器的竞争；<br><strong>cellsBusy:</strong> 调整或创建计数单元 CounterCell 时的标记，表示某个线程竞争成功；</p>
<h4 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h4><p>sizeCtl 这个属性非常重要，对理解整个 ConcurrentHashMap 至关重要。</p>
<ol>
<li><strong>正常情况下</strong>，sizeCtl 存储的是扩容阈值，固定为数组容量的 0.75 倍，默认值为 0；</li>
<li><strong>初始化数组时</strong>，sizeCtl 会被设置为 -1，表示某个线程抢到了初始化数组的资格，没有抢到资格的线程自旋以等待数组初始化完成。数组初始化完成后，会把 sizeCtl 设置为扩容的阈值；</li>
<li><strong>数组达到扩容条件时</strong>，sizeCtl 不再存储扩容阈值，而是用来标识正处于扩容过程。在扩容前，会将 sizeCtl 设置为一个负数，在扩容完成后会重新计算扩容阈值并赋值到 sizeCtl 。</li>
</ol>
<p>其中，扩容过程中 sizeCtl 为负数的情况不太好理解，下面我们详细说说这种情况下的 sizeCtl 为负数时的组成。假设场景为某时刻数组的容量为 16 ，此时达到了扩容的条件。</p>
<p><strong>第一步：</strong>扩容前先标识数组处于扩容的过程，即设置 sizeCtl 的值；</p>
<p>线程通过执行 <code>U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</code> 代码片段设置 sizeCtl 的值，因为此时数组容量为 16，针对该容量扩容的标识值 rs=32795（计算出来的），左移 16 位后对应的二进制数为：<code>1000 0000 0001 1011 0000 0000 0000 0000</code> 。整个结果具体组成如下图：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-7.png" alt></p>
<p><strong>第二步：</strong>一旦扩容开始了，执行写操作（新增、删除）的线程<strong>发现</strong>集合处于扩容过程，此时就会尝试加入到迁移元素的流程中，加快扩容进度；其中“发现”的情况如下：</p>
<ul>
<li>线程在新增元素后，如果判断达到扩容条件，那么会进入到扩容流程，如果此时已经有线程在扩容了，那么当前线程会<strong>尝试</strong>加入到迁移元素的流程；</li>
<li>线程在定位数组桶时，发现桶中元素类型是 ForwardingNode ，那么会先<strong>尝试</strong>加入到迁移元素流程，完成迁移后再执行写操作；</li>
</ul>
<p>注意，上面我特意加粗了<strong>尝试</strong>这两个字，也就是说不一定真的参与了一起迁移元素的流程，因为参与迁移元素的线程数是有限制的，下文会从源码层面进行解释。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认初始表大小 (16) 创建一个新的空映射。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with an initial table size</span></span><br><span class="line"><span class="comment"> * accommodating the specified number of elements without the need</span></span><br><span class="line"><span class="comment"> * to dynamically resize.</span></span><br><span class="line"><span class="comment"> * 创建一个新的空映射，其初始表大小可容纳指定数量的元素，无需动态调整大小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity The implementation performs internal</span></span><br><span class="line"><span class="comment"> *                        sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment"> *                                  elements is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入容量大小计算容量，返回大于 initialCapacity 且最近的2的整数次幂的数</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">            MAXIMUM_CAPACITY :</span><br><span class="line">            tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容量大小赋值给 sizeCtl，初始化后 sizeCtl 作为扩容阈值</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化 ConcurrentHashMap 时底层数组是没有进行初始化的，会等到第一次添加元素时才会初始化。此外，相比 HashMap 控制数组容量及填充度分别使用了 <code>threshold</code> 和 <code>loadFactor</code>，ConcurrentHashMap 使用了 sizeCtl 属性来控制，具体如下：</p>
<ul>
<li>非扩容的情况下，sizeCtl 表示的语意同 threshold；</li>
<li>在计算扩容阈值时，使用了固定的负载因子 0.75；</li>
</ul>
<p>这个在后续的源码中会有体现。</p>
<h3 id="put-新增元素"><a href="#put-新增元素" class="headerlink" title="put() - 新增元素"></a>put() - 新增元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key 和 value，都不允许为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认覆盖式</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用 put 方法默认式覆盖式新增元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整体流程和 HashMap 类似</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key          key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value        value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 是否覆盖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key 、value 都不允许为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于记录要插入的元素所在桶的元素个数，主要用于判断是否将链表转为红黑树的情况</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋，结合 CAS 使用（如果 CAS 失败，则会重新取整个桶进行下面的流程），直到 put 操作完成后退出循环</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = table; ; ) &#123;</span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  1 如果数组为空，则进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组</span></span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 定位到 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果数组该位置没有节点，则使用一次 CAS 操作将这个新值放入其中即可。</span></span><br><span class="line">            <span class="comment">// 如果 CAS 失败，说明是并发操作，进入到下一个循环重试；如果 CAS 成功，则 break ，流程结束</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="comment">// 插入成功，退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果 hash 值对应的位置有节点，且取的第一个节点的 hash 值为 MOVED ，说明当前数组处于扩容过程，则当前线程尝试帮忙一起迁移元素，</span></span><br><span class="line">        <span class="comment">// 然后再执行插入元素操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 辅助数据迁移</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 非以上三种情况，也就是当前定位的桶不为空，且不在迁移元素，那么锁住这个桶（以桶的第一个元素作为锁对象-分段锁）</span></span><br><span class="line">            <span class="comment">// 要插入的元素在该桶，则替换值（onlyIfAbsent=false）；不在该桶，则插入到链表结尾或插入树中；</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.1 获取 synchronized 的锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次检测第一个元素是否有变化，如果有变化则进入下一次循环，从头来过</span></span><br><span class="line">                <span class="comment">// Unsafe 类的 volatile 式查看值，保证获取到的值都是最新的</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果第一个元素的hash值大于等于0（说明不是在迁移，也不是树），那就是桶中的元素使用的是链表方式存储</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 记录链表的元素个数</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遍历链表，尾节点插入数据</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = f; ; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了相同的 key ，判断是否要进行值覆盖，然后也就可以 break 了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                            (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 找到了相同 key 的元素，根据情况进行覆盖并退出循环</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 到了链表的末尾还没发现相同 key 的元素，那么就将这个新值放到链表的最后，尾插法</span></span><br><span class="line">                            Node&lt;K, V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key,</span><br><span class="line">                                        value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 树结构</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K, V&gt; p;</span><br><span class="line">                        <span class="comment">// 记录树中元素个数为 2「注意，树的情况没有进行累加」</span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插入方法插入元素，如果成功则返回 null，否则返回找到的节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key,</span><br><span class="line">                                value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 找到了相同 key 的元素，根据情况进行覆盖并退出循环</span></span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 binCount不为0，说明成功插入了元素或者寻找到了元素</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果链表元素个数 &gt;= 8 ，那么尝试进行链表树化「只有数组容量 &gt;= 64 时才会真正进行树化，否则优先扩容」</span></span><br><span class="line">                <span class="comment">// 因为上面把元素插入到树中时，binCount只赋值了2，并没有计算整个树中元素的个数，所以不会重复树化</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 树化</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果要插入的元素已经存在，那么把旧值返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 退出外层大循环，流程结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是插入元素的情况，则：累加元素个数 &amp; 判断扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功插入元素返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述新增元素的源码中可以看到，如果将并发控制的逻辑剔除，剩下的逻辑和 HashMap 的 put 方法基本类似。主干流程如下：</p>
<ol>
<li>不允许 key 或 value 为 null；</li>
<li>如果桶数组未初始化，执行初始化流程，然后再尝试添加元素；</li>
<li>如果待插入的元素所在的桶为空，则使用 CAS 尝试将元素放到该桶中；</li>
<li>如果数组正处于扩容过程，那么当前线程尝试一起加入到扩容的过程中；</li>
<li>如果待插入的元素所在的桶不为空，且没有迁移元素，那么锁住这个桶，锁粒度就是桶元素对象；<ul>
<li>如果当前桶中元素以链表方式存储，则在链表中寻找该元素或者<strong>尾插入元素</strong>；</li>
<li>如果当前桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素；</li>
</ul>
</li>
<li>针对链表的情况判断是否需要进行树化；</li>
<li>如果要插入的元素（元素 key）存在，则返回旧值，此时不需要累加元素个数以及判断容量情况；</li>
<li>如果要插入的元素（元素 key）不存在，则累加元素个数，并检查是否需要扩容；</li>
</ol>
<p><strong>为什么不允许 key 和 value 为 null ?</strong></p>
<p>我们知道 HashMap 是支持 key 和 value 为 null 的，但是 ConcurrentHashMap 不允许。因为在<strong>并发编程中</strong> null 容易引起歧义，比如在 ConcurrentHashMap 中通过调用 get 方法获取的结果为 null，那么我们无法确认是因为这个 key 对应的 value 本身放的就是 null 还是这个 key 压根就不存在，如果在非并发编程中可以通过类似 <code>containsKey</code> 判断 key 的存在情况，但是在并发编程中无法保证两个方法之间没有其它线程操作这个 key 值，所以直接不允许为 null 的情况。</p>
<p>了解了添加元素的主干逻辑后，<strong>下面我们对上述方法中针对并发控制的关键点进行说明</strong>：</p>
<ul>
<li>使用<strong>自旋结合CAS的方式</strong>完成新增元素操作；</li>
<li>使用<strong>Unsafe 类的 volatile 式的获取方法查看元素，保证每次获取到的元素都是最新的</strong>。注意，虽然桶数组 table 使用了 volatile 修饰，但也只能保证其引用的可见性，并不能确保其数组中的元素是否是最新的，所以通过 Unsafe 类的 volatile 式获取到最新的元素；</li>
<li>尝试协同扩容流程优先，新增元素流程靠后；</li>
<li>使用 <code>synchronized</code> 实现分段锁，完成新增元素的流程。注意，这里将 key 映射的桶元素作为锁对象，达到缩小锁范围的目的。在 hash 不冲突的情况下，可同时支持 n 个线程同时 put 操作，n 为桶数组的大小。</li>
</ul>
<h3 id="initTable-初始化数组"><a href="#initTable-初始化数组" class="headerlink" title="initTable() - 初始化数组"></a>initTable() - 初始化数组</h3><p>初始化数组流程是在新增元素时进行的，通过对新增元素的源码分析后我们知道，初始化数组流程是不受锁的保护的，那么该方法是如何处理并发问题的呢？下面我们一起来看看源码是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K, V&gt;[] tab;</span><br><span class="line">       <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 每次循环都获取最新的 Node 数组引用</span></span><br><span class="line">       <span class="comment">// 初始化数组时，sizeCtl 为数组容量大小，默认为 0；如果 sizeClt &gt; 0 ，那使用的是带有初始化容量的构造方法</span></span><br><span class="line">       <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 如果 sizeCtl &lt; 0 ，说明其它线程正在进行初始化或扩容，那么就让出 CPU，从运行状态回到就绪状态</span></span><br><span class="line">           <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">               Thread.yield(); <span class="comment">// lost initialization race; just spin 初始化失败，只是旋转</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了初始化数组的资格，当前线程进入初始化，成功后退出循环。</span></span><br><span class="line">               <span class="comment">// 如果原子更新失败则说明有其它线程先一步进入初始化了，则进入下一次循环，如果下一次循环时还没初始化完毕，则sizeCtl&lt;0进入上面if的逻辑让出CPU，如果初始化完毕退出循环；</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 再次检查table是否为空</span></span><br><span class="line">                   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 如果 sc 为 0，则使用 DEFAULT_CAPACITY 默认初始容量是 16</span></span><br><span class="line">                       <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 创建数组，长度为 16 或初始化时提供的长度（也是 2^N)</span></span><br><span class="line">                       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                       Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node&lt;?, ?&gt;[n];</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 将创建的数组赋值给 table</span></span><br><span class="line">                       table = tab = nt;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 设置 sc 为数组长度的 0.75 倍</span></span><br><span class="line">                       <span class="comment">// n - (n &gt;&gt;&gt; 2) = n - n/4 = 0.75 * n</span></span><br><span class="line">                       sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">// 由于这里只会有一个线程在执行，直接赋值即可，没有线程安全问题。把sc赋值给sizeCtl，这时存储的是扩容阈值</span></span><br><span class="line">                   sizeCtl = sc;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>初始化数组的主要过程如下：</p>
<ol>
<li>使用 CAS 设置 sizeCtl 为 -1 ，控制只有一个线程初始化桶数组，CAS 失败的线程会等待桶数组初始化完毕；</li>
<li>sizeCtl 在初始化后存储的是桶数组的扩容阈值，其中扩容阈值的计算是固定的，大小为<strong>桶数组大小的 0.75 倍</strong>。这里的负载因子和扩容阈值相当于都是固定了，这也正是没有使用 threshold 和 loadFactor 属性而是使用 sizeCtl 控制数组的原因。</li>
</ol>
<p>可见，就算有多个线程同时进行 put 操作，在初始化数组时使用了乐观锁 CAS 操作来决定哪个线程有资格进行初始化，其它线程只能等待数组初始化完成。处理并发点如下：</p>
<ul>
<li>桶数组 table 使用了 volatile 修饰，保证获取到的都是最新的值；</li>
<li>数组控制 sizeCtl 属性使用了 volatile 修饰，保证线程间的可见性；</li>
<li>使用 CAS 操作保证设置 sizeCtl 标记的原子性，只有一个线程能设置成功，没有设置成功的线程，等待数组初始化完成即可；</li>
</ul>
<h3 id="addCount-计数并判断扩容"><a href="#addCount-计数并判断扩容" class="headerlink" title="addCount() - 计数并判断扩容"></a>addCount() - 计数并判断扩容</h3><p>每次添加元素后（注意，是添加不是覆盖），集合中的元素数需要加 1，然后判断是否达到扩容阈值，达到了需要进行扩容或协助迁移元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x     要累加的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> check 如果&lt;0，不检查调整大小；如果&lt;= 1，只检查是否无竞争；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*----------------------- 1、累加元素个数  ---------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里使用的思想和 LongAdder 类很类似。</span></span><br><span class="line">    CounterCell[] as;</span><br><span class="line">    <span class="keyword">long</span> b, s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计元素个数的操作</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">            !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 执行到这里，说明：</span></span><br><span class="line"><span class="comment">        1.counterCells被初始化完成了，不为null</span></span><br><span class="line"><span class="comment">        2.增加数量到 baseCount 失败了，存在线程竞争，接下来尝试增加到当前线程映射到的桶上</span></span><br><span class="line"><span class="comment">        3.先优先尝试把数量加到 baseCount 上，如果失败再加到对应的 CounterCell 上</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//标志是否存在竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在计数桶数组中随机选一个计数桶，然后使用CAS操作将此计数桶中的value+1</span></span><br><span class="line">        <span class="comment">// 1 先判断计数桶是否还没初始化，也就是 as==nul，进入语句</span></span><br><span class="line">        <span class="comment">// 2 判断计数桶长度是否为空或，若是进入语句块</span></span><br><span class="line">        <span class="comment">// 3 这里做了一个线程变量随机数，与上桶大小-1，若桶的这个位置为空，进入语句块</span></span><br><span class="line">        <span class="comment">// 4 到这里说明桶已经初始化了，且随机的这个位置不为空，尝试CAS操作使桶加1，失败进入语句块</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                        U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若CAS操作失败，证明有竞争，进入fullAddCount方法</span></span><br><span class="line">            <span class="comment">// 失败几次，那么就对counterCells进行扩容，以减少多个线程hash到同一个桶的概率</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算元素个数</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*------------------ 2、判断是否需要进行扩容 ----------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K, V&gt;[] tab, nt;</span><br><span class="line">        <span class="keyword">int</span> n, sc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果元素个数达到了扩容阈值，则进行扩容。</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>) (sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// rs 为要扩容容量为 n 的数组的一个标识，如数组容量 n=16，那 rs=32795</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// sc &lt; 0 说明有线程正在迁移</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  判断扩容是否已经完成了，如果完成则退出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扩容未完成，则当前线程加入迁移元素流程中，并把扩容线程数加 1</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不为负数，则为第一个扩容的线程，此时多了创建新数组的操作</span></span><br><span class="line">                <span class="comment">// sizeCtl 的高 16 位存储 rs 这个标识</span></span><br><span class="line">                <span class="comment">// sizeCtl 的低 16 位存储扩容线程数，刚开始为2，表示有一个线程正在迁移，如果为3，代表2个线程正在迁移以此类推…</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进入扩容并迁移元素的逻辑，传入 nextTab 为 null 就会触发创建新数组进而扩容</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新计算元素个数</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码中也可以看到，上述方法包含两部分的逻辑，一个是记录集合中元素个数，另一个是达到扩容阈值执行扩容逻辑。下面我们分别介绍。</p>
<h4 id="记数"><a href="#记数" class="headerlink" title="记数"></a>记数</h4><p>在 ConcurrentHashMap 中，快速统计元素个数是非常重要的，不仅使用方会关注集合中元素个数，而且集合内部需要根据元素个数来判断是否需要扩容。使用的思想和 LongAdder 类似，如下图：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-8.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶是由线程对应的，多个线程可以对应一个桶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前桶对应的元素数量，可见性保证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123;</span><br><span class="line">        value = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设计时，使用了<strong>分而治之</strong>的思想，除了基础的计数，将每一个计数都分散到各个 CounterCell 对象（桶）中，使竞争最小化。总的来说，ConcurrentHashMap 的大小分为两部分：</p>
<ul>
<li><strong>基础计数 baseCount:</strong> 在记录元素个数时优先 CAS 更新该属性，如果 CAS 失败才会采用分治桶计数的方式。即在线程竞争不大的时候，直接使用CAS操作baseCount值即可；</li>
<li><strong>分治桶计数 CounterCell[]:</strong> 若出现了CAS操作失败的情况，则证明此时有线程竞争了，计数方式转变为分而治之的桶计数方式，也就是线程映射到不同的 CounterCell；</li>
</ul>
<p><strong>注意：</strong>该类使用了 <code>@sun.misc.Contended</code> 注解，这个注解的作用是用来解决伪共享问题的，关于伪共享可参考 <a href="https://gentryhuang.com/posts/88d55383/">「伪共享」</a>。</p>
<p>了解了 ConcurrentHashMap 计数的思想后，下面看看源码是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*----------------------- 1、累加元素个数  ---------------------------*/</span></span><br><span class="line">      CounterCell[] as;</span><br><span class="line">      <span class="keyword">long</span> b, s;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 统计元素个数的操作</span></span><br><span class="line">      <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">              !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*------------- 执行到这里，说明：</span></span><br><span class="line"><span class="comment">          1.counterCells被初始化完成了，不为null</span></span><br><span class="line"><span class="comment">          2.增加数量到 baseCount 失败了，存在线程竞争，接下来尝试增加到当前线程映射到的桶上</span></span><br><span class="line"><span class="comment">          3.先优先尝试把数量加到 baseCount 上，如果失败再加到对应的 CounterCell 上</span></span><br><span class="line"><span class="comment">          ----------------*/</span></span><br><span class="line">          CounterCell a;</span><br><span class="line">          <span class="keyword">long</span> v;</span><br><span class="line">          <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//标志是否存在竞争</span></span><br><span class="line">          <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 在计数桶数组中根据当前线程选一个计数桶，然后使用CAS操作将此计数桶中的value+1</span></span><br><span class="line">          <span class="comment">// 1 先判断计数桶是否还没初始化，也就是 as==nul，进入语句</span></span><br><span class="line">          <span class="comment">// 2 判断计数桶长度是否为空或，若是进入语句块</span></span><br><span class="line">          <span class="comment">// 3 这里做了一个线程变量随机数，与上桶大小-1，若桶的这个位置为空，进入语句块</span></span><br><span class="line">          <span class="comment">// 4 到这里说明桶已经初始化了，且随机的这个位置不为空，尝试CAS操作使桶加1，失败进入语句块</span></span><br><span class="line">          <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                  (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                  !(uncontended =</span><br><span class="line">                          U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">//若CAS操作失败，证明有竞争，进入fullAddCount方法</span></span><br><span class="line">              <span class="comment">// 失败几次，那么就对counterCells进行扩容，以减少多个线程hash到同一个桶的概率</span></span><br><span class="line">              fullAddCount(x, uncontended);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 返回</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 计算元素个数</span></span><br><span class="line">          s = sumCount();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//... 省略判断扩容逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中也能看到，在计数时优先使用基础计数，有竞争的情况下会使用<strong>分而治之桶计数</strong>，对应的逻辑在 <code>fullAddCount</code> 方法中。这里有两种情况，一种是计数桶数组还没有初始化，另外一种是计数数组已经初始化过了，此外，<strong>如果计数桶数组存在，优先使用分而治之桶计数</strong>。下面我们从源码层面看这两种情况。</p>
<h5 id="初始化计数桶数组"><a href="#初始化计数桶数组" class="headerlink" title="初始化计数桶数组"></a>初始化计数桶数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See LongAdder version for explanation</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 线程对应的随机值</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">         ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">         h = ThreadLocalRandom.getProbe();</span><br><span class="line">         wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 自旋，更新元素个数</span></span><br><span class="line">     <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">         CounterCell[] as;</span><br><span class="line">         CounterCell a;</span><br><span class="line">         <span class="keyword">int</span> n;</span><br><span class="line">         <span class="keyword">long</span> v;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果计数单元桶!=null，证明已经初始化过，那么就针对当前线程映射一个计算单元并累加数量</span></span><br><span class="line">         <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//... 略</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// 进入此语句块进行计数桶的初始化</span></span><br><span class="line">             <span class="comment">// CAS设置cellsBusy=1，表示现在计数桶 busy 中，控制并发</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 若有线程同时初始化计数桶，由于CAS操作只有一个线程进入这里</span></span><br><span class="line">             <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">//再次确认计数桶为空</span></span><br><span class="line">                 <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                     <span class="comment">//初始化一个长度为2的计数桶</span></span><br><span class="line">                     CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                     <span class="comment">//h为当前线程相关的一个随机数，&amp; 1 代表，在 0、1中随机的一个</span></span><br><span class="line">                     <span class="comment">//也就是在0、1下标中随便选一个计数桶，x=1，放入1的值代表增加1个容量</span></span><br><span class="line">                     rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                     <span class="comment">//将初始化好的计数桶赋值给ConcurrentHashMap中的属性</span></span><br><span class="line">                     counterCells = rs;</span><br><span class="line">                     init = <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">//最后将busy标识设置为0，表示不busy了</span></span><br><span class="line">                 cellsBusy = <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 初始化计数桶数组后退出循环</span></span><br><span class="line">             <span class="keyword">if</span> (init)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//若有线程同时来初始化计数桶，则没有抢到busy资格的线程就CAS递增基础计数 baseCount</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">             <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当更新基础计数器 baseCount 失败后，获取到初始化资格的线程会初始化一个大小为 2 的计算桶数组。<strong>完成了计数桶数组的初始化后，在之后的计数都将会使用计算桶来计数</strong>。</p>
<p><strong>注意：</strong>这里同样使用了乐观锁 CAS 保证并发安全，如果在初始化时，有并发竞争，那么竞争失败的线程会 CAS 更新基础计数器 baseCount，尽可能提高并发度。</p>
<h5 id="扩容计数桶"><a href="#扩容计数桶" class="headerlink" title="扩容计数桶"></a>扩容计数桶</h5><p>从上面初始化计数桶数组中我们知道，计数桶数组的长度为 2，在并发大的时候竞争依然会很大，因此就需要计数桶数组的扩容，这个过程就对应 fullAddCount 方法的另一个分支。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程对应的随机值，用于对计数桶数组取模定位计算桶</span></span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋，更新元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        CounterCell[] as;</span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果计数单元桶!=null，证明已经初始化过，那么就针对当前线程映射一个计算桶并计算元素数</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从计数桶数组中定位当前线程映射的计数桶，若为null表示该桶为空，需要创建一个</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断计数单元 的 busy 状态（用于控制并发），为 0 表示不忙碌，即没有线程竞争</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 创建一个计数单元桶，初始值为传入的个数 x</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// CAS 操作 busy 为 1，标记计数桶处理中</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            CounterCell[] rs;</span><br><span class="line">                            <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="comment">// 再检查一次计数桶为null</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//将刚刚创建的计数桶赋值给对应位置</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">// 处理完成后，标记计数桶处理完成</span></span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果是创建计数桶的情况，直接退出循环即可</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*------------- 走到这里，说明当前线程映射的计数桶不为空 ----------------*/</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//走到这里代表计数桶不为null，尝试递增计数桶</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//若CAS操作失败了，到了这里，会先进入一次，然后再走一次刚刚的for循环</span></span><br><span class="line">                <span class="comment">//若是第二次for循环，collide=true，则不会走进去</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 走到这里，说明竞争较大，多个线程都映射到了一个计数桶，导致更新计数失败较多，那么就需要通过扩容计数桶数组来减小竞争 */</span></span><br><span class="line">                <span class="comment">//一个线程若进行了多次CAS操作计数桶失败，那么就需要进行计数桶扩容逻辑，完成扩容后重新计数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 确认计数桶还是同一个</span></span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//将长度扩大到2倍</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遍历旧计数桶，直接将旧计数桶拿过来填充</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 完成扩容后，标记计数桶处理完成</span></span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新计算当前线程的随机值，用于定位对应的计数桶</span></span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进入此语句块进行计数桶的初始化</span></span><br><span class="line">            <span class="comment">// CAS设置cellsBusy=1，表示现在计数桶 busy 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//... 省略</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//若有线程同时来初始化计数桶，则没有抢到busy资格的线程就先来CAS递增baseCount</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 CAS 操作计数桶失败多次之后，会先进行扩容计数桶数组流程，扩容完毕后再次尝试 CAS 操作映射的计数桶。一般扩容后再次 CAS 操作大都会成功，除非并发太大了。</p>
<h5 id="统计元素个数"><a href="#统计元素个数" class="headerlink" title="统计元素个数"></a>统计元素个数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算所有计数桶及 baseCount 的数量之和</span></span><br><span class="line">    CounterCell[] as = counterCells;</span><br><span class="line">    CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历 CounterCell ，不保证可见性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 使用 getObjectVolatile 方法保证可见性</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于集合中的元素存储在两个部分中，因此需要将两部分的数量累加起来。</p>
<p><strong>注意：</strong>上述统计元素个数的方法是<strong>弱一致性</strong>的，因为在遍历 CounterCell 数组时，不能保证其内部属性 value 的可见性。</p>
<h5 id="计数小结"><a href="#计数小结" class="headerlink" title="计数小结"></a>计数小结</h5><p>计数时优先利用 CAS 操作基础计数器 baseCount，在竞争不大时一般都能成功，此时性能没有啥大的损失；</p>
<p>若存在线程竞争基础计数器 baseCount，则初始化计数桶数组来分摊竞争。在初始化计数桶数组的过程中也存在竞争的话，通过 CAS 保证只有一个线程有资格进行初始化，没有抢到初始化资格的线程直接尝试 CAS 操作基础计数器的方式完成计数，没有完成计数的线程会进行自旋，<strong>尽可能最大化并发度</strong>。</p>
<p>如果已经存在计数桶数组，那么使用计数桶计数，采用分而治之的方式来计数。由于计数桶数组能同时提供计数的桶数量有限，如果还是存在频繁失败的情况，那么就对计数桶数组扩容，并发安全的处理同样使用 CAS 来保证，这样就可以支持同时更多线程并发计数了。其中，在为线程映射计数桶时，<strong>利用位运算和随机数以负载均衡的方式将线程计数请求接近均匀的分散到不同的计数桶中</strong>。</p>
<h4 id="判断扩容"><a href="#判断扩容" class="headerlink" title="判断扩容"></a>判断扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** because resizings are lagging additions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x     要累加的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> check 如果&lt;0，不检查调整大小；如果&lt;= 1，只检查是否无竞争；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*----------------------- 1、累加元素个数  ---------------------------*/</span></span><br><span class="line">    CounterCell[] as;</span><br><span class="line">    <span class="keyword">long</span> b, s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算元素个数</span></span><br><span class="line">    s = sumCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*------------------ 2、判断是否需要进行扩容 ----------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K, V&gt;[] tab, nt;</span><br><span class="line">        <span class="keyword">int</span> n, sc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果元素个数达到了扩容阈值，则进行扩容。</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>) (sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// rs 为要扩容容量为 n 的数组的一个标识，如数组容量 n=16，那 rs=32795</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// sc &lt; 0 说明有线程正在迁移</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  判断扩容是否已经完成了，如果完成则退出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扩容未完成，则当前线程加入迁移数据流程中，并把扩容线程数加 1</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不为负数，则为第一个迁移的线程，此时多了创建新数组的操作</span></span><br><span class="line">                <span class="comment">// sizeCtl 的高 16 位存储 rs 这个标识</span></span><br><span class="line">                <span class="comment">// sizeCtl 的低 16 位存储扩容线程数，刚开始为2，表示有一个线程正在迁移，如果为3，代表2个线程正在迁移以此类推…</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进入扩容并迁移元素的逻辑，传入 nextTab 为 null 就会触发创建新数组进而扩容</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新计算元素个数</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次添加元素后，集合中的元素数量加 1。紧接着会判断是否达到扩容阈值，达到的话则<strong>进行扩容或协助扩容</strong>。</p>
<p>如果达到扩容条件，那么会有一个线程 CAS 设置扩容标识位 sizeCtl 成功，此时 <strong>sizeCtl 的含义</strong>前文已经详细介绍。获取到扩容资格的线程会执行 <code>transfer(tab, null)</code> 方法进入扩容和迁移元素流程，启动扩容流程后进入上述方法的线程会感知到 <code>sizeCtl&lt;0</code> ，此时如果扩容还没有结束，也会加入到迁移元素的流程中，<strong>此时需要注意 sizeCtl 值的更新</strong>。 </p>
<p>下面对判断扩容终止条件进行说明，下文就不再重复说明：</p>
<ul>
<li><code>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</code> 反推的方式，说明容量为 n 的数组扩容完毕了，此时 rs 是一个新的数组计算出来的值；</li>
<li><code>sc == rs + 1</code> 表示最后一个扩容线程正在执行收尾工作，代表扩容即将结束；</li>
<li><code>sc == rs + MAX_RESIZERS</code> 表示当前已经达到最大扩容线程数，所以不能继续让线程加入扩容过程中；</li>
<li><code>(nt = nextTable) == null</code> 扩容完成后会把临时的 nextTable 重置为 null；</li>
<li><code>transferIndex &lt;= 0</code> 表示当前可供扩容的桶已经分配完毕，代表了扩容即将结束。<strong>注意</strong>，这个条件和线程能否参与迁移元素直接相关，每个线程最少分配 16 个桶的迁移任务，如果桶被分完了，那么该属性会被设置为 0；</li>
</ul>
<h3 id="tryPresize-扩容或迁移元素"><a href="#tryPresize-扩容或迁移元素" class="headerlink" title="tryPresize() - 扩容或迁移元素"></a>tryPresize() - 扩容或迁移元素</h3><p>除了执行 put 方法时检测到达到扩容阈值会扩容，检测链表是否要进行树化的时候也需要判断可否优先扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若数组长度小于64，则优先扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">      <span class="comment">// 尝试扩容</span></span><br><span class="line">      tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为红黑树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">        <span class="comment">//...转换为红黑树的操作</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>treeifyBin 方法会将链表转换为红黑树以增加查找效率，但在这之前会检查数组长度，若小于 64 则会优先做扩容操作。其中尝试扩容的方法和前文中的 <code>addCount</code> 方法的判断是否扩容分支逻辑基本类似，就不再重复说明，源代码注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取 2^n 值</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组没有在初始化或扩容</span></span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K, V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该分支用于初始化数组，主要用于 putAll 方法添加元素的场景</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node&lt;?, ?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无需进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// 扩容 table 的 epoch</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果处于扩容过程中</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K, V&gt;[] nt;</span><br><span class="line">                <span class="comment">// 扩容完毕了，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  CAS 将 sizeCtl 加 1 表示当前线程加入到扩容过程，然后执行 transfer 方法</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// CAS 设置 sizeCtl 成功后执行 transfer 方法进行扩容</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                    (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="transfer-扩容或迁移元素"><a href="#transfer-扩容或迁移元素" class="headerlink" title="transfer() - 扩容或迁移元素"></a>transfer() - 扩容或迁移元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab     旧数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nextTab 扩大2倍后的新数组，如果为空说明还没有创建新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K, V&gt;[] tab, Node&lt;K, V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录旧数组容量</span></span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据机器CPU核心数来计算，一条线程负责Node数组中多长的迁移量， stride 就是当前线程分到的迁移量</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*--------------------------------- 1、扩容 -------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextTab 为空，说明还没开始扩容，就创建一个新桶数组</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 新桶数组大小是原桶的 2 倍</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node&lt;?, ?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩容期间的新数组</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// 旧数组容量作为迁移下标</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*--------------------------------- 2、迁移元素 ---------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新数组大小</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个 ForwardingNode 类型的标记节点，其 hash 值为 MOVED，并把新桶数组存储在里面，这个对象作为旧数组某个桶迁移完毕的标志。</span></span><br><span class="line">    ForwardingNode&lt;K, V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K, V&gt;(nextTab);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前，依次对旧数组每个桶进行元素的迁移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>; ; ) &#123;</span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 确定当前线程要迁移哪些桶，比如线程1负责 1-16 ，那么对应的数组边界就是 0-15 ，然后从最后一位 15 开始迁移数据</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i为当前正在处理的Node数组下标，每次处理一个Node节点就会自减1</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过 CAS 操作确认当前线程迁移桶的边界</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                    (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                            nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                    nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 确定好下标后，就可以退出确定下标的循环了</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 对下标为 i 的桶进行处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果旧数组元素迁移完了</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果所有桶中的元素都迁移完成了，则替换旧桶数组，并设置下一次扩容阈值为新桶数组容量的 0.75 倍</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首次进入这里，通过 CAS 将 sizeCtl 减 1 表示将扩容的线程数 -1，表示当前线程扩容完成</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断扩容是否完成，也就是前面进入扩容前条件的反推，如果成立说明扩容完成，设置 finishing 为 true，此时也是参与扩容的最后一个线程执行到这了，</span></span><br><span class="line">                <span class="comment">// 否则，当前线程退出即可，因为它完成了自己的迁移任务</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 标记完成</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// i 重新赋值为 n，这样会再重新遍历一次桶数组，看看是不是都迁移完成了</span></span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果桶中无数据，直接在旧桶的 i 位置放入 ForwardingNode 表示该桶已迁移完</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果桶中第一个元素的 hash 值为 MOVED ，说明它是 ForwardingNode 节点，表示该桶已迁移完</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 迁移 i 位置桶中的元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 锁定该桶，并迁移元素</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 再次判断当前桶第一个元素是否有修改，也就是可能其它线程先一步迁移了元素</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K, V&gt; ln, hn;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 桶中第一个元素 fh &gt;= 0 说明桶是链表形式，这里与 HashMap 迁移算法基本一致，仅做了点优化</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K, V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 看看最后这几个元素归属于低位链表还是高位链表</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遍历链表，把hash&amp;n为0的放在低位链表中，不为0的放在高位链表中</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash;</span><br><span class="line">                            K pk = p.key;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K, V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K, V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 低位链表的位置不变 - CAS操作</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 高位链表的位置是原位置加n - CAS操作</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 使用 Unsafe 的 volatile 式标记该桶已迁移完成，即在该桶中放置 ForwardingNode 类型的元素以标记该桶迁移完成</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// advance为true，返回上面进行 --i 操作</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果桶中第一个元素是树节点，也是一样分化成两颗树，也是根据hash&amp;n为0放在低位树中，不为0放在高位树中， 基本同 HashMap</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K, V&gt; t = (TreeBin&lt;K, V&gt;) f;</span><br><span class="line">                        TreeNode&lt;K, V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K, V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K, V&gt; p = <span class="keyword">new</span> TreeNode&lt;K, V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果分化的树中元素个数小于等于6，则退化成链表</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K, V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K, V&gt;(hi) : t;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 低位树的位置不变 - CAS操作</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 高位树的位置是原位置加n - CAS操作</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 使用 Unsafe 的 volatile 式标记该桶已迁移，即在桶中放置 ForwardingNode 类型的元素，标记该桶迁移完成</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance为true，返回上面进行--i操作</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法实现了<strong>扩容和迁移元素</strong>的逻辑。下面我们先对关键步骤进行说明，然后再对并发处理进行分析。</p>
<ol>
<li>如果还没开始扩容，那么就先进行扩容，扩容后的数组大小是旧数组的 2 倍；</li>
<li>创建完新的数组后，就可以开始将旧数组中的元素迁移到新数组中了，迁移的方式是从后往前逐个桶迁移：<ul>
<li><strong>为当前执行的线程分配要迁移哪些桶</strong>，该线程会根据具体情况处理该桶；</li>
<li>判断是否已经迁移完毕，迁移完毕就用新数组替换旧数组，并根据新数组的容量以 0.75 计算扩容阈值并赋予 sizeCtl，扩容过程结束；</li>
<li>判断当前桶是否为空，为空就直接 CAS 填充 ForwardingNode 对象，表示该桶迁移完了；</li>
<li>判断当前桶是否为 ForwardingNode 对象（也就是元素的 hash 值为 MOVED） ，如果是则表示该桶已经迁移完了，跳过即可；</li>
<li>以上条件都不成立，那么就锁定该桶，然后将该桶元素迁移到新数组中，迁移方式基本同 HashMap 的迁移方式，主要区别是在迁移完成后，使用 ForwardingNode 对象打标记，表示该桶已经完成了迁移；</li>
</ul>
</li>
</ol>
<p>在扩容时，ConcurrentHashMap 支持<strong>并发扩容</strong>，在扩容过程中同时支持查找元素。<strong>这种无阻塞算法，将并发度大大的提高了</strong>。下面我们就对并发处理进行分析。</p>
<ol>
<li>临时的新数组 nextTable 使用 volatile 修饰，保证可见性；</li>
<li>使用 ForwardingNode 类型对象封装新数组，这个对象非常重要，<strong>不仅作为旧数组某个桶迁移完成的标记，还支持了扩容时的元素查找</strong>；</li>
<li>使用 CAS 为不同的线程分配待迁移的不同桶，实现并发扩容；</li>
<li>使用 <code>synchronized</code> 分段锁保证迁移桶元素时的安全；</li>
</ol>
<p><strong>注意：</strong>这里需要强调的是，ConcurrentHashMap 虽然支持并发扩容，但是参与扩容迁移元素的线程数是有限制的，每个线程最小要迁移 16 个桶，如果数组比较大的情况会使用多个线程，具体计算方法参见源码。没有参与迁移的线程、完成迁移任务的线程，在扩容完成之前都要自旋等待扩容完成，这个等待一般非常短的。</p>
<h3 id="helpTransfer-辅助数据迁移"><a href="#helpTransfer-辅助数据迁移" class="headerlink" title="helpTransfer() - 辅助数据迁移"></a>helpTransfer() - 辅助数据迁移</h3><p>假设在进行 put 或 remove 操作时正处于迁移的过程，映射到的桶已经被迁移了（Node.hash==MOVED)，此时该怎么办呢？<strong>ConcurrentHashMap 采用的是辅助扩容的方式，完成扩容后再执行对应的写操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 辅助扩容（迁移元素）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  f 所在桶元素迁移完了才去协助迁移其它桶元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 旧数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f   一般为 ForwardingNode 类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt;[] helpTransfer(Node&lt;K, V&gt;[] tab, Node&lt;K, V&gt; f) &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] nextTab;</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果桶数组不为空 &amp;&amp; 当前桶第一个元素 f 是 ForwardingNode 类型 &amp;&amp; 封装的 nextTab（新数组） 不为空，说明当前桶已经迁移完毕了，才去帮忙迁移其它桶的元素。</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab = ((ForwardingNode&lt;K, V&gt;) f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩容旧数组的标记位，类似 epoch 的概念</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sizeCtl &lt; 0 &amp;&amp; nextTable 不为空，说明集合正处于扩容过程</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 协助迁移元素前，再次判断扩容是否结束，如果结束直接返回，无需协助迁移</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩容线程数加 1 ，标示多一个线程参与协助迁移</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 当前线程帮忙迁移元素</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帮忙迁移完元素后，返回新数组</span></span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非扩容过程，返回旧数组</span></span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>辅助扩容是为了支持并发扩容的，当检测到定位的桶是 <strong><code>MOVED</code></strong> 状态时，那么当前线程会先辅助一起完成扩容，然后再继续执行写操作，这个逻辑一般需要自旋支持，因此我们可以看到前面介绍的 put 方法有一个自旋逻辑，在后面要介绍的 remove 方法也是这么做的。下面我们对辅助扩容方法中关键点进行分析：</p>
<ol>
<li>判断是否在进行扩容的条件是 <strong>sizeCtl &lt; 0 &amp;&amp; nextTable != null</strong>，这两个条件缺一不可。<code>sizeCtl &lt; 0</code> 的情况有两种，一种是在初始化数组时，通过 CAS 设置为 -1 才能拿到初始化资格；另一种是在扩容的时候，通过 CAS 设置为一个负数，高16位和低16位分别表示扩容旧数组的 epoch，参与扩容的线程数，这个前文已经详细说明。<code>nextTable</code> 只有在扩容期间才不会为 null，扩容完成后会重置为 null；</li>
<li>在迁移元素前，需要再次判断扩容是否结束，结束的情况下就直接返回即可；没有结束的话，就更新 <code>sizeCtl</code> 的值，也就是增加参与扩容线程数；</li>
<li>如果参与了协助扩容，就返回扩容完成后的新数组；如果没有参与扩容，那么还是返回旧数组；</li>
</ol>
<h3 id="remove-删除元素"><a href="#remove-删除元素" class="headerlink" title="remove() - 删除元素"></a>remove() - 删除元素</h3><p>删除元素和添加元素逻辑类似，都是先定位对应的桶，如果该桶被标记迁移了，那么就先辅助迁移元素，完成迁移后继续执行写操作；如果桶没有被标志迁移，那么就采用 <code>synchronized</code> 分段锁锁住整个桶，然后执行对应的写操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 调用替换节点方法</span></span><br><span class="line">     <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 计算 hash</span></span><br><span class="line">     <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 自旋</span></span><br><span class="line">     <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = table; ; ) &#123;</span><br><span class="line">         Node&lt;K, V&gt; f;</span><br><span class="line">         <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果数组为空，或目标 key 所在的桶不存在，跳出循环返回 null</span></span><br><span class="line">         <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">                 (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 如果桶中第一个元素的 hash 值为 MOVED ，说明这个桶已经迁移完了，但是其它的桶不知道，因此当前线程协助迁移，协助扩容完成后再进行删除操作</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">             tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 查找元素并执行删除</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             V oldVal = <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">// 标记是否处理过</span></span><br><span class="line">             <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 加锁（锁对象使用桶的第一个元素，达到分段的效果）</span></span><br><span class="line">             <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                 <span class="comment">// 再次验证当前桶的第一个元素是否被修改</span></span><br><span class="line">                 <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 桶的第一个元素的 hash &gt;= 0 表示是链表节点</span></span><br><span class="line">                     <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                         validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                         <span class="comment">// 遍历链表寻找目标节点</span></span><br><span class="line">                         <span class="keyword">for</span> (Node&lt;K, V&gt; e = f, pred = <span class="keyword">null</span>; ; ) &#123;</span><br><span class="line">                             K ek;</span><br><span class="line">                             <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                     ((ek = e.key) == key ||</span><br><span class="line">                                             (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                 <span class="comment">// 找到目标节点</span></span><br><span class="line">                                 V ev = e.val;</span><br><span class="line"></span><br><span class="line">                                 <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                         (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                     oldVal = ev;</span><br><span class="line"></span><br><span class="line">                                     <span class="comment">// 如果 value 不为空则替换旧值</span></span><br><span class="line">                                     <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                         e.val = value;</span><br><span class="line">                                     <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                         <span class="comment">// 如果前置节点不为空，删除当前节点</span></span><br><span class="line">                                         pred.next = e.next;</span><br><span class="line">                                     <span class="keyword">else</span></span><br><span class="line">                                         <span class="comment">// 如果前置节点为空，说明是桶中第一个元素，删除即可</span></span><br><span class="line">                                         setTabAt(tab, i, e.next);</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 <span class="keyword">break</span>;</span><br><span class="line">                             &#125;</span><br><span class="line">                             pred = e;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 遍历到链表尾部还没找到元素，跳出循环</span></span><br><span class="line">                             <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                 <span class="keyword">break</span>;</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                         <span class="comment">// 桶的第一个元素类型为树，则遍历树找目标节点</span></span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                         validated = <span class="keyword">true</span>;</span><br><span class="line">                         TreeBin&lt;K, V&gt; t = (TreeBin&lt;K, V&gt;) f;</span><br><span class="line">                         TreeNode&lt;K, V&gt; r, p;</span><br><span class="line">                         <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                 (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 找到目标节点</span></span><br><span class="line">                             V pv = p.val;</span><br><span class="line">                             <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                     (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                 oldVal = pv;</span><br><span class="line">                                 <span class="comment">// 如果value不为空则替换旧值</span></span><br><span class="line">                                 <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                     p.val = value;</span><br><span class="line">                                     <span class="comment">// 如果 value 为空，从树中删除</span></span><br><span class="line">                                 <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line"></span><br><span class="line">                                     <span class="comment">// 判断是否退化成链表</span></span><br><span class="line">                                     <span class="comment">//  t.removeTreeNode(p)这个方法返回true表示删除节点后树的元素个数较少，此时退化成链表</span></span><br><span class="line">                                     setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 如果处理过，就不需要循环了，可以退出了</span></span><br><span class="line">             <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                 <span class="comment">// 如果找到了元素，返回其旧值</span></span><br><span class="line">                 <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 如果要替换的值为空，元素个数减 1，不考虑调整数组大小</span></span><br><span class="line">                     <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                         addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                     <span class="keyword">return</span> oldVal;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 没找到元素返回空</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>删除方法和新增方法类似，就不再说明。需要注意的一点是，如果定位到的桶是以红黑树存储的，那么删除元素后需要判断是否要退化为链表。</p>
<h3 id="get-获取元素"><a href="#get-获取元素" class="headerlink" title="get() - 获取元素"></a>get() - 获取元素</h3><p>一般来说，对于 get 操作是没有线程安全问题的，只有可见性的问题，只需要确保获取的元素是线程间可见的即可，针对这个问题 ConcurrentHashMap 使用 <code>volatile</code> 关键字修饰节点的值 val 和后继指针来保证可见性。</p>
<p>除了可见性问题，ConcurrentHashMap 还需要解决一个问题，这个问题是由其支持<strong>并发扩容</strong>带来的。也就是说，<strong>在扩容期间访问元素的时候，集合中的元素可能分布在新旧两个数组中</strong>，针对这种情况的访问策略是，先访问旧数组，如果旧数组相应位置的桶已经被标记迁移完成了，那么就需要继续访问新数组以查询目标元素，否则只需访问旧数组即可（注意，即使定位到的旧数组桶处于迁移过程也没关系，在完成迁移之前该桶中的元素之间的关联是不变的）。而这个策略实现的核心是 <strong><code>ForwardingNode</code></strong> 类型对象，它作为旧数组某个桶迁移完成的标记的同时，内部还封装了新数组，并且重写了查找元素的方法，而这个重写的查找方法就是从新数组中查找元素的。</p>
<p>下面我们对源码进行分析，看看 ConcurrentHashMap 具体是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; e, p;</span><br><span class="line">    <span class="keyword">int</span> n, eh;</span><br><span class="line">    K ek;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 hash</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果元素所在的桶存在且里面有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             <span class="comment">// 使用 Unsafe 的 volatile 式获取节点，保证最新值</span></span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果第一个元素就是要找的元素，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// hash &lt; 0 说明第一个元素是树类型，或者数组处于扩容过程（元素类型是 ForwardingNode）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 使用find寻找元素，find的寻找方式依据Node的不同子类有不同的实现方式：</span></span><br><span class="line">            <span class="comment">// 处于扩容过程：java.util.concurrent.ConcurrentHashMap.ForwardingNode.find</span></span><br><span class="line">            <span class="comment">// 非扩容过程，也就是树类型：java.util.concurrent.ConcurrentHashMap.TreeNode.find</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里，说明元素所在的桶中是链表，遍历链表即可</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在访问元素时会计算 key 的 hash 值;</li>
<li>如果定位到的桶元素就是要查找的元素，那么直接返回对应的 value；</li>
<li>如果定位到的桶元素不是要查找的元素，那么就需要做出判断，这个判断非常重要，对应三种情况：<ul>
<li>如果桶元素的 <code>hash &lt; 0 &amp;&amp; hash == -1</code>，那么说明桶元素的类型是 <strong>ForwardingNode</strong>，此时集合处于扩容过程，查找元素调用 ForwardingNode 实现的查找方法；</li>
<li>如果桶元素的 <code>hash &lt; 0 &amp;&amp; hash == -2</code>，那么说明桶元素的类型是 <strong>TreeNode</strong>，是一颗红黑树，查找元素调用 TreeNode 实现的查找方法；</li>
<li>不是前面两种情况，那么桶中就是链表，遍历链表查找即可；</li>
</ul>
</li>
<li>没有定位到对应的桶，直接返回 null；</li>
</ol>
<p>关于链表和红黑树查找没有可说的，下面我们对处于扩容状态的查找进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容期间作为桶迁移完成的标志元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容期间的新数组。保存新Node数组的引用是为了支持在迁移的过程不阻塞地查找值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K, V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tab 新数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ForwardingNode(Node&lt;K, V&gt;[] tab) &#123;</span><br><span class="line">        <span class="comment">// hash 固定为 MOVED </span></span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容期间查找元素，那么从扩容期间的新数组查找</span></span><br><span class="line"><span class="comment">     *    </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node&lt;K, V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = nextTable; ; ) &#123;</span><br><span class="line">            Node&lt;K, V&gt; e;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新的数组为空，或者对应的桶为空，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">                    (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定位桶查找目标元素</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> eh;</span><br><span class="line">                K ek;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否是要查找的元素</span></span><br><span class="line">                <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                        ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 非链表的情况</span></span><br><span class="line">                <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果元素是 ForwardingNode ，说明该桶的元素已经迁移到新的数组中，那么需要从新的数组中查找</span></span><br><span class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                        tab = ((ForwardingNode&lt;K, V&gt;) e).nextTable;</span><br><span class="line">                        <span class="keyword">continue</span> outer;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果 e 元素对应的桶还没有迁移，则根据红黑树查找</span></span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> e.find(h, k);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<strong><code>ForwardingNode</code></strong> 这个特殊节点的作用已经介绍完毕了，下面再进行总结：</p>
<ul>
<li>标识旧数组某个桶迁移完成，以支持并发扩容；</li>
<li>封装新数组，以支持在迁移的过程中非阻塞查找值；</li>
</ul>
<h4 id="浅谈Redis-rehash"><a href="#浅谈Redis-rehash" class="headerlink" title="浅谈Redis rehash"></a>浅谈Redis rehash</h4><p>如果了解 Redis 扩容机制的话，你会发现两者有异曲同工之处。</p>
<ul>
<li><strong>扩容操作：</strong>Redis 实现的是渐进式 rehash，主线程以一定的步长迁移桶元素；ConcurrentHashMap 实现的是辅助扩容，多个线程可以并发迁移桶元素；</li>
<li><strong>扩容期间查找元素：</strong>Redis 在扩容的时候使用到了两个哈希表，会先从 0 号哈希表查找，没有再从 1 号哈希表查找；ConcurrentHashMap 在扩容过程也同时使用了两个桶数组，查找的时候也会先到旧数组中定位桶元素，如果桶元素是迁移标识元素 ForwardingNode，那么会再从新数组中查找；</li>
</ul>
<h2 id="JDK1-7-与-JDK1-8的区别"><a href="#JDK1-7-与-JDK1-8的区别" class="headerlink" title="JDK1.7 与 JDK1.8的区别"></a>JDK1.7 与 JDK1.8的区别</h2><p>JDK 1.7 的核心实现也采用了分段锁的技术，每个段 Segment 中对应一个小 HashMap，Segment 通过继承 ReentrantLock 来保证其内部的 HashMap 安全。</p>
<p>JDK 1.8 废弃了 Segment 分段锁的实现，采用<strong>多种 CAS + Node 级别的 synchronized 锁</strong>来保证并发安全，整体减小了锁竞争，减小程序同步的部分。</p>
<h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h2><p>这里我们讨论的一致性问题是针对 put 和 get 方法来说的。</p>
<p>JDK 1.7 的实现中 ConcurrentHashMap 表现为弱一致性，因为写操作只是简单赋值操作，读操作也是简单读操作。具体实现如下：</p>
<p><strong>写操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">  lock();</span><br><span class="line">  ...</span><br><span class="line">    tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(...);</span><br><span class="line">  ...</span><br><span class="line">    unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">0</span>) &#123; <span class="comment">// read-volatile</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = getFirst(hash);</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;</span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line">                <span class="keyword">return</span> readValueUnderLock(e); <span class="comment">// recheck</span></span><br><span class="line">            &#125;</span><br><span class="line">            e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行写操作时，先加锁，然后直接给数组中的桶赋值，此时虽然数组 tab 使用 vlolatile 修饰保证可见性，但是不保证元素的可见性，因此无法保证能及时读取到写入的元素。由此可以看出，在 JDK 1.8 之前的读写操作是弱一致性的。</p>
<p>要保证读写强一致性，一般可以加锁，或者使用 volatile 修饰变量。如果采用加锁的方式，会导致 ConcurrentHashMap 的性能问题，这也违背了设计的初衷，因此可以考虑使用 volatile 来保证可见性。但是我们需要知道的是，volatile 可以修饰变量却不能修饰数组中的元素，也就是修饰数组只能保证数组的地址可见性。</p>
<p>JDK 1.8 正是从上述点进行突破，使用了 Unsafe 类来实现数组元素的可见性。</p>
<p><strong>写操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">      <span class="comment">// 使用 Unsafe 类 volatile 式的操作查看值</span></span><br><span class="line">      <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组该位置没有节点，则使用一次 CAS 操作将这个新值放入其中即可。  </span></span><br><span class="line">        <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                     <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 如果元素所在的桶存在且里面有元素 </span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      <span class="comment">// 使用 Unsafe 的 volatile 式获取节点，保证最新值</span></span><br><span class="line">      (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>写操作使用 CAS 更新内存中数组中的元素；</li>
<li>读操作使用 Unsafe 的 volatile 式获取内存中数组中的元素；</li>
</ul>
<p>由于读写都是直接对内存操作，所以通过上述方式可以保证 put 和 get 的强一致性。ConcurrentHashMap 是通过 <code>compareAndSwapObject</code> 来取代对数组元素直接赋值的操作，通过 <code>getObjectVolatile</code> 来弥补无法对数组元素进行 volatile 读的缺陷。</p>
<p>需要注意，JDK 1.8 下的 ConcurrentHashMap 并非所有操作都是强一致性的，其中计算集合元素个数的 size() 方法就是弱一致性的，具体原因通过前面的源码就能看出来。</p>
<h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><p>ConcurrentHashMap 运用各类 CAS 操作保证并发安全，并在关键逻辑位置使用 <code>synchronized</code> 分段锁以小范围进行锁定保证安全。</p>
<p>在扩容时，ConcurrentHashMap 支持多线程并发扩容，在扩容过程的同时支持 get 获取元素，这种无阻塞算法，大大提高了并发度。其中，整个扩容过程都是通过 CAS 控制 <strong>sizeCtl</strong> 这个属性来进行的，某个桶完成迁移会使用 ForwardingNode 节点填充以标识该桶迁移完毕。整个迁移过程类似 Redis 中的 rehash 过程。</p>
<p>ConcurrentHashMap 元素个数的存储采用的是<strong>分段存储</strong>思想，类似 LongAdder 的实现，提高并发度。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>ConcurrentHashMap 设计非常精妙，读完源码后收获很大，很多设计让人眼前一亮，也开阔了技术视野。</p>
<ul>
<li>自旋 + CAS，采用乐观锁的思想保证安全，避免线程阻塞；</li>
<li>分段锁的思想，使用 <code>synchronized</code> 锁住单个桶对象以减小锁范围；</li>
<li>分段存储集合元素个数，减小并发更新一个字段的竞争；</li>
<li>支持并发扩容，尽可能无阻塞实现读写；</li>
</ul>
<p>下面我们探讨几个问题，以问题的形式再对关键点进行回顾。</p>
<p><strong>Q：如何保证并发安全？</strong></p>
<p>在 ConcurrentHashMap 中大量使用了各种 CAS 操作来保证安全性，并不是一股脑都加锁来保证安全，在必要的流程中即使使用了 <code>synchronized</code> 锁，也是把粒度缩到了很小。</p>
<p><strong>Q：如何保证数组元素的可见性？</strong></p>
<p>ConcurrentHashMap 中的桶数组是采用了 <code>volatile</code> 修饰，但是这只能保证数组的引用在不同线程之间的可见性，并不能保证数组内部的元素在不同线程之间也是可见的。所以，我们在判断某个下标是否有元素时，不能直接通过下标获取，而是通过 Unsafe 的 volatile 式获取来保证可见。写入值的场景有两处：</p>
<ul>
<li>定位到的桶为空时，通过 CAS 操作来存储当前元素；</li>
<li>定位到的桶不为空，使用 <code>synchronized</code> 关键字锁住当前桶，并进行设值操作；</li>
</ul>
<p>可以看到，不管是写入元素到数组，还是从数组中读取元素，都能保证可见性。</p>
<p><strong>Q：如何计数？</strong></p>
<p>在 HashMap 中是通过对 size 属性进行自增或自减来统计元素的个数的，但是并发模型下这种操作是不安全的，那么是否可以通过 CAS 操作来修改 size 呢？答案是可行的，只是在并发冲突较高的时候，只会有一个线程能够成功，其他线程只能不断地尝试 CAS ，这无疑对 ConcurrentHashMap 的性能有影响，因此 ConcurrentHashMap 采用了<strong>分而治之的思想</strong>来完成计数。</p>
<p>具体来说，ConcurrentHashMap 又定义了一个数组，这个数组中的每个非空元素都是元素个数的一部分。每次线程需要计数的时候，都会基于线程计算出一个随机值然后定位到计数数组中的某个元素，然后对这个元素进行计数操作。这样就可以尽可能地提高并发度了。此外，计数数组同样可以扩容，通过扩容来解决并发更加激烈的情况。</p>
<p><strong>Q：扩容也支持并发吗？</strong></p>
<p>ConcurrentHashMap 支持多线程并发扩容，在进行新增或删除操作时，如果定位到的桶标记为迁移状态，那么当前线程就会尝试协助扩容，如果不需要当前线程协助，那么当前线程就等着扩容完成后继续操作。</p>
<p>并发扩容采用的是<strong>分段扩容</strong>，每个线程负责桶数组的一段，默认最小是 16 个桶，也就是说如果 ConcurrentHashMap 中只有 16 个桶，那么就只会有一个线程参与扩容。如果大于 16 则根据机器的 CPU 核数来进行分配；</p>
<p><strong>参考：</strong></p>
<p><a href="https://mp.weixin.qq.com/s/1yWSfdz0j-PprGkDgOomhQ" target="_blank" rel="noopener">漫画：什么是ConcurrentHashMap</a></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/218dc61f/" title="并发 - ConcurrentHashMap" target="_blank" rel="external">https://gentryhuang.com/posts/218dc61f/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/282602b0/" title="并发 - LongAdder"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/9012be3f/" title="并发 - ScheduledThreadPoolExecutor"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2022 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>