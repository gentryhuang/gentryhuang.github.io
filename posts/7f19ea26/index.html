<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>集群容错 - Cluster | gentryhuang的博客</title>
  <meta name="description" content="前言前面的几篇文章分别对服务目录 Directory、路由 Router、负载均衡 LoadBalance 以及动态配置 Configurator 进行了介绍，本篇文章将对 Dubbo 的集群容错进行分析，集群容错是基于前面几部分内容实现的。考虑到 Dubbo 2.7.x 集群容错部分新增了一些内容，因此本篇文章基于 Dubbo 2.7.x 版本的源代码进行分析。 概述为了避免单点故障，现在的应用">
<meta property="og:type" content="article">
<meta property="og:title" content="集群容错 - Cluster">
<meta property="og:url" content="https://gentryhuang.com/posts/7f19ea26/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="前言前面的几篇文章分别对服务目录 Directory、路由 Router、负载均衡 LoadBalance 以及动态配置 Configurator 进行了介绍，本篇文章将对 Dubbo 的集群容错进行分析，集群容错是基于前面几部分内容实现的。考虑到 Dubbo 2.7.x 集群容错部分新增了一些内容，因此本篇文章基于 Dubbo 2.7.x 版本的源代码进行分析。 概述为了避免单点故障，现在的应用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-frame.jpeg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-cluster-uml.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-cluster-invoker-uml.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-interceptor-uml.jpg">
<meta property="article:published_time" content="2020-10-02T16:00:00.000Z">
<meta property="article:modified_time" content="2021-04-08T15:03:15.425Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="Dubbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-frame.jpeg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/7f19ea26/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            
            <p>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次</p>
            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AQS/" rel="tag">AQS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a><span class="tag-list-count">62</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Filter/" rel="tag">Filter</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUC/" rel="tag">JUC</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javassist/" rel="tag">Javassist</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mina/" rel="tag">Mina</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Protocol/" rel="tag">Protocol</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/" rel="tag">RPC</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raft/" rel="tag">Raft</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">Redis数据结构</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPI/" rel="tag">SPI</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/" rel="tag">Zookeeper</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" rel="tag">共识算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">32</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.14px;">AQS</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.71px;">Filter</a> <a href="/tags/JUC/" style="font-size: 13.43px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.29px;">Javassist</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.29px;">Protocol</a> <a href="/tags/RPC/" style="font-size: 13.57px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.14px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.29px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.29px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.86px;">设计模式</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/4760cec/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/RPC/">RPC</a>
              </p>
              <p class="item-title">
                <a href="/posts/4760cec/" class="title">Dubbo源码分析 - 健康检测</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-04T10:56:21.000Z" itemprop="datePublished">2021-05-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/48468614/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
              </p>
              <p class="item-title">
                <a href="/posts/48468614/" class="title">Raft 共识算法</a>
              </p>
              <p class="item-date">
                <time datetime="2021-04-23T11:28:56.000Z" itemprop="datePublished">2021-04-23</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/2362a8ea/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/2362a8ea/" class="title">Redis原理 - 链表</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-16T11:33:59.000Z" itemprop="datePublished">2021-03-16</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/aa1d8127/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/aa1d8127/" class="title">Redis原理 - 简单动态字符串</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-13T11:00:50.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/c812f120/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/RPC/">RPC</a>
              </p>
              <p class="item-title">
                <a href="/posts/c812f120/" class="title">Dubbo源码分析 - 异步改造</a>
              </p>
              <p class="item-date">
                <time datetime="2021-02-13T16:00:00.000Z" itemprop="datePublished">2021-02-14</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集群容错"><span class="toc-number">3.</span> <span class="toc-text">集群容错</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码分析"><span class="toc-number">4.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cluster"><span class="toc-number">4.1.</span> <span class="toc-text">Cluster</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AbstractCluster"><span class="toc-number">4.2.</span> <span class="toc-text">AbstractCluster</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClusterInterceptor"><span class="toc-number">4.3.</span> <span class="toc-text">ClusterInterceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConsumerContextClusterInterceptor"><span class="toc-number">4.3.1.</span> <span class="toc-text">ConsumerContextClusterInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZoneAwareClusterInterceptor"><span class="toc-number">4.3.2.</span> <span class="toc-text">ZoneAwareClusterInterceptor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AbstractClusterInvoker"><span class="toc-number">4.4.</span> <span class="toc-text">AbstractClusterInvoker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">4.4.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断-Cluster-Invoker-状态"><span class="toc-number">4.4.2.</span> <span class="toc-text">判断 Cluster Invoker 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取-Invoker-列表"><span class="toc-number">4.4.3.</span> <span class="toc-text">获取 Invoker 列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#invoke-调用"><span class="toc-number">4.4.4.</span> <span class="toc-text">invoke() 调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通用选择方法"><span class="toc-number">4.4.5.</span> <span class="toc-text">通用选择方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FailoverCluster-amp-FailoverClusterInvoker"><span class="toc-number">4.5.</span> <span class="toc-text">FailoverCluster &amp; FailoverClusterInvoker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FailoverCluster"><span class="toc-number">4.5.1.</span> <span class="toc-text">FailoverCluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FailoverClusterInvoker"><span class="toc-number">4.5.2.</span> <span class="toc-text">FailoverClusterInvoker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FailbackCluster-amp-FailbackClusterInvoker"><span class="toc-number">4.6.</span> <span class="toc-text">FailbackCluster &amp; FailbackClusterInvoker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FailbackCluster"><span class="toc-number">4.6.1.</span> <span class="toc-text">FailbackCluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FailbackClusterInvoker"><span class="toc-number">4.6.2.</span> <span class="toc-text">FailbackClusterInvoker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RetryTimerTask"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">RetryTimerTask</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FailfastCluster-amp-FailfastClusterInvoker"><span class="toc-number">4.7.</span> <span class="toc-text">FailfastCluster &amp; FailfastClusterInvoker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FailfastCluster"><span class="toc-number">4.7.1.</span> <span class="toc-text">FailfastCluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FailfastClusterInvoker"><span class="toc-number">4.7.2.</span> <span class="toc-text">FailfastClusterInvoker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FailsafeCluster-amp-FailsafeClusterInvoker"><span class="toc-number">4.8.</span> <span class="toc-text">FailsafeCluster &amp; FailsafeClusterInvoker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FailsafeCluster"><span class="toc-number">4.8.1.</span> <span class="toc-text">FailsafeCluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FailsafeClusterInvoker"><span class="toc-number">4.8.2.</span> <span class="toc-text">FailsafeClusterInvoker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkingCluster-amp-ForkingClusterInvoker"><span class="toc-number">4.9.</span> <span class="toc-text">ForkingCluster &amp; ForkingClusterInvoker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkingCluster"><span class="toc-number">4.9.1.</span> <span class="toc-text">ForkingCluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkingClusterInvoker"><span class="toc-number">4.9.2.</span> <span class="toc-text">ForkingClusterInvoker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BroadcastCluster-amp-BroadcastClusterInvoker"><span class="toc-number">4.10.</span> <span class="toc-text">BroadcastCluster &amp; BroadcastClusterInvoker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BroadcastCluster"><span class="toc-number">4.10.1.</span> <span class="toc-text">BroadcastCluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BroadcastClusterInvoker"><span class="toc-number">4.10.2.</span> <span class="toc-text">BroadcastClusterInvoker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AvailableCluster-amp-AvailableClusterInvoker"><span class="toc-number">4.11.</span> <span class="toc-text">AvailableCluster &amp; AvailableClusterInvoker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AvailableCluster"><span class="toc-number">4.11.1.</span> <span class="toc-text">AvailableCluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AvailableClusterInvoker"><span class="toc-number">4.11.2.</span> <span class="toc-text">AvailableClusterInvoker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZoneAwareCluster-amp-ZoneAwareClusterInvoker"><span class="toc-number">4.12.</span> <span class="toc-text">ZoneAwareCluster &amp; ZoneAwareClusterInvoker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ZoneAwareCluster"><span class="toc-number">4.12.1.</span> <span class="toc-text">ZoneAwareCluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZoneAwareClusterInvoker"><span class="toc-number">4.12.2.</span> <span class="toc-text">ZoneAwareClusterInvoker</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-rpc/集群容错之Cluster" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      集群容错 - Cluster
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/7f19ea26/" class="article-date">
	  <time datetime="2020-10-02T16:00:00.000Z" itemprop="datePublished">2020-10-03</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/RPC/">RPC</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Dubbo/" rel="tag">Dubbo</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/7f19ea26/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 10.1k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 45(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的几篇文章分别对服务目录 <code>Directory</code>、路由 <code>Router</code>、负载均衡 <code>LoadBalance</code> 以及动态配置 <code>Configurator</code> 进行了介绍，本篇文章将对 Dubbo 的集群容错进行分析，集群容错是基于前面几部分内容实现的。考虑到 Dubbo 2.7.x 集群容错部分新增了一些内容，因此本篇文章基于 Dubbo 2.7.x 版本的源代码进行分析。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>为了避免单点故障，现在的应用通常至少会部署在两台服务器上，对一些负载比较高的服务，会部署更多的服务器。这样，在同一环境下的服务提供者就会有多台，对于服务消费者来说，需要选择一个服务提供者进行调用，如果调用失败还需要进行失败处理，如重试、抛出异常或者记录异常日志等。为了处理这些问题，Dubbo 定义了集群接口 <code>Cluster</code> 以及 <code>Cluster Invoker</code> 。<strong>Cluster 用途是将多个服务提供者对应的 Invoker 合并为一个 Cluster Invoker，并将这个 Invoker 暴露给服务消费者</strong>。这样一来，服务消费者只需通过这个 Invoker 进行远程调用即可，至于具体调用哪个服务提供者，以及调用失败后如何处理等问题，现在都交给集群模块去处理。集群模块是服务提供者和服务消费者的中间层，为服务消费者屏蔽了服务提供者的情况，这样服务消费者就可以专心处理远程调用相关事宜。比如发请求，接受服务提供者返回的数据等。这就是集群的作用。</p>
<p>Dubbo 默认内置了若干容错策略，每种容错策略都有独特的应用场景，使用方可以根据具体需要配置不同的容错策略，如果这些内置容错策略不能满足需求，还可以自定义容错策略。</p>
<h1 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h1><p>在分析集群容错相关代码之前，先对涉及的组件进行介绍，主要包括了 <code>Cluster</code>、<code>Cluster Invoker</code>、<code>Directory</code>、<code>Router</code> 和 <code>LoadBalance</code> 等。</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-frame.jpeg" alt></p>
<p><strong>集群工作过程可分为两个阶段，具体如下：</strong></p>
<ol>
<li>创建 <code>Cluster Invoker</code> 实例<blockquote>
<p>在服务消费者初始化期间（服务引用过程），集群 Cluster 实现类为服务消费者创建 Cluster Invoker 实例，即上图中的 merge 操作。</p>
</blockquote>
</li>
<li>使用 <code>Cluster Invoker</code> 实例<blockquote>
<p>在服务消费者发起远程调用请求时，<code>Cluster Invoker</code> 会依赖 <code>Directory</code>、<code>Router</code>、<code>LoadBalance</code> 等组件得到最终要调用的 Invoker 对象。</p>
</blockquote>
</li>
</ol>
<p><strong>其中使用 <code>Cluster Invoker</code> 获取目标 Invoker 的具体流程如下：</strong></p>
<ol>
<li>通过服务目录 Directory 获取消费端 Invoker 列表（提供者对应的 Invoker 列表），其中的 RegistryDirectory 会感知注册中心的动态变化，实时获取提供者对应的 Invoker 对象。</li>
<li>使用 Router 对服务目录中提供者对应的 Invoker 列表进行路由，过滤掉不符合路由规则的 Invoker 对象。</li>
<li>使用 LoadBalance 从路由后的 Invoker 列表中选择一个目标 Invoker。</li>
<li>ClusterInvoker 会将请求信息传给负载均衡选出的 Invoker 实例，进行真正的远程调用。</li>
</ol>
<p>以上就是集群工作的正常流程，没有涉及到容错处理，容错处理逻辑是在 <code>Cluster Invoker</code> 中封装的。到这里我们知道了，集群工作的正常流程就是单纯地对其他组件的使用，只有调用出现异常时才会使用到容错逻辑。</p>
<p><strong>Dubbo 主要提供了以下的容错方式：</strong></p>
<ul>
<li><strong>Failover Cluster - 失败自动切换</strong> <blockquote>
<p>失败自动切换，是 Dubbo 默认的容错机制。当请求一个提供者节点失败时，会自动切换到其他提供者节点，默认执行 3 次，也就是重试 2 次，适合幂等场景操作。</p>
</blockquote>
</li>
<li><strong>Failfast Cluster - 快速失败</strong><blockquote>
<p>快速失败。请求失败后返回异常，不进行任务重试。适合非幂等的操作</p>
</blockquote>
</li>
<li><strong>Failsafe Cluster - 失败安全</strong><blockquote>
<p>失败安全。请求失败后忽略异常，不进行任何重试，返回一个空结果。</p>
</blockquote>
</li>
<li><strong>Failback Cluster - 失败自动恢复</strong><blockquote>
<p>失败自动恢复。失败后记录到队列，并返回一个空结果，对于失败的调用会定时重试，重试是不关心结果的。</p>
</blockquote>
</li>
<li><strong>Forking Cluster - 并行调用多个提供者</strong><blockquote>
<p>并行调用多个提供者，只要有一个成功就返回。主要应用在一些对实时性要求比较高的读操作下使用，但这将会耗费更多的资源。</p>
</blockquote>
</li>
<li><strong>Broadcast Cluster - 广播多个提供者</strong><blockquote>
<p>广播多个提供者，只要有一个失败就失败。通常用于通知类的操作，如通知所有提供者更新缓存或日志等本地资源信息。</p>
</blockquote>
</li>
<li><strong>Availabel Cluster - 调用首个可用的提供者</strong><blockquote>
<p>遍历所有的 Provider 节点，找到每一个可用的节点，就直接调用。如果没有可用的 Provider 节点，则直接抛出异常。</p>
</blockquote>
</li>
<li><strong>ZoneAware Cluster - 优先多注册中心选择提供者</strong><blockquote>
<p>在 Dubbo 中使用多个注册中心的情况，服务消费端可以使用 ZoneAwareClusterInvoker 先在多个注册中心之间选择，确定注册中心之后，再选择服务提供者节点。</p>
</blockquote>
</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>集群容错有两个概念，分别是集群接口 <code>Cluster</code> 和封装集群容错功能的 <code>Cluster Invoker</code> ，这两者是不同的。<code>Cluster</code> 是扩展接口，它的扩展实现仅用于创建 <code>Cluster Invoker</code> 。<code>Cluster Invoker</code> 是一种特殊的 Invoker ，服务提供者的选择逻辑，以及远程调用失败后的处理逻辑都是封装在 <code>Cluster Invoker</code> 中。</p>
<h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(FailoverCluster.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merge the directory invokers to a virtual invoker.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> cluster invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Cluster</code> 接口是一个扩展接口，通过 <strong>@SPI</strong> 注解的参数可知其默认实现是 <code>FailoverCluster</code>。它只定义了一个 <code>join</code> 方法，其上添加了 <strong>@Adaptive</strong> 注解，会动态生成适配器类，其中会优先根据 <strong>Directory.getUrl</strong> 方法返回的 URL 中的 <strong>cluster</strong> 参数值选择扩展实现，若无 <strong>cluster</strong> 参数则使用默认的 <code>FailoverCluster</code> 实现。</p>
<p><code>Cluster</code> 的继承体系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-cluster-uml.jpg" alt></p>
<p>在每个 Cluster 接口实现中，都会创建对应的 Invoker 对象，它们都继续自 <code>AbstractClusterInvoker</code> 抽象类，继承体系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-cluster-invoker-uml.jpg" alt></p>
<p>通过上面的继承关系图不难发现，<code>Cluster</code> 接口和 <code>Invoker</code> 接口都有相应的抽象实现类，这些抽象实现类都提供了一些公共能力。下面我们先对 <code>AbstractCluster</code> 和 <code>AbstractClusterInvoker</code> 这两个抽象类进行介绍。</p>
<p>关于 <code>Mock</code> 和 <code>Merger</code> 相关的实现，会分别在服务降级部分和分组聚合部分进行详细分析，本篇文章暂不展开说明。</p>
<h2 id="AbstractCluster"><a href="#AbstractCluster" class="headerlink" title="AbstractCluster"></a>AbstractCluster</h2><p><code>AbstractCluster</code> 核心逻辑是在 <code>AbstractClusterInvoker</code> 外层包装一层 <code>ClusterInterceptor</code>，从而实现类似切面的效果。切面逻辑目前应用不是很多，这是 Dubbo 2.7.x 增加的，这里了解即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildClusterInterceptors</span><span class="params">(AbstractClusterInvoker&lt;T&gt; clusterInvoker, String key)</span> </span>&#123;</span><br><span class="line">        AbstractClusterInvoker&lt;T&gt; last = clusterInvoker;</span><br><span class="line">        <span class="comment">// 通过 SPI 方式加载 ClusterInterceptor 扩展实现</span></span><br><span class="line">        List&lt;ClusterInterceptor&gt; interceptors = ExtensionLoader.getExtensionLoader(ClusterInterceptor<span class="class">.<span class="keyword">class</span>).<span class="title">getActivateExtension</span>(<span class="title">clusterInvoker</span>.<span class="title">getUrl</span>(), <span class="title">key</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果存在，则将 InterceptorInvokerNode 首尾连接到一起，形成调用链。</span></span><br><span class="line">        <span class="keyword">if</span> (!interceptors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> ClusterInterceptor interceptor = interceptors.get(i);</span><br><span class="line">                <span class="keyword">final</span> AbstractClusterInvoker&lt;T&gt; next = last;</span><br><span class="line">                last = <span class="keyword">new</span> InterceptorInvokerNode&lt;&gt;(clusterInvoker, interceptor, next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 在 AbstractClusterInvoker 外层包装一层 ClusterInterceptor</span></span><br><span class="line">        <span class="keyword">return</span> buildClusterInterceptors(doJoin(directory), directory.getUrl().getParameter(REFERENCE_INTERCEPTOR_KEY));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体子类创建 AbstractClusterInvoker</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>AbstractCluster</code> 抽象类的 <strong>join</strong> 方法中，首先会调用 <strong>doJoin</strong> 方法获取最终要调用的 Invoker 对象，该方法由具体子类根据具体策略实现。之后，<strong>join</strong> 方法会调用 <strong>buildClusterInterceptors</strong> 方法对 Invoker 对象进行包装，实现切面逻辑。切面逻辑由 <code>InterceptorInvokerNode</code> 对象完成，它会将 ClusterInvoker 对象以及关联的 ClusterInterceptor 对象封装到一起，同时还会维护一个 next 引用，指向下一个 InterceptorInvokerNode 对象，核心逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorInvokerNode</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> AbstractClusterInvoker&lt;T&gt; clusterInvoker;</span><br><span class="line">       <span class="keyword">private</span> ClusterInterceptor interceptor;</span><br><span class="line">       <span class="keyword">private</span> AbstractClusterInvoker&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">InterceptorInvokerNode</span><span class="params">(AbstractClusterInvoker&lt;T&gt; clusterInvoker,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     ClusterInterceptor interceptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     AbstractClusterInvoker&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.clusterInvoker = clusterInvoker;</span><br><span class="line">           <span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">           Result asyncResult;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 前置逻辑</span></span><br><span class="line">               interceptor.before(next, invocation);</span><br><span class="line">               <span class="comment">// 执行 invoke() 方法完成远程调用</span></span><br><span class="line">               asyncResult = interceptor.intercept(next, invocation);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="comment">// 出现异常时，会触发监听器的 onError 方法</span></span><br><span class="line">               <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> ClusterInterceptor.Listener) &#123;</span><br><span class="line">                   ClusterInterceptor.Listener listener = (ClusterInterceptor.Listener) interceptor;</span><br><span class="line">                   listener.onError(e, clusterInvoker, invocation);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">throw</span> e;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 后置逻辑</span></span><br><span class="line">               interceptor.after(next, invocation);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> asyncResult.whenCompleteWithContext((r, t) -&gt; &#123;</span><br><span class="line">               <span class="comment">// onResponse callback</span></span><br><span class="line">               <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> ClusterInterceptor.Listener) &#123;</span><br><span class="line">                   ClusterInterceptor.Listener listener = (ClusterInterceptor.Listener) interceptor;</span><br><span class="line">                   <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       listener.onMessage(r, clusterInvoker, invocation);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       listener.onError(t, clusterInvoker, invocation);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClusterInterceptor"><a href="#ClusterInterceptor" class="headerlink" title="ClusterInterceptor"></a>ClusterInterceptor</h2><p>用于对 <code>Cluster Invoker</code> 外围包装一层类似切面逻辑，具体有没有该切面逻辑需要看环境中没有对应扩展实现被加载到内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClusterInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置拦截方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clusterInvoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置拦截方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clusterInvoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">(AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用 clusterInvoker.invoke 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clusterInvoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Result <span class="title">intercept</span><span class="params">(AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clusterInvoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来监听请求的正常结果以及异常</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Result appResponse, AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t, AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dubbo 提供了两个 <code>ClusterInterceptor</code> 实现类，分别是 <code>ConsumerContextClusterInterceptor</code> 和 <code>ZoneAwareClusterInterceptor</code>，继承关系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-interceptor-uml.jpg" alt></p>
<h3 id="ConsumerContextClusterInterceptor"><a href="#ConsumerContextClusterInterceptor" class="headerlink" title="ConsumerContextClusterInterceptor"></a>ConsumerContextClusterInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerContextClusterInterceptor</span> <span class="keyword">implements</span> <span class="title">ClusterInterceptor</span>, <span class="title">ClusterInterceptor</span>.<span class="title">Listener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(AbstractClusterInvoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        RpcContext context = RpcContext.getContext();</span><br><span class="line">        <span class="comment">// 设置当前 Consumer 地址</span></span><br><span class="line">        context.setInvocation(invocation).setLocalAddress(NetUtils.getLocalHost(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置此次调用的 Invoker </span></span><br><span class="line">        <span class="keyword">if</span> (invocation <span class="keyword">instanceof</span> RpcInvocation) &#123;</span><br><span class="line">            ((RpcInvocation) invocation).setInvoker(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除 Server Context</span></span><br><span class="line">        RpcContext.removeServerContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 移除本地 RpcContext</span></span><br><span class="line">        RpcContext.removeContext(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现了 ClusterInterceptor.Listener 接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Result appResponse, AbstractClusterInvoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取响应中的 attachments 并设置到 RpcContext</span></span><br><span class="line">        RpcContext.getServerContext().setObjectAttachments(appResponse.getObjectAttachments());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t, AbstractClusterInvoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZoneAwareClusterInterceptor"><a href="#ZoneAwareClusterInterceptor" class="headerlink" title="ZoneAwareClusterInterceptor"></a>ZoneAwareClusterInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determines the zone information of current request.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * active only when url has key 'cluster=zone-aware'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Activate</span>(value = <span class="string">"cluster:zone-aware"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAwareClusterInterceptor</span> <span class="keyword">implements</span> <span class="title">ClusterInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        RpcContext rpcContext = RpcContext.getContext();</span><br><span class="line">        <span class="comment">// 获取多注册中心相关参数并设置到 Invocation 中，主要是 registry_zone 参数和 registry_zone_force 参数</span></span><br><span class="line">        String zone = (String) rpcContext.getAttachment(REGISTRY_ZONE);</span><br><span class="line">        String force = (String) rpcContext.getAttachment(REGISTRY_ZONE_FORCE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测用户是否提供了ZoneDetector接口的扩展实现</span></span><br><span class="line">        ExtensionLoader&lt;ZoneDetector&gt; loader = ExtensionLoader.getExtensionLoader(ZoneDetector<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(zone) &amp;&amp; loader.hasExtension(<span class="string">"default"</span>)) &#123;</span><br><span class="line">            ZoneDetector detector = loader.getExtension(<span class="string">"default"</span>);</span><br><span class="line">            zone = detector.getZoneOfCurrentRequest(invocation);</span><br><span class="line">            force = detector.isZoneForcingEnabled(invocation, zone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将registry_zone参数和registry_zone_force参数设置到Invocation中</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(zone)) &#123;</span><br><span class="line">            invocation.setAttachment(REGISTRY_ZONE, zone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(force)) &#123;</span><br><span class="line">            invocation.setAttachment(REGISTRY_ZONE_FORCE, force);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，只有当 URL 中存在 <code>key = cluster=zone-aware</code> 时 <code>ZoneAwareClusterInterceptor</code> 才会激活。该拦截器主要是将多注册中心相关的参数设置到 Invocation 中，为 <code>ZoneAwareClusterInvoker</code> 服务。</p>
<h2 id="AbstractClusterInvoker"><a href="#AbstractClusterInvoker" class="headerlink" title="AbstractClusterInvoker"></a>AbstractClusterInvoker</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractClusterInvoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重要- Directory[RegistryDirectory]，通过它，可以获得所有服务提供者的Invoker对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Directory&lt;T&gt; directory;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群时是否排除非可用的Invoker，默认为true。通过 cluster.availablecheck 配置项设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> availablecheck;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经销毁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 粘滞连接 Invoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Invoker&lt;T&gt; stickyInvoker = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(directory, directory.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (directory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service directory == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">        <span class="comment">// sticky: invoker.isAvailable() should always be checked before using when availablecheck is true.</span></span><br><span class="line">        <span class="keyword">this</span>.availablecheck = url.getParameter(Constants.CLUSTER_AVAILABLE_CHECK_KEY, Constants.DEFAULT_CLUSTER_AVAILABLE_CHECK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面对 <code>AbstractClusterInvoker</code> 中的核心属性进行说明：</strong></p>
<ul>
<li><strong>directory</strong><blockquote>
<p>服务目录，可以获取所有提供者对应的 Invoker 集合。</p>
</blockquote>
</li>
<li><strong>availablecheck</strong><blockquote>
<p>集群时是否排除非可用的 Invoker，默认为 true，可通过 cluster.availablecheck 配置项设置.</p>
</blockquote>
</li>
<li><strong>destroyed</strong><blockquote>
<p>标记当前 Cluster Invoker 是否已销毁。</p>
</blockquote>
</li>
<li><strong>stickyInvoker</strong><blockquote>
<ol>
<li>粘滞连接用于有状态服务，尽可能让<strong>客户端</strong>总是向同一提供者发起调用，除非该提供者挂了，再连另一台。粘滞连接将自动开启延迟连接，以减少长连接数。</li>
<li>配置：<code>&lt;dubbo:reference stick=&quot;true&quot;/&gt;</code> 或 <code>&lt;dubbo:reference&gt; &lt;dubbo:method name=&quot;&quot; sticky=&quot;true&quot;&gt;&lt;/dubbo:method&gt;&lt;/dubbo:reference&gt;</code></li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="判断-Cluster-Invoker-状态"><a href="#判断-Cluster-Invoker-状态" class="headerlink" title="判断 Cluster Invoker 状态"></a>判断 Cluster Invoker 状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractClusterInvoker</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断 Cluster Invoker 是否可用</span></span><br><span class="line"><span class="comment">     * 1. 如果存在粘滞 Invoker，则基于该 Invoker 进行判断</span></span><br><span class="line"><span class="comment">     * 2. 如果不存在粘滞 Invoker，则基于 Directory 判断</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Invoker&lt;T&gt; invoker = stickyInvoker;</span><br><span class="line">        <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.isAvailable();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> directory.isAvailable();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取-Invoker-列表"><a href="#获取-Invoker-列表" class="headerlink" title="获取 Invoker 列表"></a>获取 Invoker 列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractClusterInvoker</span><br><span class="line">  <span class="keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">       <span class="keyword">return</span> directory.list(invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="invoke-调用"><a href="#invoke-调用" class="headerlink" title="invoke() 调用"></a>invoke() 调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractClusterInvoker</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 检查当前 Cluster Invoker 是否已销毁</span></span><br><span class="line">        checkWhetherDestroyed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 将 RpcContext 中的 attachments 添加到 invocation 中</span></span><br><span class="line">        Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">        <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            ((RpcInvocation) invocation).addObjectAttachments(contextAttachments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 通过 Directory 获取 Invoker 列表</span></span><br><span class="line">        <span class="comment">// 注意，该 Invoker 列表是已经经过 Router 过滤后的结果</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 通过 SPI 加载 LoadBalance</span></span><br><span class="line">        <span class="comment">// 4.1 如果 Invoker 列表不为空，则根据第一个 Invoker的URL和调用信息初始化</span></span><br><span class="line">        <span class="comment">// 4.2 如果 Invoker 列表为空，则使用默认的负载均衡器</span></span><br><span class="line">        LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 如果是异步操作，则添加一个 id 调用编号到 invocation 的 attachment 中</span></span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 执行调用逻辑，由子类实现</span></span><br><span class="line">        <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>AbstractClusterInvoker</code> 的 <code>invoke</code> 方法主要做以下工作：</strong></p>
<ol>
<li>检查当前 Cluster Invoker 的状态，如果处于销毁状态，则不可调用。</li>
<li>从上下文中取出隐式参数，然后设置到调用信息 Invocation 中。</li>
<li>从服务目录中获取 Invoker 列表，<strong>注意是经过 Router 过滤后的结果</strong>。</li>
<li>初始化 LoadBalance ，子类将会使用该负载均衡器选择目标 Invoker 。</li>
<li>对异步操作进行处理，添加一个调用编号到调用信息中</li>
<li>子类实现选择目标 Invoker 并调用逻辑。</li>
</ol>
<p><code>AbstractClusterInvoker.invoke</code> 逻辑就是为选择和调用目标 Invoker 作准备的，具体地选择和调用目标 Invoker 由子类实现。 </p>
<h3 id="通用选择方法"><a href="#通用选择方法" class="headerlink" title="通用选择方法"></a>通用选择方法</h3><p><code>AbstractClusterInvoker</code> 并没有简单粗暴地直接使用负载均衡完成选择逻辑，而是做了进一步的封装。<strong>在效率方面使用了粘滞连接的特性，在正确性方面使用了重新选择的方式来尽最大努力确保选出的 Invoker 是可用的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractClusterInvoker</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadbalance 负载均衡器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation  调用信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers    候选的 Invoker 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selected    已选择过的 Invoker 集合（注意，不是所有的集群策略都会传该值，不关心的将会传 null）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标 Invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 候选 Invoker 列表为空，直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取调用方法名</span></span><br><span class="line">        String methodName = invocation == <span class="keyword">null</span> ? StringUtils.EMPTY_STRING : invocation.getMethodName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取 sticky 配置项，优先方法级别的</span></span><br><span class="line">        <span class="comment">// sticky 表示粘滞连接，所谓粘滞连接是指 Consumer 会尽可能地调用同一个Provider节点，除非这个Provider无法提供服务</span></span><br><span class="line">        <span class="keyword">boolean</span> sticky = invokers.get(<span class="number">0</span>).getUrl()</span><br><span class="line">                .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 检测候选 Invoker 列表是否包含 sticky Invoker。</span></span><br><span class="line">        <span class="comment">// 如果不包含，说明缓存的 sticky Invoker 是不可用的，需要将其置空</span></span><br><span class="line">        <span class="keyword">if</span> (stickyInvoker != <span class="keyword">null</span> &amp;&amp; !invokers.contains(stickyInvoker)) &#123;</span><br><span class="line">            stickyInvoker = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 开启了粘滞连接特性 &amp; sticky Invoker 存在且没有被选择过 &amp; sticky Invoker 可用</span></span><br><span class="line">        <span class="keyword">if</span> (sticky &amp;&amp; <span class="comment">// 开启粘滞连接特性</span></span><br><span class="line">                stickyInvoker != <span class="keyword">null</span> &amp;&amp; <span class="comment">// sticky Invoker 不为空</span></span><br><span class="line">                (selected == <span class="keyword">null</span> || !selected.contains(stickyInvoker))) &#123; <span class="comment">// sticky Invoker 未被选择过</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测当前 stickyInvoker 是否可用，如果可用，直接返回 sticky Invoker</span></span><br><span class="line">            <span class="keyword">if</span> (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> stickyInvoker;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 sticky Invoker 为空或不可用，则执行选择 Invoker 逻辑</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = doSelect(loadbalance, invocation, invokers, selected);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 如果开启粘滞连接特性，则更新 stickyInvoker 字段</span></span><br><span class="line">        <span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">            stickyInvoker = invoker;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>select()</code> 方法中会根据配置决定是否开启粘滞连接特性，如果开启了，则会将上次选择出的 Invoker 缓存起来，只要该粘滞 Invoker 可用就直接使用，不会再进行负载均衡。该方法主要是处理粘滞连接特性。</p>
<p>下面我们继续分析 <code>doSelect()</code> 方法，该方法才会使用负载均衡器选择目标 Invoker，并尽最大努力确保选出的 Invoker 是可用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractClusterInvoker</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadbalance 负载均衡对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation  调用信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers    候选的 Invoker 列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selected    已选过的 Invoker 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 判断是否需要负载均衡，Invoker 集合为空，则直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 候选 Invoker 仅有一个，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用负载均衡器选择目标 Invoker</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = loadbalance.select(invokers, getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//If the `invoker` is in the  `selected` or invoker is unavailable &amp;&amp; availablecheck is true, reselect.</span></span><br><span class="line">        <span class="comment">// 4 对负载均衡选出的 Invoker 进行校验，决定是否重新选择</span></span><br><span class="line">        <span class="keyword">if</span> ((selected != <span class="keyword">null</span> &amp;&amp; selected.contains(invoker)) <span class="comment">// 选出的 Invoker 已经被选择过</span></span><br><span class="line">                || (!invoker.isAvailable() &amp;&amp; getUrl() != <span class="keyword">null</span> &amp;&amp; availablecheck)) &#123; <span class="comment">// 选出的 Invoker 不可用</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 4.1 重新进行一次负载均衡</span></span><br><span class="line">                Invoker&lt;T&gt; rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);</span><br><span class="line">                <span class="comment">// 4.2 如果重新选择的 Invoker 对象不为空，则直接使用该 Invoker</span></span><br><span class="line">                <span class="keyword">if</span> (rInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    invoker = rInvoker;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.3 如果重新选择的Invoker为空，就进行容错，无论如何都要选出一个</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.4 第一次选的Invoker如果不是候选Invoker列表中最后一个就选它的下一个，否则就使用候选Invoker列表中的第一个。进行兜底，保证能够获取到一个Invoker</span></span><br><span class="line">                    <span class="keyword">int</span> index = invokers.indexOf(invoker);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//Avoid collision</span></span><br><span class="line">                        invoker = invokers.get((index + <span class="number">1</span>) % invokers.size());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.warn(e.getMessage() + <span class="string">" may because invokers list dynamic change, ignore."</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.error(<span class="string">"cluster reselect fail reason is :"</span> + t.getMessage() + <span class="string">" if can not solve, you can set cluster.availablecheck=false in url"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>doSelect()</code> 方法主要做了两件事，其一是通过 LoadBalance 选择 Invoker 对象；其二是如果选出来的 Invoker 不稳定或不可用，会调用 <code>reselect()</code> 方法进行重选。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractClusterInvoker</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reselect, use invokers not in `selected` first, if all invokers are in `selected`,</span></span><br><span class="line"><span class="comment">     * just pick an available one using loadbalance policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadbalance    负载均衡器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation     调用信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers       候选 Invoker 列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selected       已选过的 Invoker 列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> availablecheck 可用性检查</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标 Invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">reselect</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected, <span class="keyword">boolean</span> availablecheck)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 预先分配一个列表</span></span><br><span class="line">        <span class="comment">// 注意：这个列表大小比候选的 Invoker列表大小小 1，因为候选Invoker列表中的Invoker可能在selected中或者不可用，从上一步结果可知。</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; reselectInvokers = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">                invokers.size() &gt; <span class="number">1</span> ? (invokers.size() - <span class="number">1</span>) : invokers.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 将不在 selected 集合中且是可用状态的 Invoker 过滤出来参与负载均衡</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (availablecheck &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (selected == <span class="keyword">null</span> || !selected.contains(invoker)) &#123;</span><br><span class="line">                reselectInvokers.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 reselectInvokers 不为空时，才需要通过负载均衡组件进行选择</span></span><br><span class="line">        <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 线程走到这里，说明 reselectInvokers 集合为空。这时需要兜底，从已经选择过的Invoker列表中选择可用的Invoker列表，然后通过负载均衡器选择一个目标的Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (selected != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((invoker.isAvailable()) <span class="comment">// available first</span></span><br><span class="line">                        &amp;&amp; !reselectInvokers.contains(invoker)) &#123;</span><br><span class="line">                    reselectInvokers.add(invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 实在选不出来，只能返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>reselect</code> 方法会重新进行一次负载均衡，首先会对未尝试过的且可用状态的 Invoker 列表进行负载均衡，选出最终的 Invoker 对象并返回。如果没有可尝试的 Invoker ，则进行兜底操作，只能对尝试过的且是可用状态的 Invoker 列表重新进行负载均衡，选出目标 Invoker 对象。</p>
<p>至此，通用的 <code>Cluster</code> 和 <code>Cluster Invoker</code> 逻辑已经介绍完了，下面我们就来分析 Dubbo 中的具体集群策略。</p>
<h2 id="FailoverCluster-amp-FailoverClusterInvoker"><a href="#FailoverCluster-amp-FailoverClusterInvoker" class="headerlink" title="FailoverCluster &amp; FailoverClusterInvoker"></a>FailoverCluster &amp; FailoverClusterInvoker</h2><p><code>FailoverCluster</code> 用于创建 <code>FailoverClusterInvoker</code> 对象，<code>FailoverClusterInvoker</code> 实现了调用失败自动切换的逻辑。</p>
<h3 id="FailoverCluster"><a href="#FailoverCluster" class="headerlink" title="FailoverCluster"></a>FailoverCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failover"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 FailoverClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailoverClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FailoverClusterInvoker"><a href="#FailoverClusterInvoker" class="headerlink" title="FailoverClusterInvoker"></a>FailoverClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FailoverClusterInvoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailoverClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;</span><br><span class="line">        <span class="comment">// 1 检查候选 Invoker 列表是否为空</span></span><br><span class="line">        checkInvokers(copyInvokers, invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取调用方法名</span></span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取配置的重试次数，默认重试 2 次，总共执行 3 次</span></span><br><span class="line">        <span class="keyword">int</span> len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 准备调用记录属性</span></span><br><span class="line">        <span class="comment">// 记录最后一次调用异常（如果有的情况下）</span></span><br><span class="line">        RpcException le = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 记录已经调用过的 Invoker</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size());</span><br><span class="line">        <span class="comment">// 记录负载均衡选出来的 Invoker 的网络地址</span></span><br><span class="line">        Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 如果出现调用失败，则重试其他服务。这是该集群容错机制的核心。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 第一次传进来的 invokers 已经check过了，第二次则是重试，需要重新获取最新的服务列表</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查当前 ClusterInvoker 是否可用</span></span><br><span class="line">                checkWhetherDestroyed();</span><br><span class="line">                <span class="comment">// 重新从服务目录中拉取 Invoker 列表</span></span><br><span class="line">                copyInvokers = list(invocation);</span><br><span class="line">                <span class="comment">// 检查 copyInvokers ，防止服务目录中的 Invoker 列表为空</span></span><br><span class="line">                checkInvokers(copyInvokers, invocation);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 LoadBalance 选择 Invoker 对象，这里传入 invoked 集合</span></span><br><span class="line">            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">            <span class="comment">// 记录此次尝试调用的 Invoker ，之后非兜底情况会过滤掉该 Invoker </span></span><br><span class="line">            invoked.add(invoker);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存已选过的 Invoker 到上下文</span></span><br><span class="line">            RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// RPC 调用</span></span><br><span class="line">                Result result = invoker.invoke(invocation);</span><br><span class="line">                <span class="comment">// 经过重试之后，成功了。这里会打印最后一次调用的异常信息。</span></span><br><span class="line">                <span class="keyword">if</span> (le != <span class="keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Although retry the method "</span> + methodName</span><br><span class="line">                            + <span class="string">" in the service "</span> + getInterface().getName()</span><br><span class="line">                            + <span class="string">" was successful by the provider "</span> + invoker.getUrl().getAddress()</span><br><span class="line">                            + <span class="string">", but there have been failed providers "</span> + providers</span><br><span class="line">                            + <span class="string">" ("</span> + providers.size() + <span class="string">"/"</span> + copyInvokers.size()</span><br><span class="line">                            + <span class="string">") from the registry "</span> + directory.getUrl().getAddress()</span><br><span class="line">                            + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost()</span><br><span class="line">                            + <span class="string">" using the dubbo version "</span> + Version.getVersion() + <span class="string">". Last error is: "</span></span><br><span class="line">                            + le.getMessage(), le);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                <span class="comment">// 如果是业务性质的异常，则不再重试，直接抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                le = e;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 其他异常同一封装成 RpcException，表示此次尝试失败，会进行重试。</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 记录尝试过的提供者的地址</span></span><br><span class="line">                providers.add(invoker.getUrl().getAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 达到重试次数上限后仍然调用失败的话，就抛出异常。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(le.getCode(), <span class="string">"Failed to invoke the method "</span></span><br><span class="line">                + methodName + <span class="string">" in the service "</span> + getInterface().getName()</span><br><span class="line">                + <span class="string">". Tried "</span> + len + <span class="string">" times of the providers "</span> + providers</span><br><span class="line">                + <span class="string">" ("</span> + providers.size() + <span class="string">"/"</span> + copyInvokers.size()</span><br><span class="line">                + <span class="string">") from the registry "</span> + directory.getUrl().getAddress()</span><br><span class="line">                + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" using the dubbo version "</span></span><br><span class="line">                + Version.getVersion() + <span class="string">". Last error is: "</span></span><br><span class="line">                + le.getMessage(), le.getCause() != <span class="keyword">null</span> ? le.getCause() : le);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FailoverClusterInvoker</code> 的 <code>doInvoke</code> 方法首先是获取重试次数，然后根据重试次数进行循环调用，失败后进行重试。在循环逻辑中，先根据负载均衡器选择一个 Invoker，然后再通过这个 Invoker 进行远程调用。如果失败了，记录下异常，并进行重试，直到达到最大重试次数。注意，每次进行重试时都会重新从服务目录中拉取 Invoker 列表防止脏数据，并且会进行一次负载均衡处理。</p>
<h2 id="FailbackCluster-amp-FailbackClusterInvoker"><a href="#FailbackCluster-amp-FailbackClusterInvoker" class="headerlink" title="FailbackCluster &amp; FailbackClusterInvoker"></a>FailbackCluster &amp; FailbackClusterInvoker</h2><p><code>FailbackCluster</code> 用于创建 <code>FailbackClusterInvoker</code> 对象，<code>FailbackClusterInvoker</code> 会在调用失败后返回一个空结果给服务消费端，并通过定时任务对失败的调用进行重试，注意，服务消费端已经收到了空的结果，虽然定时重试，但是和调用方已经无关了。</p>
<h3 id="FailbackCluster"><a href="#FailbackCluster" class="headerlink" title="FailbackCluster"></a>FailbackCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failback"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 FailbackClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailbackClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FailbackClusterInvoker"><a href="#FailbackClusterInvoker" class="headerlink" title="FailbackClusterInvoker"></a>FailbackClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FailbackClusterInvoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RETRY_FAILED_PERIOD = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败重试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> retries;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败任务数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> failbackTasks;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Timer failTimer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailbackClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">        <span class="comment">// 1 获取 retries 配置项，即请求失败重试次数，默认 3 次</span></span><br><span class="line">        <span class="keyword">int</span> retriesConfig = getUrl().getParameter(RETRIES_KEY, DEFAULT_FAILBACK_TIMES);</span><br><span class="line">        <span class="keyword">if</span> (retriesConfig &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            retriesConfig = DEFAULT_FAILBACK_TIMES;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 失败重试的任务数，默认 100</span></span><br><span class="line">        <span class="keyword">int</span> failbackTasksConfig = getUrl().getParameter(FAIL_BACK_TASKS_KEY, DEFAULT_FAILBACK_TASKS);</span><br><span class="line">        <span class="keyword">if</span> (failbackTasksConfig &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            failbackTasksConfig = DEFAULT_FAILBACK_TASKS;</span><br><span class="line">        &#125;</span><br><span class="line">        retries = retriesConfig;</span><br><span class="line">        failbackTasks = failbackTasksConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        Invoker&lt;T&gt; invoker = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 检查候选 Invoker 列表是否为空</span></span><br><span class="line">            checkInvokers(invokers, invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 使用 LoadBalance 选择 Invoker 对象，这里传入 invoked 集合</span></span><br><span class="line">            invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 RPC 调用</span></span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failback to invoke method "</span> + invocation.getMethodName() + <span class="string">", wait for retry in background. Ignored exception: "</span></span><br><span class="line">                    + e.getMessage() + <span class="string">", "</span>, e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 调用失败后，添加一个定时任务进行定时重试</span></span><br><span class="line">            addFailed(loadbalance, invocation, invokers, invoker);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 返回一个空结果</span></span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, <span class="keyword">null</span>, invocation); <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加失败重试定时任务。默认每隔 5s 执行一次，总共重试 3 次。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadbalance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastInvoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFailed</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, Invoker&lt;T&gt; lastInvoker)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 初始化时间轮</span></span><br><span class="line">        <span class="keyword">if</span> (failTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (failTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    failTimer = <span class="keyword">new</span> HashedWheelTimer(</span><br><span class="line">                            <span class="keyword">new</span> NamedThreadFactory(<span class="string">"failback-cluster-timer"</span>, <span class="keyword">true</span>),</span><br><span class="line">                            <span class="number">1</span>,</span><br><span class="line">                            TimeUnit.SECONDS, <span class="number">32</span>, failbackTasks);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建重试定时任务</span></span><br><span class="line">        RetryTimerTask retryTimerTask = <span class="keyword">new</span> RetryTimerTask(loadbalance, invocation, invokers, lastInvoker, retries, RETRY_FAILED_PERIOD);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3 将定时任务加载到时间轮中</span></span><br><span class="line">            failTimer.newTimeout(retryTimerTask, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failback background works error,invocation-&gt;"</span> + invocation + <span class="string">", exception: "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>FailbackClusterInvoker</code> 主要逻辑如下：</p>
<ol>
<li>使用 LoadBalance 选择一个 Invoker 对象（存在可用的粘滞 Invoker 就不需要负载均衡了）</li>
<li>使用选出的 Invoker 进行 RPC 调用，如果调用成功则直接返回，也就没有重试的事了</li>
<li>调用失败后，通过 <code>addFailed</code> 方法创建一个失败重试的定时任务，重试任务默认会每隔 5s 执行一次，最多重试 3 次。并且，每次重试都会重新选择 Invoker 。</li>
<li>调用失败后，会返回一个空结果。</li>
</ol>
<p>了解了 <code>FailbackClusterInvoker</code> 逻辑后，我们继续对重试逻辑进行说明。</p>
<h4 id="RetryTimerTask"><a href="#RetryTimerTask" class="headerlink" title="RetryTimerTask"></a>RetryTimerTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryTimerTask</span> <span class="keyword">implements</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Invocation invocation;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> LoadBalance loadbalance;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> retries;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> tick;</span><br><span class="line">      <span class="keyword">private</span> Invoker&lt;T&gt; lastInvoker;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> retryTimes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      RetryTimerTask(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, Invoker&lt;T&gt; lastInvoker, <span class="keyword">int</span> retries, <span class="keyword">long</span> tick) &#123;</span><br><span class="line">          <span class="keyword">this</span>.loadbalance = loadbalance;</span><br><span class="line">          <span class="keyword">this</span>.invocation = invocation;</span><br><span class="line">          <span class="keyword">this</span>.invokers = invokers;</span><br><span class="line">          <span class="keyword">this</span>.retries = retries;</span><br><span class="line">          <span class="keyword">this</span>.tick = tick;</span><br><span class="line">          <span class="keyword">this</span>.lastInvoker = lastInvoker;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 重新选择 Invoker 对象，这里会将上次重试失败的 Invoker 作为 selected 集合传入</span></span><br><span class="line">              Invoker&lt;T&gt; retryInvoker = select(loadbalance, invocation, invokers, Collections.singletonList(lastInvoker));</span><br><span class="line">              lastInvoker = retryInvoker;</span><br><span class="line">              <span class="comment">// RPC 调用</span></span><br><span class="line">              retryInvoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// RPC 调用失败时才会尝试重试</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">              logger.error(<span class="string">"Failed retry to invoke method "</span> + invocation.getMethodName() + <span class="string">", waiting again."</span>, e);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 重试次数未达到上限，才会重新添加定时任务，然后等待重试</span></span><br><span class="line">              <span class="keyword">if</span> ((++retryTimes) &gt;= retries) &#123;</span><br><span class="line">                  logger.error(<span class="string">"Failed retry times exceed threshold ("</span> + retries + <span class="string">"), We have to abandon, invocation-&gt;"</span> + invocation);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  rePut(timeout);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 重新添加，等待重试</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rePut</span><span class="params">(Timeout timeout)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Timer timer = timeout.timer();</span><br><span class="line">          <span class="keyword">if</span> (timer.isStop() || timeout.isCancelled()) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          timer.newTimeout(timeout.task(), tick, TimeUnit.SECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="FailfastCluster-amp-FailfastClusterInvoker"><a href="#FailfastCluster-amp-FailfastClusterInvoker" class="headerlink" title="FailfastCluster &amp; FailfastClusterInvoker"></a>FailfastCluster &amp; FailfastClusterInvoker</h2><p><code>FailfastCluster</code> 用于创建 <code>FailfastClusterInvoker</code> 对象，<code>FailfastClusterInvoker</code> 只会进行一次调用，失败后立即抛出异常，这种策略适合非幂等的操作。</p>
<h3 id="FailfastCluster"><a href="#FailfastCluster" class="headerlink" title="FailfastCluster"></a>FailfastCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailfastCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failfast"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 FailfastClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailfastClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FailfastClusterInvoker"><a href="#FailfastClusterInvoker" class="headerlink" title="FailfastClusterInvoker"></a>FailfastClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailfastClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailfastClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 检测候选 Invoker 列表是否为空</span></span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 使用 LoadBalance 选择 Invoker 对象</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 RPC 调用</span></span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 请求失败，直接抛出异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RpcException &amp;&amp; ((RpcException) e).isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                <span class="keyword">throw</span> (RpcException) e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e <span class="keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="number">0</span>,</span><br><span class="line">                    <span class="string">"Failfast invoke providers "</span> + invoker.getUrl() + <span class="string">" "</span> + loadbalance.getClass().getSimpleName()</span><br><span class="line">                            + <span class="string">" select from all providers "</span> + invokers + <span class="string">" for service "</span> + getInterface().getName()</span><br><span class="line">                            + <span class="string">" method "</span> + invocation.getMethodName() + <span class="string">" on consumer "</span> + NetUtils.getLocalHost()</span><br><span class="line">                            + <span class="string">" use dubbo version "</span> + Version.getVersion()</span><br><span class="line">                            + <span class="string">", but no luck to perform the invocation. Last error is: "</span> + e.getMessage(),</span><br><span class="line">                    e.getCause() != <span class="keyword">null</span> ? e.getCause() : e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FailsafeCluster-amp-FailsafeClusterInvoker"><a href="#FailsafeCluster-amp-FailsafeClusterInvoker" class="headerlink" title="FailsafeCluster &amp; FailsafeClusterInvoker"></a>FailsafeCluster &amp; FailsafeClusterInvoker</h2><p><code>FailsafeCluster</code> 用于创建 <code>FailsafeClusterInvoker</code> 对象，<code>FailsafeClusterInvoker</code> 是一种失败安全的 <code>Cluster Invoker</code> 。所谓失败安全指的是，当调用过程出现异常时，<code>FailsafeClusterInvoker</code> 仅会打印异常日志，而不会抛出异常，代替的是返回一个空间结果。</p>
<h3 id="FailsafeCluster"><a href="#FailsafeCluster" class="headerlink" title="FailsafeCluster"></a>FailsafeCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailsafeCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failsafe"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 FailsafeClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailsafeClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FailsafeClusterInvoker"><a href="#FailsafeClusterInvoker" class="headerlink" title="FailsafeClusterInvoker"></a>FailsafeClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailsafeClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FailsafeClusterInvoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailsafeClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 检测候选 Invoker 列表是否为空</span></span><br><span class="line">            checkInvokers(invokers, invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 使用 LoadBalance 选择 Invoker 对象</span></span><br><span class="line">            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 RPC 调用</span></span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failsafe ignore exception: "</span> + e.getMessage(), e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 调用异常，直接返回一个空结果，不会抛出异常</span></span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, <span class="keyword">null</span>, invocation); <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ForkingCluster-amp-ForkingClusterInvoker"><a href="#ForkingCluster-amp-ForkingClusterInvoker" class="headerlink" title="ForkingCluster &amp; ForkingClusterInvoker"></a>ForkingCluster &amp; ForkingClusterInvoker</h2><p><code>ForkingCluster</code> 用于创建 <code>ForkingClusterInvoker</code> 对象，<code>ForkingClusterInvoker</code> 支持并发调用多个服务提供者，只要有一个服务提供者成功返回了结果，就会立即结束运行。</p>
<h3 id="ForkingCluster"><a href="#ForkingCluster" class="headerlink" title="ForkingCluster"></a>ForkingCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkingCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"forking"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ForkingClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkingClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ForkingClusterInvoker"><a href="#ForkingClusterInvoker" class="headerlink" title="ForkingClusterInvoker"></a>ForkingClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkingClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行多个 Invoker RPC 调用的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = Executors.newCachedThreadPool(</span><br><span class="line">            <span class="keyword">new</span> NamedInternalThreadFactory(<span class="string">"forking-cluster-timer"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkingClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 检查候选 Invoker 集合是否为空</span></span><br><span class="line">            checkInvokers(invokers, invocation);</span><br><span class="line">            <span class="comment">// 保存选择的 Invoker</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; selected;</span><br><span class="line">            <span class="comment">// 获取 forks 配置项，即并行数，默认为 2</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> forks = getUrl().getParameter(FORKS_KEY, DEFAULT_FORKS);</span><br><span class="line">            <span class="comment">// 获取 timeout 配置项，即超时时间，默认为 1000 毫秒</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> timeout = getUrl().getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 最大并行数 &lt;= 0 或者 &gt;= Invoker 数，则选择所有的 Invoker</span></span><br><span class="line">            <span class="keyword">if</span> (forks &lt;= <span class="number">0</span> || forks &gt;= invokers.size()) &#123;</span><br><span class="line">                selected = invokers;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3 根据并行数，选择此次并发调用的 Invoker</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                selected = <span class="keyword">new</span> ArrayList&lt;&gt;(forks);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环并行数，每次循环都要尝试选择一个 Invoker</span></span><br><span class="line">                <span class="comment">// 注意：可能最终得到的 Invoker 列表大小小于并发数</span></span><br><span class="line">                <span class="keyword">while</span> (selected.size() &lt; forks) &#123;</span><br><span class="line">                    Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, selected);</span><br><span class="line">                    <span class="comment">// 避免重复选择</span></span><br><span class="line">                    <span class="keyword">if</span> (!selected.contains(invoker)) &#123;</span><br><span class="line">                        <span class="comment">//Avoid add the same invoker several times.</span></span><br><span class="line">                        selected.add(invoker);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 将选中的 Invoker 列表设置到上下文中</span></span><br><span class="line">            RpcContext.getContext().setInvokers((List) selected);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录调用失败数</span></span><br><span class="line">            <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">            <span class="comment">// 记录请求的结果</span></span><br><span class="line">            <span class="keyword">final</span> BlockingQueue&lt;Object&gt; ref = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 遍历 selected ，将每个 Invoker 的 RPC 调用提交到线程池，并把结果放入到阻塞队列中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class="line">                executor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// RPC 调用</span></span><br><span class="line">                        Result result = invoker.invoke(invocation);</span><br><span class="line">                        <span class="comment">// 把调用结果放入到阻塞队列中</span></span><br><span class="line">                        ref.offer(result);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 调用失败</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        <span class="comment">// 记录调用失败数</span></span><br><span class="line">                        <span class="keyword">int</span> value = count.incrementAndGet();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果选择的 Invoker 全部调用失败，则把最后一次调用异常加入到阻塞队列</span></span><br><span class="line">                        <span class="comment">// 保证异常对象不会出现在正常结果的前面，这样可从阻塞队列中优先取出正常的结果</span></span><br><span class="line">                        <span class="keyword">if</span> (value &gt;= selected.size()) &#123;</span><br><span class="line">                            ref.offer(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 6 当前线程会阻塞等待任意一个调用结果，如果选择的 Invoker 全部调用失败，则会获取到一个异常结果。</span></span><br><span class="line">                Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">                    Throwable e = (Throwable) ret;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e <span class="keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="number">0</span>, <span class="string">"Failed to forking invoke provider "</span> + selected + <span class="string">", but no luck to perform the invocation. Last error is: "</span> + e.getMessage(), e.getCause() != <span class="keyword">null</span> ? e.getCause() : e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> (Result) ret;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to forking invoke provider "</span> + selected + <span class="string">", but no luck to perform the invocation. Last error is: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// clear attachments which is binding to current thread.</span></span><br><span class="line">            RpcContext.getContext().clearAttachments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ForkingClusterInvoker</code> 会在运行依据并行调用数通过线程池创建多个线程，并发调用多个服务提供者，只要有一个服务提供者成功返回了结果，就会立即结束运行。主要应用在一些对实时性要求比较高的读操作下使用，但这将会耗费更多的资源。需要注意的是，因为没有并发控制，并行写操作可能不安全。</p>
<p>主要逻辑如下：</p>
<ol>
<li>基于并行配置项 forks 的值选出合适数量的 Invoker，选出的 Invoker 数量小于等于并行数。</li>
<li>通过线程池并发调用步骤 1 中的多个 Invoker ，并将每个 Invoker 的调用结果暂存到阻塞队列中。</li>
<li>在阻塞队列中阻塞等待任意一个返回结果，并对返回结果类型进行判断，如果为异常类型，则直接抛出，否则返回。</li>
</ol>
<h2 id="BroadcastCluster-amp-BroadcastClusterInvoker"><a href="#BroadcastCluster-amp-BroadcastClusterInvoker" class="headerlink" title="BroadcastCluster &amp; BroadcastClusterInvoker"></a>BroadcastCluster &amp; BroadcastClusterInvoker</h2><p><code>BroadcastCluster</code> 用于创建 <code>BroadcastClusterInvoker</code> 对象，<code>BroadcastClusterInvoker</code> 会逐个调用每个服务提供者，其中任意一个服务提供者节点报错，都会在全部调用结束之后抛出异常。该类通常用于通知类的操作，如通知所有提供者更新缓存或日志等本地资源信息。</p>
<h3 id="BroadcastCluster"><a href="#BroadcastCluster" class="headerlink" title="BroadcastCluster"></a>BroadcastCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 BroadcastClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BroadcastClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BroadcastClusterInvoker"><a href="#BroadcastClusterInvoker" class="headerlink" title="BroadcastClusterInvoker"></a>BroadcastClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(BroadcastClusterInvoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BroadcastClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 检测 Invoker 列表是否为空</span></span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line">        RpcContext.getContext().setInvokers((List) invokers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于记录调用异常信息和调用结果</span></span><br><span class="line">        RpcException exception = <span class="keyword">null</span>;</span><br><span class="line">        Result result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的 Invoker 对象</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// RPC 请求</span></span><br><span class="line">                result = invoker.invoke(invocation);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                exception = e;</span><br><span class="line">                logger.warn(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                exception = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">                logger.warn(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AvailableCluster-amp-AvailableClusterInvoker"><a href="#AvailableCluster-amp-AvailableClusterInvoker" class="headerlink" title="AvailableCluster &amp; AvailableClusterInvoker"></a>AvailableCluster &amp; AvailableClusterInvoker</h2><p><code>AvailableCluster</code> 用于创建 <code>AvailableClusterInvoker</code> 对象，<code>AvailableClusterInvoker</code> 会遍历整个候选 Invoker 列表，会使用首个可用的 Invoker 进行调用，成功则返回结果，失败则抛出异常终止遍历。需要说明的是，该集群策略没有使用到负载均衡机制。</p>
<h3 id="AvailableCluster"><a href="#AvailableCluster" class="headerlink" title="AvailableCluster"></a>AvailableCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"available"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 AvailableClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AvailableClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AvailableClusterInvoker"><a href="#AvailableClusterInvoker" class="headerlink" title="AvailableClusterInvoker"></a>AvailableClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AvailableClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历整个候选 Invoker 列表</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 使用首个可用的 Invoker 进行调用</span></span><br><span class="line">            <span class="keyword">if</span> (invoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到可用的 Invoker，则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"No provider available in "</span> + invokers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ZoneAwareCluster-amp-ZoneAwareClusterInvoker"><a href="#ZoneAwareCluster-amp-ZoneAwareClusterInvoker" class="headerlink" title="ZoneAwareCluster &amp; ZoneAwareClusterInvoker"></a>ZoneAwareCluster &amp; ZoneAwareClusterInvoker</h2><p><code>ZoneAwareCluster</code> 用于创建 <code>ZoneAwareClusterInvoker</code> 对象，<code>ZoneAwareClusterInvoker</code> 主要优先支持注册中心层面 Invoker 的选择与调用。</p>
<h3 id="ZoneAwareCluster"><a href="#ZoneAwareCluster" class="headerlink" title="ZoneAwareCluster"></a>ZoneAwareCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAwareCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"zone-aware"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ZoneAwareClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareClusterInvoker&lt;T&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZoneAwareClusterInvoker"><a href="#ZoneAwareClusterInvoker" class="headerlink" title="ZoneAwareClusterInvoker"></a>ZoneAwareClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When there're more than one registry for subscription.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This extension provides a strategy to decide how to distribute traffics among them:</span></span><br><span class="line"><span class="comment"> * 1. registry marked as 'preferred=true' has the highest priority.</span></span><br><span class="line"><span class="comment"> * 2. check the zone the current request belongs, pick the registry that has the same zone first.</span></span><br><span class="line"><span class="comment"> * 3. Evenly balance traffic between all registries based on each registry's weight.</span></span><br><span class="line"><span class="comment"> * 4. Pick anyone that's available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAwareClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ZoneAwareClusterInvoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoneAwareClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -------------- 1 基于注册中心选择 Invoker ---------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1 优先找到 preferred 属性为 true 的注册中心，它是优先级最高的注册中心，只有该注册中心无可用 Provider 节点时，才会回落到其他注册中心</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// FIXME, the invoker is a cluster invoker representing one Registry, so it will automatically wrapped by MockClusterInvoker.</span></span><br><span class="line">            MockClusterInvoker&lt;T&gt; mockClusterInvoker = (MockClusterInvoker&lt;T&gt;) invoker;</span><br><span class="line">            <span class="keyword">if</span> (mockClusterInvoker.isAvailable() &amp;&amp; mockClusterInvoker.getRegistryUrl()</span><br><span class="line">                    .getParameter(REGISTRY_KEY + <span class="string">"."</span> + PREFERRED_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mockClusterInvoker.invoke(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2 候选的 Invoker 都不在 preferred 属性为 true 的注册中心上，则根据请求中的 zone key 信息，查找该注册中下的 Invoker</span></span><br><span class="line">        String zone = (String) invocation.getAttachment(REGISTRY_ZONE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(zone)) &#123;</span><br><span class="line">            <span class="comment">// 遍历候选的 Invoker 列表</span></span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">                MockClusterInvoker&lt;T&gt; mockClusterInvoker = (MockClusterInvoker&lt;T&gt;) invoker;</span><br><span class="line">                <span class="comment">// 根据请求中的 registry_zone 做匹配，选择相同 zone 的注册中心下的 Invoker</span></span><br><span class="line">                <span class="keyword">if</span> (mockClusterInvoker.isAvailable() &amp;&amp; zone.equals(mockClusterInvoker.getRegistryUrl().getParameter(REGISTRY_KEY + <span class="string">"."</span> + ZONE_KEY))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mockClusterInvoker.invoke(invocation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否强制匹配</span></span><br><span class="line">            String force = (String) invocation.getAttachment(REGISTRY_ZONE_FORCE);</span><br><span class="line">            <span class="comment">// 如果强制匹配，只匹配和请求中具有相同 zone 的注册中心下提供者，如果没有匹配到，则抛出异常。如果不是强制匹配，则使用负载均衡选择 Invoker</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(force) &amp;&amp; <span class="string">"true"</span>.equalsIgnoreCase(force)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No registry instance in zone or no available providers in the registry, zone: "</span></span><br><span class="line">                        + zone</span><br><span class="line">                        + <span class="string">", registries: "</span> + invokers.stream().map(invoker -&gt; ((MockClusterInvoker&lt;T&gt;) invoker).getRegistryUrl().toString()).collect(Collectors.joining(<span class="string">","</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------------------ 2 根据负载均衡选择 Invoker  ------------------/</span></span><br><span class="line">        Invoker&lt;T&gt; balancedInvoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (balancedInvoker.isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">return</span> balancedInvoker.invoke(invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------------------ 3 以上两种都没有选中 Invoker ，则从候选 Invoker 列表中选择一个可用的即可 --------------/</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            MockClusterInvoker&lt;T&gt; mockClusterInvoker = (MockClusterInvoker&lt;T&gt;) invoker;</span><br><span class="line">            <span class="keyword">if</span> (mockClusterInvoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> mockClusterInvoker.invoke(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"No provider available in "</span> + invokers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Dubbo 中使用多个注册中心的情况，服务消费端可以使用 <code>ZoneAwareClusterInvoker</code> 先在多个注册中心之间选择，确定注册中心之后，再选择服务提供者节点。</p>
<p><code>ZoneAwareClusterInvoker</code> 选择目标 Invoker 的流程如下：</p>
<ol>
<li>优先找到 <code>preferred</code> 属性为 true 的注册中心下的 Invoker，只有该中心无可用 Invoker 时，才会去匹配其他注册中心下的 Invoker 。</li>
<li>根据请求中的 <code>zone</code> 信息（注册中心信息）做匹配，如果候选 Invoker 中有匹配到该注册中心信息，则选中对应的 Invoker 。</li>
<li>无法根据注册中心信息匹配到目标 Invoker，则使用负载均衡选出目标 Invoker 。</li>
<li>如果以上流程都没有选择出 Invoker，则从候选 Invoker 列表中选出第一个可用的 Invoker 。</li>
</ol>
<p>注意，前文中介绍的 <code>ZoneAwareClusterInterceptor</code> 会在前置处理方法中设置 <code>registry_zone</code> 参数和 <code>registry_zone_force</code> 参数到调用信息 Invocation 中，</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章详细分析了 Dubbo 集群容错的几种实现方式。集群模块处于服务提供者和消费者之间，对于服务消费者来说，集群可向其屏蔽服务提供者集群的情况，使其能够专心进行远程调用。需要说明是，集群模块还包括 <code>Merger</code> 策略以及 <code>Mock</code> 机制，相比本篇文章介绍的几种常见集群策略，它们具有特定地功能机制，在后面的两篇文章中将会详细介绍。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/7f19ea26/" title="集群容错 - Cluster" target="_blank" rel="external">https://gentryhuang.com/posts/7f19ea26/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/1d657bdb/" title="集群容错 - Merger"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/9966fbd5/" title="集群容错 - LoadBalance"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2021 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>