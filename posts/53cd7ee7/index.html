<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Dubbo源码分析 - 网络传输层 | gentryhuang的博客</title>
  <meta name="description" content="前言在 远程通信模块总览 中对 Remoting 层进行了总体说明，下面我们开始详细介绍 Remoting 层的 Transport 网络传输层。本文会从 Transporter 层的 Server、Client、Channel、ChannelHandler、Dispatcher 以及 Codec2 等核心接口出发，分别介绍这些核心接口的实现。 概述有很多网络库可以实现网络传输的功能，如 Nett">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo源码分析 - 网络传输层">
<meta property="og:url" content="https://gentryhuang.com/posts/53cd7ee7/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="前言在 远程通信模块总览 中对 Remoting 层进行了总体说明，下面我们开始详细介绍 Remoting 层的 Transport 网络传输层。本文会从 Transporter 层的 Server、Client、Channel、ChannelHandler、Dispatcher 以及 Codec2 等核心接口出发，分别介绍这些核心接口的实现。 概述有很多网络库可以实现网络传输的功能，如 Nett">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-outline.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-api.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-server.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-client.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-abstractpeer-hierarchy.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-abstractchannel-hierarchy.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-channelhandler.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-channelhandler-dispatcher.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-threadpool-model.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-codec-hierarchy.jpg">
<meta property="article:published_time" content="2020-05-22T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-15T02:10:06.551Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="Dubbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-outline.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/53cd7ee7/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.14px;">AQS</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.71px;">Filter</a> <a href="/tags/I-O/" style="font-size: 13.14px;">I/O</a> <a href="/tags/JUC/" style="font-size: 13.43px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.29px;">Javassist</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.29px;">Protocol</a> <a href="/tags/RPC/" style="font-size: 13.57px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.14px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.29px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.29px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.86px;">设计模式</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/b25f5b99/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a>
              </p>
              <p class="item-title">
                <a href="/posts/b25f5b99/" class="title">网络通信 - IO多路复用</a>
              </p>
              <p class="item-date">
                <time datetime="2021-06-12T02:43:23.000Z" itemprop="datePublished">2021-06-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/51fff883/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a>
              </p>
              <p class="item-title">
                <a href="/posts/51fff883/" class="title">网络通信 - I/O模型</a>
              </p>
              <p class="item-date">
                <time datetime="2021-06-05T07:36:47.000Z" itemprop="datePublished">2021-06-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/a26fab1/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/a26fab1/" class="title">Redis原理 - 事务</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-27T12:08:59.000Z" itemprop="datePublished">2021-05-27</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/d80e61c2/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/posts/d80e61c2/" class="title">MySQL - 事务与隔离级别</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-21T10:49:59.000Z" itemprop="datePublished">2021-05-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/4132ef9f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/posts/4132ef9f/" class="title">MySQL - 慢查询日志</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-14T11:17:14.000Z" itemprop="datePublished">2021-05-14</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Transporter-扩展接口"><span class="toc-number">3.</span> <span class="toc-text">Transporter 扩展接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#具体NIO库Server的实现"><span class="toc-number">3.1.</span> <span class="toc-text">具体NIO库Server的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体NIO库Client的实现"><span class="toc-number">3.2.</span> <span class="toc-text">具体NIO库Client的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AbstractPeer-抽象类"><span class="toc-number">4.</span> <span class="toc-text">AbstractPeer 抽象类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AbstractEndpoint-抽象类"><span class="toc-number">5.</span> <span class="toc-text">AbstractEndpoint 抽象类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#抽象的服务端和客户端"><span class="toc-number">6.</span> <span class="toc-text">抽象的服务端和客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AbstractServer"><span class="toc-number">6.1.</span> <span class="toc-text">AbstractServer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">6.1.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法"><span class="toc-number">6.1.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模版方法"><span class="toc-number">6.1.3.</span> <span class="toc-text">模版方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送消息"><span class="toc-number">6.1.4.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端请求连接"><span class="toc-number">6.1.5.</span> <span class="toc-text">客户端请求连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端断开连接"><span class="toc-number">6.1.6.</span> <span class="toc-text">客户端断开连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务关闭"><span class="toc-number">6.1.7.</span> <span class="toc-text">服务关闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AbstractClient"><span class="toc-number">6.2.</span> <span class="toc-text">AbstractClient</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性-1"><span class="toc-number">6.2.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法-1"><span class="toc-number">6.2.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模版方法-1"><span class="toc-number">6.2.3.</span> <span class="toc-text">模版方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连接服务的通用逻辑"><span class="toc-number">6.2.4.</span> <span class="toc-text">连接服务的通用逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#断线重连机制"><span class="toc-number">6.2.5.</span> <span class="toc-text">断线重连机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送消息-1"><span class="toc-number">6.2.6.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#断开连接"><span class="toc-number">6.2.7.</span> <span class="toc-text">断开连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重连"><span class="toc-number">6.2.8.</span> <span class="toc-text">重连</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关闭"><span class="toc-number">6.2.9.</span> <span class="toc-text">关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超时关闭"><span class="toc-number">6.2.10.</span> <span class="toc-text">超时关闭</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#抽象通道-AbstractChannel"><span class="toc-number">7.</span> <span class="toc-text">抽象通道 AbstractChannel</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ChannelHandler"><span class="toc-number">8.</span> <span class="toc-text">ChannelHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ChannelHandlerAdapter"><span class="toc-number">8.1.</span> <span class="toc-text">ChannelHandlerAdapter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChannelHandlerDispatcher"><span class="toc-number">8.2.</span> <span class="toc-text">ChannelHandlerDispatcher</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChannelHandlerDelegate"><span class="toc-number">8.3.</span> <span class="toc-text">ChannelHandlerDelegate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractChannelHandlerDelegate"><span class="toc-number">8.3.1.</span> <span class="toc-text">AbstractChannelHandlerDelegate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DecodeHandler"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">DecodeHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MultiMessageHandler"><span class="toc-number">8.3.1.2.</span> <span class="toc-text">MultiMessageHandler</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WrappedChannelHandler"><span class="toc-number">8.3.2.</span> <span class="toc-text">WrappedChannelHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程模型"><span class="toc-number">8.3.3.</span> <span class="toc-text">线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AllDispatcher-amp-AllChannelHandler"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">AllDispatcher &amp; AllChannelHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ExecutionDispatcher-amp-AllChannelHandler"><span class="toc-number">8.3.3.2.</span> <span class="toc-text">ExecutionDispatcher &amp; AllChannelHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DirectDispatcher-amp-DirectChannelHandler"><span class="toc-number">8.3.3.3.</span> <span class="toc-text">DirectDispatcher &amp; DirectChannelHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MessageOnlyDispatcher-amp-MessageOnlyChannelHandler"><span class="toc-number">8.3.3.4.</span> <span class="toc-text">MessageOnlyDispatcher &amp; MessageOnlyChannelHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConnectionOrderedDispatcher-amp-ConnectionOrderedChannelHandler"><span class="toc-number">8.3.3.5.</span> <span class="toc-text">ConnectionOrderedDispatcher &amp; ConnectionOrderedChannelHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelEventRunnable-线程派发任务体"><span class="toc-number">8.3.3.6.</span> <span class="toc-text">ChannelEventRunnable 线程派发任务体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#属性-2"><span class="toc-number">8.3.3.6.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#任务体"><span class="toc-number">8.3.3.6.2.</span> <span class="toc-text">任务体</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ChannelHandlers"><span class="toc-number">9.</span> <span class="toc-text">ChannelHandlers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#编解码"><span class="toc-number">10.</span> <span class="toc-text">编解码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#编解码工具类-CodecSupport"><span class="toc-number">10.1.</span> <span class="toc-text">编解码工具类 CodecSupport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编解码适配器"><span class="toc-number">10.2.</span> <span class="toc-text">编解码适配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编解码继承关系"><span class="toc-number">10.3.</span> <span class="toc-text">编解码继承关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractCodec"><span class="toc-number">10.3.1.</span> <span class="toc-text">AbstractCodec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TransportCodec"><span class="toc-number">10.3.2.</span> <span class="toc-text">TransportCodec</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">11.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-rpc/Transport层" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Dubbo源码分析 - 网络传输层
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/53cd7ee7/" class="article-date">
	  <time datetime="2020-05-22T16:00:00.000Z" itemprop="datePublished">2020-05-23</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/RPC/">RPC</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Dubbo/" rel="tag">Dubbo</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/53cd7ee7/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 13.2k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 59(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中对 Remoting 层进行了总体说明，下面我们开始详细介绍 Remoting 层的 Transport 网络传输层。本文会从 Transporter 层的 Server、Client、Channel、ChannelHandler、Dispatcher 以及 Codec2 等核心接口出发，分别介绍这些核心接口的实现。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>有很多网络库可以实现网络传输的功能，如 Netty、Mina、Grizzly等。但这些 NIO 库对外接口和使用方式不一样，如果使用方直接使用 Netty 或其它通信组件，那么就依赖了具体的NIO库实现，而不是依赖一个有传输能力的抽象，后续要切换其它NIO库实现的话就需要修改依赖和接入的相关代码，这既容易出错也不符合设计模式中的开放-封闭原则。因此，Dubbo Transporter 层就被抽象出来了，它屏蔽了不同的通信框架的异同，封装了统一的对外接口。有了 Transporter 层之后，我们可以通过 Dubbo SPI 动态切换具体的 Transporter 扩展实现，从而切换到不同的 Client 和 Server 实现，达到底层 NIO 库切换的目的。需要注意的是，Dubbo Transporter 层不等于 Transport 扩展接口及其实现，它是对网络传输层的抽象即在NIO库之上的抽象，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec, ChannelHandler, Dispatcher 等。</p>
<p>Transport 抽象层代码结构如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-outline.jpg" alt></p>
<p>注意， Dubbo 接入具体 NIO 库的代码散落在 dubbo-remoting-* 实现模块中，会在后面的文章中介绍。</p>
<h1 id="Transporter-扩展接口"><a href="#Transporter-扩展接口" class="headerlink" title="Transporter 扩展接口"></a>Transporter 扩展接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"netty"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个服务器，监听来自客户端的请求。根据 'server'，'transporter' 确定 Server 扩展实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> server 返回服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.remoting.Transporters#bind(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务器，即创建一个客户端。根据 'client','transporter' 确定 Client 扩展实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> client 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.remoting.Transporters#connect(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transporter 是在 Client 和 Server 之上封装的统一的对外接口，针对每个支持的NIO库，都有一个 Transporter 接口实现，它们是 Dubbo 接入具体NIO库的实现入口，在各个 dubbo-remoting-* 实现模块中。如，Dubbo 接入 Mina 网络通信库，就会有对应的 <strong>dubbo-remoting-mina</strong> 模块对抽象api模块的实现，该模块提供了 <strong>Transporter</strong>、<strong>Server</strong>、<strong>Client</strong>、<strong>Channel</strong>、<strong>ChannelHandler</strong> 等核心接口的实现。</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-api.jpg" alt></p>
<p>这些 Transporter 接口实现返回的 Client 和 Server 具体实现如下图所示，它们是Dubbo 接入的NIO库对应的 Server和Client实现。</p>
<h2 id="具体NIO库Server的实现"><a href="#具体NIO库Server的实现" class="headerlink" title="具体NIO库Server的实现"></a>具体NIO库Server的实现</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-server.jpg" alt></p>
<h2 id="具体NIO库Client的实现"><a href="#具体NIO库Client的实现" class="headerlink" title="具体NIO库Client的实现"></a>具体NIO库Client的实现</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-client.jpg" alt></p>
<p>在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中已经介绍过 Transporter 接口以及该接口的门面类 Transporters ，这里不再重复介绍。关于通信具体实现模块会在后面的文章中介绍，它们也是 Transporter 层的一部分，本篇文章着重分析 Transport 层公用组件及抽象概念。</p>
<h1 id="AbstractPeer-抽象类"><a href="#AbstractPeer-抽象类" class="headerlink" title="AbstractPeer 抽象类"></a>AbstractPeer 抽象类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPeer</span> <span class="keyword">implements</span> <span class="title">Endpoint</span>, <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道处理器,AbstractPeer 对 ChannelHandler 接口的所有实现，都是委托给了这个 ChannelHandler 对象来处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 端点自身的 URL 类型的字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正在关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closing;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler 属性，通道处理器，通过构造方法传入。使用 '装饰者模式'</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractPeer</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractPeer 这个抽象类，它同时实现了 Endpoint 接口和 ChannelHandler 接口，AbstractPeer 对 ChannelHandler 接口的所有实现都是委托给维护的 ChannelHandler 属性来处理。对 Endpoint 接口的实现，包括和Channel有关的，如关闭Channel、开始关闭Channel(做标记关闭)、检查Channel是否关闭，这些都是对其维护的 <strong>closing</strong> 和 <strong>closed</strong> 属性进行操作；发送消息 send 方法的实现交给其子类去完成；获取端点自身的 URL；获取 ChannelHandler。<strong>需要特别说明的是，上层的 ChannelHandler 在链路的最底层保存的位置就是在 AbstractPeer 这个抽象类中</strong>。</p>
<p>AbstractPeer 也是 AbstractChannel、AbstractEndpoint 抽象类的父类，继承关系如下图：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-abstractpeer-hierarchy.jpg" alt></p>
<p>红框中的实现类是 Dubbo 接入的具体NIO库实现相关的 Server、Client 和 Channel 实现类，通过继承关系以及前面的描述，我们可以知道 <strong>AbstractChannel、AbstractServer、AbstractClient 都会关联一个 ChannelHandler 对象</strong>，这个对象很重要，后面会慢慢揭开它的面纱。</p>
<h1 id="AbstractEndpoint-抽象类"><a href="#AbstractEndpoint-抽象类" class="headerlink" title="AbstractEndpoint 抽象类"></a>AbstractEndpoint 抽象类</h1><p>上文也提到了，AbstractEndpoint 继承了 AbstractPeer 这个抽象类，因为继承关系因此也会关联一个 ChannelHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractPeer</span> <span class="keyword">implements</span> <span class="title">Resetable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractEndpoint<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编解码器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Codec2 codec;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接超时时间 (用于具体子类客户端连接超时时间)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connectTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractEndpoint</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类 AbstractPeer 的构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">        <span class="comment">// 根据URL中的 codec 参数值 获取Codec2的实现类</span></span><br><span class="line">        <span class="keyword">this</span>.codec = getChannelCodec(url);</span><br><span class="line">        <span class="comment">// 根据 URL 中的 timeout 参数确定 timeout 字段的值，默认 1000</span></span><br><span class="line">        <span class="keyword">this</span>.timeout = url.getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">        <span class="comment">// 根据URL中的connect.timeout 参数确定connectTimeout 字段值，默认 3000</span></span><br><span class="line">        <span class="keyword">this</span>.connectTimeout = url.getPositiveParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于Dubbo SPI机制，加载对应的Codec实现对象，如：在DubboProtocol中会获得DubboCodec对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Codec2 <span class="title">getChannelCodec</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        String codecName = url.getParameter(Constants.CODEC_KEY, <span class="string">"telnet"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(Codec2<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">codecName</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Codec2<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">codecName</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 注意： Codec接口已经废弃了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CodecAdapter(ExtensionLoader.getExtensionLoader(Codec<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">codecName</span>))</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以看到，<strong>AbstractEndpoint 中维护了一个编解码对象 Codec2 ，该对象是在 AbstractEndpoint 构造方法中根据传入的URL完成初始化</strong>，这个非常重要。除了维护 Codec2 编解码对象外，还维护了超时时间（timeout）和连接超时时间（connectTimeout），它们也是在构造方法中根据传入的URL进行初始化的。</p>
<p>此外，AbstractEndpoint 还实现了 Resetable 接口用来支持重置 AbstractEndpoint 中维护的三个属性，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractEndpoint</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置属性, 即使用新的 url 重置 codec、timeout、connectTimeout 属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isClosed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to reset parameters "</span></span><br><span class="line">                    + url + <span class="string">", cause: Channel closed. channel: "</span> + getLocalAddress());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.hasParameter(Constants.TIMEOUT_KEY)) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = url.getParameter(Constants.TIMEOUT_KEY, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.timeout = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.hasParameter(Constants.CONNECT_TIMEOUT_KEY)) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = url.getParameter(Constants.CONNECT_TIMEOUT_KEY, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.connectTimeout = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.hasParameter(Constants.CODEC_KEY)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.codec = getChannelCodec(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="抽象的服务端和客户端"><a href="#抽象的服务端和客户端" class="headerlink" title="抽象的服务端和客户端"></a>抽象的服务端和客户端</h1><p>由上面的继承关系图可知，AbstractServer 和 AbstractClient 都继承自 AbstractEndpoint 抽象类，下面我们先来分析 AbstractServer 这个抽象服务的实现。</p>
<h2 id="AbstractServer"><a href="#AbstractServer" class="headerlink" title="AbstractServer"></a>AbstractServer</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServer</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_THREAD_POOL_NAME = <span class="string">"DubboServerHandler"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前Server关联的线程池，是从 DataStore 中取的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ExecutorService executor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前Server本地地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InetSocketAddress localAddress;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定地址  （默认值与 localAddress 一致）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InetSocketAddress bindAddress;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器最大可接受连接数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> accepts;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空闲超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idleTimeout = <span class="number">600</span>; <span class="comment">//600 seconds</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractServer 在继承 AbstractEndpoint 的同时，还实现了 Server 接口，是服务抽象类，<strong>重点实现了服务的公用逻辑</strong>，Server 接口在 在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中已经介绍，其中的属性已经在代码中详细标注。下面我们接着看它的构造方法，上述的属性字段都是在构造方法中进行初始化的。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractServer</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">AbstractServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">        <span class="comment">// 服务地址: 本机地址  如：-&gt; /192.168.0.100:20880</span></span><br><span class="line">        localAddress = getUrl().toInetSocketAddress();</span><br><span class="line">        <span class="comment">// 获取ip和端口</span></span><br><span class="line">        String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());</span><br><span class="line">        <span class="keyword">int</span> bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());</span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(Constants.ANYHOST_KEY, <span class="keyword">false</span>) || NetUtils.isInvalidLocalHost(bindIp)) &#123;</span><br><span class="line">            <span class="comment">// 设置ip 为 0.0.0.0</span></span><br><span class="line">            bindIp = NetUtils.ANYHOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 绑定地址  如： /0.0.0.0:20880</span></span><br><span class="line">        bindAddress = <span class="keyword">new</span> InetSocketAddress(bindIp, bindPort);</span><br><span class="line">        <span class="comment">// 获取最大可接受连接数</span></span><br><span class="line">        <span class="keyword">this</span>.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);</span><br><span class="line">        <span class="comment">// 空闲超时时间</span></span><br><span class="line">        <span class="keyword">this</span>.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用模版方法 doOpen 启动服务</span></span><br><span class="line">            doOpen();</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Start "</span> + getClass().getSimpleName() + <span class="string">" bind "</span> + getBindAddress() + <span class="string">", export "</span> + getLocalAddress());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(url.toInetSocketAddress(), <span class="keyword">null</span>, <span class="string">"Failed to bind "</span> + getClass().getSimpleName()</span><br><span class="line">                    + <span class="string">" on "</span> + getLocalAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 从DataStore中获得线程池 ,来源 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.remoting.transport.dispatcher.WrappedChannelHandler.WrappedChannelHandler&#125;*/</span></span><br><span class="line">        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;</span><br><span class="line">        executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>构造方法会根据传入的URL初始化 AbstractServer 中的属性，这也是为了其子类的初始化做准备，其中在构造方法中调用了一个<strong>模版方法 doOpen，这个方法就是初始化其子类的关键入口，即启动具体的NIO服务</strong>，下篇文章分析具体NIO库是如何接入的就会清晰了。当前Server关联的线程池 executor 是从 DataStore 中取的，下文会对 DataStore 进行介绍并说明线程池的来源。</p>
<h3 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a>模版方法</h3><p>用于子类实现，完成服务的开启和关闭工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure>

<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>发送消息方法是对 Endpoint 接口的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractServer</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sent    true: 会等待消息发出，消息发送失败会抛出异常；  false: 不等待消息发出，将消息放入IO队列，即可返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取连接上服务器的通道列表 【客户端列表】</span></span><br><span class="line">        Collection&lt;Channel&gt; channels = getChannels();</span><br><span class="line">        <span class="comment">// 群发消息</span></span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">            <span class="comment">// 如果是已经连接的就发送</span></span><br><span class="line">            <span class="keyword">if</span> (channel.isConnected()) &#123;</span><br><span class="line">                channel.send(message, sent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端请求连接"><a href="#客户端请求连接" class="headerlink" title="客户端请求连接"></a>客户端请求连接</h3><p>用于客户端连接当前服务，是对父类 AbstractPeer 方法的重写，对 ChannelHandler 的实现，AbstractPeer 中的实现很简单，只是判断服务是否关闭，关闭就不会处理客户端连接请求，没有关闭则会把连接请求交给维护的 ChannelHandler 处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractServer</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// If the server has entered the shutdown process, reject any new connection</span></span><br><span class="line">        <span class="comment">// 调用父类AbstractPeer 中的方法，判读当前这个 Server 端是否正在关闭或关闭了。如果不是启动状态则直接关闭新建的 Client 连接。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isClosing() || <span class="keyword">this</span>.isClosed()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Close new channel "</span> + ch + <span class="string">", cause: server is closing or has been closed. For example, receive a new connect request while in shutdown process."</span>);</span><br><span class="line">            ch.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1 超过上限，关闭新的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.1 获取连接上服务器的通道列表 【客户端列表】</span></span><br><span class="line">        Collection&lt;Channel&gt; channels = getChannels();</span><br><span class="line">        <span class="comment">//1.2 判断服务器上连接数是否超过上限</span></span><br><span class="line">        <span class="keyword">if</span> (accepts &gt; <span class="number">0</span> &amp;&amp; channels.size() &gt; accepts) &#123;</span><br><span class="line">            logger.error(<span class="string">"Close channel "</span> + ch + <span class="string">", cause: The server "</span> + ch.getLocalAddress() + <span class="string">" connections greater than max config "</span> + accepts);</span><br><span class="line">            <span class="comment">// 服务器上的连接数超过上上限的话，就关闭新的连接</span></span><br><span class="line">            ch.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理连接事件，AbstractPeer 中的方法，本质还是委托内部装饰的 ChannelHandler 来处理</span></span><br><span class="line">        <span class="keyword">super</span>.connected(ch);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端断开连接"><a href="#客户端断开连接" class="headerlink" title="客户端断开连接"></a>客户端断开连接</h3><p>用于客户端断开连接当前服务，是对父类 AbstractPeer 方法的重写，对 ChannelHandler 的实现，AbstractPeer 中的实现很简单，直接把断开连接请求交给装饰的 ChannelHandler 处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractServer</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        Collection&lt;Channel&gt; channels = getChannels();</span><br><span class="line">        <span class="keyword">if</span> (channels.isEmpty()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"All clients has discontected from "</span> + ch.getLocalAddress() + <span class="string">". You can graceful shutdown now."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理断开连接请求</span></span><br><span class="line">        <span class="keyword">super</span>.disconnected(ch);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务关闭"><a href="#服务关闭" class="headerlink" title="服务关闭"></a>服务关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">         logger.info(<span class="string">"Close "</span> + getClass().getSimpleName() + <span class="string">" bind "</span> + getBindAddress() + <span class="string">", export "</span> + getLocalAddress());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 关闭关联的线程池</span></span><br><span class="line">     ExecutorUtil.shutdownNow(executor, <span class="number">100</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 标记关闭</span></span><br><span class="line">         <span class="keyword">super</span>.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         logger.warn(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 子类关闭动作</span></span><br><span class="line">         doClose();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         logger.warn(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>还有一些不是很重要的其它方法就不分析了，下面继续分析抽象客户端实现。</p>
<h2 id="AbstractClient"><a href="#AbstractClient" class="headerlink" title="AbstractClient"></a>AbstractClient</h2><p>AbstractClient 同样继承了 AbstractEndpoint 抽象类，并且实现了 Client 接口，是客户端的抽象类，实现了公用的逻辑。Client 接口在 在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中已经介绍过，就不再重复说明。</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClient</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span> <span class="keyword">implements</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接线程池名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLIENT_THREAD_POOL_NAME = <span class="string">"DubboClientHandler"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接线程池id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger CLIENT_THREAD_POOL_ID = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连定时任务执行器，在客户端连接服务端时，会创建后台任务，定时检查连接，若断开会进行重新连</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor reconnectExecutorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">2</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboClientReconnectTimer"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接锁，用于实现发起连接和断开连接互斥，避免并发。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock connectLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息时，若断开，是否重连</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> send_reconnect;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger reconnect_count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连时，是否已经打印过错误日志。默认没有打印过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean reconnect_error_log_flag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连warning的间隔，warning多少次之后warning一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> reconnect_warning_period;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> shutdown_timeout;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前客户端对应的线程池</span></span><br><span class="line"><span class="comment">     * 在调用 &#123;<span class="doctag">@link</span> #wrapChannelHandler(URL, ChannelHandler)&#125; 时，会调用 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.remoting.transport.dispatcher.WrappedChannelHandler&#125; 创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> ExecutorService executor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连执行任务 Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ScheduledFuture&lt;?&gt; reconnectExecutorFuture = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后成功连接时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastConnectedTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractClient 中的相关属性已经详细标注，因为是客户端，会涉及到重连服务的情况，属性相对比服务端要多些，但是这些属性都是很有用的 。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractClient</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从URL中，获得重连相关配置，即 send.reconnect 配置属性</span></span><br><span class="line">        send_reconnect = url.getParameter(Constants.SEND_RECONNECT_KEY, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从URL中获得关闭超时时间 即 shutdown.timeout 配置属性</span></span><br><span class="line">        shutdown_timeout = url.getParameter(Constants.SHUTDOWN_TIMEOUT_KEY, Constants.DEFAULT_SHUTDOWN_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The default reconnection interval is 2s, 1800 means warning interval is 1 hour.</span></span><br><span class="line">        reconnect_warning_period = url.getParameter(<span class="string">"reconnect.waring.period"</span>, <span class="number">1800</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化客户端</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doOpen();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 初始化失败，则关闭，并抛出异常</span></span><br><span class="line">            close();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(url.toInetSocketAddress(), <span class="keyword">null</span>,</span><br><span class="line">                    <span class="string">"Failed to start "</span> + getClass().getSimpleName() + <span class="string">" "</span> + NetUtils.getLocalAddress()</span><br><span class="line">                            + <span class="string">" connect to the server "</span> + getRemoteAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接服务器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connect();</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Start "</span> + getClass().getSimpleName() + <span class="string">" "</span> + NetUtils.getLocalAddress() + <span class="string">" connect to the server "</span> + getRemoteAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException t) &#123;</span><br><span class="line">            <span class="comment">// 如果连接失败，并且配置了启动检查，则进行对应的逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                close();</span><br><span class="line">                <span class="keyword">throw</span> t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"Failed to start "</span> + getClass().getSimpleName() + <span class="string">" "</span> + NetUtils.getLocalAddress()</span><br><span class="line">                        + <span class="string">" connect to the server "</span> + getRemoteAddress() + <span class="string">" (check == false, ignore and retry later!), cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            close();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(url.toInetSocketAddress(), <span class="keyword">null</span>,</span><br><span class="line">                    <span class="string">"Failed to start "</span> + getClass().getSimpleName() + <span class="string">" "</span> + NetUtils.getLocalAddress()</span><br><span class="line">                            + <span class="string">" connect to the server "</span> + getRemoteAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从DataStore中获得线程池，这里的线程池就是线程模型中的涉及的线程池</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> WrappedChannelHandler#WrappedChannelHandler(com.alibaba.dubbo.remoting.ChannelHandler, com.alibaba.dubbo.common.URL)&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        executor = (ExecutorService) ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>().<span class="title">get</span>(<span class="title">Constants</span>.<span class="title">CONSUMER_SIDE</span>, <span class="title">Integer</span>.<span class="title">toString</span>(<span class="title">url</span>.<span class="title">getPort</span>()))</span>;</span><br><span class="line">        ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>().<span class="title">remove</span>(<span class="title">Constants</span>.<span class="title">CONSUMER_SIDE</span>, <span class="title">Integer</span>.<span class="title">toString</span>(<span class="title">url</span>.<span class="title">getPort</span>()))</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造方法中不仅初始化了属性，还调用了模版方法，用于完成子类的初始化工作，即完成客户端的初始化并连接上服务。具体的客户端实现同样在后面的文章中说明。</p>
<h3 id="模版方法-1"><a href="#模版方法-1" class="headerlink" title="模版方法"></a>模版方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Open client.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Close client.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Connect to server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * disConnect to server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doDisConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the connected channel.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Channel <span class="title">getChannel</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>与 AbstractServer 类似，AbstractClient 定义了 doOpen()、doClose()、doConnect()、 doDisConnect() 和 getChannel() 抽象方法给子类实现以完成特定的功能。其中 doClose() 方法在 Netty 实现中是个空方法。</p>
<h3 id="连接服务的通用逻辑"><a href="#连接服务的通用逻辑" class="headerlink" title="连接服务的通用逻辑"></a>连接服务的通用逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 获得锁 </span></span><br><span class="line">        connectLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断连接状态，若已经连接就不重复连接。</span></span><br><span class="line">            <span class="keyword">if</span> (isConnected()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化重连线程 【断线重连机制】</span></span><br><span class="line">            initConnectStatusCheckCommand();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行连接</span></span><br><span class="line">            doConnect();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否已经连接，如过连接失败则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!isConnected()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed connect to server "</span> + getRemoteAddress() + <span class="string">" from "</span> + getClass().getSimpleName() + <span class="string">" "</span></span><br><span class="line">                        + NetUtils.getLocalHost() + <span class="string">" using dubbo version "</span> + Version.getVersion()</span><br><span class="line">                        + <span class="string">", cause: Connect wait timeout: "</span> + getConnectTimeout() + <span class="string">"ms."</span>);</span><br><span class="line">                <span class="comment">// 连接成功，打印日志</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Successed connect to server "</span> + getRemoteAddress() + <span class="string">" from "</span> + getClass().getSimpleName() + <span class="string">" "</span></span><br><span class="line">                            + NetUtils.getLocalHost() + <span class="string">" using dubbo version "</span> + Version.getVersion()</span><br><span class="line">                            + <span class="string">", channel is "</span> + <span class="keyword">this</span>.getChannel());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置重连次数归零</span></span><br><span class="line">            reconnect_count.set(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置未打印过重连错误日志</span></span><br><span class="line">            reconnect_error_log_flag.set(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed connect to server "</span> + getRemoteAddress() + <span class="string">" from "</span> + getClass().getSimpleName() + <span class="string">" "</span></span><br><span class="line">                    + NetUtils.getLocalHost() + <span class="string">" using dubbo version "</span> + Version.getVersion()</span><br><span class="line">                    + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            connectLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>连接服务通用逻辑主要做了以下工作：</p>
<ol>
<li>获得锁，用于实现在连接和断开连接同时操作时，通过加锁以防止并发问题。</li>
<li>判断是否连接，如果连接了就无需再连接，是否连接逻辑是对Channel接口方法的实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo的Channel 接口中的方法。方法内部调用的是Channel对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel channel = getChannel();</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channel.isConnected();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>开启断线重连机制，即初始化重连线程，定时检查连接状态。</li>
<li>调用具体客户端实现的连接服务的方法去连接对应的服务。</li>
<li>连接失败抛出异常，连接成功则打印日志并归零重连次数。</li>
</ol>
<h3 id="断线重连机制"><a href="#断线重连机制" class="headerlink" title="断线重连机制"></a>断线重连机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化重连线程 【以一定频率尝试重连任务】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initConnectStatusCheckCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得重连频率  【注意：默认是开启的，2000毫秒】</span></span><br><span class="line">        <span class="keyword">int</span> reconnect = getReconnectParam(getUrl());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若开启重连功能，创建重连线程 </span></span><br><span class="line">        <span class="keyword">if</span> (reconnect &gt; <span class="number">0</span> &amp;&amp; (reconnectExecutorFuture == <span class="keyword">null</span> || reconnectExecutorFuture.isCancelled())) &#123;</span><br><span class="line">            <span class="comment">// 创建重连任务体</span></span><br><span class="line">            Runnable connectStatusCheckCommand = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 判断是否连接，未连接就重连</span></span><br><span class="line">                        <span class="keyword">if</span> (!isConnected()) &#123;</span><br><span class="line">                            connect();</span><br><span class="line">                            <span class="comment">// 已连接则记录最后连接时间（确保是连接状态的时间）</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            lastConnectedTime = System.currentTimeMillis();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 符合条件时，打印错误或告警日志。 如果不加节制打印日志，很容易打出满屏日志，严重的可能造成JVM崩溃</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 超过一定时间未连接上，才打印异常日志。并且，仅打印一次。默认15分钟</span></span><br><span class="line">                        String errorMsg = <span class="string">"client reconnect to "</span> + getUrl().getAddress() + <span class="string">" find error . url: "</span> + getUrl();</span><br><span class="line">                        <span class="comment">// wait registry sync provider list</span></span><br><span class="line">                        <span class="keyword">if</span> (System.currentTimeMillis() - lastConnectedTime &gt; shutdown_timeout) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!reconnect_error_log_flag.get()) &#123;</span><br><span class="line">                                reconnect_error_log_flag.set(<span class="keyword">true</span>);</span><br><span class="line">                                logger.error(errorMsg, t);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 按照一定的重连次数，打印告警日志</span></span><br><span class="line">                        <span class="keyword">if</span> (reconnect_count.getAndIncrement() % reconnect_warning_period == <span class="number">0</span>) &#123;</span><br><span class="line">                            logger.warn(errorMsg, t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 发起重连定时任务，定时检查是否需要重连 [默认两秒检查一次]</span></span><br><span class="line">            reconnectExecutorFuture = reconnectExecutorService.scheduleWithFixedDelay(connectStatusCheckCommand, reconnect, reconnect, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>断线重连机制就是在客户端连接服务端时，会创建后台任务，定时检查连接，若断开会进行重连。</p>
<h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sent    true: 会等待消息发出，消息发送失败会抛出异常；  false: 不等待消息发出，将消息放入IO队列，即可返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 未连接时，并且开启了发送消息断开重连功能，则先发起连接</span></span><br><span class="line">        <span class="keyword">if</span> (send_reconnect &amp;&amp; !isConnected()) &#123;</span><br><span class="line">            connect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取通道，如 NettyChannel 实例，该实例内部channel实例就是 NioClientSocketChannel。</span></span><br><span class="line">        Channel channel = getChannel();</span><br><span class="line">        <span class="comment">//TODO Can the value returned by getChannel() be null? need improvement.</span></span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span> || !channel.isConnected()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"message can not send, because channel is closed . url:"</span> + getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        channel.send(message, sent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>客户端连接服务时只会有对应的一个 Channel 通道，客户端发送消息时使用的是 Dubbo 接入具体NIO库的 Channel 实例，如 NettyChannel 实例，它内部封装的 Channel 实例是 Netty 的通道实例 NioClientSocketChannel 。这个在后面的文章中详细说明。</p>
<h3 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h3><p>该方法目前用在 reconnect() 重连方法和 close() 关闭方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 加锁</span></span><br><span class="line">     connectLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 1 关闭断线重连任务</span></span><br><span class="line">         destroyConnectStatusCheckCommand();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 2 关闭连接服务的通道</span></span><br><span class="line">             Channel channel = getChannel();</span><br><span class="line">             <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 channel.close();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">             logger.warn(e.getMessage(), e);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 3 清除通道缓存(Dubbo 层面的 Channel，该Channel 内部封装了NIO库的Channel，它们是一对一关系)</span></span><br><span class="line">             doDisConnect();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">             logger.warn(e.getMessage(), e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         connectLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="重连"><a href="#重连" class="headerlink" title="重连"></a>重连</h3><p>先断开连接，在进行连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reconnect</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 1 先断开连接</span></span><br><span class="line">    disconnect();</span><br><span class="line">    <span class="comment">// 2 连接</span></span><br><span class="line">    connect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 1 关闭线程池</span></span><br><span class="line">          <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">              ExecutorUtil.shutdownNow(executor, <span class="number">100</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          logger.warn(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 2 标记通道关闭完成</span></span><br><span class="line">          <span class="keyword">super</span>.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          logger.warn(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 3 断开连接</span></span><br><span class="line">          disconnect();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          logger.warn(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//4 执行关闭</span></span><br><span class="line">          doClose();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          logger.warn(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="超时关闭"><a href="#超时关闭" class="headerlink" title="超时关闭"></a>超时关闭</h3><p>对线程池超时关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">       ExecutorUtil.gracefulShutdown(executor, timeout);</span><br><span class="line">       close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="抽象通道-AbstractChannel"><a href="#抽象通道-AbstractChannel" class="headerlink" title="抽象通道 AbstractChannel"></a>抽象通道 AbstractChannel</h1><p>AbstractChannel 同样继承了 AbstractPeer 这个抽象类，同时还实现了 Channel 接口。AbstractChannel 实现非常简单，只是在 send() 方法中检测了底层连接的状态，没有实现具体的发送消息的逻辑。注意，一般情况下 <strong>Dubbo 层面的 Channel 和 具体NIO库的通道是一对一的关系，前者会对后者进行装饰，前者的功能本质上是后者的职能</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span> <span class="keyword">extends</span> <span class="title">AbstractPeer</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联了 ChannelHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractChannel</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息，在这里只做底层连接状态检查，没有实现具体的发送消息的逻辑，具体的发送逻辑由子类实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sent    true: 会等待消息发出，消息发送失败会抛出异常；  false: 不等待消息发出，将消息放入IO队列，即可返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isClosed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message "</span> + (message == <span class="keyword">null</span> ? <span class="string">""</span> : message.getClass().getName()) + <span class="string">":"</span> + message + <span class="string">", cause: Channel closed. channel: "</span> + getLocalAddress() + <span class="string">" -&gt; "</span> + getRemoteAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承关系图如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-abstractchannel-hierarchy.jpg" alt></p>
<p>各子类实现会对 send 方法进行重写。</p>
<h1 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h1><p>前文介绍的 AbstractEndpoint、AbstractChannel 都是通过对 AbstractPeer 继承间接实现了 ChannelHandler 接口并关联了 ChannelHandler 对象，仅仅是对 ChannelHandler 的装饰，方法都是委托给底层关联的这个 ChannelHandler 对象。下面我们对 Transporter 层相关的 ChannelHandler 进行详细分析。继承关系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-channelhandler.jpg" alt></p>
<h2 id="ChannelHandlerAdapter"><a href="#ChannelHandlerAdapter" class="headerlink" title="ChannelHandlerAdapter"></a>ChannelHandlerAdapter</h2><p>ChannelHandlerAdapter 是 ChannelHandler 的一个空实现，TelnetHandlerAdapter 继承了它并实现了 TelnetHandler 接口，用于支持 Dubbo 命令行的服务治理。关于 Telnet 的实现，会在后面单独进行介绍，这里就不展开说明了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ChannelHandlerAdapter.  实现ChannelHandler接口，通道处理器适配器，每个方法都是空实现。子类可根据具体场景选择性实现所需方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ChannelHandlerDispatcher"><a href="#ChannelHandlerDispatcher" class="headerlink" title="ChannelHandlerDispatcher"></a>ChannelHandlerDispatcher</h2><p>在前面的文章中有提到过 ChannelHandlerDispatcher，它维护了一个 CopyOnWriteArraySet 集合，负责将多个 ChannelHandler 对象聚合成一个 ChannelHandler 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelHandlerDispatcher</span> <span class="keyword">implements</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelHandlerDispatcher<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道处理器集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;ChannelHandler&gt; channelHandlers = <span class="keyword">new</span> CopyOnWriteArraySet&lt;ChannelHandler&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelHandlerDispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelHandlerDispatcher</span><span class="params">(ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(handlers == <span class="keyword">null</span> ? <span class="keyword">null</span> : Arrays.asList(handlers));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelHandlerDispatcher</span><span class="params">(Collection&lt;ChannelHandler&gt; handlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlers != <span class="keyword">null</span> &amp;&amp; !handlers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.channelHandlers.addAll(handlers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略对 ChannelHandler 接口方法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChannelHandlerDispatcher 实现了 ChannelHandler 接口中的所有方法，每个方法都是循环通道集合调用相应的方法。</p>
<h2 id="ChannelHandlerDelegate"><a href="#ChannelHandlerDelegate" class="headerlink" title="ChannelHandlerDelegate"></a>ChannelHandlerDelegate</h2><p>实现 ChannelHandler 接口，通道处理器装饰者接口，即<strong>是对其它 ChannelHandler 进行装饰的接口，这个接口非常重要</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandlerDelegate</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取装饰的ChannelHandler</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ChannelHandler <span class="title">getHandler</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChannelHandlerDelegate 有三个直接的实现类，分别是 <strong>AbstractChannelHandlerDelegate</strong>、<strong>WrappedChannelHandler</strong> 和 <strong>HeaderExchangeHandler</strong> ，它们就是对其它 ChannelHandler 的装饰。其中 <strong>HeaderExchangeHandler</strong> 是 Exchange 层涉及的对象，我们先不讨论。我们先来分析 AbstractChannelHandlerDelegate 继承体系。</p>
<h3 id="AbstractChannelHandlerDelegate"><a href="#AbstractChannelHandlerDelegate" class="headerlink" title="AbstractChannelHandlerDelegate"></a>AbstractChannelHandlerDelegate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannelHandlerDelegate</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 装饰的 ChannelHandler</span></span><br><span class="line">    <span class="keyword">protected</span> ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannelHandlerDelegate</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(handler, <span class="string">"handler == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelHandlerDelegate) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ChannelHandlerDelegate) handler).getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        handler.connected(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        handler.disconnected(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        handler.sent(channel, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        handler.received(channel, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        handler.caught(channel, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 ChannelHandlerDelegate 接口，在每个实现的方法里都是直接调用被装饰的 ChannelHandler 对象对应的方法，没有其它逻辑。它的三个子类都是在被装饰的 ChannelHandler 的基础上添加了一些增强的功能，使用的是装饰者模式。因为 <strong>HeartbeatHandler</strong> 属于 Exchange 层的 ChannelHandler ，在分析  Exchange 层时再进行分析，这里不再展开说明。</p>
<h4 id="DecodeHandler"><a href="#DecodeHandler" class="headerlink" title="DecodeHandler"></a>DecodeHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeHandler</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DecodeHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecodeHandler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆写了 received(channel,message)方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message RpcInvocation 或 RpcResult</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec#decodeBody(com.alibaba.dubbo.remoting.Channel, java.io.InputStream, byte[])</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 当消息是 Decodeable 类型时 进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Decodeable) &#123;</span><br><span class="line">            decode(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当消息是Request类型时，对 data 字段进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">            decode(((Request) message).getData());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当消息是Response类型时，对 result 字段进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">            decode(((Response) message).getResult());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解码后，调用ChannelHandler#received(channel,message)方法，将消息交给委托的handler继续处理</span></span><br><span class="line">        handler.received(channel, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Decodeable 接口目前有两个实现类：</span></span><br><span class="line"><span class="comment">         * 1 DecodeableRpcInvocation</span></span><br><span class="line"><span class="comment">         * 2 DecodeableRpcResult</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (message != <span class="keyword">null</span> &amp;&amp; message <span class="keyword">instanceof</span> Decodeable) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 解析消息</span></span><br><span class="line">                ((Decodeable) message).decode();</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(<span class="string">"Decode decodeable message "</span> + message.getClass().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Call Decodeable.decode failed: "</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// ~ end of catch</span></span><br><span class="line">        &#125; <span class="comment">// ~ end of if</span></span><br><span class="line">    &#125; <span class="comment">// ~ end of method decode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DecodeHandler 是一个解码处理器，<strong>专门用于处理 Decodeable 类型消息的 ChannelHandler实现类</strong>，因此该实现类只重写了 received() 接收消息的方法，它的作用和含义如下：</p>
<ol>
<li>请求解码可在IO线程上执行，也可在线程池中执行，取决于配置。DecodeHandler 存在的意义就是保证请求体或响应体可在线程池中被解码。</li>
</ol>
<blockquote>
<p>在Codec2解码器实现中，如果请求体和响应结果需要在线程池中进行解码，那么就不进行直接解码，而是把解码任务最终交给线程池来处理，最后由 DecodeHandler来处理，因为 DecodeHandler 也参与了对上层 ChannelHandler 的包装。</p>
</blockquote>
<ol start="2">
<li>实现了 Decodeable 接口的类都会提供了一个 decode() 方法实现对自身的解码，DecodeHandler.received() 方法就是通过该方法得到解码后的消息，然后传递给底层的 ChannelHandler 对象继续处理。</li>
</ol>
<h4 id="MultiMessageHandler"><a href="#MultiMessageHandler" class="headerlink" title="MultiMessageHandler"></a>MultiMessageHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiMessageHandler</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiMessageHandler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆写了 received方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 消息类型是MultiMessage，即多消息</span></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> MultiMessage) &#123;</span><br><span class="line">            MultiMessage list = (MultiMessage) message;</span><br><span class="line">            <span class="comment">// 循环提交给handler处理</span></span><br><span class="line">            <span class="keyword">for</span> (Object obj : list) &#123;</span><br><span class="line">                handler.received(channel, obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是单消息时，直接提交给handler处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handler.received(channel, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MultiMessageHandler 是<strong>专门处理 MultiMessage 类型消息</strong>的 ChannelHandler 实现类。MultiMessage 是 Exchange 层的一种消息类型，它其中封装了多个消息。在 MultiMessageHandler 收到 MultiMessage 消息的时候，received() 方法会遍历其中的所有消息，并交给底层的 ChannelHandler 对象进行处理。</p>
<p>至此，Transport 层的 AbstractChannelHandlerDelegate 继承体系分析完毕。下面我们继续看 ChannelHandlerDelegate 的另一条继承体系分支。</p>
<h3 id="WrappedChannelHandler"><a href="#WrappedChannelHandler" class="headerlink" title="WrappedChannelHandler"></a>WrappedChannelHandler</h3><p>WrappedChannelHandler 也实现了 ChannelHandlerDelegate 接口，也是对其它 ChannelHandler 装饰的类。WrappedChannelHandler 在 ChannelHandler 接口方法实现上和 AbstractChannelHandlerDelegate 基本一致，那为什么又要搞一个新的继承体系而不是直接继承 AbstractChannelHandlerDelegate 呢？因为 <strong>WrappedChannelHandler 继承体系不仅是对其它 ChannelHandler 的装饰而且还决定了 Dubbo 的线程模型</strong>，有关 Dubbo 中的线程池会单独分析，这里先不展开说明。WrappedChannelHandler 关联体系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-channelhandler-dispatcher.jpg" alt></p>
<p>从上图可知，每个 WrappedChannelHandler 的子类都有一个对应的 Dispatcher 实现类，这些实现类就是用来创建 WrappedChannelHandler 的子类们。 Dispatcher 接口已经在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中已经介绍过，它主要支持了 Dubbo 的线程模型，通过它的实现类可以创建不同的 ChannelHandler 来决定消息是交给线程池处理还是IO线程处理。</p>
<p>WrappedChannelHandler 实现了 ChannelHandlerDelegate 接口，其子类实现了消息派发功能，即决定了 Dubbo 以哪种线程模型处理收到的事件和消息。每个子类都由对应的Dispatcher 实现类创建。</p>
<p><strong>属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedChannelHandler</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WrappedChannelHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService SHARED_EXECUTOR = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboSharedHandler"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前端点关联的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被装饰的通道处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WrappedChannelHandler 中有四个核心的属性，因为是对 ChannelHandler 的装饰，因此 ChannelHandler 是必须的。需要说明的是共享线程池和当前端点关联的线程池，共享线程池对每个子类公用，当前端点关联的线程池属于每个子类对象独有，它是在构造方法中初始化的。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">--- WrappedChannelHandler</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappedChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于SPI机制创建线程池</span></span><br><span class="line">        executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>().<span class="title">getExecutor</span>(<span class="title">url</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认是 ExecutorService 的名称</span></span><br><span class="line">        String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是消费端，则 componentKey 为 'consumer'</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(Constants.SIDE_KEY))) &#123;</span><br><span class="line">            componentKey = Constants.CONSUMER_SIDE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于SPI机制创建线程池存储对象</span></span><br><span class="line">        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加线程池到 DataStore中</span></span><br><span class="line">        dataStore.put(componentKey, Integer.toString(url.getPort()), executor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过 WrappedChannelHandler 的构造方法可知，每个子类对象都会创建一个线程池并添加到 DataStore 缓存起来，我们上面介绍的 AbstractClient 和 AbstractServer 是从 DataStore 获得线程池的，而数据来源正是这里。关于线程池的介绍，会在后面的文章中详细分析，这里先不展开说明。</p>
<p>DataSource 核心就是一个 Map 结构缓存，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleDataStore 是 DataStore 唯一扩展实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDataStore</span> <span class="keyword">implements</span> <span class="title">DataStore</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key1: ExecutorService 的名称 或 'consumer'</span></span><br><span class="line"><span class="comment">     * key2: port</span></span><br><span class="line"><span class="comment">     * value: ExecutorService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt; data = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">get</span><span class="params">(String componentName)</span> </span>&#123;</span><br><span class="line">        ConcurrentMap&lt;String, Object&gt; value = data.get(componentName);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, Object&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String componentName, String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.containsKey(componentName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.get(componentName).get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String componentName, String key, Object value)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; componentData = data.get(componentName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == componentData) &#123;</span><br><span class="line">            data.putIfAbsent(componentName, <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;());</span><br><span class="line">            componentData = data.get(componentName);</span><br><span class="line">        &#125;</span><br><span class="line">        componentData.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String componentName, String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.containsKey(componentName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data.get(componentName).remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取线程池</strong></p>
<p>获取线程池，供子类使用调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--- WrappedChannelHandler</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前端点关联的公共线程池，部分子类会使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = executor;</span><br><span class="line">        <span class="comment">// 当前端点关联的线程池为空或关闭就使用共享的</span></span><br><span class="line">        <span class="keyword">if</span> (cexecutor == <span class="keyword">null</span> || cexecutor.isShutdown()) &#123;</span><br><span class="line">            cexecutor = SHARED_EXECUTOR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cexecutor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>WrappedChannelHandler 实现 ChannelHandler 接口的方法都是直接调用装饰的 ChannelHandler 对应的方法，就不再进行分析。</p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识，则直接在 IO 线程上处理更快，因为减少了线程池调度。但如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。因此，需要通过不同的派发策略和不同的线程池配置的组合来应对不同的场景:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">dispatcher</span>=<span class="string">"all"</span> <span class="attr">threadpool</span>=<span class="string">"fixed"</span> <span class="attr">threads</span>=<span class="string">"100"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-threadpool-model.jpg" alt></p>
<p>Dubbo 的线程模型需要具有线程派发能力的 ChannelHandler 和 定制化的线程池来支撑。Dispatcher 的职责就是用来创建具有线程派发能力的 ChannelHandler，其本身并不具备线程派发能力。关于 Dispatcher 在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中已经介绍，这里不再重复说明。</p>
<p>Dispatcher 派发策略：</p>
<ul>
<li><strong>all:</strong> 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。</li>
<li><strong>direct:</strong> 所有消息都不派发到线程池，全部在 IO 线程上直接执行。</li>
<li><strong>message:</strong> 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li>
<li><strong>execution:</strong> 只有请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li>
<li><strong>connection:</strong> 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。</li>
</ul>
<p>关于线程池部分在后面的文章中详细说明，先不在这里展开介绍。</p>
<p>Dispatcher 实现类用来创建 WrappedChannelHandler 的子类对象，每个子类对象代表不同的派发策略，同时子类对象在创建的时候会初始化一个线程池。下面我们来分析 Dispatcher 扩展实现和对应的 WrappedChannelHandler 的子类。</p>
<h4 id="AllDispatcher-amp-AllChannelHandler"><a href="#AllDispatcher-amp-AllChannelHandler" class="headerlink" title="AllDispatcher &amp; AllChannelHandler"></a>AllDispatcher &amp; AllChannelHandler</h4><p>AllDispatcher 用来创建 AllChannelHandler 对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllDispatcher</span> <span class="keyword">implements</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"all"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 AllChannelHandler 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AllChannelHandler(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AllChannelHandler 实现 WrappedChannelHandler 抽象类，所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllChannelHandler</span> <span class="keyword">extends</span> <span class="title">WrappedChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法调用父类方法，创建独享的线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AllChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理连接事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程池</span></span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将CONNECTED 事件的处理封装成ChannelEventRunnable提交到线程池中执行</span></span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"connect event"</span>, channel, getClass() + <span class="string">" error when process connected event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理断开连接事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程池</span></span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建ChannelEventRunnable对象，用于将断开连接事件任务派发到线程池执行</span></span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"disconnect event"</span>, channel, getClass() + <span class="string">" error when process disconnected event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收到的所有消息都派发到线程池。注意这里的message 可能是 Request也可能是 Response。</span></span><br><span class="line"><span class="comment">     * 流程大概是：消息先由IO线程（Netty 中的EventLoopGroup ）从二进制流中解码出来，然后执行到该方法会把请求提交给线程池处理，处理完后调用send 方法用于向对端写回结果。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将请求/响应消息派发到线程池中处理，ChannelEventRunnable对象作为任务体</span></span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 如果是请求消息，并且出现了线程池满了的异常</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">                Request request = (Request) message;</span><br><span class="line">                <span class="comment">// 如果通信方式为双向通信，将错误信息封装到Response 中，并返回给服务消费方。防止消费端等待超时</span></span><br><span class="line">                <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                    String msg = <span class="string">"Server side("</span> + url.getIp() + <span class="string">","</span> + url.getPort() + <span class="string">") threadpool is exhausted ,detail msg:"</span> + t.getMessage();</span><br><span class="line">                    Response response = <span class="keyword">new</span> Response(request.getId(), request.getVersion());</span><br><span class="line">                    response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);</span><br><span class="line">                    response.setErrorMessage(msg);</span><br><span class="line">                    <span class="comment">// 返回包含错误信息的 Response 对象</span></span><br><span class="line">                    channel.send(response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">" error when process received event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"caught event"</span>, channel, getClass() + <span class="string">" error when process caught event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AllChannelHandler 重写了 WrappedChannelHandler 中除了发送消息的 sent() 方法之外的其它方法，执行底层的 ChannelHandler 的逻辑都交给线程池处理，请求执行完毕后发送消息 AllChannelHandler 会直接在 IO 线程中进行处理。</p>
<h4 id="ExecutionDispatcher-amp-AllChannelHandler"><a href="#ExecutionDispatcher-amp-AllChannelHandler" class="headerlink" title="ExecutionDispatcher &amp; AllChannelHandler"></a>ExecutionDispatcher &amp; AllChannelHandler</h4><p>ExecutionDispatcher 用来创建 ExecutionChannelHandler 对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutionDispatcher</span> <span class="keyword">implements</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"execution"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 ExecutionChannelHandler 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutionChannelHandler(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExecutionChannelHandler 实现 WrappedChannelHandler 抽象类，只会将请求消息派发到线程池进行处理。对于响应消息以及其他网络事件（例如，连接建立事件、连接断开事件、心跳消息等），ExecutionChannelHandler 会直接在 IO 线程中进行处理，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutionChannelHandler</span> <span class="keyword">extends</span> <span class="title">WrappedChannelHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法调用父类方法，创建独享的线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutionChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="comment">// 请求消息</span></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">                    Request request = (Request) message;</span><br><span class="line">                    <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                        String msg = <span class="string">"Server side("</span> + url.getIp() + <span class="string">","</span> + url.getPort()</span><br><span class="line">                                + <span class="string">") thread pool is exhausted, detail msg:"</span> + t.getMessage();</span><br><span class="line">                        Response response = <span class="keyword">new</span> Response(request.getId(), request.getVersion());</span><br><span class="line">                        response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);</span><br><span class="line">                        response.setErrorMessage(msg);</span><br><span class="line">                        channel.send(response);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">" error when process received event."</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 直接交给装饰的 ChannelHandler 处理</span></span><br><span class="line">            handler.received(channel, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面代码可知，ExecutionChannelHandler 只重写了 received() 方法并且只处理请求消息，其它方法的调用直接调用父类的，是直接在 IO 线程中进行处理。</p>
<h4 id="DirectDispatcher-amp-DirectChannelHandler"><a href="#DirectDispatcher-amp-DirectChannelHandler" class="headerlink" title="DirectDispatcher &amp; DirectChannelHandler"></a>DirectDispatcher &amp; DirectChannelHandler</h4><p>direct 类型，所有消息都不派发到线程池，全部在 IO 线程上直接执行，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectDispatcher</span> <span class="keyword">implements</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MessageOnlyDispatcher-amp-MessageOnlyChannelHandler"><a href="#MessageOnlyDispatcher-amp-MessageOnlyChannelHandler" class="headerlink" title="MessageOnlyDispatcher &amp; MessageOnlyChannelHandler"></a>MessageOnlyDispatcher &amp; MessageOnlyChannelHandler</h4><p>MessageOnlyDispatcher 用来创建 MessageOnlyChannelHandler 对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageOnlyDispatcher</span> <span class="keyword">implements</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"message"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 MessageOnlyChannelHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageOnlyChannelHandler(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageOnlyChannelHandler 实现 WrappedChannelHandler 抽象类，会将所有收到的消息（请求/响应）提交到线程池处理，其他网络事件（连接断开事件，心跳等消息）则是由 IO 线程直接处理，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageOnlyChannelHandler</span> <span class="keyword">extends</span> <span class="title">WrappedChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法调用父类方法，创建独享的线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageOnlyChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理读取到的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message request/response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">" error when process received event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面代码可知，ExecutionChannelHandler 只重写了 received() 方法，其它方法的调用是直接调用父类的方法，直接在 IO 线程中进行处理。</p>
<h4 id="ConnectionOrderedDispatcher-amp-ConnectionOrderedChannelHandler"><a href="#ConnectionOrderedDispatcher-amp-ConnectionOrderedChannelHandler" class="headerlink" title="ConnectionOrderedDispatcher &amp; ConnectionOrderedChannelHandler"></a>ConnectionOrderedDispatcher &amp; ConnectionOrderedChannelHandler</h4><p>ConnectionOrderedDispatcher 用来创建 ConnectionOrderedChannelHandler 对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionOrderedDispatcher</span> <span class="keyword">implements</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"connection"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 ConnectionOrderedChannelHandler 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConnectionOrderedChannelHandler(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConnectionOrderedChannelHandler 实现 WrappedChannelHandler 抽象类，会将收到的消息交给线程池进行处理，对于连接建立以及断开事件是通过 IO 线程将连接、断开事件交给 connectionExecutor 线程池排队处理的，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionOrderedChannelHandler</span> <span class="keyword">extends</span> <span class="title">WrappedChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理连接建立和断开事件的线程池，线程池线程数只有一个，因此任务多的情况会先堆积到阻塞队列进行排队，有序执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ThreadPoolExecutor connectionExecutor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池阻塞队列告警阈值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> queuewarninglimit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionOrderedChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类构造方法，创建独享的线程池</span></span><br><span class="line">        <span class="keyword">super</span>(handler, url);</span><br><span class="line">        <span class="comment">// 从 'threadname' 配置项获取线程池名，默认为 Dubbo</span></span><br><span class="line">        String threadName = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br><span class="line">        <span class="comment">// 该线程池只有一个线程，并且阻塞队列的长度也是固定的，由配置参数决定</span></span><br><span class="line">        connectionExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(url.getPositiveParameter(Constants.CONNECT_QUEUE_CAPACITY, Integer.MAX_VALUE)),</span><br><span class="line">                <span class="keyword">new</span> NamedThreadFactory(threadName, <span class="keyword">true</span>),</span><br><span class="line">                <span class="keyword">new</span> AbortPolicyWithReport(threadName, url)</span><br><span class="line">        ); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 'connect.queue.warning.size' 配置项获取线程池阻塞队列告警阈值，默认大小为 1000</span></span><br><span class="line">        queuewarninglimit = url.getParameter(Constants.CONNECT_QUEUE_WARNING_SIZE, Constants.DEFAULT_CONNECT_QUEUE_WARNING_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkQueueLength();</span><br><span class="line">            connectionExecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"connect event"</span>, channel, getClass() + <span class="string">" error when process connected event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkQueueLength();</span><br><span class="line">            connectionExecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"disconnected event"</span>, channel, getClass() + <span class="string">" error when process disconnected event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">//fix, reject exception can not be sent to consumer because thread pool is full, resulting in consumers waiting till timeout.</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">                Request request = (Request) message;</span><br><span class="line">                <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                    String msg = <span class="string">"Server side("</span> + url.getIp() + <span class="string">","</span> + url.getPort() + <span class="string">") threadpool is exhausted ,detail msg:"</span> + t.getMessage();</span><br><span class="line">                    Response response = <span class="keyword">new</span> Response(request.getId(), request.getVersion());</span><br><span class="line">                    response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);</span><br><span class="line">                    response.setErrorMessage(msg);</span><br><span class="line">                    channel.send(response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">" error when process received event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"caught event"</span>, channel, getClass() + <span class="string">" error when process caught event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查阈值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkQueueLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 排队任务超过阈值打印告警日志</span></span><br><span class="line">        <span class="keyword">if</span> (connectionExecutor.getQueue().size() &gt; queuewarninglimit) &#123;</span><br><span class="line">            logger.warn(<span class="keyword">new</span> IllegalThreadStateException(<span class="string">"connectionordered channel handler `queue size: "</span> + connectionExecutor.getQueue().size() + <span class="string">" exceed the warning limit number :"</span> + queuewarninglimit));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 AllChannelHandler 一样，发送消息由 ConnectionOrderedChannelHandler 直接在 IO 线程中进行处理，区别在于后者的连接建立、断开事件不是通过父类中创建的线程池处理，而是创建了一个排队线程池。之所以叫它排队线程池，是该线程池只有一个线程，并且使用的阻塞队列是有序的。</p>
<h4 id="ChannelEventRunnable-线程派发任务体"><a href="#ChannelEventRunnable-线程派发任务体" class="headerlink" title="ChannelEventRunnable 线程派发任务体"></a>ChannelEventRunnable 线程派发任务体</h4><p>实现Runnable接口，该任务体被不同的线程派发机制使用。</p>
<h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelEventRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelEventRunnable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装饰的通道处理器，会在线程池中处理消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelState state;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息（可能为空，如连接断开事件）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常时，捕获的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Throwable exception;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ChannelEventRunnable</span><span class="params">(Channel channel, ChannelHandler handler, ChannelState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(channel, handler, state, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelEventRunnable</span><span class="params">(Channel channel, ChannelHandler handler, ChannelState state, Object message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(channel, handler, state, message, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelEventRunnable</span><span class="params">(Channel channel, ChannelHandler handler, ChannelState state, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(channel, handler, state, <span class="keyword">null</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelEventRunnable</span><span class="params">(Channel channel, ChannelHandler handler, ChannelState state, Object message, Throwable exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.exception = exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChannelEventRunnable 中的属性都是由线程派发相关的 ChannelHandler 传入的，不同的派发策略传入的属性不同，通过不同的构造方法也可以看出。</p>
<h5 id="任务体"><a href="#任务体" class="headerlink" title="任务体"></a>任务体</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelEventRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测通道状态，如果是请求或响应消息， 那么state = RECEIVED</span></span><br><span class="line">        <span class="keyword">if</span> (state == ChannelState.RECEIVED) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 channel 和 message 传递给 ChannelHandler 对象用于后续的调用。</span></span><br><span class="line">                handler.received(channel, message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"ChannelEventRunnable handle "</span> + state + <span class="string">" operation error, channel is "</span> + channel</span><br><span class="line">                        + <span class="string">", message is "</span> + message, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其它通道状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                <span class="comment">// 连接事件</span></span><br><span class="line">                <span class="keyword">case</span> CONNECTED:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        handler.connected(channel);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"ChannelEventRunnable handle "</span> + state + <span class="string">" operation error, channel is "</span> + channel, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 断开连接事件</span></span><br><span class="line">                <span class="keyword">case</span> DISCONNECTED:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        handler.disconnected(channel);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"ChannelEventRunnable handle "</span> + state + <span class="string">" operation error, channel is "</span> + channel, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                <span class="keyword">case</span> SENT:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        handler.sent(channel, message);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"ChannelEventRunnable handle "</span> + state + <span class="string">" operation error, channel is "</span> + channel</span><br><span class="line">                                + <span class="string">", message is "</span> + message, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 异常处理</span></span><br><span class="line">                <span class="keyword">case</span> CAUGHT:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        handler.caught(channel, exception);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"ChannelEventRunnable handle "</span> + state + <span class="string">" operation error, channel is "</span> + channel</span><br><span class="line">                                + <span class="string">", message is: "</span> + message + <span class="string">", exception is "</span> + exception, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    logger.warn(<span class="string">"unknown state: "</span> + state + <span class="string">", message is "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ChannelState &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * CONNECTED  - 连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CONNECTED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * DISCONNECTED - 断开连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DISCONNECTED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * SENT - 发送消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SENT,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * RECEIVED - 接收请求/响应消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RECEIVED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * CAUGHT - 异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CAUGHT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该任务体功能和作用如下：</p>
<blockquote>
<p>1 请求和响应消息出现频率比其他类型消息高，因此这里对消息类型进行了针对性判断，便于提前处理。<br>2 ChannelEventRunnable 仅是一个中转站，它的 run 方法中并不包含具体的调用逻辑，只是判断对应的通道状态，然后将参数传给装饰的 ChannelHandler 对象进行针对性处理。</p>
</blockquote>
<p>至此，ChannelHandlerDelegate 的另一条继承体系分析完毕，Transport 层的主要 ChannelHandler 分析到此结束。     </p>
<h1 id="ChannelHandlers"><a href="#ChannelHandlers" class="headerlink" title="ChannelHandlers"></a>ChannelHandlers</h1><p>ChannelHandler 的工具类，主要是对传入的 ChannelHandler 进行层层包装，具体怎么包装的我们看下面的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelHandlers</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelHandlers INSTANCE = <span class="keyword">new</span> ChannelHandlers();</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ChannelHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包装</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelHandler <span class="title">wrap</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ChannelHandlers.getInstance().wrapInternal(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> ChannelHandlers <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无论是Client还是Server，在构造方法中都会将传入的ChannelHandler进行包装，为该 ChannelHandler 增加了 Dubbo 消息派发、心跳处理以及多消息处理的功能。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ChannelHandler <span class="title">wrapInternal</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MultiMessageHandler( <span class="comment">// 多消息处理</span></span><br><span class="line">                <span class="keyword">new</span> HeartbeatHandler( <span class="comment">// 心跳处理</span></span><br><span class="line">                        ExtensionLoader.getExtensionLoader(Dispatcher<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                                .<span class="title">getAdaptiveExtension</span>() </span></span><br><span class="line"><span class="class">                                .<span class="title">dispatch</span>(<span class="title">handler</span>, <span class="title">url</span>) // 返回的是一个 <span class="title">ChannelHandlerDelegate</span> 类型的对象，默认是 <span class="title">AllChannelHandler</span>，确定了具体的线程模型</span></span><br><span class="line"><span class="class">                )</span></span><br><span class="line"><span class="class">        )</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易发现，包装器其实就是前文介绍的 ChannelHandlerDelegate 类型的 ChannelHandler。<strong>该包装逻辑无论在 Client 端还是 Server 端都会使用</strong>，也就意味着上层传入的 ChannelHandler 会增加很多的逻辑，即支持多消息处理、心跳处理以及支持 Dubbo 线程模型机制。我们在下一篇文章中还会再次介绍，这里先以 netty4 实现的网络通信简单说明。</p>
<ul>
<li>NettyServer<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// ChannelHandlers.wrap方法，用来包装 ChannelHandler，实现Dubbo 线程模型等功能</span></span><br><span class="line">        <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>NettyClient<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">extends</span> <span class="title">AbstractClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// wrapChannelHandler方法，用来包装 ChannelHandler，实现Dubbo 线程模型等功能</span></span><br><span class="line">        <span class="keyword">super</span>(url, wrapChannelHandler(url, handler));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h1><p>关于 Codec2 扩展接口已经在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中进行了介绍，下面介绍在 Transport 层相关的实现和扩展。</p>
<h2 id="编解码工具类-CodecSupport"><a href="#编解码工具类-CodecSupport" class="headerlink" title="编解码工具类 CodecSupport"></a>编解码工具类 CodecSupport</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodecSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CodecSupport<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化对象集合</span></span><br><span class="line"><span class="comment">     * key: 序列化类型编号  &#123;<span class="doctag">@link</span> Serialization#getContentTypeId()&#125;</span></span><br><span class="line"><span class="comment">     * value: 序列化对象，如： Hessian2Serialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, Serialization&gt; ID_SERIALIZATION_MAP = <span class="keyword">new</span> HashMap&lt;Byte, Serialization&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化名集合</span></span><br><span class="line"><span class="comment">     * key: 序列化类型编号 &#123;<span class="doctag">@link</span> Serialization#getContentTypeId()&#125;</span></span><br><span class="line"><span class="comment">     * value: 序列化拓展名，如：hessian2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; ID_SERIALIZATIONNAME_MAP = <span class="keyword">new</span> HashMap&lt;Byte, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 基于 Dubbo SPI，获取 Serialization 的扩展名列表</span></span><br><span class="line">        Set&lt;String&gt; supportedExtensions = ExtensionLoader.getExtensionLoader(Serialization<span class="class">.<span class="keyword">class</span>).<span class="title">getSupportedExtensions</span>()</span>;</span><br><span class="line">        <span class="keyword">for</span> (String name : supportedExtensions) &#123;</span><br><span class="line">            <span class="comment">// 根据扩展名获取对应的扩展实现</span></span><br><span class="line">            Serialization serialization = ExtensionLoader.getExtensionLoader(Serialization<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">name</span>)</span>;</span><br><span class="line">            <span class="comment">// 内容类型编号</span></span><br><span class="line">            <span class="keyword">byte</span> idByte = serialization.getContentTypeId();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ID_SERIALIZATION_MAP.containsKey(idByte)) &#123;</span><br><span class="line">                logger.error(<span class="string">"Serialization extension "</span> + serialization.getClass().getName()</span><br><span class="line">                        + <span class="string">" has duplicate id to Serialization extension "</span></span><br><span class="line">                        + ID_SERIALIZATION_MAP.get(idByte).getClass().getName()</span><br><span class="line">                        + <span class="string">", ignore this Serialization extension"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以内容编号作为 key,分别缓存序列化扩展实现和扩展实现名</span></span><br><span class="line">            ID_SERIALIZATION_MAP.put(idByte, serialization);</span><br><span class="line">            ID_SERIALIZATIONNAME_MAP.put(idByte, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CodecSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从缓存中，根据序列化号查找Serialization对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Serialization <span class="title">getSerializationById</span><span class="params">(Byte id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ID_SERIALIZATION_MAP.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过URL根据SPI机制查找Serialization对象，默认使用 hessian2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Serialization <span class="title">getSerialization</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Serialization<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">url</span>.<span class="title">getParameter</span>(<span class="title">Constants</span>.<span class="title">SERIALIZATION_KEY</span>, <span class="title">Constants</span>.<span class="title">DEFAULT_REMOTING_SERIALIZATION</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找Serialization对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Serialization <span class="title">getSerialization</span><span class="params">(URL url, Byte id)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Serialization serialization = getSerializationById(id);</span><br><span class="line">        <span class="comment">// 序列化扩展名</span></span><br><span class="line">        String serializationName = url.getParameter(Constants.SERIALIZATION_KEY, Constants.DEFAULT_REMOTING_SERIALIZATION);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出于安全的目的，针对 JDK 类型的序列化方式，检查连接到服务器的 URL 和实际传输的数据协议是否一致。</span></span><br><span class="line">        <span class="keyword">if</span> (serialization == <span class="keyword">null</span></span><br><span class="line">                || ((id == <span class="number">3</span> || id == <span class="number">7</span> || id == <span class="number">4</span>) &amp;&amp; !(serializationName.equals(ID_SERIALIZATIONNAME_MAP.get(id))))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected serialization id:"</span> + id + <span class="string">" received from network, please check if the peer send the right id."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serialization;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取反序列化对应的 ObjectInput</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proto</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream is, <span class="keyword">byte</span> proto)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Serialization s = getSerialization(url, proto);</span><br><span class="line">        <span class="keyword">return</span> s.deserialize(url, is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码已经详细注释，整个逻辑分为两点，Dubbo 应用启动时缓存序列化并提供获取序列化的方法。 关于序列化在之前的文章中已经详细介绍过，这里就不再重复说明。</p>
<h2 id="编解码适配器"><a href="#编解码适配器" class="headerlink" title="编解码适配器"></a>编解码适配器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodecAdapter</span> <span class="keyword">implements</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被适配的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Codec codec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过构造方法设置被适配的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codec</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodecAdapter</span><span class="params">(Codec codec)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(codec, <span class="string">"codec == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.codec = codec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object message)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        UnsafeByteArrayOutputStream os = <span class="keyword">new</span> UnsafeByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">        codec.encode(channel, os, message);</span><br><span class="line">        buffer.writeBytes(os.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.readableBytes()];</span><br><span class="line">        <span class="keyword">int</span> savedReaderIndex = buffer.readerIndex();</span><br><span class="line">        buffer.readBytes(bytes);</span><br><span class="line">        UnsafeByteArrayInputStream is = <span class="keyword">new</span> UnsafeByteArrayInputStream(bytes);</span><br><span class="line">        Object result = codec.decode(channel, is);</span><br><span class="line">        buffer.readerIndex(savedReaderIndex + is.position());</span><br><span class="line">        <span class="keyword">return</span> result == Codec.NEED_MORE_INPUT ? DecodeResult.NEED_MORE_INPUT : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Codec <span class="title">getCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> codec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CodecAdapter 使用<strong>对象适配模式</strong>完成对 Codec 类型的适配工作，即将 Codec 适配成 Codec2 。关于适配器模式可以参考 <a href="https://gentryhuang.com/posts/f5c535ea/">适配器模式</a> 。</p>
<h2 id="编解码继承关系"><a href="#编解码继承关系" class="headerlink" title="编解码继承关系"></a>编解码继承关系</h2><p>编解码 Codec2 的继承关系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-codec-hierarchy.jpg" alt></p>
<p>继承关系中包含了各层的编解码实现，本篇文章只介绍 Transport 层相关的实现，其它层相关的实现会在对应的层进行介绍。需要注意的是，Exchange 层的编解码实现依赖了 Transport 层的编解码实现，Protocol 层又依赖了 Exchange 层的编解码实现。可以发现，编解码器的实现通过继承的方式以获得更多的功能，每个编码器实现类编解码消息的逻辑都不一样。</p>
<h3 id="AbstractCodec"><a href="#AbstractCodec" class="headerlink" title="AbstractCodec"></a>AbstractCodec</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCodec</span> <span class="keyword">implements</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractCodec<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法，校验消息长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkPayload</span><span class="params">(Channel channel, <span class="keyword">long</span> size)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//  8M</span></span><br><span class="line">        <span class="keyword">int</span> payload = Constants.DEFAULT_PAYLOAD;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.getUrl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取配置允许最大的消息大小，默认 为 8 * 1024 * 1024;  8M</span></span><br><span class="line">            payload = channel.getUrl().getParameter(Constants.PAYLOAD_KEY, Constants.DEFAULT_PAYLOAD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超过允许最大的消息大小，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (payload &gt; <span class="number">0</span> &amp;&amp; size &gt; payload) &#123;</span><br><span class="line">            ExceedPayloadLimitException e = <span class="keyword">new</span> ExceedPayloadLimitException(<span class="string">"Data length too large: "</span> + size + <span class="string">", max payload: "</span> + payload + <span class="string">", channel: "</span> + channel);</span><br><span class="line">            logger.error(e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得Serialization对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serialization <span class="title">getSerialization</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CodecSupport.getSerialization(channel.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为客户端的通道</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isClientSide</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        String side = (String) channel.getAttribute(Constants.SIDE_KEY);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"client"</span>.equals(side)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"server"</span>.equals(side)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            InetSocketAddress address = channel.getRemoteAddress();</span><br><span class="line">            URL url = channel.getUrl();</span><br><span class="line">            <span class="keyword">boolean</span> client = url.getPort() == address.getPort()</span><br><span class="line">                    &amp;&amp; NetUtils.filterLocalHost(url.getIp()).equals(</span><br><span class="line">                    NetUtils.filterLocalHost(address.getAddress()</span><br><span class="line">                            .getHostAddress()));</span><br><span class="line">            channel.setAttribute(Constants.SIDE_KEY, client ? <span class="string">"client"</span></span><br><span class="line">                    : <span class="string">"server"</span>);</span><br><span class="line">            <span class="keyword">return</span> client;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为服务端的通道</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isServerSide</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !isClientSide(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是 Codec2 的抽象实现，提供了公用的一些方法，如校验消息长度是否超过阈值，根据URL获取 Serialization 扩展实现，判断当前通道属于客户端侧还是服务端侧。</p>
<h3 id="TransportCodec"><a href="#TransportCodec" class="headerlink" title="TransportCodec"></a>TransportCodec</h3><p>TransportCodec 的逻辑简单、粗暴，使用 Serialize 对所有消息直接序列化或者反序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportCodec</span> <span class="keyword">extends</span> <span class="title">AbstractCodec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 对 ChannelBuffer 进行装饰获得 Dubbo 输出流</span></span><br><span class="line">        OutputStream output = <span class="keyword">new</span> ChannelBufferOutputStream(buffer);</span><br><span class="line">        <span class="comment">// 获得用于序列化的ObjectOutput对象</span></span><br><span class="line">        ObjectOutput objectOutput = getSerialization(channel).serialize(channel.getUrl(), output);</span><br><span class="line">        <span class="comment">// 将消息写入 ObjectOutput</span></span><br><span class="line">        encodeData(channel, objectOutput, message);</span><br><span class="line">        objectOutput.flushBuffer();</span><br><span class="line">        <span class="comment">// 释放，kryo 的 KryoObjectInput 和 KryoObjectOutput 实现了 Cleanable 接口，需要释放资源。</span></span><br><span class="line">        <span class="keyword">if</span> (objectOutput <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) objectOutput).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//  对 ChannelBuffer 进行装饰获得 Dubbo 输入流</span></span><br><span class="line">        InputStream input = <span class="keyword">new</span> ChannelBufferInputStream(buffer);</span><br><span class="line">        <span class="comment">// 获得用于反序列的 ObjectInput 对象</span></span><br><span class="line">        ObjectInput objectInput = getSerialization(channel).deserialize(channel.getUrl(), input);</span><br><span class="line">        <span class="comment">// 从 ObjectInput 读取消息并反序列化为 对象</span></span><br><span class="line">        Object object = decodeData(channel, objectInput);</span><br><span class="line">        <span class="keyword">if</span> (objectInput <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) objectInput).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeData</span><span class="params">(Channel channel, ObjectOutput output, Object message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        encodeData(output, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decodeData</span><span class="params">(Channel channel, ObjectInput input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decodeData(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeData</span><span class="params">(ObjectOutput output, Object message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeObject(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decodeData</span><span class="params">(ObjectInput input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> input.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"ClassNotFoundException: "</span> + StringUtils.toString(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章简单介绍了 Transport 层及其必要性，然后从端点抽象类 AbstractPeer、AbstractEndpoint，语义端点抽象类 AbstractServer、AbstractServer，抽象通道 AbstractChannel 以及 通道关联的 ChannelHandler 多方面介绍了 Transport 层的实现，最后介绍了编解码的继承体系。不难发现，作为底层的 Transport，支持了消息/事件发送、处理、响应以及编解码，涉及的接口和类在功能层面上已经是一个闭环了。后面两篇文章会对本篇文章的抽象进行具体化。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/53cd7ee7/" title="Dubbo源码分析 - 网络传输层" target="_blank" rel="external">https://gentryhuang.com/posts/53cd7ee7/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/4468445c/" title="Dubbo源码分析 - Netty4网络通信"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/e79185fb/" title="Dubbo源码分析 - Buffer缓冲区"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2021 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>