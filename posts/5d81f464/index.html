<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Dubbo源码分析 - Dubbo SPI | gentryhuang的博客</title>
  <meta name="description" content="概述Dubbo并未使用jdk标准的SPI机制，而是对其进行了增强，优化了性能问题并且相比jdk spi更加健壮。 Dubbo SPI 对 JDK SPI的改进 JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源，而dubbo可以选择性实例化。 如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK标准的 ScriptEngine，">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo源码分析 - Dubbo SPI">
<meta property="og:url" content="https://gentryhuang.com/posts/5d81f464/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="概述Dubbo并未使用jdk标准的SPI机制，而是对其进行了增强，优化了性能问题并且相比jdk spi更加健壮。 Dubbo SPI 对 JDK SPI的改进 JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源，而dubbo可以选择性实例化。 如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK标准的 ScriptEngine，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-spi.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/extension-factory.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/spi-wrapper.jpg">
<meta property="article:published_time" content="2020-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-26T01:46:13.504Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="Dubbo">
<meta property="article:tag" content="SPI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-spi.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/5d81f464/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.29px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.71px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.14px;">I/O</a> <a href="/tags/JUC/" style="font-size: 13.43px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.29px;">Javassist</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.29px;">Protocol</a> <a href="/tags/RPC/" style="font-size: 13.57px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.14px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.29px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.29px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.86px;">设计模式</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/1d01ceec/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a>
              </p>
              <p class="item-title">
                <a href="/posts/1d01ceec/" class="title">时间轮算法 - HashedWheelTimer</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-24T02:06:24.000Z" itemprop="datePublished">2021-07-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/19fe4bc5/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/19fe4bc5/" class="title">Redis原理 - Redis主流程</a>
              </p>
              <p class="item-date">
                <time datetime="2021-06-24T06:59:01.000Z" itemprop="datePublished">2021-06-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/b25f5b99/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a>
              </p>
              <p class="item-title">
                <a href="/posts/b25f5b99/" class="title">网络通信 - IO多路复用</a>
              </p>
              <p class="item-date">
                <time datetime="2021-06-12T02:43:23.000Z" itemprop="datePublished">2021-06-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/51fff883/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a>
              </p>
              <p class="item-title">
                <a href="/posts/51fff883/" class="title">网络通信 - IO模型</a>
              </p>
              <p class="item-date">
                <time datetime="2021-06-05T07:36:47.000Z" itemprop="datePublished">2021-06-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/a26fab1/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/a26fab1/" class="title">Redis原理 - 事务</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-27T12:08:59.000Z" itemprop="datePublished">2021-05-27</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-SPI-对-JDK-SPI的改进"><span class="toc-number">2.</span> <span class="toc-text">Dubbo SPI 对 JDK SPI的改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI-核心概念"><span class="toc-number">3.</span> <span class="toc-text">SPI 核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-SPI-配置规范"><span class="toc-number">4.</span> <span class="toc-text">Dubbo SPI 配置规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例"><span class="toc-number">5.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-SPI-源码分析"><span class="toc-number">6.</span> <span class="toc-text">Dubbo SPI 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码结构"><span class="toc-number">6.1.</span> <span class="toc-text">代码结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展点-SPI-注解"><span class="toc-number">6.2.</span> <span class="toc-text">扩展点 SPI 注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展点-Adaptive-注解"><span class="toc-number">6.3.</span> <span class="toc-text">扩展点 Adaptive 注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展点-Activate-注解"><span class="toc-number">6.4.</span> <span class="toc-text">扩展点 Activate 注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ExtensionLoader"><span class="toc-number">6.5.</span> <span class="toc-text">ExtensionLoader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多类型的扩展点"><span class="toc-number">6.6.</span> <span class="toc-text">多类型的扩展点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#普通扩展类"><span class="toc-number">6.6.1.</span> <span class="toc-text">普通扩展类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#包装扩展类"><span class="toc-number">6.6.2.</span> <span class="toc-text">包装扩展类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#自适应类"><span class="toc-number">6.6.3.</span> <span class="toc-text">自适应类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#自动激活类"><span class="toc-number">6.6.4.</span> <span class="toc-text">自动激活类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ExtensionLoader-工作流程"><span class="toc-number">6.7.</span> <span class="toc-text">ExtensionLoader 工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#getExtension-方法"><span class="toc-number">6.7.1.</span> <span class="toc-text">getExtension 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getActivateExtension-方法"><span class="toc-number">6.7.2.</span> <span class="toc-text">getActivateExtension 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getAdaptiveExtension-方法"><span class="toc-number">6.7.3.</span> <span class="toc-text">getAdaptiveExtension 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hasExtension-方法"><span class="toc-number">6.7.4.</span> <span class="toc-text">hasExtension 方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dubbo-IOC-实现"><span class="toc-number">6.8.</span> <span class="toc-text">Dubbo IOC 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#扩展工厂接口"><span class="toc-number">6.8.1.</span> <span class="toc-text">扩展工厂接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AdaptiveExtensionFactory-工厂"><span class="toc-number">6.8.2.</span> <span class="toc-text">AdaptiveExtensionFactory 工厂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SpiExtensionFactory-工厂"><span class="toc-number">6.8.3.</span> <span class="toc-text">SpiExtensionFactory 工厂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SpringExtensionFactory-工厂"><span class="toc-number">6.8.4.</span> <span class="toc-text">SpringExtensionFactory 工厂</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dubbo-AOP-实现"><span class="toc-number">6.9.</span> <span class="toc-text">Dubbo AOP 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定义-Wrapper类"><span class="toc-number">6.9.1.</span> <span class="toc-text">定义 Wrapper类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#配置-Wrapper类"><span class="toc-number">6.9.2.</span> <span class="toc-text">配置 Wrapper类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dubbo-内置的Wrapper-举例"><span class="toc-number">6.9.3.</span> <span class="toc-text">Dubbo 内置的Wrapper 举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-rpc/spi机制之dubbo" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Dubbo源码分析 - Dubbo SPI
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/5d81f464/" class="article-date">
	  <time datetime="2020-03-12T16:00:00.000Z" itemprop="datePublished">2020-03-13</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/RPC/">RPC</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Dubbo/" rel="tag">Dubbo</a>, <a class="article-tag-link" href="/tags/SPI/" rel="tag">SPI</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/5d81f464/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 12.2k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 50(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Dubbo并未使用jdk标准的SPI机制，而是对其进行了增强，优化了性能问题并且相比jdk spi更加健壮。</p>
<h3 id="Dubbo-SPI-对-JDK-SPI的改进"><a href="#Dubbo-SPI-对-JDK-SPI的改进" class="headerlink" title="Dubbo SPI 对 JDK SPI的改进"></a>Dubbo SPI 对 JDK SPI的改进</h3><ul>
<li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源，而dubbo可以选择性实例化。</li>
<li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时会报不支持ruby，而不是真正失败的原因。</li>
<li>对 JDK SPI 配置文件进行了扩展和修改，兼容了 JDK SPI 配置。</li>
<li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li>
<li>原始jdk spi 不支持缓存，dubbo设计了多维度缓存，提高了框架的性能。</li>
</ul>
<h3 id="SPI-核心概念"><a href="#SPI-核心概念" class="headerlink" title="SPI 核心概念"></a>SPI 核心概念</h3><ol>
<li>扩展点：通过 SPI 机制查找并加载实现的接口成为扩展点，也叫做扩展接口</li>
<li>扩展(点)实现：实现了扩展点的实现类</li>
</ol>
<h3 id="Dubbo-SPI-配置规范"><a href="#Dubbo-SPI-配置规范" class="headerlink" title="Dubbo SPI 配置规范"></a>Dubbo SPI 配置规范</h3><ul>
<li><p>spi配置文件路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">META-INF&#x2F;dubbo&#x2F;internal : 主要用于 Dubbo 内部提供的拓展点实现</span><br><span class="line">META-INF&#x2F;dubbo : 主要用于自定义扩展点实现</span><br><span class="line">META-INF&#x2F;services : 用于兼容jdk的spi</span><br></pre></td></tr></table></figure>
<p><font color="#c7254e">说明:</font> 上面的 SPI 配置文件路径是种规范，实际上在使用的时候写在哪个文件下都可以被加载到，但是实际开放种最好按照规范配置。</p>
</li>
<li><p>spi配置文件名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扩展点全路径名</span><br></pre></td></tr></table></figure></li>
<li><p>文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key&#x3D;value形式，多个使用换行符分割，这是Dubbo配置的方式</span><br><span class="line">value形式，没有指定扩展名，这是jdk配置方式，Dubbo进行了兼容，会自动为扩展实现类生成默认的扩展名</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><font color="#c7254e">说明:</font> Dubbo SPI 通过键值对的方式进行配置，这样我们可以按需实例化扩展点的实现，而不是一次实例化所有的扩展实现类。此外，异常信息更加准确，便于定位问题，如在 Dubbo SPI 抛出异常时，一般会携带扩展名信息而不是直接抛出无法加载扩展实现类的异常信息。</p>
<ul>
<li>加载扩展实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dubbo使用ExtensionLoader加载指定实现类，Dubbo SPI 的逻辑几乎都封装在该类中。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>前面简单介绍了Dubbo SPI机制，下面我们通过一个例子来演示Dubbo SPI的简单用法。扩展点接口及实现复用 <a href="https://gentryhuang.com/posts/a9c33b8c/">spi机制之jdk示例</a> 中代码，区别是Dubbo SPI的接口使用@SPI注解进行标注。</p>
<p>定义扩展接口，使用@SPI注解进行标注</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.spi;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在META-INF/dubbo文件目录下创建一个文件，名称为Command的全路径名 com.alibaba.dubbo.spi.Command。 配置内容为扩展实现类及其扩展名，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start&#x3D;com.alibaba.dubbo.spi.impl.StartCommand</span><br><span class="line">shutdown&#x3D;com.alibaba.dubbo.spi.impl.ShutdownCommand</span><br></pre></td></tr></table></figure>

<p>准备就绪后，最后写测试代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// ExtensionLoader是dubbo提供的，用来加载拓展实现类</span></span><br><span class="line">       ExtensionLoader&lt;Command&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Command<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 加载指定扩展名对应的扩展实现对象（获取的时候会进行实例化）</span></span><br><span class="line">       Command startCommand = extensionLoader.getExtension(<span class="string">"start"</span>);</span><br><span class="line">       startCommand.execute();</span><br><span class="line"></span><br><span class="line">       Command shutdownCommand = extensionLoader.getExtension(<span class="string">"shutdown"</span>);</span><br><span class="line">       shutdownCommand.execute();</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start command</span><br><span class="line">shut down command</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>简单说明和演示Dubbo SPI后，我们对Dubbo SPI有了一定的认识，使用起来还是比较简单的，接下来进入源码分析阶段，让我们一起去看看Dubbo底层是怎么加载和选择扩展实现的。</p>
<h3 id="Dubbo-SPI-源码分析"><a href="#Dubbo-SPI-源码分析" class="headerlink" title="Dubbo SPI 源码分析"></a>Dubbo SPI 源码分析</h3><p>进行源码分析之前，我们先看下Dubbo SPI整体的代码结构，然后对核心注解和类进行说明。</p>
<h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-spi.jpg" alt></p>
<h4 id="扩展点-SPI-注解"><a href="#扩展点-SPI-注解" class="headerlink" title="扩展点 SPI 注解"></a>扩展点 SPI 注解</h4><p>扩展点接口标识，Dubbo的扩展点必须标注该注解，否则在执行SPI逻辑时框架会报异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SPI &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缺省扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SPI注解的value属性是用来指定扩展点的默认扩展名，如Protocol扩展接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>&#123;<span class="comment">//...&#125;  // dubbo对应的扩展实现类就是DubboProtocol，即Protocol默认的扩展实现类</span></span><br></pre></td></tr></table></figure>


<h4 id="扩展点-Adaptive-注解"><a href="#扩展点-Adaptive-注解" class="headerlink" title="扩展点 Adaptive 注解"></a>扩展点 Adaptive 注解</h4><p>该注解用来实现适配器功能，标注该注解的可能时类或扩展点中的方法。前者一般不实现任何具体的功能仅用来适配扩展接口的实现，如 AdaptiveExtensionFactory 用来适配 ExtensionFactory 的 SpiExtensionFactory 和 SpringExtensionFactory 这两种实现，它会根据运行时的状态选择合适的 ExtensionFactory 的实现。后者会动态生成适配器类，生成的这个适配器类的逻辑同样是在运行时选择合适的扩展实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据URL的Key获取对应的Value作为自适应拓展名。比如，&lt;code&gt;String[] &#123;"key1", "key2"&#125;&lt;/code&gt;，表示</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;先在URL上找key1的Value作为自适应拓展名；</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;key1没有value，则使用key2的value作为自适应拓展名。</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;key2没有value，就使用缺省的扩展，即： 如果&#123;<span class="doctag">@link</span> URL&#125;这些Key都没有value，使用缺省的扩展（在接口的&#123;<span class="doctag">@link</span> SPI&#125;中设定的值）</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;如果没有设置缺省扩展名或者缺省扩展名也没有value，则方法调用会抛出&#123;<span class="doctag">@link</span> IllegalStateException&#125;。</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * 注意：如果没有使用Adaptive注解指定扩展名，扩展接口也没有指定<span class="doctag">@SPI</span>默认值，则在加载扩展实现的时候dubbo会自动把扩展接口名称根据驼峰大小写分开，并使用 '.' 符号连接起来，</span></span><br><span class="line"><span class="comment">     *      以此名称作为默认扩展名。如：SimpleExt -&gt; simple.ext</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> parameter key names in URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个拓展接口，在框架中同时只能存在一个 Adaptive 拓展实现类，可能是固定的扩展实现类，也可能是自动生成、编译得到的扩展实现类。@Adaptive 注解，可添加类或方法上，分别代表了两种不同的使用方式。第一种，标记在类上（属于装饰类），整个实现类会作为自适应扩展类，Dubbo不会为该类生成代理类，它主要用于固定已知类。目前 Dubbo 项目里，只有 ExtensionFactory 拓展的实现类 AdaptiveExtensionFactory 和Compiler 拓展的实现AdaptiveCompiler这么使用。第二种，标记在扩展接口的方法上，代表自动生成、编译一个该接口的动态Adaptive拓展实现类（属于动态代理类，如Protocol$Adaptive），一般该类没有实际的工作，只是根据参数和运行状态加载其他的扩展实现来完成最终的工作。</p>
<h4 id="扩展点-Activate-注解"><a href="#扩展点-Activate-注解" class="headerlink" title="扩展点 Activate 注解"></a>扩展点 Activate 注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Activate &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * group过滤条件。在调用&#123;<span class="doctag">@link</span> ExtensionLoader#getActivateExtension(URL, String, String)&#125; 方法时，如果传入的group参数符合该注解设置的group属性值，则匹配。</span></span><br><span class="line"><span class="comment">     * 即 修饰的实现类是在 Provider 端被激活还是在 Consumer 端被激活</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] group() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key过滤条件。在调用&#123;<span class="doctag">@link</span> ExtensionLoader#getActivateExtension(URL, String, String)&#125; 方法时，如果url中的参数中存在该注解设置的key值，则激活。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension list which should be put before the current one</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] before() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension list which should be put after the current one</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] after() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> absolute ordering info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该注解用于设置扩展实现类被自动激活的加载条件，如：过滤器扩展点有多个实现，那么就可以使用该注解设置激活条件，在获取自动激活扩展实现时需要符合条件才能获取到。框架通过ExtensionLoader#getActivateExtension方法获得激活条件的扩展实现集合。</p>
<h4 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h4><p>Dubbo的扩展加载器，功能类似于 JDK SPI 中的 ServiceLoader。Dubbo SPI 的相关逻辑几乎都被封装在该类中，该类是 <code>Dubbo SPI 的 核心</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtensionLoader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//========================================= 类属性，所有ExtensionLoader对象共享 ================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dubbo扩展点目录 ，该目录是为了兼容jdk的spi</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICES_DIRECTORY = <span class="string">"META-INF/services/"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dubbo扩展点目录，主要用于自定义扩展点实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_DIRECTORY = <span class="string">"META-INF/dubbo/"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dubbo扩展点目录，用于 Dubbo 内部提供的拓展点实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + <span class="string">"internal/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点实现名的分隔符 正则表达式，多个扩展点名之间使用 ',' 进行分割</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern NAME_SEPARATOR = Pattern.compile(<span class="string">"\\s*[,]+\\s*"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点加载器集合</span></span><br><span class="line"><span class="comment">     * key: 拓展点接口</span></span><br><span class="line"><span class="comment">     * value: 扩展点加载器。 一个扩展点接口对应一个 扩展点加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点实现类集合</span></span><br><span class="line"><span class="comment">     * key: 扩展点实现类</span></span><br><span class="line"><span class="comment">     * value: 扩展点实现对象</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 一个扩展点通过对应的ExtensionLoader去加载它的具体实现，考虑到性能和资源问题，在加载拓展配置后不会立马进行扩展实现的对象的初始化，而是先把扩展配置存起来。</span></span><br><span class="line"><span class="comment">     * 等到真正使用对应的拓展实现时才进行扩展实现的对象的初始化，初始化后也进行缓存。即：</span></span><br><span class="line"><span class="comment">     * 1 缓存加载的拓展配置</span></span><br><span class="line"><span class="comment">     * 2 缓存创建的拓展实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==============================  实例属性 ，每个ExtensionLoader对象独有 ====================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点，如：Protocol</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点实现工厂，用于向扩展对象中注入依赖属性，一般通过调用 &#123;<span class="doctag">@link</span> #injectExtension(Object)&#125; 方法进行实现。</span></span><br><span class="line"><span class="comment">     * 特别说明：</span></span><br><span class="line"><span class="comment">     *  除了ExtensionFactory扩展接口，其余的所有扩展接口的ExtensionLoader对象都会拥有一个自己的扩展工厂，即 objectFactory = AdaptiveExtensionFactory；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExtensionFactory objectFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点实现类 到 扩展名 的映射</span></span><br><span class="line"><span class="comment">     * 如：</span></span><br><span class="line"><span class="comment">     * dubbo=dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol ===&gt; &lt;DubboProtocol,dubbo&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名 到 扩展点实现类 的映射</span></span><br><span class="line"><span class="comment">     * 不包括以下两种类型：</span></span><br><span class="line"><span class="comment">     * 1 自适应扩展实现类，如：AdaptiveExtensionFactory</span></span><br><span class="line"><span class="comment">     * 2 扩展点的Wrapper实现类，如：ProtocolFilterWrapper</span></span><br><span class="line"><span class="comment">     * 如：</span></span><br><span class="line"><span class="comment">     * dubbo=dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol ===&gt; &lt;dubbo,DubboProtocol&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class="keyword">new</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名 到 <span class="doctag">@Activate</span>注解 的映射， 如： ContextFilter -&gt; Activate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Activate&gt; cachedActivates = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Activate&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名 到 扩展点实现对象 的映射</span></span><br><span class="line"><span class="comment">     * 如：</span></span><br><span class="line"><span class="comment">     * dubbo=dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol ===&gt; &lt;dubbo,Holder&lt;DubboProtocol对象&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应扩展对象</span></span><br><span class="line"><span class="comment">     * 注意: 一个扩展点最多只能有一个自适应扩展对象，&gt; 1 框架就会报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Object&gt; cachedAdaptiveInstance = <span class="keyword">new</span> Holder&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应扩展实现类 &#123;<span class="doctag">@link</span> #getAdaptiveExtensionClass()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Class&lt;?&gt; cachedAdaptiveClass = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点的默认扩展名，通过 &#123;<span class="doctag">@link</span> SPI&#125; 注解获得，即记录了 type 对应扩展接口上 <span class="doctag">@SPI</span> 注解的 value 值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String cachedDefaultName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建自适应对象时发生的异常 -&gt; &#123;<span class="doctag">@link</span> #createAdaptiveExtension()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Throwable createAdaptiveInstanceError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点Wrapper实现类集合，如：ProtocolFilterWrapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名 到 加载对应扩展类发生的异常 的映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IllegalStateException&gt; exceptions = <span class="keyword">new</span> ConcurrentHashMap&lt;String, IllegalStateException&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1 任意一个扩展点在获取对应的ExtensionLoader时，都会先尝试获取属于它的ExtensionFactory自适应扩展，即 AdaptiveExtensionFactory，</span></span><br><span class="line"><span class="comment">     * 它管理着SpiExtensionFactory和SpringExtensionFactory这两大扩展点工厂，用于调用 &#123;<span class="doctag">@link</span> #injectExtension(Object)&#125;方法，向扩展实现中注入依赖属性，</span></span><br><span class="line"><span class="comment">     * 需要注意的是，SpiExtensionFactory和SpringExtensionFactory获得对象是不同的，前者获取自适应对象，后者从Spring容器中获取对象。</span></span><br><span class="line"><span class="comment">     * 2 当扩展点是ExtensionFactory时，那么它的对应的ExtensionLoader的objectFactory 属性为null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 扩展点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 省略其它代码...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于性能的考虑，Dubbo SPI相比较与JDK SPI的一个改进就是使用了大量的缓存，Dubbo SPI 缓存从大的方向可分为 <code>类缓存</code>、<code>实例缓存</code>，这两种缓存又能根据扩展实现类的种类分为 <code>普通扩展缓存</code>、<code>包装扩展缓存</code>、<code>自适应扩展缓存</code>。</p>
<ul>
<li>类缓存<blockquote>
<p>Dubbo SPI在查询扩展类时，会先从缓存中获取，如果缓存中不存在，再加载配置文件并分类缓存，注意，这个过程不会进行初始化流程。</p>
</blockquote>
</li>
<li>实例缓存<blockquote>
<p>Dubbo SPI缓存的Class是按需进行实例化的，在查询实例时会先从缓存中获取，如果缓存不存在则会进行加载/初始化，然后缓存起来。</p>
</blockquote>
</li>
</ul>
<h4 id="多类型的扩展点"><a href="#多类型的扩展点" class="headerlink" title="多类型的扩展点"></a>多类型的扩展点</h4><p>根据扩展实现类的特点及用途可以分为普通扩展类、自动激活扩展类、包装扩展类以及自适应扩展类，其中自动激活扩展类属于普通扩展类。需要注意的是，除了动态编译得到的自适应扩展类，其它的所有扩展类都需要在配置文件中进行配置，否则框架无法加载到。下面我们简单说明下各个类型的扩展类及其特点。</p>
<h5 id="普通扩展类"><a href="#普通扩展类" class="headerlink" title="普通扩展类"></a>普通扩展类</h5><p>属于最基础的扩展类，一般通过扩展名获取对应的扩展实现就是该类型。在配置普通扩展类时需要指定扩展名，不指定会按规则自动生成，因为普通扩展实现都是根据扩展名获取的。</p>
<h5 id="包装扩展类"><a href="#包装扩展类" class="headerlink" title="包装扩展类"></a>包装扩展类</h5><p>包括扩展类又叫 <code>Wrapper类</code>，一般不是扩展点的真正实现，主要用来对扩展实现进行功能增强或通用逻辑处理。Wrapper类有两个特征：<code>实现扩展接口</code>、<code>存在一个参数类型是扩展点的构造方法</code>。Wrapper类是Dubbo <code>AOP</code>的实现。在配置Wrapper类时，可以不指定扩展名，即使指定了也不会使用，但一般情况根据Dubbo SPI的约定还是统一配置。</p>
<h5 id="自适应类"><a href="#自适应类" class="headerlink" title="自适应类"></a>自适应类</h5><p>自适应类非常灵活，也叫 <code>Adaptive类</code>，更直观的称为适配器类，有两种实现方式。Adaptive类的两个特征：<code>实现扩展接口</code>、<code>实现类或扩展接口的方法上需要使用 @Adaptive 标注</code>。类上标注@Adaptive是一个Adaptive类可以理解，但是扩展接口的方法上标注@Adaptive怎么会是一个类呢？是因为标注在扩展接口的方法上，Dubbo SPI机制在获取自适应扩展实现类时，如果当前环境中没有自适应扩展实现类就会对标注的方法所在接口进行javassist操作，生成自适应扩展类的字符串，然后通过动态编译成一个自适应类。@Adaptive标注在扩展接口的方法上的方式，可以动态地通过URL中的参数来确定使用哪个扩展实现。在配置文件中可以不指定扩展名，即使指定了也不会使用，但一般情况根据Dubbo SPI的约定还是统一配置。需要注意，自适应扩展类什么实际工作都不做，只是根据参数和状态选择其它实现而已。</p>
<h5 id="自动激活类"><a href="#自动激活类" class="headerlink" title="自动激活类"></a>自动激活类</h5><p>自动激活类属于特殊的普通扩展类，该类的两个特征：<code>实现接口</code>、<code>类上使用 @Activate 标注</code>。它支持某个扩展点需要同时激活多个实现的特性，如 Dubbo中的过滤器扩展点，需要激活多个扩展实现。</p>
<h4 id="ExtensionLoader-工作流程"><a href="#ExtensionLoader-工作流程" class="headerlink" title="ExtensionLoader 工作流程"></a>ExtensionLoader 工作流程</h4><p>ExtensionLoader封装了Dubbo SPI的主要逻辑，配置的加载、扩展类缓存、扩展实现的实例化及缓存、自适应类的生成与编译及缓存、自适应对象的实例化及缓存以及Dubbo IOC 和 AOP 的实现等。这些逻辑主要体现在三个入口方法中，每个入口方法获取到的扩展实现类型会有所不同，但是方法内部逻辑有相同之处。下面我们分别从三个入口方法开始详细分析Dubbo SPI的整个流程，需要说明的是，getExtension方法是最核心的方法，其它两个入口方法都会依赖该方法中的部分流程，因此我们会先分析getExtension方法，在分析其它两个方法的时候涉及重复的流程就不再分析。</p>
<h5 id="getExtension-方法"><a href="#getExtension-方法" class="headerlink" title="getExtension 方法"></a>getExtension 方法</h5><p>ExtensionLoader中最核心的方法，因为它实现了一个完整的查询扩展实现的逻辑。获取过程中的每一步都会先检查缓存是否命中，命中就直接返回或进行赋值，没有命中则加载配置文件，然后缓存配置文件中的扩展实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获得指定扩展名的扩展对象</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> name 扩展名</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果当前扩展名是 'true'，就获取默认的扩展对象</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="string">"true"</span>.equals(name)) &#123;</span><br><span class="line">         <span class="comment">// 方法简化为 getExtension(cachedDefaultName) , cacheDefaultName的值参见 @SPI注解</span></span><br><span class="line">         <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 从缓存中获得对应的扩展对象</span></span><br><span class="line">     Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line">     <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">         cachedInstances.putIfAbsent(name, <span class="keyword">new</span> Holder&lt;Object&gt;());</span><br><span class="line">         holder = cachedInstances.get(name);</span><br><span class="line">     &#125;</span><br><span class="line">     Object instance = holder.get();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 缓存中没有， 双重检锁获取扩展名对应扩展实现对象</span></span><br><span class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">             instance = holder.get();</span><br><span class="line">             <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 缓存中确实没有，就创建扩展名对应的扩展实现对象</span></span><br><span class="line">                 instance = createExtension(name);</span><br><span class="line">                 <span class="comment">// 将扩展实现对象放入缓存中</span></span><br><span class="line">                 holder.set(instance);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> (T) instance;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码逻辑比较简单，根据扩展名获取扩展对象，先检查缓存中是否有目标对象，没有则调用 <code>createExtension</code>方法开始创建扩展对象。需要特被说明的是，如果name是true的情况，加载的就是默认扩展类。那么下面我们来分析createExtension方法流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建扩展名对应的扩展点实现对象并缓存到类属性的集合中</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取扩展名对应的扩展点实现类，先尝试从缓存中取对应的扩展实现类，没有的话就加载配置文件然后再次获取</span></span><br><span class="line">       Class&lt;?&gt; clazz =</span><br><span class="line">               getExtensionClasses()</span><br><span class="line">                       .get(name);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 没有找到扩展名对应的扩展点实现类，则报错</span></span><br><span class="line">       <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> findException(name);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 从类属性缓存集合中尝试获取扩展点实现类对应的对象</span></span><br><span class="line">           T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 当缓存中没有，就通过反射创建扩展点实现类对象并放入缓存</span></span><br><span class="line">           <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">               EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">               instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// dubbo ioc实现，进行setter注入</span></span><br><span class="line">           injectExtension(instance);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * dubbo aop实现</span></span><br><span class="line"><span class="comment">            * 注意：</span></span><br><span class="line"><span class="comment">            *  如果当前扩展点存在 Wrapper类，那么从ExtensionLoader 中获得的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类，因此调用方法时调用的是Wrapper类中的方法，并非直接调用扩展点的真正实现。</span></span><br><span class="line"><span class="comment">            *  即 如果在Wrapper的方法中不显示调用扩展点的真正实现的话，那么结果一定不是预期的。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">           <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                   <span class="comment">// 创建 Wrapper 实例，然后进行 setter注入依赖属性</span></span><br><span class="line">                   instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> instance;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension instance(name: "</span> + name + <span class="string">", class: "</span> +</span><br><span class="line">                   type + <span class="string">")  could not be instantiated: "</span> + t.getMessage(), t);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>createExtension(String name)方法的逻辑代码中已经详细注释说明，下面小结关键的步骤：</p>
<ol>
<li>调用getExtensionClasses()刷新扩展点实现类集合</li>
<li>通过反射创建扩展点的扩展对象并放入类缓存中</li>
<li>使用Dubbo的setter注入向扩展对象中注入依赖属性</li>
<li>使用扩展点的Wrapper对扩展对象实现Dubbo的aop处理逻辑<br>

</li>
</ol>
<p>通过扩展名获取扩展对象时可能不能命中缓存，此时就要创建扩展对象，创建扩展对象需要扩展实现类，下面我们看下Dubbo获取扩展名到扩展实现类的映射集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取扩展点实现类的集合，先从缓存中获取，没有命中缓存就从配置文件中加载并分类放入缓存。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 先从缓存中获取</span></span><br><span class="line">      Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 双重检锁，获取扩展点的扩展实现类集合</span></span><br><span class="line">      <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">              classes = cachedClasses.get();</span><br><span class="line">              <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 加载扩展类</span></span><br><span class="line">                  classes = loadExtensionClasses();</span><br><span class="line">                  <span class="comment">// 将 扩展名到扩展点实现类的映射 加入到 cachedClasses 集合中，缓存起来</span></span><br><span class="line">                  cachedClasses.set(classes);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> classes;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果缓存不能命中扩展名对应的扩展实现类就只能加载配置文件刷新扩展点实现类集合,下面我们看下Dubbo是如何加载配置文件的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">//1、 通过@SPI注解获得扩展点的默认扩展名（前提是当前拓展点需要有@SPI注解，其实程序执行到这里type一定是有@SPI注解的，因为在获取扩展点的扩展加载器的时候已经判断了）</span></span><br><span class="line">    <span class="keyword">final</span> SPI defaultAnnotation = type.getAnnotation(SPI<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.1 如果扩展点的@SPI注解设置了默认值</span></span><br><span class="line">    <span class="keyword">if</span> (defaultAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @SPI注解的值就是扩展点的默认扩展名</span></span><br><span class="line">        String value = defaultAnnotation.value();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对默认扩展名进行分隔处理，以逗号分隔为字符串数组</span></span><br><span class="line">            String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测 SPI 注解内容是否合法，不合法则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"more than 1 default extension name on extension "</span> + type.getName()</span><br><span class="line">                        + <span class="string">": "</span> + Arrays.toString(names));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** 设置默认名称，cachedDefaultName 是用来加载扩展点的默认实现 &#123;<span class="doctag">@link</span> #getDefaultExtension()&#125; */</span></span><br><span class="line">            <span class="keyword">if</span> (names.length == <span class="number">1</span>) &#123;</span><br><span class="line">                cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、 从配置文件中加载拓展实现类集合，这里分别对应三类文件（1. Dubbo内置的 2. Dubbo自定义 3. JDK SPI）</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY);</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到该方法没有太多的逻辑，主要处理扩展点的默认扩展名，如果存在的化就放入缓存中，具体加载配置文件的逻辑由loadDirectory方法实现。 需要注意的是，唯一调用该方法的入口 {@link #getExtensionClasses()} 已经加过了锁，因此此处无需再次加锁。接下来继续分析Dubbo如何加载配置文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接完整的文件名（相对路径）： 目录 + type全类名</span></span><br><span class="line">    String fileName = dir + type.getName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类加载器</span></span><br><span class="line">        ClassLoader classLoader = findClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 获得文件名对应的所有文件数组（可能同一个文件名在不同的目录结构中，这样就会获取多个文件）,每个文件内容封装到一个java.net.URL中*/</span></span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            urls = classLoader.getResources(fileName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历java.net.URL集合</span></span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.URL resourceURL = urls.nextElement();</span><br><span class="line">                <span class="comment">// 加载java.net.URL</span></span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"Exception when load extension class(interface: "</span> +</span><br><span class="line">                type + <span class="string">", description file: "</span> + fileName + <span class="string">")."</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面代码可以看出,loadDirectory方法主要就做一件事，加载配置文件并将每个配置文件内容封装到java.net.URL集合中，接下来在loadResource方法中就可以从该URL中依次解析扩展名和扩展实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 加载配置文件内容（已经封装成了java.net.URL）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> extensionClasses 扩展类集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> classLoader      类加载器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> resourceURL      文件内容资源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 读取文件内容</span></span><br><span class="line">           BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(resourceURL.openStream(), <span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">               String line;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 一行一行的读取。会跳过当前被注释掉行，例如：#dubbo=xxx</span></span><br><span class="line">               <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 如果有#注释，那么ci为0，没有就为-1</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">'#'</span>);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 在有#注释的情况下，此时line的长度为0</span></span><br><span class="line">                   <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 去除前后端空格，防止自定义扩展点实现时配置不规范</span></span><br><span class="line">                   line = line.trim();</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 没有#注释的情况</span></span><br><span class="line">                   <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">/**</span></span><br><span class="line"><span class="comment">                            * 拆分 key=value ，name为拓展名 line为拓展实现类名。注意：</span></span><br><span class="line"><span class="comment">                            * 1 这里name可能为空,这种情况扩展名会自动生成（因为Dubbo SPI兼容Java SPI，Dubbo SPI配置强调key=value格式，应该尽可能遵守规则）</span></span><br><span class="line"><span class="comment">                            * 2 扩展名只对普通扩展才有意义，对自适应扩展、Wrapper是没用的，之所以要配置，是为了统一dubbo spi配置规则</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line"></span><br><span class="line">                           String name = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// i &gt; 0，有扩展名； i &lt; 0 没有配置扩展名，即兼容Java SPI</span></span><br><span class="line">                           <span class="keyword">int</span> i = line.indexOf(<span class="string">'='</span>);</span><br><span class="line"></span><br><span class="line">                           <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="comment">/** 获取 = 左边的key 即扩展名 */</span></span><br><span class="line">                               name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                               <span class="comment">/** 获取 = 右边的value 即拓展点的实现的全限定性类名 */</span></span><br><span class="line">                               line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// 加载当前行对应的扩展点配置</span></span><br><span class="line">                           <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                * 1 通过反射，根据名称获取扩展点实现类</span></span><br><span class="line"><span class="comment">                                * 2 对扩展实现类进行分类缓存</span></span><br><span class="line"><span class="comment">                                */</span></span><br><span class="line">                               loadClass(extensionClasses, resourceURL, Class.forName(line, <span class="keyword">true</span>, classLoader), name);</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                           IllegalStateException e = <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to load extension class(interface: "</span> + type + <span class="string">", class line: "</span> + line + <span class="string">") in "</span> + resourceURL + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                           exceptions.put(line, e);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               reader.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           logger.error(<span class="string">"Exception when load extension class(interface: "</span> +</span><br><span class="line">                   type + <span class="string">", class file: "</span> + resourceURL + <span class="string">") in "</span> + resourceURL, t);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>loadResource方法用于将配置文件中的每行记录读取出来，经过解析和反射处理就能拿到扩展名和对应的扩展实现类，扩展名和扩展实现类的获取逻辑已经在代码中详细注释。最后调用loadClass方法进行分类缓存，这些缓存很多，我们来看下Dubbo是如何处理实例缓存的分类的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对扩展点实现类进行分类缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> extensionClasses 扩展实现类集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resourceURL      文件内容资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz            扩展点实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name             扩展名  【只对普通扩展才有意义】</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断拓展点实现类，是否实现了当前type接口，没有实现就会报错</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error when load extension class(interface: "</span> +</span><br><span class="line">                type + <span class="string">", class line: "</span> + clazz.getName() + <span class="string">"), class "</span></span><br><span class="line">                + clazz.getName() + <span class="string">"is not subtype of interface."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------- 根据扩展点实现类的类型可分为三大类 ，在进行分类缓存中有优先级，即同一个实现类只能归属到某个分类中 --------------------------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、自适应扩展类</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * （1）当前扩展点实现类是否标注<span class="doctag">@Adaptive</span>注解，标记的话就是自适应扩展类，直接缓存到 cachedAdaptiveClass 属性中，然后结束逻辑，即不会进行下面的 Wrapper、普通扩展类以及自动激活类逻辑判断。</span></span><br><span class="line"><span class="comment">     * （2）自适应固定扩展实现类其实不需要配置扩展名，即使配置了也用不到，因为自适应扩展类和自适应扩展对象整个转换闭环都用不到扩展名。之所以配置，是为了统一规则。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="comment">// 一个扩展点有且仅允许一个自适应扩展实现类，如果符合条件就加入到缓存中，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedAdaptiveClass = clazz;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"More than 1 adaptive class found: "</span></span><br><span class="line">                    + cachedAdaptiveClass.getClass().getName()</span><br><span class="line">                    + <span class="string">", "</span> + clazz.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  2、Wrapper类型 （该类需要有有一个参数的构造方法，且这个参数类型是当前的扩展点type）</span></span><br><span class="line"><span class="comment">         *  说明：</span></span><br><span class="line"><span class="comment">         *  （1）当前扩展点实现类如果是Wrapper类，直接缓存到 cachedWrapperClasses 属性集合中，然后结束逻辑，即不会进行下面的 普通扩展类以及自动激活类逻辑判断。</span></span><br><span class="line"><span class="comment">         *  （2）Wrapper类其实不需要配置扩展名，即使配置了也用不到。之所以配置，是为了统一规则。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrappers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">            wrappers = cachedWrapperClasses;</span><br><span class="line">        &#125;</span><br><span class="line">        wrappers.add(clazz);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3、普通的扩展实现类，注意Activate自动激活类从大的方面也属于普通的扩展实现类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否有默认的构造方法，没有会抛出异常</span></span><br><span class="line">        clazz.getConstructor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未配置扩展名，则自动生成。适用于Java SPI的配置方式（Dubbo SPI 兼容Java SPI） 例如： xxx.yyy.DemoFilter生成的拓展名为demo</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 自动生成扩展名</span></span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such extension name for the class "</span> + clazz.getName() + <span class="string">" in the config "</span> + resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对扩展名进行分割处理，dubbo支持配置多个扩展名。如果配置多个扩展名需要以','分割</span></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (names != <span class="keyword">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.1、 如果当前类标注了@Activate，就缓存到 cachedActivates集合。需要注意的是，即使扩展点配置多个，cachedActivates 的key 只取第一个。</span></span><br><span class="line">            Activate activate = clazz.getAnnotation(Activate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (activate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 拓展名与 @Activate的映射</span></span><br><span class="line">                cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 3.2、缓存当前扩展点分类到 cachedNames 集合 和 cachedClasses 集合</span></span><br><span class="line"><span class="comment">             * 说明：</span></span><br><span class="line"><span class="comment">             *  （1）cachedNames 缓存集合中的数据特点：同一个扩展点实现类对应的扩展名即使在配置多个扩展名的情况下也只取第一个</span></span><br><span class="line"><span class="comment">             *  （2）cachedClasses 缓存集合的数据特点：同一个扩展点实现类对应的扩展名可能存在多个</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存扩展类到扩展名的映射</span></span><br><span class="line">                <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                    cachedNames.put(clazz, n);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存扩展名到扩展类的映射，注意如果在不同的文件中配置同一个扩展点实现，并且扩展名有相同的情况，这时以解析的第一个为准</span></span><br><span class="line">                Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    extensionClasses.put(n, clazz);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate extension "</span> + type.getName() + <span class="string">" name "</span> + n + <span class="string">" on "</span> + c.getName() + <span class="string">" and "</span> + clazz.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可知，loadClass方法主要就是分类缓存不同扩展实现类，这个过程不涉及扩展实现类的实例化，这也验证了前面的结论，Dubbo SPI是按需实例化对象。到这里getExtension方法主要过就分析完了，前面也说到该方法是加载扩展实现的完整逻辑，其它的两个入口中的逻辑也会使用上面过程中的部分逻辑，在下面的代码分析中我们可以看到。</p>
<h5 id="getActivateExtension-方法"><a href="#getActivateExtension-方法" class="headerlink" title="getActivateExtension 方法"></a>getActivateExtension 方法</h5><p>该方法只是根据不同的条件同时激活多个普通扩展实现类，即会做一些通用的判断来筛选是否是激活扩展扩展对象。前面多次提到该法会依赖getExtension方法中的逻辑，下面我就一起来看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得激活条件的扩展实现对象集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url    url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 激活的扩展名数组，可能为空。如：获取dubbo内置的过滤器时，key=service.filter，url中没有对应的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> group  过滤分组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被激活的扩展实现对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.common.extension.Activate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 激活扩展实现对象结果集</span></span><br><span class="line">        List&lt;T&gt; exts = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 激活的扩展名集合</span></span><br><span class="line">        List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">0</span>) : Arrays.asList(values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  判断扩展名集合中是否有 '-default' , 如： &lt;dubbo:service filter="-default"/&gt; 代表移出所有默认的过滤器。注意，names是个空的List是符合条件的</span></span><br><span class="line">        <span class="keyword">if</span> (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取/刷新 扩展点实现类的集合</span></span><br><span class="line">            getExtensionClasses();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 遍历cachedActivates (拓展名 到 <span class="doctag">@Activate</span> 的映射)</span></span><br><span class="line"><span class="comment">             * 1 匹配分组，匹配成功则继续逻辑，否则不处理 加载配置文件时收集到的激活扩展类</span></span><br><span class="line"><span class="comment">             * 2 对激活扩展类进行实例化[初次才会，以后就从缓存中取]</span></span><br><span class="line"><span class="comment">             * 3 判断当前缓存中的激活扩展类是否和传入的激活扩展类冲突，如果有冲突，就忽略缓存中的激活扩展类，以传入的扩展类为主</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扩展名</span></span><br><span class="line">                String name = entry.getKey();</span><br><span class="line">                <span class="comment">// Activate</span></span><br><span class="line">                Activate activate = entry.getValue();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 匹配分组，判断Activate注解的group属性值是否包含当前传入的group，包含就符合分组条件</span></span><br><span class="line">                <span class="keyword">if</span> (isMatchGroup(group, activate.group())) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取扩展名对应的扩展点实现对象</span></span><br><span class="line">                    T ext = getExtension(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 是否忽略 加载配置文件时收集到的激活扩展类</span></span><br><span class="line">                    <span class="keyword">if</span> (!names.contains(name) <span class="comment">// 匹配扩展名</span></span><br><span class="line">                            &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name) <span class="comment">// 如果包含 '-' 表示不激活该扩展实现</span></span><br><span class="line">                            &amp;&amp; isActive(activate, url)) <span class="comment">// 检测URL中是否出现了指定的key</span></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        exts.add(ext);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对扩展对象进行排序（根据注解的before、after、order属性）</span></span><br><span class="line">            Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// z执行到此步骤的时候Dubbo原生的Filter已经添加完毕了，下面处理自定义的Filter</span></span><br><span class="line">        List&lt;T&gt; usrs = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="comment">// 遍历传入的激活扩展名集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取激活扩展名</span></span><br><span class="line">            String name = names.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否是 移除激活扩展名，如果是就忽略。 如： &lt;dubbo:service filter="-demo"/&gt;，那么此时demo对应的扩展实现就是属于无效的</span></span><br><span class="line">            <span class="keyword">if</span> (!name.startsWith(Constants.REMOVE_VALUE_PREFIX) &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理 自定义的激活扩展配置在默认的激活扩展前面的情况, 如： &lt;dubbo:service filter="demo,default"/&gt;，那么自定义的demo激活扩展就优先默认的激活扩展。主要是exts中的值变化，前面已经处理了默认的激活扩展(加载配置文件时收集到的激活扩展类)</span></span><br><span class="line">                <span class="keyword">if</span> (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!usrs.isEmpty()) &#123;</span><br><span class="line">                        exts.addAll(<span class="number">0</span>, usrs);</span><br><span class="line">                        usrs.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 获得激活扩展实现对象</span></span><br><span class="line">                    T ext = getExtension(name);</span><br><span class="line">                    usrs.add(ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!usrs.isEmpty()) &#123;</span><br><span class="line">            exts.addAll(usrs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exts;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>获取激活的扩展对象逻辑在代码中已经详细注释说明，获取扩展实现对象还是调用了getExtension方法。该方法主要步骤：</p>
<ol>
<li>如果触发获取扩展实现类动作时，会检查缓存，如果缓存中没有，就加载配置文件来刷新扩展实现类集合。</li>
<li>遍历缓存中的激活集合（这个缓存内容是加载的带有@Activate注解的扩展类信息），根据传入的URL匹配条件筛选出符合激活条件的扩展类实现，然后进行排序操作。</li>
<li>遍历传入的激活扩展名集合，根据设置的顺序调整扩展点激活顺序，其中default代表的是所有@Activate标注并且配置在配置文件中的扩展实现类</li>
<li>通过getExtension(name)获取激活扩展名对应的扩展对象并加入结果集合</li>
<li>返回符合条件的激活类集合</li>
</ol>
<h5 id="getAdaptiveExtension-方法"><a href="#getAdaptiveExtension-方法" class="headerlink" title="getAdaptiveExtension 方法"></a>getAdaptiveExtension 方法</h5><p>获取自适应扩展对象的入口，即适配器对象。如果获取的自适应扩展类属于固定的，那么该方法相对独立，几乎不依赖getExtension方法的逻辑。如果属于动态生成则内部也会调用getExtension方法。由于该方法会涉及到javassist、动态编译等技术，内容较多且比较复杂，这里不再进行分析，我会单独写一篇文章进行详细说明。下面先给出固定的自适应扩展类和自动生成的自适应扩展类的示例，让胖友们有个概念。</p>
<p>固定的自适应扩展类，以编译扩展接口为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AdaptiveCompiler. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * 实现Compiler接口，自适应Compiler实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveCompiler</span> <span class="keyword">implements</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认编辑器的拓展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> String DEFAULT_COMPILER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法，设置默认编辑器的拓展名。该方法被 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.config.ApplicationConfig#setCompiler(java.lang.String)&#125;方法调用.</span></span><br><span class="line"><span class="comment">     * 在&lt;dubbo:application compiler=""/&gt; 配置下可触发该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> compiler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultCompiler</span><span class="params">(String compiler)</span> </span>&#123;</span><br><span class="line">        DEFAULT_COMPILER = compiler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123;</span><br><span class="line">        Compiler compiler;</span><br><span class="line">        <span class="comment">// 获得Compiler的ExtensionLoader对象</span></span><br><span class="line">        ExtensionLoader&lt;Compiler&gt; loader = ExtensionLoader.getExtensionLoader(Compiler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 声明 name 变量，引用 DEFAULT_COMPILER 的值，避免下面的值变了</span></span><br><span class="line">        String name = DEFAULT_COMPILER;</span><br><span class="line">        <span class="comment">// 使用设置的拓展名，获得Compiler拓展对象</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            compiler = loader.getExtension(name);</span><br><span class="line">            <span class="comment">// 获得默认的Compiler拓展对象</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            compiler = loader.getDefaultExtension();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用真正的Compiler对象，动态编译代码</span></span><br><span class="line">        <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态生成的自适应扩展类，以ZookeeperTransporter扩展接口为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperTransporter</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">dubbo</span>.<span class="title">remoting</span>.<span class="title">zookeeper</span>.<span class="title">ZookeeperTransporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> com.alibaba.dubbo.remoting.zookeeper.<span class="function">ZookeeperClient <span class="title">connect</span><span class="params">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(<span class="string">"client"</span>, url.getParameter(<span class="string">"transporter"</span>, <span class="string">"curator"</span>));</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter) name from url("</span> + url.toString() + <span class="string">") use keys([client, transporter])"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter extension = (com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter) ExtensionLoader</span><br><span class="line">                .getExtensionLoader(com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">getExtension</span>(<span class="title">extName</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> extension.connect(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="hasExtension-方法"><a href="#hasExtension-方法" class="headerlink" title="hasExtension 方法"></a>hasExtension 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有对应的扩展实现类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 扩展名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 没有name对应的扩展实现类就抛出异常，即最后返回false</span></span><br><span class="line">            <span class="keyword">this</span>.getExtensionClass(name);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码比较简单，根据扩展名判断是否有对应的扩展实现类，之所以单独拿出来介绍是Dubbo的很多流程会用到该方法，有个印象就可以了。</p>
<h4 id="Dubbo-IOC-实现"><a href="#Dubbo-IOC-实现" class="headerlink" title="Dubbo IOC 实现"></a>Dubbo IOC 实现</h4><p>Dubbo IOC 实现目前仅支持setter注入，严谨来说，Dubbo IOC 实现方式还可以通过构造注入，即Wrapper类的实现。Dubbo的setter注入要求是，如果某个扩展类是另外一个扩展点实现类的成员属性，并且拥有对应的setter方法，那么Dubbo就会自动注入对应的扩展点实现对象。这个功能在上面创建扩展实现的时候需要用到，当时没有详细说明，下面我们单独来分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 依赖注入</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> instance 扩展实现对象 （注意，可能会是一个Wrapper）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 只有ExtensionFactory扩展点对应的ExtensionLoader对象的该属性为null，其它扩展点的ExtensionLoader对象的该属性必然不为null</span></span><br><span class="line">           <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 反射获得扩展实现对象中的所有方法</span></span><br><span class="line">               <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 过滤规则为 ' set开头 + 仅有一个参数 + public ' 的方法</span></span><br><span class="line">                   <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br><span class="line">                           &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                           &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        * 检查方法是否有 <span class="doctag">@DisableInject</span> 注解，有该注解就忽略依赖注入</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                       <span class="keyword">if</span> (method.getAnnotation(DisableInject<span class="class">.<span class="keyword">class</span>) !</span>= <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 获取setter方法参数类型</span></span><br><span class="line">                       Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// 获得属性名，如：setXxx -&gt; xxx</span></span><br><span class="line">                           String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">/**</span></span><br><span class="line"><span class="comment">                            * 通过扩展工厂获得属性值，即 方法参数类型作为扩展点，属性名作为扩展名。</span></span><br><span class="line"><span class="comment">                            * ExtensionFactory的实现有三个,AdaptiveExtensionFactory是对其它两个工厂的管理，getExtension方法的真正调用的是其它两个工厂的方法:</span></span><br><span class="line"><span class="comment">                            *  1）SpringExtensionFactory</span></span><br><span class="line"><span class="comment">                            *   getExtension方法会返回容器中名称为property并且类型为pt的bean对象</span></span><br><span class="line"><span class="comment">                            *  2）SpiExtensionFactory</span></span><br><span class="line"><span class="comment">                            *   getExtension方法会返回类型为pt的自适应拓展对象，因为该方法会校验pt是接口类型并且有<span class="doctag">@SPI</span>注解，然后pt有拓展类的情况下，就会获取pt的自适应拓展对象，property没用到</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                           Object object = objectFactory.getExtension(pt, property);</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// 通过反射设置属性值</span></span><br><span class="line">                           <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               method.invoke(instance, object);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                           logger.error(<span class="string">"fail to inject via method "</span> + method.getName()</span><br><span class="line">                                   + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           logger.error(e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Dubbo的ioc基于setter方法注入依赖的，注入的依赖来源则需要通过扩展工厂提供，接下来我们来分析Dubbo的扩展工厂。</p>
<h5 id="扩展工厂接口"><a href="#扩展工厂接口" class="headerlink" title="扩展工厂接口"></a>扩展工厂接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get extension. 获得扩展对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type object type. 扩展接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name object name. 扩展名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object instance. 扩展实现实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExtensionFactory 扩展工厂，是Dubbo的一个扩展点。主要用于获取扩展实现对象所需的依赖，然后完成依赖注入，该接口的uml关系如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/extension-factory.jpg" alt></p>
<p>由uml图可知，该接口有三个扩展实现类。AdaptiveExtensionFactory是它的自适应实现类，只是用来管理SpiExtensionFactory和SpringExtensionFactory，具体依赖的查找还是由这两个类完成，下面我们分别来分析。</p>
<h5 id="AdaptiveExtensionFactory-工厂"><a href="#AdaptiveExtensionFactory-工厂" class="headerlink" title="AdaptiveExtensionFactory 工厂"></a>AdaptiveExtensionFactory 工厂</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ExtensionFactory扩展实现对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AdaptiveExtensionFactory也是ExtensionFactory的扩展实现类，只是比较特殊，是自适应扩展类，不同于普通的扩展类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptiveExtensionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;ExtensionFactory&gt; list = <span class="keyword">new</span> ArrayList&lt;ExtensionFactory&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用ExtensionLoader 加载拓展点实现类，getSupportedExtensions() 返回的是ExtensionFactory扩展点实现类对应的扩展名集合</span></span><br><span class="line">        <span class="keyword">for</span> (String name : loader.getSupportedExtensions()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据扩展名获取 ExtensionFactory 的扩展实现对象 并加入缓存中</span></span><br><span class="line">            list.add(loader.getExtension(name));</span><br><span class="line">        &#125;</span><br><span class="line">        factories = Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取目标对象，主要用于 &#123;<span class="doctag">@link</span> ExtensionLoader#injectExtension(java.lang.Object)&#125; 方法中，用于获取扩展实现对象所需要的依赖属性值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type object type. 扩展接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name object name. 扩展名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历扩展工厂对象，获取指定的扩展对象或Spring中的Bean对象</span></span><br><span class="line">        <span class="keyword">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            T extension = factory.getExtension(type, name);</span><br><span class="line">            <span class="keyword">if</span> (extension != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AdaptiveExtensionFactory 自适应扩展工厂，内部维护了一个 ExtensionFactory 列表，用来管理其它的ExtensionFactory。在用户没有自定义ExtensionFactory的情况下，Dubbo目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建 <code>自适应的拓展</code>，后者从Spring容器中获取所需依赖。</p>
<h5 id="SpiExtensionFactory-工厂"><a href="#SpiExtensionFactory-工厂" class="headerlink" title="SpiExtensionFactory 工厂"></a>SpiExtensionFactory 工厂</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取自适应扩展对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type object type. 扩展接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name object name. 扩展名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 校验是接口类型并且有@SPI注解</span></span><br><span class="line">        <span class="keyword">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            <span class="comment">// 加载拓展接口对应的 ExtensionLoader</span></span><br><span class="line">            ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断当前扩展点是否有普通的扩展实现类，注意：当前扩展点存在普通的扩展实现类才会去获取对应的自适应扩展对象</span></span><br><span class="line">            <span class="keyword">if</span> (!loader.getSupportedExtensions().isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 获取自适应扩展对象</span></span><br><span class="line">                <span class="keyword">return</span> loader.getAdaptiveExtension();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpiExtensionFactory 是根据扩展接口获取相应的自适应扩展对象，也就是适配器，其中的属性名称没有用到。</p>
<h5 id="SpringExtensionFactory-工厂"><a href="#SpringExtensionFactory-工厂" class="headerlink" title="SpringExtensionFactory 工厂"></a>SpringExtensionFactory 工厂</h5><p>将属性名称作为 Spring Bean 的名称，从 Spring 容器中获取 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SpringExtensionFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashSet&lt;ApplicationContext&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存Spring上下文</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addApplicationContext</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        contexts.add(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeApplicationContext</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        contexts.remove(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// currently for test purpose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearContexts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        contexts.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历SpringContext上下集合</span></span><br><span class="line">        <span class="keyword">for</span> (ApplicationContext context : contexts) &#123;</span><br><span class="line">            <span class="comment">// 判断容器中是否包含名称为name的bean</span></span><br><span class="line">            <span class="keyword">if</span> (context.containsBean(name)) &#123;</span><br><span class="line">                <span class="comment">// 获得bean对象</span></span><br><span class="line">                Object bean = context.getBean(name);</span><br><span class="line">                <span class="comment">// 判断获得的bean类型是否是type类型</span></span><br><span class="line">                <span class="keyword">if</span> (type.isInstance(bean)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (T) bean;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.warn(<span class="string">"No spring extension (bean) named:"</span> + name + <span class="string">", try to find an extension (bean) of type "</span> + type.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span> </span>== type) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ApplicationContext context : contexts) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> context.getBean(type);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoUniqueBeanDefinitionException multiBeanExe) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Find more than 1 spring extensions (beans) of type "</span> + type.getName() + <span class="string">", will stop auto injection. Please make sure you have specified the concrete parameter type and there's only one extension of that type."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException noBeanExe) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Error when get spring extension(bean) for type:"</span> + type.getName(), noBeanExe);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.warn(<span class="string">"No spring extension (bean) named:"</span> + name + <span class="string">", type:"</span> + type.getName() + <span class="string">" found, stop get bean."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dubbo使用Spring容器管理的依赖为扩展对象注入依赖属性。Dubbo是如何与Spring容器打通的呢？有两处结合点，分别是服务暴露和服务引用的时候，利用ApplicationContextAware的回调方法设置spring上下文。</p>
<ul>
<li>服务暴露结合点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;<span class="comment">// 当前加载的上下文</span></span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="comment">// 为Spring拓展工厂注入上下文 , dubbo和Spring容器打通</span></span><br><span class="line">        SpringExtensionFactory.addApplicationContext(applicationContext);</span><br><span class="line">        <span class="keyword">if</span> (applicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SPRING_CONTEXT = applicationContext;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method method = applicationContext.getClass().getMethod(<span class="string">"addApplicationListener"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;ApplicationListener<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">// backward compatibility to spring 2.0.1</span></span><br><span class="line">                method.invoke(applicationContext, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">                supportedApplicationListener = <span class="keyword">true</span>; <span class="comment">// 当前Spring容器是否支持上下文监听</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (applicationContext <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Method method = AbstractApplicationContext.class.getDeclaredMethod("addListener", new Class&lt;?&gt;[]&#123;ApplicationListener.class&#125;); // backward compatibility to spring 2.0.1</span><br><span class="line">                        <span class="keyword">if</span> (!method.isAccessible()) &#123;</span><br><span class="line">                            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(applicationContext, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">                        supportedApplicationListener = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务引用结合点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="comment">// dubbo 和 spring容器打通</span></span><br><span class="line">        SpringExtensionFactory.addApplicationContext(applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Dubbo-AOP-实现"><a href="#Dubbo-AOP-实现" class="headerlink" title="Dubbo AOP 实现"></a>Dubbo AOP 实现</h4><p>Dubbo AOP 实现需要Wrapper类，关于Wrapper类前面已经介绍过了，这里不再说明。关于Dubbo AOP 的功能也在前面的流程中体现出来了，单独把Dubbo AOP 拿出来进行说明是考虑到前面的篇幅没有具体到Wrapper类，只是阐述了其功能和实现。实现一个Wrapper类的基本步骤如下：</p>
<ol>
<li>定义一个Wrapper类并实现扩展接口，然后编写AOP逻辑。</li>
<li>在配置文件配置自定义的Wrapper类</li>
</ol>
<h5 id="定义-Wrapper类"><a href="#定义-Wrapper类" class="headerlink" title="定义 Wrapper类"></a>定义 Wrapper类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandWrapper</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Command command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法的参数必须是扩展点类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommandWrapper</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"CommandWrapper is running ..."</span>);</span><br><span class="line">        <span class="comment">// 执行扩展实现对象，注意，如果不显示调用扩展实现，那么就达不到目标结果，只会执行这个并没有真正实现的Wrapper</span></span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义Wrapper类很简单，只要按照Wrapper类的要求进行实现即可。需要说明的是，我们所说的Wrapper类其实不强制类名以Wrapper结尾，只要符合Wrapper类的要求就是一个Wrapper类，并不是用名字进行区分是否Wrapper类，只是这样写是Dubbo的一种约定罢了。</p>
<h5 id="配置-Wrapper类"><a href="#配置-Wrapper类" class="headerlink" title="配置 Wrapper类"></a>配置 Wrapper类</h5><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/spi-wrapper.jpg" alt></p>
<h5 id="Dubbo-内置的Wrapper-举例"><a href="#Dubbo-内置的Wrapper-举例" class="headerlink" title="Dubbo 内置的Wrapper 举例"></a>Dubbo 内置的Wrapper 举例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Cluster接口，MockClusterWrapper实现类，注意它是个Wrapper类，对应的Cluster对象都会被它所包装。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockClusterWrapper</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真正的Cluster 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Cluster cluster;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockClusterWrapper</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cluster = cluster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建MockClusterInvoker对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory Directory 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MockClusterInvoker&lt;T&gt;(directory, <span class="keyword">this</span>.cluster.join(directory));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇文章简单介绍了Dubbo SPI 用法，并对 Dubbo SPI 的核心源码进行了分析，总体上不算复杂但很繁琐，细节点很多，比如，扩展名生成的规则，扩展类的种类区别，自动激活扩展生效条件。想要掌握整个流程需要耐心调试源码，笔者差点被spi及接下来要分析的Dubbo配置给劝退了。另外，由于Dubbo SPI自适应机制涉及到的代码量较多，逻辑比较复杂，我将会在下一篇文章中单独进行分析。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/5d81f464/" title="Dubbo源码分析 - Dubbo SPI" target="_blank" rel="external">https://gentryhuang.com/posts/5d81f464/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/3e0b5964/" title="Dubbo源码分析 - 自适应扩展"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/a9c33b8c/" title="Java SPI"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2021 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>