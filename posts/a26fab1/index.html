<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Redis原理 - 事务 | gentryhuang的博客</title>
  <meta name="description" content="概述Redis 通过 MULTI、EXEC、DISCARD 以及 WATCH 命令来实现事务功能。与我们所熟知的事务最大的不同是，Redis 实现的事务不支持回滚特性。此外，Redis 事务的 ACID 特性也并不完整，不同的情况下表现会有不同。Redis 事务也被称为 半事务，它是简单地使用队列存放一组 Redis 命令。 事务的实现Redis 事务的执行过程包含三个阶段，如下：   开启事务">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis原理 - 事务">
<meta property="og:url" content="https://gentryhuang.com/posts/a26fab1/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="概述Redis 通过 MULTI、EXEC、DISCARD 以及 WATCH 命令来实现事务功能。与我们所熟知的事务最大的不同是，Redis 实现的事务不支持回滚特性。此外，Redis 事务的 ACID 特性也并不完整，不同的情况下表现会有不同。Redis 事务也被称为 半事务，它是简单地使用队列存放一组 Redis 命令。 事务的实现Redis 事务的执行过程包含三个阶段，如下：   开启事务">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gentryhuang.com/posts/a26fab1/redis-tx-multistate.jpg">
<meta property="article:published_time" content="2021-05-27T12:08:59.000Z">
<meta property="article:modified_time" content="2021-06-28T05:15:46.092Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="求职">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="生活">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gentryhuang.com/posts/a26fab1/redis-tx-multistate.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/a26fab1/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.14px;">AQS</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.71px;">Filter</a> <a href="/tags/JUC/" style="font-size: 13.43px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.29px;">Javassist</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.29px;">Protocol</a> <a href="/tags/RPC/" style="font-size: 13.57px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.14px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.29px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.29px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.86px;">设计模式</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/a26fab1/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/a26fab1/" class="title">Redis原理 - 事务</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-27T12:08:59.000Z" itemprop="datePublished">2021-05-27</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/d80e61c2/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/posts/d80e61c2/" class="title">MySQL - 事务与隔离级别</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-21T10:49:59.000Z" itemprop="datePublished">2021-05-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/4132ef9f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/posts/4132ef9f/" class="title">MySQL - 慢查询日志</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-14T11:17:14.000Z" itemprop="datePublished">2021-05-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/fa9a5340/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
              </p>
              <p class="item-title">
                <a href="/posts/fa9a5340/" class="title">缓存一致性问题</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-04T04:44:15.000Z" itemprop="datePublished">2021-05-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/4760cec/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/RPC/">RPC</a>
              </p>
              <p class="item-title">
                <a href="/posts/4760cec/" class="title">Dubbo源码分析 - 健康检测</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-01T10:56:21.000Z" itemprop="datePublished">2021-05-01</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事务的实现"><span class="toc-number">2.</span> <span class="toc-text">事务的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#开启事务"><span class="toc-number">2.1.</span> <span class="toc-text">开启事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命令入队"><span class="toc-number">2.2.</span> <span class="toc-text">命令入队</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务队列"><span class="toc-number">2.3.</span> <span class="toc-text">事务队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行事务"><span class="toc-number">2.4.</span> <span class="toc-text">执行事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#取消事务"><span class="toc-number">2.5.</span> <span class="toc-text">取消事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WATCH-机制"><span class="toc-number">2.6.</span> <span class="toc-text">WATCH 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#监视键信息"><span class="toc-number">2.6.1.</span> <span class="toc-text">监视键信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监视键"><span class="toc-number">2.6.2.</span> <span class="toc-text">监视键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监视机制的触发"><span class="toc-number">2.6.3.</span> <span class="toc-text">监视机制的触发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事务的-ACID-性质"><span class="toc-number">3.</span> <span class="toc-text">事务的 ACID 性质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原子性"><span class="toc-number">3.1.</span> <span class="toc-text">原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#命令入队时出错"><span class="toc-number">3.1.1.</span> <span class="toc-text">命令入队时出错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令执行时出错"><span class="toc-number">3.1.2.</span> <span class="toc-text">命令执行时出错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例故障"><span class="toc-number">3.1.3.</span> <span class="toc-text">实例故障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一致性"><span class="toc-number">3.2.</span> <span class="toc-text">一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#命令入队时出错-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">命令入队时出错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令执行时出错-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">命令执行时出错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例故障-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">实例故障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#隔离性"><span class="toc-number">3.3.</span> <span class="toc-text">隔离性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久性"><span class="toc-number">3.4.</span> <span class="toc-text">持久性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回滚实现"><span class="toc-number">3.5.</span> <span class="toc-text">回滚实现</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-redis_theory/themory/事务" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Redis原理 - 事务
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/a26fab1/" class="article-date">
	  <time datetime="2021-05-27T12:08:59.000Z" itemprop="datePublished">2021-05-27</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </span>

        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/a26fab1/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 6.5k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 25(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Redis 通过 <strong>MULTI</strong>、<strong>EXEC</strong>、<strong>DISCARD</strong> 以及 <strong>WATCH</strong> 命令来实现事务功能。与我们所熟知的事务最大的不同是，Redis 实现的事务不支持回滚特性。此外，Redis 事务的 ACID 特性也并不完整，不同的情况下表现会有不同。Redis 事务也被称为 <strong>半事务</strong>，它是简单地使用队列存放一组 Redis 命令。</p>
<h1 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h1><p>Redis 事务的执行过程包含三个阶段，如下：</p>
<blockquote>
<ol>
<li>开启事务</li>
<li>命令入队</li>
<li>事务执行/取消</li>
</ol>
</blockquote>
<p>下面我们分别对以上三个阶段进行说明，并介绍核心的实现逻辑。</p>
<h2 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h2><p>Redis 客户端执行 <strong>MULTI</strong> 命令标志着事务的开启:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt;</span><br></pre></td></tr></table></figure>

<p><strong>MULTI</strong> 命令可以将执行该命令的客户端从<strong>非事务状态</strong>切换到<strong>事务状态</strong>，这一切换是将客户端的 <code>flags</code> 属性设置为 <code>CLIENT_MULTI</code> 标识来完成的。</p>
<p><strong>MULTI 命令的实现逻辑如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * multi 命令对应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 检测客户端状态，不支持在事务中嵌套事务</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"MULTI calls can not be nested"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 开启事务，即设置客户端的状态标志为 CLIENT_MULTI</span></span><br><span class="line">    c-&gt;flags |= CLIENT_MULTI;</span><br><span class="line"></span><br><span class="line">    addReply(c, shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，Redis 开启事务主要是将当前客户端的状态标志属性 <code>flags</code> 设置为 <code>CLIENT_MULTI</code>。Redis 事务的生命周期是和该状态标志紧密相关的，除此状态外，命令入队出错需要将客户端的状态设置为 <code>REDIS_DIRTY_EXEC</code>，客户端监视的键被改动需要将客户端的状态设置为 <code>REDIS_DIRTY_CAS</code>，这两种情况将在下文进行介绍。</p>
<h2 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h2><p>Redis 在没有开启事务时，即一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行，这个也是我们日常多使用的方式。与此不同的是，当一个客户端开启事务，即一个客户端处于事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：</p>
<ul>
<li>如果客户端发送的命令为 <code>EXEC</code> 或 <code>DISCARD</code> ，那么服务端会立即执行这个命令，进行事务的提交或取消。</li>
<li>如果客户端发送的命令是操作数据命令，那么服务端并不会立即执行这个命令，而是将这个命令加入到<strong>事务队列</strong>中，然后向客户端返回 <code>QUEUED</code> 回复，标识加入事务队列完成。</li>
</ul>
<p><strong>将命令入队的实现逻辑如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a new command into the MULTI commands queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将一个新命令添加到事务队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    multiCmd *mc;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 检测客户端状态，如果要入队的命令出现类似语法错误，则不允许入队</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_DIRTY_EXEC)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 为命令分配对应的空间，如存储命令结构的队列、封装命令的命令结构 multiCmd</span></span><br><span class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(multiCmd) * (c-&gt;mstate.count + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 指向新元素</span></span><br><span class="line">    mc = c-&gt;mstate.commands + c-&gt;mstate.count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 设置命令、命令参数数量、以及命令的参数</span></span><br><span class="line">    mc-&gt;cmd = c-&gt;cmd;</span><br><span class="line">    mc-&gt;argc = c-&gt;argc;</span><br><span class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj *) * c-&gt;argc);</span><br><span class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv, c-&gt;argv, <span class="keyword">sizeof</span>(robj *) * c-&gt;argc);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        incrRefCount(mc-&gt;argv[j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 事务队列长度增一</span></span><br><span class="line">    c-&gt;mstate.count++;</span><br><span class="line"></span><br><span class="line">    c-&gt;mstate.cmd_flags |= c-&gt;cmd-&gt;flags;</span><br><span class="line">    c-&gt;mstate.cmd_inv_flags |= ~c-&gt;cmd-&gt;flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 每次在入队的命令出现类似语法错误时调用，将客户端的状态设置为 DIRTY_EXEC，让之后的 EXEC 命令失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flagTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前客户端的状态处于事务状态</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI)</span><br><span class="line">        <span class="comment">// 将客户端的状态设置为 CLIENT_DIRTY_EXEC，表示该客户端的事务安全性已经被破坏</span></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_EXEC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，以上函数只是命令入队逻辑，在该方法上层会对当前客户端的状态标志进行判断，并结合当前命令选择对应处理方式，因为涉及的内容相对较多且不是本文的重点，暂不展开说明。</p>
<h2 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h2><p>前文介绍了 Redis 事务中的命令入队逻辑，但是并没有详细说明事务队列的结构以及命令封装结构，本小节就来对 Redis 事务中涉及的相关数据结构进行介绍。</p>
<p>每个 Redis 客户端都有自己的状态，其它状态我们暂不介绍，这里我们围绕着事务相关状态进行说明。下面只列举客户端结构体中涉及事务相关的属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前正在使用的数据库</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数对象数组</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录被客户端执行的命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端的状态标志</span></span><br><span class="line">    <span class="keyword">uint64_t</span> flags;         <span class="comment">/* Client flags: CLIENT_* macros. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务状态（本质上是事务队列的封装）</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被监视的键，用于存放当前客户端使用 WATCH 命令监视键的链表</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure>

<p>客户端的状态标志是通过 <code>flags</code> 属性记录的。如果客户端开启事务，那么客户端的 <code>mastate</code> 属性封装了事务队列信息，用来管理事务中的命令；客户端的 <code>watched_keys</code> 链表结构用来管理客户端使用 <strong>WATCH</strong> 命令监视的键信息。下文我们会分别详细介绍这些关键属性。</p>
<p>客户端的 <code>mstate</code> 属性主要包含一个<strong>事务队列</strong>和一个<strong>记录事务队列长度的属性</strong>，具体结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 主要包含一个事务队列，以及一个已入队命令的计数器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 事务队列，是一个 multiCmd 类型的数组</span></span><br><span class="line">    multiCmd *commands;     <span class="comment">/* Array of MULTI commands */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已入队命令计数（事务队列的长度）</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">/* Total number of MULTI commands */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cmd_flags;          <span class="comment">/* The accumulated command flags OR-ed together.</span></span><br><span class="line"><span class="comment">                               So if at least a command has a given flag, it</span></span><br><span class="line"><span class="comment">                               will be set in this field. */</span></span><br><span class="line">    <span class="keyword">int</span> cmd_inv_flags;      <span class="comment">/* Same as cmd_flags, OR-ing the ~flags. so that it</span></span><br><span class="line"><span class="comment">                               is possible to know if all the commands have a</span></span><br><span class="line"><span class="comment">                               certain flag. */</span></span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure>

<p>从 <strong>multiState</strong> 结构中可以看出，事务队列本质上是一个 <strong>multiCmd</strong> 类型的数组。<strong>multiCmd</strong> 结构用于封装了一个已入队命令的信息，具体结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存了一个已入队命令的相关信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    <span class="comment">// 参数数组</span></span><br><span class="line">    robj **argv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令指针，指向具体的命令（命令结构中封装了对应的命令函数）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure>

<p>事务队列以先进先出（FIFO）的方式保存入队的命令信息，较先入队的命令会被放到数组的前面，而较后入队的命令则会放到数组的后面。下面结合示例，对事务队列结构进行说明：</p>
<p><strong>事务中的命令入队过程：</strong></p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; SET name "Practical Common Lisp"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; GET "name"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; SET author "Peter Seibel"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; GET author</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt;</span><br></pre></td></tr></table></figure>

<p><strong>事务队列结构如下图所示：</strong><br><img src="/posts/a26fab1/redis-tx-multistate.jpg" alt></p>
<p>上图很直观地展示了客户端中的 <code>multiState</code> 属性的平铺结构。</p>
<p>了解了 Redis 事务的开启以及事务相关的数据结构后，下面我们看看 Redis 提交事务的逻辑。</p>
<h2 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h2><p>当一个处于事务状态的客户端向服务端发送 <code>EXEC</code> 命令时，该命令将立即被服务端执行。服务端会遍历这个客户端的事务队列，依次执行队列中保存的命令，最后将执行命令得到的结果全部返回给客户端。</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) "Practical Common Lisp"</span><br><span class="line">3) OK</span><br><span class="line">4) "Peter Seibel"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p><strong>执行事务逻辑如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * exec 命令对应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj **orig_argv;</span><br><span class="line">    <span class="keyword">int</span> orig_argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">orig_cmd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> was_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 检测当前客户端状态，非事务状态直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"EXEC without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 2 检查是否需要阻止事务执行，因为：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) Some WATCHed key was touched.</span></span><br><span class="line"><span class="comment">     *    存在被客户端监视的键被修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2) There was a previous error while queueing commands.</span></span><br><span class="line"><span class="comment">     *    命令在入队时发生错误</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A failed EXEC in the first case returns a multi bulk nil object</span></span><br><span class="line"><span class="comment">     * (technically it is not an error but a special behavior), while</span></span><br><span class="line"><span class="comment">     * in the second an EXECABORT error is returned. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_DIRTY_CAS | CLIENT_DIRTY_EXEC)) &#123;</span><br><span class="line">        addReply(c, c-&gt;flags &amp; CLIENT_DIRTY_EXEC ? shared.execaborterr :</span><br><span class="line">                    shared.nullarray[c-&gt;resp]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 discard 逻辑，即取消事务</span></span><br><span class="line">        discardTransaction(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前客户端的状态标记</span></span><br><span class="line">    <span class="keyword">uint64_t</span> old_flags = c-&gt;flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we do not want to allow blocking commands inside multi */</span></span><br><span class="line">    <span class="comment">// 我们不希望在multi中允许阻塞命令</span></span><br><span class="line">    c-&gt;flags |= CLIENT_DENY_BLOCKING;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 已经可以保证安全性了，取消客户端对所有键的监视</span></span><br><span class="line">    <span class="comment">// 将当前客户端的 watched_keys 链表回收</span></span><br><span class="line">    <span class="comment">// 从当前客户端操作的数据库的 watched_keys 字典中移除当前客户端</span></span><br><span class="line">    unwatchAllKeys(c); <span class="comment">/* Unwatch ASAP otherwise we'll waste CPU cycles */</span></span><br><span class="line"></span><br><span class="line">    server.in_exec = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 因为事务中的命令在执行时可能会修改命令和命令的参数，所以为了正确地传播命令，需要现备份这些命令和参数</span></span><br><span class="line">    orig_argv = c-&gt;argv;</span><br><span class="line">    orig_argc = c-&gt;argc;</span><br><span class="line">    orig_cmd = c-&gt;cmd;</span><br><span class="line"></span><br><span class="line">    addReplyArrayLen(c, c-&gt;mstate.count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 执行事务队列中的命令</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 因为 Redis 的命令必须在客户端的上下文中执行，所以需要将事务队列中的命令、命令参数等设置到客户端</span></span><br><span class="line">        c-&gt;argc = c-&gt;mstate.commands[j].argc;</span><br><span class="line">        c-&gt;argv = c-&gt;mstate.commands[j].argv;</span><br><span class="line">        c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/* 省略 ACL权限检查逻辑 */</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 5.2 执行命令</span></span><br><span class="line">        call(c, server.loading ? CMD_CALL_NONE : CMD_CALL_FULL);</span><br><span class="line">        serverAssert((c-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Commands may alter argc/argv, restore mstate. */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 因为命令执行后命令、命令参数可能会被改变，比如 SPOP 会被改写为 SREM</span></span><br><span class="line"><span class="comment">         * 所以这里需要更新事务队列中的命令和参数，确保附属节点和 AOF 的数据一致性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c-&gt;mstate.commands[j].argc = c-&gt;argc;</span><br><span class="line">        c-&gt;mstate.commands[j].argv = c-&gt;argv;</span><br><span class="line">        c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore old DENY_BLOCKING value</span></span><br><span class="line">    <span class="keyword">if</span> (!(old_flags &amp; CLIENT_DENY_BLOCKING))</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_DENY_BLOCKING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原命令</span></span><br><span class="line">    c-&gt;argv = orig_argv;</span><br><span class="line">    c-&gt;argc = orig_argc;</span><br><span class="line">    c-&gt;cmd = orig_cmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 清理事务状态</span></span><br><span class="line">    <span class="comment">// 释放事务队列相关的资源 &amp; 重置客户端的状态</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure the EXEC command will be propagated as well if MULTI</span></span><br><span class="line"><span class="comment">     * was already propagated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果已经传播了 MULTI，也要确保传播 EXEC 命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (server.propagate_in_transaction) &#123;</span><br><span class="line">        <span class="keyword">int</span> is_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="comment">/* If inside the MULTI/EXEC block this instance was suddenly</span></span><br><span class="line"><span class="comment">         * switched from master to slave (using the SLAVEOF command), the</span></span><br><span class="line"><span class="comment">         * initial MULTI was propagated into the replication backlog, but the</span></span><br><span class="line"><span class="comment">         * rest was not. We need to make sure to at least terminate the</span></span><br><span class="line"><span class="comment">         * backlog with the final EXEC. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog &amp;&amp; was_master &amp;&amp; !is_master) &#123;</span><br><span class="line">            <span class="keyword">char</span> *execcmd = <span class="string">"*1\r\n$4\r\nEXEC\r\n"</span>;</span><br><span class="line">            feedReplicationBacklog(execcmd, <span class="built_in">strlen</span>(execcmd));</span><br><span class="line">        &#125;</span><br><span class="line">        afterPropagateExec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.in_exec = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事务执行逻辑比较复杂，下面进行概要总结：</strong></p>
<ol>
<li>在事务执行时会判断客户端的状态，如果没有开启事务直接返回。</li>
<li>对阻止事务执行的情况进行检查，检测到任何一种非法的情况，需要取消事务。</li>
<li>取消客户端对所有键的监视</li>
<li>依次执行事务队列中的任务</li>
<li>清理事务列表并重置客户端状态</li>
<li>传播 EXEC 命令</li>
</ol>
<p>事务执行时涉及的监视机制会在下文进行介绍，这里暂不展开。</p>
<h2 id="取消事务"><a href="#取消事务" class="headerlink" title="取消事务"></a>取消事务</h2><p>当一个处于事务状态的客户端向服务端发送 <code>DISCARD</code> 命令时，该命令将立即被服务端执行。服务端会释放事务状态资源并重置客户端的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * discard 命令对应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测当前客户端状态，非事务状态直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"DISCARD without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// discard 逻辑</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line"></span><br><span class="line">    addReply(c, shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * discard 操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重置事务状态</span></span><br><span class="line">    <span class="comment">// 释放所有事务状态相关的资源</span></span><br><span class="line">    freeClientMultiState(c);</span><br><span class="line">    <span class="comment">// 初始化客户端的事务状态</span></span><br><span class="line">    initClientMultiState(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置客户端状态标志</span></span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_MULTI | CLIENT_DIRTY_CAS | CLIENT_DIRTY_EXEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消对所有键的监视</span></span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="WATCH-机制"><a href="#WATCH-机制" class="headerlink" title="WATCH 机制"></a>WATCH 机制</h2><p><strong>WATCH</strong> 命令可以在 <strong>EXEC</strong> 命令执行之前，监视任意数量的数据库键，并在 <strong>EXEC</strong> 命令执行时检查是否存在被监视的键被修改的情况，如果存在服务端会拒绝执行事务。前文介绍事务执行和取消时，都有 <strong>WATCH</strong> 机制逻辑，它是 Redis 事务实现的一部分，本小节我们就来详细说明该机制。</p>
<h3 id="监视键信息"><a href="#监视键信息" class="headerlink" title="监视键信息"></a>监视键信息</h3><p>客户端监视键的时候，被监视的键信息会分别保存在客户端的监视键链表中和当前数据库的监视键字典中，下面我们分别介绍。</p>
<p><strong>客户端的监视键链表</strong></p>
<p>每个客户端创建的时候都会初始化一个用于存放监视键的链表。前文在介绍客户端的结构有列举对应的属性，这里直接拿过来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存放被监视的键的链表</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure>

<p>客户端结构中的这个链表的节点的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 在监视一个键时：</span></span><br><span class="line"><span class="comment"> * 我们既需要保存被监视的键，还需要保存该键所在的数据库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchedKey</span> &#123;</span></span><br><span class="line">    <span class="comment">// 被监视的键对象</span></span><br><span class="line">    robj *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键所在的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125; watchedKey;</span><br></pre></td></tr></table></figure>

<p>watched_keys 链表数据举例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># before:</span><br><span class="line"> [</span><br><span class="line">  &#123;</span><br><span class="line">    'key': 'key1',  # 被监视的键</span><br><span class="line">    'db': 0  # 客户端操作的数据库</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br><span class="line">#  after client watch key-2 in db 0:</span><br><span class="line"> [</span><br><span class="line">  &#123;</span><br><span class="line">   'key': 'key1',</span><br><span class="line">   'db': 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   'key': 'key2',</span><br><span class="line">   'db': 0</span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>


<p><strong>数据库的监视键字典</strong></p>
<p>每个 Redis 数据库都有一个 <code>watched_keys</code> 字典，这个字典的键就是被 <code>WATCH</code> 命令监视的键，而字典的值则是一个链表，该链表中记录了监视当前键的客户端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>watched_keys 字典数据举例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> # before :</span><br><span class="line"> &#123;</span><br><span class="line">   'key1' : [c1, c2]</span><br><span class="line"> &#125;</span><br><span class="line"> # after c3 WATCH key1 and key2:</span><br><span class="line">&#123;</span><br><span class="line">   'key1' : [c1, c2, c3],</span><br><span class="line">   'key2' : [c3]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="监视键"><a href="#监视键" class="headerlink" title="监视键"></a>监视键</h3><p><strong>监视键命令操作如下：</strong></p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; WATCH name</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p><strong>客户端监视给定键的逻辑如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Watch for the specified key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 客户端监视给定的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchForKey</span><span class="params">(client *c, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    watchedKey *wk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key */</span></span><br><span class="line">    <span class="comment">// 1 检查 key 是否已经保存在 watched_keys 链表中，如果已经存在，则直接返回</span></span><br><span class="line">    listRewind(c-&gt;watched_keys, &amp;li);</span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        wk = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">if</span> (wk-&gt;db == c-&gt;db &amp;&amp; equalStringObjects(key, wk-&gt;key))</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* Key already watched */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This key is not already watched in this DB. Let's add it */</span></span><br><span class="line">    <span class="comment">// 2 检查 key 是否存在于数据库的 watched_keys 字典中</span></span><br><span class="line">    clients = dictFetchValue(c-&gt;db-&gt;watched_keys, key);</span><br><span class="line">    <span class="comment">// 2.1 如果不存在则，添加它</span></span><br><span class="line">    <span class="keyword">if</span> (!clients) &#123;</span><br><span class="line">        <span class="comment">// 值是一个链表</span></span><br><span class="line">        clients = listCreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联键值对到字典</span></span><br><span class="line">        dictAdd(c-&gt;db-&gt;watched_keys, key, clients);</span><br><span class="line">        incrRefCount(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将客户端添加到链表的末尾</span></span><br><span class="line">    listAddNodeTail(clients, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the new key to the list of keys watched by this client */</span></span><br><span class="line">    <span class="comment">// 3 构建 watchedKey 结构并添加到客户端的 watched_key 链表的末尾</span></span><br><span class="line">    wk = zmalloc(<span class="keyword">sizeof</span>(*wk));</span><br><span class="line">    wk-&gt;key = key;</span><br><span class="line">    wk-&gt;db = c-&gt;db;</span><br><span class="line">    incrRefCount(key);</span><br><span class="line">    listAddNodeTail(c-&gt;watched_keys, wk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上方法是监视给定的键，本质上就是将指定的键关联上当前客户端，然后分别添加到客户端的监视键链表中和数据库监视字典中。关于取消监视的键逻辑就不再介绍。</p>
<h3 id="监视机制的触发"><a href="#监视机制的触发" class="headerlink" title="监视机制的触发"></a>监视机制的触发</h3><p>所有对数据库进行写操作的命令，在执行后都会尝试触发监视机制，试图将正在监视当前键的客户端的状态设置为 <code>CLIENT_DIRTY_CAS</code>，表示该客户端的事务安全性已经被破坏了。监视机制的触发逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "Touch" a key, so that if this key is being WATCHed by some client the</span></span><br><span class="line"><span class="comment"> * next EXEC will fail.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * "触碰" key，如果该 key 正在被某个/某些客户端监视着，那么这个/这些客户端在执行 EXEC 时，事件将失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touchWatchedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 当前数据库的 watched_leys 字典为空，没有任何键被监视</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 从监视键字典中获取所有监视这个键的客户端</span></span><br><span class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark all the clients watching this key as CLIENT_DIRTY_CAS */</span></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3 遍历所有客户端，打开它们的 CLIENT_DIRTY_CAS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    listRewind(clients, &amp;li);</span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将客户端的状态设置为 CLIENT_DIRTY_CAS，表示该客户端的事务安全性已经被破坏</span></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_CAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当服务器执行客户端的 <strong>EXEC</strong> 命令时，服务器会校验客户端的状态来决定是否执行事务。如果客户端的状态是 <code>CLIENT_DIRTY_EXEC</code> 或者 <code>CLIENT_DIRTY_CAS</code> 时，服务器会拒绝执行客户端提交的事务。</p>
<p>至此，Redis 的事务原理已经全部介绍完毕了。下面我们从事务的 ACID 特性角度对 Redis 的事务进行说明。</p>
<h1 id="事务的-ACID-性质"><a href="#事务的-ACID-性质" class="headerlink" title="事务的 ACID 性质"></a>事务的 ACID 性质</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>对于 Redis 的事务功能来说，事务队列中的命令要么全部执行，要么一个都不执行。Redis 事务的原子性需要分以下三种情况来考虑。</p>
<h3 id="命令入队时出错"><a href="#命令入队时出错" class="headerlink" title="命令入队时出错"></a>命令入队时出错</h3><p>在执行 EXEC 命令前，客户端发送的操作命令本身就有错误，比如语法错误或者使用了不存的命令，在命令入队时就被 Redis 实例检测出来了，进而导致事务失败。例子如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行一个 Redis 不支持的命令，返回报错信息</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SETT num 1</span><br><span class="line">(error) ERR unknown command `SETT`, with args beginning with: `num`, `1`, </span><br><span class="line">(51.33s)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 继续执行命令</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SET num 1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交事务，但由于存在命令入队失败的情况，因此 Redis 拒绝执行事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure>

<p>对于这种情况，Redis 实例检测出错误后会记录错误信息并调用 <strong>flagTransaction</strong> 方法将客户端的状态设置为 <code>CLIENT_DIRTY_EXEC</code>,然后执行入队逻辑时，命令入队就会失败。此时，虽然还能继续提交命令操作，但是等到执行 EXEC 命令时，Redis 服务端就会拒绝执行提交的事务，返回事务失败的结果，因为此时客户端的状态为 <code>CLIENT_DIRTY_EXEC</code>。关于命令入队和事务执行逻辑，上文已经详细说明。</p>
<p><strong>结论：</strong>命令入队时出现错误，会放弃事务的执行，能够保证原子性。</p>
<h3 id="命令执行时出错"><a href="#命令执行时出错" class="headerlink" title="命令执行时出错"></a>命令执行时出错</h3><p>客户端发送的操作命令和操作的数据类型不匹配，在命令入队时 Redis 实例无法检测出错误。但是在执行 <code>EXEC</code> 命令时，当 Redis 从事务队列中取出异常操作命令并执行时就会报错。需要注意的是，虽然 Redis 会对异常操作命令报错，但还是会继续将事务队列中的命令执行完。在这种情况下，事务的原子性就无法得到保证了，根本原因在于 Redis 并没有提供回滚机制。</p>
<p>例子如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开始事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行 SADD 命令</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SADD st gentryhuang</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行 GET 命令，GET 命令操作的数据类型不匹配，此时不会影响入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; GET st</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交事务，事务中的第二个命令会报错</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong>命令入队时没有出错，实际执行时报错，不能保证原子性。</p>
<h3 id="实例故障"><a href="#实例故障" class="headerlink" title="实例故障"></a>实例故障</h3><p>在执行 <code>EXEC</code> 命令时，Redis 实例发生了故障，导致事务执行失败。由于 Redis 的持久化机制，实例重启后会加载 AOF 日志文件或 RDB 快照，如果只有部分的事务操作被记录，那么就无法保证原子性。但是事实是，RDB 快照不会在事务执行时执行，所以事务命令操作的结果不会被保存到 RDB 快照中。即使开启了 AOF 日志，我们可以使用 <strong>redis-check-aof</strong> 工具检查 AOF 日志文件，这个工具可以把未完成的事务操作从 AOF 文件中去除。这样一来，不管 AOF 日志文件中是否保存完整的事务操作，还是根本就没有保存事务操作，AOF 文件不再是导致原子性问题的因素。</p>
<p><strong>结论：</strong><code>EXEC</code> 命令执行时实例故障，可以保证原子性。</p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>事务的一致性指的是数据符合数据库本身的定义和要求，事务执行过程不会产生非法或者无效的错误数据。Redis 通过语法错误检查机制和简单的设计来保证事务的一致性。Redis 事务的一致性依然需要分以下三种情况来考虑。</p>
<h3 id="命令入队时出错-1"><a href="#命令入队时出错-1" class="headerlink" title="命令入队时出错"></a>命令入队时出错</h3><p>命令入队时出错，事务本身就会被放弃，所以可以保证事务的一致性。</p>
<h3 id="命令执行时出错-1"><a href="#命令执行时出错-1" class="headerlink" title="命令执行时出错"></a>命令执行时出错</h3><p>在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，这些出错的命令不会对数据库做任何改动。也就不会对事务的一致性产生任何影响。如果硬从无效的错误数据角度来看，这种情况是破坏了事务的一致性，毕竟出错的命令虽然没有执行，但没有达到预期的目的。</p>
<h3 id="实例故障-1"><a href="#实例故障-1" class="headerlink" title="实例故障"></a>实例故障</h3><p>在执行 <code>EXEC</code> 命令时，Redis 实例发生了故障，无论 Redis 使用哪种持久化模式，都不会影响数据库的一致性。这种情况和前文介绍的实例故障是否影响原子性的因素是一致的。</p>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。</p>
<p>由于 Redis 使用单线程的方式来执行事务，并且在执行事务期间不会对事务进行中断，也就是说 Redis 的事务总是以串行的方式运行的，事务具有隔离性。</p>
<p>需要特别说明的是，一个客户端在开启事务之前可以利用 <code>WATCH</code> 机制来监视要操作的键，通过这种方式可以自定义隔离规则，规定如果在事务执行时发现要操作的键发生了改变，那么就认为破坏了事务的隔离性，就需要放弃事务的执行。</p>
<h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>事务的持久性指的是，当一个事务执行完毕时，执行这个事务的结果会永久性存储起来，即使服务器在事务执行完毕后宕机了，执行事务所得到的结果也不会丢失。</p>
<p>Redis 并没有为事务提供任何额外的持久化功能，Redis 事务的持久性由 Redis 的持久化配置模式决定。由事务的持久性特点不难看出，Redis 要实现事务的持久性必须使用 AOF 模式，并且刷盘机制 <strong>appendfsync</strong> 必须设置为 <strong>always</strong>，这样数据才能尽量不丢失。此时，还是不能保证事务数据不丢，因为 Redis 为了提高性能尽可能不阻塞主线程，允许设置配置项控制在执行快照或重写 AOF 日志文件时停止对 AOF 文件进行刷盘。如果打开 <strong>no-appendfsync-on-rewrite</strong> 配置项（默认是关闭的），那么即使 Redis 实例运行在 <strong>always</strong> 模式的 AOF 持久化之下，事务也不具有持久性。</p>
<p>Redis 本身是内存数据库，持久性并不是一个必须的属性，具体可以根据使用场景进行取舍。</p>
<h2 id="回滚实现"><a href="#回滚实现" class="headerlink" title="回滚实现"></a>回滚实现</h2><p>Redis 的事务和传统的关系型数据库事务最大的区别在于，Redis 不支持事务回滚机制，即使事务队列中的某个命令在执行时出错，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。需要说明的是 Redis 提供的 <code>DISCARD</code> 命令，并没有回滚事务的能力，它只是用来放弃事务，把事务队列清空并重置客户端的事务状态。只要开启一个事务，就能通过 <code>DISCARD</code> 命令放弃事务。<code>DISCARD</code> 命令具体使用如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; SADD num </span><br><span class="line">(error) ERR wrong number of arguments for 'sadd' command</span><br><span class="line">(5.99s)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 放弃事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; discard</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>


<p>Redis 不支持事务回滚的原因有两点：其一，较为复杂的事务回滚功能和 Redis 追求简单高效的设计主旨不相符；其二，Redis 事务执行时的错误通常都是编程错误产生的，需要使用方去避免。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/a26fab1/" title="Redis原理 - 事务" target="_blank" rel="external">https://gentryhuang.com/posts/a26fab1/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    
    <li class="next">
      <a href="/posts/d80e61c2/" title="MySQL - 事务与隔离级别"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2021 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>