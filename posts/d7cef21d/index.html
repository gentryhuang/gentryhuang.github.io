<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>并发 - 线程池 | gentryhuang的博客</title>
  <meta name="description" content="前言最初的时候并没有线程池的概念，而是先有线程。每个任务都需要对应一个线程，任务少的情况没有太大问题，任务过多就出现了各种性能和资源开销问题，更重要的是可创建线程的数量是有上限的，不可能无限的创建。在并发环境下，系统不能够确定在某一时刻有多少任务需要执行，有多少资源需要投入。 针对上述问题，于是诞生了线程池，用来平衡线程与系统资源之间的关系。线程池解决问题思路如下：  对于反复创建线程开销问题，线">
<meta property="og:type" content="article">
<meta property="og:title" content="并发 - 线程池">
<meta property="og:url" content="https://gentryhuang.com/posts/d7cef21d/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="前言最初的时候并没有线程池的概念，而是先有线程。每个任务都需要对应一个线程，任务少的情况没有太大问题，任务过多就出现了各种性能和资源开销问题，更重要的是可创建线程的数量是有上限的，不可能无限的创建。在并发环境下，系统不能够确定在某一时刻有多少任务需要执行，有多少资源需要投入。 针对上述问题，于是诞生了线程池，用来平衡线程与系统资源之间的关系。线程池解决问题思路如下：  对于反复创建线程开销问题，线">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-threadpoolexecutor-base-uml.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-executor.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-executorservice-method.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-future-hierarchy.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-abstract-method.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-principle.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-threadpoolexecutor-ctl.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-status.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-process.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-syncronousqueue.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-gettask-process.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-rejectedexecutionhandler.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-process-simple.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-addworker-process.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-runworker-process.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-exit.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-process.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-monitor-method.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-dynamic-method.jpg">
<meta property="article:published_time" content="2020-12-02T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T06:10:39.314Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-threadpoolexecutor-base-uml.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/d7cef21d/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.14px;">AQS</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.71px;">Filter</a> <a href="/tags/JUC/" style="font-size: 13.43px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.29px;">Javassist</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.29px;">Protocol</a> <a href="/tags/RPC/" style="font-size: 13.57px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.14px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.29px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.29px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.86px;">设计模式</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/4132ef9f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/posts/4132ef9f/" class="title">MySQL - 慢查询日志</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-14T11:17:14.000Z" itemprop="datePublished">2021-05-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/fa9a5340/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
              </p>
              <p class="item-title">
                <a href="/posts/fa9a5340/" class="title">缓存一致性问题</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-04T04:44:15.000Z" itemprop="datePublished">2021-05-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/4760cec/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/RPC/">RPC</a>
              </p>
              <p class="item-title">
                <a href="/posts/4760cec/" class="title">Dubbo源码分析 - 健康检测</a>
              </p>
              <p class="item-date">
                <time datetime="2021-05-01T10:56:21.000Z" itemprop="datePublished">2021-05-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/48468614/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
              </p>
              <p class="item-title">
                <a href="/posts/48468614/" class="title">Raft 共识算法</a>
              </p>
              <p class="item-date">
                <time datetime="2021-04-23T11:28:56.000Z" itemprop="datePublished">2021-04-23</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/2362a8ea/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/2362a8ea/" class="title">Redis原理 - 链表</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-16T11:33:59.000Z" itemprop="datePublished">2021-03-16</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总体设计"><span class="toc-number">3.</span> <span class="toc-text">总体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#任务执行"><span class="toc-number">3.1.</span> <span class="toc-text">任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程级别调用"><span class="toc-number">3.1.1.</span> <span class="toc-text">线程级别调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法级别调用"><span class="toc-number">3.1.2.</span> <span class="toc-text">方法级别调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Executor-框架"><span class="toc-number">3.2.</span> <span class="toc-text">Executor 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#两级调度模型"><span class="toc-number">3.2.1.</span> <span class="toc-text">两级调度模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor-框架结构"><span class="toc-number">3.2.2.</span> <span class="toc-text">Executor 框架结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor-框架成员"><span class="toc-number">3.2.3.</span> <span class="toc-text">Executor 框架成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor-接口"><span class="toc-number">3.2.4.</span> <span class="toc-text">Executor 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExecutorService-接口"><span class="toc-number">3.2.5.</span> <span class="toc-text">ExecutorService 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future"><span class="toc-number">3.2.6.</span> <span class="toc-text">Future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractExecutorService-实现"><span class="toc-number">3.2.7.</span> <span class="toc-text">AbstractExecutorService 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#newTaskFor-方法"><span class="toc-number">3.2.7.1.</span> <span class="toc-text">newTaskFor 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#submit-提交任务"><span class="toc-number">3.2.7.2.</span> <span class="toc-text">submit 提交任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提交任务方式"><span class="toc-number">3.2.7.3.</span> <span class="toc-text">提交任务方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行机制"><span class="toc-number">3.3.</span> <span class="toc-text">运行机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">4.</span> <span class="toc-text">ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#核心参数"><span class="toc-number">4.1.</span> <span class="toc-text">核心参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#核心属性"><span class="toc-number">4.2.</span> <span class="toc-text">核心属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法"><span class="toc-number">4.3.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期"><span class="toc-number">4.4.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设计思想"><span class="toc-number">4.4.1.</span> <span class="toc-text">设计思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池状态"><span class="toc-number">4.4.2.</span> <span class="toc-text">线程池状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RUNNING"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">RUNNING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHUTDOWN"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">SHUTDOWN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STOP"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">STOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TIDYING"><span class="toc-number">4.4.2.4.</span> <span class="toc-text">TIDYING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TERMINATED"><span class="toc-number">4.4.2.5.</span> <span class="toc-text">TERMINATED</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任务执行机制"><span class="toc-number">4.5.</span> <span class="toc-text">任务执行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#任务调度"><span class="toc-number">4.5.1.</span> <span class="toc-text">任务调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务缓冲"><span class="toc-number">4.5.2.</span> <span class="toc-text">任务缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务申请"><span class="toc-number">4.5.3.</span> <span class="toc-text">任务申请</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务执行-1"><span class="toc-number">4.5.4.</span> <span class="toc-text">任务执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务拒绝"><span class="toc-number">4.5.5.</span> <span class="toc-text">任务拒绝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#拒绝策略"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">拒绝策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbortPolicy"><span class="toc-number">4.5.5.2.</span> <span class="toc-text">AbortPolicy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CallerRunsPolicy"><span class="toc-number">4.5.5.3.</span> <span class="toc-text">CallerRunsPolicy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiscardPolicy"><span class="toc-number">4.5.5.4.</span> <span class="toc-text">DiscardPolicy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiscardOldestPolicy"><span class="toc-number">4.5.5.5.</span> <span class="toc-text">DiscardOldestPolicy</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Worker线程管理"><span class="toc-number">5.</span> <span class="toc-text">Worker线程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Worker线程"><span class="toc-number">5.1.</span> <span class="toc-text">Worker线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新增线程"><span class="toc-number">5.2.</span> <span class="toc-text">新增线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行任务"><span class="toc-number">5.3.</span> <span class="toc-text">执行任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#再谈线程复用"><span class="toc-number">5.3.1.</span> <span class="toc-text">再谈线程复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程回收"><span class="toc-number">5.4.</span> <span class="toc-text">线程回收</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关闭线程池"><span class="toc-number">6.</span> <span class="toc-text">关闭线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#shutdown"><span class="toc-number">6.1.</span> <span class="toc-text">shutdown</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shutdownNow"><span class="toc-number">6.2.</span> <span class="toc-text">shutdownNow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tryTerminate"><span class="toc-number">6.3.</span> <span class="toc-text">tryTerminate()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池配置"><span class="toc-number">7.</span> <span class="toc-text">线程池配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-密集型任务"><span class="toc-number">7.1.</span> <span class="toc-text">CPU 密集型任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-密集型任务"><span class="toc-number">7.2.</span> <span class="toc-text">IO 密集型任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#合适线程数"><span class="toc-number">7.3.</span> <span class="toc-text">合适线程数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池监控"><span class="toc-number">8.</span> <span class="toc-text">线程池监控</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#动态设置核心线程数"><span class="toc-number">8.1.</span> <span class="toc-text">动态设置核心线程数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态设置最大线程数"><span class="toc-number">8.2.</span> <span class="toc-text">动态设置最大线程数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态设置空闲时间"><span class="toc-number">8.3.</span> <span class="toc-text">动态设置空闲时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#允许核心线程超时回收"><span class="toc-number">8.4.</span> <span class="toc-text">允许核心线程超时回收</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">9.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-concurrent/ThreadPool" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      并发 - 线程池
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/d7cef21d/" class="article-date">
	  <time datetime="2020-12-02T16:00:00.000Z" itemprop="datePublished">2020-12-03</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/JDK/">JDK</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/JUC/" rel="tag">JUC</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/d7cef21d/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 17.3k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 66(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最初的时候并没有线程池的概念，而是先有线程。每个任务都需要对应一个线程，任务少的情况没有太大问题，任务过多就出现了各种性能和资源开销问题，更重要的是可创建线程的数量是有上限的，不可能无限的创建。在并发环境下，系统不能够确定在某一时刻有多少任务需要执行，有多少资源需要投入。</p>
<p>针对上述问题，于是诞生了线程池，用来平衡线程与系统资源之间的关系。<strong>线程池解决问题思路</strong>如下：</p>
<ol>
<li>对于反复创建线程开销问题，线程池采用固定数量的线程一直保持工作状态并能反复执行任务。</li>
<li>对于创建过多线程占用太多资源问题，线程池会根据需要创建线程，灵活地控制线程数量，避免使用过多资源。</li>
</ol>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>线程池是一种<strong>管理线程和任务的工具</strong>，是应用场景最多的并发框架之一，几乎所有需要异步或并发执行任务的应用程序都可以使用线程池，合理地使用线程池可以带来可观得性能提升和响应速度。具体好处如下：</p>
<ul>
<li>解耦：线程的创建与任务执行完全分开。</li>
<li>降低资源消耗：线程的复用降低了线程创建和销毁带来的资源消耗。</li>
<li>提高响应速度：大多情况下（线程池预热后），到达的任务可以不需要等待线程创建就能立即执行，消除了线程创建所带来的延迟，提升了响应速度。</li>
<li>便于线程管理：线程是稀缺资源，不能无限制地创建，使用线程池可以对线程进行统一分配、调优和监控。</li>
</ul>
<p>关于线程池的概述就介绍这么多，本篇文章介绍的线程池核心是 JDK 中提供的 <code>ThreadPoolExecutor</code> 类，具体涉及的接口和实现类如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-threadpoolexecutor-base-uml.jpg" alt></p>
<p>需要说明的是，关于<strong>Scheduled类型</strong>的线程池继承体系本篇文章没有介绍到，它是基于本篇文章着重介绍的 <strong>ThreadPoolExecutor</strong> 的扩展实现，支持时间纬度执行任务。</p>
<h1 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h1><p>线程池的设计没有办法直接采用一般意义上池化资源方案，而是采用<strong>生产者 - 消费者</strong>模式，将任务和线程解耦并不直接关联，从而良好的缓冲任务、复用线程，缓冲任务通过阻塞队列实现，工作线程从阻塞队列中获取任务以实现线程复用。线程池的使用方是生产者，线程池本身是消费者。至于为什么线程池没有采用一般意义上池化资源的设计方法，这个取决于线程对象的特殊性，线程有着特殊的生命周期，一旦一个线程启动执行任务就不能再次启动了。</p>
<h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>任务的执行不一定非要通过开启新线程，任务在线程执行之前它也是一个实现类，也有对应的方法。因此我们可以定义出方法级别调用和线程级别调用。</p>
<h3 id="线程级别调用"><a href="#线程级别调用" class="headerlink" title="线程级别调用"></a>线程级别调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">      &#125;).start();</span><br></pre></td></tr></table></figure>

<h3 id="方法级别调用"><a href="#方法级别调用" class="headerlink" title="方法级别调用"></a>方法级别调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((Runnable) () -&gt; &#123;</span><br><span class="line">          <span class="comment">//..</span></span><br><span class="line">        &#125;).run();</span><br></pre></td></tr></table></figure>

<p>线程池对任务的处理最终是通过方法级别调用的来完成，在后面分析源码的时候我们可以看到。</p>
<h2 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h2><p>Executor 是一个异步任务的框架，根据一组执行策略进行调用、调度、执行和控制，目的是提供一种将<strong>任务提交</strong>和<strong>任务执行</strong>分离的机制。 </p>
<h3 id="两级调度模型"><a href="#两级调度模型" class="headerlink" title="两级调度模型"></a>两级调度模型</h3><p>最早 Java 的线程既是任务体也是执行机制，从 JDK5 开始，把任务体和执行机制进行了分离。任务体包括 Runnable 和 Callable，而执行机制由 Executor 框架提供，即 <strong>Executor是 Runnable 和 Callable 的调度容器</strong>。</p>
<p>Java 线程会被一对一映射为操作系统线程，在 Java 线程启动时创建对应的操作系统线程，同样地，当该 Java 线程终止时对应的操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的 CPU 。对于计算复杂的应用，我们通常会将其拆解为若干个任务并交给 Java 多个线程，这个动作是由用户级别的调度器 Executor 框架完成的，它会将这若干个任务映射为对应数量的线程。在底层，操作系统内核将这些线程映射到硬件处理器上。由此可见，创建一个线程远比创建一个对象要复杂得多，不仅要在 JVM 堆中分配内存，还需要调用操作系统内核 API 来为线程分配资源，因此应该避免频繁创建和销毁。</p>
<p>这个过程属于两级调度模型，对应的示意图如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-executor.jpg" alt></p>
<p>从示意图可看出，应用程序通过 Executor 框架控制上层的调度。而下层的调度由操作系统内核控制，应用程序是无法控制的。</p>
<h3 id="Executor-框架结构"><a href="#Executor-框架结构" class="headerlink" title="Executor 框架结构"></a>Executor 框架结构</h3><p>Executor 框架主要由三大部分组成，具体如下：</p>
<ul>
<li>任务体<br>包括 Runnable 接口和 Callable 接口及其实现。</li>
<li>任务的执行<br>包括任务执行机制的核心接口 Executor，继承 Executor 的 ExecutorService 接口和它的实现们。</li>
<li>异步计算结果<br>包括核心接口 Future 以及对应的实现们，特别是 FutureTask 实现类。是对具体 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作。</li>
</ul>
<h3 id="Executor-框架成员"><a href="#Executor-框架成员" class="headerlink" title="Executor 框架成员"></a>Executor 框架成员</h3><p>Executor 框架是线程池实现的基础，它的主要成员有 <code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>、<code>Executors</code>、<code>Runnable</code>、<code>Callable</code> 以及 <code>Future</code> 。</p>
<p>下面正式进入到代码层面的介绍，定时任务实现类 <code>ScheduledThreadPoolExecutor</code> 继承自 <code>ThreadPoolExecutor</code> ，用于实现定时执行，本文暂不介绍它的实现。</p>
<h3 id="Executor-接口"><a href="#Executor-接口" class="headerlink" title="Executor 接口"></a>Executor 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Runable 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Executor 接口仅定义了一个方法，参数是 Runnable 类型，该方法的目的是<strong>将任务提交和任务执行细节解耦</strong>。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需将任务提交到执行器 Executor 中，由执行器完成线程的调配和任务的执行。需要注意的是，该接口是没有返回值的，也就意味着无法判断提交的任务是否被线程池执行成功。</p>
<h3 id="ExecutorService-接口"><a href="#ExecutorService-接口" class="headerlink" title="ExecutorService 接口"></a>ExecutorService 接口</h3><p>ExecutorService 接口继承自 Executor 接口，一般我们自定义线程池时使用的就是这个接口，该接口中定义的方法加上继承过来的 <strong>execute</strong> 方法在很多场景中已经可以满足需求了。</p>
<p>该接口中的方法如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-executorservice-method.jpg" alt></p>
<p>上图中的方法大致分类如下：</p>
<ol>
<li>向线程池提交任务方法<blockquote>
<p><strong>submit</strong> 方法和前文中的 <strong>Executor</strong> 接口中的 <strong>execute</strong> 方法有所不同，虽然也是向线程池提交任务，但是有返回值 Future ，并且参数类型不仅支持 <strong>Runnable</strong> 类型还支持 Callable 类型。</p>
</blockquote>
</li>
<li>执行任务方法<blockquote>
<p><strong>invokeAll</strong> 方法用于执行多个任务，同时支持设置超时时间。<strong>invokeAny</strong> 方法用于执行多个方法中的一个即可，任务执行完成就可以返回，同样支持设置超时时间。这两类方法的底层需要依赖 execute 方法。</p>
</blockquote>
</li>
<li>关闭线程池方法<blockquote>
<p><strong>shutdown</strong> 和 <strong>shutdownNow</strong> 方法用于关闭线程池。</p>
</blockquote>
</li>
<li>判断线程池是否关闭<blockquote>
<p><strong>isShutdown</strong> 判断线程池是否已经开始了关闭工作，即是否执行了 shutdown 或者 shutdownNow 方法。注意，该方法返回 true 并不代表线程池此时已经彻底关闭了，仅说明线程池开始了关闭的流程，此时线程池中可能依然有线程在执行任务，队列中仍有等待被执行的任务。</p>
</blockquote>
</li>
<li>判断线程池是否终止方法<blockquote>
<p><strong>isTerminated</strong> 和 <strong>awaitTermination</strong> 方法用于判断线程池是否终止。只有在调用关闭方法后才有调用的意义。</p>
</blockquote>
</li>
</ol>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future 的继承体系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-future-hierarchy.jpg" alt></p>
<p>由上图的UML可知，FutureTask 通过 RunnableFuture 间接实现了 Runnable 接口，因此 <code>Executor.execute</code> 方法支持将 FutureTask 提交到线程池。接下来介绍 AbstractExecutorService 抽象实现类就能很清晰看出 FutureTask 的作用。</p>
<h3 id="AbstractExecutorService-实现"><a href="#AbstractExecutorService-实现" class="headerlink" title="AbstractExecutorService 实现"></a>AbstractExecutorService 实现</h3><p>AbstractExecutorService 抽象类实现自 ExecutorService 接口，在其基础上实现了几个常用的方法，这些方法供子类进行调用。<strong>将执行任务的流程串联起来，保证下层的实现（如 ThreadPoolExecutor）只需关注执行任务的方法即可</strong>。具体方法如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-abstract-method.jpg" alt></p>
<p>由于 <strong>invokeAll</strong> 方法和 <strong>invokeAny</strong> 方法更多的是执行将任务提交给线程池前的工作，它们并没有将任务提交给线程池，需要通过 Executor 中的 execute 方法实现，而 execute 方法最终要交给具体子类实现。因此，不再对这两类方法展开说明。下面重点介绍下 <strong>newTaskFor</strong> 方法和 <strong>submit</strong> 方法。</p>
<h4 id="newTaskFor-方法"><a href="#newTaskFor-方法" class="headerlink" title="newTaskFor 方法"></a>newTaskFor 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractExecutorService</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Runnable 包装成 FutureTask</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value    任务执行成功的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Callable 包装成 FutureTask</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，<strong>newTaskFor</strong>  方法用于将 Runnable 和 Callable 类型的任务统一包装成 FutureTask ，FutureTask 又间接继承了 Runnable 接口。我们知道，Runnable 的 <strong>void run()</strong> 方法是没有返回值的， 而 Callable 的 <strong>V call()</strong> 方法是有返回值的，但 Executor 中的 <strong>void execute(Runnable command)</strong>方法是不关心返回结果的，它只负责处理 Runnable 类型的任务。综上，不难看出 <strong>newTaskFor</strong> 方法就是为了屏蔽不同类型任务的差异，以达到统一交给 <strong>Executor.execute</strong> 执行的目的。下面我们继续看提交任务的另外一种方式。</p>
<h4 id="submit-提交任务"><a href="#submit-提交任务" class="headerlink" title="submit 提交任务"></a>submit 提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractExecutorService</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交 Runnable 任务，不需要返回结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交 Runnable 任务，任务执行成功的返回结果为 result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交 Callable 任务，任务执行成功返回结果是Callable#call 方法返回值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Runnable 的 <strong>void run()</strong> 方法没有返回值，但是有的时候我们需要返回值，这个时候 <strong>submit</strong> 方法就可以实现，只需在该方法的第二个参数传入预期结果，当任务执行完成后会自动返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure>

<p>此外，我们可以看出 <strong>submit</strong> 方法提交任务的能力是通过 <strong>execute</strong> 方法实现的。定义于最上层接口 Executor 中的 <strong>void execute(Runnable command)</strong> 方法不会返回执行结果，想要执行结果就需要通过 FutureTask 包装任务，然后将包装后的任务 <strong>FutureTask</strong> 交给 <strong>Executor.execute</strong> 方法执行，执行后的结果也会保存到 <strong>FutureTask</strong> 中。关于 Future 的继承体系不展开分析，下面概述下 submit 提交任务的原理。</p>
<ol>
<li>调用 newTaskFor 方法将 Runnable 和 Callable 类型的任务统一包装成 FutureTask 对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callable</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;      </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Runnable</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将 Runnable 适配成 Callable</span></span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable task;</span><br><span class="line">        <span class="keyword">final</span> T result;</span><br><span class="line">        RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务执行还是调用 run 方法，返回结果是传入的预期值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            task.run();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
包装的本质是将任务统一适配为Callable类型，因为Callable类型任务可以通过call方法返回执行结果。</li>
<li>当任务执行的时候，FutureTask 中的 run 方法会执行，这个过程是最关键的一步。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">           !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                        <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Callable&lt;V&gt; c = callable;</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">               V result;</span><br><span class="line">               <span class="keyword">boolean</span> ran;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 被适配的Runnable 和 Callable 方法级别调用</span></span><br><span class="line">                   result = c.call();</span><br><span class="line">                   ran = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                   result = <span class="keyword">null</span>;</span><br><span class="line">                   ran = <span class="keyword">false</span>;</span><br><span class="line">                   setException(ex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (ran)</span><br><span class="line">                   <span class="comment">// 将执行结果保存到 FutureTask 中</span></span><br><span class="line">                   set(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">           <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">           runner = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">           <span class="comment">// leaked interrupts</span></span><br><span class="line">           <span class="keyword">int</span> s = state;</span><br><span class="line">           <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">               handlePossibleCancellationInterrupt(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>通过FutureTask#get方法从 FutureTask 中取出任务执行结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> s = state;</span><br><span class="line">      <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">          s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">      <span class="comment">// 从 FutureTask 中取出任务执行结果</span></span><br><span class="line">      <span class="keyword">return</span> report(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">int</span> s = state;</span><br><span class="line">      <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">          (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">     <span class="comment">// 从 FutureTask 中取出任务执行结果</span></span><br><span class="line">      <span class="keyword">return</span> report(s);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="提交任务方式"><a href="#提交任务方式" class="headerlink" title="提交任务方式"></a>提交任务方式</h4><p>最上层接口 Executor 中的 <strong>void execute(Runnable)</strong> 不需要获取结果，不会使用 FutureTask 包装任务。抽象实现类 AbstractExecutorService 中的 <strong>Future&lt;?&gt; submit()</strong> 需要获取结果，因此使用了 FutureTask 包装任务。</p>
<blockquote>
<p>需要获取任务结果用 submit 方法，不需要获取结果用 execute 方法。</p>
</blockquote>
<h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-principle.jpg" alt></p>
<p>上图展示了线程池的运行机制，线程池运行机制主要分成两个部分，线程管理和任务管理。下面对线程池的主要处理流程进行说明：</p>
<ol start="0">
<li>主线程提交任务到线程池。</li>
<li>如果当前线程池中的线程少于核心线程数，则创建新的线程来执行任务。</li>
<li>如果线程池中的线程达到或超过核心线程数，则将任务加入到阻塞队列中。</li>
<li>如果在第 2 步中无法将任务加入阻塞队列，则依据最大线程数创建新的线程来处理任务。</li>
<li>如果在第 3 步创建新线程会使线程池中线程数超出最大线程数，任务将被拒绝并使用饱和策略处理（拒绝策略）。</li>
<li>处理完任务的线程会自旋获取新的任务去执行，当线程获取不到任务时，线程会被回收（一般针对非核心线程）。</li>
</ol>
<p>其中第 1 步和第 3 步涉及到创建线程，该过程需要获取全局锁，因为关闭线程池也需要获取这个全局锁。当线程池完成了<strong>预热</strong>即核心线程数创建完毕，在一定程度上就不需要频繁创建线程，也就降低了获取全局锁的频次，对于线程池来说全局锁是一个严重的可伸缩瓶颈。关于流程中的概念下文会陆续说明。</p>
<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>线程池核心实现就在 <strong>ThreadPoolExecutor</strong> 实现类中，该类实现了线程池所需的各个方法，包括最核心的 <strong>execute</strong> 方法。开发者可以基于该实现类来进行功能上的扩展，定时任务实现类 <code>ScheduledThreadPoolExecutor</code> 就是基于 <code>ThreadPoolExecutor</code> 扩展的功能。</p>
<p>在详细介绍 <code>ThreadPoolExecutor</code> 运行机制之前，我们先对其核心概念，属性、方法等进行简单介绍。</p>
<h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize, // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime, // 空闲线程存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit, // 空闲线程存活时间的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory, // 线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler // 饱和策略</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;<span class="comment">//...&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>corePoolSize</strong><blockquote>
<p>核心线程数，线程池的基本大小。当提交一个任务到线程池时，线程池会创建一个基本线程来执行任务，即使其它空闲的基本线程能够执行新任务也会创建线程，只有线程池预热完毕（线程池中线程数达到核心线程数）才不再创建核心线程。</p>
</blockquote>
</li>
</ul>
<p><strong>特别说明：</strong></p>
<ol>
<li>核心线程并不是特指某一个或某几个线程，而是针对设置的核心线程数而言，任何一个线程都可以是核心线程。</li>
<li>corePoolSize 表示的是线程池的常驻线程数，如果设置为 0 则表示在没有任何任务时需要销毁线程池。如果大于 0 ，即使没有任务时也会保证线程池的线程数等于此值。</li>
<li>关于此值设置的合理性，如果设置的较小，则会频繁的创建和销毁线程（非核心线程）；设置过大，则会浪费资源。</li>
</ol>
<ul>
<li><p><strong>maximumPoolSize</strong></p>
<blockquote>
<p>最大线程数，线程池允许创建的最大线程数，最大线程数 = 核心线程数 + 非核心线程数。此值只有在任务比较多且阻塞队列放不下时才会用到。</p>
</blockquote>
</li>
<li><p><strong>keepAliveTime</strong></p>
<blockquote>
<p>空闲线程存活时间，线程池中的线程空闲时间超过该值也没任务可做那么就需要回收销毁。如果设置为 0，表示一旦空闲立即回收。该参数一般只会对非核心线程起作用，核心线程不会因为空闲太长时间而被关闭，当最大线程数等于核心线程数时，那么线程池在空闲的时候也不会销毁任何线程。但是可通过调用 <strong>allowCoreThreadTimeOut(true)</strong> 方法使核心线程数内的线程也可以被回收。</p>
</blockquote>
</li>
<li><p><strong>unit</strong></p>
<blockquote>
<p>和 keepAliveTime 参数一起使用，是时间单位。如：天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）等。</p>
</blockquote>
</li>
<li><p><strong>workQueue</strong></p>
<blockquote>
<p>用于存放等待执行的任务的阻塞队列，是 BlockingQueue 接口的实现。当线程池中的线程数大于等于核心线程数时才会用到该队列，注意和有没有空闲核心线程无关。</p>
</blockquote>
</li>
<li><p><strong>threadFactory</strong></p>
<blockquote>
<p>线程工厂，线程池中的线程就由它创建。如果没有设置就使用默认的线程工厂。</p>
</blockquote>
</li>
<li><p><strong>handler</strong></p>
<blockquote>
<p>饱和策略（拒绝策略），当阻塞队列和线程池都满了，说明线程池处于饱和状态，需要采取一种策略处理提交的新任务，默认是直接抛出异常。</p>
</blockquote>
</li>
</ul>
<p><strong>通过配置不同的参数，就可以创建出行为不同的线程池，这也是线程池高度灵活性的基础。</strong></p>
<h2 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">--- ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">     <span class="comment">//======= 约定使用32位表示线程池状态和数量，高3位表示状态 ，低29位表示数量 =============/</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池初始化状态码，状态为 RUNNING，线程数为 0</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * COUNT_BITS 为 29 (0001 1101)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池允许最大线程池临界值，1 * 2^29 = 536870912</span></span><br><span class="line"><span class="comment">      * 过程：（1）001 （2）左移29位得到001后跟29个0 -&gt; 0010 0000 0000 0000 0000 0000 0000 0000 （3）减去1得0001 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 运行状态：111 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 关闭状态：000 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN = <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 停止状态：001 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 整理状态：010 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING = <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 终止状态：011 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 获取线程池的状态。将整数 c 的低 29 位置为 0 就得到了线程池的状态</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &amp; ~CAPACITY;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 用于计算线程池中线程数量。将整数 c 的高 3 位置为 0，就得到了线程池中的线程数</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 获取线程池状态码</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> rs | wc;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 比较状态</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &lt; s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 当前线程池是否处于运行状态</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 增加线程池中的线程数量</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 减少线程池中的线程数量</span></span><br><span class="line"><span class="comment">      * Attempts to CAS-decrement the workerCount field of ctl.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">         &#125; <span class="keyword">while</span> (!compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池阻塞队列</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池全局锁</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 1.用于保存和移除线程池创建的Worker，用来控制线程的生命周期。</span></span><br><span class="line"><span class="comment">      * 2.对于垃圾回收来说，即使Worker中封装的thread完成了任务的执行（包括异常情况），但是如果Worker不被回收那么thread仍然被强引用着。</span></span><br><span class="line"><span class="comment">      * 3.该Hash表是线程不安全的，操作时需要加全局锁</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 全局锁条件 - 条件队列</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 追踪线程池最大值，仅在获取到全局锁条件下执行</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池完成任务数量</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程工厂</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 饱和策略</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 保活时间，即最大允许空闲时间</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 是否允许核心线程被回收</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 核心线程池数，不会被回收，即 workers的最小值。除非设置 allowCoreThreadTimeOut 。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 最大线程数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 默认的饱和策略，直接抛出异常</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br></pre></td></tr></table></figure>

<p>上面的属性都很重要，其中还包含了部分属性的操作方法，这些都会在下面的源码分析中不断出现。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Public constructors and methods 构造方法们</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">              Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">              threadFactory, defaultHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">              <span class="comment">// 当没有指定线程工厂时，使用默认的线程创建工厂</span></span><br><span class="line">              Executors.defaultThreadFactory(), handler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">              maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">              maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">              keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">              <span class="keyword">null</span> :</span><br><span class="line">              AccessController.getContext();</span><br><span class="line">      <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">      <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">      <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">      <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">      <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">      <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>创建线程池时如果不指定线程工厂则会使用默认的线程工厂，默认线程工厂创建的线程都属于同一个线程组，拥有相同的优先级，并且都是非守护线程，具体代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">--- Executors</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            <span class="comment">// 线程组</span></span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">"-thread-"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 创建线程</span></span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 设置为非守护线程</span></span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 设置优先级</span></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>线程池采用的是 <strong>Integer.SIZE</strong> 32 位的整数来存放线程池的<strong>状态</strong>和池中的<strong>线程数</strong>，其中高 3 位表示线程池状态即可以表示 7 种状态，低 29 位表示线程数即可以存放 5 亿多个线程。这种设计思想对整数赋予了双重角色，通过高低位的不同，既表示线程池状态，又表示工作线程数目，这是一个典型的高效优化。要知道用一个变量存储两个值，可以避免在做相关决策时出现不一致的情况，省去了占用锁资源去维护两个变量的一致性。这种方式在其它框架中也多有使用，如 Dubbo 协议就使用 16 个字节共 128 位，每一位用来表示不同意义的数值。</p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>线程池的状态表示如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-threadpoolexecutor-ctl.jpg" alt></p>
<p>注意，<strong>线程池的状态并非用户显示配置（用户调用关闭方法除外），而是随着线程池的运行由内部自行维护，和线程的执行密切相关</strong>，下面分别说明线程池的状态及其状态流转。</p>
<h4 id="RUNNING"><a href="#RUNNING" class="headerlink" title="RUNNING"></a>RUNNING</h4><ul>
<li><strong>状态说明</strong><br>线程池处于 RUNNING 状态允许接受新的任务，处理任务队列中的任务。</li>
<li><strong>状态转换</strong><br>线程池一旦被创建就处于 RUNNING 状态，并且线程池中的线程数为 0 。</li>
</ul>
<h4 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h4><ul>
<li><strong>状态说明</strong><br>线程池处于 SHUTDOWN 状态时，不再接收新任务，但能处理任务队列中的任务。</li>
<li><strong>状态转换</strong><br>调用线程池的shutdown()方法时，线程池由RUNNING -&gt; SHUTDOWN 。</li>
</ul>
<h4 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h4><ul>
<li><strong>状态说明</strong><br>线程池处在 STOP 状态时，不能接收新任务，也不处理任务队列中的任务，并且会<strong>中断</strong>正在处理任务的线程。</li>
<li><strong>状态转换</strong><br>调用线程池的shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP 。</li>
</ul>
<h4 id="TIDYING"><a href="#TIDYING" class="headerlink" title="TIDYING"></a>TIDYING</h4><ul>
<li><strong>状态说明</strong><br>所有的任务已终止，线程池中线程数为 0 ，线程池会变为TIDYING状态（线程池内部自动更新状态）。当线程池变为TIDYING状态后，会紧接着执行钩子方法terminated()。若用户需要在线程池变为TIDYING时，进行相应的处理，可以通过重写terminated()方法来实现。 </li>
<li><strong>状态转换</strong><br>当线程池在 SHUTDOWN 状态下时，阻塞队列为空并且线程池中线程数为 0 时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在 STOP 状态下，线程池中线程数为 0 时，就会由STOP -&gt; TIDYING。</li>
</ul>
<h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><ul>
<li><strong>状态说明</strong><br>线程池彻底终止，就变成 TERMINATED 状态。</li>
<li><strong>状态转换</strong><br>线程池处在TIDYING状态时，执行完 terminated() 方法之后，就会由 TIDYING -&gt; TERMINATED。</li>
</ul>
<p>下面进行小结，线程池状态及流转（线程池的生命周期）如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-status.jpg" alt></p>
<h2 id="任务执行机制"><a href="#任务执行机制" class="headerlink" title="任务执行机制"></a>任务执行机制</h2><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>任务调度是线程池的主要入口，所有任务的调度都是由<strong>execute方法</strong>完成的，当用户提交了一个任务后，任务调度阶段将决定如何执行该任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 任务体不允许为 null</span></span><br><span class="line">     <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取线程池的状态码,该值包含了线程池的状态和线程数</span></span><br><span class="line">     <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1 如果当前线程数少于核心线程数，则创建一个 Worker 来执行任务，即创建一个线程并将 command 作为该线程的第一个任务</span></span><br><span class="line">     <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         <span class="comment">// 返回 false 说明线程池不允许创建线程，可能原因：（1）线程池关闭（2）当前线程数已经达到临界值</span></span><br><span class="line">         <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">// 创建失败，重读线程池状态码</span></span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2 如果线程池处于运行状态，则尝试将任务添加到阻塞队列 workQueue 中</span></span><br><span class="line">     <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         <span class="comment">// 再次获取线程池状态码</span></span><br><span class="line">         <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">         <span class="comment">// 双重检查，再次判断线程池状态。如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，同时执行拒绝策略。防止线程池关闭。</span></span><br><span class="line">         <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             reject(command);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 如果线程池状态仍然是运行状态，并且线程池为空则创建一个非核心线程来执行任务，防止线程提交到阻塞队列后线程都关闭了。</span></span><br><span class="line">             <span class="comment">// 一般这种情况是设置核心线程数为 0 </span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">             addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 3 如果任务队列满了，则根据 maximumPoolSize 创建非核心线程。如果创建失败，说明当前线程数已经达到 maximumPoolSize 或线程池关闭，需要执行拒绝策略</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>execute 方法逻辑体现了提交任务到线程池的流程</strong>，上面代码已经详细注释。需要强调的是，符合将任务加入阻塞队列中的情况，会进行双重检查线程池的状态，因为是直接将任务入队，和前后两种情况不一样，即使任务成功排队，也有可能出现线程池关闭或线程池为空的情况。</p>
<p>下面通过一张图进行阐述正常流（不考虑线程池关闭等情况）的流程：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-process.jpg" alt></p>
<h3 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h3><p>任务缓冲是线程池管理任务的核心部分，通过一个阻塞队列来实现。<strong>线程池的本质是对任务和线程的管理</strong>，而做到这一点关键的思想是将任务和线程解耦，阻塞队列缓冲任务，工作线程自旋从阻塞队列中获取任务。</p>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。</p>
<p>线程池中的阻塞队列参数非常重要，<strong>不同的阻塞队列对线程池有不同影响</strong>，下面对线程池常用的阻塞队列进行说明。</p>
<ul>
<li><p><strong>ArrayBlockingQueue</strong><br>基于数组结构的有界阻塞队列，该队列按照先进先出原则对元素进行排序。</p>
</li>
<li><p><strong>LinkedBlockingQueue</strong><br>基于链表结构的无界阻塞队列，该队列按照先进先出规则对元素进行排序。此队列的默认长度为 <strong>Integer.MAX_VALUE</strong>，使用该队列作为任务队列有容量危险。</p>
</li>
<li><p><strong>SynchronousQueue</strong><br>一个比较特殊的阻塞队列，其本身不存储元素。每个插入操作必须等待另一个线程执行移除操作，反之亦然。如果使用该阻塞队列，只有当两个线程执行相反模式的操作才能配对成功，否则先执行的一方只能等待。下图是对线程池使用该队列处理任务过程的描述：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-syncronousqueue.jpg" alt></p>
</li>
<li><p><strong>PriorityBlockingQueue</strong><br>支持优先级排序的无界阻塞队列，默认自然排序规则，不能保证同优先级元素的顺序。</p>
</li>
<li><p><strong>DelayQueue</strong><br>一个实现 PriorityBlockingQueue 实现延迟获取的无界队列，在创建元素时可以指定多久才能从队列中移除，只有延时期满后才能从队列中获取元素。</p>
</li>
<li><p><strong>LinkedBlockingDeque</strong><br>一个由链表结构构成的双向阻塞队列。队列头部和尾部都可以添加和移除元素。</p>
</li>
</ul>
<h3 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h3><p>任务执行有两种情况，一种是任务直接交给新创建的线程执行。另一种是线程执行 <strong>getTask</strong> 方法从任务队列中获取任务并执行，执行完任务的线程会继续尝试从任务队列中申请任务再去执行。第一种情况仅出现在用户提交任务到线程池，线程池为该任务创建线程的时候。第二种情况是线程执行任务最多的情况，包括线程池存在的线程执行任务，创建的非核心线程执行任务。</p>
<p>任务申请的核心方法 <strong>getTask</strong> 是配合 <strong>Worker线程</strong> 工作的，用于 <strong>Worker线程</strong> 拉取任务队列，下面对该方法进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回null 表示可以对当前线程进行回收</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取线程池状态码</span></span><br><span class="line">         <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">         <span class="comment">// 获取线程池状态</span></span><br><span class="line">         <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 线程池状态为SHUTDOWN且队列为空 或 线程池状态为 STOP，应该回收线程。这个条件不仅可以回收非核心线程，也可以回收核心线程。todo 核心线程唯一回收条件</span></span><br><span class="line">         <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">             <span class="comment">// 减少线程池中的线程数</span></span><br><span class="line">             decrementWorkerCount();</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 线程池中的线程数</span></span><br><span class="line">         <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 是否需要进行超时控制。即允许核心线程数内的线程回收，或线程池中的线程数超过了核心线程数，那么有可能发生超时关闭</span></span><br><span class="line">         <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 控制线程池中线程数的关键</span></span><br><span class="line">         <span class="comment">//1. wc &gt; maximumPoolSize ，可能是在此方法执行阶段同时执行 setMaximumPoolSize 方法修改了最大值。</span></span><br><span class="line">         <span class="comment">//2. timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，且线程上一轮获取任务超时</span></span><br><span class="line">         <span class="comment">//3. 结果：如果线程池中的线程数大于最大线程数或获取任务超时（不设置 allowCoreThreadTimeOut，核心线程没有超时概念），并且（线程数 &gt; 1 或 任务队列为空），则应该回收当前线程。</span></span><br><span class="line">         <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">             <span class="comment">// 减少工作线程数</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 根据timed来判断：</span></span><br><span class="line">             <span class="comment">// 1. 如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务则返回null</span></span><br><span class="line">             <span class="comment">// 2. 否则通过take方法获取任务，如果队列为空则take方法会阻塞直到队列不为空</span></span><br><span class="line">             Runnable r = timed ?</span><br><span class="line">                     <span class="comment">// 超时获取任务，因为线程超时要被回收。如果线程在等待的过程发生了中断，会抛出中断异常</span></span><br><span class="line">                     workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                     <span class="comment">// 不需要超时，如果线程在等待的过程发生了中断，会抛出中断异常</span></span><br><span class="line">                     workQueue.take();</span><br><span class="line">             <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                 <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 如果 r == null ，说明获取任务超时</span></span><br><span class="line">             timedOut = <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">             <span class="comment">// 获取任务时当前线程发生中断，重置超时标记并重试</span></span><br><span class="line">             timedOut = <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上述方法用于从任务队列中<strong>不断</strong>拉取待执行的任务，具体执行流程如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-gettask-process.jpg" alt></p>
<p>下面对主要逻辑进行说明：</p>
<ol>
<li>该方法返回 null 时，表示当前线程可以被回收了，包括核心线程。这也是该方法多次判断的原因，控制线程池中线程数量，进而控制线程池的状态。</li>
<li>在没有设置 allowCoreThreadTimeOut 时，核心线程数的线程会阻塞等待任务，不会被回收。</li>
<li>超时回收，在 keepAliveTime 对应的具体时间内都没有任务，应该回收非核心线程。</li>
<li>以下情况需要返回 null，回收当前线程。<ul>
<li>线程池处于 STOP 状态。</li>
<li>线程池处于 SHUTDOWN 状态，且阻塞队列为空。</li>
<li>线程池中的线程数大于最大线程数。</li>
<li>线程获取任务超时再次重试时，仍为可回收线程。</li>
</ul>
</li>
</ol>
<p>getTask 方法还是比较复杂的，整个逻辑中进行了多次判断，目的是控制线程的数量，进而维护线程池的状态。需要特殊说明的是，当线程获取任务超时时并没有立刻回收该线程，而是让线程重试，这么做是为了防止该线程可能会成为核心线程，避免误回收，如果误回收在后续流程中还需要重新创建线程，因此重试一次代价会小一些。</p>
<h3 id="任务执行-1"><a href="#任务执行-1" class="headerlink" title="任务执行"></a>任务执行</h3><p>任务执行是 <strong>Worker线程</strong> 的工作，我们会在下面详细介绍。 </p>
<h3 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h3><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>线程池的拒绝策略属于一种限流保护机制，防止线程池崩溃。线程池拒绝任务的时机如下：</p>
<ol>
<li>执行关闭方法后线程池处于关闭状态及以上状态</li>
<li>线程池处于运行状态，但是没有能力（阻塞队列已满，线程数达到最大值）处理新提交的任务了。</li>
</ol>
<p>JDK 内置了 4 种拒绝策略，默认使用 AbortPolicy 策略。拒绝策略如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-rejectedexecutionhandler.jpg" alt></p>
<h4 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 丢弃任务并抛出异常（默认策略）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 直接抛出异常</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e te</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                   <span class="string">" rejected from "</span> +</span><br><span class="line">                   e.toString());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>AbortPolicy 策略是线程池默认的拒绝策略，在任务不能再提交到线程池时抛出异常，能够及时反馈程序的运行状态。对于比较核心的业务推荐使用此拒绝策略，因为当系统不能承载更大的并发流量时，业务方能够及时地通过异常发现。</p>
<h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 由提交任务的线程自己来执行任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 只要线程池没有被关闭，就由提交任务的线程自己来执行这个任务。</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 线程池没有关闭</span></span><br><span class="line">          <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">              <span class="comment">// 方法级别调用</span></span><br><span class="line">              r.run();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>CallerRunsPolicy 策略是由提交任务的线程处理任务，此策略适合让所有任务都执行完毕。</p>
<h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 直接忽略任务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 直接忽略</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>DiscardPolicy 策略会直接丢弃任务，并且不会抛出异常。此策略会导致业务方无法发现异常，不建议核心业务采用此策略。</p>
<h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将阻塞队列头的任务扔掉，然后将当前任务提交到线程池尝试执行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将队列都任务移除，并将当前任务提交到线程池</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">               e.getQueue().poll();</span><br><span class="line">               e.execute(r);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>DiscardOldestPolicy 策略会丢弃队列最前面的任务，然后重新提交被拒绝的任务。这种策略存在丢失任务的风险。</p>
<p>自定义拒绝策略只需要实现 RejectedExecutionHandler 接口，重写 rejectedExecution 方法即可。如果不自定义拒绝策略，线程池将使用默认的拒绝策略。</p>
<h1 id="Worker线程管理"><a href="#Worker线程管理" class="headerlink" title="Worker线程管理"></a>Worker线程管理</h1><p>前文在介绍任务执行机制的时候涉及到 Worker线程，线程池维护的线程模块其实就是一组 <strong>Worker对象</strong> ，下面我们就来看看 ThreadPoolExecutor 的内部类 Worker 。</p>
<h2 id="Worker线程"><a href="#Worker线程" class="headerlink" title="Worker线程"></a>Worker线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker持有的线程，即任务执行的真正线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程提交任务到线程池，任务就会存放到这里。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存放当前线程完成的任务数。注意和 completedTaskCount 的区别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker 唯一的构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask 任务，可能为 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 设置状态值为 -1，防止在启动线程之前，线程就被中断。因为AQS中默认的 state 为 0，Worker中实现的 tryAcquire 方法内存值就是 0，修改值为 1</span></span><br><span class="line">        setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 使用工厂创建线程，注意创建出来的线程的任务体就是 Worker 本身。这意味着当线程启动时，Worker#run方法就会执行</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker 实现了 Runnable 接口，重写了run() 方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里调用了外部类的 runWorker 方法</span></span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------- Worker继承了AQS类，下面的核心方法是重写了AQS的方法，使用独占锁获得执行权，不支持锁的重入 -----------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 独占式获取资源。AQS 中默认的 state 为 0。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * unlock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池在创建线程时，会将线程封装成工作线程Worker，目的是<strong>管理线程的状态并维护线程的生命周期</strong>。</p>
<p><strong>工作线程Worker 比较特别，下面对其关键点进行说明：</strong></p>
<ul>
<li>继承了 AQS ，实现了一套独占锁机制。<blockquote>
<p>1.Worker 并没有直接使用可重入锁 ReentrantLock ，而是通过继承 AQS 实现了不可重入的独占锁，目的就是通过不可重入的特性判断 Worker 中封装线程的执行状态。<br>2.在线程执行任务期间会加 Worker非重入锁，表示当前线程正在执行任务中，并不是处于空闲状态，不应该中断该线程。<br>3.如果线程不是独占锁的状态则表明该线程处于空闲状态，可以对该线程进行中断</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li><p>实现了 Runnable 接口，它是一个任务体并重写的 run 方法，该方法是线程池执行任务的关键。</p>
<blockquote>
<p>在创建 Worker 成功后，紧接着就会启动 Worker 封装的真实 Thread ，启动成功后 Worker 中的 run 方法就会执行。</p>
</blockquote>
</li>
<li><p>内部封装了实际执行任务的线程。 </p>
<blockquote>
<p>内部封装的线程是线程池的工厂创建出来的，它的使命就是执行 Worker 中的 run 方法中的任务。那业务任务谁来执行？ 同样地，也是该线程执行，只不过它使用的是方法级别的调用。</p>
</blockquote>
</li>
<li><p>内部封装了初始化任务体</p>
<blockquote>
<p>Worker 使用 firstTask 保存传入的第一个任务，该任务允许为null。如果该任务非空，那么线程就会在启动后优先执行这个任务，一般对应于核心线程的创建；如果该任务为空，对应于非核心线程的创建，用于去执行任务队列中的任务。</p>
</blockquote>
</li>
<li><p>线程复用</p>
<blockquote>
<p>一个 Worker 对应线程池中的一个线程，线程复用的逻辑实现是在 Worker 类中的 run 方法中执行 runWorker 方法。由上面的第 2、3 两个说明，很容易得出，当 Worker 中的线程启动后会执行 Worker 这个任务体的 run 方法，进而该线程就会执行 runWorker 方法，然后进入到 while 自旋，实现线程的复用。</p>
</blockquote>
</li>
<li><p>线程回收</p>
<blockquote>
<p>线程池管理着线程的生命周期，需要对长时间空闲的线程、启动失败的线程以及执行任务出现异常的线程进行回收。线程池使用了HashSet这个Hash表去持有Worker的引用，这样可以通过添加引用和移除引用的操作来控制线程的生命周期。</p>
</blockquote>
</li>
</ol>
<p>前文对线程池的任务执行机制进行了介绍，下图是 <strong>Worker</strong> 执行任务的模型：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-process-simple.jpg" alt></p>
<h2 id="新增线程"><a href="#新增线程" class="headerlink" title="新增线程"></a>新增线程</h2><p>如果说 <strong>execute</strong> 方法逻辑体现了提交任务到线程池的流程，那么 <strong>addWorker</strong> 方法则体现了线程池执行任务的开端，即接收任务、创建线程、启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//-------------------------------  1 创建线程前的检测工作 -------------------------------------/</span></span><br><span class="line">     <span class="comment">// for 跳出标志</span></span><br><span class="line">     retry:</span><br><span class="line">     <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//------------------------- 1.1 创建线程前，对线程池状态和队列进行检查，判断是否还可以创建线程 ----------------------/</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取线程池状态码</span></span><br><span class="line">         <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取线程池状态</span></span><br><span class="line">         <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * 如果线程池状态范围是：[SHUTDOWN，TERMINATED]，出现下列任一种情况都不允许创建Worker:</span></span><br><span class="line"><span class="comment">          * 1 firstTask != null</span></span><br><span class="line"><span class="comment">          * 2 workQueue 为空</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          *小结：</span></span><br><span class="line"><span class="comment">          * 1 线程池处于 SHUTDOWN 状态时，不允许提交任务，但是已经存在的任务需要继续执行。</span></span><br><span class="line"><span class="comment">          *  1.1 当 firstTask == null 时且阻塞队列不为空，说明非提交任务创建线程，执行阻塞队列中的任务，允许创建 Worker</span></span><br><span class="line"><span class="comment">          *  1.2 当 firstTask == null 但阻塞队列为空，不能创建 Worker</span></span><br><span class="line"><span class="comment">          *  1.3 当 firstTask ！= null 时，不能创建</span></span><br><span class="line"><span class="comment">          * 2 线程池状态大于 SHUTDOWN 状态时，不允许提交任务，且中断正在执行的任务。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                 !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">//---------------------------- 2 创建线程前，对线程池中线程数检查，判断是否还可以创建线程 ---------------------/</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">             <span class="comment">// 获取线程池线程数</span></span><br><span class="line">             <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 判断线程池线程数是否达到边界值：1 临界值 2 核心线程数或最大线程数</span></span><br><span class="line">             <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 增加线程池中线程数如果成功，则表示创建 Worker 前的校验工作完成，可以进行创建 Worker 流程了。</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                 <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 增加线程数失败，说明可能其它线程也在尝试创建Worker，就需要回到起点，重新校验。</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">//并发影响，需要重新获取线程池状态码</span></span><br><span class="line">             c = ctl.get();</span><br><span class="line"></span><br><span class="line">             <span class="comment">//线程池状态是否改变，改变了则需要重头校验，否则只需要再次校验线程数即可</span></span><br><span class="line">             <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                 <span class="keyword">continue</span> retry;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//----------------------------------   创建 Worker 流程     ------------------------------------/</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Worker 中的线程是否启动的标志</span></span><br><span class="line">     <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Worker 是否添加到 workers 集合中的标志</span></span><br><span class="line">     <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     Worker w = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 创建 Worker，将任务传入。注意，如果是非提交任务创建Worker的话，firstTask 为null</span></span><br><span class="line">         w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将创建的Worker中的线程临时保存到 t，这个是真正的线程，Worker 只是对线程进行了包装。</span></span><br><span class="line">         <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Worker 中的线程创建成功</span></span><br><span class="line">         <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 加锁，注意这个锁的粒度是全局的。也就是说，当这里获取到锁，线程池不能关闭，因为线程池关闭也需要锁。</span></span><br><span class="line">             <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">             mainLock.lock();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 再次获取线程池状态</span></span><br><span class="line">                 <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 如果线程池是运行状态，或者是关闭状态且传入的任务为null(不接收新任务，但是会继续执行任务队列中的任务)，符合条件。</span></span><br><span class="line">                 <span class="comment">// 此外都不符合条件，线程池不会维护当前创建的Worker线程，该Worker线程由于没有被引用最后会被JVM回收</span></span><br><span class="line">                 <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 提前检查新创建的Worker中的线程是否是启动状态</span></span><br><span class="line">                     <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 将新创建的 Worker 加入到 workers 集合，意味着线程池持有当前 Worker 的引用，当前 Worker 不会被 GC。</span></span><br><span class="line">                     workers.add(w);</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 更新 largestPoolSize 的值，该值用于追踪线程池中出现过的最大线程数量</span></span><br><span class="line">                     <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                     <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                         largestPoolSize = s;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 更新标记值</span></span><br><span class="line">                     workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">// 全局锁释放，注意全局锁释放的时机</span></span><br><span class="line">                 mainLock.unlock();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Worker线程只有添加到Worker集合后才能启动线程</span></span><br><span class="line">             <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                 <span class="comment">// 启动Worker中的线程，这一步的意义重大</span></span><br><span class="line">                 t.start();</span><br><span class="line">                 <span class="comment">// 标记线程启动成功</span></span><br><span class="line">                 workerStarted = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 线程加入线程池失败或启动失败，需要清理工作</span></span><br><span class="line">         <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">             addWorkerFailed(w);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> workerStarted;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>线程池通过上述方法增加线程，该方法仅完成创建线程并使它运行，最后返回是否成功。至于是哪种情况下增加线程，该方法并不关心。下图是新增Worker线程的流程图：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-addworker-process.jpg" alt></p>
<p>还需要强调一点，该方法只是创建并启动线程，线程还没有执行任务。再分析执行任务逻辑之前，先来看看创建 Worker 的异常流程，<code>addWorkerFailed</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得全局锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 从 workers 缓存中移除启动失败的 Worker</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少线程池中线程数，因为在此之前递增了</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试终止线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法名非常直观，就是执行 addWorker 失败的处理方法。该方法主要做了以下工作：</p>
<ol>
<li>从 Worker 缓存集合中移除启动失败的 Worker 便于 GC 。</li>
<li>递减线程池中线程数，在校验是否允许创建 Worker 流程中递增了线程数，这里需要递减。</li>
<li>尝试终止线程池，新增线程失败的原因可能是线程池状态处于[SHUTDOWN,TERMINATED]，这种情况下要尝试更新线程池的状态为终止状态。</li>
</ol>
<h2 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h2><p>Worker 中的线程启动成功后，其 run 方法会调用 <strong>runWorker</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Worker 实现了 Runnable 接口，重写了run() 方法。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里调用了外部类的 runWorker 方法</span></span><br><span class="line">     runWorker(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>runWorker 方法是执行提交任务和阻塞队列中等待任务的核心实现，接下来我们分析它的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 当前线程，即 w 中的线程</span></span><br><span class="line">      Thread wt = Thread.currentThread();</span><br><span class="line">      <span class="comment">// 获取该线程的第一个任务，可能没有。如果有的话，优先执行该任务。</span></span><br><span class="line">      Runnable task = w.firstTask;</span><br><span class="line">      w.firstTask = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将 state 值由由 -1 设置为 0，这样就可以允许中断了 。</span></span><br><span class="line">      w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 循环调用getTask() 方法从任务队列中获取任务并执行</span></span><br><span class="line">          <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; </span><br><span class="line"></span><br><span class="line">              <span class="comment">// 申请Worker非重入锁，标志着自己处于工作状态。</span></span><br><span class="line">              w.lock();</span><br><span class="line"></span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 该if判断保证了：如果线程池正在停止，需要确保当前线程是中断状态，否则要保证当前线程不是中断状态。</span></span><br><span class="line"><span class="comment">               *</span></span><br><span class="line"><span class="comment">               * 出现以下任何一种情况都需要中断线程：</span></span><br><span class="line"><span class="comment">               * 1 如果线程池状态大于等于 STOP，并且当前线程没有被中断</span></span><br><span class="line"><span class="comment">               * 2 如果当前线程被中断了并且线程池状态大于等于 STOP 状态（恢复中断标识）</span></span><br><span class="line"><span class="comment">               * 使用interrupted()方法判断线程是否被中断，该方法会清除中断标志位，既确保了在线程RUNNING或者SHUTDOWN状态时线程是非中断状态的，又支持了线程池是STOP状态下的判断</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                      (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                  <span class="comment">// 中断当前线程，进行中断标志复位</span></span><br><span class="line">                  wt.interrupt();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// ThreadPoolExecutor 的扩展方法</span></span><br><span class="line">                  beforeExecute(wt, task);</span><br><span class="line"></span><br><span class="line">                  Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 执行目标任务,方法级别调用。</span></span><br><span class="line">                      task.run();</span><br><span class="line"></span><br><span class="line">                  &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                      thrown = x;</span><br><span class="line">                      <span class="keyword">throw</span> x;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                      thrown = x;</span><br><span class="line">                      <span class="keyword">throw</span> x;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                      thrown = x;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">// ThreadPoolExecutor 的扩展方法</span></span><br><span class="line">                      afterExecute(task, thrown);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">// 置空 task,为下一个任务做准备</span></span><br><span class="line">                  task = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">// 更新Worker线程完成任务数量</span></span><br><span class="line">                  w.completedTasks++;</span><br><span class="line">                  <span class="comment">// 释放 Worker非重入锁</span></span><br><span class="line">                  w.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// while 循环没有出现异常，completedAbruptly 才会被设置为 false</span></span><br><span class="line">          completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 线程退出 while 循环后需要进行回收，可能情况如下：</span></span><br><span class="line"><span class="comment">           * 1 任务队列中已经没有要执行的任务了</span></span><br><span class="line"><span class="comment">           * 2 任务执行过程出现异常</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          processWorkerExit(w, completedAbruptly);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>线程执行任务的流程如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-runworker-process.jpg" alt></p>
<p>执行任务逻辑已经详细注释，下面对该方法简要分析：</p>
<ol>
<li>线程执行任务有两个途径，通过取 Worker 的 firstTask 或者调用 getTask 方法从任务队列中取出待执行的任务。</li>
<li>线程复用得益于对线程的封装，封装后的线程不再局限于执行当前任务，而是while循环不断地通过getTask()方法获取任务，然后执行任务，从而实现了线程的复用。</li>
<li><strong>线程在执行任务前会先申请对应 Worker 独占锁，标志自己处于工作状态，不应该中断该线程</strong>，这是对线程封装的好处。</li>
<li>当线程池状态大于等于 STOP 状态，要保证当前线程是中断状态，否则要保证当前线程不是中断状态。</li>
<li>线程通过调用任务的 <strong>run</strong> 方法来执行对应的任务，而不是启动线程，这个正是前文特别说明的<strong>方法级别调用</strong>。 </li>
<li>当 Worker 封装的线程退出循环后，执行 <strong>processWorkerExit()</strong> 方法对该线程进行回收。</li>
<li>可以通过重写 beforeExecute() 和 afterExecute() 方法来实现 ThreadPoolExecutor 的扩展功能。</li>
</ol>
<h3 id="再谈线程复用"><a href="#再谈线程复用" class="headerlink" title="再谈线程复用"></a>再谈线程复用</h3><p>线程池会使用一定数量的线程去执行任务，通常线程数量远小于任务数量，针对这种情况线程池通过线程复用的方式让同一个线程去执行不同的任务。我们知道线程池是将线程和任务解耦，摆脱了一个任务必须一个线程的限制，这也是线程复用的必要条件。线程池使用<strong>Worker</strong>对线程的封装，也就是<strong>Worker线程</strong>，线程启动后会去执行一个<strong>循环任务</strong>，该任务可以执行线程的<strong>首个任务</strong>和<strong>轮询任务队列中的任务</strong>，线程通过调用任务的 <strong><code>run</code></strong> 方法实现任务的执行。</p>
<p>线程复用的逻辑主要在 runWorker 方法中，该方法是 Worker 类的 run 方法中的逻辑，Worker 中封装的线程启动后会执行 Worker 的 run 方法进而执行 runWorker 方法。整个逻辑简化后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">runWorker(Worker w) &#123;</span><br><span class="line">    <span class="comment">// 线程首个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    <span class="comment">// 轮询任务队列中的任务</span></span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程执行任务的 run 方法，即方法级别的调用</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h2><p>线程池中线程的销毁依赖JVM自动回收，Worker 线程结束任务或异常退出后，Worker 会主动清除自身在线程池中的引用，这意味着线程池可以回收该线程了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 线程执行任务抛出了异常</span></span><br><span class="line">       <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">           <span class="comment">// 减少线程池中线程数量</span></span><br><span class="line">           decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取全局锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">       mainLock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 累计线程池完成的任务数量</span></span><br><span class="line">           completedTaskCount += w.completedTasks;</span><br><span class="line">           <span class="comment">// 将线程引用移出线程池</span></span><br><span class="line">           workers.remove(w);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 释放全局锁</span></span><br><span class="line">           mainLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 尝试终止线程池</span></span><br><span class="line">       tryTerminate();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果线程池状态小于 STOP 状态，说明还可以处理任务</span></span><br><span class="line">       <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 1. 当前线程处理任务没有出现异常</span></span><br><span class="line">           <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">               <span class="comment">// 获取核心线程数，如果设置了允许回收核心线程数，则返回 0，否则取核心线程数</span></span><br><span class="line">               <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 1.1 如果 allowCoreThreadTimeOut=true，并且任务队列中有任务，至少保留一个worker线程</span></span><br><span class="line">               <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                   min = <span class="number">1</span>;</span><br><span class="line">              </span><br><span class="line">               <span class="comment">// 1.2 如果 allowCoreThreadTimeOut=false，线程池中线程数不能少于 corePoolSize</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// 线程池中线程数大于等于 min ，说明无需创建线程。</span></span><br><span class="line">               <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                   <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 执行到这里的可能情况：</span></span><br><span class="line">           <span class="comment">// 1 线程池中没有线程执行任务队列中的任务，需要创建线程取执行。（核心线程数设置为 0 或 允许回收核心线程）</span></span><br><span class="line">           <span class="comment">// 2 线程池中线程数小于核心线程数，需要创建线程补充核心线程数。（核心线程数 &gt; 0）</span></span><br><span class="line">           <span class="comment">// 3 当前线程执行任务过程出现异常，而且当前线程被回收了，为了确保有线程执行任务，这里需要创建线程。</span></span><br><span class="line">           addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>线程回收流程如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-exit.jpg" alt></p>
<p>需要注意的是，线程销毁工作不是只有 <code>processWorkerExit</code> 方法才能完成，前文介绍的新增Worker线程逻辑中对异常流处理的 <code>addWorkerFailed</code> 方法也可以做到。这两者销毁线程的时机不同，前者是线程执行任务的逻辑中销毁，后者是创建线程后启动失败的处理。</p>
<p>上述 <code>processWorkerExit</code> 方法在将Worker线程移除线程池后也就完成了线程的回收工作，但由于执行该方法的原因很多，线程正常退出<code>getTask</code>方法或者执行任务异常都会执行该方法，因此在该方法中需要额外完成两个工作。一是使线程池自适应当前状态，另一个是根据需要创建线程。</p>
<p>至此，<code>processWorkerExit</code> 执行完之后Worker线程被销毁，该线程的整个生命周期结束。下面对整个过程使用流程图的形式进行总结，流程图如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-process.jpg" alt></p>
<h1 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h1><p>调用线程池的 <code>shutdown</code> 或 <code>shutdownNow</code> 方法来关闭线程池，两者的原理有点差异，下面我们分别说明这两个方法。</p>
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 全局锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">     mainLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         checkShutdownAccess();</span><br><span class="line">         <span class="comment">// 设置线程池状态为 SHUTDOWN</span></span><br><span class="line">         advanceRunState(SHUTDOWN);</span><br><span class="line">         <span class="comment">// 尝试中断线程池所有中闲置的线程</span></span><br><span class="line">         interruptIdleWorkers();</span><br><span class="line">         <span class="comment">// hook</span></span><br><span class="line">         onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         mainLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 尝试终止线程池</span></span><br><span class="line">     tryTerminate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>shutdown() 方法可以安全地关闭一个线程池，体现在下面几个方面：</strong></p>
<ol>
<li>只是将线程池的状态置为 SHUTDOWN ，这意味着线程池不能接收新的任务，再有新的任务被提交则根据拒绝策略进行处理。</li>
<li>会执行完正在执行的任务和队列中等待的任务，任务全部结束后才会彻底关闭线程池。</li>
<li>尝试中断线程池中所有闲置的线程。</li>
<li>调用tryTerminate尝试终止线程池，用于将线程池的状态更新为 TERMINATED 。</li>
</ol>
<h2 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     List&lt;Runnable&gt; tasks;</span><br><span class="line">     <span class="comment">// 全局锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">     mainLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         checkShutdownAccess();</span><br><span class="line">         <span class="comment">// 设置线程池状态为 STOP</span></span><br><span class="line">         advanceRunState(STOP);</span><br><span class="line">         <span class="comment">// 尝试中断线程池中所有启动状态的线程</span></span><br><span class="line">         interruptWorkers();</span><br><span class="line">         <span class="comment">// 将阻塞队列中正在等待的所有任务进行备份，然后清空阻塞队列并返回备份。有了这个备份，可以根据需要做补救措施。</span></span><br><span class="line">         tasks = drainQueue();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         mainLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 尝试终止线程池</span></span><br><span class="line">     tryTerminate();</span><br><span class="line">     <span class="keyword">return</span> tasks;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>shutdownNow() 方法表示立即关闭线程池，工作如下：</p>
<ol>
<li>将线程池状态置为 STOP 状态。</li>
<li>中断所有Worker线程，包括空闲和非空闲。</li>
<li>清空阻塞队列并返回等待执行的任务备份。</li>
<li>调用tryTerminate尝试终止线程池，用于将线程池的状态更新为 TERMINATED 。</li>
</ol>
<h2 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate()"></a>tryTerminate()</h2><p>对于 <strong>tryTerminate()</strong> 方法的调用，前文中的<strong>新增线程失败逻辑、线程退出while逻辑以及两种关闭线程池的方法</strong>都会调用了该方法，下面我们来看看这个方法的具体逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 线程池状态码</span></span><br><span class="line">          <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 以下几种情况不能终止线程池，直接返回（STOP 状态可不会直接返回）</span></span><br><span class="line">           <span class="comment">//1. 线程池是运行状态 RUNNING</span></span><br><span class="line">           <span class="comment">//2. 大于等于 TIDYING 状态，此时线程池中已经没有正在运行的线程了</span></span><br><span class="line">           <span class="comment">//3. SHUTDOWN 状态且阻塞队列非空，这种情况需要执行完任务队列中的任务</span></span><br><span class="line">          <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 执行到这里，说明已经具备终止线程池的条件，只差线程回收了。</span></span><br><span class="line">          <span class="comment">// 线程池中线程数量不为 0，向任意空闲线程发出中断信号，所有被阻塞的线程（执行poll/take）最终都会被一个个唤醒，回收。</span></span><br><span class="line">          <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">              <span class="comment">// 这里既不是中断所有线程，也不是中断所有空闲线程，而是中断任意一个空闲线程，原因如下：</span></span><br><span class="line">              <span class="comment">// 1. tryTerminate() 方法多处被调用，需要中断线程逻辑在上层已经进行了处理，如 shutdown 方法调用时会中断所有空闲线程</span></span><br><span class="line">              <span class="comment">// 2. interruptIdleWorkers(ONLY_ONE) 方法用在 tryTerminate() 方法中主要为了唤醒 getTask()方法中存在执行workQueue.take()等待的线程，防止一直等待造成线程无法回收。</span></span><br><span class="line">              <span class="comment">//    即使有多个线程阻塞等待，唤醒任意一个也足够了，被唤醒的线程在退出while循环后会再次调用tryTerminate()方法，继续中断阻塞等待线程。此外线程退出后进入到processWorkerExit()方法中</span></span><br><span class="line">              <span class="comment">//    会要申请全局锁的，如果全部唤醒会出现竞争锁的情况。</span></span><br><span class="line">              interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 全局锁</span></span><br><span class="line">          <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 终止线程池时加全局锁，保证CAS执行成功，即线程池状态依次更新为 TIDYING 和 TERMINATED 。</span></span><br><span class="line">          <span class="comment">// 这里可能发生并发问题，如两个线程都通过了 workerCountOf(c) != 0 条件，执行到这里就需要加锁。</span></span><br><span class="line">          mainLock.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 设置线程池状态码为 TIDYING</span></span><br><span class="line">              <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// 状态设置成功后执行 terminated() 钩子方法</span></span><br><span class="line">                      terminated();</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 设置线程池状态码为 TERMINATED 终止状态</span></span><br><span class="line">                      ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                      termination.signalAll();</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              mainLock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// else retry on failed CAS</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>tryTerminate() 方法主要根据线程池状态判断是否终止线程池，下面进行简单总结：</strong></p>
<ol>
<li>判断线程池是否可以终止，原则是线程池处于关闭状态、队列中没有任务的情况下可以终止。</li>
<li>interruptIdleWorkers()方法的执行表示线程池具备终止条件，向任意空闲线程发送中断信号<strong>防止 <code>getTask</code> 方法中存在核心线程执行 <code>workQueue.take()</code>时一直阻塞，导致线程无法回收</strong>。</li>
<li>符合终止线程池的条件时，先获取全局锁，然后先将线程池状态置为 TIDYING 状态，设置成功后会执行 terminated() 钩子方法，最后将线程池状态设置为 TERMINATED 状态，完成线程池状态更新后释放全局锁。</li>
</ol>
<p>下面我们来简单分析一下<code>interruptIdleWorkers</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断所有闲置的Worker</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyOne 是否仅中断一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">// 全局锁，涉及到 workers 操作线程池都会加该锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历 workers ，对每个非中断线程进行中断操作。</span></span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                <span class="comment">// 如果线程非中断状态，且能 tryLock() 成功，说明该线程闲置，需要进行中断</span></span><br><span class="line">                <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>前文也进行了说明，Worker 继承了AQS，在Worker线程处理任务时会申请Worker独占锁，<code>interruptIdleWorkers</code> 在进行中断时会使用 <strong>tryLock()</strong> 来判断该Worker线程是否正在处理任务，如果 <strong>tryLock()</strong> 返回true，说明该Worker线程处于空闲状态，可以被中断。</p>
<p><strong>注意事项：</strong></p>
<ol>
<li>线程池中多处执行 <code>tryTerminate</code> 方法的目的是将符合条件的线程池终止，前文也提到线程池的状态是内部自行维护的，并非人为设置。如用户执行 <code>shutdown</code> 和 <code>shutdownNow</code> 方法只是将线程池的状态设置为 <strong>SHUTDOWN</strong> 和 <strong>STOP</strong> ，后续的 <strong>TIDYING</strong> 和 <strong>TERMINATED</strong> 状态的设置就在于此。</li>
<li><code>tryTerminate</code> 方法中的 <code>interruptIdleWorkers(ONLY_ONE)</code> 的作用是防止线程池在终止的过程中 <code>getTask</code> 方法中存在执行 <code>workQueue.take()</code> 阻塞的线程，因为此时线程池不允许再有新的任务添加到阻塞队列中，这样一来线程将一直阻塞下去，线程池永远都终止不了。</li>
</ol>
<p>线程池中虽然多处使用中断来期望中断任务的执行，但由于 <strong>Java 中不推荐强行停止线程的机制的限制，因为强制的让一个线程被动的退出是很不安全的，内部的数据不一致会对程序造成不可预知的后果</strong>。即使调用了 shutdownNow 方法，如果被中断的线程对于中断信号不敏感，那么依然有可能导致任务不会停止。</p>
<h1 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h1><p>线程池太大或太小都会导致麻烦，选择一个合适的线程池是非常有必要的。调整线程池中的数量是为了充分并合理地使用 CPU 和内存资源，从而最大限度地提高程序性能。通常我们需要根据任务执行的性质来选择对应的策略。</p>
<h2 id="CPU-密集型任务"><a href="#CPU-密集型任务" class="headerlink" title="CPU 密集型任务"></a>CPU 密集型任务</h2><p>如果任务主要进行大量复杂的计算，例如加密、解密、压缩等，那么意味着 CPU 的处理能力是稀缺的资源，应当分配较少的线程，通常按照 CPU 核数 或者 CPU 核数 + 1 进行设置。 计算任务会占用大量的 CPU 资源，CPU 的每个核工作基本都是高负荷的，如果设置过多的线程，每个线程都会尝试抢占 CPU 资源，这就造成了不必要的上下文切换（CPU并没有太多空闲），性能反而由于线程数量过多导致性能下降。</p>
<h2 id="IO-密集型任务"><a href="#IO-密集型任务" class="headerlink" title="IO 密集型任务"></a>IO 密集型任务</h2><p>I/O 操作比较多的任务，如数据库操作、文件读写、网络通信等，一般不会消耗太多 CPU 资源，但是普遍需要较长时间的等待，对于这类任务可以配置适当多的线程，如 CPU 核数 * 2 。由于 IO 读写速度相比于 CPU 的速度是比较慢的，设置过少的线程数是不能充分利用 CPU 资源。</p>
<h2 id="合适线程数"><a href="#合适线程数" class="headerlink" title="合适线程数"></a>合适线程数</h2><p>Brain Goetz 推荐的计算方法如下：</p>
<blockquote>
<p>线程数 = CPU核数 × 目标CPU利用率 ×（1 + 平均等待时间/平均工作时间）</p>
</blockquote>
<p>通过上面的公式可以大致计算出一个合理的线程数（核心线程数和最大线程数统称）。如果任务平均等待时间长则线程数就应该多，对应于 IO 密集型任务。如果平均工作时间长则线程数就应该少，对应于 CPU 密集型任务。</p>
<p>线程数太少可能会使得程序整体性能降低，线程数太多可能会消耗内存资源以及造成不必要的上下文切换。想用准确定制线程池需要做的工作很多，除了考虑线程数还可以合理使用线程池的阻塞队列实现任务的调度，还可以根据业务等纬度实现线程池隔离。</p>
<h1 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h1><p>线程池提供了一些用于获取属性的方法，这些属性可以用来对线程池进行监控。</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-monitor-method.jpg" alt></p>
<p>线程池还提供了一些用于设置核心属性的方法，使用方可以通过这些方法动态设置线程池的核心策略，线程池内部会处理好当前状态并做到平滑修改。</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-dynamic-method.jpg" alt></p>
<h2 id="动态设置核心线程数"><a href="#动态设置核心线程数" class="headerlink" title="动态设置核心线程数"></a>动态设置核心线程数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="comment">// 计算核心线程数变化值</span></span><br><span class="line">        <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆盖原来的corePoolSize</span></span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池的线程数大于变更的核心线程数，说明有多余的worker线程，此时会向空闲的worker线程发起中断请求以实现回收</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 核心线程数大于原来值，尝试增加核心线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取 任务数和 delta 两者的最小值</span></span><br><span class="line">            <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 预先创建足够多的新Worker以达到核心线程数，并处理队列中的任务。队列空了则停止</span></span><br><span class="line">            <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (workQueue.isEmpty())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态设置最大线程数"><a href="#动态设置最大线程数" class="headerlink" title="动态设置最大线程数"></a>动态设置最大线程数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆盖原来的 maximumPoolSize</span></span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是设置小了的话，此时会向空闲的worker线程发起中断请求以实现回收</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态设置空闲时间"><a href="#动态设置空闲时间" class="headerlink" title="动态设置空闲时间"></a>动态设置空闲时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeepAliveTime</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (time == <span class="number">0</span> &amp;&amp; allowsCoreThreadTimeOut())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line">        <span class="comment">// 计算超时时间</span></span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = unit.toNanos(time);</span><br><span class="line">        <span class="comment">// 计算差值</span></span><br><span class="line">        <span class="keyword">long</span> delta = keepAliveTime - <span class="keyword">this</span>.keepAliveTime;</span><br><span class="line">        <span class="comment">// 覆盖原来的 keepAliveTime</span></span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">        <span class="comment">// 如果时间设置比原来小，则向空闲的worker线程发起中断请求以实现回收</span></span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="允许核心线程超时回收"><a href="#允许核心线程超时回收" class="headerlink" title="允许核心线程超时回收"></a>允许核心线程超时回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 核心线程必须要有保活时间</span></span><br><span class="line">        <span class="keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class="line">            allowCoreThreadTimeOut = value;</span><br><span class="line">            <span class="comment">// 允许回收则立即中断空闲线程</span></span><br><span class="line">            <span class="keyword">if</span> (value)</span><br><span class="line">                interruptIdleWorkers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对线程池核心点进行了详细分析，先是简单介绍了线程池产生的背景，接着说明了线程池的优势，最后对线程池源码进行了分析。从任务提交到线程池，到线程池创建线程并处理任务，到最后线程被回收，最后简单介绍了线程池的配置以及线程池的监控。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/d7cef21d/" title="并发 - 线程池" target="_blank" rel="external">https://gentryhuang.com/posts/d7cef21d/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/9e3a7d05/" title="并发 - 线程池工具类"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/37f29896/" title="并发 - Java并发工具类"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2021 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>