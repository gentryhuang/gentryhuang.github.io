<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>并发 - ThreadLocal | gentryhuang的博客</title>
  <meta name="description" content="概述ThreadLocal 提供了线程局部变量，它是将线程需要访问的数据存储在线程对象自身中，从而避免多线程的数据竞争问题。ThreadLocal 实现原理如下图所示： 理解 ThreadLocal 原理，其实就是理解 Thread、ThreadLocal 以及 ThreadLocalMap 三者之间的关系。线程类 Thread 内部持有 ThreadLocalMap 的成员变量，而 Thread">
<meta property="og:type" content="article">
<meta property="og:title" content="并发 - ThreadLocal">
<meta property="og:url" content="https://gentryhuang.com/posts/151f44ae/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="概述ThreadLocal 提供了线程局部变量，它是将线程需要访问的数据存储在线程对象自身中，从而避免多线程的数据竞争问题。ThreadLocal 实现原理如下图所示： 理解 ThreadLocal 原理，其实就是理解 Thread、ThreadLocal 以及 ThreadLocalMap 三者之间的关系。线程类 Thread 内部持有 ThreadLocalMap 的成员变量，而 Thread">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-struct.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-uml.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-map-struct.jpg">
<meta property="article:published_time" content="2021-08-21T04:30:12.000Z">
<meta property="article:modified_time" content="2021-08-31T04:32:54.548Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="Thread">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-struct.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/151f44ae/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.38px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.75px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.13px;">I/O</a> <a href="/tags/JUC/" style="font-size: 13.5px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.25px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.13px;">Lock</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.25px;">Protocol</a> <a href="/tags/RPC/" style="font-size: 13.63px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.13px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.25px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.25px;">Spring</a> <a href="/tags/Thread/" style="font-size: 13px;">Thread</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.88px;">设计模式</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/151f44ae/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/151f44ae/" class="title">并发 - ThreadLocal</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-21T04:30:12.000Z" itemprop="datePublished">2021-08-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/55ae5a2b/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/55ae5a2b/" class="title">Java基础 - Reference</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-14T02:30:12.000Z" itemprop="datePublished">2021-08-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/1d01ceec/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a>
              </p>
              <p class="item-title">
                <a href="/posts/1d01ceec/" class="title">时间轮算法 - HashedWheelTimer</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-24T02:06:24.000Z" itemprop="datePublished">2021-07-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/f3292e6c/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/f3292e6c/" class="title">并发 - ReentrantReadWriteLock</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-10T12:46:36.000Z" itemprop="datePublished">2021-07-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/19fe4bc5/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/19fe4bc5/" class="title">Redis原理 - Redis主流程</a>
              </p>
              <p class="item-date">
                <time datetime="2021-06-24T06:59:01.000Z" itemprop="datePublished">2021-06-24</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码分析"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread"><span class="toc-number">2.1.</span> <span class="toc-text">Thread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">2.2.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">2.2.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-方法"><span class="toc-number">2.2.2.</span> <span class="toc-text">Set 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Get-方法"><span class="toc-number">2.2.3.</span> <span class="toc-text">Get 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#setInitialValue-方法"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">setInitialValue 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Remove-方法"><span class="toc-number">2.2.4.</span> <span class="toc-text">Remove 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createMap-方法"><span class="toc-number">2.2.5.</span> <span class="toc-text">createMap 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getMap-方法"><span class="toc-number">2.2.6.</span> <span class="toc-text">getMap 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocalMap"><span class="toc-number">2.3.</span> <span class="toc-text">ThreadLocalMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储结构"><span class="toc-number">2.3.2.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法"><span class="toc-number">2.3.3.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getEntry-方法"><span class="toc-number">2.3.4.</span> <span class="toc-text">getEntry 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-方法"><span class="toc-number">2.3.5.</span> <span class="toc-text">set 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#replaceStaleEntry-方法"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">replaceStaleEntry 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rehash-操作"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">rehash 操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove-方法"><span class="toc-number">2.3.6.</span> <span class="toc-text">remove 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#expungeStaleEntry-方法"><span class="toc-number">2.3.7.</span> <span class="toc-text">expungeStaleEntry 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#expungeStaleEntries-方法"><span class="toc-number">2.3.8.</span> <span class="toc-text">expungeStaleEntries 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cleanSomeSlots-方法"><span class="toc-number">2.3.9.</span> <span class="toc-text">cleanSomeSlots 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#共享数据"><span class="toc-number">2.4.</span> <span class="toc-text">共享数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用示例"><span class="toc-number">2.4.1.</span> <span class="toc-text">使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现原理"><span class="toc-number">2.4.2.</span> <span class="toc-text">实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InheritableThreadLocal"><span class="toc-number">2.5.</span> <span class="toc-text">InheritableThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#问题"><span class="toc-number">3.</span> <span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存泄漏"><span class="toc-number">3.1.</span> <span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么使用弱引用"><span class="toc-number">3.2.</span> <span class="toc-text">为什么使用弱引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最佳实践"><span class="toc-number">3.3.</span> <span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#应用场景"><span class="toc-number">4.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-concurrent/ThreadLocal" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      并发 - ThreadLocal
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/151f44ae/" class="article-date">
	  <time datetime="2021-08-21T04:30:12.000Z" itemprop="datePublished">2021-08-21</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/JDK/">JDK</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Thread/" rel="tag">Thread</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/151f44ae/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 7.7k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 31(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ThreadLocal 提供了线程局部变量，它是将线程需要访问的数据存储在线程对象自身中，从而避免多线程的数据竞争问题。ThreadLocal 实现原理如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-struct.png" alt></p>
<p>理解 ThreadLocal 原理，其实就是理解 <strong>Thread</strong>、<strong>ThreadLocal</strong> 以及 <strong>ThreadLocalMap</strong> 三者之间的关系。线程类 Thread 内部持有 ThreadLocalMap 的成员变量，而 ThreadLocalMap 是 ThreadLocal 的内部类，ThreadLocal 对外暴露操作数据的 API 都是操作 ThreadLocalMap 中的数据。<strong>总得来说，线程 Thread 在向 ThreadLocal 中设置值时，其实都是向自己所持有的 ThreadLocalMap 中设置数据；读的时候同理，先是从线程自身中取出持有的 ThreadLocalMap ，然后再根据 ThreadLocal 引用作为 key 取出对应的元素 Entry 进而取出 value</strong>。因此 ThreadLocal 可以轻松实现变量的线程隔离，毕竟变量都是维护在各个线程中的，自然没有竞争。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>根据前文中的 ThreadLocal 实现原理图可以发现 ThreadLocal 是 Thread 使用的一个工具，下面我们剥离出 Thread 中相关 ThreadLocal 信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 与此线程相关的 ThreadLocal 值，这个映射由 ThreadLocal 类维护 */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 与此线程相关的 InheritableThreadLocal 值。这个映射由 InheritableThreadLocal 类维护。*/</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread 中维护了两个 ThreadLocalMap 类型的变量，<strong><code>threadLocals</code> 用于存储当前线程使用的 ThreadLocal 相关信息；<code>inheritableThreadLocals</code> 用于存储当前线程使用的 InheritableThreadLocal 相关信息。使用 InheritableThreadLocal 可以实现多个线程访问 ThreadLocal 的值，即父线程中创建一个 InheritableThreadLocal 的实例，然后在子线程中就可以得到这个 InheritableThreadLocal 中设置的值</strong>。关于共享线程的 ThreadLocal 数据将在下面的内容中分析。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><strong>ThreadLocal 相关的 UML 类图如下所示：</strong></p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-uml.jpg" alt></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1 作为 ThreadLocal 实例的变量，私有、不可变。每当创建 ThreadLocal 时这个值都会累加 HASH_INCREMENT</span></span><br><span class="line"><span class="comment">    * 2 主要为了多个 ThreadLocal 实例的情况下，让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二进制：-10011110001101110111100110111001</span></span><br><span class="line"><span class="comment">    * 十进制：-2654435769</span></span><br><span class="line"><span class="comment">    * 说明：</span></span><br><span class="line"><span class="comment">    * 1 Entry[] table 的大小必须是 2^N，那 2^N-1 的二进制表示就是低位连续的N个1，</span></span><br><span class="line"><span class="comment">    * 2 key.threadLocalHashCode &amp; (len-1) 的值就是 threadLocalHashCode 的低 N 位，这里使用位运算实现取模，和 HashMap 计算下标类似</span></span><br><span class="line"><span class="comment">    * 3 要求 threadLocalHashCode 的值要均匀，这里给出 0x61c88647 就能达到。</span></span><br><span class="line"><span class="comment">    * 原因：</span></span><br><span class="line"><span class="comment">    * 取该值与fibonacci hashing(斐波那契散列法)以及黄金分割有关，目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是Entry[] table中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 作为 ThreadLocal 类变量</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 基于当前 ThreadLocal ，下一个要给出的哈希码，自动更新，从 0 开始计数。</span></span><br><span class="line"><span class="comment">    * 每次获取当前值并加上固定的 HASH_INCREMENT</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回下一个 ThreadLocal 的 hash</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal 关键属性分为两类。一类是 ThreadLocal 实例变量，另一类是 ThreadLocal 类变量。其中类变量在 ThreadLocal 类加载过程就进行初始化，也就是 <code>nextHashCode</code> 的初始化，后续实例变量 <code>threadLocalHashCode</code> 随着对象的创建而调用 <code>nextHashCode</code> 方法进行赋值，可以看出每次递增为 <strong>HASH_INCREMENT</strong> ，至于为什么选择这个值，是和斐波那契散列法以及黄金分割有关，目的就是为了让哈希码能均匀的分布在 2^n 次方的数组里，这个和 HashMap 中 hash 实现目的是一致的。</p>
<p>了解了核心属性后，下面以几个方法做为入口分析 ThreadLocal 源码。</p>
<h3 id="Set-方法"><a href="#Set-方法" class="headerlink" title="Set 方法"></a>Set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置当前线程变量的值 value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据当前线程获取其成员变量 threadLocals 所指向的 ThreadLocalMap 对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 判断当前线程的 ThreadLocalMap 是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 3.1 如果不为空，说明当前线程内部已经有ThreadLocalMap对象了</span></span><br><span class="line">            <span class="comment">// 那么直接将当前对应的 ThreadLocal 对象的引用作为键，存入的 value 作为值存储到 ThreadLocalMap 中</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 3.2 创建一个 ThreadLocalMap 对象并将值存入到该对象中，并赋值给当前线程的threadLocals成员变量</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>ThreadLocal 中的增、删、查方法基本都会有三个步骤。下面对 Set 方法进行小结:</strong></p>
<blockquote>
<ol>
<li>获取当前线程</li>
<li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li>
<li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 set 方法放入数据，映射表不存在则先创建映射表再放入数据</li>
</ol>
</blockquote>
<h3 id="Get-方法"><a href="#Get-方法" class="headerlink" title="Get 方法"></a>Get 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程的线程副本变量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据当前线程获取其 ThreadLocalMap 实例</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果当前线程的 ThreadLocalMap 不为空</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T) e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果当前线程的 ThreadLocalMap 为空或 ThreadLocalMap 中没有当前 ThreadLocal 对应的元素，则调用 initialValue() 方法初始化值</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面对 Get 方法进行小结:</strong></p>
<blockquote>
<ol>
<li>获取当前线程</li>
<li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li>
<li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 getEntry 方法查询数据；映射表不存在或从映射表中没有找到当前 ThreadLocal 对应的元素，则调用 setInitialValue 方法完成映射表的创建或初始值的获取</li>
</ol>
</blockquote>
<p>Get 方法相比 Set 方法会涉及查询不到元素的情况，如果当前线程持有的映射表还没有或者找不到元素，那么 ThreadLocal 会尝试以初始化值的方式进行兜底处理，初始值的情况通过方法 <code>initialValue()</code> 交给具体实现。</p>
<h4 id="setInitialValue-方法"><a href="#setInitialValue-方法" class="headerlink" title="setInitialValue 方法"></a>setInitialValue 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置初始化值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 调用 initialValue() 方法获取指定的初始化值，默认为 null</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取当前线程的 ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果 ThreadLocalMap 不为空，则直接将初始值设置到 ThreadLocalMap 中</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 如果 ThreadLocalMap 为空，则创建 ThreadLocalMap 对象，并设置初始值</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化值，子类覆盖</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Remove-方法"><a href="#Remove-方法" class="headerlink" title="Remove 方法"></a>Remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程持有的 ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 删除 ThreadLocalMap 中当前 ThreadLocal 相关的信息</span></span><br><span class="line">        <span class="comment">// 包括清理对应的引用和值</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面对 Remove 方法进行小结:</strong></p>
<blockquote>
<ol>
<li>获取当前线程</li>
<li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li>
<li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 remove 方法根据当前 ThreadLocal 清理对应数据，可以防止内存泄漏</li>
</ol>
</blockquote>
<h3 id="createMap-方法"><a href="#createMap-方法" class="headerlink" title="createMap 方法"></a>createMap 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为线程 t 初始化 ThreadLocalMap 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t          当前线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>线程中的 ThreadLocalMap 使用的是延迟初始化，即第一次调用 get() 或者 set() 方法的时候才会进行初始化。</p>
<h3 id="getMap-方法"><a href="#getMap-方法" class="headerlink" title="getMap 方法"></a>getMap 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">// 返回线程 t 的 threadLocals</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述方法用于获取每个线程持有自身的 ThreadLocalMap 实例，因此它们是不存在并发竞争的，这就是我们说的每个线程都有自己的变量副本。</p>
<p>至此，ThreadLocal 相关属性以及暴露的方法已经分析完毕。可以看出，ThreadLocal 中并没有持有 ThreadLocalMap 的引用，该引用是在 Thread 类中。此外，ThreadLocal 暴露的 API 操作都是基于 ThreadLocalMap 的。因此，我们理解了 ThreadLocalMap 才算是掌握了 ThreadLocal 。下面我们重点对 ThreadLocalMap 进行分析。</p>
<h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，本质上是一个 Map ，和 HashMap 类似，依然是 key-value 的形式，具体由 Entry 结构封装。</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-map-struct.jpg" alt></p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储数据的 Entry 数组，长度是 2 的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中元素的个数，初始值为 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组扩容阈值，默认为0，创建了 ThreadLocalMap 对象后会被重新设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置调整大小阈值，以保持在最坏 2/3 的负载因子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ThreadLocalMap使用 开放地址法-线性探测法 来解决哈希冲突 */</span></span><br><span class="line"><span class="comment">// 向后一个位置找，注意从头开始的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向前一个位置找，注意跳到尾部的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体属性类似 HashMap ，各个值的含义已经详细注释就不再说明。需要注意的是，由于 ThreadLocalMap 使用的是线性探测法解决 hash 冲突，因此定义向前和向后探测的方法以便于寻找合适的位置及定位元素。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 与传入 ThreadLocal 关联的值，也就是线程局部变量值</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Entry的 key 是对 ThreadLocal 的弱引用，当抛弃掉 ThreadLocal 对象时，垃圾收集器会忽略这个 key 的引用而清理掉 ThreadLocal 对象。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>一个线程可以使用多个 ThreadLocal 将不同的值存储到当前线程的 ThreadLocalMap 中。熟悉 HashMap 存储结构的可以发现，ThreadLocalMap 中的存储结构有两大不同点：</p>
<ul>
<li>没有链表相关的指针，更没有树节点的左右链接</li>
<li>元素节点结构 Entry 继承了 <code>WeakReference</code> 类，以实现弱引用功能</li>
</ul>
<p>作为一个映射表，必然会有元素冲突的可能，虽然和 HashMap 结构类似，但是没有 HashMap 中链表和树形结构，那么 ThreadLocalMap 是怎么解决 hash 冲突的呢？答案是<strong>线性探测法</strong>。关于 Entry 继承 <code>WeakReference</code> 的原因我们在后面的文章中进行分析。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstKey   ThreadLocal 引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue 设置的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">// 1 初始化 Entry 数组，大小为 16</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取 ThreadLocal 的 hash 值(该值是累加的)</span></span><br><span class="line">        <span class="comment">// 计算当前 key 对应的数组下标位置， 和 HashMap 的位运算代替取模原理一样</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 将 Entry 对象存入到数组指定的位置</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 记录数组元素个数</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 初始化扩容阈值</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当线程 Thread 持有的 ThreadLocalMap 还没有初始化时，在使用 ThreadLocal 存储或获取数据时都会先创建一个 ThreadLocalMap 对象然后挂载到当前线程 Thread 上，后续不管该线程使用了多少个 ThreadLocal ，都会使用创建的 ThreadLocalMap 进行储存相应值，有冲突就使用<strong>线性探测法</strong>解决。</p>
<p>了解了 ThreadLocalMap 的底层数据结构后，下面我们依然从它的核心操作方法出发分析底层实现。</p>
<h3 id="getEntry-方法"><a href="#getEntry-方法" class="headerlink" title="getEntry 方法"></a>getEntry 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取与 key 关联的 Entry</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 根据 key 计算下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 根据下标获取 Entry</span></span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 通过下标直接得到的 Entry 不是要找的，那么就线性探测找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>获取线程局部变量值的 getEntry 方法是 ThreadLocal 暴露的 get() 方法的底层实现，它的主要流程如下：</p>
<ul>
<li>根据 ThreadLocal 引用计算对应的数组下标，这个和 HashMap 类似</li>
<li>根据计算得到的下标尝试直接获取对应的 Entry，如果当前 Entry 为空或对应的 key 不是当前传入的 key ，那么进行线性探测获取</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * getEntry方法的版本，用于在键未在其直接散列槽中找到时使用。</span></span><br><span class="line"><span class="comment">         * 注意，该方法会清理无效 Entry</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i   the table index for key's hash code</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e   the entry at table[i]</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 线性探测</span></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取 Entry 的 key</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.1 命中，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="comment">// 2.2 无效 Entry，执行连续段删除</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3 获取下个位置</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3 遍历完也没查到，返回 null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>之所以要进行线性探测获取其实是和链表查询一样，可能目标元素由于 hash 冲突放到了后续位置。<strong>注意：查询流程也就是 get() 方法可能也会清理无效的元素，以防止内存泄漏，但不能保证</strong>。关于连续段清理无效元素逻辑暂略过。</p>
<h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置与 key 关联的值</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * ThreadLocal 的 set 方法，就是为了将指定的值存入到指定线程的 ThreadLocalMap 对象中，具体还是通过 ThreadLocalMap 的 set 方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key   the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 获取数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 计算当前 ThreadLocal 对象引用作为键在数组中的下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 根据获取到的下标进行线性探测，寻找空的位置。</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 中的 key ，即 ThreadLocal 的引用，注意是弱引用。</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 判断和当前的 ThreadLocal 对象是否是同一个对象，如果是，那么直接进行值替换，并结束方法，</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.3 判断当前 Entry 是否失效，即是否被回收（弱引用），如果失效，说明当前位置可以重新使用，就使用新的 key-value 将其替换</span></span><br><span class="line">                <span class="comment">// 该过程还会进行连续段删除其它无效的 entry</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 找到某个空位置，直接将键值对设置到该位置上。</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 尝试随机清理无效 entry ，如果没有可清理的 entry 且数组元素大小 &gt;= 扩容阈值，则进行 rehash</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置线程局部变量值的 set 方法稍微复杂点，下面对其主要流程进行说明：</strong></p>
<blockquote>
<ol>
<li>根据传入的 key 计算数组下标位置</li>
<li>根据计算得到的下标进行线性探测，寻找空的位置以存放元素<ul>
<li>检测到存在相同 key 的元素，进行值覆盖，然后结束流程即可</li>
<li>检测到无效的元素，则重用无效元素位置，并尝试清理无效的元素</li>
<li>在某个空位置存放数据</li>
</ul>
</li>
<li>如果不是值覆盖或重用无效元素位置的情况，那么需要判断是否需要 rehash  </li>
</ol>
</blockquote>
<p>下面我们对上述关联的核心方法进行拆解分析。</p>
<h4 id="replaceStaleEntry-方法"><a href="#replaceStaleEntry-方法" class="headerlink" title="replaceStaleEntry 方法"></a>replaceStaleEntry 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 替换无效 Entry ，并尝试删除其它无效的 Entry。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> staleSlot 无效 entry 的位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标志 Table 中是否存在无效 Entry。slotToExpunge != staleSlot 说明 table 中存在无效 Entry 需要进行清理，否则说明没有。</span></span><br><span class="line">            <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 根据传入的无效 Entry 的位置 staleSlot 向前扫描一段连续非空的 Entry ，并记录最后一个无效的 Entry 的位置。或者扫描完也没有找到。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = prevIndex(i, len))</span><br><span class="line">                <span class="comment">// 2.1 如果是无效 Entry ，则更新删除标记 slotToExpunge</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 根据传入的无效 Entry 向后扫描一段连续的 Entry（根据线性探测，具有相同的 key 的元素一定是从后找的） ,以寻找是否有相同 key 的 Entry，以及在需要时更新删除标记位 slotToExpunge</span></span><br><span class="line">            <span class="comment">// 找到相同 key 的元素或末尾的空槽，以最先出现的为准</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 的 key</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 如果找到了具有相同的 key ，则更新其值。也就是更新其值并将其与传入的无效 Entry 替换，即与 table[staleSlot] 进行替换</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    <span class="comment">// 3.2.1 更新为传入的 value</span></span><br><span class="line">                    e.value = value;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.2.2 使用相同 key 的 Entry 重用失效位置以避免新创建一个 Entry，以维持散列表的顺序。</span></span><br><span class="line">                    tab[i] = tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.2.3 如果向前查找没有找到无效的 Entry，则更新删除标记位 slotToExpunge 为当前位置 i，此时 i 位置对应的是无效 Entry</span></span><br><span class="line">                    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                        slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.3.4 将新过时的槽或在其上面遇到的任何其他过时槽发送到expungeStaleEntry，以删除或重新散列运行中的所有其他条目。</span></span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果向前查找没有找到无效 entry，并且当前向后扫描的entry无效，则更新 slotToExpunge 为当前值 i</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 执行到这里，说明 table 中不存在相同 key 的 Entry，此时只需直接重用无效位置即可</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 slotToExpunge != staleSlot 说明 table 中存在无效 Entry 需要进行清理</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>重用无效 Entry 位置有两种可能：</strong></p>
<ul>
<li>如果扫描到的 Table 中存在和要插入的 key 相同的 Entry，那么就使用更新 value 后的该 Entry 替换无效 Entry 以避免新创建 Entry，同时该 Entry 成为了无效 Entry，只需等待后续删除即可。</li>
<li>如果扫描到的 Table 中不存在和要插入的 key 相同的 Entry ，那么直接创建 Entry 替换无效 Entry 即可。</li>
</ul>
<p>此外，上述方法还会对无效 Entry 进行清理，触发条件就是检测到其它无效 Entry 的存在。</p>
<h4 id="rehash-操作"><a href="#rehash-操作" class="headerlink" title="rehash 操作"></a>rehash 操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * rehash 操作</span></span><br><span class="line"><span class="comment">         * 1 扫描整个 Table ，删除无效的 Entry</span></span><br><span class="line"><span class="comment">         * 2 执行清理后，如果还需要扩容，则将表扩大一倍</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 清理所有无效 Entry</span></span><br><span class="line">            expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  2 threshold - threshold / 4 = 1en / 2，降低扩容阈值是因为上面做了一次全清理 size 可能会减小</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Table 容量扩大为原来 2 倍</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] oldTab = table;</span><br><span class="line">            <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 容量扩大为原来 2 倍</span></span><br><span class="line">            <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">            Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 重新映射旧数组中的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">                Entry e = oldTab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 清理无效 Entry</span></span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 线性探测重新设置值</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, newLen);</span><br><span class="line">                        newTab[h] = e;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 设置新的阈值</span></span><br><span class="line">            setThreshold(newLen);</span><br><span class="line">            size = count;</span><br><span class="line">            table = newTab;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>新增数据后，如果达到阈值就会触发 rehash 流程，进行<strong>数组扩容和数据重新映射</strong>，这个没什么可说的。</p>
<h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 计算 key 对应的下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 进行线性探测，查找正确的 Entry</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到对应的 Entry</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    <span class="comment">// 调用 WeakReference.clear() 方法清除对应的引用</span></span><br><span class="line">                    e.clear();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 连续段删除 Entry</span></span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>上述方法是 ThreadLocal 暴露的 remove() 方法的底层实现，用来清理当前 ThreadLocal 关联的信息。具体清理信息如下：</p>
<ul>
<li>清除对当前 ThreadLocal 的弱引用</li>
<li>清除当前 ThreadLcoal 对应的 Entry 中的 value </li>
<li>清除当前 ThreadLocal 对应的 Entry </li>
</ul>
<h3 id="expungeStaleEntry-方法"><a href="#expungeStaleEntry-方法" class="headerlink" title="expungeStaleEntry 方法"></a>expungeStaleEntry 方法</h3><p>expungeStaleEntry 方法用于彻底删除指定位置的 Entry 所以信息，接着向后连续段扫描删除无效 Entry ，并对可能存在 hash 冲突的 Entry 进行 rehash 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除过期的元素，是连续段方式的删除</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 清理 staleSlot 位置的无效 Entry ，并递减元素个数</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 从 stateSlot 开始向后扫描一段连续的非空的 Entry</span></span><br><span class="line">            <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 的 k</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 如果遇到key为null,表示无效entry，进行清理.</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// value 置空</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 元素置空</span></span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 元素个数递减</span></span><br><span class="line">                    size--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.3 如果 key 不为 null ，则对可能存在 hash 冲突的 Entry 进行 rehash</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 计算 key 对应的下标，如果与现在所在位置不一致，认为存在 hash 冲突，置空当前 table[i] ，</span></span><br><span class="line">                    <span class="comment">// 并从 h 开始向后线性探测到第一个空的 slot，把当前的 entry 移动过去。</span></span><br><span class="line">                    <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                        tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                        <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                        <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        tab[h] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下一个为空的下标</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>上述方法用于删除过期的元素，具体删除策略如下：</p>
<ul>
<li>根据传入的 stateSlot 清理对应的无效 Entry，这个是绝对删除。</li>
<li>根据传入的 stateSlot 向后扫描一段连续非空的 Entry ，对可能存在 hash 冲突的 Entry 进行 rehash ，并且清理遇到的无效 Entry 。</li>
</ul>
<h3 id="expungeStaleEntries-方法"><a href="#expungeStaleEntries-方法" class="headerlink" title="expungeStaleEntries 方法"></a>expungeStaleEntries 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描整个 Table ，删除无效的 Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="comment">// 无效 Entry ，则调用 expungeStaleEntry 方法删除对应位置及连坐删除 Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是在 expungeStaleEntry 方法的基础上，对整个 Table 中无效元素进行清理，一定会清理截止到当前 Table 中所有的无效 Entry 。需要说明的是，ThreadLocal 的所有一些列操作都是单线程的，也就是当前线程。</p>
<h3 id="cleanSomeSlots-方法"><a href="#cleanSomeSlots-方法" class="headerlink" title="cleanSomeSlots 方法"></a>cleanSomeSlots 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 启发式的扫描清除，扫描次数由传入的参数n决定</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i 从i向后开始扫描（不包括i，因为索引为i的Slot肯定为null）</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> n  控制扫描次数，正常情况下为 log2(n) ，如果找到了无效 Entry ，会将 n 重置为 table 的长度 len 进行阶段删除</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> true if any stale entries have been removed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 删除标志</span></span><br><span class="line">            <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 i 位置向后遍历，删除无效的 Entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">                Entry e = tab[i];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前 Entry 无效，则进行清理并进行连坐</span></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    n = len;</span><br><span class="line">                    removed = <span class="keyword">true</span>;</span><br><span class="line">                    i = expungeStaleEntry(i);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 无符号的右移动，可以用于控制扫描次数在log2(n)</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> removed;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>启发式扫描删除具有随机性，启发式思想也用在其他代码中，如 Redis 中的定期删除逻辑。</p>
<p>自此，ThreadLocalMap 的源码实现分析完毕。</p>
<h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><p>一般来说 ThreadLocal 数据都是线程独享的，但是 ThreadLocal 继承体系支持子线程共享父线程的变量副本数据。共享线程的 ThreadLocal 数据可以使用 <strong>InheritableThreadLocal</strong> 来实现。通过在父线程中创建一个 <strong>InheritableThreadLocal</strong> 的实例，然后在子线程中就可以获取该实例中设置的值。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 创建 InheritableThreadLocal 对象</span></span><br><span class="line">    ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 创建的 ThreadLocalMap 挂载到当前 Thread 的 inheritableThreadLocals 属性</span></span><br><span class="line">    threadLocal.set(<span class="string">"小芒果!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 创建并启动子线程</span></span><br><span class="line">    Runnable runnable = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 打印子线程 ThreadLocal 的线程变量值</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt; "</span> + threadLocal.get());</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印父线程（这里是主线程） ThreadLocal 的线程变量值</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt; "</span> + threadLocal.get());</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>打印结果</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main-&gt; 小芒果!</span><br><span class="line">Thread-0-&gt; 小芒果!</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>线程变量传递逻辑很简单，它隐藏在 Thread 的 init 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- Thread</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 获取初始化当前线程的线程</span></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果 parent 线程使用了 InheritableThreadLocal ，那么就把 parent 的 inheritableThreadLocals 给当前线程的 inheritableThreadLocals 。</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 设置到当前线程的 inheritableThreadLocals 属性中</span></span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从线程初始化逻辑中可以看出，如果父线程 ThreadLocalMap 类型的变量 <code>inheritableThreadLocals</code> 不为空，那么就把父线程的该属性设置给当前线程的 <code>inheritableThreadLocals</code> 属性。具体设置逻辑在 ThreadLocal 的 createInheritedMap 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">// 继承式创建 ThreadLocal</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅由 createInheritedMap 方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocal.ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取 parentMap 的 Table 信息</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建新的 Table</span></span><br><span class="line">        table = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 将 parentMap 中的数据依次映射到新创建的 Table 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 3.1 获取当前 Entry</span></span><br><span class="line">            ThreadLocal.ThreadLocalMap.Entry e = parentTable[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 获取 Entry 中的 key</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.3 Entry 有效的话就进行映射</span></span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 用于获取父线程变量值的转换，默认就是父线程 Entry.value 值</span></span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 线性探测存储元素</span></span><br><span class="line">                    ThreadLocal.ThreadLocalMap.Entry c = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line">                    <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line"></span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过以上逻辑可以发现，如果要使用线程变量共享需要使用到 <strong>InheritableThreadLocal</strong> 类，线程 Thread 的映射属性使用 <code>inheritableThreadLocals</code> 而非 <code>threadLocals</code> 。</p>
<h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认是 Entry 的 value 值，使用方可继承 InheritableThreadLocal 覆盖该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentValue the parent thread's value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the child thread's initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程 t 的 ThreadLocalMap ，注意取的是 inheritableThreadLocals 属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建当前线程 t 的 ThreadLocalMap ，注意设置的是 inheritableThreadLocals 属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InheritableThreadLocal 继承了 ThreadLocal ，重写了以上三个方法，主要是将映射表挂在到 Thread 的 <code>inheritableThreadLocals</code> 属性上，用以实现线程变量的共享。注意，线程变量独享使用的是 Thread 中的 <code>threadLocals</code> 属性。InheritableThreadLocal 对比 ThreadLocal 唯一不同是子线程会继承父线程变量，并支持自定义赋值函数。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>ThreadLocalMap 使用 ThreadLocal 的弱引用做为元素 Entry 的 key ,如果一个 ThreadLocal 没有外部强引用来引用它，那么系统 GC 时这个 ThreadLocal 会被回收。此时，ThreadLocalMap 中就会出现 key 为 null 的 Entry ，这样就没有办法访问这些 Entry，这些 Entry 理论上属于无效的，应该被 GC 回收。但是，如果存在持有这些 Entry 的线程迟迟不结束（如使用线程池），那么这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链 <strong>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</strong>，导致无法回收，造成内存泄漏。</p>
<p>ThreadLocal 为了尽可能避免内存泄漏问题，在 <code>get()</code>、<code>set()</code> 以及 <code>remove()</code> 方法中都有清除线程的 ThreadLocalMap 中 key 为 null 的 value 逻辑。<strong>注意，其中 get()、set() 两个方法都不能完全防止内存泄漏，存在无效 Entry 无法扫描到的情况，因为只有在线性探测流程中才会尝试连续段清理无效 Entry 。最好的方式是每次使用完 ThreadLocal 都手动 remove 一下</strong>。</p>
<p>此外，以下措施会增加内存泄漏的风险：</p>
<ul>
<li>使用 static 的 ThreadLocal ，这种方式延长了 ThreadLocal 的生命周期</li>
<li>分配使用了 ThreadLocal ，而不再调用其 <code>get()</code>、<code>set()</code> 以及 <code>remove()</code> 方法</li>
</ul>
<h2 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h2><ul>
<li><strong>key 使用强引用：</strong>ThreadLocal 对象没有外部引用，但是 ThreadLocalMap 持有 ThreadLocal 的强引用，如果没有手动删除，ThreadLocal 不会被回收，这会导致 Entry 内存泄漏。</li>
<li><strong>key 使用弱引用：</strong>ThreadLocal 对象没有外部引用，由于 ThreadLocalMap 持有 ThreadLocal 的弱引用，即使没有手动删除，ThreadLcoal 也可以被回收。value 在下一次执行方法时被清除。 </li>
</ul>
<p>Entry 继承 WeakReference，并且使用 ThreadLocal 的弱引用作为 key，这样可以将 ThreadLocal 对象的生命周期和线程生命周期解绑。持有弱引用可以使得 ThreadLocal 在没有其他强引用的时候被回收掉，这样可以避免因为线程得不到销毁导致 ThreadLocal 对象无法被回收。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>每次使用完 ThreadLocal 都应该调用它的 remove() 方法，进行数据清理，防止内存泄漏。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul>
<li>多线程之间需要拥有同一个信息，那么通常可以采用 <code>initialValue()</code> 方法进行初始化，直接将需要拥有的变量副本存储到 ThreadLocal 中。</li>
<li>多个线程中存储不同的信息，那么需要使用 set() 方法设置变量副本到 ThreadLocal 中。</li>
</ul>
<p>上述描述<strong>存储到 ThreadLocal 中</strong>是不对的，需要注意，数据其实是存储到线程持有的 ThreadLocalMap 对象中，该对象是一个散列表。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 ThreadLocal 进行了深入的分析，它能保证数据安全是因为每个线程都有自己的线程变量，不会发生多个线程共享变量的情况。首先对 ThreadLocal 的关系进行了介绍，从总体上认识 ThreadLocal 。接着对 ThreadLocal 进行了分析，从其属性到暴露的 API 。然后对 ThreadLocal 底层的支持类 ThreadLocalMap 进行了分析，同样从属性到支撑上层的方法的分析。最后对父子线程就 ThreadLocal 如何共享线程变量进行了分析。在文章的最后，对内存泄漏问题进行了介绍。</p>
<p><strong>参考资料</strong><br><a href="https://www.cnblogs.com/lqlqlq/p/13302901.html" target="_blank" rel="noopener">https://www.cnblogs.com/lqlqlq/p/13302901.html</a></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/151f44ae/" title="并发 - ThreadLocal" target="_blank" rel="external">https://gentryhuang.com/posts/151f44ae/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    
    <li class="next">
      <a href="/posts/55ae5a2b/" title="Java基础 - Reference"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2021 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>