<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>集群容错 - Directory | gentryhuang的博客</title>
  <meta name="description" content="概述本篇文章对 Dubbo 集群模块中的 Directory 服务目录进行介绍。服务目录 RegistryDirectory 中存储了一些和服务提供者有关的信息（附加服务治理参数），通过服务目录消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。服务目录本质上是对注册中心上服务配置信息的整合结果，最终会结合配置信息以及消费端信息组装消费端的 Invoker 。服务目录可以看做是 Invo">
<meta property="og:type" content="article">
<meta property="og:title" content="集群容错 - Directory">
<meta property="og:url" content="https://gentryhuang.com/posts/e43ac0a6/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="概述本篇文章对 Dubbo 集群模块中的 Directory 服务目录进行介绍。服务目录 RegistryDirectory 中存储了一些和服务提供者有关的信息（附加服务治理参数），通过服务目录消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。服务目录本质上是对注册中心上服务配置信息的整合结果，最终会结合配置信息以及消费端信息组装消费端的 Invoker 。服务目录可以看做是 Invo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-directory-uml.jpg">
<meta property="article:published_time" content="2020-09-18T03:00:00.000Z">
<meta property="article:modified_time" content="2021-11-28T09:21:04.413Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="Dubbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-directory-uml.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/e43ac0a6/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.5px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.75px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.13px;">I/O</a> <a href="/tags/JMM/" style="font-size: 13px;">JMM</a> <a href="/tags/JUC/" style="font-size: 13.75px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.25px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.13px;">Lock</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.25px;">Protocol</a> <a href="/tags/Queue/" style="font-size: 13.38px;">Queue</a> <a href="/tags/RPC/" style="font-size: 13.63px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13.38px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.13px;">Redis数据结构</a> <a href="/tags/SCAN/" style="font-size: 13px;">SCAN</a> <a href="/tags/SPI/" style="font-size: 13.25px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.25px;">Spring</a> <a href="/tags/Thread/" style="font-size: 13.13px;">Thread</a> <a href="/tags/Zookeeper/" style="font-size: 13.13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 13px;">分布式锁</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.88px;">设计模式</a> <a href="/tags/%E9%99%90%E6%B5%81/" style="font-size: 13px;">限流</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/9012be3f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/9012be3f/" class="title">并发 - ScheduledThreadPoolExecutor</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-02T01:55:06.000Z" itemprop="datePublished">2022-05-02</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/a16a077e/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/a16a077e/" class="title">并发 - FutureTask</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-22T02:07:06.000Z" itemprop="datePublished">2022-04-22</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/3c450cc6/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/posts/3c450cc6/" class="title">MySQL - 乐观锁和悲观锁</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-10T02:46:59.000Z" itemprop="datePublished">2022-04-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/c1861d8c/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/c1861d8c/" class="title">Redis原理 - SCAN 原理</a>
              </p>
              <p class="item-date">
                <time datetime="2022-03-12T14:14:47.000Z" itemprop="datePublished">2022-03-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/e0c3e79e/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/posts/e0c3e79e/" class="title">MySQL - Double Write</a>
              </p>
              <p class="item-date">
                <time datetime="2022-03-09T08:25:44.000Z" itemprop="datePublished">2022-03-09</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#继承体系"><span class="toc-number">2.</span> <span class="toc-text">继承体系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码分析"><span class="toc-number">3.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Directory"><span class="toc-number">3.1.</span> <span class="toc-text">Directory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AbstractDirectory"><span class="toc-number">3.2.</span> <span class="toc-text">AbstractDirectory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">3.2.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拉取-Invoker-集合"><span class="toc-number">3.2.2.</span> <span class="toc-text">拉取 Invoker 集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StaticDirectory"><span class="toc-number">3.3.</span> <span class="toc-text">StaticDirectory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RegistryDirectory"><span class="toc-number">3.4.</span> <span class="toc-text">RegistryDirectory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法"><span class="toc-number">3.4.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InvokerDelegate"><span class="toc-number">3.4.3.</span> <span class="toc-text">InvokerDelegate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拉取-Invoker"><span class="toc-number">3.4.4.</span> <span class="toc-text">拉取 Invoker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#订阅"><span class="toc-number">3.4.5.</span> <span class="toc-text">订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通知"><span class="toc-number">3.4.6.</span> <span class="toc-text">通知</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#转换-Configurator"><span class="toc-number">3.4.6.1.</span> <span class="toc-text">转换 Configurator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#转换-Router"><span class="toc-number">3.4.6.2.</span> <span class="toc-text">转换 Router</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#刷新-Invoker-列表"><span class="toc-number">3.4.6.3.</span> <span class="toc-text">刷新 Invoker 列表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#转换-Invoker"><span class="toc-number">3.4.6.3.1.</span> <span class="toc-text">转换 Invoker</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法名-gt-Invoker列表"><span class="toc-number">3.4.6.3.2.</span> <span class="toc-text">方法名-&gt;Invoker列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#多分组聚合"><span class="toc-number">3.4.6.3.3.</span> <span class="toc-text">多分组聚合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#销毁无用-Invoker"><span class="toc-number">3.4.6.3.4.</span> <span class="toc-text">销毁无用 Invoker</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-rpc/集群容错之Directory" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      集群容错 - Directory
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/e43ac0a6/" class="article-date">
	  <time datetime="2020-09-18T03:00:00.000Z" itemprop="datePublished">2020-09-18</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/RPC/">RPC</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Dubbo/" rel="tag">Dubbo</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/e43ac0a6/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 11.4k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 50(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇文章对 Dubbo 集群模块中的 <code>Directory</code> 服务目录进行介绍。服务目录 <code>RegistryDirectory</code> 中存储了一些和服务提供者有关的信息（附加服务治理参数），通过服务目录消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。服务目录本质上是对注册中心上服务配置信息的整合结果，最终会结合配置信息以及消费端信息组装消费端的 <code>Invoker</code> 。服务目录可以看做是 Invoker 的集合，且这个集合中的元素会随注册中心的变化而进行动态调整。 </p>
<h1 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h1><p>服务目录 <code>Directory</code> 继承关系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-directory-uml.jpg" alt></p>
<p>服务目录内置实现分别为 <code>StaticDirectory</code> 和 <code>RegistryDirectory</code> ，前者用于将传入的 <code>Invoker</code> 集合封装成静态的 <code>Directory</code> 对象，后者是基于注册中心的动态 <code>Directory</code> 对象。下面我们从源码层面上分析服务目录的实现。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Directory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得服务接口类型，如：com.alibaba.dubbo.demo.DemoService</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> service type.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的 Invocation 请求返回符合条件的 Invoker 集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> invokers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Directory</code> 接口表示的是一个服务目录，由多个 <code>Invoker</code> 构成，后续的 <code>路由处理</code>、<code>负载均衡</code>、<code>集群容错</code>等都是基于 <code>Directory</code> 实现的。<strong>需要注意的是，一个服务目录 Directory 仅对应一个服务类型，管理的是该类型的多个服务。</strong> 该接口包含了一个重要的方法定义，即 list(Invocation)，用于列举 Invoker。下面我们对它的抽象实现进行说明。</p>
<h2 id="AbstractDirectory"><a href="#AbstractDirectory" class="headerlink" title="AbstractDirectory"></a>AbstractDirectory</h2><p><code>AbstractDirectory</code> 是 <code>Directory</code> 接口的抽象实现，其中除了维护消费端的 URL 信息，还维护了路由信息。此外，封装了获取 Invoker 列表的流程，具体的逻辑由子类实现。下面我们先来看该抽象实现源码。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Directory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractDirectory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经销毁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroyed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者订阅 URL</span></span><br><span class="line"><span class="comment">     * 注意：如果没有显示调用用构造方法，那么该属性的值为 url的值。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.registry.integration.RegistryDirectory#subscribe(com.alibaba.dubbo.common.URL) 会设置该值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> URL consumerUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;Router&gt; routers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(url, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url, List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(url, url, routers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url, URL consumerUrl, List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置url</span></span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="comment">// 设置consumerUrl</span></span><br><span class="line">        <span class="keyword">this</span>.consumerUrl = consumerUrl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置路由数组</span></span><br><span class="line">        setRouters(routers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法中会维护传入的 <strong>注册中心 URL</strong>、<strong>消费端 URL</strong> 以及 <strong>设置路由列表</strong>。在处理路由时，除了保存传入的路由外，如果配置了路由也会将其加入到路由集合中，下面我们看下其实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractDirectory</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setRouters</span><span class="params">(List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 保存传入的路由集合</span></span><br><span class="line">        routers = routers == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;Router&gt;() : <span class="keyword">new</span> ArrayList&lt;Router&gt;(routers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 从URL中取出配置的路由</span></span><br><span class="line">        String routerkey = url.getParameter(Constants.ROUTER_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果配置了路由，则获取对应的路由实现，并加入到 routers集合 中</span></span><br><span class="line">        <span class="keyword">if</span> (routerkey != <span class="keyword">null</span> &amp;&amp; routerkey.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">routerkey</span>)</span>;</span><br><span class="line">            routers.add(routerFactory.getRouter(url));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 统一添加 MockInvokersSelector 路由</span></span><br><span class="line">        routers.add(<span class="keyword">new</span> MockInvokersSelector());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 排序</span></span><br><span class="line">        Collections.sort(routers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 放入缓存</span></span><br><span class="line">        <span class="keyword">this</span>.routers = routers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建服务目录时，会同时维护路由，维护的路由由三部分组成，<strong>外部传入的Router</strong> + <strong>配置的Router</strong> + <strong>MockInvokersSelector</strong> 。关于路由的介绍会在后面的文章中单独说明，这里不再展开。</p>
<p><strong>注意：</strong>MockInvokersSelector 路由是为了过滤 MockProtocol 协议下的 MockInvoker 。</p>
<h3 id="拉取-Invoker-集合"><a href="#拉取-Invoker-集合" class="headerlink" title="拉取 Invoker 集合"></a>拉取 Invoker 集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractDirectory</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 1 服务目录销毁了就直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Directory already destroyed .url: "</span> + getUrl());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 调用 doList 方法获取 Invokers 集合，具体实现交给子类</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用路由</span></span><br><span class="line">        List&lt;Router&gt; localRouters = <span class="keyword">this</span>.routers;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用路由规则筛选Invoker集合</span></span><br><span class="line">        <span class="keyword">if</span> (localRouters != <span class="keyword">null</span> &amp;&amp; !localRouters.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Router router : localRouters) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 根据路由的URL值以及 runtime 参数，决定是否进行路由</span></span><br><span class="line"><span class="comment">                     * 注意：</span></span><br><span class="line"><span class="comment">                     *  Router的runtime参数决定是否每次调用服务时都执行路由规则。如果 runtime配置为true，每次调用服务前都需要进行服务路由，这个会对性能会造成影响。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (router.getUrl() == <span class="keyword">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 使用路由筛选 Invoker</span></span><br><span class="line">                        invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Failed to execute router: "</span> + getUrl() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 返回路由后的结果</span></span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractDirectory</code> 拉取 Invoker 列表的主要逻辑如下：</p>
<ol>
<li>调用子类实现的 doList 方法获取 Invoker 列表。</li>
<li>使用路由，根据 Router 的 getUrl 返回值是否为空，以及 runtime 参数决定是否进行路由过滤。</li>
</ol>
<p>需要说明的是，Router 的 <strong>runtime</strong> 参数决定了是否每次调用服务时都要执行路由规则。如果 <strong>runtime</strong> 为 true，那么每次调用服务前，都需要进行服务路由，这个会对性能造成影响。 </p>
<h2 id="StaticDirectory"><a href="#StaticDirectory" class="headerlink" title="StaticDirectory"></a>StaticDirectory</h2><p><code>StaticDirectory</code> 实现中维护的 Invoker 集合是静态的，在 <code>StaticDirectory</code> 对象创建完毕后，是不会发生改变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractDirectory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoker 集合，这个集合中的元素是不变的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, invokers, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, invokers, routers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(URL url, List&lt;Invoker&lt;T&gt;&gt; invokers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(url, invokers, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(URL url, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 确定url有效性</span></span><br><span class="line">        <span class="keyword">super</span>(url == <span class="keyword">null</span> &amp;&amp; invokers != <span class="keyword">null</span> &amp;&amp; !invokers.isEmpty() ? invokers.get(<span class="number">0</span>).getUrl() : url, routers);</span><br><span class="line">        <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invokers == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.invokers = invokers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Invoker对应的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>).getInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测服务目录是否可用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若已经销毁，则不可用</span></span><br><span class="line">        <span class="keyword">if</span> (isDestroyed()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任意一个Invoker 可用，当前服务目录就可用</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (invoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 已销毁，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (isDestroyed()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 销毁</span></span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">        <span class="comment">// 销毁每个 Invoker</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            invoker.destroy();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空Invoker 集合</span></span><br><span class="line">        invokers.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接返回由构造方法传入进来的Invoker 集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RegistryDirectory"><a href="#RegistryDirectory" class="headerlink" title="RegistryDirectory"></a>RegistryDirectory</h2><p><code>RegistryDirectory</code> 是一个动态的 <code>Directory</code> 实现，实现了 <code>NotifyListener</code> 接口，<strong>订阅注册中心的数据，实现监听功能</strong>。当注册中心的服务配置发生变更时，会触发回调 <code>NotifyListener.notify</code> 方法，<code>RegistryDirectory</code> 收到变更通知后会根据注册中心推送的通知，重新引用服务，即 <strong>刷新 Invoker 列表</strong>。该实现类为了让本地服务目录和注册中心的服务信息保持一致做了很多的工作，下文我们一一分析。</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">NotifyListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RegistryDirectory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群扩展实现 Cluster$Adaptive 对象 - 对同组 Invoker 进行合并</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由工厂扩展实现 RouterFactory$Adaptive对象 - 创建路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置规则工厂实现 ConfiguratorFactory$Adaptive 对象 - 创建配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConfiguratorFactory configuratorFactory = ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心URL的服务键， 如：com.alibaba.dubbo.registry.RegistryService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口类型，如：com.alibaba.dubbo.demo.DemoService</span></span><br><span class="line"><span class="comment">     * 每一个服务引用都对应一个服务目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; serviceType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务消费者 URL 的配置项 Map。即 Consumer URL 中 refer 参数解析后得到的全部 KV</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; queryMap;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只保留 Consumer 属性的 URL，也就是由 queryMap 集合重新生成的 URL，URL 主体仍然是注册中心的 URL信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL directoryUrl;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用的服务接口方法数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] serviceMethods;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否引用多个服务分组 - 服务分组概念</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> multiGroup;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心的Protocol 对象，使用方设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Protocol protocol;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心，使用方设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Registry registry;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否禁止访问：</span></span><br><span class="line"><span class="comment">     * 1 当没有服务提供者</span></span><br><span class="line"><span class="comment">     * 2 当服务提供者被禁用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> forbidden = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结合配置规则，重写原始目录URL得到的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> URL overrideDirectoryUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置规则数组</span></span><br><span class="line"><span class="comment">     * override rules</span></span><br><span class="line"><span class="comment">     * Priority: override&gt;-D&gt;consumer&gt;provider</span></span><br><span class="line"><span class="comment">     * Rule one: for a certain provider &lt;ip:port,timeout=100&gt;</span></span><br><span class="line"><span class="comment">     * Rule two: for all providers &lt;* ,timeout=5000&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;Configurator&gt; configurators;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;服务提供者URL合并处理后的URL串,服务引用创建的Invoker&gt;</span></span><br><span class="line"><span class="comment">     * Map&lt;url, Invoker&gt; cache service url to invoker mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Invoker&lt;T&gt;&gt; urlInvokerMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法名与引用Invoker集合的映射</span></span><br><span class="line"><span class="comment">     * Map&lt;methodName, Invoker&gt; cache service method to invokers mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; methodInvokerMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前缓存的所有 Provider 的 URL</span></span><br><span class="line"><span class="comment">     * Set&lt;invokerUrls&gt; cache invokeUrls to invokers mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;URL&gt; cachedInvokerUrls;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，根据注册中心URL初始化相关属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceType 服务接口类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url         注册中心 URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegistryDirectory</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">        <span class="comment">// 如果服务类型为空，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (serviceType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service type is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Url对应的服务键为空，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (url.getServiceKey() == <span class="keyword">null</span> || url.getServiceKey().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"registry serviceKey is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置服务类型 和 注册中心URL的服务键</span></span><br><span class="line">        <span class="keyword">this</span>.serviceType = serviceType;</span><br><span class="line">        <span class="keyword">this</span>.serviceKey = url.getServiceKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置服务消费者 URL 的配置项 Map，即解析 refer 参数值，得到 Consumer 的配置参数 parameters 的值</span></span><br><span class="line">        <span class="keyword">this</span>.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造的时候，this.overrideDirectoryUrl == this.directoryUrl</span></span><br><span class="line">        <span class="comment">// 将 queryMap 中的 KV 作为参数，重新构造 URL，URL主体不变</span></span><br><span class="line">        <span class="keyword">this</span>.overrideDirectoryUrl = <span class="keyword">this</span>.directoryUrl = url.setPath(url.getServiceInterface()).clearParameters().addParameters(queryMap).removeParameter(Constants.MONITOR_KEY);</span><br><span class="line">        <span class="comment">// 从消费者配置项中获取分组参数</span></span><br><span class="line">        String group = directoryUrl.getParameter(Constants.GROUP_KEY, <span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 设置多分组标识</span></span><br><span class="line">        <span class="keyword">this</span>.multiGroup = group != <span class="keyword">null</span> &amp;&amp; (<span class="string">"*"</span>.equals(group) || group.contains(<span class="string">","</span>));</span><br><span class="line">        <span class="comment">// 从消费者配置项中获取服务方法串</span></span><br><span class="line">        String methods = queryMap.get(Constants.METHODS_KEY);</span><br><span class="line">        <span class="comment">// 设置引用服务接口中的方法数组</span></span><br><span class="line">        <span class="keyword">this</span>.serviceMethods = methods == <span class="keyword">null</span> ? <span class="keyword">null</span> : Constants.COMMA_SPLIT_PATTERN.split(methods);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>RegistryDirectory</code> 中的部分属性会根据注册中心URL初始化。下面对较为重要的属性进行说明：</p>
<ol>
<li><strong>this.queryMap:</strong><blockquote>
<p>Consumer 端的 URL 的参数配置项 parameters 的值</p>
</blockquote>
</li>
<li><strong>this.directoryUrl:</strong><blockquote>
<p>传入的注册中心 URL 的主干部分 + Consumer 端的 URL 的 parameters（this.queryMap）</p>
</blockquote>
</li>
<li><strong>this.overrideDirectoryUrl</strong><blockquote>
<p>初始值为 this.directoryUrl，在接收注册中心目录（某个服务接口下的目录，其中一服务接口对应一个服务目录）变更通知时会先结合配置规则 Configurator 重写 this.directoryUrl，然后再将服务端URL合并后的URL参数配置项选择性的合并（提供方的参数配置项优先级最低）。</p>
</blockquote>
</li>
</ol>
<h3 id="InvokerDelegate"><a href="#InvokerDelegate" class="headerlink" title="InvokerDelegate"></a>InvokerDelegate</h3><p><code>InvokerDelegate</code> 是 <code>RegistryDirectory</code> 的内部类，继承了 <code>InvokerWrapper</code> 这个 Invoker 的包装类。这个代理类主要用于存储注册中心下发的服务提供者的URL以及服务引用创建的 Invoker 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerDelegate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InvokerWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 服务提供者URL，注意：这是未经过配置合并的URL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> URL providerUrl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> invoker     Protocol.refer 引用的 Invoker</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> url         合并后的 URL</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> providerUrl 服务提供者URL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InvokerDelegate</span><span class="params">(Invoker&lt;T&gt; invoker, URL url, URL providerUrl)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(invoker, url);</span><br><span class="line">            <span class="keyword">this</span>.providerUrl = providerUrl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> URL <span class="title">getProviderUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> providerUrl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




<h3 id="拉取-Invoker"><a href="#拉取-Invoker" class="headerlink" title="拉取 Invoker"></a>拉取 Invoker</h3><p>拉取 Invoker 逻辑封装在 doList 方法中，是父类 <code>AbstractDirectory</code> 的模版方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 检测forbidden字段，当该字段在 refreshInvoker() 过程中设置为true时，表示无 Provider 可用，直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (forbidden) &#123;</span><br><span class="line">            <span class="comment">// 1. No service provider 2. Service providers are disabled</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.FORBIDDEN_EXCEPTION,</span><br><span class="line">                    <span class="string">"No provider available from registry "</span> + getUrl().getAddress() + <span class="string">" for service "</span> + getConsumerUrl().getServiceKey() + <span class="string">" on consumer "</span> + NetUtils.getLocalHost()</span><br><span class="line">                            + <span class="string">" use dubbo version "</span> + Version.getVersion() + <span class="string">", please check status of providers(disabled, not registered or in blacklist)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取Invoker本地缓存 （服务引用的过程 methodInvokerMap 中的值已经有了，并且该值会随着订阅的服务而变化）</span></span><br><span class="line">        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap = <span class="keyword">this</span>.methodInvokerMap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 从 Invoker 本地缓存信息中选出目标 Invoker 集合</span></span><br><span class="line">        <span class="keyword">if</span> (localMethodInvokerMap != <span class="keyword">null</span> &amp;&amp; localMethodInvokerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获得调用的方法名和方法参数列表</span></span><br><span class="line">            String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">            Object[] args = RpcUtils.getArguments(invocation);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> &amp;&amp; (args[<span class="number">0</span>] <span class="keyword">instanceof</span> String || args[<span class="number">0</span>].getClass().isEnum())) &#123;</span><br><span class="line">                <span class="comment">// 3.1 根据第一个参数和本身的方法名拼接确定最后的方法名，然后获得Invoker集合。</span></span><br><span class="line">                invokers = localMethodInvokerMap.get(methodName + args[<span class="number">0</span>]); <span class="comment">// The routing can be enumerated according to the first parameter</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.2 根据方法名获得 Invoker 集合，一般会成功</span></span><br><span class="line">                invokers = localMethodInvokerMap.get(methodName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.3 通过通配符 * 获取 Invoker 集合，如 回声探测方法</span></span><br><span class="line">                invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//4 使用 methodInvokerMap 第一个Invoker。防御性编程。</span></span><br><span class="line">                Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator = localMethodInvokerMap.values().iterator();</span><br><span class="line">                <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    invokers = iterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 返回目标Invoker集合</span></span><br><span class="line">        <span class="keyword">return</span> invokers == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(<span class="number">0</span>) : invokers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上方法用于从 <code>RegistryDirectory</code> 的 <code>Invoker</code> 缓存中获取本次调用的消费端 Invoker 列表。其中获取的方式有以下 4 种：</p>
<ol>
<li>根据<strong>调用的方法名 + 参数值</strong>确定最终的调用方法名。使用例子如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello01</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费方调用</span></span><br><span class="line">DemoService demoService = (DemoService) context.getBean(<span class="string">"demoService"</span>);</span><br><span class="line"><span class="comment">// 最终调用到的是 DemoService 中的 hello01 方法</span></span><br><span class="line">demoService.hello(<span class="string">"01"</span>);</span><br></pre></td></tr></table></figure></li>
<li>根据调用方法名获取 Invoker 集合。</li>
<li>使用全量 Invoker 集合。</li>
<li>基于防御性编程，使用第一个 Invoker 集合。</li>
</ol>
<p>以上方法可以看作是对 <code>RegistryDirectory</code> 中 Invoker 缓存的读操作，写操作是在收到通知的时候完成的，后续会详细分析。</p>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置服务消费者订阅URL</span></span><br><span class="line">        setConsumerUrl(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向注册中心发起订阅。注意注册了一个监听器，也就是 RegistryDirectory </span></span><br><span class="line">        registry.subscribe(url, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法会在消费端进行订阅时被调用，通过调用 <code>Registry</code> 的 <strong>subscribe</strong> 方法完成订阅，同时还会将当前 <code>RegistryDirectory</code> 以 <code>NotifyListener</code> 监听器形式添加到 <code>Registry</code> 上，这样服务目录 RegistryDirectory 就和注册中心关联了。</p>
<p>消费端订阅触发时机是在服务引用过程，具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryProtocol</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行服务引用，返回Invoker对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cluster  Cluster 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry 注册中心对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type     服务接口类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      注册中心URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;      泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Invoker 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 1 创建RegistryDirectory对象【服务目录】，并设置注册中心到它的属性，该对象包含了注册中心的所有服务提供者 List&lt;Invoker&gt;</span></span><br><span class="line">        <span class="comment">// 同时它也是一个监听器</span></span><br><span class="line">        RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">        <span class="comment">// 1.1 设置 注册中心对象 和 协议</span></span><br><span class="line">        directory.setRegistry(registry);</span><br><span class="line">        directory.setProtocol(protocol);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获得服务引用配置集合parameters。注意：url传入RegistryDirectory后，经过处理并重新创建，所以 url != directory.url，</span></span><br><span class="line">        Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 生成消费者URL</span></span><br><span class="line">        URL subscribeUrl = <span class="keyword">new</span> URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 注册服务消费者，在consumers目录下</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.ANY_VALUE.equals(url.getServiceInterface())</span><br><span class="line">                &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,</span><br><span class="line">                    Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 向注册中心订阅服务（type 对应的服务）的 服务提供者 + 路由规则 + 配置规则 节点下的数据</span></span><br><span class="line">        <span class="comment">// 后续会将订阅URL进行解析，构建要监听的路径 如：/dubbo/com.alibaba.dubbo.demo.DemoService/configurators，然后注册并绑定监听器</span></span><br><span class="line">        directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,</span><br><span class="line">                Constants.PROVIDERS_CATEGORY</span><br><span class="line">                        + <span class="string">","</span> + Constants.CONFIGURATORS_CATEGORY</span><br><span class="line">                        + <span class="string">","</span> + Constants.ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅完成后就会触发服务目录的更新，因为首次订阅就会拉取全量数据，此时 directory 就有对应的服务列表</span></span><br><span class="line">        <span class="comment">// 6 基于 RegistryDirectory 创建 Invoker 对象</span></span><br><span class="line">        Invoker invoker = cluster.join(directory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向本地注册表，注册消费者</span></span><br><span class="line">        ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>消费端在服务引用过程会进行服务订阅，当监听的节点发生变更时，注册中心会将节点下的数据以 <strong>全量</strong> 形式通知给订阅方，也就是对应的 <code>NotifyListener</code> 们。关于订阅通知可以参考 <a href="https://gentryhuang.com/posts/dafcd048/#AbstractRegistry">订阅通知</a> 。下面粘贴注册中心模块通知逻辑代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 订阅URL映射的节点对应的子节点发生变化时，通知监听器</span></span><br><span class="line"><span class="comment">    * @param url      订阅URL</span></span><br><span class="line"><span class="comment">    * @param listener 订阅ULR对应的监听器</span></span><br><span class="line"><span class="comment">    * @param urls     变动的订阅URL映射的路径下的子路径集合（全量数据）【todo 注意：每次传入的 urls 的'全量'，指的是至少要是一个分类的全量[动态类型的]，而不一定是全部数据】。可能为 null 或 只有一个 empty://...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((urls == <span class="keyword">null</span> || urls.isEmpty()) &amp;&amp; !Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Ignore empty notify urls for subscribe url "</span> + url);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Notify urls for subscribe url "</span> + url + <span class="string">", urls: "</span> + urls);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 将 `urls` 按照 URL中的 'category` 参数进行分类，添加到Map集合result中</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;String, List&lt;URL&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 子路径URL是否匹配订阅URL：</span></span><br><span class="line">            <span class="comment">// 1 是否是自己关注的服务：group/interface:version</span></span><br><span class="line">            <span class="comment">// 2 是否是自己感兴趣的 category</span></span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">                <span class="comment">// 获取分类，默认为 providers</span></span><br><span class="line">                String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加入到结果集</span></span><br><span class="line">                List&lt;URL&gt; categoryList = result.get(category);</span><br><span class="line">                <span class="keyword">if</span> (categoryList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    categoryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">                    result.put(category, categoryList);</span><br><span class="line">                &#125;</span><br><span class="line">                categoryList.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得订阅URL对应的缓存`notified`,即通知的 URL 变化结果（全量数据），会把result中的值放入到 categoryNotified中</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url);</span><br><span class="line">        <span class="keyword">if</span> (categoryNotified == <span class="keyword">null</span>) &#123;</span><br><span class="line">            notified.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;());</span><br><span class="line">            categoryNotified = notified.get(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理通知的 URL 变化结果（全量数据），即按照分类，循环处理通知的URL变化结果（全量数据）</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 获得分类名</span></span><br><span class="line">            String category = entry.getKey();</span><br><span class="line">            <span class="comment">// 获得分类名对应的通知ULR列表，可能为 empty://...</span></span><br><span class="line">            List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">            <span class="comment">// 1 将result 覆盖到 `notified`缓存【更新notified集合中的通知ULR列表】，需要注意：当某个分类的数据为空时，会依然有URL，如 empty://...` ，通过这样的方式，处理所有订阅URL对应的数据为空(todo 没有和订阅URL匹配的变更)的情况。</span></span><br><span class="line">            categoryNotified.put(category, categoryList);</span><br><span class="line">            <span class="comment">// 2 保存订阅url对应的被通知的URL到 properties和文件 中 // 在循环中的保存的原因是，订阅url对应的通知url可能是变动的，上一步的操作会更新notified集合，为了让 properties和文件中的 订阅-通知关系正确就需要不断更新。</span></span><br><span class="line">            saveProperties(url);</span><br><span class="line">            <span class="comment">// 3 调用传入的listener的notify()方法</span></span><br><span class="line">            listener.notify(categoryList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>RegistryDirectory</code> 作为一个 <code>NotifyListener</code> 向注册中心 <code>Registry</code> 发起了订阅，因此会收到通知。由通知代码逻辑可知，是按照分类循环通知的，也就说可能订阅的分类有多个，但是每次通知只有一类 URL 。</p>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p><code>RegistryDirectory</code> 是一个动态服务目录，它需要监听注册中心上的相关数据变更进而动态调整，因此实现了 <code>NotifyListener</code> 接口，通过该接口获取注册中心变更通知。下面我们来看具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 根据URL的分类，分成三个类别：1 服务提供者URL  2 路由URL 3 配置URL</span></span><br><span class="line">        List&lt;URL&gt; invokerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">        List&lt;URL&gt; routerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">        List&lt;URL&gt; configuratorUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 遍历 urls，进行分类</span></span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            <span class="comment">// 2.1 获取协议</span></span><br><span class="line">            String protocol = url.getProtocol();</span><br><span class="line">            <span class="comment">// 2.2 获取 category 参数的值，默认是 providers</span></span><br><span class="line">            String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.3 根据 category 参数将 url 分别放到不同的列表中</span></span><br><span class="line">            <span class="comment">// 2.3.1 符合路由规则</span></span><br><span class="line">            <span class="keyword">if</span> (Constants.ROUTERS_CATEGORY.equals(category) || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">                routerUrls.add(url);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3.2 符合配置规则</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.CONFIGURATORS_CATEGORY.equals(category) || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">                configuratorUrls.add(url);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3.3 符合服务提供者</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;</span><br><span class="line">                invokerUrls.add(url);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"Unsupported category "</span> + category + <span class="string">" in notified url: "</span> + url + <span class="string">" from registry "</span> + getUrl().getAddress() + <span class="string">" to consumer "</span> + NetUtils.getLocalHost());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 configurators 下的数据变更，则将配置规则URL集合转换成对应的 Configurator 集合</span></span><br><span class="line">        <span class="keyword">if</span> (configuratorUrls != <span class="keyword">null</span> &amp;&amp; !configuratorUrls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configurators = toConfigurators(configuratorUrls);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 routers 下的数据变更，则将路由URL集合转换成对应的Router集合</span></span><br><span class="line">        <span class="keyword">if</span> (routerUrls != <span class="keyword">null</span> &amp;&amp; !routerUrls.isEmpty()) &#123;</span><br><span class="line">            List&lt;Router&gt; routers = toRouters(routerUrls);</span><br><span class="line">            <span class="comment">// 如果处理得到的Router非空，调用父类的#setRouters方法，设置路由规则。</span></span><br><span class="line">            <span class="keyword">if</span> (routers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                setRouters(routers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 合并配置规则到 directoryUrl, 形成 overrideDirectoryUrl 变量</span></span><br><span class="line">        List&lt;Configurator&gt; localConfigurators = <span class="keyword">this</span>.configurators;</span><br><span class="line">        <span class="keyword">this</span>.overrideDirectoryUrl = directoryUrl;</span><br><span class="line">        <span class="keyword">if</span> (localConfigurators != <span class="keyword">null</span> &amp;&amp; !localConfigurators.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Configurator configurator : localConfigurators) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用配置规则器 将 配置规则应用到 overrideDirectoryUrl</span></span><br><span class="line">                <span class="keyword">this</span>.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 刷新Invoker列表</span></span><br><span class="line">        refreshInvoker(invokerUrls);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过前面的介绍我们知道，在服务引用的过程中会创建 <code>RegistryDirectory</code> 对象，一方面做为 <code>NotifyListener</code> 监听注册中心的 <strong>providers</strong>、<strong>configurators</strong> 和 <strong>routers</strong> 三个目录，所以在这三个目录下发生变化的时候，就会触发 <code>RegistryDirectory</code> 的 <code>notify</code> 方法。另一方面作为消费端的 Invoker 源供集群策略使用。在该方法中，首先会按照 <strong>category 参数</strong> 对变更的 URL 进行分类，并分别对不同类型的 URL 进行处理：</p>
<ul>
<li>将 router 类型的 URL 转化为 Router ，并保存到服务目录中。</li>
<li>将 configurators 类型的 URL 转化为 Configurator ，并保存到服务目录中。</li>
<li>将 provider 类型的 URL 转化为 Invoker ，并保存到服务目录中，该过程是最核心的逻辑。</li>
</ul>
<p><code>RegistryDirectory</code> 中有很多核心属性，它们的更新主要在注册中心通知的过程，Dubbo 使用了 <code>synchronized</code> 锁来处理线程安全问题。</p>
<p>其中在将 configurators 类型 URL 转为 Configurator 后，还会将配置规则应用在 <code>overrideDirectoryUrl</code> 。下面我们对以上 3 个关键流程进行分析。</p>
<h4 id="转换-Configurator"><a href="#转换-Configurator" class="headerlink" title="转换 Configurator"></a>转换 Configurator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Configurator&gt; <span class="title">toConfigurators</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 配置规则URL集合为空，表示不使用配置规则</span></span><br><span class="line">        <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 遍历配置规则 URL ，创建Configurator 配置规则</span></span><br><span class="line">        List&lt;Configurator&gt; configurators = <span class="keyword">new</span> ArrayList&lt;Configurator&gt;(urls.size());</span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            <span class="comment">// 2.1 如果协议为 empty:// ，会清空所有配置规则，返回空集合</span></span><br><span class="line">            <span class="keyword">if</span> (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                configurators.clear();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.2 获取配置规则URL的key-value参数集合</span></span><br><span class="line">            Map&lt;String, String&gt; override = <span class="keyword">new</span> HashMap&lt;String, String&gt;(url.getParameters());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.3 override 上的 anyhost 可能是自动添加的，为了防止影响下面的判断，需要先删除掉</span></span><br><span class="line">            override.remove(Constants.ANYHOST_KEY);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.4 如果配置Url参数部分为空，会清空所有配置规则</span></span><br><span class="line">            <span class="keyword">if</span> (override.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                configurators.clear();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.5 由工厂创建Configurator 对象，并添加到 configurators 集合中</span></span><br><span class="line">            configurators.add(configuratorFactory.getConfigurator(url));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对多个配置规则对象排序</span></span><br><span class="line">        Collections.sort(configurators);</span><br><span class="line">        <span class="keyword">return</span> configurators;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上方法用于将配置规则 URL 转换成对应的配置规则 Configurator 对象，用于实现服务治理功能。配置规则 URL 可能值如下：</p>
<blockquote>
<ol>
<li>override://0.0.0.0/…( or override://ip:port…?anyhost=true)&amp;para1=value1… means global rules (all of the providers take effect) ## 表示全局规则（对所有的提供者全部生效）</li>
<li>override://ip:port…?anyhost=false Special rules (only for a certain provider) ## 特殊规则（只针对某个提供者生效）</li>
<li>override:// rule is not supported… ,needs to be calculated by registry itself. ##  不支持override:// 规则，需要注册中心自行计算</li>
<li>override://0.0.0.0/ without parameters means clearing the override ##  不带参数,表示清除override</li>
</ol>
</blockquote>
<h4 id="转换-Router"><a href="#转换-Router" class="headerlink" title="转换 Router"></a>转换 Router</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"> <span class="function"><span class="keyword">private</span> List&lt;Router&gt; <span class="title">toRouters</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        List&lt;Router&gt; routers = <span class="keyword">new</span> ArrayList&lt;Router&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 路由规则 URL集合判空</span></span><br><span class="line">        <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> routers;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 遍历路由规则 URL</span></span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="keyword">null</span> &amp;&amp; !urls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                <span class="comment">// 2.1 如果是 empty:// ，则忽略。</span></span><br><span class="line">                <span class="comment">// 一般情况下，当所有路由规则被删除时，有且仅有一条协议为 empty:// 的路由规则 URL</span></span><br><span class="line">                <span class="keyword">if</span> (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.2 获取配置的 router 配置项，如果有设置则使用设置的配置项</span></span><br><span class="line">                String routerType = url.getParameter(Constants.ROUTER_KEY);</span><br><span class="line">                <span class="keyword">if</span> (routerType != <span class="keyword">null</span> &amp;&amp; routerType.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    url = url.setProtocol(routerType);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 2.3  通过路由工厂创建 Router</span></span><br><span class="line">                    Router router = routerFactory.getRouter(url);</span><br><span class="line">                    <span class="keyword">if</span> (!routers.contains(router)) &#123;</span><br><span class="line">                        routers.add(router);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">"convert router url to router error, url: "</span> + url, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> routers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上方法用于将路由规则 URL 转换成对应路由规则 Router 对象，用于过滤服务目录中的服务集合。</p>
<h4 id="刷新-Invoker-列表"><a href="#刷新-Invoker-列表" class="headerlink" title="刷新 Invoker 列表"></a>刷新 Invoker 列表</h4><p>刷新 Invoker 列表是为了保证服务目录随注册中心变化而变化，使消费端的 Invoker 是最新的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"><span class="comment">// invokerUrls 是 .../providers 路径下的子路径列表，全量数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 所有服务不可用</span></span><br><span class="line">        <span class="comment">// 当 invokerUrls 集合大小为1，并且协议是 empty://，说明所有的服务都已经下线了，即禁用所有服务。Zookeeper 册中心可参见 &#123;@link ZookeeperRegistry#toUrlsWithEmpty&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (invokerUrls != <span class="keyword">null</span> &amp;&amp; invokerUrls.size() == <span class="number">1</span> &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="keyword">null</span> &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) &#123;</span><br><span class="line">            <span class="comment">// 1.1 设置禁止访问，后续请求将直接抛出异常</span></span><br><span class="line">            <span class="keyword">this</span>.forbidden = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2 置空 方法名与Invoker集合映射 methodInvokerMap</span></span><br><span class="line">            <span class="keyword">this</span>.methodInvokerMap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.3 清空 Invoker 缓存，销毁所有的 Invoker</span></span><br><span class="line">            destroyAllInvokers();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 存在可用服务</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.1 设置允许访问</span></span><br><span class="line">            <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.2 保存旧的 urlInvokerMap，为后续逻辑是否存在无效的 invoker 作为判断依据。</span></span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.3 传入的 invokerUrls 为空说明 注册中心中的 providers 目录未发生变化，</span></span><br><span class="line">            <span class="comment">// 是路由规则或者配置规则发生改变。那么直接使用缓存的服务提供者 Invoker 的URL集合</span></span><br><span class="line">            <span class="keyword">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class="keyword">this</span>.cachedInvokerUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">                invokerUrls.addAll(<span class="keyword">this</span>.cachedInvokerUrls);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.4 传入的 invokerUrls 非空，说明注册中心中的 providers 目录发生了改变，即服务提供者发生了改变（第一次全量拉取数据也是一种改变，从无到有）</span></span><br><span class="line">                <span class="comment">// 则使用传入的 invokerUrls 更新 cachedInvokerUrls</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.cachedInvokerUrls = <span class="keyword">new</span> HashSet&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//缓存invokerUrls列表，便于交叉对比</span></span><br><span class="line">                <span class="keyword">this</span>.cachedInvokerUrls.addAll(invokerUrls);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.4 invokerUrls 为空则直接忽略（例如：初始是按照 configurators =&gt; routers =&gt; providers ，那么前两个会出现为空的情况）</span></span><br><span class="line">            <span class="keyword">if</span> (invokerUrls.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.5 将变更的URL列表转成 URL串 到 Invoker 的映射 (最核心的方法); 内部使用具体的 Protocol 根据合并后的服务提供者URL引入服务</span></span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);<span class="comment">// Translate url list to Invoker map</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.6 将上一步得到的 newUrlInvokerMap 转换成 方法名到Invoker列表的映射；注意，此步会通过 Router 进行过滤</span></span><br><span class="line">            Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); <span class="comment">// Change method name to map Invoker Map</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.7 如果转换错误，则忽略本次转换</span></span><br><span class="line">            <span class="keyword">if</span> (newUrlInvokerMap == <span class="keyword">null</span> || newUrlInvokerMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"urls to invokers error .invokerUrls.size :"</span> + invokerUrls.size() + <span class="string">", invoker.size :0. urls :"</span> + invokerUrls.toString()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.8 如果引用多个服务分组，那么就按照 method + group 维度进一步合并Invoker</span></span><br><span class="line">            <span class="keyword">this</span>.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.9 保存 URL串 到 Invoker 的映射 </span></span><br><span class="line">            <span class="keyword">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 2.10 比较新旧两组 Invoker 集合，销毁已经下线的 Invoker 集合，避免服务消费方调用已经下线的服务</span></span><br><span class="line">                destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); <span class="comment">// Close the unused Invoker</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"destroyUnusedInvokers error. "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务目录转换服务提供者URL -&gt; Invoker 的规则如下：</strong></p>
<blockquote>
<ol>
<li>如果 URL（Provider URL合并后的 URL） 已经转换为 Invoker（缓存中已经存在），则不再重新引用，直接从缓存中获取。需要注意的是，如果 URL 中任何一个参数变更都会重新引用。</li>
<li>如果传入的服务提供者URL列表大小为 1 且协议是 empty://，说明所有的服务都已经下线，要禁用所有服务。</li>
<li>如多传入的服务提供者URL列表为空，则表示只是下发配置规则和路由规则。</li>
</ol>
</blockquote>
<p>注意，上面规则中提到的 URL 并非是服务提供者URL，而是合并后的服务提供者URL，关于合并规则下文会详细说明。</p>
<p><strong>刷新 Invoker 列表的逻辑如下：</strong></p>
<ol>
<li>根据入参 invokerUrls 的数量和协议判断是否禁用所有服务，如果禁用则将禁用标志 forbidden 设置为 true ，并销毁引用所有的 Invoker 。</li>
<li>非禁用，则将 invokerUrls 中的 URL 进行合并操作，然后转换成 Invoker（引用 Invoker），得到新的 <code>&lt;url串,Invoker&gt;</code> 的映射关系。</li>
<li>将第 2 步中得到的 <code>&lt;url串,Invoker&gt;</code> 进一步转成 <code>&lt;methodName,Invoker列表&gt;</code> ，该过程会使用 Router 进行过滤。</li>
<li>如果消费方引用多个服务分组，则根据 <strong>method + group</strong> 进行多组合并操作，同样得到 <code>&lt;methodName,Invoker列表&gt;</code> 数据，<strong>doList</strong> 方法中读取的就是该数据，而这里是写操作。</li>
<li>新的消费端 Invoker 列表生成后，根据第 2 步得到的 <code>&lt;url串,Invoker&gt;</code> ，同旧的 <code>&lt;url串,Invoker&gt;</code> 对比，销毁无用的 Invoker，避免服务消费者调用已经下线的服务。</li>
</ol>
<p>刷新 Invoker 逻辑中会变更两个核心的属性：<strong>urlInvokerMap</strong> 和 <strong>methodInvokerMap</strong> ，前者以URL维度（合并后的URL）后者以方法名维度，前者用于判断是否需要重新引用服务，后者用于存储引用的Invoker集合供 <strong>doList</strong> 方法拉取。</p>
<p>接下来我们对上面涉及到的核心步骤进行分析。</p>
<h5 id="转换-Invoker"><a href="#转换-Invoker" class="headerlink" title="转换 Invoker"></a>转换 Invoker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">        <span class="comment">// &lt;URL串,Invoker&gt;</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;String, Invoker&lt;T&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若为空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 记录已初始化的服务提供者URL串，即已经处理过的服务提供者URL</span></span><br><span class="line">        Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取消费者配置的协议 (一般情况下，我们不在消费端 &lt;dubbo:reference protocol=""/&gt; 配置服务协议)</span></span><br><span class="line">        String queryProtocols = <span class="keyword">this</span>.queryMap.get(Constants.PROTOCOL_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 循环遍历变更的提供者URL集合</span></span><br><span class="line">        <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line">            <span class="comment">// 4 对消费端配置协议的处理逻辑</span></span><br><span class="line">            <span class="comment">// 4.1 如果消费端配置了协议，则只选择和消费端匹配的协议</span></span><br><span class="line">            <span class="keyword">if</span> (queryProtocols != <span class="keyword">null</span> &amp;&amp; queryProtocols.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> accept = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 可能配置了多协议</span></span><br><span class="line">                String[] acceptProtocols = queryProtocols.split(<span class="string">","</span>);</span><br><span class="line">                <span class="comment">// 4.2 根据消费方protocol过滤不匹配协议，因为Dubbo允许在消费方配置只消费指定协议的服务</span></span><br><span class="line">                <span class="keyword">for</span> (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                        accept = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 4.3 如果当前URL不支持Consumer端的协议，也就无法执行后续转换成Invoker的逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (!accept) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 跳过 empty:// 协议的 URL</span></span><br><span class="line">            <span class="keyword">if</span> (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6 如果消费端不支持变更的服务端的协议，则忽略</span></span><br><span class="line">            <span class="keyword">if</span> (!ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">providerUrl</span>.<span class="title">getProtocol</span>())) </span>&#123;</span><br><span class="line">                logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported protocol "</span> + providerUrl.getProtocol() + <span class="string">" in notified url: "</span> + providerUrl + <span class="string">" from registry "</span> + getUrl().getAddress() + <span class="string">" to consumer "</span> + NetUtils.getLocalHost()</span><br><span class="line">                        + <span class="string">", supported protocol: "</span> + ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getSupportedExtensions</span>()))</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7 合并URL数据，即将配置规则，消费端配置参数合并到服务提供者URl中</span></span><br><span class="line">            <span class="comment">// 注意服务提供者URL的主体信息不变，合并的只是参数部分</span></span><br><span class="line">            URL url = mergeUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8 URL字符串，该字符串是服务提供者URL合并处理后的，作为是否需要重新引用的标志</span></span><br><span class="line">            String key = url.toFullString();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9 跳过重复的 URL，防止重复引用</span></span><br><span class="line">            <span class="keyword">if</span> (keys.contains(key)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入到 keys 集合中，为了防止重复</span></span><br><span class="line">            keys.add(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 10 判断 key 是否已经引用过，引用过则无需重新引用，直接使用对应的缓存即可</span></span><br><span class="line">            <span class="comment">// 如果没有引用过，则通过 Protocol.refer 方法引用服务，创建 Invoker</span></span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap;</span><br><span class="line">            Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">            <span class="comment">// 没有引用过</span></span><br><span class="line">            <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 通过获取配置项 enable 和 disable 的值判断服务是否开启</span></span><br><span class="line">                    <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class="line">                        enabled = !url.getParameter(Constants.DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        enabled = url.getParameter(Constants.ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果开启，则创建 Invoker 对象</span></span><br><span class="line">                    <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                        <span class="comment">//  通过 Protocol.refer 方法创建对应的 Invoker 对象，并使用 InvokerDelegate 装饰引用的 Invoker</span></span><br><span class="line">                        <span class="comment">//  如使用 DubboProtocol、HttpProtocl  协议进行服务引用，此时 url 是 providerUrl 处理后的</span></span><br><span class="line">                        invoker = <span class="keyword">new</span> InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Failed to refer invoker for interface:"</span> + serviceType + <span class="string">",url:("</span> + url + <span class="string">")"</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将key和Invoker对象之间的映射关系记录到newUrlInvokerMap中</span></span><br><span class="line">                <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    newUrlInvokerMap.put(key, invoker);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存命中，直接使用缓存的 Invoker</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newUrlInvokerMap.put(key, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11 清空keys标记集合</span></span><br><span class="line">        keys.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 12 返回新的消费端 Invoker</span></span><br><span class="line">        <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>转换 Invoker 方法用于将服务提供者URL最终转为Invoker，即使用protocol.refer方法进行服务引用，也就是一条服务提供者URL对应一个消费端Invoker。主要核心逻辑如下：</p>
<ol>
<li>对服务提供者 URL 进行检测，若服务消费端的配置不支持服务端的协议，或服务端 URL 协议头为 empty 时，则忽略服务提供方 URL。</li>
<li>合并 URL ，即将配置规则和消费端配置参数合并到服务提供者URL中。</li>
<li>根据合并后的 URL 访问缓存，尝试获取与 URL 对应的 Invoker。缓存未命中，则通过 <code>Protocol.refer</code> 进行服务引用，并将创建的 Invoker 进行缓存。</li>
</ol>
<p>toInvokers() 方法的核心逻辑就是调用 Protocol.refer() 方法创建 Invoker 对象，其他的逻辑都是在判断是否调用该方法以及调用该方法前的准备工作。下面我们对 URL 参数合并逻辑简单介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"> <span class="function"><span class="keyword">private</span> URL <span class="title">mergeUrl</span><span class="params">(URL providerUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 将消费端URL参数配置项合并到服务提供者的URL中</span></span><br><span class="line">        <span class="comment">// 1.1 移除 Provider URL 中只在 Provider 端生效的属性，如：threadname、threadpool、corethreads、threads、queues、alive、transporter</span></span><br><span class="line">        <span class="comment">// 1.2 用 Consumer 端的参数配置（parameters）覆盖 Provider URL 的相应配置，但：version、group、methods、timestamp等参数以Provider端的配置优先，因为它们是远程配置的参数。</span></span><br><span class="line">        <span class="comment">// 1.3 合并 Provider 端和 Consumer 端配置的 Filter 以及 Listener</span></span><br><span class="line">        providerUrl = ClusterUtils.mergeUrl(providerUrl, queryMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 合并配置规则URL到 providerUrl中，配置规则URL可以是：</span></span><br><span class="line">        <span class="comment">// 2.1 第一类是注册中心 Configurators 目录下的的URL（override 协议）</span></span><br><span class="line">        <span class="comment">// 2.2 第二类是服务治理控制台动态添加配置</span></span><br><span class="line">        List&lt;Configurator&gt; localConfigurators = <span class="keyword">this</span>.configurators; <span class="comment">// local reference</span></span><br><span class="line">        <span class="keyword">if</span> (localConfigurators != <span class="keyword">null</span> &amp;&amp; !localConfigurators.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Configurator configurator : localConfigurators) &#123;</span><br><span class="line">                <span class="comment">// 使用配置规则器 将 配置规则应用到 providerUrl</span></span><br><span class="line">                providerUrl = configurator.configure(providerUrl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 增加check=false，即只有在调用时，才检查Provider是否可用</span></span><br><span class="line">        providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 更新 overrideDirectoryUrl</span></span><br><span class="line">        <span class="keyword">this</span>.overrideDirectoryUrl = <span class="keyword">this</span>.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters()); <span class="comment">// Merge the provider side parameters</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 忽略 对 1.0 版本的兼容</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 返回处理后的新的服务提供者 URL</span></span><br><span class="line">        <span class="keyword">return</span> providerUrl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>合并 URL 的逻辑如下：</strong></p>
<ol>
<li>将消费端URL参数配置项合并到服务提供者URL中，但 <strong>group</strong>、<strong>version</strong>、<strong>methods</strong> 等参数以服务端的配置优先，因为它们是远程服务配置参数。</li>
<li>filter 和 listener 参数使用两端的配置项。</li>
<li>将注册中心中 configurators 目录下的 URL，以及服务治理控制台动态添加的配置与 Provider URL 进行合并，即覆盖 Provider URL 原有的一些信息。</li>
<li>增加check=false，即只有在调用时，才检查Provider是否可用。</li>
<li>更新 overrideDirectoryUrl 的值：<strong>注册中心URL + 消费端URL参数配置项 -&gt; 注册中心URL + 消费端URL参数配置项 + 服务端URL合并后的URL参数配置项</strong>。</li>
</ol>
<p>需要说明的是，合并 URL 参数的优先级：<strong>配置规则</strong> -&gt; <strong>系统参数</strong> -&gt; <strong>消费端配置</strong> -&gt; <strong>服务端配置</strong> </p>
<p><strong>toInvokers</strong> 方法返回的是 <code>&lt;url串,Invoker&gt;</code> 映射关系，接下来还会对该结果进一步处理，得到方法名到 Invoker 列表的映射关系。</p>
<h5 id="方法名-gt-Invoker列表"><a href="#方法名-gt-Invoker列表" class="headerlink" title="方法名-&gt;Invoker列表"></a>方法名-&gt;Invoker列表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; toMethodInvokers(Map&lt;String, Invoker&lt;T&gt;&gt; invokersMap) &#123;</span><br><span class="line">        <span class="comment">// 方法名到Invoker集合映射</span></span><br><span class="line">        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录服务提供者Invoker集合</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokersList = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照服务提供者URL声明的 method 分类，兼容注册中心执行路由过滤掉的 methods</span></span><br><span class="line">        <span class="keyword">if</span> (invokersMap != <span class="keyword">null</span> &amp;&amp; invokersMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环每个服务提供者Invoker</span></span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokersMap.values()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1 服务提供者URL声明的 methods</span></span><br><span class="line">                String parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 遍历方法集合</span></span><br><span class="line">                <span class="keyword">if</span> (parameter != <span class="keyword">null</span> &amp;&amp; parameter.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 切割 methods 参数值，处理成方法名数组</span></span><br><span class="line">                    String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);</span><br><span class="line">                    <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 3 循环每个方法，按照方法名的维度收集引用的 Invoker</span></span><br><span class="line">                        <span class="keyword">for</span> (String method : methods) &#123;</span><br><span class="line">                            <span class="comment">// 当服务提供者的方法为 * 时，代表泛化调用，不处理。</span></span><br><span class="line">                            <span class="keyword">if</span> (method != <span class="keyword">null</span> &amp;&amp; method.length() &gt; <span class="number">0</span> &amp;&amp; !Constants.ANY_VALUE.equals(method)) &#123;</span><br><span class="line">                                List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method);</span><br><span class="line">                                <span class="keyword">if</span> (methodInvokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    methodInvokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">                                    newMethodInvokerMap.put(method, methodInvokers);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 根据方法名获取Invoker集合</span></span><br><span class="line">                                methodInvokers.add(invoker);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 收集引用的 Invoker</span></span><br><span class="line">                invokersList.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 进行服务级别路由，即对引用的服务进行路由</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; newInvokersList = route(invokersList, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 存储 &lt;*, newInvokersList&gt; 映射关系</span></span><br><span class="line">        newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 对引用的服务接口中的方法进行方法级别路由</span></span><br><span class="line">        <span class="keyword">if</span> (serviceMethods != <span class="keyword">null</span> &amp;&amp; serviceMethods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历服务方法数组基于每个方法路由，匹配方法对应的Invoker集合</span></span><br><span class="line">            <span class="keyword">for</span> (String method : serviceMethods) &#123;</span><br><span class="line">                List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method);</span><br><span class="line">                <span class="keyword">if</span> (methodInvokers == <span class="keyword">null</span> || methodInvokers.isEmpty()) &#123;</span><br><span class="line">                    methodInvokers = newInvokersList;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 进行方法级别路由</span></span><br><span class="line">                newMethodInvokerMap.put(method, route(methodInvokers, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8 排序，转成不可变集合</span></span><br><span class="line">        <span class="keyword">for</span> (String method : <span class="keyword">new</span> HashSet&lt;String&gt;(newMethodInvokerMap.keySet())) &#123;</span><br><span class="line">            List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method);</span><br><span class="line">            Collections.sort(methodInvokers, InvokerComparator.getComparator());</span><br><span class="line">            newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(newMethodInvokerMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">---+</span><br><span class="line">    <span class="keyword">private</span> List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, String method) &#123;</span><br><span class="line">        <span class="comment">// 创建Invocation 对象</span></span><br><span class="line">        Invocation invocation = <span class="keyword">new</span> RpcInvocation(method, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>], <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 获得 Router 数组</span></span><br><span class="line">        List&lt;Router&gt; routers = getRouters();</span><br><span class="line">        <span class="comment">// 根据路由规则，筛选Invoker 集合</span></span><br><span class="line">        <span class="keyword">if</span> (routers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Router router : routers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (router.getUrl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将引用的 Invoker 列表进行映射，得到方法名到 Invoker 的映射。主要过程如下：</p>
<ol>
<li>对传入的引用 Invoker 进行遍历，获取其中的 <strong>methods</strong> 参数，并切分成数组。然后以方法名为键，Invoker 列表为值进行缓存。</li>
<li>先后基于服务级别和方法级别对 Invoker 列表进行路由操作，筛选目标 Invoker 。</li>
<li>对路由后的 Invoker 列表进行排序，并转成不可变列表。</li>
</ol>
<h5 id="多分组聚合"><a href="#多分组聚合" class="headerlink" title="多分组聚合"></a>多分组聚合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; toMergeMethodInvokerMap(Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; methodMap) &#123;</span><br><span class="line">        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;();</span><br><span class="line">        <span class="comment">// 循环map集合，根据 method + group 聚合 Invoker 集合</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; entry : methodMap.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 获取方法名</span></span><br><span class="line">            String method = entry.getKey();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 获取方法名对应的invoker列表</span></span><br><span class="line">            List&lt;Invoker&lt;T&gt;&gt; invokers = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 按照 group 聚合 Invoker 集合的结果，key：group value：Invoker集合</span></span><br><span class="line">            Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; groupMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 遍历Invoker集合 。注意：一个方法对应的 Invoker 列表可能属于多个组</span></span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">                <span class="comment">// 4.1 获取分组名</span></span><br><span class="line">                String group = invoker.getUrl().getParameter(Constants.GROUP_KEY, <span class="string">""</span>);</span><br><span class="line">                <span class="comment">// 4.2 以分组名聚合Invoker集合</span></span><br><span class="line">                List&lt;Invoker&lt;T&gt;&gt; groupInvokers = groupMap.get(group);</span><br><span class="line">                <span class="keyword">if</span> (groupInvokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    groupInvokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">                    groupMap.put(group, groupInvokers);</span><br><span class="line">                &#125;</span><br><span class="line">                groupInvokers.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 如果只有一个group，则直接使用该group分组对应的Invoker集合作为结果</span></span><br><span class="line">            <span class="keyword">if</span> (groupMap.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                result.put(method, groupMap.values().iterator().next());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6 有多个分组的话，将每个group对应的Invoker集合经过Cluster合并成一个Invoker</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (groupMap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                List&lt;Invoker&lt;T&gt;&gt; groupInvokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (List&lt;Invoker&lt;T&gt;&gt; groupList : groupMap.values()) &#123;</span><br><span class="line">                    <span class="comment">// 这里使用到StaticDirectory以及Cluster合并每个group中的Invoker</span></span><br><span class="line">                    groupInvokers.add(cluster.join(<span class="keyword">new</span> StaticDirectory&lt;T&gt;(groupList)));</span><br><span class="line">                &#125;</span><br><span class="line">                result.put(method, groupInvokers);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有的话，就使用原来的数据</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.put(method, invokers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>多分组聚合方法用于在 <code>&lt;methodName,Invoker列表&gt;</code> 基础中，对同一个方法对应的 Invoker 列表进行 group 维度的分类，同一个 group 维度的 Invoker 列表通过 Cluster 合并成一个 Invoker 。</p>
<p><strong>关键一点：</strong><br>这里按照 <code>group</code> 进行聚合的目的是，为 <code>MergeableCluster</code> 创建的 <code>MergeableClusterInvoker</code> 提供分组后的服务列表。当引用多个服务分组时，会自动使用分组聚合的特性，这个特性就是由 <code>MergeableCluster</code> 创建的 <code>MergeableClusterInvoker</code> 完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryProtocol</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 获得真实的注册中心的URL</span></span><br><span class="line">        url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);</span><br><span class="line">        <span class="comment">// 获得注册中心</span></span><br><span class="line">        Registry registry = registryFactory.getRegistry(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// todo 这是干嘛的？为什么要给RegistryService 类型生成Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (RegistryService<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">type</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得服务引用配置参数集合Map</span></span><br><span class="line">        Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取group属性</span></span><br><span class="line">        String group = qs.get(Constants.GROUP_KEY);</span><br><span class="line">        <span class="comment">// 分组聚合 group="a,b" or group="*"</span></span><br><span class="line">        <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果多个分组 -&gt; todo 分组聚合，将每个组的服务调用一次，然后聚合结果</span></span><br><span class="line">            <span class="keyword">if</span> ((Constants.COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">"*"</span>.equals(group)) &#123;</span><br><span class="line">                <span class="comment">// 通过SPI加载MergeableCluster实例，并调用doRefer继续执行引用服务逻辑。</span></span><br><span class="line">                <span class="comment">// 注意这里使用的是 MergeableCluster，并不是配置的cluster或者默认的cluster不再使用了，</span></span><br><span class="line">                <span class="comment">// 对于分组聚合来说，cluster用在了聚合同一个group下的 Invoker 列表</span></span><br><span class="line">                <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行服务引用</span></span><br><span class="line"><span class="comment">         * todo 服务分组的使用，如果消费方有指定 group 属性，那么该属性发挥的作用在服务订阅时，对 Provider 的过滤。注意和分组聚合的区别。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> com.alibaba.dubbo.common.utils.UrlUtils#isMatch(com.alibaba.dubbo.common.URL, com.alibaba.dubbo.common.URL)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="销毁无用-Invoker"><a href="#销毁无用-Invoker" class="headerlink" title="销毁无用 Invoker"></a>销毁无用 Invoker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroyUnusedInvokers</span><span class="params">(Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap, Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 安全处理</span></span><br><span class="line">        <span class="keyword">if</span> (newUrlInvokerMap == <span class="keyword">null</span> || newUrlInvokerMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 销毁所有服务提供者Invoker</span></span><br><span class="line">            destroyAllInvokers();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 比较新老集合，确定需要销毁哪些Invoker。</span></span><br><span class="line">        <span class="comment">// 原则是：以新的为基准，如果新的中不包含老的，说明老的应该被销毁</span></span><br><span class="line">        List&lt;String&gt; deleted = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldUrlInvokerMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取新生成的 Invoker 集合</span></span><br><span class="line">            Collection&lt;Invoker&lt;T&gt;&gt; newInvokers = newUrlInvokerMap.values();</span><br><span class="line">            <span class="comment">// 遍历老的 &lt;url串, Invoker&gt; 映射表</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Invoker&lt;T&gt;&gt; entry : oldUrlInvokerMap.entrySet()) &#123;</span><br><span class="line">                <span class="comment">// 如果新的集合中不包含老的Invoker，则表示可以把当前老的Invoker删除</span></span><br><span class="line">                <span class="keyword">if</span> (!newInvokers.contains(entry.getValue())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (deleted == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        deleted = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 若不包含，则将老的 Invoker 对应的 url 存入 deleted 列表中</span></span><br><span class="line">                    deleted.add(entry.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 有需要销毁的Invoker就进行销毁</span></span><br><span class="line">        <span class="keyword">if</span> (deleted != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历 deleted 集合，并到老的 &lt;url, Invoker&gt; 映射关系表查出 Invoker并销毁</span></span><br><span class="line">            <span class="keyword">for</span> (String url : deleted) &#123;</span><br><span class="line">                <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 从老的Invoker集合中移除要销毁的Invoker</span></span><br><span class="line">                    Invoker&lt;T&gt; invoker = oldUrlInvokerMap.remove(url);</span><br><span class="line">                    <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 销毁Invoker</span></span><br><span class="line">                            invoker.destroy();</span><br><span class="line">                            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                                logger.debug(<span class="string">"destroy invoker["</span> + invoker.getUrl() + <span class="string">"] success. "</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"destroy invoker["</span> + invoker.getUrl() + <span class="string">"] faild. "</span> + e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>销毁无用 Invoker 关键看旧的 Invoker 是否在新的 Invoker 集合中，不在则说明需要销毁。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Dubbo 的服务目录进行了分析，相比静态服务目录 <strong>StaticDirectory</strong> ，动态的服务目录 <strong>RegistryDirectory</strong> 要复杂得多，为了让本地服务目录和注册中心保持一致，需要做很多工作。</p>
<p><strong>关键一点：</strong>服务目录生成与刷新的前提是，服务提供方的服务 URL 必须是服务消费方感兴趣的，否则不会对服务提供方 URL 进行后续的 URL合并与引用操作流程，而感兴趣的一个非常关键条件是，服务消费方订阅URL和服务提供方URL的关系如下：</p>
<ul>
<li>是否是自己关注的服务：group、serviceName、version</li>
<li>是否是自己感兴趣的 category</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/e43ac0a6/" title="集群容错 - Directory" target="_blank" rel="external">https://gentryhuang.com/posts/e43ac0a6/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/a965bdb8/" title="集群容错 - 动态配置"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/7aca9035/" title="Dubbo源码分析 - 集群模块总览"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2022 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>