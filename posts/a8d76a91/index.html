<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Dubbo源码分析 - XML配置 | gentryhuang的博客</title>
  <meta name="description" content="前言在 Dubbo源码分析 - API和属性配置 中介绍了Dubbo的配置承载对象，分析了核心的配置类及方法。了解了API配置后XML配置就容易多了，XML配置相比较API配置的区别在配置对象创建及其属性的设置是由Spring管理的，Dubbo和Spring XML融合是关键。 Dubbo和Spring融合Dubbo框架直接集成了Spring的能力，利用Spring配置文件扩展出自定义的解析方式，">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo源码分析 - XML配置">
<meta property="og:url" content="https://gentryhuang.com/posts/a8d76a91/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="前言在 Dubbo源码分析 - API和属性配置 中介绍了Dubbo的配置承载对象，分析了核心的配置类及方法。了解了API配置后XML配置就容易多了，XML配置相比较API配置的区别在配置对象创建及其属性的设置是由Spring管理的，Dubbo和Spring XML融合是关键。 Dubbo和Spring融合Dubbo框架直接集成了Spring的能力，利用Spring配置文件扩展出自定义的解析方式，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-schema.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-schema-relation.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-spring-handlers.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-parsercontext.jpg">
<meta property="article:published_time" content="2020-03-28T16:00:00.000Z">
<meta property="article:modified_time" content="2021-11-19T06:45:29.380Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="Dubbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-schema.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/a8d76a91/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.png" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.5px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.75px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.13px;">I/O</a> <a href="/tags/JMM/" style="font-size: 13px;">JMM</a> <a href="/tags/JUC/" style="font-size: 13.75px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.25px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.13px;">Lock</a> <a href="/tags/LongAdder/" style="font-size: 13px;">LongAdder</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.25px;">Protocol</a> <a href="/tags/Queue/" style="font-size: 13.38px;">Queue</a> <a href="/tags/RPC/" style="font-size: 13.63px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13.38px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.13px;">Redis数据结构</a> <a href="/tags/SCAN/" style="font-size: 13px;">SCAN</a> <a href="/tags/SPI/" style="font-size: 13.25px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.25px;">Spring</a> <a href="/tags/Thread/" style="font-size: 13.13px;">Thread</a> <a href="/tags/Zookeeper/" style="font-size: 13.13px;">Zookeeper</a> <a href="/tags/cahce/" style="font-size: 13px;">cahce</a> <a href="/tags/false-sharing/" style="font-size: 13px;">false sharing</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 13px;">分布式锁</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.88px;">设计模式</a> <a href="/tags/%E9%99%90%E6%B5%81/" style="font-size: 13px;">限流</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/c1861d8c/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/c1861d8c/" class="title">Redis原理 - SCAN 原理</a>
              </p>
              <p class="item-date">
                <time datetime="2022-06-26T13:14:47.000Z" itemprop="datePublished">2022-06-26</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/db98efcf/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/db98efcf/" class="title">队列 - DelayQueue</a>
              </p>
              <p class="item-date">
                <time datetime="2022-06-15T12:10:53.000Z" itemprop="datePublished">2022-06-15</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/282602b0/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/282602b0/" class="title">并发 - LongAdder</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-30T02:25:18.000Z" itemprop="datePublished">2022-05-30</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/218dc61f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/218dc61f/" class="title">并发 - ConcurrentHashMap</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-14T02:30:35.000Z" itemprop="datePublished">2022-05-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/9012be3f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/9012be3f/" class="title">并发 - ScheduledThreadPoolExecutor</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-02T01:55:06.000Z" itemprop="datePublished">2022-05-02</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo和Spring融合"><span class="toc-number">2.</span> <span class="toc-text">Dubbo和Spring融合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dubbo的配置对象模型"><span class="toc-number">2.1.</span> <span class="toc-text">Dubbo的配置对象模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dubbo的xsd文件"><span class="toc-number">2.2.</span> <span class="toc-text">Dubbo的xsd文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dubbo的spring-schemas文件"><span class="toc-number">2.3.</span> <span class="toc-text">Dubbo的spring.schemas文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dubbo的spring-handlers"><span class="toc-number">2.4.</span> <span class="toc-text">Dubbo的spring.handlers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dubbo的DubboNamespaceHandler"><span class="toc-number">2.5.</span> <span class="toc-text">Dubbo的DubboNamespaceHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dubbo的DubboBeanDefinitionParser"><span class="toc-number">2.6.</span> <span class="toc-text">Dubbo的DubboBeanDefinitionParser</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Dubbo标签"><span class="toc-number">2.7.</span> <span class="toc-text">使用Dubbo标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-number">2.8.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析准备"><span class="toc-number">3.</span> <span class="toc-text">解析准备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#加载-spring-schemas-文件"><span class="toc-number">3.1.</span> <span class="toc-text">加载 spring.schemas 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载-spring-handlers-文件"><span class="toc-number">3.2.</span> <span class="toc-text">加载 spring.handlers 文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析标签"><span class="toc-number">4.</span> <span class="toc-text">解析标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dubbo-Bean定义解析器"><span class="toc-number">4.1.</span> <span class="toc-text">Dubbo Bean定义解析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建Bean定义并注册到Spring上下文"><span class="toc-number">4.2.</span> <span class="toc-text">创建Bean定义并注册到Spring上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特殊处理protocol标签"><span class="toc-number">4.3.</span> <span class="toc-text">特殊处理protocol标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特殊处理service标签"><span class="toc-number">4.4.</span> <span class="toc-text">特殊处理service标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特殊处理provider-consumer标签"><span class="toc-number">4.5.</span> <span class="toc-text">特殊处理provider&#x2F;consumer标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置标签的属性到-BeanDefinition"><span class="toc-number">4.6.</span> <span class="toc-text">设置标签的属性到 BeanDefinition</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-rpc/xml配置" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Dubbo源码分析 - XML配置
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/a8d76a91/" class="article-date">
	  <time datetime="2020-03-28T16:00:00.000Z" itemprop="datePublished">2020-03-29</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/RPC/">RPC</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Dubbo/" rel="tag">Dubbo</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/a8d76a91/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 8.1k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 36(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 <a href="https://gentryhuang.com/posts/1d3295e6/">Dubbo源码分析 - API和属性配置</a> 中介绍了Dubbo的配置承载对象，分析了核心的配置类及方法。了解了API配置后XML配置就容易多了，XML配置相比较API配置的区别在配置对象创建及其属性的设置是由Spring管理的，Dubbo和Spring XML融合是关键。</p>
<h3 id="Dubbo和Spring融合"><a href="#Dubbo和Spring融合" class="headerlink" title="Dubbo和Spring融合"></a>Dubbo和Spring融合</h3><p>Dubbo框架直接集成了Spring的能力，利用Spring配置文件扩展出自定义的解析方式，即使用Spring的自定标签。关于Spring自定标签的示例，在<a href="https://gentryhuang.com/posts/eee3e639/">Spring自定义标签</a> 中有详细介绍，Dubbo基于schema的设计也是如此，下面我们就来分析下Dubbo是怎么和Spring融合的。</p>
<h4 id="Dubbo的配置对象模型"><a href="#Dubbo的配置对象模型" class="headerlink" title="Dubbo的配置对象模型"></a>Dubbo的配置对象模型</h4><p>Dubbo的配置对象模型已经在 [Dubbo源码分析 - API和属性配置] 中详细介绍过了，在Dubbo的命名空间处理器中也可以具体看到哪些配置类和Spring进行交互，这里就不再介绍。</p>
<h4 id="Dubbo的xsd文件"><a href="#Dubbo的xsd文件" class="headerlink" title="Dubbo的xsd文件"></a>Dubbo的xsd文件</h4><p>dubbo.xsd文件是用来约束使用XML配置时的标签和对应的属性，如Dubbo中的&lt;dubbo:service&gt;标签等。由于当前分析的dubbo版本是2.6.5，Dubbo已经捐给了Apache组织，为了遵循Apache标准和兼容Dubbo原来的版本，会出现两个xsd文件，这篇文章还是按照Dubbo原来的版本进行相关描述。</p>
<ul>
<li>dubbo.xsd总览</li>
</ul>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-schema.jpg" alt></p>
<p>Dubbo设计的粒度很多都是针对方法级别的，如方法级别的timeout、retries等特性。具体的每个复杂类型的详细使用可以参考:<a href="http://dubbo.apache.org/zh-cn/docs/user/references/xml/introduction.html" target="_blank" rel="noopener">官方文档</a></p>
<ul>
<li>dubbo.xsd中的类型关系</li>
</ul>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-schema-relation.jpg" alt></p>
<p>上图的类型继承关系和Dubbo的配置类之间的关系几乎保持一致，因为这里定义的复杂类型就是要映射到配置类的属性上，即schema中的字段对应Config类中的属性和get/set方法。</p>
<h4 id="Dubbo的spring-schemas文件"><a href="#Dubbo的spring-schemas文件" class="headerlink" title="Dubbo的spring.schemas文件"></a>Dubbo的spring.schemas文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http\:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&#x3D;META-INF&#x2F;dubbo.xsd</span><br><span class="line">http\:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&#x3D;META-INF&#x2F;compat&#x2F;dubbo.xsd</span><br></pre></td></tr></table></figure>
<p>spring.schemas文件用来指明约束文件的具体路径。</p>
<h4 id="Dubbo的spring-handlers"><a href="#Dubbo的spring-handlers" class="headerlink" title="Dubbo的spring.handlers"></a>Dubbo的spring.handlers</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http\:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x3D;com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</span><br><span class="line">http\:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x3D;com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</span><br></pre></td></tr></table></figure>
<p>spring.handlers文件用来指明Dubbo的XML命名空间处理器，即使用DubboNamespaceHandler来解析Dubbo自定义的标签。</p>
<h4 id="Dubbo的DubboNamespaceHandler"><a href="#Dubbo的DubboNamespaceHandler" class="headerlink" title="Dubbo的DubboNamespaceHandler"></a>Dubbo的DubboNamespaceHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法中定义了每个&lt;xsd:element/&gt;对应的BeanDefinitionParser 【Dubbo Bean定义解析器】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"module"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"registry"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"monitor"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"protocol"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>))</span>;</span><br><span class="line">        <span class="comment">// 注解已经重写，AnnotationBeanDefinitionParser 已经废弃，即@DubboComponentScan 作为 Dubbo 2.5.7 新增的 Annotation，是XML 元素 &lt;dubbo:annotation&gt; 的替代方案。</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation"</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dubbo解析配置的入口是在 DubboNamespaceHandler类中完成的，该类主要把不同的标签关联到解析实现类中，registerBeanDefinitionParser方法约定在遇到Dubbo自定的标签如application、registry、protocol等都会委托给Dubbo的命名空间处理器DubboNamespaceHandler处理，该处理器又会把解析任务交给DubboBeanDefinitionParser来处理。</p>
<h4 id="Dubbo的DubboBeanDefinitionParser"><a href="#Dubbo的DubboBeanDefinitionParser" class="headerlink" title="Dubbo的DubboBeanDefinitionParser"></a>Dubbo的DubboBeanDefinitionParser</h4><p>实现了Spring的BeanDefinitionParser接口，是真正用来解析自定的Dubbo标签，将标签解析成对应的Bean定义并注册到Spring上下文中。</p>
<h4 id="使用Dubbo标签"><a href="#使用Dubbo标签" class="headerlink" title="使用Dubbo标签"></a>使用Dubbo标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- provider's application name, used for tracing dependency relationship --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span> <span class="attr">owner</span>=<span class="string">"gentryhuang"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- use multicast registry center to export service --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:registry address="multicast://224.5.6.7:1234" protocol="test"/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- use dubbo protocol to export service on port 20880 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- service implementation, as same as regular local bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.dubbo.demo.provider.DemoServiceImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- declare the service interface to be exported --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上就是Dubbo和Spring的XML配置进行融合的过程，与 <a href="https://gentryhuang.com/posts/eee3e639/">Spring自定义标签</a> 文章中的流程是一样的。总的来说，Dubbo框架先以流的形式装载Spring的XML配置文件，在将流解析成DOM的过程中会加载<code>spring.schemas</code>文件，然后读取该文件中指定的的xsd约束文件，接着使用xsd中的约束规则对每个标签及其属性进行校验，不合法则抛出异常，整个配置文件符合约束规则则生成DOM对象。<code>spring.schema</code>文件指定了配置约束文件的位置，加载<code>spring.schemas</code>文件的目的就是用来校验Spring的XML配置文件内容是否合法。加载<code>spring.handlers</code>文件的目的是，当解析Spring的XML配置文件中的标签时,会查找该文件中指定的DubboNamespaceHandler类来进行自定义标签的初始化和解析。</p>
<h3 id="解析准备"><a href="#解析准备" class="headerlink" title="解析准备"></a>解析准备</h3><h4 id="加载-spring-schemas-文件"><a href="#加载-spring-schemas-文件" class="headerlink" title="加载 spring.schemas 文件"></a>加载 spring.schemas 文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory)&#123;</span><br><span class="line">   <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">  <span class="comment">// resource loading environment.</span></span><br><span class="line">  beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">  beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 设置 'META-INF/spring.schemas' 到 ResourceEntityResolver</span></span><br><span class="line">  beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">  <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">  initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">  loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就设置 spring.schemas 文件路径，为接下来加载 spring.schemas 文件做准备。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">XmlBeanDefinitionReader#doLoadBeanDefinitions(InputSource inputSource, Resource resource)&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加载 META-INF/spring.schemas 中xsd文件，在构建Dom时进行校验XML配置内容是否正确</span></span><br><span class="line">	Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">    <span class="comment">// 加载 META-INF/spring.handlers 中的命名空间处理器，初始化并放入缓存</span></span><br><span class="line">	<span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是注册XML中的Bean的大流程入口，分别是加载 META-INF/spring.schemas 中xsd文件，用于构建DOM时校验XML配置内容是否正确，加载 META-INF/spring.handlers 中的命名空间处理器，用于处理标签和BeanDefinitionParser的映射关系以及解析标签。下面我们来看Spring是如何加载spring.schemas文件内容的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PluggableSchemaResolver#getSchemaMappings()&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.schemaMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line"> 	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"> 	 <span class="keyword">if</span> (<span class="keyword">this</span>.schemaMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line"> 		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"> 			logger.debug(<span class="string">"Loading schema mappings from ["</span> + <span class="keyword">this</span>.schemaMappingsLocation + <span class="string">"]"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	 <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从 META-INF/spring.schemas 中读取xsd文件路径</span></span><br><span class="line"> 		Properties mappings = PropertiesLoaderUtils.loadAllProperties(<span class="keyword">this</span>.schemaMappingsLocation, <span class="keyword">this</span>.classLoader);</span><br><span class="line"> 		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"> 			logger.debug(<span class="string">"Loaded schema mappings: "</span> + mappings);</span><br><span class="line"> 		  &#125;</span><br><span class="line"> 		Map&lt;String, String&gt; schemaMappings = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;(mappings.size());</span><br><span class="line">        <span class="comment">// 放入缓存中</span></span><br><span class="line"> 		CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);</span><br><span class="line"> 		<span class="keyword">this</span>.schemaMappings = schemaMappings;</span><br><span class="line"> 	 &#125;<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"> 		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to load schema mappings from location ["</span> + <span class="keyword">this</span>.schemaMappingsLocation + <span class="string">"]"</span>, ex);</span><br><span class="line"> 	    &#125;</span><br><span class="line"> 	  &#125;</span><br><span class="line"> 	 &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">this</span>.schemaMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> publicId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> systemId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PluggableSchemaResolver#resolveEntity(String publicId, String systemId)&#123;</span><br><span class="line"> <span class="keyword">if</span> (systemId != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 根据 spring.schemas中配置的xxx.xsd找到对应的xsd文件</span></span><br><span class="line">	String resourceLocation = getSchemaMappings().get(systemId);</span><br><span class="line">	<span class="keyword">if</span> (resourceLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载xsd文件</span></span><br><span class="line">		Resource resource = <span class="keyword">new</span> ClassPathResource(resourceLocation, <span class="keyword">this</span>.classLoader);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			InputSource source = <span class="keyword">new</span> InputSource(resource.getInputStream());</span><br><span class="line">			source.setPublicId(publicId);</span><br><span class="line">			source.setSystemId(systemId);</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Found XML schema ["</span> + systemId + <span class="string">"] in classpath: "</span> + resourceLocation);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> source;</span><br><span class="line">			&#125;<span class="keyword">catch</span> (FileNotFoundException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Couldn't find XML schema ["</span> + systemId + <span class="string">"]: "</span> + resource, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是Spring在启动时加载spring.schemas中配置的xsd文件的几个代码片段，将XML配置文件解析成DOM的过程中，对每个标签及其属性进行校验，依据就是xsd中的约束条件。由于是Spring的源码部分，这里不进行深入分析，感兴趣的胖友可以自行调试。</p>
<h4 id="加载-spring-handlers-文件"><a href="#加载-spring-handlers-文件" class="headerlink" title="加载 spring.handlers 文件"></a>加载 spring.handlers 文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> doc 配置文件对应的DOM对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource 配置文件资源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XmlBeanDefinitionReader#registerBeanDefinitions(Document doc, Resource resource)&#123;</span><br><span class="line">  <span class="comment">// 创建Bean定义的DOMReader，用来读取、解析DOM，接着创建对应的Bean</span></span><br><span class="line">  BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">  <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">  <span class="comment">// 读取、解析DOM、创建对应的Bean</span></span><br><span class="line">  documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">  <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>registerBeanDefinitions方法是将Spring的XML配置文件中定义的有关标签进行创建并注册到Spring的注册表中。注意，这里所说的能够创建Bean的有关标签必须有对应的BeanDefinitionParser，否则不会对该标签进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource 配置文件资源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XmlBeanDefinitionReader#createReaderContext(Resource resource)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(</span><br><span class="line">        resource, </span><br><span class="line">        <span class="keyword">this</span>.problemReporter, </span><br><span class="line">        <span class="keyword">this</span>.eventListener,</span><br><span class="line">  		<span class="keyword">this</span>.sourceExtractor, </span><br><span class="line">        <span class="keyword">this</span>, </span><br><span class="line">        <span class="comment">// 读取 META-INF/spring.handlers 文件</span></span><br><span class="line">         getNamespaceHandlerResolver()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createReaderContext 方法用来创建 XmlReaderContext，该对象中包含的核心属性如下：<br><br></p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-spring-handlers.jpg" alt></p>
<p>由XmlReaderContext对象中的属性可知，在创建该对象的过程中对 META-INF/spring.handlers 文件进行了读取。现在有了配置文件的DOM对象、Bean定义工厂以及spring.handlers文件中各种NamespaceHandler，接下来就可以解析DOM树，创建并注册相应的Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DefaultBeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)&#123;</span><br><span class="line">  <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">  logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">  <span class="comment">// 获取DOM的根元素，一般是 beans</span></span><br><span class="line">  Element root = doc.getDocumentElement();</span><br><span class="line">  <span class="comment">// 解析入口</span></span><br><span class="line">  doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码主要是获取DOM对象的根元素，然后以这个根元素作为起点进行解析，下面我们接着解析代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment">* "import", "alias", "bean".</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> root DOM的根元素</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> delegate Bean定义解析器代理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">DefaultBeanDefinitionDocumentReader#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line"> <span class="comment">// 判读根元素是不是默认的命名空间 'http://www.springframework.org/schema/beans'</span></span><br><span class="line"> <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="comment">// 获取根元素下的子元素列表</span></span><br><span class="line">	NodeList nl = root.getChildNodes();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		Node node = nl.item(i);</span><br><span class="line">        <span class="comment">// 判断是否是元素</span></span><br><span class="line">		<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">		  Element ele = (Element) node;</span><br><span class="line">          <span class="comment">// 当前元素的命名空间如果是默认的命名空间即Spring自身的命名空间，则通过Spring自身逻辑进行解析</span></span><br><span class="line">		  <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">			 parseDefaultElement(ele, delegate);</span><br><span class="line">			&#125;</span><br><span class="line">           <span class="comment">// 当前元素的命名空间非默认的命名空间即自定义的标签，则通过自定义逻辑进行解析</span></span><br><span class="line">		  <span class="keyword">else</span> &#123;</span><br><span class="line">				delegate.parseCustomElement(ele);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	delegate.parseCustomElement(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的主要逻辑是判断要解析的DOM元素即标签，是否是Spring内置的，如果是Spring内置则整个解析逻辑使用Spring自身的那一套，如果是自定义的，则解析逻辑交给开发者。Spring自身的解析逻辑忽略，下面我们来分析下自定义的标签的处理流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element ele)&#123;</span><br><span class="line">  <span class="keyword">return</span> parseCustomElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ele DOM的根元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> containingBd </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element ele, org.springframework.beans.factory.config.BeanDefinition containingBd)&#123;</span><br><span class="line">        <span class="comment">// 获取元素即标签的命名空间</span></span><br><span class="line">        String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">        <span class="comment">// 使用 XmlReaderContext中的 DefaultNamespaceHandlerResolver获取命名空间对应的 NamespaceHandler对象</span></span><br><span class="line">    	NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    	 <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    		error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	   &#125;</span><br><span class="line">        <span class="comment">// 使用 NamespaceHandler 对象解析标签</span></span><br><span class="line">    	<span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码先是获取当前元素的命名空间，然后通过该命名空间获取对应 NamespaceHandler对象，最后通过该对象解析当前元素。下面我们依次分析这两个步骤的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">DefaultNamespaceHandlerResolver#resolve(String namespaceUri)&#123;</span><br><span class="line"><span class="comment">// 获取 DefaultNamespaceHandlerResolver#handlerMappings属性，即命名空间到NamespaceHandler的映射，注意这里的NamespaceHandler可能是还没有进行实例化的字符串</span></span><br><span class="line"> Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line"><span class="comment">// 从缓存中获取 NamespaceHandler</span></span><br><span class="line"> Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line"> <span class="keyword">if</span> (handlerOrClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 如果当前命名空间对应的 NamespaceHandler 就是 NamespaceHandler对象，则需要进行实例化，直接返回即可</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line"> 	<span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 当前命名空间对应的 NamespaceHandler 还是字符串，需要反射创建对象</span></span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> 	String className = (String) handlerOrClassName;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 获取当前 当前命名空间对应的 NamespaceHandler 串 的 Class</span></span><br><span class="line"> 	Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line"> 	<span class="keyword">if</span> (!NamespaceHandler<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">handlerClass</span>)) </span>&#123;</span><br><span class="line"> 		<span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Class ["</span> + className + <span class="string">"] for namespace ["</span> + namespaceUri +</span><br><span class="line"> 							"] does not implement the [" + NamespaceHandler.class.getName() + "] interface");</span><br><span class="line"> 	 &#125;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line"> 	NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">    <span class="comment">// 执行 init 方法，进行标签和BeanDefinitionParser 的关联 </span></span><br><span class="line"> 	namespaceHandler.init();</span><br><span class="line">    <span class="comment">// 加入缓存</span></span><br><span class="line"> 	handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line"> 		<span class="keyword">return</span> namespaceHandler;</span><br><span class="line"> 	&#125;<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"> 			<span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"NamespaceHandler class ["</span> + className + <span class="string">"] for namespace ["</span> +</span><br><span class="line"> 						namespaceUri + <span class="string">"] not found"</span>, ex);</span><br><span class="line"> 	&#125;<span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line"> 				<span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Invalid NamespaceHandler class ["</span> + className + <span class="string">"] for namespace ["</span> +</span><br><span class="line"> 						namespaceUri + <span class="string">"]: problem with handler class file or dependent class"</span>, err);</span><br><span class="line"> 			&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码核心是获取当前命名空间对应的 NamespaceHandler ，如果 NamespaceHandler 还是个字符串，那么就通过反射创建对象，接着调用该对象的 <code>init()</code>,进行标签和 BeanDefinitionParser 的关联 ，方法如果已经创建过了对象则直接返回该 NamespaceHandler 对象。由于Dubbo自定义标签的命名空间对应的NamespaceHandler是 DubboNamespaceHandler，我们在前面已经分析过了它的源码，这里再详细说明下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法中定义了每个&lt;xsd:element/&gt;对应的BeanDefinitionParser 【Dubbo Bean定义解析器】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"module"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"registry"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"monitor"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"protocol"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation"</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码比较直观，一个标签对应一个 DubboBeanDefinitionParser 对象，同时也对应这一个Dubbo的配置承载类。我们接下主要看registerBeanDefinitionParser方法是怎么把标签和DubboBeanDefinitionParser关联到一起的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamespaceHandlerSupport</span> <span class="keyword">implements</span> <span class="title">NamespaceHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * 标签名 到 BeanDefinitionParser 映射集合</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinitionParser&gt; parsers = <span class="keyword">new</span> HashMap&lt;String, BeanDefinitionParser&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 关联 标签名 到 BeanDefinitionParser</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitionParser</span><span class="params">(String elementName, BeanDefinitionParser parser)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.parsers.put(elementName, parser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来如此简单，就是调用父类 NamespaceHandlerSupport 的registerBeanDefinitionParser方法，将标签名到BeanDefinitionParser的映射保存到缓存中。到了这里所有解析前的工作已经准备就绪，终于可以进入到这篇文章的核心部分了。之所以用了那么多的铺垫，就是想把整个过程串起来，如果一下子进入到Dubbo自定义标签的解析感觉还是挺奇怪的，毕竟笔者对Spring的源码也不熟悉，就按部就班吧。</p>
<h3 id="解析标签"><a href="#解析标签" class="headerlink" title="解析标签"></a>解析标签</h3><p>解析准备是特意为解析标签做的铺垫，有了这个铺垫下面的解析逻辑就容易很多了。我们接着解析准备中的 <code>parseCustomElement</code> 方法继续分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 1. 获取DOM元素即标签对应的命名空间</span></span><br><span class="line">   String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">   <span class="comment">// 2. 获取命名空间映射的 NamespaceHandler对象</span></span><br><span class="line">   NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">	<span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">		error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">    <span class="comment">// 3. 调用 NamespaceHandler对象 的parse方法进行解析</span></span><br><span class="line">	<span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的第3步才正式进入到标签的解析，这里的 NamespaceHandler 就 DubboNamespaceHandler对象，<code>parse</code> 方法是其父类 NamespaceHandlerSupport 中的方法，我们来看看逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1. 获取标签的名称关联的 BeanDefinitionParser</span></span><br><span class="line"><span class="comment">        * 2. 使用 BeanDefinitionParser解析标签</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">	<span class="keyword">return</span> findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取标签名</span></span><br><span class="line">	String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">       <span class="comment">// 从缓存中获取标签名对应的 BeanDefinitionParser对象，即 DubboBeanDefinitionParser对象</span></span><br><span class="line">	BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line">	<span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">		parserContext.getReaderContext().fatal(</span><br><span class="line">				<span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就是从 标签名 到 BeanDefinitionParser 映射集合parsers中获取标签名对应的BeanDefinitionParser对象，该映射集合是在 DubboNamespaceHandler#init 方法执行时维护的。下面我们接着分析DubboBeanDefinitionParser类。</p>
<h4 id="Dubbo-Bean定义解析器"><a href="#Dubbo-Bean定义解析器" class="headerlink" title="Dubbo Bean定义解析器"></a>Dubbo Bean定义解析器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标签元素对应的对象类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; beanClass;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否需要Bean的 id 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> required;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass Bean 对象的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> required  是否需要在Bean对象的编号（id）不存在时自动生成编号。无需被其他应用引用的配置对象，无需自动生成编号。 eg：&lt;dubbo:reference/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBeanDefinitionParser</span><span class="params">(Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClass = beanClass;</span><br><span class="line">        <span class="keyword">this</span>.required = required;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring解析标签的入口方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element       标签元素对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parserContext 解析上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parse(element, parserContext, beanClass, required);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略的代码&#125;</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DubboBeanDefinitionParser实现了Spring的BeanDefinitionParser接口，即Spring的Bean定义解析器。该类中有两个重要属性，<code>beanClass</code> 和 <code>required</code>，这两个属性的值是在创建Dubbo的Bean定义解析器时通过构造方法传入的，分别是标签元素对应的配置类和在创建配置Bean的时候可能需要i的d属性。<code>parse</code>方法是解析XML元素的主流程的入口，其中 parserContext 参数是XML解析的上下文，它包含了 XmlReaderContext 这个重要对象，而该对象中又包含了BeanFactory等信息，具体如下图:<br><br></p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-parsercontext.jpg" alt></p>
<p>有了BeanFactory就可以实现Bean的定义了，接下来我们继续分析Dubbo是如何处理自定义标签与对应的配置类之间的关系，以及怎样创建标签对应的Bean定义的。</p>
<h4 id="创建Bean定义并注册到Spring上下文"><a href="#创建Bean定义并注册到Spring上下文" class="headerlink" title="创建Bean定义并注册到Spring上下文"></a>创建Bean定义并注册到Spring上下文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> element       标签对应的DOM</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parserContext spring 解析上下文</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> beanClass     标签对应的配置类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> required 在创建Bean定义的时候是否需要id</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 标签对应的配置类的Bean定义</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 生成Spring的Bean定义，指定beanClass交给Spring反射创建实例</span></span><br><span class="line">      RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">      beanDefinition.setBeanClass(beanClass);</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 设置Bean初始化方式，默认设置为延迟加载。</span></span><br><span class="line"><span class="comment">       * 需要说明的是，引用缺省是延迟初始化的，只有引用被注入到其它Bean或者getBean() 获取才会初始化。如果需要立即初始化可以配置： &lt;dubbo:reference init="true"/&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      beanDefinition.setLazyInit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//--------------------------- 确保Spring 容器中没有重复的Bean定义 开始  ------------------------/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析标签对象的id属性</span></span><br><span class="line">      String id = element.getAttribute(<span class="string">"id"</span>);</span><br><span class="line">      <span class="comment">// 标签没有设置id属性，并且创建的Bean定义需要id时，就执行生成id的逻辑。需要注意的是，Dubbo的reference标签对应Bean定义不需要id</span></span><br><span class="line">      <span class="keyword">if</span> ((id == <span class="keyword">null</span> || id.length() == <span class="number">0</span>) &amp;&amp; required) &#123;</span><br><span class="line">          <span class="comment">// 1. 取name属性值</span></span><br><span class="line">          String generatedBeanName = element.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">          <span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span> || generatedBeanName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 2. 也没有设置name属性，此时如果当前标签是Protocol，那么id的值就直接设置为 'dubbo'，非Protocol协议则尝试取标签的interface属性值</span></span><br><span class="line">              <span class="keyword">if</span> (ProtocolConfig<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">beanClass</span>)) </span>&#123;</span><br><span class="line">                  generatedBeanName = <span class="string">"dubbo"</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  generatedBeanName = element.getAttribute(<span class="string">"interface"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 3. 以上过程都没有生成id，则最后使用标签对应的配置类的类名</span></span><br><span class="line">          <span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span> || generatedBeanName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">              generatedBeanName = beanClass.getName();</span><br><span class="line">          &#125;</span><br><span class="line">          id = generatedBeanName;</span><br><span class="line">          <span class="keyword">int</span> counter = <span class="number">2</span>;</span><br><span class="line">          <span class="comment">// 检查Spring注册表中是否存在标识id，存在就通过自增序列继续处理id,使其唯一</span></span><br><span class="line">          <span class="keyword">while</span> (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class="line">              id = generatedBeanName + (counter++);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate spring bean id "</span> + id);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 把标签对应的配置类的Bean定义注册到Spring，Bean 名称为id</span></span><br><span class="line">          parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);</span><br><span class="line">          <span class="comment">// 为Bean追加id属性</span></span><br><span class="line">          beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"id"</span>, id);</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">// $&#123;省略的代码&#125;</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="特殊处理protocol标签"><a href="#特殊处理protocol标签" class="headerlink" title="特殊处理protocol标签"></a>特殊处理protocol标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element       标签对应的DOM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parserContext spring 解析上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass     标签对应的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> required 在创建Bean定义的时候是否需要id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 标签对应的配置类的Bean定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// $&#123;省略的代码&#125;    </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ProtocolConfig<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">beanClass</span>)) </span>&#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 以下代码逻辑需要满足：</span></span><br><span class="line"><span class="comment">                * 顺序需要这样：</span></span><br><span class="line"><span class="comment">                * 1 &lt;dubbo:service interface="com.xxx.xxxService protocol="dubbo" ref="xxxServiceImpl"/&gt;</span></span><br><span class="line"><span class="comment">                * 2 &lt;dubbo:protocol id ="dubbo" name="dubbo" port="20880"/&gt;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="comment">// 获取Bean注册表中所有的Bean id</span></span><br><span class="line">               <span class="keyword">for</span> (String name : parserContext.getRegistry().getBeanDefinitionNames()) &#123;</span><br><span class="line">                   <span class="comment">// 根据id获取Bean定义</span></span><br><span class="line">                   BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);</span><br><span class="line">                   <span class="comment">// 获取当前Bean定义的属性对象集合，并尝试获取属性名为 'protocol' 的属性对象</span></span><br><span class="line">                   PropertyValue property = definition.getPropertyValues().getPropertyValue(<span class="string">"protocol"</span>);</span><br><span class="line">                   <span class="keyword">if</span> (property != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 获取属性值</span></span><br><span class="line">                       Object value = property.getValue();</span><br><span class="line">                       <span class="comment">// 如果当前遍历的Bean定义中的属性满足条件，就更新该Bean的 protocol 属性值，即名称为id的RuntimeBeanReference对象</span></span><br><span class="line">                       <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) &#123;</span><br><span class="line">                           definition.getPropertyValues().addPropertyValue(<span class="string">"protocol"</span>, <span class="keyword">new</span> RuntimeBeanReference(id));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// $&#123;省略的代码&#125; </span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码用来处理框架中那些属性名为’protocol’且属性类型为为ProtocolConfig的Bean，如果该Bean符合条件就更新该Bean的protocol属性值。</p>
<h4 id="特殊处理service标签"><a href="#特殊处理service标签" class="headerlink" title="特殊处理service标签"></a>特殊处理service标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element       标签对应的DOM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parserContext spring 解析上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass     标签对应的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> required 在创建Bean定义的时候是否需要id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 标签对应的配置类的Bean定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// $&#123;省略的代码&#125;    </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ServiceBean<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">beanClass</span>)) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果&lt;dubbo:service&gt;配置了class属性，那么为具体class配置的类创建Bean定义，并且把该定义注入到Service的 ref属性。一般不这么使用。</span></span><br><span class="line">            <span class="comment">// eg: &lt;dubbo:service interface="com.alibaba.dubbo.demo.DemoService class="com.alibaba.dubbo.demo.provider.DemoServiceImpl"/&gt;</span></span><br><span class="line">            String className = element.getAttribute(<span class="string">"class"</span>);</span><br><span class="line">            <span class="keyword">if</span> (className != <span class="keyword">null</span> &amp;&amp; className.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                RootBeanDefinition classDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">                classDefinition.setBeanClass(ReflectUtils.forName(className));</span><br><span class="line">                classDefinition.setLazyInit(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 解析 &lt;dubbo:service class="xxx"/&gt; 情况下内嵌的&lt;property/&gt;标签，然后设置到classDefinition的属性中</span></span><br><span class="line">                parseProperties(element.getChildNodes(), classDefinition);</span><br><span class="line">                <span class="comment">// 设置ref属性，相当于设置 &lt;dubbo:service ref=""/&gt;属性</span></span><br><span class="line">                beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"ref"</span>, <span class="keyword">new</span> BeanDefinitionHolder(classDefinition, id + <span class="string">"Impl"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略的代码&#125;    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码用来处理 <code>service标签</code> 中有 class 属性的情况，处理逻辑就是创建class对应的Bean定义，然后设置到 <code>service标签</code> 对应的Bean的ref属性中。我们再来看看对service的子标签 <code>property</code> 的解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析 &lt;dubbo:service class="xxx"/&gt; 情况下内嵌的&lt;property/&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodeList       子元素数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanDefinition Bean定义对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseProperties</span><span class="params">(NodeList nodeList, RootBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeList != <span class="keyword">null</span> &amp;&amp; nodeList.getLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">            Node node = nodeList.item(i);</span><br><span class="line">            <span class="comment">// 只解析&lt;property/&gt;标签</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"property"</span>.equals(node.getNodeName())</span><br><span class="line">                        || <span class="string">"property"</span>.equals(node.getLocalName())) &#123;</span><br><span class="line">                    String name = ((Element) node).getAttribute(<span class="string">"name"</span>);</span><br><span class="line">                    <span class="comment">// 优先使用value属性，其次使用ref属性</span></span><br><span class="line">                    <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        String value = ((Element) node).getAttribute(<span class="string">"value"</span>);</span><br><span class="line">                        String ref = ((Element) node).getAttribute(<span class="string">"ref"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            beanDefinition.getPropertyValues().addPropertyValue(name, value);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ref != <span class="keyword">null</span> &amp;&amp; ref.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            beanDefinition.getPropertyValues().addPropertyValue(name, <span class="keyword">new</span> RuntimeBeanReference(ref));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 属性不全，抛出异常</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Unsupported &lt;property name=\""</span> + name + <span class="string">"\"&gt; sub tag, Only supported &lt;property name=\""</span> + name + <span class="string">"\" ref=\"...\" /&gt; or &lt;property name=\""</span> + name + <span class="string">"\" value=\"...\" /&gt;"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码用来解析service的property标签，目的是为service标签的class属性对应的Bean定义设置属性，比较简单。</p>
<h4 id="特殊处理provider-consumer标签"><a href="#特殊处理provider-consumer标签" class="headerlink" title="特殊处理provider/consumer标签"></a>特殊处理provider/consumer标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element       标签对应的DOM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parserContext spring 解析上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass     标签对应的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> required 在创建Bean定义的时候是否需要id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 标签对应的配置类的Bean定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// $&#123;省略的代码&#125;   </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ProviderConfig<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">beanClass</span>)) </span>&#123;</span><br><span class="line">        <span class="comment">// 解析 &lt;dubbo:provider/&gt; 的内嵌子元素&lt;dubbo:service/&gt;</span></span><br><span class="line">       parseNested(element, parserContext, ServiceBean.class, true, "service", "provider", id, beanDefinition);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ConsumerConfig<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">beanClass</span>)) </span>&#123;</span><br><span class="line">       <span class="comment">// 解析 &lt;dubbo:consumer/&gt; 的内嵌子元素&lt;dubbo:reference/&gt;</span></span><br><span class="line">       parseNested(element, parserContext, ReferenceBean.class, false, "reference", "consumer", id, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略的代码&#125;</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，特殊处理provider/consumer标签就是处理它有service/reference子标签的情况，代码过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析内嵌的标签</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> element        父标签对象 - provider/consumer标签对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parserContext  Spring解析上下文</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanClass      内嵌子元素的Bean类 - ServiceBean/ReferenceBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> required       是否需要Bean的id属性</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> tag            子元素标签名  service/reference</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> property       父Bean对象在子元素中的属性名 provider/consumer</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ref            父Bean的id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanDefinition 父Bean定义对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseNested</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required, String tag, String property, String ref, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取子节点列表</span></span><br><span class="line">       NodeList nodeList = element.getChildNodes();</span><br><span class="line">       <span class="keyword">if</span> (nodeList != <span class="keyword">null</span> &amp;&amp; nodeList.getLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">               <span class="comment">// 获取子节点</span></span><br><span class="line">               Node node = nodeList.item(i);</span><br><span class="line">               <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                   <span class="comment">// 当前节点是否是指定的子节点，这里可能是service/reference节点</span></span><br><span class="line">                   <span class="keyword">if</span> (tag.equals(node.getNodeName()) || tag.equals(node.getLocalName())) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                           first = <span class="keyword">false</span>;</span><br><span class="line">                           <span class="comment">// 获取父节点的default的属性值 [暂时不知道有什么用]</span></span><br><span class="line">                           String isDefault = element.getAttribute(<span class="string">"default"</span>);</span><br><span class="line">                           <span class="keyword">if</span> (isDefault == <span class="keyword">null</span> || isDefault.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                               beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"default"</span>, <span class="string">"false"</span>);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 解析子元素，创建BeanDefinition 对象 （递归）</span></span><br><span class="line">                       BeanDefinition subDefinition = parse((Element) node, parserContext, beanClass, required);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 设置子BeanDefinition的指向，指向父BeanDefinition</span></span><br><span class="line">                       <span class="keyword">if</span> (subDefinition != <span class="keyword">null</span> &amp;&amp; ref != <span class="keyword">null</span> &amp;&amp; ref.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           subDefinition.getPropertyValues().addPropertyValue(property, <span class="keyword">new</span> RuntimeBeanReference(ref));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码主要处理provider/consumer标签内部嵌套的标签，内部嵌套的标签对象会自动持有外层标签的对象。</p>
<h4 id="设置标签的属性到-BeanDefinition"><a href="#设置标签的属性到-BeanDefinition" class="headerlink" title="设置标签的属性到 BeanDefinition"></a>设置标签的属性到 BeanDefinition</h4><p>前面处理的逻辑属于特殊的情况，接下来我们分析标签的属性是如何设置到配置对象中的。本质上是通过遍历配置对象的get、set和is前缀方法，通过反射将标签属性设置到配置对象中。总体上分为两种情况：</p>
<ul>
<li>如果标签属性和方法名相同，则通过反射调用设置标签的值到配置对象中。</li>
<li>如果标签属性不能匹配到配置对象中的方法名称，则将标签属性当作parameter参数设置到配置对象中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element       标签对应的DOM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parserContext spring 解析上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass     标签对应的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> required 在创建Bean定义的时候是否需要id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 标签对应的配置类的Bean定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// $&#123;省略的代码&#125;   </span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 用来保存已遍历的配置对象的属性集合，用来判断标签中哪些属性没有匹配上</span></span><br><span class="line">        Set&lt;String&gt; props = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 专门存放&lt;dubbo:parameters/&gt; 标签下子标签属性信息。最后都设置到Bean定义中</span></span><br><span class="line">        ManagedMap parameters = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取配置对象所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method setter : beanClass.getMethods()) &#123;</span><br><span class="line">            String name = setter.getName();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 选择所有set前缀方法，并且只有一个参数的 public 方法</span></span><br><span class="line">            <span class="keyword">if</span> (name.length() &gt; <span class="number">3</span> &amp;&amp; name.startsWith(<span class="string">"set"</span>) &amp;&amp; Modifier.isPublic(setter.getModifiers()) &amp;&amp; setter.getParameterTypes().length == <span class="number">1</span>) &#123;</span><br><span class="line">               </span><br><span class="line">                <span class="comment">// 获取方法的参数类型</span></span><br><span class="line">                Class&lt;?&gt; type = setter.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 3. 提取set对应的属性名字，eg: setTimeout-&gt;timeout,setBeanName-&gt;bean-name</span></span><br><span class="line">                String property = StringUtils.camelToSplitName(name.substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + name.substring(<span class="number">4</span>), <span class="string">"-"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保存到属性 props 集合中</span></span><br><span class="line">                props.add(property);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4. 尝试获取属性对应的getter方法</span></span><br><span class="line">                Method getter = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    getter = beanClass.getMethod(<span class="string">"get"</span> + name.substring(<span class="number">3</span>), <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; <span class="comment">// 没有setter对应的getter方法，尝试获取is方法，is方法在功能上是同getter</span></span><br><span class="line">                        getter = beanClass.getMethod(<span class="string">"is"</span> + name.substring(<span class="number">3</span>), <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchMethodException e2) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 校验属性是否有对应的getter/is前缀方法，没有就跳过</span></span><br><span class="line">                <span class="keyword">if</span> (getter == <span class="keyword">null</span></span><br><span class="line">                        || !Modifier.isPublic(getter.getModifiers())</span><br><span class="line">                        || !type.equals(getter.getReturnType())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6. 解析 &lt;dubbo:parameter/&gt; 标签，将当前标签element的子标签 &lt;dubbo:parameter/&gt; 的属性键值对保存到parameters中</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"parameters"</span>.equals(property)) &#123;</span><br><span class="line">                    parameters = parseParameters(element.getChildNodes(), beanDefinition);</span><br><span class="line">                    <span class="comment">// 7. 解析 &lt;dubbo:method/&gt; 标签，将当前标签element的子标签  &lt;dubbo:method/&gt; 进行解析，将解析得到的对应BeanDefiniton放入到ManagedList集合中，最后作为 beanDefiniton的methods属性值。</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"methods"</span>.equals(property)) &#123;</span><br><span class="line">                    parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);</span><br><span class="line">                    <span class="comment">// 8. 解析 &lt;dubbo:argument/&gt;标签，将当前标签element的子标签 &lt;dubbo:argument/&gt; 进行解析，将解析得到的对应的BeanDefinition放入到ManagedList集合中，最后作为 beanDefinition的arguments属性值。</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"arguments"</span>.equals(property)) &#123;</span><br><span class="line">                    parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 9. 获取标签属性的值 【前面的步骤之所以单独处理，是因为当前配置配置对象对应的属性不是一个标签属性，而是一个子标签】</span></span><br><span class="line">                    String value = element.getAttribute(property);</span><br><span class="line">                    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        value = value.trim();</span><br><span class="line">                        <span class="keyword">if</span> (value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 9.1 标签中配置了 registry=N/A, 不想注册到的情况</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="string">"registry"</span>.equals(property) &amp;&amp; RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) &#123;</span><br><span class="line">                                RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">                                <span class="comment">// RegistryConfig的地址设置 N/A</span></span><br><span class="line">                                registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);</span><br><span class="line">                                beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);</span><br><span class="line">                                <span class="comment">// 9.2 多注册中心情况，将多个注册中心处理成一个集合，然后设置到 beanDefiniton 中，属性名为 'registries'</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"registry"</span>.equals(property) &amp;&amp; value.indexOf(<span class="string">','</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                parseMultiRef(<span class="string">"registries"</span>, value, beanDefinition, parserContext);</span><br><span class="line">                                <span class="comment">// 9.3 多服务提供者情况，将多个服务提供者处理成一个集合，然后设置到 beanDefinition 中，属性为 'providers'</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"provider"</span>.equals(property) &amp;&amp; value.indexOf(<span class="string">','</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                parseMultiRef(<span class="string">"providers"</span>, value, beanDefinition, parserContext);</span><br><span class="line">                                <span class="comment">// 9.4 多协议情况，将多个协议处理成一个集合，然后设置到 beanDefinition 中，属性为 'protocols'</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"protocol"</span>.equals(property) &amp;&amp; value.indexOf(<span class="string">','</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                parseMultiRef(<span class="string">"protocols"</span>, value, beanDefinition, parserContext);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                Object reference;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 10. 属性类型为基本类型的情况</span></span><br><span class="line">                                <span class="keyword">if</span> (isPrimitive(type)) &#123;</span><br><span class="line">                                    <span class="comment">// 兼容性处理【一些设置了但是意义不大的属性就把值设置为null】</span></span><br><span class="line">                                    <span class="keyword">if</span> (<span class="string">"async"</span>.equals(property) &amp;&amp; <span class="string">"false"</span>.equals(value)</span><br><span class="line">                                            || <span class="string">"timeout"</span>.equals(property) &amp;&amp; <span class="string">"0"</span>.equals(value)</span><br><span class="line">                                            || <span class="string">"delay"</span>.equals(property) &amp;&amp; <span class="string">"0"</span>.equals(value)</span><br><span class="line">                                            || <span class="string">"version"</span>.equals(property) &amp;&amp; <span class="string">"0.0.0"</span>.equals(value)</span><br><span class="line">                                            || <span class="string">"stat"</span>.equals(property) &amp;&amp; <span class="string">"-1"</span>.equals(value)</span><br><span class="line">                                            || <span class="string">"reliable"</span>.equals(property) &amp;&amp; <span class="string">"false"</span>.equals(value)) &#123;</span><br><span class="line">                                        <span class="comment">// backward compatibility for the default value in old version's xsd</span></span><br><span class="line">                                        value = <span class="keyword">null</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    reference = value;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//11. 处理在&lt;dubbo:provider/&gt; 或者 &lt;dubbo:service/&gt; 上定义了 protocol 属性的兼容性，目前已经不推荐这样使用了，应该单独配置 &lt;dubbo:protocol/&gt;</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"protocol"</span>.equals(property)</span><br><span class="line">                                        &amp;&amp; ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">value</span>)</span></span><br><span class="line"><span class="class">                                        &amp;&amp; (!<span class="title">parserContext</span>.<span class="title">getRegistry</span>().<span class="title">containsBeanDefinition</span>(<span class="title">value</span>)</span></span><br><span class="line"><span class="class">                                        || !<span class="title">ProtocolConfig</span>.<span class="title">class</span>.<span class="title">getName</span>().<span class="title">equals</span>(<span class="title">parserContext</span>.<span class="title">getRegistry</span>().<span class="title">getBeanDefinition</span>(<span class="title">value</span>).<span class="title">getBeanClassName</span>()))) </span>&#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (<span class="string">"dubbo:provider"</span>.equals(element.getTagName())) &#123;</span><br><span class="line">                                        logger.warn(<span class="string">"Recommended replace &lt;dubbo:provider protocol=\""</span> + value + <span class="string">"\" ... /&gt; to &lt;dubbo:protocol name=\""</span> + value + <span class="string">"\" ... /&gt;"</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="comment">// backward compatibility</span></span><br><span class="line">                                    ProtocolConfig protocol = <span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">                                    protocol.setName(value);</span><br><span class="line">                                    reference = protocol;</span><br><span class="line"></span><br><span class="line">                              <span class="comment">//------- 12. 事件通知: 在调用前，调用后，出现异常，会触发oninvoke，onreturn,onthrow三个事件，可以配置当事件发生时，通知哪个类的哪个方法  ------//</span></span><br><span class="line">                              <span class="comment">/*</span></span><br><span class="line"><span class="comment">                              // 格式：实现Bean.方法</span></span><br><span class="line"><span class="comment">                              &lt;bean id="demoCallBack" class = "com.alibaba.dubbo.callback.implicit.NofifyImpl"/&gt;</span></span><br><span class="line"><span class="comment">                              &lt;dubbo:reference id = "demoService" interface="com.alibaba.dubbo.IDemoService"&gt;</span></span><br><span class="line"><span class="comment">                                  &lt;dubbo:method name="get" onreturn="demoCallBack.xxxMethod" onthrow="demoCallBack.xMethod"/&gt;</span></span><br><span class="line"><span class="comment">                              &lt;/dubbo:reference&gt;</span></span><br><span class="line"><span class="comment">                               */</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 12.1 处理 onreturn 属性</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"onreturn"</span>.equals(property)) &#123;</span><br><span class="line">                                    <span class="comment">// 按照 . 拆分</span></span><br><span class="line">                                    <span class="keyword">int</span> index = value.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">                                    <span class="comment">// 获取实例名</span></span><br><span class="line">                                    String returnRef = value.substring(<span class="number">0</span>, index);</span><br><span class="line">                                    <span class="comment">// 获取实例的方法</span></span><br><span class="line">                                    String returnMethod = value.substring(index + <span class="number">1</span>);</span><br><span class="line">                                    <span class="comment">// 创建 RuntimeBeanReference，指向回调的对象</span></span><br><span class="line">                                    reference = <span class="keyword">new</span> RuntimeBeanReference(returnRef);</span><br><span class="line">                                    <span class="comment">// 设置 onreturnMethod 到 BeanDefinition 的属性值</span></span><br><span class="line">                                    beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"onreturnMethod"</span>, returnMethod);</span><br><span class="line">                                    <span class="comment">// 12.2 处理 onthrow 属性</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"onthrow"</span>.equals(property)) &#123;</span><br><span class="line">                                    <span class="keyword">int</span> index = value.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">                                    String throwRef = value.substring(<span class="number">0</span>, index);</span><br><span class="line">                                    String throwMethod = value.substring(index + <span class="number">1</span>);</span><br><span class="line">                                    <span class="comment">// 创建 RuntimeBeanReference，指向回调的对象</span></span><br><span class="line">                                    reference = <span class="keyword">new</span> RuntimeBeanReference(throwRef);</span><br><span class="line">                                    <span class="comment">// 设置 onthrowMethod 到 BeanDefinition 的属性值</span></span><br><span class="line">                                    beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"onthrowMethod"</span>, throwMethod);</span><br><span class="line">                                    <span class="comment">//12.3  处理oninvoke 属性</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"oninvoke"</span>.equals(property)) &#123;</span><br><span class="line">                                    <span class="keyword">int</span> index = value.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">                                    String invokeRef = value.substring(<span class="number">0</span>, index);</span><br><span class="line">                                    String invokeRefMethod = value.substring(index + <span class="number">1</span>);</span><br><span class="line">                                    reference = <span class="keyword">new</span> RuntimeBeanReference(invokeRef);</span><br><span class="line">                                    beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"oninvokeMethod"</span>, invokeRefMethod);</span><br><span class="line">                                 </span><br><span class="line">                              <span class="comment">//-----------------------------  事件通知结束 ------------------------------//</span></span><br><span class="line">                                  </span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// 13. 属性名没有匹配到对应的标签名，都会到这里</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//13.1 如果属性名是ref, ref 对应的Bean 必须是单例的 </span></span><br><span class="line">                                    <span class="keyword">if</span> (<span class="string">"ref"</span>.equals(property) &amp;&amp; parserContext.getRegistry().containsBeanDefinition(value)) &#123;</span><br><span class="line">                                        BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);</span><br><span class="line">                                        <span class="keyword">if</span> (!refBean.isSingleton()) &#123;</span><br><span class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The exported service ref "</span> + value + <span class="string">" must be singleton! Please set the "</span> + value + <span class="string">" bean scope to singleton, eg: &lt;bean id=\""</span> + value + <span class="string">"\" scope=\"singleton\" ...&gt;"</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="comment">// 创建RuntimeBeanReference</span></span><br><span class="line">                                    reference = <span class="keyword">new</span> RuntimeBeanReference(value);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 设置Bean定义的属性</span></span><br><span class="line">                                beanDefinition.getPropertyValues().addPropertyValue(property, reference);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将标签中自定义的属性（不是Dubbo Schema 约定好的）也加入到 parameters 集合中</span></span><br><span class="line">        NamedNodeMap attributes = element.getAttributes();</span><br><span class="line">        <span class="keyword">int</span> len = attributes.getLength();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            Node node = attributes.item(i);</span><br><span class="line">            String name = node.getLocalName();</span><br><span class="line">            <span class="keyword">if</span> (!props.contains(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parameters == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    parameters = <span class="keyword">new</span> ManagedMap();</span><br><span class="line">                &#125;</span><br><span class="line">                String value = node.getNodeValue();</span><br><span class="line">                parameters.put(name, <span class="keyword">new</span> TypedStringValue(value, String<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">            beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"parameters"</span>, parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是把属性注入到标签对应的BeanDefinition，如果属性是引用对象，Dubbo默认会创建 <code>RuntimeBeanReference</code> 类型注入，运行时由Spring注入引用对象。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Dubbo框架解析配置文件生成BeanDefinition其实是生成标签对应的配置类的Bean定义，Bean定义中的属性值主要来源于标签的属性值，Dubbo对标签属性只是进行了提取，标签的内嵌标签处理也是如此，运行时属性注入和转换都还是Spring来完成的，Dubbo框架生成的BeanDefinition最终会委托Spring创建对应的对象，这个属于Spring的流程就不多说了。dubbo.xsd文件中定义的类型都会有与之对应的配置承载类中的属性，我们已经在API配置中介绍过了。XML配置解析还是挺复杂的，分支流比较多，下一章要分析的注解配置稍微比这个复杂一些。随着后面深入的分析就会发现这些东西都是基础，结合Dubbo的整个过程就很容易理解了。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/a8d76a91/" title="Dubbo源码分析 - XML配置" target="_blank" rel="external">https://gentryhuang.com/posts/a8d76a91/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/1a889dcd/" title="Dubbo源码分析 - 注解配置"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/1d3295e6/" title="Dubbo源码分析 - API和属性配置"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2024 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>