<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Dubbo源码分析 - 异步改造 | gentryhuang的博客</title>
  <meta name="description" content="概述从 2.7.0 版本开始，Dubbo 的所有异步编程接口开始以 CompletableFuture 为基础，不仅支持了服务提供方的异步执行，而且对当前的异步调用功能进行了增强。异步改造引入了一些功能接口和实现，以及对部分逻辑进行了调整，但底层逻辑并没有改变，本篇文章将对 Dubbo 的异步演进进行介绍。 调用方式 Dubbo 的远程调用中大致可以分为以上 4 种调用方式：  oneway: 客">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo源码分析 - 异步改造">
<meta property="og:url" content="https://gentryhuang.com/posts/c812f120/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="概述从 2.7.0 版本开始，Dubbo 的所有异步编程接口开始以 CompletableFuture 为基础，不仅支持了服务提供方的异步执行，而且对当前的异步调用功能进行了增强。异步改造引入了一些功能接口和实现，以及对部分逻辑进行了调整，但底层逻辑并没有改变，本篇文章将对 Dubbo 的异步演进进行介绍。 调用方式 Dubbo 的远程调用中大致可以分为以上 4 种调用方式：  oneway: 客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-invoke-model.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-invoke-transform-result-uml.jpg">
<meta property="article:published_time" content="2021-02-13T16:00:00.000Z">
<meta property="article:modified_time" content="2021-04-06T08:30:21.668Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="Dubbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-invoke-model.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/c812f120/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.38px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.75px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.13px;">I/O</a> <a href="/tags/JUC/" style="font-size: 13.5px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.25px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.13px;">Lock</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.25px;">Protocol</a> <a href="/tags/RPC/" style="font-size: 13.63px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.13px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.25px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.25px;">Spring</a> <a href="/tags/Thread/" style="font-size: 13.13px;">Thread</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.88px;">设计模式</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/ae5dbc38/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a>
              </p>
              <p class="item-title">
                <a href="/posts/ae5dbc38/" class="title">网络通信 - Reactor模型</a>
              </p>
              <p class="item-date">
                <time datetime="2021-09-12T13:10:23.000Z" itemprop="datePublished">2021-09-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/151f44ae/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/151f44ae/" class="title">并发 - ThreadLocal</a>
              </p>
              <p class="item-date">
                <time datetime="2021-09-03T04:30:12.000Z" itemprop="datePublished">2021-09-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/55ae5a2b/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/55ae5a2b/" class="title">Java基础 - Reference</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-21T02:30:12.000Z" itemprop="datePublished">2021-08-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/dbdf391f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/dbdf391f/" class="title">并发 - Thread</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-14T13:50:21.000Z" itemprop="datePublished">2021-08-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/1d01ceec/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a>
              </p>
              <p class="item-title">
                <a href="/posts/1d01ceec/" class="title">时间轮算法 - HashedWheelTimer</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-24T02:06:24.000Z" itemprop="datePublished">2021-07-24</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#调用方式"><span class="toc-number">2.</span> <span class="toc-text">调用方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dubbo-2-6-x-异步实现"><span class="toc-number">3.</span> <span class="toc-text">Dubbo 2.6.x 异步实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现方式"><span class="toc-number">3.1.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存在问题"><span class="toc-number">3.2.</span> <span class="toc-text">存在问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dubbo-2-7-x-异步实现"><span class="toc-number">4.</span> <span class="toc-text">Dubbo 2.7.x 异步实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础模型"><span class="toc-number">4.1.</span> <span class="toc-text">基础模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Result"><span class="toc-number">4.1.1.</span> <span class="toc-text">Result</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AppResponse"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">AppResponse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DecodeableRpcResult"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">DecodeableRpcResult</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#属性"><span class="toc-number">4.1.1.2.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解码"><span class="toc-number">4.1.1.2.2.</span> <span class="toc-text">解码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CompletableFuture"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">CompletableFuture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncRpcResult"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">AsyncRpcResult</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#属性-1"><span class="toc-number">4.1.1.4.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取结果"><span class="toc-number">4.1.1.4.2.</span> <span class="toc-text">获取结果</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#获取-CompletableFuture"><span class="toc-number">4.1.1.4.2.1.</span> <span class="toc-text">获取 CompletableFuture</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#获取-AppResponse"><span class="toc-number">4.1.1.4.2.2.</span> <span class="toc-text">获取 AppResponse</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#获取结果-1"><span class="toc-number">4.1.1.4.2.3.</span> <span class="toc-text">获取结果</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#添加回调"><span class="toc-number">4.1.1.4.2.4.</span> <span class="toc-text">添加回调</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Invoker"><span class="toc-number">4.1.2.</span> <span class="toc-text">Invoker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncToSyncInvoker"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">AsyncToSyncInvoker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractProxyInvoker"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">AbstractProxyInvoker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractInvoker"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">AbstractInvoker</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#构造方法"><span class="toc-number">4.1.2.3.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#invoke-方法"><span class="toc-number">4.1.2.3.2.</span> <span class="toc-text">invoke 方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo协议异步实现"><span class="toc-number">4.2.</span> <span class="toc-text">Dubbo协议异步实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#消费端"><span class="toc-number">4.2.1.</span> <span class="toc-text">消费端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务端"><span class="toc-number">4.2.2.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#异步实现"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">异步实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定义-CompletableFuture-签名接口"><span class="toc-number">4.2.2.1.1.</span> <span class="toc-text">定义 CompletableFuture 签名接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#服务消费方"><span class="toc-number">4.2.2.1.2.</span> <span class="toc-text">服务消费方</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#结果"><span class="toc-number">4.2.2.1.3.</span> <span class="toc-text">结果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HeaderExchangeHandler-处理请求"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">HeaderExchangeHandler 处理请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DubboProtocol-的处理器"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">DubboProtocol 的处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractProxyInvoker-1"><span class="toc-number">4.2.2.4.</span> <span class="toc-text">AbstractProxyInvoker</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-协议实现"><span class="toc-number">4.3.</span> <span class="toc-text">HTTP 协议实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#消费端-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">消费端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务端-1"><span class="toc-number">4.3.2.</span> <span class="toc-text">服务端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-rpc/Dubbo异步改造" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Dubbo源码分析 - 异步改造
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/c812f120/" class="article-date">
	  <time datetime="2021-02-13T16:00:00.000Z" itemprop="datePublished">2021-02-14</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/RPC/">RPC</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Dubbo/" rel="tag">Dubbo</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/c812f120/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 8.1k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 36(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从 2.7.0 版本开始，Dubbo 的所有异步编程接口开始以 <code>CompletableFuture</code> 为基础，不仅支持了服务提供方的异步执行，而且对当前的异步调用功能进行了增强。异步改造引入了一些功能接口和实现，以及对部分逻辑进行了调整，但底层逻辑并没有改变，本篇文章将对 Dubbo 的异步演进进行介绍。</p>
<h1 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-invoke-model.jpg" alt></p>
<p><strong>Dubbo 的远程调用中大致可以分为以上 4 种调用方式：</strong></p>
<ul>
<li><strong>oneway:</strong> 客户端发送消息后，不需要接收响应。对于不需要关心服务响应结果的请求适合 oneway 通信。</li>
<li><strong>sync:</strong> Dubbo 默认的通信方式，即同步调用。</li>
<li><strong>async:</strong> 异步调用范畴，使用 Future 的方式获取结果。</li>
<li><strong>future:</strong> 异步调用范畴，使用 CompletableFuture 获取结果，也支持通过 Future 的方式获取结果。</li>
</ul>
<p><strong>注意：</strong> Dubbo 中的调用方式可以分为两大类，oneway 和 twoway ，对于 Dubbo 协议来说，会对这两种方式做分别处理，对于非 Dubbo 协议不会特别区分。</p>
<h1 id="Dubbo-2-6-x-异步实现"><a href="#Dubbo-2-6-x-异步实现" class="headerlink" title="Dubbo 2.6.x 异步实现"></a>Dubbo 2.6.x 异步实现</h1><p>Dubbo 2.6.x 的异步实现是针对消费端异步，只需指定调用方式为异步调用，并在需要结果的地方从 <strong>RpcContext</strong> 中取出 <strong>Future</strong> 获取结果即可。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol>
<li>指定异步调用<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置 async = true，表示异步调用。默认是 false，同步调用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">async</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>通过上下文取出 Future<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hello = demoService.sayHello(<span class="string">"world"</span>); <span class="comment">// call remote method</span></span><br><span class="line">Future&lt;String&gt; future = RpcContext.getContext().getFuture();</span><br><span class="line">String result = future.get();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>具体调用实现可以参考 <a href="https://gentryhuang.com/posts/26722deb/#%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8">Dubbo异步调用</a> 。</p>
<h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>Dubbo 2.6.x 提供了一定的异步编程能力，但其异步方式存在以下问题：</p>
<ul>
<li>Future 获取方式不够直接，业务方需要从 RpcContext 中获取。如果同时进行多个异步调用，如果使用不当很容易造成上下文污染。</li>
<li>Future 接口无法实现自动回调，而且定义的 ResponseFure (2.7 已经废弃)虽然支持回调，但支持的异步场景有限，并且不支持 Future 间的相互协调。</li>
<li>不支持服务端异步。</li>
</ul>
<h1 id="Dubbo-2-7-x-异步实现"><a href="#Dubbo-2-7-x-异步实现" class="headerlink" title="Dubbo 2.7.x 异步实现"></a>Dubbo 2.7.x 异步实现</h1><p>Dubbo 2.7.x 异步改造是对 Dubbo 2.6.x 异步功能的增强，引入的 <code>CompletableFuture</code> 既支持 <code>Future</code> 又支持 <code>Callback</code> 的调用方式，使用方可以根据需要自行选择。</p>
<h2 id="基础模型"><a href="#基础模型" class="headerlink" title="基础模型"></a>基础模型</h2><p>Dubbo 2.7.x 对异步实现进行了改造，引入了相关的接口和实现类，异步实现需要这些相关的基础模型配合完成。下面我们先对基础模型进行介绍。</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Result 相关的继承关系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-invoke-transform-result-uml.jpg" alt></p>
<p>在 Dubbo 2.6.x 中统一使用 <code>RpcResult</code> 表示调用结果，Dubbo 2.7.x 中废弃了 <code>RpcResult</code> ，采用以下三个对象表示结果状态。</p>
<ul>
<li>AsyncRpcResult<blockquote>
<p>表示的是一个异步的、未完成的RPC调用，是在调用链中实际传递的对象。</p>
</blockquote>
</li>
<li>AppResponse<blockquote>
<p>表示的是服务端返回的具体响应，相当于 Dubbo 2.6.x 中的 RpcResult 。其子类是 DecodeableRpcResult。</p>
</blockquote>
</li>
<li>CompletableFuture<blockquote>
<p>表示的是服务端返回的结果，由调用端创建，用于封装 AppResponse 对象。其中 DefaultFuture 继承该类。</p>
</blockquote>
</li>
</ul>
<p>三者关系：AppResponse -&gt; CompletableFuture -&gt; AsyncResult ，下面我们对其进行介绍。</p>
<h4 id="AppResponse"><a href="#AppResponse" class="headerlink" title="AppResponse"></a>AppResponse</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppResponse</span> <span class="keyword">implements</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6925924956850004727L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应结果</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的异常信息</span></span><br><span class="line">    <span class="keyword">private</span> Throwable exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的附加信息</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; attachments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppResponse</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppResponse</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exception = exception;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">recreate</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 1 异常处理</span></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// fix issue#619</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// get Throwable class</span></span><br><span class="line">                Class clazz = exception.getClass();</span><br><span class="line">                <span class="keyword">while</span> (!clazz.getName().equals(Throwable<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">                    clazz = clazz.getSuperclass();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// get stackTrace value</span></span><br><span class="line">                Field stackTraceField = clazz.getDeclaredField(<span class="string">"stackTrace"</span>);</span><br><span class="line">                stackTraceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Object stackTrace = stackTraceField.get(exception);</span><br><span class="line">                <span class="keyword">if</span> (stackTrace == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    exception.setStackTrace(<span class="keyword">new</span> StackTraceElement[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它方法 getter/setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AppResponse</code> 是调用的实际返回类型，相当于 Dubbo 2.6.x 中的 <code>RpcResult</code> ，理论上不需要实现 <code>Result</code> 接口，这样做是为了兼容。 </p>
<h4 id="DecodeableRpcResult"><a href="#DecodeableRpcResult" class="headerlink" title="DecodeableRpcResult"></a>DecodeableRpcResult</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeableRpcResult</span> <span class="keyword">extends</span> <span class="title">AppResponse</span> <span class="keyword">implements</span> <span class="title">Codec</span>, <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DecodeableRpcResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 通道</span></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">// 序列化类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> serializationType;</span><br><span class="line">    <span class="comment">// 序列化相关的输入流</span></span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span><br><span class="line">    <span class="comment">// 响应对象</span></span><br><span class="line">    <span class="keyword">private</span> Response response;</span><br><span class="line">    <span class="comment">// 调用信息</span></span><br><span class="line">    <span class="keyword">private</span> Invocation invocation;</span><br><span class="line">    <span class="comment">// 标志是否已经解码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasDecoded;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecodeableRpcResult</span><span class="params">(Channel channel, Response response, InputStream is, Invocation invocation, <span class="keyword">byte</span> id)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(channel, <span class="string">"channel == null"</span>);</span><br><span class="line">        Assert.notNull(response, <span class="string">"response == null"</span>);</span><br><span class="line">        Assert.notNull(is, <span class="string">"inputStream == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.response = response;</span><br><span class="line">        <span class="keyword">this</span>.inputStream = is;</span><br><span class="line">        <span class="keyword">this</span>.invocation = invocation;</span><br><span class="line">        <span class="keyword">this</span>.serializationType = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">+--- DecodeableRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 没有解码，则进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="keyword">null</span> &amp;&amp; inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 解码</span></span><br><span class="line">                decode(channel, inputStream);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Decode rpc result failed: "</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                response.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">                response.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                hasDecoded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            Thread thread = Thread.currentThread();</span><br><span class="line">            log.debug(<span class="string">"Decoding in thread -- ["</span> + thread.getName() + <span class="string">"#"</span> + thread.getId() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 确定序列化方式，用于反序列化</span></span><br><span class="line">        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">                .deserialize(channel.getUrl(), input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 读取一个 byte 的标志位，其值可能有 6 种</span></span><br><span class="line">        <span class="keyword">byte</span> flag = in.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 根据标志位判断当前结果中包含的信息，并调用不同的方法进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE:</span><br><span class="line">                handleValue(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:</span><br><span class="line">                handleException(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                handleAttachment(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="comment">// 根据 RpcInvocation 中记录的返回值类型读取返回结果，并设置到当前类的 result 字段</span></span><br><span class="line">                handleValue(in);</span><br><span class="line">                <span class="comment">// 读取附加信息并设置到当前类的 attachmetns 中</span></span><br><span class="line">                handleAttachment(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:</span><br><span class="line">                handleException(in);</span><br><span class="line">                handleAttachment(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unknown result flag, expect '0' '1' '2' '3' '4' '5', but received: "</span> + flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) in).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">---</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleValue</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 返回结果类型</span></span><br><span class="line">            Type[] returnTypes;</span><br><span class="line">            <span class="keyword">if</span> (invocation <span class="keyword">instanceof</span> RpcInvocation) &#123;</span><br><span class="line">                returnTypes = ((RpcInvocation) invocation).getReturnTypes();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                returnTypes = RpcUtils.getReturnTypes(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2 根据返回结果类型获取结果</span></span><br><span class="line">            Object value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (ArrayUtils.isEmpty(returnTypes)) &#123;</span><br><span class="line">                <span class="comment">// This almost never happens?</span></span><br><span class="line">                value = in.readObject();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                value = in.readObject((Class&lt;?&gt;) returnTypes[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = in.readObject((Class&lt;?&gt;) returnTypes[<span class="number">0</span>], returnTypes[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3 设置结果 result</span></span><br><span class="line">            setValue(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            rethrow(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>DecodeableRpcResult</code> 主要对响应结果进行解码，从字节流中获取数据对象。</p>
<h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p><code>CompletableFuture</code> 是 Java 8 提供的异步编程类，Dubbo 2.7.x 中的 <code>DefaultFuture</code> 继承了 CompletableFuture ，Dubbo 协议下对于 twoway 请求都会返回一个 <code>DefaultFuutre</code> 对象。此外，<code>DefaultFuture</code> 支持在请求的时候指定线程池，用来处理请求的响应，具体的我们会在下一篇文章中分析。</p>
<h4 id="AsyncRpcResult"><a href="#AsyncRpcResult" class="headerlink" title="AsyncRpcResult"></a>AsyncRpcResult</h4><p><code>AsyncRpcResult</code> 是在调用链中实际传递的对象，表示一个异步的，未完成的RPC调用。注意，它并不是实际的调用结果，<code>AppResponse</code> 才是业务结果。</p>
<h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncRpcResult</span> <span class="keyword">implements</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AsyncRpcResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当回调发生时，RpcContext 可能已经被更改。即执行 AsyncRpcResult 上添加的回调方法的线程可能先后处理过多个不同的 AsyncRpcResult 。</span></span><br><span class="line">    <span class="comment">// 因此，我们应该保留当前RpcContext实例的引用，并在回调执行之前恢复它。</span></span><br><span class="line">    <span class="keyword">private</span> RpcContext storedContext;</span><br><span class="line">    <span class="keyword">private</span> RpcContext storedServerContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此次 RPC 调用关联的线程池</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此次 RPC 调用关联的 Invocation 对象</span></span><br><span class="line">    <span class="keyword">private</span> Invocation invocation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求返回的对象 （由调用端创建）</span></span><br><span class="line">    <span class="keyword">private</span> CompletableFuture&lt;AppResponse&gt; responseFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在构造方法中除了接收发送请求返回的 CompletableFuture&lt;AppResponse&gt; 对象，还会保存当前的 RPC 上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncRpcResult</span><span class="params">(CompletableFuture&lt;AppResponse&gt; future, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseFuture = future;</span><br><span class="line">        <span class="keyword">this</span>.invocation = invocation;</span><br><span class="line">        <span class="keyword">this</span>.storedContext = RpcContext.getContext();</span><br><span class="line">        <span class="keyword">this</span>.storedServerContext = RpcContext.getServerContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要说明的是，<code>responseFuture</code> 属性不仅针对 Dubbo 协议，HTTP等协议调用返回结果也是 <code>CompletableFuture</code> 对象，都是由调用端创建。区别在于 Dubbo 协议一般返回的是 <code>DefaultFuture</code> 对象，而 HTTP 等协议会构造一个 <code>CompletableFuture</code> 对象，我们会在下面内容提到。</p>
<h5 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h5><p><code>AsyncRpcResult</code> 获取结果本质上需要先获取发送请求返回的 <code>CompletableFuture</code> ，也就是 <strong>responseFuture</strong> 属性，然后再从 <strong>responseFuture</strong> 中获取 <code>AppResponse</code> 对象，最后调用其对应的方法。</p>
<h6 id="获取-CompletableFuture"><a href="#获取-CompletableFuture" class="headerlink" title="获取 CompletableFuture"></a>获取 CompletableFuture</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">   <span class="function"><span class="keyword">public</span> CompletableFuture&lt;AppResponse&gt; <span class="title">getResponseFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="获取-AppResponse"><a href="#获取-AppResponse" class="headerlink" title="获取 AppResponse"></a>获取 AppResponse</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">getAppResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果完成，则获取 AppResponse</span></span><br><span class="line">            <span class="keyword">if</span> (responseFuture.isDone()) &#123;</span><br><span class="line">                <span class="keyword">return</span> responseFuture.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// This should not happen in normal request process;</span></span><br><span class="line">            logger.error(<span class="string">"Got exception when trying to fetch the underlying result from AsyncRpcResult."</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取默认的 AppResponse</span></span><br><span class="line">        <span class="keyword">return</span> createDefaultValue(invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法将始终在最大 timeout 等待之后返回：</span></span><br><span class="line"><span class="comment">     * 1. 如果value在超时前返回，则正常返回。</span></span><br><span class="line"><span class="comment">     * 2. 如果timeout之后没有返回值，则抛出TimeoutException。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">       <span class="comment">// 针对 ThreadlessExecutor 的特殊处理，这里调用 waitAndDrain() 等待响应</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">            threadlessExecutor.waitAndDrain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseFuture.get(timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">            threadlessExecutor.waitAndDrain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseFuture.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>ThreadlessExecutor</code> 是一个特殊的线程池，主要用来解决同步调用模式下的响应，是对线程模型的优化，我们在下一篇文章中进行详细说明。</p>
<h6 id="获取结果-1"><a href="#获取结果-1" class="headerlink" title="获取结果"></a>获取结果</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">recreate</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation rpcInvocation = (RpcInvocation) invocation;</span><br><span class="line">        <span class="comment">//  1 如果是服务端的异步实现，则从上下文中取。</span></span><br><span class="line">        <span class="comment">// 为什么？ 因为接口返回的结果是 CompletableFuture,属于异步范畴（服务端的异步），和消费端异步类似。</span></span><br><span class="line">        <span class="keyword">if</span> (InvokeMode.FUTURE == rpcInvocation.getInvokeMode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcContext.getContext().getFuture();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 获取 AppResponse 中的结果</span></span><br><span class="line">        <span class="keyword">return</span> getAppResponse().recreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>AsyncRpcResult.recreate()</code> 方法是获取结果的方法，也就是从 <code>AppResponse</code> 中获取结果。</p>
<h6 id="添加回调"><a href="#添加回调" class="headerlink" title="添加回调"></a>添加回调</h6><p>回调是 Dubbo 2.7.x 异步改造的重要角色，<code>AsyncRpcResult</code> 支持添加回调方法，而这个回调方法会被包装一层并注册到 <strong>responseFuture</strong> 上，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">whenCompleteWithContext</span><span class="params">(BiConsumer&lt;Result, Throwable&gt; fn)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在responseFuture之上注册回调</span></span><br><span class="line">        <span class="keyword">this</span>.responseFuture = <span class="keyword">this</span>.responseFuture.whenComplete((v, t) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 将当前线程的 RpcContext 记录到临时属性中，然后将构造函数中存储的 RpcContext 设置到当前线程中，为后面的回调执行做准备</span></span><br><span class="line">            beforeContext.accept(v, t);</span><br><span class="line">            <span class="comment">// 执行回调 （使用的 RpcContext 是回调所属服务方法的调用线程的 RpcContext）</span></span><br><span class="line">            fn.accept(v, t);</span><br><span class="line">            <span class="comment">// 恢复线程原有的 RpcContext</span></span><br><span class="line">            afterContext.accept(v, t);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在添加回调时，需要使用 <strong>beforeContext</strong> 和 <strong>afterContext</strong> 来保证执行回调的线程的 RpcContext 是最初创建 <code>AsyncRpcResult</code> 对象的线程对应的 RpcContext，执行完回调后需要将执行回调的线程的 RpcContext 恢复到原有值。其中 <strong>beforeContext</strong> 用于保存执行回调线程的 RpcContext，并将最初创建 <code>AsyncRpcResult</code> 对象的线程的 RpcContext 临时设置到执行回调用线程中，为执行回调做准备。<strong>afterContext</strong> 用于恢复执行回调用的线程原有的 RpcContext 。具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="keyword">private</span> RpcContext tmpContext;</span><br><span class="line">    <span class="keyword">private</span> RpcContext tmpServerContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BiConsumer&lt;Result, Throwable&gt; beforeContext = (appResponse, t) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 将当前线程的 RpcContext 记录到 tmpContext 中</span></span><br><span class="line">        tmpContext = RpcContext.getContext();</span><br><span class="line">        tmpServerContext = RpcContext.getServerContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将构造函数中存储的 RpcContext (也就是创建 AsyncRpcResult 线程的 RpcContext) 设置到当前线程中</span></span><br><span class="line">        RpcContext.restoreContext(storedContext);</span><br><span class="line">        RpcContext.restoreServerContext(storedServerContext);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BiConsumer&lt;Result, Throwable&gt; afterContext = (appResponse, t) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 将当前线程的 RpcContext 恢复到原始值</span></span><br><span class="line">        RpcContext.restoreContext(tmpContext);</span><br><span class="line">        RpcContext.restoreServerContext(tmpServerContext);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>如此一来，<code>AsyncRpcResult</code> 就可以随意添加回调，无需担心 RpcContext 被污染。</p>
<p><code>AsyncRpcResult</code> 整个是为异步请求设计的，但是 Dubbo 中默认的请求方式是同步的，那么 Dubbo 又是如何支持同步调用的呢？Dubbo 进行服务引用时，在 <code>AbstractProtocol.refer()</code> 方法中，Dubbo 会将 <code>AbstractProtocol.protocolBindingRefer()</code> 方法实现返回的 Invoker 对象使用 <code>AsyncToSyncInvoker</code> 封装一层，该对象中的调用逻辑会对同步调用专门处理，我们在下面的内容中进行介绍。相比较而言，Dubbo 2.6.x 在 Dubbo 协议做了异步转同步处理，就是在调用时拿到 <code>DefaultFuture</code> 后立即阻塞等待结果。HTTP 协议就没有异步调用支持，而 Dubbo 2.7.x 使用了 <code>AbstractInvoker</code> 对 <strong>Future</strong> 功能进行统一支持，也就是 HTTP 协议也基本上支持了调用异步。</p>
<h3 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h3><h4 id="AsyncToSyncInvoker"><a href="#AsyncToSyncInvoker" class="headerlink" title="AsyncToSyncInvoker"></a>AsyncToSyncInvoker</h4><p><code>AsyncToSyncInvoker</code> 描述了异步转同步的逻辑，是对 <code>AsyncRpcResult</code> 获取结果的补充，触发时机是在执行调用的时候。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncToSyncInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 服务引用的 Invoker</span></span><br><span class="line">    <span class="keyword">private</span> Invoker&lt;T&gt; invoker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncToSyncInvoker</span><span class="params">(Invoker&lt;T&gt; invoker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invoker = invoker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        Result asyncResult = invoker.invoke(invocation);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是同步调用，则调用 get() 方法，阻塞等待响应返回。</span></span><br><span class="line">            <span class="comment">// 调用的是 AsyncRpcResult.get 方法，其底层调用的是 CompletableFuture 的 get 方法</span></span><br><span class="line">            <span class="keyword">if</span> (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * NOTICE!</span></span><br><span class="line"><span class="comment">                 * must call &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get(long, TimeUnit)&#125; because</span></span><br><span class="line"><span class="comment">                 * &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get()&#125; 被证明有严重的性能下降。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Interrupted unexpectedly while waiting for remote result to return!  method: "</span> +</span><br><span class="line">                    invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> TimeoutException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> +</span><br><span class="line">                        invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RemotingException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> +</span><br><span class="line">                        invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.UNKNOWN_EXCEPTION, <span class="string">"Fail to invoke remote method: "</span> +</span><br><span class="line">                        invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非同步调用直接返回调用结果 AsyncRpcResult</span></span><br><span class="line">        <span class="keyword">return</span> asyncResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AsyncToSyncInvoker</code> 是 Invoker 的装饰器，负责将异步调用转换成同步调用，也就是调用 <code>AsyncRpcResult</code> 中的 <code>CompletableFuture.get</code> 方法实现同步等待。相比 Dubbo 2.6.x 还是有很大区别的，Dubbo 2.6.x 使用 <strong>Future.get</strong> 功能阻塞等待，业务线程将处于阻塞等待状态，返回结果时需要消费端 Dubbo 线程池将结果写到 DefaultFuture 中，业务线程才能取出并返回。Dubbo 2.7.x 彻底优化了这种线程模型，关于优化的背景和实现会在下一篇文章中进行介绍，这里先了解即可。</p>
<h4 id="AbstractProxyInvoker"><a href="#AbstractProxyInvoker" class="headerlink" title="AbstractProxyInvoker"></a>AbstractProxyInvoker</h4><p><code>AbstractProxyInvoker</code> 是 Dubbo 框架在服务暴露过程中创建的对象，由 <code>ProxyFactory.getInvoker</code> 创建，是对服务接口实现的封装。该过程对 Dubbo 中所有协议一致。</p>
<h4 id="AbstractInvoker"><a href="#AbstractInvoker" class="headerlink" title="AbstractInvoker"></a>AbstractInvoker</h4><p>Dubbo 在服务引用时会创建消费端的 <code>Invoker</code>，对于不同的协议创建的 <code>Invoker</code> 有所不同。下面我们对 <strong>Dubbo 协议</strong> 和 <strong>使用 HTTP 通信的协议</strong> 创建 <code>Invoker</code> 流程进行分析。其中每个协议创建的 <code>Invoker</code> 都会继承 <code>AbstractInvoker</code> 抽象类，该抽象类中定义了通用的执行逻辑，如调用模式的确定。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 Invoker 对象封装的业务接口类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="comment">// 当前 Invoker 关联的 URL 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="comment">// 当前 Invoker 关联的一些附加信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attachment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标志 Invoker 的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> available = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractInvoker</span><span class="params">(Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(type, url, (Map&lt;String, Object&gt;) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractInvoker</span><span class="params">(Class&lt;T&gt; type, URL url, String[] keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(type, url, convertAttachment(url, keys));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractInvoker</span><span class="params">(Class&lt;T&gt; type, URL url, Map&lt;String, Object&gt; attachment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service type == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.attachment = attachment == <span class="keyword">null</span> ? <span class="keyword">null</span> : Collections.unmodifiableMap(attachment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="invoke-方法"><a href="#invoke-方法" class="headerlink" title="invoke 方法"></a>invoke 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// if invoker is destroyed due to address refresh from registry, let's allow the current invoke to proceed</span></span><br><span class="line">        <span class="keyword">if</span> (destroyed.get()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Invoker for service "</span> + <span class="keyword">this</span> + <span class="string">" on consumer "</span> + NetUtils.getLocalHost() + <span class="string">" is destroyed, "</span></span><br><span class="line">                    + <span class="string">", dubbo version is "</span> + Version.getVersion() + <span class="string">", this invoker should not be used any longer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcInvocation invocation = (RpcInvocation) inv;</span><br><span class="line">        invocation.setInvoker(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(attachment)) &#123;</span><br><span class="line">            invocation.addObjectAttachmentsIfAbsent(attachment);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 从上下文中取出 附加信息</span></span><br><span class="line">        Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(contextAttachments)) &#123;</span><br><span class="line">            invocation.addObjectAttachments(contextAttachments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 设置调用模式  SYNC, ASYNC, FUTURE 。注意，oneway 调用方式</span></span><br><span class="line">        <span class="comment">// 根据以下方式确定调用模式：</span></span><br><span class="line">        <span class="comment">// 1) 根据返回值类型是否是 CompletableFuture ，或方法名是 $invokeAsync，则是 FUTURE 模式。这个属于服务端异步。</span></span><br><span class="line">        <span class="comment">// 2) 根据 async 属性，如果设置 async=true ，则是 ASYNC 模式</span></span><br><span class="line">        <span class="comment">// 3) 默认是 SYNC 模式</span></span><br><span class="line">        invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 如果是异步调用的模式，则给本次调用添加一个唯一id (FUTURE 模式不属于)</span></span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">        AsyncRpcResult asyncResult;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 调用子类实现的 doInvoker() 方法</span></span><br><span class="line">            asyncResult = (AsyncRpcResult) doInvoke(invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对调用异常的处理</span></span><br><span class="line">            <span class="comment">// 4.1 创建 CompletableFuture 对象，使用该对象包装 AppResponse 对象</span></span><br><span class="line">            <span class="comment">// 4.2 使用 AppResponse 对象包装异常信息</span></span><br><span class="line">            <span class="comment">// 4.3 使用 AsyncRpcResult 最后包装 CompletableFuture 对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123; <span class="comment">// biz exception</span></span><br><span class="line">            Throwable te = e.getTargetException();</span><br><span class="line">            <span class="keyword">if</span> (te == <span class="keyword">null</span>) &#123;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (te <span class="keyword">instanceof</span> RpcException) &#123;</span><br><span class="line">                    ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);</span><br><span class="line">                &#125;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, te, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 使用 FutureContext 保存 FutureAdapter，FutureAdapter 中会封装 AsyncRpcResult 中的 CompletableFuture 对象</span></span><br><span class="line">        RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter(asyncResult.getResponseFuture()));</span><br><span class="line">        <span class="keyword">return</span> asyncResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractInvoker</code> 的 <strong>invoke</strong> 方法是调用服务的模版方法，具体调用细节交给具体子类实现。</p>
<ol>
<li>设置附加信息到调用信息 Invocation 中。</li>
<li>设置调用模式<ul>
<li><strong>FUTURE:</strong> 根据返回值类型是否是 <code>CompletableFuture</code> ，或方法名是否是 <code>$invokeAsync</code>，则是 FUTURE 模式。这个属于服务端异步。</li>
<li><strong>ASYNC:</strong> 根据 async 属性，如果设置 async=true ，则是 ASYNC 模式。</li>
<li><strong>SYNC:</strong> 默认调用模式。</li>
</ul>
</li>
<li>异步调用时，给本地调用添加一个唯一id，并设置到附加属性中。</li>
<li>调用具体子类 Invoker 对象的 <code>doInvoke</code> 方法，不管是哪个子类实现，调用的结果都是 <code>AsyncRpcResult</code> 类型。</li>
<li>如果调用异常，则对异常进行处理。</li>
<li>使用上下文保存 FutureAdapter ，其中 FutureAdapter 中会封装 AsyncRpcResult 中的 CompletableFuture 对象。在后续的链路中可以使用 <strong>Future</strong> 的异步功能。</li>
</ol>
<p><strong>注意:</strong></p>
<blockquote>
<p>相比 Dubbo 2.6.x，<code>AbstractInvoker</code> 的模版方法中实现了异步逻辑，也就是任何协议的服务调用都支持 <code>Future</code> 的异步功能。在 Dubbo 2.6.x 中非 Dubbo 协议大都不支持异步调用特性。</p>
</blockquote>
<h2 id="Dubbo协议异步实现"><a href="#Dubbo协议异步实现" class="headerlink" title="Dubbo协议异步实现"></a>Dubbo协议异步实现</h2><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p><code>DubboInvoker</code> 是 Dubbo 协议在消费端创建的 Invoker 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取此次调用的方法名</span></span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 向 Invocation 中添加附加信息，这里将 URL 的 path 和 version 添加到附加信息中</span></span><br><span class="line">        inv.setAttachment(PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 选择一个 ExchangeClient 实例</span></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4 判断是否是 oneway 调用，不关心服务端的响应结果。调用后直接返回一个空 AsyncRpcResult</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// 根据调用方法名和配置，计算此次调用的超时时间</span></span><br><span class="line">            <span class="keyword">int</span> timeout = calculateTimeout(invocation, methodName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 request() 方法会相应创建 DefaultFuture 对象以及检测超时的定时任务，而 send() 方法则不会创建这些东西。</span></span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">                <span class="comment">// 是否等待底层 NIO 将请求发出，等待时间默认 1s，1s未发送则抛出异常</span></span><br><span class="line">                <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">                currentClient.send(inv, isSent);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回已完成状态的 AsynRpcResult 即 AsynRpcResult -&gt; CompletableFuture（已完成状态） -&gt; AppResponse（空结果）</span></span><br><span class="line">                <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(invocation);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 需要关注返回值的请求</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5 获取处理响应的线程池 </span></span><br><span class="line">                ExecutorService executor = getCallbackExecutor(getUrl(), inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6 调用 ExchangeClient.request() 方法，将 Invocation 包装成 Request 请求发送出去，同时会创建相应的 DefaultFuture 返回。</span></span><br><span class="line">                CompletableFuture&lt;AppResponse&gt; appResponseFuture =</span><br><span class="line">                        <span class="comment">// currentClient.request 返回的是 DefaultFuture，DefaultFuture 继承了 CompletableFuture 。</span></span><br><span class="line">                        currentClient.request(inv, timeout, executor)</span><br><span class="line">                                <span class="comment">// 增加了一个回调，取出其中的 AppResponse 对象。</span></span><br><span class="line">                                <span class="comment">// thenApply 是一个回调,obj 是 上一个任务的结果。返回的 AppResponse 表示的是 服务端返回的具体响应。</span></span><br><span class="line">                                .thenApply(obj -&gt; (AppResponse) obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter</span></span><br><span class="line">                FutureContext.getContext().setCompatibleFuture(appResponseFuture);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7 这里将 CompletableFuture （其实是 DefaultFuture） 封装成 AsyncRpcResult 并返回</span></span><br><span class="line">                AsyncRpcResult result = <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 8 设置处理响应的线程池</span></span><br><span class="line">                result.setExecutor(executor);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 9 返回调用</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>DubboInvoker</code> 进行远程调用时，会分别对 <strong>oneway</strong> 和 <strong>twoway</strong> 进行处理。</p>
<ul>
<li>处理 <strong>oneway</strong> 调用方式<blockquote>
<p>不需要响应结果，直接使用客户端的 <strong>send</strong> 方法即可，该方法不会返回服务端的响应。<code>DubboInvoker</code> 会返回一个空结果的 <code>AsyncRpcResult</code> 对象给业务方。</p>
</blockquote>
</li>
<li>处理 <strong>twoway</strong> 调用方式<blockquote>
<p>需要响应结果，使用客户端的 <strong>request</strong> 方法发送请求，该方法会创建并返回本次调用的 DefaultFuture 对象，当服务端响应时会更新 DefaultFuture 中的结果信息。此外，Dubbo 对线程模型进行了优化，可以指定处理响应的线程池，特别是同步调用的线程池，这个我们在下一篇文章中详细介绍。</p>
</blockquote>
</li>
</ul>
<p>相比较 Dubbo 2.6.x 中的 <code>DefaultFuture</code>，引入了 <code>CompletableFuture</code> 可以支持多异步场景，并且支持 <code>Future</code> 间的相互协调，此外提供了良好的回调方法，避免等待响应而阻塞。这是对 <code>ExchangeClient</code> 的改造，将 Dubbo 2.6.x 中异步编程接口都替换成了 <code>CompletableFuture</code> 。介绍完消费端的异步实现后，下面我们来看看服务端的异步实现。</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><code>AbstractProxyInvoker</code> 是 Dubbo 协议在服务端创建的 Invoker，它封装的是服务接口实现。Dubbo 协议下的服务暴露会使用 <code>ProxyFactory#getInvoker</code> 将服务接口实现封装成 <code>AbstractProxyInvoker</code>。当收到请求时，通道处理器链上的每个处理器都会对该请求进行各自逻辑的处理，其中 <code>HeaderExchangeHandler#handleRequest</code> 会将请求交给 <code>DubboProtocol</code> 中的 <code>ExchangeHandler</code> 处理，Dubbo 协议下的服务端异步实现处理逻辑就在这三者中。在分析源码之前，我们先看服务端异步实现的例子：</p>
<h4 id="异步实现"><a href="#异步实现" class="headerlink" title="异步实现"></a>异步实现</h4><p>服务提供端异步执行将阻塞的业务从 Dubbo 内部线程池切换到业务自定义线程，在一定程度上避免 Dubbo 线程池的过度占用，有助于避免不同服务间的互相影响。</p>
<h5 id="定义-CompletableFuture-签名接口"><a href="#定义-CompletableFuture-签名接口" class="headerlink" title="定义 CompletableFuture 签名接口"></a>定义 <code>CompletableFuture</code> 签名接口</h5><ul>
<li>服务接口定义<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="function">CompletableFuture&lt;String&gt; <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>服务实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServiceImpl</span> <span class="keyword">implements</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        RpcContext savedContext = RpcContext.getContext();</span><br><span class="line">        <span class="comment">// 建议为supplyAsync提供自定义线程池，避免使用JDK公用线程池</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"async response from provider."</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过 <code>return CompletableFuture.supplyAsync()</code> ，业务执行已从 Dubbo 线程切换到业务线程，避免了对 Dubbo 线程池的阻塞。</p>
<h5 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h5><p> <code>CompletableFuture</code> 签名接口是服务提供方的异步实现，消费端同普通消费一致，Dubbo 内部会根据调用的方法返回值类型等方式确定 <strong>调用模式</strong>，具体的在后面的源码部分介绍。</p>
<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>Dubbo 2.7 虽然支持了服务端的异步，但 Dubbo 的线程模型本身就是异步处理的方式，因此服务端的异步特性相对还是有点鸡肋的。</p>
<p>了解了服务端异步实现后，下面我们从代码层面分析，Dubbo 如何就 <code>CompletableFuture</code> 签名服务接口方法实现异步的。</p>
<h4 id="HeaderExchangeHandler-处理请求"><a href="#HeaderExchangeHandler-处理请求" class="headerlink" title="HeaderExchangeHandler 处理请求"></a>HeaderExchangeHandler 处理请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeHandler</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">        <span class="comment">// 省略异常处理代码</span></span><br><span class="line"></span><br><span class="line">        Object msg = req.getData();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 使用上层通道处理器处理消息，其实就是 DubboProtocol 中的 ExchangeHandler </span></span><br><span class="line">            CompletionStage&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 请求处理完成回调，将结果发送到对端</span></span><br><span class="line">            future.whenComplete((appResult, t) -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        res.setStatus(Response.OK);</span><br><span class="line">                        res.setResult(appResult);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">                        res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3 将处理后的结果发送到对端</span></span><br><span class="line">                    channel.send(res);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Send result to consumer failed, channel is "</span> + channel + <span class="string">", msg is "</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">            res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">            channel.send(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>相比较与 Dubbo 2.6.x 中的处理请求逻辑，这里使用了 <code>CompletableFuture</code> 的完成回调，避免了阻塞等待请求完成。这得益于对通道处理 ExchangeHandler 的异步方法的改造，也就是 DubboProtocol 中的 ExchangeHandler 的实现。</p>
<h4 id="DubboProtocol-的处理器"><a href="#DubboProtocol-的处理器" class="headerlink" title="DubboProtocol 的处理器"></a>DubboProtocol 的处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"><span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line"></span><br><span class="line">            Invocation inv = (Invocation) message;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取暴露的 Invoker，这里是 AbstractProxyInvoker</span></span><br><span class="line">            Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">           </span><br><span class="line">            RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果服务端异步实现，这里返回的 result 是一个 AsyncRpcResult 类型对象，其中的 AppResonse 中的值并非 CompletableFuture 类型，而是 CompletableFuture 封装的 AppResponse</span></span><br><span class="line">            Result result = invoker.invoke(inv);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result.thenApply(Function.identity());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DubboProtocol 中的 ExchangeHandler 的请求处理方法返回的是 CompletableFuture 对象，这同样是 Dubbo 2.7.x 中的改造，服务方法的结果统一包装成 <code>CompletableFuture</code> 类型，在服务端的 Invoker 的执行逻辑中就可以体现这一点，下面我们就来看 <code>AbstractProxyInvoker</code> 。</p>
<h4 id="AbstractProxyInvoker-1"><a href="#AbstractProxyInvoker-1" class="headerlink" title="AbstractProxyInvoker"></a>AbstractProxyInvoker</h4><p>服务端的 Invoker，直接封装服务接口实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractProxyInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 执行服务方法，如 DemoService.sayHello </span></span><br><span class="line">            Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 将方法结果以 CompletableFuture 对象形式进行封装。</span></span><br><span class="line">            <span class="comment">// 注意：如果服务方法返回类型是 CompletableFuture ，则无需再使用 CompletableFuture 包装。这个针对服务端的异步实现。</span></span><br><span class="line">            CompletableFuture&lt;Object&gt; future = wrapWithFuture(value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 执行 future 逻辑</span></span><br><span class="line">            CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 使用 AppResponse 封装实际结果</span></span><br><span class="line">                AppResponse result = <span class="keyword">new</span> AppResponse();</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t <span class="keyword">instanceof</span> CompletionException) &#123;</span><br><span class="line">                        result.setException(t.getCause());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.setException(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.setValue(obj);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 统一包装成 AsyncRpcResult 对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123;</span><br><span class="line">                logger.error(<span class="string">"Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e.getTargetException(), invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke remote proxy method "</span> + invocation.getMethodName() + <span class="string">" to "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractProxyInvoker</code> 的执行逻辑主要有四点，下面进行总结：</p>
<ol>
<li>执行服务接口实例方法，如 demoService.sayhello 方法。</li>
<li>将服务实例方法的调用结果包装成 <code>CompletableFuture</code> ，<strong>如果是服务端异步实现（服务接口方法返回类型是 CompletableFuture），则无需对结果进行包装，直接使用返回的 <code>CompletableFuture</code></strong> 即可。</li>
<li>执行 <code>CompletableFuture</code> 的回调方法，将实际结果封装到 AppResponse 中。</li>
<li>将返回结果包装成 AsyncRpcResult 对象。</li>
</ol>
<h2 id="HTTP-协议实现"><a href="#HTTP-协议实现" class="headerlink" title="HTTP 协议实现"></a>HTTP 协议实现</h2><h3 id="消费端-1"><a href="#消费端-1" class="headerlink" title="消费端"></a>消费端</h3><p>Dubbo 中的 HTTP 协议在消费端创建的 Invoker 是一个 <code>AbstractInvoker</code> 匿名对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">+--- AbstractProxyProtocol</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">protocolBindingRefer</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; type, <span class="keyword">final</span> URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 调用子类实现的 doRefer() 方法返回一个目标服务接口的代理对象</span></span><br><span class="line">        <span class="comment">// 2 使用 ProxyFactory.getInvoker() 方法将服务接口的代理对象封装成一个 Invoker ，类型是 AbstractProxyInvoker。</span></span><br><span class="line">        <span class="keyword">final</span> Invoker&lt;T&gt; target = proxyFactory.getInvoker(doRefer(type, url), type, url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 创建 AbstractInvoker 的匿名对象</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = <span class="keyword">new</span> AbstractInvoker&lt;T&gt;(type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 4 调用 AbstractProxyInvoker.invoke 方法，返回的结果是 AsyncRpcResult</span></span><br><span class="line">                    Result result = target.invoke(invocation);</span><br><span class="line">                    <span class="comment">// FIXME result is an AsyncRpcResult instance.</span></span><br><span class="line">                    Throwable e = result.getException();</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Class&lt;?&gt; rpcException : rpcExceptions) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (rpcException.isAssignableFrom(e.getClass())) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> getRpcException(type, url, invocation, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.getCode() == RpcException.UNKNOWN_EXCEPTION) &#123;</span><br><span class="line">                        e.setCode(getErrorCode(e.getCause()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> getRpcException(type, url, invocation, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        invokers.add(invoker);</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Dubbo 协议下的服务调用不仅引入 CompletableFuture ，还对方法等进行改造，如 <code>HeaderExchangeClient.request</code> 方法。<strong>HTTP 协议下的服务调用异步改造力度相对不大</strong>，异步实现主要依赖引入的 CompletableFuture ，以及在 <code>AbstractInvoker</code> 中统一的 <code>Future</code> 异步功能。</p>
<p><strong>特别说明：</strong></p>
<blockquote>
<p>为什么将 <code>doRefer</code> 返回的代理对象通过 <code>ProxyFactory.getInvoker</code> 包装成 <code>AbstractProxyInvoker</code> 对象？因为此代理对象具备和远程服务通信的能力，原则上可以使用该代理对象调用服务接口方法，但是调用信息是存在 <code>Invocation</code> 中，将该代理对象包装成 <code>AbstractProxyInvoker</code> 可以根据 <code>Invocation</code> 中的信息动态选择目标服务方法。本质上和 DubboInvoker 类似，DubboInvoker 和远程服务通信需要使用 <code>ExchangeClient</code>，将调用信息 <code>Invocation</code> 交给它即可实现目标服务的调用，这里的代理对象就相当于 DubboInvoker 中的 <code>ExchangeClient</code> 。</p>
</blockquote>
<h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p>使用 <code>JsonRpcServer</code> 暴露服务，具体过程可参考：<a href="https://gentryhuang.com/posts/c5a37c18/#%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2-2">HTTP协议服务暴露</a> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--- HttpProtocol.doExport</span><br><span class="line"><span class="comment">// 5 创建 JsonRpcServer，暴露服务</span></span><br><span class="line">JsonRpcServer skeleton = <span class="keyword">new</span> JsonRpcServer(impl, type);</span><br><span class="line">JsonRpcServer genericServer = <span class="keyword">new</span> JsonRpcServer(impl, GenericService<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>其中的具有服务能力的 <strong>impl</strong> 是 <code>ProxyFactory#getProxy(org.apache.dubbo.rpc.Invoker&lt;T&gt;, boolean)</code>  创建的代理对象，具体逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractProxyProtocol</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 省略无关代码</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String uri = serviceKey(invoker.getUrl());</span><br><span class="line">        Exporter&lt;T&gt; exporter = (Exporter&lt;T&gt;) exporterMap.get(uri);</span><br><span class="line">        <span class="keyword">if</span> (exporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// When modifying the configuration through override, you need to re-expose the newly modified service.</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(exporter.getInvoker().getUrl(), invoker.getUrl())) &#123;</span><br><span class="line">                <span class="keyword">return</span> exporter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其中的 invoker 是由 ProxyFactory#getInvoker 创建</span></span><br><span class="line">        <span class="keyword">final</span> Runnable runnable = doExport(proxyFactory.getProxy(invoker, <span class="keyword">true</span>), invoker.getInterface(), invoker.getUrl());</span><br><span class="line">        exporter = <span class="keyword">new</span> AbstractExporter&lt;T&gt;(invoker) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.unexport();</span><br><span class="line">                exporterMap.remove(uri);</span><br><span class="line">                <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        runnable.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.warn(t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        exporterMap.put(uri, exporter);</span><br><span class="line">        <span class="keyword">return</span> exporter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>不难看出最终处理请求的还是上面方法传入的 <code>invoker</code> 对象，该对象中包含真正的服务实例。而传入的 <code>invoker</code> 对象是由 <code>ProxyFactory#getInvoker</code> 创建的，对象类型是 <code>AbstractProxyInvoker</code> ，下面以 <code>JavassistProxyFactory</code> 工厂为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'</span></span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们把前文的 <code>AbstractProxyInvoker</code> 的代码实现粘贴过来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractProxyInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 执行服务方法，如 DemoService.sayHello </span></span><br><span class="line">            Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 将方法结果以 CompletableFuture 对象形式进行封装。</span></span><br><span class="line">            <span class="comment">// 注意：如果服务方法返回类型是 CompletableFuture ，则无需再使用 CompletableFuture 包装。这个针对服务端的异步实现。</span></span><br><span class="line">            CompletableFuture&lt;Object&gt; future = wrapWithFuture(value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 执行 future 逻辑</span></span><br><span class="line">            CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 使用 AppResponse 封装实际结果</span></span><br><span class="line">                AppResponse result = <span class="keyword">new</span> AppResponse();</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t <span class="keyword">instanceof</span> CompletionException) &#123;</span><br><span class="line">                        result.setException(t.getCause());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.setException(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.setValue(obj);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 统一包装成 AsyncRpcResult 对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123;</span><br><span class="line">                logger.error(<span class="string">"Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e.getTargetException(), invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke remote proxy method "</span> + invocation.getMethodName() + <span class="string">" to "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>对于使用 HTTP 协议的服务实现，更多的是在形式上保持统一，和 Dubbo 协议的服务实现类似。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Dubbo 2.6.x 及之前版本中使用 <code>Future</code> 实现异步功能，并且不支持服务端的异步，这在功能设计上存在一些问题，Dubbo 2.7.x 基于 <code>CompletableFuture</code> 对异步功能进行了增强，弥补了功能设计上的一些问题。由于 <code>CompletableFuture</code> 实现了 <code>CompletionStage</code> 和 <code>Future</code> 接口，因此仍然支持 Dubbo 2.6 中通过 <strong>get()</strong> 或者 <strong>isDone()</strong> 方法轮询结果。但是，不建议使用 <strong>get()</strong> 这样阻塞的方式获取结果，因为这样做的的话就丢失了异步操作带来的性能提升。<code>CompletableFuture</code> 提供了良好的回调支持，如 <strong>whenComplete()</strong> 等方法可以在逻辑完成后，执行回调逻辑。同时 <code>CompletableFuture</code> 支持 <code>Future</code> 间的相互协调，如 <strong>thenApply()</strong> 等方法。正是由于 <code>CompletableFuture</code> 强大的功能，我们可以更加流畅地使用回调而无需等待响应而阻塞调用线程。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/c812f120/" title="Dubbo源码分析 - 异步改造" target="_blank" rel="external">https://gentryhuang.com/posts/c812f120/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/aa1d8127/" title="Redis原理 - 简单动态字符串"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/13d5a11a/" title="Dubbo源码分析 - 线程模型改造"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2021 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>