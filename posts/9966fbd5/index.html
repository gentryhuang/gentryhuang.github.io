<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>集群容错 - LoadBalance | gentryhuang的博客</title>
  <meta name="description" content="概述Dubbo 中的负载均衡 LoadBalance 的职责是将网络请求或者其它形式的负载 &quot;均摊&quot; 到不同的服务节点上，从而避免服务集群中部分节点压力过大，而另一部分节点比较空闲的情况。通过合理的负载均衡，可以让每个服务节点获取到适合自己处理能力的负载，实现处理能力和流量的合理分配。常用的负载均衡可分为软件负载均衡和硬件负载均衡，在日常开发中一般很难接触到硬件负载均衡，主要有">
<meta property="og:type" content="article">
<meta property="og:title" content="集群容错 - LoadBalance">
<meta property="og:url" content="https://gentryhuang.com/posts/9966fbd5/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="概述Dubbo 中的负载均衡 LoadBalance 的职责是将网络请求或者其它形式的负载 &quot;均摊&quot; 到不同的服务节点上，从而避免服务集群中部分节点压力过大，而另一部分节点比较空闲的情况。通过合理的负载均衡，可以让每个服务节点获取到适合自己处理能力的负载，实现处理能力和流量的合理分配。常用的负载均衡可分为软件负载均衡和硬件负载均衡，在日常开发中一般很难接触到硬件负载均衡，主要有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-loadbalance-relation.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-loadbalance-random.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-cache-consistent-hash.jpeg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-dubbo-consistent-hash.jpeg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-dubbo-consistent-hash-virtual.jpeg">
<meta property="article:published_time" content="2020-09-30T23:00:00.000Z">
<meta property="article:modified_time" content="2021-11-28T06:05:24.932Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="Dubbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-loadbalance-relation.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/9966fbd5/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.44px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.78px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.11px;">I/O</a> <a href="/tags/JMM/" style="font-size: 13px;">JMM</a> <a href="/tags/JUC/" style="font-size: 13.67px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.22px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.11px;">Lock</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.22px;">Protocol</a> <a href="/tags/Queue/" style="font-size: 13.33px;">Queue</a> <a href="/tags/RPC/" style="font-size: 13.56px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.11px;">Redis数据结构</a> <a href="/tags/SCAN/" style="font-size: 13px;">SCAN</a> <a href="/tags/SPI/" style="font-size: 13.22px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.22px;">Spring</a> <a href="/tags/Thread/" style="font-size: 13.11px;">Thread</a> <a href="/tags/Zookeeper/" style="font-size: 13.11px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 13px;">分布式锁</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.89px;">设计模式</a> <a href="/tags/%E9%99%90%E6%B5%81/" style="font-size: 13px;">限流</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/a16a077e/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/a16a077e/" class="title">并发 - FutureTask</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-22T02:07:06.000Z" itemprop="datePublished">2022-04-22</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/3c450cc6/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/posts/3c450cc6/" class="title">MySQL - 乐观锁和悲观锁</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-10T02:46:59.000Z" itemprop="datePublished">2022-04-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/c1861d8c/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/c1861d8c/" class="title">Redis原理 - SCAN 原理</a>
              </p>
              <p class="item-date">
                <time datetime="2022-03-12T14:14:47.000Z" itemprop="datePublished">2022-03-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/e0c3e79e/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/posts/e0c3e79e/" class="title">MySQL - Double Write</a>
              </p>
              <p class="item-date">
                <time datetime="2022-03-09T08:25:44.000Z" itemprop="datePublished">2022-03-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/db98efcf/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/db98efcf/" class="title">队列 - DelayQueue</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-25T13:10:53.000Z" itemprop="datePublished">2022-02-25</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#负载均衡策略"><span class="toc-number">2.</span> <span class="toc-text">负载均衡策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#配置"><span class="toc-number">3.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码分析"><span class="toc-number">4.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LoadBalance"><span class="toc-number">4.1.</span> <span class="toc-text">LoadBalance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AbstractLoadBalance"><span class="toc-number">4.2.</span> <span class="toc-text">AbstractLoadBalance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择-Invoker"><span class="toc-number">4.2.1.</span> <span class="toc-text">选择 Invoker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务提供者权重计算"><span class="toc-number">4.2.2.</span> <span class="toc-text">服务提供者权重计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RandomLoadBalance"><span class="toc-number">4.3.</span> <span class="toc-text">RandomLoadBalance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RoundRobinLoadBalance"><span class="toc-number">4.4.</span> <span class="toc-text">RoundRobinLoadBalance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加权轮询算法"><span class="toc-number">4.4.1.</span> <span class="toc-text">加权轮询算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">4.4.2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择目标-Invoker"><span class="toc-number">4.4.3.</span> <span class="toc-text">选择目标 Invoker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeastActiveLoadBalance"><span class="toc-number">4.5.</span> <span class="toc-text">LeastActiveLoadBalance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConsistentHashLoadBalance"><span class="toc-number">4.6.</span> <span class="toc-text">ConsistentHashLoadBalance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性-1"><span class="toc-number">4.6.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择-Invoker-1"><span class="toc-number">4.6.2.</span> <span class="toc-text">选择 Invoker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConsistentHashSelector"><span class="toc-number">4.6.3.</span> <span class="toc-text">ConsistentHashSelector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#核心属性"><span class="toc-number">4.6.3.1.</span> <span class="toc-text">核心属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造方法"><span class="toc-number">4.6.3.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择服务"><span class="toc-number">4.6.3.3.</span> <span class="toc-text">选择服务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ShortestResponseLoadBalance"><span class="toc-number">4.7.</span> <span class="toc-text">ShortestResponseLoadBalance</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-rpc/集群容错之负载均衡" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      集群容错 - LoadBalance
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/9966fbd5/" class="article-date">
	  <time datetime="2020-09-30T23:00:00.000Z" itemprop="datePublished">2020-10-01</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/RPC/">RPC</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Dubbo/" rel="tag">Dubbo</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/9966fbd5/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 10.3k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 41(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 中的负载均衡 <code>LoadBalance</code> 的职责是将网络请求或者其它形式的负载 <code>&quot;均摊&quot;</code> 到不同的服务节点上，从而避免服务集群中部分节点压力过大，而另一部分节点比较空闲的情况。通过合理的负载均衡，可以让每个服务节点获取到适合自己处理能力的负载，实现处理能力和流量的合理分配。常用的负载均衡可分为<strong>软件负载均衡</strong>和<strong>硬件负载均衡</strong>，在日常开发中一般很难接触到硬件负载均衡，主要有 F5、NetScaler 等；软件负载均衡还是很常见的，比如 Nginx 。常见的 RPC 框架都有负载均衡的概念和相应的实现，Dubbo 也不例外。Dubbo 需要对服务消费者的调用请求进行分配，避免少数提供者节点负载过大，而其它提供者节点处于空闲状态。服务提供者负载过大，会导致部分请求超时、甚至丢失等一系列问题，造成线上故障。因此将负载均衡到每个服务提供者是非常有必要的。</p>
<h1 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h1><p>在集群负载均衡时，Dubbo 提供了 5 种均衡策略，缺省为 <code>random</code> 随机调用。</p>
<ul>
<li>基于加权随机算法的 <strong>RandomLoadBalance</strong></li>
<li>基于加权轮询算法的 <strong>RoundRobinLoadBalance</strong></li>
<li>基于最小活跃调用数算法的 <strong>LeastActiveLoadBalance</strong></li>
<li>基于一致性 Hash 的 <strong>ConsistentHashLoadBalance</strong></li>
<li>基于最短响应时间的 <strong>ShortestResponseLoadBalance</strong></li>
</ul>
<p>继承关系图如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-loadbalance-relation.jpg" alt></p>
<p>其中基于最短响应时间的 <code>ShortestResponseLoadBalance</code> 负载均衡策略是 Dubbo 2.7.x 新增的，和基于最少活跃调用数算法类似。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul>
<li>服务端服务级别<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>客户端服务级别<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>服务端方法级别<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>客户端方法级别<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="LoadBalance"><a href="#LoadBalance" class="headerlink" title="LoadBalance"></a>LoadBalance</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(RandomLoadBalance.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的 URL 和 Invocation ，以及负载均衡算法从 Invoker 集合中选择一个 Invoker</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers   invokers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        refer url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation invocation.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> selected invoker.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(<span class="string">"loadbalance"</span>)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LoadBalance</code> 是一个扩展接口，默认扩展实现是 <code>RandomLoadBalance</code> ，Dubbo 根据 <code>@Adaptive(&quot;loadbalance&quot;)</code> 注解生成的适配器会按照 URL 中的 <code>loadbalance</code> 参数值选择扩展实现类。</p>
<h2 id="AbstractLoadBalance"><a href="#AbstractLoadBalance" class="headerlink" title="AbstractLoadBalance"></a>AbstractLoadBalance</h2><h3 id="选择-Invoker"><a href="#选择-Invoker" class="headerlink" title="选择 Invoker"></a>选择 Invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractLoadBalance</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers   invokers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        refer url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation invocation.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 Invoker集合为空，直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 Invoker集合只包含一个Invoker，则直接返回该Invoker对象</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3 Invoker集合包含多个Invoker对象时，交给doSelect()方法处理，这是个抽象方法，留给子类具体实现</span></span><br><span class="line">        <span class="keyword">return</span> doSelect(invokers, url, invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractLoadBalance</code> 抽象类并没有真正实现 <code>select()</code> 方法，仅是对 Invoker 集合为空或是只包含一个 Invoker 对象的情况进行了处理，其它情况的选择逻辑交给子类实现。</p>
<h3 id="服务提供者权重计算"><a href="#服务提供者权重计算" class="headerlink" title="服务提供者权重计算"></a>服务提供者权重计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractLoadBalance</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line">        <span class="comment">// 1 多注册中心场景，多注册中心负载均衡。</span></span><br><span class="line">        <span class="keyword">if</span> (REGISTRY_SERVICE_REFERENCE_PATH.equals(url.getServiceInterface())) &#123;</span><br><span class="line">            <span class="comment">// 1.1 如果是RegistryService接口的话，直接根据配置项 registry.weight 获取权重即可，默认是 100</span></span><br><span class="line">            weight = url.getParameter(REGISTRY_KEY + <span class="string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 非多注册中心场景</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1 从 url 中获取 weight 配置值，默认为 100</span></span><br><span class="line">            weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span><br><span class="line">            <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 2.2 获取服务提供者的启动时间戳</span></span><br><span class="line">                <span class="keyword">long</span> timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, <span class="number">0L</span>);</span><br><span class="line">                <span class="keyword">if</span> (timestamp &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                    <span class="comment">// 2.3 计算Provider运行时长</span></span><br><span class="line">                    <span class="keyword">long</span> uptime = System.currentTimeMillis() - timestamp;</span><br><span class="line">                    <span class="keyword">if</span> (uptime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 2.4 从 url 中获取 Provider 预热时间配置值，默认为10分钟，即 10 * 60 * 1000</span></span><br><span class="line">                    <span class="keyword">int</span> warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2.5 如果Provider运行时间小于预热时间，则该Provider节点可能还在预热阶段，需要降低其权重</span></span><br><span class="line">                    <span class="keyword">if</span> (uptime &gt; <span class="number">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                        weight = calculateWarmupWeight((<span class="keyword">int</span>) uptime, warmup, weight);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3 防御性编程，权重不能为负数</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(weight, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在获取服务提供者权重时，需要考虑当前服务提供者是否还在预热阶段（运行时间小于预热时间），<strong>如果还在预热阶段需要对其进行降权处理，目的是避免服务提供者一启动就有大量请求涌来，处于高负载状态。服务预热是一个优化手段，一般在服务启动后，让其在小流量状态下运行一段时间，然后再逐步放大流量</strong>。</p>
<p>权重计算是在 <code>calculateWarmupWeight</code> 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractLoadBalance</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对还在预热状态的 Provider 节点进行降权，避免 Provider 一启动就有大量请求涌进来。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uptime the uptime in milliseconds 服务运行时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> warmup the warmup time in milliseconds 预热时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight the weight of an invoker 配置的服务权重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> weight which takes warmup into account 计算的服务权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateWarmupWeight</span><span class="params">(<span class="keyword">int</span> uptime, <span class="keyword">int</span> warmup, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算权重，简化为： (uptime/warmup) * weight。</span></span><br><span class="line">        <span class="comment">// 随着服务运行时间 uptime 增大，权重计算值 ww 会慢慢接近配置值 weight</span></span><br><span class="line">        <span class="keyword">int</span> ww = (<span class="keyword">int</span>) (uptime / ((<span class="keyword">float</span>) warmup / weight));</span><br><span class="line">        <span class="comment">// 权重范围为 [0,weight] 之间</span></span><br><span class="line">        <span class="keyword">return</span> ww &lt; <span class="number">1</span> ? <span class="number">1</span> : (Math.min(ww, weight));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>calculateWarmupWeight()</code> 方法用于计算还处于预热状态的 Provider 节点的权重，随着服务运行时间增大，权重计算值会慢慢接近配置的权重值。</p>
<p>负载均衡的抽象实现主要是对消费端 Invoker 集合为空或仅有一个的情况下直接处理，无需子类进行选择。此外还对消费端 Invoker 权重的获取做了统一实现。了解了负载均衡抽象实现后，下面我们对负载均衡的具体实现进行分析。</p>
<h2 id="RandomLoadBalance"><a href="#RandomLoadBalance" class="headerlink" title="RandomLoadBalance"></a>RandomLoadBalance</h2><p><code>RandomLoadBalance</code> 是<code>加权随机算法</code>的具体实现，它是一个简单、高效的负载均衡实现，也是 Dubbo 默认使用的负载均衡策略。其核心就是加权随机算法，下面我们简单对该算法进行说明。</p>
<p>假设有 3 个服务节点，分别为节点 A、节点 B、节点 C，它们对应的权重依次为 5、2、3，权重总和为 10。现在把这些权重值放到一维坐标上，<code>[0,5)</code>区间属于节点A，<code>[5,7)</code>区间属于节点B，<code>[7,10)</code>区间属于节点C，具体分布如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-loadbalance-random.jpg" alt></p>
<p>接下来通过随机数生成器在 <code>[0,10)</code> 这个范围内生成一个随机数，然后计算这个随机数会落到哪个区间上。比如，随机生成数字 3 ，就会落到 <code>Provider A</code> 对应的区间上，此时 <code>RandomLoadBalance</code> 就会返回 <code>Provider A</code> 这个节点。权重越大的节点，在坐标轴上对应的区间范围就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务节点被选中的次数比例接近其权重比例。比如，经过一万次选择后，服务器 A 被选中的次数大约为 5000 次，服务器 B 被选中的次数约为 2000 次，服务器 C 被选中的次数约为 3000 次。</p>
<p>了解了加权随机算法后，我们开始对 <code>RandomLoadBalance</code> 源码进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"random"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Select one invoker between a list using a random criteria</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers   List of possible invokers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation Invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The selected invoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="comment">// 每个 Invoker 权重是否相同的标志</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 计算每个 Invoker 对象对应的权重，并填充到 weights 数组中</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算第一个 Invoker 权重</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = getWeight(invokers.get(<span class="number">0</span>), invocation);</span><br><span class="line">        weights[<span class="number">0</span>] = firstWeight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录权重总和</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = firstWeight;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算第 i 个 Invoker 的权重</span></span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">            weights[i] = weight;</span><br><span class="line">            <span class="comment">// 累加总权重</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测是否有不同权重的 Invoker</span></span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) &#123;</span><br><span class="line">                sameWeight = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总权重 &gt; 0 &amp;&amp; 并非所有 Invoker 权重都相同</span></span><br><span class="line">        <span class="comment">// 计算随机数落在哪个区间</span></span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// 随机获取一个 [0,totalWeight) 区间内的随机数</span></span><br><span class="line">            <span class="keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环让随机数数减去Invoker的权重值，当随机数小于0时，返回相应的Invoker</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                offset -= weights[i];</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果所有的 Invoker 权重相同 或 权重总权重为 0，则均等随机</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RandomLoadBalance</code> 中 <code>doSelect()</code> 方法的实现，主要有以下 3 个关键点：</p>
<ol>
<li>通过 <code>AbstractLoadBalance.getWeight</code> 方法计算每个 Invoker 的权重值</li>
<li>汇总 Invoker 的总权重值</li>
<li>只要不是每个 Invoker 权重都相同，则使用加权随机算法选出对应的 Invoker 对象。</li>
<li>当所有 Invoker 权重相同时，随机返回一个 Invoker 即可。</li>
</ol>
<p>总体上加权随机负载均衡策略还是比较简单的，同时它也是其它负载均衡算法的基础，如最小活跃调用数负载均衡和最短响应时间负载均衡在具有多个相同条件的 Invoker 时，最后会通过该算法进一步选择目标 Invoker 。</p>
<p><strong>缺点：</strong>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，大量请求都卡在调到第二台上。解决办法可以通过监控，及时调整权重。</p>
<h2 id="RoundRobinLoadBalance"><a href="#RoundRobinLoadBalance" class="headerlink" title="RoundRobinLoadBalance"></a>RoundRobinLoadBalance</h2><p><code>RoundRobinLoadBalance</code> 是<code>加权轮询算法</code>的具体实现。<code>轮询</code>指的是将请求轮流分配给每个服务节点，例如，有 A、B、C 三个服务节点，按照普通轮询的方式，会将第一个请求分配给 A 节点，将第二个请求分配给 B 节点，第三个请求分配给 C 节点，第四个请求分配给 A 节点……如此循环往复。<strong>轮询是一种无状态负载均衡算法，实现简单，适用于每台服务器性能相近的场景</strong>。但现实情况下，我们并不能保证每台服务器性能均相近。如果我们将等量的请求分配给性能较差的服务器，这显然是不合理的。因此，这个时候我们需要对轮询过程进行加权，以调控每台服务器的负载。经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。比如服务节点 A、B、C 权重比为 5:2:1。那么在8次请求中，服务器 A 将收到其中的5次请求，服务器 B 会收到其中的2次请求，服务器 C 则收到其中的1次请求。</p>
<p><code>RoundRobinLoadBalance</code> 参考自 Nginx 的平滑加权轮询负载均衡。每个服务节点有两个权重，分别为 <code>weight</code> 和 <code>current</code> ，其中 <code>weight</code> 是通过父类的 <code>getWeight</code> 方法计算出来的值，虽然在预热过程是变化的，但这里可以认为是固定的；<code>current</code> 是动态的，初始值为 0 ，每次有新的请求进来时，遍历 Invoker 列表，并用对应的 <code>current</code> 加上 <code>weight</code> 。遍历完成后，找到具有最大 <code>current</code> 的 Invoker 和对应的 <code>WeightedRoundRobin</code> 。<strong>在返回选中的 Invoker 之前，将其对应的 <code>WeightedRoundRobin</code> 中的当前权重值 <code>current</code> 减去本次请求累加的总权重值，从而实现平滑负载均衡。</strong></p>
<h3 id="加权轮询算法"><a href="#加权轮询算法" class="headerlink" title="加权轮询算法"></a>加权轮询算法</h3><p>下面举例对 <code>RoundRobinLoadBalance</code> 的执行流程进行说明。假设有 3 个服务节点，分别为节点 A、节点 B、节点 C，对应的权重依次为：5、1、1 ，选择过程如下：</p>
<table>
<thead>
<tr>
<th align="left">请求编号</th>
<th>当前权重(current)数组</th>
<th>选择结果</th>
<th>合计权重</th>
<th>胜者减去合计权重后的当前权重(current)数组</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>[0, 0, 0]</td>
</tr>
<tr>
<td align="left">1</td>
<td>[5, 1, 1]</td>
<td>A</td>
<td>7</td>
<td>[-2, 1, 1]</td>
</tr>
<tr>
<td align="left">2</td>
<td>[3, 2, 2]</td>
<td>A</td>
<td>7</td>
<td>[-4, 2, 2]</td>
</tr>
<tr>
<td align="left">3</td>
<td>[1, 3, 3]</td>
<td>B</td>
<td>7</td>
<td>[1, -4, 3]</td>
</tr>
<tr>
<td align="left">4</td>
<td>[6, -3, 4]</td>
<td>A</td>
<td>7</td>
<td>[-1, -3, 4]</td>
</tr>
<tr>
<td align="left">5</td>
<td>[4, -2, 5]</td>
<td>C</td>
<td>7</td>
<td>[4, -2, -2]</td>
</tr>
<tr>
<td align="left">6</td>
<td>[9, -1, -1]</td>
<td>A</td>
<td>7</td>
<td>[2, -1, -1]</td>
</tr>
<tr>
<td align="left">7</td>
<td>[7, 0, 0]</td>
<td>A</td>
<td>7</td>
<td>[0, 0, 0]</td>
</tr>
</tbody></table>
<p><strong>下面对以上每次请求数据变更进行说明，该过程就是加权轮询算法的实现：</strong></p>
<blockquote>
<ol>
<li>处理第一个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [0, 0, 0] 变为 [5, 1, 1]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 A。最后，将节点 A 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [-2, 1, 1]。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>处理第二个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [-2, 1, 1] 变为 [3, 2, 2]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 A。最后，将节点 A 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [-4, 2, 2]。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>处理第三个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [-4, 2, 2] 变为 [1, 3, 3]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 B。最后，将节点 B 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [1, -4, 3]。</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>处理第四个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [1, -4, 3] 变为 [6, -3, 4]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 A。最后，将节点 A 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [-1, -3, 4]。</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>处理第五个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [-1, -3, 4] 变为 [4, -2, 5]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 C。最后，将节点 C 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [4, -2, -2]。</li>
</ol>
</blockquote>
<blockquote>
<ol start="6">
<li>处理第六个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [4, -2, -2] 变为 [9, -1, -1]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 A。最后，将节点 A 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [2, -1, -1]。</li>
</ol>
</blockquote>
<blockquote>
<ol start="7">
<li>处理第七个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [2, -1, -1] 变为 [7, 0, 0]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 A。最后，将节点 A 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [0, 0, 0]。</li>
</ol>
</blockquote>
<p>以上就是一个轮询的周期，可以发现经过合计权重（5 + 1 +1）轮次后，循环又回到了起点，整个过程中节点流量时平滑的，且哪怕在很短的时间周期内，概率都是按期望分布的。</p>
<p>了解了加权轮询的计算过程后，下面我们就对 <code>RoundRobinLoadBalance</code> 源码实现进行分析。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">+--- RoundRobinLoadBalance</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"roundrobin"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 长时间未更新的阈值 60 s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECYCLE_PERIOD = <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个 Invoker 对应的对象，加权轮流调度器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedRoundRobin</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 服务提供者配置权重，在负载均衡过程不会变化(忽略启动预热)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 服务提供者当前权重，在负载均衡过程会动态调整，初始值为 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> AtomicLong current = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最后更新时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastUpdate;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">            current.set(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoker当前权重 + 配置的权重</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">increaseCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Invoker当前权重 - 总权重</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sel</span><span class="params">(<span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">            current.addAndGet(-<span class="number">1</span> * total);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastUpdate</span><span class="params">(<span class="keyword">long</span> lastUpdate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lastUpdate = lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务方法与 WeightedRoundRobin 的映射关系</span></span><br><span class="line"><span class="comment">     * key1: 服务键 + 方法名 -&gt; 完整方法名</span></span><br><span class="line"><span class="comment">     * key2: URL串</span></span><br><span class="line"><span class="comment">     * value: WeightedRoundRobin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RoundRobinLoadBalance</code> 中有 3 个核心属性，下面我们对其进行介绍。</p>
<ul>
<li><strong>RECYCLE_PERIOD</strong> <blockquote>
<p>用于监控 Invoker 对应的 WeightedRoundRobin 的更新频率。由于 Invoker 对应的服务可能会宕机，如果宕机就必须将其对应的 <code>WeightedRoundRobin</code> 缓存清除，RECYCLE_PERIOD 属性就是用来监控长时间未更新的 <code>WeightedRoundRobin</code>。</p>
</blockquote>
</li>
<li><strong>WeightedRoundRobin</strong><blockquote>
<p>作为 <code>RoundRobinLoadBalance</code> 的内部类，在 <code>RoundRobinLoadBalance</code> 中会为每个 Invoker 对象都创建一个对应的 <code>WeightedRoundRobin</code> 对象，用来记录配置的权重（weight字段）以及随每次负载均衡算法执行变化的当前权重（current字段）。</p>
</blockquote>
</li>
<li><strong>methodWeightMap</strong><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># key1: 完整方法名</span><br><span class="line"># key2: URL串</span><br><span class="line"># value: WeightedRoundRobin</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="attr">"...UserService.query"</span>:&#123;</span><br><span class="line">         <span class="attr">"url1"</span>: WeightedRoundRobin@<span class="number">123</span>,</span><br><span class="line">         <span class="attr">"url2"</span>: WeightedRoundRobin@<span class="number">456</span></span><br><span class="line">      &#125;,</span><br><span class="line">    <span class="attr">"...UserService.update"</span>:&#123;</span><br><span class="line">         <span class="attr">"url1"</span>: WeightedRoundRobin@<span class="number">111</span>,</span><br><span class="line">         <span class="attr">"url2"</span>: WeightedRoundRobin@<span class="number">222</span></span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
会基于每个方法创建一个 <code>WeightedRoundRobin</code> 映射关系。</li>
</ul>
<h3 id="选择目标-Invoker"><a href="#选择目标-Invoker" class="headerlink" title="选择目标 Invoker"></a>选择目标 Invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">+--- RoundRobinLoadBalance</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取请求的完整方法名</span></span><br><span class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + invocation.getMethodName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取整个Invoker列表对应的 WeightedRoundRobin 映射表，如果为空，则创建一个新的WeightedRoundRobin映射表</span></span><br><span class="line">        ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总权重</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录 Invoker 列表中最大权重</span></span><br><span class="line">        <span class="keyword">long</span> maxCurrent = Long.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 选中的 Invoker</span></span><br><span class="line">        Invoker&lt;T&gt; selectedInvoker = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 选中的 Invoker 对应的 WeightedRoundRobin</span></span><br><span class="line">        WeightedRoundRobin selectedWRR = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 遍历 Invoker 列表，选出具有最大 current 的 Invoker</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 获取 Invoker 对应的URL串</span></span><br><span class="line">            String identifyString = invoker.getUrl().toIdentityString();</span><br><span class="line">            <span class="comment">// 获取当前 Invoker 权重</span></span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invoker, invocation);</span><br><span class="line">            <span class="comment">// 检测当前 Invoker 是否有相应的 WeightedRoundRobin ，没有则创建</span></span><br><span class="line">            WeightedRoundRobin weightedRoundRobin = map.computeIfAbsent(identifyString, k -&gt; &#123;</span><br><span class="line">                WeightedRoundRobin wrr = <span class="keyword">new</span> WeightedRoundRobin();</span><br><span class="line">                <span class="comment">// 设置权重和初始化当前权重值为0</span></span><br><span class="line">                wrr.setWeight(weight);</span><br><span class="line">                <span class="keyword">return</span> wrr;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测 Invoker 权重是否发生了变化，若变化了则更新相应 WeightedRoundRobin 中的 weight 值</span></span><br><span class="line">            <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">                <span class="comment">//weight changed</span></span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.1 让 current 加上配置的 weight 🌟</span></span><br><span class="line">            <span class="keyword">long</span> cur = weightedRoundRobin.increaseCurrent();</span><br><span class="line">            <span class="comment">// 3.2 更新 lastUpdate 字段</span></span><br><span class="line">            weightedRoundRobin.setLastUpdate(now);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.3 寻找具有最大 current 的 Invoker，以及Invoker对应的 WeightedRoundRobin ，暂存起来留作后用</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; maxCurrent) &#123;</span><br><span class="line">                maxCurrent = cur;</span><br><span class="line">                selectedInvoker = invoker;</span><br><span class="line">                selectedWRR = weightedRoundRobin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.4 计算权重总和</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 Invoker 集合数不等于缓存数，说明存在 Invoker 挂了的可能，此时应该清除无效缓存</span></span><br><span class="line">        <span class="comment">// 因为客户端缓存了数据</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() != map.size()) &#123;</span><br><span class="line">            <span class="comment">// 清除掉长时间未被更新的节点，以 60s </span></span><br><span class="line">            map.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 更新选中的 Invoker 对应的 WeightedRoundRobin 中维护的 current 的值，然后返回选中的 Invoker 🌟</span></span><br><span class="line">        <span class="keyword">if</span> (selectedInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用 current 减去 totalWeight</span></span><br><span class="line">            selectedWRR.sel(totalWeight);</span><br><span class="line">            <span class="comment">// 返回选中的Invoker对象</span></span><br><span class="line">            <span class="keyword">return</span> selectedInvoker;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// should not happen here</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>RoundRobinLoadBalance</code> 中的 <code>doSelect</code> 就是对上面加权轮询计算过程的实现，理解了加权轮询算法就理解了 <code>RoundRobinLoadBalance</code> 负载均衡策略。</p>
<h2 id="LeastActiveLoadBalance"><a href="#LeastActiveLoadBalance" class="headerlink" title="LeastActiveLoadBalance"></a>LeastActiveLoadBalance</h2><p><code>LeastActiveLoadBalance</code> 使用的是 <code>最小活跃数负载均衡算法</code>。活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求，此时应优先将请求分配给该服务提供者。在具体实现中，每个服务提供者都对应一个活跃数 <code>active</code> ，初始情况下所有服务提供者活跃数均为 0 ，每收到一个请求，活跃数加 1 ，完成请求后则将活跃数减 1 。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求。以上就是最小活跃数负载均衡算法的基本思想。</p>
<p>除了最小活跃数，<code>LeastActiveLoadBalance</code> 在实现上还引入了权重，所以准确地说该负载均衡策略是基于<strong>加权最小活跃数算法</strong>实现的。<code>LeastActiveLoadBalance</code> 需要配合 <code>ActiveLimitFilter</code>使用，ActiveLimitFilter 是 Dubbo 在消费端的限流实现，会记录消费者对一个服务端方法的并发调用量，在进行负载均衡时，只会从活跃调用数最小的 Invoker 集合中挑选 Invoker ，当有多个最小活跃调用数的Invoker时，会在最小活跃调用数基础增加加权随机策略。下面我们对源码进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeastActiveLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"leastactive"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ---------------------- 1 🌟 关键属性 ------------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoker 数量</span></span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最小的活跃调用数</span></span><br><span class="line">        <span class="keyword">int</span> leastActive = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录具有相同最小活跃调用数（leastActive 的值）的 Invoker 数量</span></span><br><span class="line">        <span class="keyword">int</span> leastCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录具有相同最小活跃调用数（leastActive 的值）的 Invoker 在 Invoker 列表中的下标位置。</span></span><br><span class="line">        <span class="comment">// leastIndexes 数组中如果有多个值，则说明有两个及以上的 Invoker 具有相同的最小活跃数（leastActive 的值）</span></span><br><span class="line">        <span class="keyword">int</span>[] leastIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个 Invoker 的权重值</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最小活跃调用数所有 Invoker 的权重值之和</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最小活跃请求数 Invoker 集合中第一个 Invoker 的权重值</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记是否具有相同权重的最小活跃数 Invoker</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------------- 2 🌟 操作关键属性 ------------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有Invoker，选出最小活跃调用数的Invoker集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该 Invoker 的活跃调用数 （使用到了消费方限流策略：ActiveLimitFilter）</span></span><br><span class="line">            <span class="keyword">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录该 Invoker 的权重</span></span><br><span class="line">            <span class="keyword">int</span> afterWarmup = getWeight(invoker, invocation);</span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比较活跃调用数，发现更小的活跃调用数则更新相关属性。这样情况只有一个 Invoker</span></span><br><span class="line">            <span class="comment">// 这个是必须要的，因为要的就是最小活跃调用数，具有相同的最小活跃调用数只是一种复杂情况，需要根据权重再处理</span></span><br><span class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || active &lt; leastActive) &#123;</span><br><span class="line">                <span class="comment">// 重新记录最小的活跃调用数</span></span><br><span class="line">                leastActive = active;</span><br><span class="line">                <span class="comment">// 重新记录最小活跃调用数的 Invoker 个数</span></span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新记录最小活跃调用数的 Invoker 在 Invoker 列表中的下标</span></span><br><span class="line">                leastIndexes[<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重置总权重</span></span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录第一个最小活跃调用数 Invoker 的权重</span></span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Each invoke has the same weight (only one invoker here)</span></span><br><span class="line">                <span class="comment">// 重置权重相同标识</span></span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前 Invoker 的活跃调用数等于最小活跃调用数，这样情况下已经存在最小活跃调用数的 Invoker</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录当前 Invoker 在 Invoker 列表中的下标</span></span><br><span class="line">                leastIndexes[leastCount++] = i;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 累加总权重，针对的是具有相同的最小活跃数</span></span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否存在相同权重的最小活跃调用数的 Invoker</span></span><br><span class="line">                <span class="comment">// 即检测当前 Invoker 的权重与firstWeight是否相等，不相等则将 sameWeight 设置为 false</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------------- 3 🌟 选择 Invoker ------------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 如果只有一个最小活跃调用数的 Invoker ，直接取出即可</span></span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 从 Invoker 列表中取出最小活跃数的 Invoker</span></span><br><span class="line">            <span class="keyword">return</span> invokers.get(leastIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 存在多个具有最小活跃数的 Invoker ，但它们的权重不相同且总权重 &gt; 0 ，则使用加权随机算法。</span></span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on </span></span><br><span class="line">            <span class="comment">// totalWeight.</span></span><br><span class="line">            <span class="keyword">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// Return a invoker based on the random value.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> leastIndex = leastIndexes[i];</span><br><span class="line">                offsetWeight -= weights[leastIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.3 存在多个 Invoker 具有相同的最小活跃数，但它们的权重相等或总权重为0，则使用随机均等</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LeastActiveLoadBalance</code> 核心思想是选择<strong>最小活跃调用数</strong>的服务提供者，如果最小活跃调用数的服务提供者有多个，则使用<strong>加权随机</strong>算法进行选择。核心思想理解起来很容易，但是实现上显得有点复杂，体现在定义了很多的属性上，下面对整个逻辑进行简单梳理。</p>
<ol>
<li>遍历 Invoker 列表，寻找活跃调用数最小的 Invoker，</li>
<li>如果存在多个 Invoker 具有相同的最小活跃调用数，此时需要使用一个数组记录这些具有相同最小活跃调用数的 Invoker，并累加它们的权重，且比较它们的权重值是否相等。</li>
<li>如果只有一个 Invoker 具有最小活跃数，此时直接返回该 Invoker 即可。</li>
<li>如果存在多个 Invoker 具有最小活跃数，且它们的权重不相等，此时处理方式和加权随机 <code>RandomLoadBalance</code> 一致。</li>
<li>如果存在多个 Invoker 具有最小活跃数，但它们的权重都相等，此时随机返回一个即可。</li>
</ol>
<h2 id="ConsistentHashLoadBalance"><a href="#ConsistentHashLoadBalance" class="headerlink" title="ConsistentHashLoadBalance"></a>ConsistentHashLoadBalance</h2><p><code>ConsistentHashLoadBalance</code> 负载均衡策略使用的是 <code>一致性 Hash</code> 来实现的。在分析具体源码之前，我们先对相关概念进行介绍。</p>
<p>一致性 Hash 算法提出之初是<strong>用于大规模缓存系统的负载均衡</strong>，它的工作过程是这样的，首先根据缓存节点地址或其它信息为缓存节点生成一个 <code>hash</code> 值，并将这个 <code>hash</code> 值投射到 <code>[0, 2^32 - 1]</code> 的圆环上（Hash环），也就是对 <code>2^32</code> 取模 。当有读写请求时，则为缓存项 <code>key</code> 生成一个 <code>hash</code> 值，然后到 Hash 环上查找第一个大于或等于该 <code>hash</code> 值的缓存节点，最后就可以在找到的缓存节点上进行读写操作了。如果当前缓存节点挂了，则在下一次读写请求时查找其它大于或等于本次请求的 <code>hash</code> 值的缓存节点即可。大致的 Hash 环如下图所示，每个缓存节点在圆环上映射一个位置。如果缓存项 <code>key</code> 的 <code>hash</code> 小于或等于缓存节点对应的 <code>hash</code> 值，则到该缓存节点中进行读写操作。如下面绿色点对应的缓存项将会被存储到 <code>cahce-2</code> 节点中。由于 <code>cache-3</code> 挂了，原本应该存到该节点中的缓存项最终会存储到 <code>cache-4</code> 节点上。</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-cache-consistent-hash.jpeg" alt></p>
<p>一致性 Hash 在 Dubbo 中的应用就是将缓存节点替换成 Dubbo 的服务提供者节点。理想情况下，一致性 Hash 算法会将 Dubbo 的服务提供者节点均匀地分布到 Hash 环上，请求也可以均匀地分发给 Dubbo 的服务提供者节点。但在实际情况中，提供者节点地址取模后的值可能在 Hash 环上分布不均匀，如下图：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-dubbo-consistent-hash.jpeg" alt></p>
<p>由于 <code>Invoker-1</code> 和 <code>Invoker-2</code> 在圆环上分布不均匀，导致系统中大部分请求都会落到 <code>Invoker-1</code> 上，只有少部分请求会落到 <code>Invoker-2</code> 上，这就出现了数据倾斜的问题。所谓数据倾斜是指由于节点不够分散，导致大量请求落到了同一个节点上，而其他节点只会接收到少量请求的情况。为了解决一致性 Hash 算法中出现的数据倾斜问题，引入了虚拟节点的概念。解决思路是：既然 Dubbo 服务提供者节点在 Hash 环上分布不均匀，那么可以虚拟出 N 组 Invoker-1，Invoker-2，…，Invoker-N 的提供者节点，让多组提供者节点相对均匀分布在 Hash 环上。如下图：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-dubbo-consistent-hash-virtual.jpeg" alt></p>
<p>上图中相同颜色的节点属于同一个服务提供者，如 Invoker1-1、Invoker1-2、….、Invoker1-160 表示的都是 Invoker1 这个服务节点，这样做的目的是通过引入虚拟节点，让 Invoker 在圆环上分散开来，避免数据倾斜问题。上图中有三个组。</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"consistenthash"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 虚拟节点数配置项，默认值为 160</span></span><br><span class="line"><span class="comment">     * 格式：&lt;dubbo:parameter key="hash.nodes" value="320" /&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HASH_NODES = <span class="string">"hash.nodes"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参与Hash计算的参数索引，默认只对第一个参数Hash</span></span><br><span class="line"><span class="comment">     * 格式：&lt;dubbo:parameter key="hash.arguments" value="0,1" /&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HASH_ARGUMENTS = <span class="string">"hash.arguments"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key: ServiceKey.methodName -&gt; 完整方法名</span></span><br><span class="line"><span class="comment">     * value: ConsistentHashSelector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HASH_NODES</code> 和 <code>HASH_ARGUMENTS</code> 属性分别是每个服务节点对应的虚拟节点数和参与Hash计算的请求参数的索引，<code>selectors</code> 属性用于存储 <code>请求调用&quot;完整方法名&quot;到一致性Hash选择器</code> 的映射关系。</p>
<h3 id="选择-Invoker-1"><a href="#选择-Invoker-1" class="headerlink" title="选择 Invoker"></a>选择 Invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--- ConsistentHashLoadBalance</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取调用的方法名称</span></span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="comment">// 2 将 ServiceKey 和 方法名 拼接起来构成一个 key，即完整方法名</span></span><br><span class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + methodName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取 Invoker 列表的 hashcode（为了在 Invokers 列表发生变化时重新生成 ConsistentHashSelector 对象）</span></span><br><span class="line">        <span class="keyword">int</span> invokersHashCode = invokers.hashCode();</span><br><span class="line">        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果 invokers 是一个新的 List 对象，说明服务提供者数量发生了变化，可能新增也可能减少了</span></span><br><span class="line">        <span class="comment">// 此时 selector.identityHashCode != invokersHashCode 成立</span></span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="keyword">null</span> || selector.identityHashCode != invokersHashCode) &#123;</span><br><span class="line">            <span class="comment">// 创建 ConsistentHashSelector 对象</span></span><br><span class="line">            selectors.put(key, <span class="keyword">new</span> ConsistentHashSelector&lt;T&gt;(invokers, methodName, invokersHashCode));</span><br><span class="line">            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 通过 ConsistentHashSelector 对象选择一个 Invoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> selector.select(invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>ConsistentHashLoadBalance</code> 的 <code>doSelect</code> 方法并没有真正选择目标 Invoker 对象，而是做了一些前置工作，主要是检测 Invoker 列表是否变更了，判断是否需要创建请求方法对应的一致性 Hash 选择器对象，也就是是否需要重新构建 Hash 环。这个准备工作完成后，Hash 环也就构建完毕了，接下来将选择 Invoker 的逻辑交给一致性选择性器 <code>ConsistentHashSelector</code> 对象。下面我们就来分析一致性 Hash 选择器。</p>
<h3 id="ConsistentHashSelector"><a href="#ConsistentHashSelector" class="headerlink" title="ConsistentHashSelector"></a>ConsistentHashSelector</h3><p><code>ConsistentHashLoadBalance</code> 实现负载均衡都是委托给一致性 Hash 选择器 <code>ConsistentHashSelector</code> 完成的，下面我们对该内部类进行介绍。</p>
<h4 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--- ConsistentHashLoadBalance</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashSelector</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用 TreeMap 存储 Invoker 虚拟节点，TreeMap 是按照Key排序的</span></span><br><span class="line"><span class="comment">         * key: Hash 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Invoker 虚拟节点个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> replicaNumber;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Invoker 集合的 HashCode 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> identityHashCode;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 需要参与 Hash 计算的参数索引。</span></span><br><span class="line"><span class="comment">         * 如：argumentIndex = [0,1,2] 时，表示调用的目标方法的前三个参数要参与 Hash 计算。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] argumentIndex;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面对核心属性进行介绍：</strong></p>
<p>需要说明的是，针对每一个请求的服务方法都会创建一个 <code>ConsistentHashLoadBalance</code> 。</p>
<ul>
<li><strong>virtualInvokers</strong><blockquote>
<p>用于缓存 Invoker 的虚拟节点，即多个 hash 值映射到同一个 Invoker 。</p>
</blockquote>
</li>
<li><strong>replicaNumber</strong><blockquote>
<p>用于记录每个 Invoker 虚拟节点的个数。</p>
</blockquote>
</li>
<li><strong>identityHashCode</strong><blockquote>
<p>用于记录请求涉及的 Invoker 集合的 HashCode 值。</p>
</blockquote>
</li>
<li><strong>argumentIndex</strong><blockquote>
<p>用于存储参与 Hash 计算的参数索引，用于请求负载均衡时对请求参数进行匹配，确定哪些参数参与 Hash 计算。</p>
</blockquote>
</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">        * @param invokers         消费端 Invoker 列表</span></span><br><span class="line"><span class="comment">        * @param methodName       方法名</span></span><br><span class="line"><span class="comment">        * @param identityHashCode Invoker 列表的 hashCode 的值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="keyword">int</span> identityHashCode) &#123;</span><br><span class="line">           <span class="comment">// 1 初始化 virtualInvokers 字段，用于缓存 Invoker 的虚拟节点</span></span><br><span class="line">           <span class="keyword">this</span>.virtualInvokers = <span class="keyword">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 2 记录 Invoker 集合的 hashCode，用该 hashCode 值可以判断 Provider 列表是否发生了变化</span></span><br><span class="line">           <span class="keyword">this</span>.identityHashCode = identityHashCode;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 3 获取消费端 Invoker 的 URL</span></span><br><span class="line">           URL url = invokers.get(<span class="number">0</span>).getUrl();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 4 从配置中获取虚拟节点数（hash.nodes 参数）以及参与 hash 计算的参数下标（hash.arguments 参数）</span></span><br><span class="line">           <span class="keyword">this</span>.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, <span class="number">160</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 5 对参与 hash  计算的参数下标进行解析，然后存放到 argumentIndex 数组中</span></span><br><span class="line">           String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, <span class="string">"0"</span>));</span><br><span class="line">           argumentIndex = <span class="keyword">new</span> <span class="keyword">int</span>[index.length];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">               argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 6 构建 Invoker 虚拟节点，默认 replicaNumber=160，相当于在 Hash 环上放 160 个槽位。外层轮询 40 次，内层轮询 4 次，共 40 * 4 = 160次，也就是同一个节点虚拟出 160 个槽位</span></span><br><span class="line">           <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">               <span class="comment">// 6.1 获取服务地址 host:port</span></span><br><span class="line">               String address = invoker.getUrl().getAddress();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                   <span class="comment">// 6.2 对 address + i 进行md5运算，得到一个长度为16的字节数组</span></span><br><span class="line">                   <span class="comment">// 基于服务地址进行 md5 计算</span></span><br><span class="line">                   <span class="keyword">byte</span>[] digest = md5(address + i);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 6.3 对 digest 部分字节进行 4 次 Hash 运算，得到 4 个不同的 long 型正整数</span></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                       <span class="comment">// h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span></span><br><span class="line">                       <span class="comment">// h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span></span><br><span class="line">                       <span class="comment">// h = 2, h = 3 时过程同上</span></span><br><span class="line">                       <span class="keyword">long</span> m = hash(digest, h);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 6.3 将 hash 到 Invoker 的映射关系存储到 virtualInvokers 中</span></span><br><span class="line">                       <span class="comment">// virtualInvokers 需要提供高效、有序的查询擦操作，因此选用 TreeMap 作为存储结构</span></span><br><span class="line">                       virtualInvokers.put(m, invoker);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><code>ConsistentHashSelector</code> 的构造方法核心点是 <code>创建虚拟节点（构建 Hash 环）</code> 和 <code>收集参与一致性Hash计算的参数下标（默认情况下只使用第一个参数，也就是下标为 0）</code> 。需要特别说明的是，<code>ConsistentHashLoadBalance</code> 的负载均衡逻辑只受<strong>参数值</strong>影响，具有相同参数值的请求将会被分配给同一个服务提供者，<code>ConsistentHashLoadBalance</code> 不关心权重，因此使用时需要注意一下。下面我们就来对其选择 Invoker 的 <code>select</code> 方法进行分析，从该方法就可以看出为什么说该负载均衡策略只受<strong>参数值</strong>影响。</p>
<h4 id="选择服务"><a href="#选择服务" class="headerlink" title="选择服务"></a>选择服务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+--- ConsistentHashSelector</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 选择合适的 Invoker 对象</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(Invocation invocation)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 将参与一致性 Hash 的参数拼接到一起</span></span><br><span class="line">            String key = toKey(invocation.getArguments());</span><br><span class="line">            <span class="comment">// 2 对 key 进行 md5 运算</span></span><br><span class="line">            <span class="keyword">byte</span>[] digest = md5(key);</span><br><span class="line">            <span class="comment">// 3 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，寻找合适的 Invoker</span></span><br><span class="line">            <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将参与 Hash 计算的参数索引对应的参数值进行拼接。默认对第一个参数进行 Hash 运算。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">toKey</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">// 对参与 Hash 计算的参数值进行拼接</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : argumentIndex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; args.length) &#123;</span><br><span class="line">                    buf.append(args[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 选择 Invoker</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> hash 调用方法参数处理后的 Hash 值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">selectForKey</span><span class="params">(<span class="keyword">long</span> hash)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 到 TreeMap 中查找第一个节点值大于或等于当前 hash 的 Invoker</span></span><br><span class="line">            Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.ceilingEntry(hash);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 如果传入的 hash 大于 Invoker 在 Hash 环上最大的位置，此时 entry = null，此时需要回到 Hash 环的开头返回第一个 Invoker 对象</span></span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry = virtualInvokers.firstEntry();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 取出目标 Invoker </span></span><br><span class="line">            <span class="keyword">return</span> entry.getValue();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>一致性 Hash 选择器 <code>ConsistentHashSelector</code> 选择的过程相对比较简单。先是对参数进行 <code>md5</code> 以及 <code>hash</code> 运算，得到一个 <strong>Hash 值</strong>，然后再拿这个 <strong>Hash 值</strong>到 <code>TreeMap</code> 中查找目标 Invoker 即可。</p>
<h2 id="ShortestResponseLoadBalance"><a href="#ShortestResponseLoadBalance" class="headerlink" title="ShortestResponseLoadBalance"></a>ShortestResponseLoadBalance</h2><p>ShortestResponseLoadBalance 使用的是 <code>最短响应时间的负载均衡算法</code>，和最小活跃数负载均衡算法类似，唯一的差别在于最短响应时间是<strong>基于调用成功的请求</strong>来计算实现的，而最小活跃数是直接基于当前正在处理的请求数实现的，其它的两者完全一致。最短响应时间越小，表明该服务提供者效率越高，此时可以将请求优先分配给该服务。在具体实现中，会记录每个服务提供者成功处理请求的个数以及对应的处理总时间，这样可以得到一个 <strong>成功调用的平均时间</strong> ，最后结合该服务提供者的最小活跃数，<strong>计算出最短响应时间</strong>。也就是从多个提供者节点中选出调用成功且响应时间最短的服务提供者节点。满足该条件的服务节点可能有多个，这种情况再使用加权随机算法进行一次选择就可以得到最终目标节点。</p>
<p>除了最短响应时间，<code>ShortestResponseLoadBalance</code> 在实现上还引入了权重，所以准确地说该负载均衡策略是基于<strong>加权最短响应时间算法</strong>实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestResponseLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"shortestresponse"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// -------------------------- 1 🪐 关键属性 ------------------------/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录 Invoker 集合数量</span></span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录所有 Invoker 集合中最短响应时间</span></span><br><span class="line">        <span class="keyword">long</span> shortestResponse = Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录具有相同最短响应时间（shortestResponse 的值）的 Invoker 数量</span></span><br><span class="line">        <span class="keyword">int</span> shortestCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放具有相同最短响应时间（shortestResponse 的值）的 Invoker 在 Invoker 列表中的下标</span></span><br><span class="line">        <span class="comment">// shortestIndexes 数组中如果有多个值，则说明有两个及以上的 Invoker 具有相同的最短响应时间</span></span><br><span class="line">        <span class="keyword">int</span>[] shortestIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放每个 Invoker 权重，主要用于当最短响应时间的 Invoker 数量有多个的情况</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录具有相同最短响应时间 Invoker 的总权重</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录第一个 Invoker 对象的权重</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记是否具有相同权重的最短响应时间的 Invoker</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --------------------------- 2 🪐 操作关键属性 -----------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有 Invoker ，选出最短响应时间的 Invoker 集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用到了消费方限流策略：ActiveLimitFilter</span></span><br><span class="line">            RpcStatus rpcStatus = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取调用成功的平均时间，计算方式：调用成功的请求数总数对应的总耗时 / 调用成功的请求数总数 = 成功调用的平均时间</span></span><br><span class="line">            <span class="keyword">long</span> succeededAverageElapsed = rpcStatus.getSucceededAverageElapsed();</span><br><span class="line">            <span class="comment">// 获取调用活跃请求数，也就是当前正在处理中的请求数</span></span><br><span class="line">            <span class="keyword">int</span> active = rpcStatus.getActive();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算一个处理新请求的预估值，也就是如果当前请求发给该提供者，大概耗时多久处理完成</span></span><br><span class="line">            <span class="keyword">long</span> estimateResponse = succeededAverageElapsed * active;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该 Invoker 的权重</span></span><br><span class="line">            <span class="keyword">int</span> afterWarmup = getWeight(invoker, invocation);</span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 和 LeastActiveLoadBalance 类似</span></span><br><span class="line">            <span class="comment">// 比较最短时间，发现更小值则更新相关属性，这种情况只有一个 Invoker</span></span><br><span class="line">            <span class="keyword">if</span> (estimateResponse &lt; shortestResponse) &#123;</span><br><span class="line">                <span class="comment">// 重新记录最短响应时间</span></span><br><span class="line">                shortestResponse = estimateResponse;</span><br><span class="line">                <span class="comment">// 重新记录最短响应时间的 Invoker 数量</span></span><br><span class="line">                shortestCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 重新记录最短响应时间的 Invoker 在 Invoker 列表中的下标</span></span><br><span class="line">                shortestIndexes[<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重置总权重</span></span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录第一个最短响应时间的 Invoker 的权重</span></span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重置权重相同标识</span></span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 出现多个耗时最短的Invoker对象</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (estimateResponse == shortestResponse) &#123;</span><br><span class="line">                <span class="comment">// 记录当前 Invoker 在 Invoker 列表中的下标</span></span><br><span class="line">                shortestIndexes[shortestCount++] = i;</span><br><span class="line">                <span class="comment">// 累加总权重，针对的是具有相同的最短响应时间</span></span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 判断是否存在相同权重的最短响应时间的 Invoker</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//------------------------------ 3 🪐 选择 Invoker ----------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仅有一个最短响应时间的 Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (shortestCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(shortestIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果耗时最短的所有Invoker对象的权重不相同，则通过加权随机负载均衡的方式选择一个Invoker返回</span></span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shortestCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> shortestIndex = shortestIndexes[i];</span><br><span class="line">                offsetWeight -= weights[shortestIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(shortestIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果耗时最短的所有 Invoker 对象的权重相同，则随机返回一个</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(shortestIndexes[ThreadLocalRandom.current().nextInt(shortestCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShortestResponseLoadBalance 核心思想是选择<strong>最短响应时间</strong>的服务提供者，如果最短响应时间的提供者有多个，则使用加权随机算法继续选择即可。由于和最小活跃数负载均衡策略基本一致，这里就不再具体描述。</p>
<p><strong>ShortestResponseLoadBalance 加权最短响应时间的核心点：</strong>根据 ActiveLimitFilter 统计的成功调用的平均时间，结合当前调用活跃请求数（当前正在处理中的请求数），计算出 Invoker 处理新请求的预估时间，这个时间作为响应时间的参考值。通过遍历服务列表，基于这个参考值找出最小的那个 Invoker ，如果最小的有多个再结合加权随机算法选择一个。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Dubbo 的五种负载均衡实现进行了详细分析，理解负载均衡代码逻辑的关键是理解对应的算法本身。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/9966fbd5/" title="集群容错 - LoadBalance" target="_blank" rel="external">https://gentryhuang.com/posts/9966fbd5/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/7f19ea26/" title="集群容错 - Cluster"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/26e2f6a4/" title="集群容错 - Router"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2022 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>