<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Dubbo源码分析 - Dubbo协议 | gentryhuang的博客</title>
  <meta name="description" content="前言在 多协议概览 中，我们对 Dubbo 的协议的两大分支从抽象层面进行了介绍，本篇文章将对 Dubbo 协议进行详细分析。 概述Dubbo 框架缺省协议就是 Dubbo 协议，该协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo 协议调用简化图如下：   Transporter: mina, netty, gri">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo源码分析 - Dubbo协议">
<meta property="og:url" content="https://gentryhuang.com/posts/a064181a/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="前言在 多协议概览 中，我们对 Dubbo 的协议的两大分支从抽象层面进行了介绍，本篇文章将对 Dubbo 协议进行详细分析。 概述Dubbo 框架缺省协议就是 Dubbo 协议，该协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo 协议调用简化图如下：   Transporter: mina, netty, gri">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-threadpool-model.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-codec.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-dubbo-protocol-export-hierarchy.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-protocol-exclusive-client.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-protocol-share-client.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-protocol-share-client-uml.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-protocol-refer-hierarchy.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-refer-protocol-invoker-uml.jpg">
<meta property="article:published_time" content="2020-08-29T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-11T14:49:25.093Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="Dubbo">
<meta property="article:tag" content="Protocol">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-threadpool-model.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/a064181a/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.38px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.75px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.13px;">I/O</a> <a href="/tags/JMM/" style="font-size: 13px;">JMM</a> <a href="/tags/JUC/" style="font-size: 13.5px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.25px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.13px;">Lock</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.25px;">Protocol</a> <a href="/tags/RPC/" style="font-size: 13.63px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.13px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.25px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.25px;">Spring</a> <a href="/tags/Thread/" style="font-size: 13.13px;">Thread</a> <a href="/tags/Zookeeper/" style="font-size: 13.13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.88px;">设计模式</a> <a href="/tags/%E9%99%90%E6%B5%81/" style="font-size: 13px;">限流</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/32609cb8/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
              </p>
              <p class="item-title">
                <a href="/posts/32609cb8/" class="title">限流算法</a>
              </p>
              <p class="item-date">
                <time datetime="2021-11-23T16:00:00.000Z" itemprop="datePublished">2021-11-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/11b0627b/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/11b0627b/" class="title">并发 - JMM</a>
              </p>
              <p class="item-date">
                <time datetime="2021-09-20T01:14:12.000Z" itemprop="datePublished">2021-09-20</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/ae5dbc38/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a>
              </p>
              <p class="item-title">
                <a href="/posts/ae5dbc38/" class="title">网络通信 - Reactor模型</a>
              </p>
              <p class="item-date">
                <time datetime="2021-09-12T13:10:23.000Z" itemprop="datePublished">2021-09-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/151f44ae/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/151f44ae/" class="title">并发 - ThreadLocal</a>
              </p>
              <p class="item-date">
                <time datetime="2021-09-03T04:30:12.000Z" itemprop="datePublished">2021-09-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/55ae5a2b/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/55ae5a2b/" class="title">Java基础 - Reference</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-21T02:30:12.000Z" itemprop="datePublished">2021-08-21</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#特性"><span class="toc-number">3.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#问题"><span class="toc-number">4.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dubbo-协议"><span class="toc-number">5.</span> <span class="toc-text">Dubbo 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QA"><span class="toc-number">5.1.</span> <span class="toc-text">QA</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DubboProtocol"><span class="toc-number">6.</span> <span class="toc-text">DubboProtocol</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#属性"><span class="toc-number">6.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务暴露"><span class="toc-number">6.2.</span> <span class="toc-text">服务暴露</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动NIO服务"><span class="toc-number">6.2.1.</span> <span class="toc-text">启动NIO服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通道处理器"><span class="toc-number">6.2.2.</span> <span class="toc-text">通道处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#服务端侧-Invoker"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">服务端侧 Invoker</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化序列化"><span class="toc-number">6.2.3.</span> <span class="toc-text">优化序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务暴露流程图"><span class="toc-number">6.2.4.</span> <span class="toc-text">服务暴露流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#领域模型"><span class="toc-number">6.2.5.</span> <span class="toc-text">领域模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务引用"><span class="toc-number">6.3.</span> <span class="toc-text">服务引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#连接NIO服务器"><span class="toc-number">6.3.1.</span> <span class="toc-text">连接NIO服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共享连接"><span class="toc-number">6.3.2.</span> <span class="toc-text">共享连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#属性-1"><span class="toc-number">6.3.2.1.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#其它方法"><span class="toc-number">6.3.2.1.2.</span> <span class="toc-text">其它方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#关闭"><span class="toc-number">6.3.2.1.3.</span> <span class="toc-text">关闭</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#独享连接"><span class="toc-number">6.3.3.</span> <span class="toc-text">独享连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LazyConnectExchangeClient"><span class="toc-number">6.3.4.</span> <span class="toc-text">LazyConnectExchangeClient</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性-2"><span class="toc-number">6.3.4.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造方法"><span class="toc-number">6.3.4.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#请求方法"><span class="toc-number">6.3.4.3.</span> <span class="toc-text">请求方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化连接"><span class="toc-number">6.3.4.4.</span> <span class="toc-text">初始化连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其它方法-1"><span class="toc-number">6.3.4.5.</span> <span class="toc-text">其它方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务引用流程图"><span class="toc-number">6.3.5.</span> <span class="toc-text">服务引用流程图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#销毁"><span class="toc-number">6.4.</span> <span class="toc-text">销毁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#领域模型-1"><span class="toc-number">6.5.</span> <span class="toc-text">领域模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DubboInvoker"><span class="toc-number">6.5.1.</span> <span class="toc-text">DubboInvoker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性-3"><span class="toc-number">6.5.1.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#远程调用"><span class="toc-number">6.5.1.2.</span> <span class="toc-text">远程调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Invoker-状态"><span class="toc-number">6.5.1.3.</span> <span class="toc-text">Invoker 状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#销毁-Invoker"><span class="toc-number">6.5.1.4.</span> <span class="toc-text">销毁 Invoker</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#编解码器"><span class="toc-number">7.</span> <span class="toc-text">编解码器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">8.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-rpc/Dubbo协议" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Dubbo源码分析 - Dubbo协议
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/a064181a/" class="article-date">
	  <time datetime="2020-08-29T16:00:00.000Z" itemprop="datePublished">2020-08-30</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/RPC/">RPC</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Dubbo/" rel="tag">Dubbo</a>, <a class="article-tag-link" href="/tags/Protocol/" rel="tag">Protocol</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/a064181a/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 10.2k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 44(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://gentryhuang.com/posts/450e3eda/">多协议概览</a> 中，我们对 Dubbo 的协议的两大分支从抽象层面进行了介绍，本篇文章将对 Dubbo 协议进行详细分析。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 框架缺省协议就是 Dubbo 协议，该协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo 协议调用简化图如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-threadpool-model.jpg" alt></p>
<ul>
<li>Transporter: mina, netty, grizzy</li>
<li>Serialization: dubbo, hessian2, java, json</li>
<li>Dispatcher: all, direct, message, execution, connection</li>
<li>ThreadPool: fixed, cached,limited,eager</li>
</ul>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><blockquote>
<p>连接个数：单一连接<br>连接方式：长连接<br>传输协议：TCP<br>传输方式：NIO 异步传输<br>序列化：默认采用 Hessian 二进制序列化<br>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。</p>
</blockquote>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li><strong>为什么要消费者比提供者个数多？</strong><blockquote>
<p>因为 Dubbo 协议采用单一长连接，每条连接数据压网卡的字节数据量是一定的，理论上一个服务提供者需要多个服务消费者才能压满网卡。</p>
</blockquote>
</li>
<li><strong>为什么不能传大包？</strong><blockquote>
<p>因为 Dubbo 协议采用单一长连接，如果每次请求的数据包太大，单个服务提供者的 TPS 会降低，因为网络带宽是一定的。此外，单个消费者调用单个服务提供者的 TPS 也会随着请求包变大而降低。</p>
</blockquote>
</li>
<li><strong>为什么采用异步单一长连接？</strong><blockquote>
<p>通过单一连接保证单一消费者不会压垮提供者；长连接减少连接握手验证等；使用异步 IO 复用线程池，防止 C10K 问题。</p>
</blockquote>
</li>
</ul>
<h1 id="Dubbo-协议"><a href="#Dubbo-协议" class="headerlink" title="Dubbo 协议"></a>Dubbo 协议</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-codec.jpg" alt></p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p><strong>不使用 HTTP 的原因:</strong></p>
<blockquote>
<ol>
<li>在设计 RPC 的时候，为了高性能和吞吐量，基于 TCP 性能更快。</li>
<li>一般 RPC 为了吞吐量，会异步发送请求，等待响应，所以需要知道哪个应答对应哪个请求，而 HTTP 属于无状态协议，无法实现请求跟响应关联。</li>
<li>版本不是很低的 HTTP 都支持 Keep-Alive 链接，可以避免了链接重复创建开销，也能支持长连接，但是目前应用 HTTP 更多是使用短连接。</li>
</ol>
</blockquote>
<p><strong>Dubbo 协议现存问题:</strong></p>
<blockquote>
<ol>
<li>Dubbo 协议是直接定义在 TCP 传输层协议之上，由于 TCP 高可靠全双工的特点，为 Dubbo 协议的定义提供了最大的灵活性，但同时也正是因为这样的灵活性，RPC 协议普遍都是定制化的私有协议，Dubbo 同样也面临这个问题。</li>
<li>相比于直接构建与 TPC 传输层的私有 RPC 协议，构建于 HTTP 之上的远程调用解决方案会有更好的通用性，如 WebServices 或 REST 架构，使用 HTTP + JSON 可以说是一个事实标准的解决方案。之所以选择构建在 HTTP 之上，有两大的优势：<ul>
<li>HTTP 的语义和可扩展性能很好的满足 RPC 调用需求。 - 扩展性</li>
<li>通用性，HTTP 协议几乎被网络上的所有设备所支持，具有很好的协议穿透性。- 通用性</li>
</ul>
</li>
</ol>
</blockquote>
<p><strong>优化点：</strong></p>
<blockquote>
<ol>
<li>Dubbo 协议体 Body 中有一个可扩展的 attachments 部分，这给 RPC 方法之外额外传递附加属性提供了可能，是一个很好的设计。但是类似的 Header 部分，却缺少类似的可扩展 attachments，这点可参考 HTTP 定义的 Ascii Header 设计，将 Body Attachments 和 Header Attachments 做职责划分。</li>
<li>Body 协议体中的一些 RPC 请求定位符如 Service Name、Method Name、Version 等，可以提到 Header 中，和具体的序列化协议解耦，以更好的被网络基础设施识别或用于流量管控。</li>
<li>扩展性不够好，欠缺协议升级方面的设计，如 Header 头中没有预留的状态标识位，或者像 HTTP 有专为协议升级或协商设计的特殊 packet。协议头要支持可扩展，可以定义一个扩展字段用于存放扩展信息，扩展后的协议头的长度就不能固定了，可以在协议头中加入一个标识头长度的字段。</li>
</ol>
</blockquote>
<p>Dubbo 协议设计上没有足够的前瞻性，但周边也有不少配件组件，如 <code>dubbo2.js</code>、<code>dubbo-go</code>、<code>dubbo-cpp</code> 等，在一定程度上解决了多语言问题。关于 Dubbo 协议具体可以参考 <a href="https://gentryhuang.com/posts/61d79ae/">编解码器</a> 中的介绍。</p>
<h1 id="DubboProtocol"><a href="#DubboProtocol" class="headerlink" title="DubboProtocol"></a>DubboProtocol</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"dubbo"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">20880</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数回调用相关字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IS_CALLBACK_SERVICE_INVOKE = <span class="string">"_isCallBackServiceInvoke"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DubboProtocol</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DubboProtocol INSTANCE;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通信服务集合</span></span><br><span class="line"><span class="comment">     * key: 服务器地址。格式：host:port</span></span><br><span class="line"><span class="comment">     * value: ExchangeServer 信息交换服务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ExchangeServer&gt; serverMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ExchangeServer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通信连接集合</span></span><br><span class="line"><span class="comment">     * key: 服务器地址 格式：host:port</span></span><br><span class="line"><span class="comment">     * value: 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ReferenceCountExchangeClient&gt; referenceClientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ReferenceCountExchangeClient&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通信连接集合 - 延迟连接的创建</span></span><br><span class="line"><span class="comment">     * key: 服务器地址 格式:host:port</span></span><br><span class="line"><span class="comment">     * value: 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, LazyConnectExchangeClient&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于jvm 锁集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Object&gt; locks = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已初始化的 SerializationOptimizer 实现类名的集合</span></span><br><span class="line"><span class="comment">     * 用于序列化优化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; optimizers = <span class="keyword">new</span> ConcurrentHashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//consumer side export a stub service for dispatching event  和本地存根相关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, String&gt; stubServiceMethodsMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        INSTANCE = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubboProtocol <span class="title">getDubboProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// dubbo SPI 获取 DubboProtocl</span></span><br><span class="line">            ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">DubboProtocol</span>.<span class="title">NAME</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DubboProtocol</code>中的属性包括以下几个方面的信息：</p>
<ol>
<li>Dubbo 协议的默认端口、Protocol 扩展实现</li>
<li>Dubbo 协议下的服务器和客户端缓存</li>
<li>序列化优化器实现</li>
</ol>
<h2 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取URL</span></span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line">        <span class="comment">//2 服务暴露</span></span><br><span class="line">        <span class="comment">//2.1 获取服务键,如：demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.0:20880</span></span><br><span class="line">        String key = serviceKey(url);</span><br><span class="line">        <span class="comment">//2.2 将上层传入的 Invoker 对象封装成 DubboExporter 对象</span></span><br><span class="line">        DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">        <span class="comment">//2.3 缓存 DubboExporter 到父类AbstractProtocol Map缓存中,相同则覆盖</span></span><br><span class="line">        exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//export an stub service for dispatching event 和本地存根有关</span></span><br><span class="line">        Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">        <span class="comment">// 参数回调相关</span></span><br><span class="line">        Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">            String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">            <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"consumer ["</span> + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                            <span class="string">"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3 启动服务器</span></span><br><span class="line">        openServer(url);</span><br><span class="line">        <span class="comment">// 4 优化序列化</span></span><br><span class="line">        optimizeSerialization(url);</span><br><span class="line">        <span class="comment">// 5 将 Invoker 以 Exporter 形式暴露出去</span></span><br><span class="line">        <span class="keyword">return</span> exporter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>DubboProtcol</code> 直接实现了 <code>Protocol</code> 的服务暴露接口，因为 <code>AbstractProtocol</code> 并没有对服务暴露接口进行实现。Dubbo 协议下的服务暴露核心就两点，将具有服务能力的 <code>Invoker</code> 封装成 <code>DubboExporter</code>，接着启动 <code>NIO服务器</code> 用于接收请求。 下面分别对启动服务和优化序列化部分详细分析。</p>
<h3 id="启动NIO服务"><a href="#启动NIO服务" class="headerlink" title="启动NIO服务"></a>启动NIO服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 host:port，并将其作为服务器实例缓存 key，用于标识当前的服务起实例</span></span><br><span class="line">        String key = url.getAddress();</span><br><span class="line">        <span class="comment">// 参数配置项 isserver，只有Server端才能启动Server对象</span></span><br><span class="line">        <span class="keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有Server端才能启动Server对象</span></span><br><span class="line">        <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">            <span class="comment">// 从serverMap缓存中获取服务器</span></span><br><span class="line">            ExchangeServer server = serverMap.get(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 无 Server监听该地址</span></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 不存在则创建 Server</span></span><br><span class="line">                serverMap.put(key, createServer(url));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果已有 Server 实例，则尝试根据URL信息重置 Server</span></span><br><span class="line">                <span class="comment">// com.alibaba.dubbo.remoting.transport.AbstractServer.reset</span></span><br><span class="line">                server.reset(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建并启动服务是以 Dubbo 的主机绑定结果 <code>host:port</code> 进行的，并且同一台服务器同一个端口上仅允许启动一个服务器实例，若某个端口上已有服务器实例，此时<code>reset</code>方法就会调用，重置服务器的一些配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line">   <span class="function"><span class="keyword">private</span> ExchangeServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 默认开启 在 Server 关闭的时候，只能发送 ReadOnly 请求</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 默认开启 心跳 【heartbeat参数会在HeaderExchangeServer启动心跳计时器使用】,默认值为 60000，表示默认的心跳时间间隔为 60 秒</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 检测SERVER_KEY参数指定的Transporter扩展实现是否合法, 即Dubbo SPI扩展是否存在，默认是Netty</span></span><br><span class="line">        String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">str</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported server type: "</span> + str + <span class="string">", url: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 设置编码解码器参数 ，默认为 DubboCountCodec</span></span><br><span class="line">        url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 创建、启动服务器</span></span><br><span class="line">        ExchangeServer server;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5.1 通过Exchangers门面类，创建ExchangeServer对象。</span></span><br><span class="line">            <span class="comment">// 需要传入 ExchangeHandler 对象，该对象用于处理通道相关事件 </span></span><br><span class="line">            server = Exchangers.bind(url, requestHandler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to start server(url: "</span> + url + <span class="string">") "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 校验Client 的 Dubbo SPI拓展是否存在。可指定netty,mina</span></span><br><span class="line">        str = url.getParameter(Constants.CLIENT_KEY);</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取所有的Transporter 实现类名称集合，比如 netty,mina</span></span><br><span class="line">            Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">getSupportedExtensions</span>()</span>;</span><br><span class="line">            <span class="comment">// 检测当前Dubbo 所支持的Transporter实现类名称列表中是否包含client所表示的 Transporter ，若不包含则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>DubboProtol</code> 在创建并启动 <code>NIO服务器</code> 之前，会为 <code>URL</code> 添加功能参数：</p>
<blockquote>
<p>1 channel.readonly.sent: 开启 在 Server 关闭的时候只能发送 ReadOnly 请求<br>2 heartbeat: 开启心跳，默认值为 60000 ，表示默认的心跳时间间隔为 60 s<br>3 codec: 设置编解码器，默认为 DubboCountCodec </p>
</blockquote>
<p>功能参数设置完毕后，通过信息交换层的 <code>Exchangers</code> 门面类创建 <code>ExchangeServer</code> 对象，并传入通道处理器 <code>ExchangeHandler</code> 对象。关于信息交换层的介绍可以参考 <a href="https://gentryhuang.com/posts/26722deb/">信息交换层</a> 一文。下面我们来看看 <code>DubboProtocol</code> 的通道处理器实现。</p>
<h3 id="通道处理器"><a href="#通道处理器" class="headerlink" title="通道处理器"></a>通道处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"> <span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理服务消费者的 同步调用和异步调用的请求</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">            <span class="comment">// 判断消息类型。其实，经过前面的 Hander 处理后这里收到的 Message 必须是 Invocation 类型的对象</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;</span><br><span class="line">                Invocation inv = (Invocation) message;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 获取此次调用的Invoker：</span></span><br><span class="line"><span class="comment">                 * 1 先获取 Exporter （在服务暴露时就已经初始化好了）</span></span><br><span class="line"><span class="comment">                 * 2 从 exporter 中获取 Invoker</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果是参数回调：</span></span><br><span class="line"><span class="comment">                 * 1 需要处理高版本调用低版本的问题</span></span><br><span class="line"><span class="comment">                 * 2 校验服务消费者实际存在对应的回调方法，通过方法名判断</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">                    String methodsStr = invoker.getUrl().getParameters().get(<span class="string">"methods"</span>);</span><br><span class="line">                    <span class="keyword">boolean</span> hasMethod = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (methodsStr == <span class="keyword">null</span> || methodsStr.indexOf(<span class="string">","</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">                        hasMethod = inv.getMethodName().equals(methodsStr);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        String[] methods = methodsStr.split(<span class="string">","</span>);</span><br><span class="line">                        <span class="keyword">for</span> (String method : methods) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (inv.getMethodName().equals(method)) &#123;</span><br><span class="line">                                hasMethod = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!hasMethod) &#123;</span><br><span class="line">                        logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"The methodName "</span> + inv.getMethodName()</span><br><span class="line">                                + <span class="string">" not found in callback service interface ,invoke will be ignored."</span></span><br><span class="line">                                + <span class="string">" please update the api interface. url is:"</span></span><br><span class="line">                                + invoker.getUrl()) + <span class="string">" ,invocation is :"</span> + inv);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置调用方的地址，即将消费方地址记录到 RpcContext 中</span></span><br><span class="line">                RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *  执行调用</span></span><br><span class="line"><span class="comment">                 *  1 执行 Filter链 ：EchoFilter-&gt;ClassLoaderFilter-&gt;GenericFilter-&gt;ContextFilter-&gt;TraceFilter-&gt;TimeoutFilter-&gt;MonitorFilter-&gt;ExceptionFilter -&gt; Invoker逻辑</span></span><br><span class="line"><span class="comment">                 *  2 然后执行真正的Invoker的调用逻辑：AbstractProxyInvoker.invoke -&gt; JavassistProxyFactory$AbstractProxyInvoker.doInvoke -&gt; Wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments) -&gt; ref.xxxYYY方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Unsupported request: "</span></span><br><span class="line">                    + (message == <span class="keyword">null</span> ? <span class="keyword">null</span> : (message.getClass().getName() + <span class="string">": "</span> + message))</span><br><span class="line">                    + <span class="string">", channel: consumer: "</span> + channel.getRemoteAddress() + <span class="string">" --&gt; provider: "</span> + channel.getLocalAddress());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *处理读取到的数据</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">            <span class="comment">// 判断消息类型是不是 Invocation</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;</span><br><span class="line">                reply((ExchangeChannel) channel, message);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.received(channel, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---------------- 以下是对设置的 onconnect 和 ondisconnect 方法的处理 -----------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在服务提供者上可以配置 onconnect 配置项指定连接上服务时会调用的方法 - 不是很重要</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">            invoke(channel, Constants.ON_CONNECT_KEY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在服务提供者上可以配置 'ondisconnect' 配置项指定方法，在服务提供者连接断开时会调用该方法 - 不是很重要</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"disconnected from "</span> + channel.getRemoteAddress() + <span class="string">",url:"</span> + channel.getUrl());</span><br><span class="line">            &#125;</span><br><span class="line">            invoke(channel, Constants.ON_DISCONNECT_KEY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 进行调用，执行对应的方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel 通道</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> methodKey 方法名</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Channel channel, String methodKey)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 创建调用信息 Invocation 对象</span></span><br><span class="line">            Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);</span><br><span class="line">            <span class="comment">// 如果 invocation 不为空，执行received方法</span></span><br><span class="line">            <span class="keyword">if</span> (invocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    received(channel, invocation);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Failed to invoke event method "</span> + invocation.getMethodName() + <span class="string">"(), cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建 Invocation</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> methodKey</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Invocation <span class="title">createInvocation</span><span class="params">(Channel channel, URL url, String methodKey)</span> </span>&#123;</span><br><span class="line">            String method = url.getParameter(methodKey);</span><br><span class="line">            <span class="keyword">if</span> (method == <span class="keyword">null</span> || method.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RpcInvocation invocation = <span class="keyword">new</span> RpcInvocation(method, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>], <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">            invocation.setAttachment(Constants.PATH_KEY, url.getPath());</span><br><span class="line">            invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY));</span><br><span class="line">            invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY));</span><br><span class="line">            invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY));</span><br><span class="line">            <span class="keyword">if</span> (url.getParameter(Constants.STUB_EVENT_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> invocation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p><code>DubboProtocol</code> 中实现了信息交换层中的 <code>ExchangeHandlerAdapter</code> 通道处理器逻辑，服务消费者的远程调用是通过 <code>#reply</code> 方法处理的，该方法的核心逻辑如下：</p>
<ol>
<li>根据连接信息和调用信息组装服务健，并根据服务健获取具有服务能力的 <code>Invoker</code> 对象。</li>
<li>如果设置了参数回调用，则对参数回调逻辑进行处理。关于参数回调内容会在 Dubbo 高级特性中介绍。</li>
<li>将调用方的地址即消费端地址记录到上下文中。</li>
<li>执行 <code>Invoker.invoke</code> 。</li>
</ol>
<p>下面我们继续分析获取 <code>Invoker</code> 对象的方法。</p>
<h4 id="服务端侧-Invoker"><a href="#服务端侧-Invoker" class="headerlink" title="服务端侧 Invoker"></a>服务端侧 Invoker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"> Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isCallBackServiceInvoke = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isStubServiceInvoke = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取端口</span></span><br><span class="line">        <span class="keyword">int</span> port = channel.getLocalAddress().getPort();</span><br><span class="line">        <span class="comment">// 从调用信息中国获取 path</span></span><br><span class="line">        String path = inv.getAttachments().get(Constants.PATH_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对客户端 Callback 的处理</span></span><br><span class="line">        isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getAttachments().get(Constants.STUB_EVENT_KEY));</span><br><span class="line">        <span class="keyword">if</span> (isStubServiceInvoke) &#123;</span><br><span class="line">            <span class="comment">// 从Channel中获取 端口 port</span></span><br><span class="line">            port = channel.getRemoteAddress().getPort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 参数回调处理，获得真正的服务名 `path`</span></span><br><span class="line">        isCallBackServiceInvoke = isClientSide(channel) &amp;&amp; !isStubServiceInvoke;</span><br><span class="line">        <span class="keyword">if</span> (isCallBackServiceInvoke) &#123;</span><br><span class="line">            path = inv.getAttachments().get(Constants.PATH_KEY) + <span class="string">"."</span> + inv.getAttachments().get(Constants.CALLBACK_SERVICE_KEY);</span><br><span class="line">            inv.getAttachments().put(IS_CALLBACK_SERVICE_INVOKE, Boolean.TRUE.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得服务键，格式： group/path:version:port</span></span><br><span class="line">        <span class="comment">// 根据 Invocation 携带的信息：attachments 中的path、group、version以及从channel中获取的port 计算服务健</span></span><br><span class="line">        String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据服务健查找缓存的 DubboExporter</span></span><br><span class="line">        DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有对应的 Exporter，直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Not found exported service: "</span> + serviceKey + <span class="string">" in "</span> + exporterMap.keySet() + <span class="string">", may be version or group mismatch "</span> + <span class="string">", channel: consumer: "</span> + channel.getRemoteAddress() + <span class="string">" --&gt; provider: "</span> + channel.getLocalAddress() + <span class="string">", message:"</span> + inv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出Exporter中的Invoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>获取服务端侧 <code>Invoker</code> 就是根据 <strong>服务键</strong> 从缓存中取出服务暴露时存储在内存中的 <code>Expoter</code> 对象，进而从该 <code>Expoter</code> 中取出对应的 <code>Invoker</code> 对象。注意，服务键的 <code>group</code>、<code>path</code>、<code>verison</code> 都是从调用信息中获取的，因为调用方更清楚目标服务，而 <code>port</code> 部分则是通过通道获取的，调用方无需关心端口，提供方自己更加清楚。</p>
<h3 id="优化序列化"><a href="#优化序列化" class="headerlink" title="优化序列化"></a>优化序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">optimizeSerialization</span><span class="params">(URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="comment">// 获得 optimizer 序列化优化器 配置项</span></span><br><span class="line">       String className = url.getParameter(Constants.OPTIMIZER_KEY, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果系统中没有指定序列化优化器就直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(className) || optimizers.contains(className)) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       logger.info(<span class="string">"Optimizing the serialization process for Kryo, FST, etc..."</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 根据 序列化优化器名 加载 SerializationOptimizer 实现类</span></span><br><span class="line">           Class clazz = Thread.currentThread().getContextClassLoader().loadClass(className);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 是否是 SerializationOptimizer.class，或者 是SerializationOptimizer 的子类</span></span><br><span class="line">           <span class="keyword">if</span> (!SerializationOptimizer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)) </span>&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"The serialization optimizer "</span> + className + <span class="string">" isn't an instance of "</span> + SerializationOptimizer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 创建 SerializationOptimizer 对象</span></span><br><span class="line">           SerializationOptimizer optimizer = (SerializationOptimizer) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 没有要优化的类直接返回</span></span><br><span class="line">           <span class="keyword">if</span> (optimizer.getSerializableClasses() == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将要优化的类注册到 SerializableClassRegistry 中 </span></span><br><span class="line">           <span class="comment">// 在使用 Kryo,FST 等序列化算法时，会读取该集合中的类，完成注册.</span></span><br><span class="line">           <span class="keyword">for</span> (Class c : optimizer.getSerializableClasses()) &#123;</span><br><span class="line">               SerializableClassRegistry.registerClass(c);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将 序列化优化器实现类名 加入到缓存中</span></span><br><span class="line">           optimizers.add(className);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot find the serialization optimizer class: "</span> + className, e);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot instantiate the serialization optimizer class: "</span> + className, e);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot instantiate the serialization optimizer class: "</span> + className, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>服务暴露时会进行序列化优化，通过自定义 <code>SerializationOptimizer</code> 对象将需要优化的类全部加入到该对象中即可。关于序列化的介绍可以参考 <a href="https://gentryhuang.com/posts/16132b67/#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%98%E5%8C%96%E5%99%A8">序列化优化器</a> 一文。</p>
<h3 id="服务暴露流程图"><a href="#服务暴露流程图" class="headerlink" title="服务暴露流程图"></a>服务暴露流程图</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-dubbo-protocol-export-hierarchy.jpg" alt></p>
<p>Dubbo 框架采用 Dubbo 协议进行服务发布的流程如上图所示。从 <code>Protocol 协议层</code> 的 <strong>openServer</strong> 方法会一路调用到 <code>Exchange 信息交换层</code>、<code>Transport 网络传输层</code>，最终创建并启动 <code>Netty 服务</code> 来接收客户端的请求。</p>
<h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><p><code>DubboExpoter</code> 是对服务端侧的 <code>Invoker</code> 的封装，服务端侧的 <code>Invoker</code> 内部封装了具体服务实现，具备服务能力。<code>DubboExpoter</code> 继承了 <code>AbstractExpoter</code> 抽象类，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboExporter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractExporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exporter 集合</span></span><br><span class="line"><span class="comment">     * key : 服务键</span></span><br><span class="line"><span class="comment">     * value: DubboProtocol 发布的服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装 Invoker</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker     Invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key         服务键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporterMap AbstractProtocol.exporterMap属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboExporter</span><span class="params">(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(invoker);</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.exporterMap = exporterMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取消暴露</span></span><br><span class="line">        <span class="keyword">super</span>.unexport();</span><br><span class="line">        <span class="comment">//清理该 DubboExporter 实例在 exporterMap 中相应的元素</span></span><br><span class="line">        exporterMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="服务引用"><a href="#服务引用" class="headerlink" title="服务引用"></a>服务引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 初始化序列化优化器</span></span><br><span class="line">        optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建 DubboInvoker 对象</span></span><br><span class="line">        DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 添加到 invokers 缓存中</span></span><br><span class="line">        invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>DubboProtocol</code> 直接实现了 <code>Protocol</code> 的服务引用接口。Dubbo 协议下的服务引用核心就一个，创建 <code>DubboInvoker</code> 对象，该对象会对 <code>Client</code> 进行封装，用于发送请求和接收响应。初始化序化优化器同服务暴露中的一致。</p>
<h3 id="连接NIO服务器"><a href="#连接NIO服务器" class="headerlink" title="连接NIO服务器"></a>连接NIO服务器</h3><p><code>getClients</code> 方法创建了底层发送请求和接收响应的 <code>Client</code> 集合，即创建客户端与服务端的长连接。其核心实现分为两部分，一个是针对<strong>共享连接</strong>的处理，另一个是针对<strong>独享连接</strong>的处理。实现逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"><span class="keyword">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">        <span class="comment">// 是否使用共享连接</span></span><br><span class="line">        <span class="keyword">boolean</span> service_share_connect = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 connections 配置项，该值决定了后续建立连接的数量。不配置的情况下默认为0，并使用共享连接的方式，建立一条共享连接。</span></span><br><span class="line">        <span class="keyword">int</span> connections = url.getParameter(Constants.CONNECTIONS_KEY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有连接数的相关配置，默认使用共享连接的方式，且连接数为 1</span></span><br><span class="line">        <span class="comment">// Dubbo 在 2.7 版本中支持共享连接数的配置 SHARE_CONNECTIONS_KEY</span></span><br><span class="line">        <span class="keyword">if</span> (connections == <span class="number">0</span>) &#123;</span><br><span class="line">            service_share_connect = <span class="keyword">true</span>;</span><br><span class="line">            connections = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接服务提供者的 ExchangeClient 对象数组</span></span><br><span class="line">        ExchangeClient[] clients = <span class="keyword">new</span> ExchangeClient[connections];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class="line">            <span class="comment">//  1 共享连接</span></span><br><span class="line">            <span class="keyword">if</span> (service_share_connect) &#123;</span><br><span class="line">                clients[i] = getSharedClient(url);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 取独享连接，connections 的值为多少就会创建几个独享连接，在调用时会轮流使用。</span></span><br><span class="line">                <span class="comment">// 注意和 Dubbo 负载均衡的区别。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clients[i] = initClient(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>ExchangeClient</code> 实际上并不具有通信能力，通信能力依赖其封装的更底层客户端实例，如 <code>NettyClient</code>、<code>MinaClient</code> 等。</p>
<p>当使用独享连接时，针对每个服务（对应一个Service）创建固定数量的 <code>Client</code> ，每个 <code>Client</code> 维护一个底层连接。如下图所示，<code>connections</code> 配置项设置了 2 ，也就是针对每个 Service 都启动了两个独享连接。</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-protocol-exclusive-client.jpg" alt></p>
<p>当使用共享连接时，会根据节点地址（host:port），一个地址只创建固定数量的共享连接。如下图所示，<code>shareconnections</code> 配置项设置了 2，也就是针对每个服务节点都会创建两个共享连接，这两个共享连接被节点中的所有服务使用，如 Consumer 调用 Provider1 提供者中的多个服务时，是使用固定数量的共享长连接进行数据传输，这样就可以达到减少服务端连接的目的。</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-protocol-share-client.jpg" alt></p>
<h3 id="共享连接"><a href="#共享连接" class="headerlink" title="共享连接"></a>共享连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"> <span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">getSharedClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取从注册中心拉取的服务提供者的地址（ip:port），连接服务自然需要知道服务地址</span></span><br><span class="line">        String key = url.getAddress();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 从 referenceClientMap 中获取与该地址连接的带有引用记数功能的ExchangeClient</span></span><br><span class="line">        ReferenceCountExchangeClient client = referenceClientMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!client.isClosed()) &#123;</span><br><span class="line">                <span class="comment">/** 若未关闭，增加指向该Client 的数量 &#123;<span class="doctag">@link</span> #refenceCount&#125;  */</span></span><br><span class="line">                client.incrementAndGetCount();</span><br><span class="line">                <span class="keyword">return</span> client;</span><br><span class="line">                <span class="comment">// 若已关闭，移除</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                referenceClientMap.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增锁对象</span></span><br><span class="line">        locks.putIfAbsent(key, <span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">// 针对指定地址的客户端创建进行加锁，这里使用分区加锁可以提高并发度</span></span><br><span class="line">        <span class="keyword">synchronized</span> (locks.get(key)) &#123;</span><br><span class="line">            <span class="comment">// double check</span></span><br><span class="line">            <span class="keyword">if</span> (referenceClientMap.containsKey(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> referenceClientMap.get(key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 初始化 ExchangeClient 客户端</span></span><br><span class="line">            ExchangeClient exchangeClient = initClient(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 使用装饰者模式将initClient返回的HeaderExchangeClient实例或LazyConnectExchangeClient实例封装为ReferenceCountExchangeClient对象</span></span><br><span class="line">            <span class="comment">// 注意，在使用共享连接时需要注意一个问题，如果两个以上的Invoker 共享这个连接的话，那么必须所有的Invoker 都关闭才能关闭连接。</span></span><br><span class="line">            client = <span class="keyword">new</span> ReferenceCountExchangeClient(exchangeClient, ghostClientMap);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 添加到缓存集合</span></span><br><span class="line">            referenceClientMap.put(key, client);</span><br><span class="line">            <span class="comment">// 6 新建了ExchangeClient，不需要进行兜底，移除兜底集合 ghostClientMap 中的元素</span></span><br><span class="line">            ghostClientMap.remove(key);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将作为锁标识的元素从集合中移除</span></span><br><span class="line">            locks.remove(key);</span><br><span class="line">            <span class="keyword">return</span> client;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>共享连接的创建是在独享连接创建的基础上进行的，共享连接的缓存基于对端地址（ip:port），同时共享连接的实现是 <code>ReferenceCountExchangeClient</code>，它是 <code>ExchangeClient</code> 的一个装饰器，在原始的 <code>ExchangeClient</code> 对象基础上添加了引用计数的功能。</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>共享连接使用的客户端实现是 <code>ReferenceCountExchangeClient</code> ，它是对信息交换层的 <code>ExchangeClient</code> 接口的直接实现，是 <code>ExchangeClient</code> 的装饰器，在原始的 <code>ExchangeClient</code> 对象基础上添加了引用计数功能，用于共享连接模式。在介绍信息交换层的客户端时，其中的 <code>HeaderExchangeClient</code> 也是对 <code>ExchangeClient</code> 接口的直接实现，这里 <code>ReferenceCountExchangeClient</code> 装饰的 <code>ExchangeClient</code> 就是 <code>HeaderExchangeClient</code> 对象。Dubbo 协议客户端继承关系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-protocol-share-client-uml.jpg" alt></p>
<p>下面对 <code>ReferenceCountExchangeClient</code> 进行介绍。</p>
<h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountExchangeClient</span> <span class="keyword">implements</span> <span class="title">ExchangeClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用计数变量，用于记录 Client 被应用的次数。 每当该对象被引用一次refenceCount 都会进行自增。 每当close方法被调用时，referenceCount 就会进行自减</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger refenceCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维护close掉的client，用于兜底。和 &#123;<span class="doctag">@link</span> Protocol#ghostClentMap&#125; 一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端 【类型是： HeaderExchangeClient】，被装饰对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExchangeClient client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将HeaderExchangeClient 实例封装为ReferenceCountExchangeClient。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ghostClientMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountExchangeClient</span><span class="params">(ExchangeClient client, ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="comment">// 引用计数递增</span></span><br><span class="line">        refenceCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">this</span>.url = client.getUrl();</span><br><span class="line">        <span class="keyword">if</span> (ghostClientMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ghostClientMap can not be null, url: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.ghostClientMap = ghostClientMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReferenceCountExchangeClient</code> 中持有的 <strong>client</strong> 属性就是被装饰的信息交换层的客户端对象，<strong>refenceCount</strong> 属性用于记录该 Client 被引用的次数，在 <code>ReferenceCountExchangeClient</code> 的构造方法以及 <code>incrementAndGetCount()</code> 方法中会增加引用次数，在 <code>close()</code> 方法中则会减少引用次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--- ReferenceCountExchangeClient</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法一般由外部调用，引用计数递增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementAndGetCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        refenceCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">+--- ReferenceCountExchangeClient</span><br><span class="line">  <span class="comment">// ----------- ExchangeChannel 接口方法实现 --------------/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.request(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.request(request, timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeHandler <span class="title">getExchangeHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getExchangeHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------- Endpoint 接口方法实现 -----------------/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        client.send(message, sent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        client.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getUrl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">getChannelHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getChannelHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">getLocalAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getLocalAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(Parameters parameters)</span> </span>&#123;</span><br><span class="line">        client.reset(parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        client.reset(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * close() is not idempotent any longer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        close(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用次数减少到0时 ，ExchangeClient 连接关闭</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 引用计数减一，若无指向，进行真正的关闭</span></span><br><span class="line">        <span class="keyword">if</span> (refenceCount.decrementAndGet() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">                client.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client.close(timeout);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭ExchangeClient对象之后，会替换 client 为 LazyConnectExchangeClient 对象，即将关闭之后的连接变成一个懒加载的client</span></span><br><span class="line">            client = replaceWithLazyClient();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.startClose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.isClosed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- Channel 接口实现 ----------/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.isConnected();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.hasAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        client.setAttribute(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        client.removeAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">getRemoteAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getRemoteAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- Client 接口实现 ----------/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reconnect</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        client.reconnect();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>采用装饰器模式，每个方法的实现都是交给被装饰的 <strong>client</strong> 处理，也就是 <code>HeaderExchangeClient</code> 处理。以上方法实现来源于不同的接口或类，和 <code>HeaderExchangeClient</code> 中的实现几乎一致，看起来比较乱，但是追溯到最底层可以发现，这些方法几乎都是交给通道 <code>Channel</code> 来处理的，Client 只完成了重连的逻辑。</p>
<h5 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+--- ReferenceCountExchangeClient</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 引用计数减一，若无指向，进行真正的关闭</span></span><br><span class="line">        <span class="keyword">if</span> (refenceCount.decrementAndGet() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">                client.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client.close(timeout);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭ExchangeClient对象之后，会替换 client 为 LazyConnectExchangeClient 对象，即将关闭之后的连接变成一个懒加载的client</span></span><br><span class="line">            client = replaceWithLazyClient();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> LazyConnectExchangeClient <span class="title">replaceWithLazyClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在原有的URL之上，添加一些LazyConnectExchangeClient特有的参数</span></span><br><span class="line">        URL lazyUrl = url.addParameter(Constants.LAZY_CONNECT_INITIAL_STATE_KEY, Boolean.FALSE)</span><br><span class="line">                <span class="comment">// 关闭重连</span></span><br><span class="line">                .addParameter(Constants.RECONNECT_KEY, Boolean.FALSE)</span><br><span class="line">                .addParameter(Constants.SEND_RECONNECT_KEY, Boolean.TRUE.toString())</span><br><span class="line">                .addParameter(<span class="string">"warning"</span>, Boolean.TRUE.toString())</span><br><span class="line">                .addParameter(LazyConnectExchangeClient.REQUEST_WITH_WARNING_KEY, <span class="keyword">true</span>)</span><br><span class="line">                .addParameter(<span class="string">"_client_memo"</span>, <span class="string">"referencecounthandler.replacewithlazyclient"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 ghostClientMap 缓存中查找</span></span><br><span class="line">        String key = url.getAddress();</span><br><span class="line">        <span class="comment">// in worst case there's only one ghost connection.</span></span><br><span class="line">        LazyConnectExchangeClient gclient = ghostClientMap.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前client字段已经指向了LazyConnectExchangeClient，则不需要再次创建</span></span><br><span class="line">        <span class="keyword">if</span> (gclient == <span class="keyword">null</span> || gclient.isClosed()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ChannelHandler 依旧使用原始ExchangeClient使用的Handler，即DubboProtocol中的requestHandler字段</span></span><br><span class="line">            gclient = <span class="keyword">new</span> LazyConnectExchangeClient(lazyUrl, client.getExchangeHandler());</span><br><span class="line">            ghostClientMap.put(key, gclient);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gclient;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从 <code>ReferenceCountExchangeClient</code> 关闭逻辑可以发现：</p>
<blockquote>
<ol>
<li>当引用次数减到 0 的时候，ExchangeClient 连接允许关闭。当引用次数未减到 0 的时候，底层的 ExchangeClient 不能关闭。</li>
<li>在关闭底层 ExchangeClient 对象之后，会立即创建一个 LazyConnectExchangeClient 对象，用于异常情况的兜底。这个连接的特点是在需要发送请求的时候才会进行 Client 的创建。</li>
</ol>
</blockquote>
<p>前文也提到，共享连接的创建是在独享连接的基础上，独享连接创建是通过 <code>initClient</code> 方法，而共享连接是以地址（host:port）作为标识将独享连接缓存，避免同一地址创建多条连接。下面我们就来分析独享连接的创建。</p>
<h3 id="独享连接"><a href="#独享连接" class="headerlink" title="独享连接"></a>独享连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"> <span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">initClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 获取客户端类型，默认为netty。下面逻辑会检查该扩展</span></span><br><span class="line">        String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 设置编解码器Codec2的扩展名,即DubboCountCodec &#123;@link DubboCountCodec&#125;</span></span><br><span class="line">        url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 默认开启heartbeat,60 * 1000</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验配置的Client 的 Dubbo SPI拓展是否存在，若不存在，抛出RpcException</span></span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">str</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str + <span class="string">","</span> +</span><br><span class="line">                    " supported client type is " + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), " "));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 连接服务器，创建客户端</span></span><br><span class="line">        ExchangeClient client;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.1 如果配置了延迟创建连接的特性</span></span><br><span class="line">            <span class="keyword">if</span> (url.getParameter(Constants.LAZY_CONNECT_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                <span class="comment">// 创建延迟建立连接的对象（在请求时才会初始化连接）</span></span><br><span class="line">                client = <span class="keyword">new</span> LazyConnectExchangeClient(url, requestHandler);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4.2 未使用延迟连接功能，则通过Exchangers的 connect 方法创建 ExchangeClient 客户端，这里是 HeaderExchangeClient</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client = Exchangers.connect(url, requestHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to create remoting client for service("</span> + url + <span class="string">"): "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>DubboProtocol</code> 创建连接的流程如下：</p>
<ol>
<li>对客户端扩展名进行校验，默认使用 netty </li>
<li>设置编解码器 Codec2 的扩展名，这里固定是 DubboCountCodec</li>
<li>设置心跳时间</li>
<li>连接NIO服务器，创建客户端。这里会根据是否设置延迟创建连接的特性创建不同的 Client </li>
</ol>
<p>没有设置延迟创建连接的配置项时直接使用信息交换层的 <code>Exchangers.connect</code> 创建 <code>HeaderExchangeClient</code> 对象，否则创建 <code>LazyConnectExchangeClient</code> 对象，该对象不会立刻初始化连接而是在请求时才会初始化。</p>
<h3 id="LazyConnectExchangeClient"><a href="#LazyConnectExchangeClient" class="headerlink" title="LazyConnectExchangeClient"></a>LazyConnectExchangeClient</h3><p><code>LazyConnectExchangeClient</code> 同样是 <code>ExchangeClient</code> 的装饰器，它会在原有 <code>ExchangeClient</code> 对象的基础上添加延迟初始化连接的功能，即在发送请求的时候才会进行初始化。</p>
<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyConnectExchangeClient</span> <span class="keyword">implements</span> <span class="title">ExchangeClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(LazyConnectExchangeClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟连接告警配置项</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String REQUEST_WITH_WARNING_KEY = <span class="string">"lazyclient_request_with_warning"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求时，是否检查告警</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> requestWithWarning;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeHandler requestHandler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock connectLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 懒连接初始化状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> initialState;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通信客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ExchangeClient client;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 警告计数器。每超过一定次数，打印告警日志。参见 &#123;<span class="doctag">@link</span> #warning(Object)&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong warningcount = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LazyConnectExchangeClient</code> 中的 <strong>url</strong> 和 <strong>requestHandler</strong> 是创建对象的时候封装的属性，<code>LazyConnectExchangeClient</code> 在构造方法中不会创建底层持有连接的 <strong>Client</strong>，而是在需要发送请求的时候才会调用 <strong>initClient()</strong> 方法进行 <strong>Client</strong> 的创建。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--- LazyConnectExchangeClient</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyConnectExchangeClient</span><span class="params">(URL url, ExchangeHandler requestHandler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 延迟连接需要设置 send.reconnect 为 true，防止通道不良状态</span></span><br><span class="line">        <span class="keyword">this</span>.url = url.addParameter(Constants.SEND_RECONNECT_KEY, Boolean.TRUE.toString());</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = requestHandler;</span><br><span class="line">        <span class="comment">// 懒连接初始化状态默认值为 true</span></span><br><span class="line">        <span class="keyword">this</span>.initialState = url.getParameter(Constants.LAZY_CONNECT_INITIAL_STATE_KEY, Constants.DEFAULT_LAZY_CONNECT_INITIAL_STATE);</span><br><span class="line">        <span class="keyword">this</span>.requestWithWarning = url.getParameter(REQUEST_WITH_WARNING_KEY, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+--- LazyConnectExchangeClient</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        warning(request);</span><br><span class="line">        initClient();</span><br><span class="line">        <span class="keyword">return</span> client.request(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        warning(request);</span><br><span class="line">        initClient();</span><br><span class="line">        <span class="keyword">return</span> client.request(request, timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息/请求前，都会调用该方法，确保客户端已经初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        client.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        client.send(message, sent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化连接"><a href="#初始化连接" class="headerlink" title="初始化连接"></a>初始化连接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--- LazyConnectExchangeClient</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 已初始化，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Lazy connect to "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得锁</span></span><br><span class="line">        connectLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 已初始化，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建Client,连接服务器</span></span><br><span class="line">            <span class="keyword">this</span>.client = Exchangers.connect(url, requestHandler);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            connectLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="其它方法-1"><a href="#其它方法-1" class="headerlink" title="其它方法"></a>其它方法</h4><p><code>LazyConnectExchangeClient</code> 中的其它方法同样是对不同接口和类中的方法实现，如获取地址的方法，获取处理器的方法，关闭相关的方法以及和通道属性相关的方法。</p>
<h3 id="服务引用流程图"><a href="#服务引用流程图" class="headerlink" title="服务引用流程图"></a>服务引用流程图</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-protocol-refer-hierarchy.jpg" alt></p>
<p>Dubbo 框架采用 Dubbo 协议进行服务引用的流程图如上图所示。从 <code>Protocol 协议层</code> 的 <strong>getClients</strong> 方法会一路调用到 <code>Exchange 信息交换层</code>、<code>Transport 网络传输层</code>，最终启动客户端并连接到服务器，后续就可以使用处于健康状态的连接进行双向远程通信了。</p>
<h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><p>在 <code>DubboProtocol</code> 销毁的时候，会调用 <code>destroy()</code> 方法释放底层资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 销毁所有通信服务器 ExchangeServer</span></span><br><span class="line">        <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(serverMap.keySet())) &#123;</span><br><span class="line">            <span class="comment">// 1.1 先从缓存中删除通信服务器</span></span><br><span class="line">            ExchangeServer server = serverMap.remove(key);</span><br><span class="line">            <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Close dubbo server: "</span> + server.getLocalAddress());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 在close()方法中，下层（如HeaderExchangeServer）会发送ReadOnly请求、阻塞指定时间、关闭底层的定时任务、关闭相关线程池，最终，会断开所有连接，关闭Server。</span></span><br><span class="line">                    <span class="comment">// 这些逻辑在前文介绍HeaderExchangeServer、NettyServer等实现的时候</span></span><br><span class="line">                    <span class="comment">// 在优雅停机的等待时长内关闭 [保证了服务平滑的下线]</span></span><br><span class="line">                    server.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 销毁所有通信客户端 ExchangeClient</span></span><br><span class="line">        <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(referenceClientMap.keySet())) &#123;</span><br><span class="line">            <span class="comment">// 2.1 先从缓存中删除通信客户端</span></span><br><span class="line">            ExchangeClient client = referenceClientMap.remove(key);</span><br><span class="line">            <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Close dubbo connect: "</span> + client.getLocalAddress() + <span class="string">"--&gt;"</span> + client.getRemoteAddress());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ReferenceCountExchangeClient 中只有引用减到 0，底层的 Client 才会真正销毁</span></span><br><span class="line">                    <span class="comment">// 在优雅停机的等待时长内关闭 【保证在处理的请求能够尽可能的在优雅停机时间内完成处理】</span></span><br><span class="line">                    client.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 销毁所有的通信客户端 LazyConnectExchangeClient</span></span><br><span class="line">        <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(ghostClientMap.keySet())) &#123;</span><br><span class="line">            <span class="comment">// 3.1 先从缓存中删除</span></span><br><span class="line">            ExchangeClient client = ghostClientMap.remove(key);</span><br><span class="line">            <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Close dubbo connect: "</span> + client.getLocalAddress() + <span class="string">"--&gt;"</span> + client.getRemoteAddress());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 在优雅停机的等待时长内关闭</span></span><br><span class="line">                    client.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理 stub 缓存</span></span><br><span class="line">        stubServiceMethodsMap.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 执行父类 AbstractProtocol 的销毁方法</span></span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>DubboProtocol</code> 执行销毁的逻辑主要针对三类对象，分别对该三类对象进行优雅关闭。</p>
<ol>
<li>优雅关闭<code>ExchangeServer</code>对象，保证服务平稳下线。</li>
<li>优雅关闭<code>ExchangeClient</code>对象，尽可能保证请求完成。</li>
<li>优雅关闭<code>LazyConnectExchangeClient</code>对象。</li>
</ol>
<h2 id="领域模型-1"><a href="#领域模型-1" class="headerlink" title="领域模型"></a>领域模型</h2><p><strong>DubboProtocol.refer()</strong> 方法会将底层的 <code>ExchangeClient</code> 集合封装成 <code>DubboInvoker</code>，然后由上层逻辑封装成代理对象。这样业务层就可以像调用本地对象一样，完成远程调用。相关继承关系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-refer-protocol-invoker-uml.jpg" alt></p>
<p>关于 <code>AbstractInvoker</code> 在前面已经介绍过了，可以参考 <a href="https://gentryhuang.com/posts/450e3eda/#AbstractInvoker">AbstractInvoker</a> 。下面我们对 <code>DubboInvoker</code> 进行介绍。</p>
<h3 id="DubboInvoker"><a href="#DubboInvoker" class="headerlink" title="DubboInvoker"></a>DubboInvoker</h3><p><code>DubboInvoker</code> 是 <code>AbstractInvoker</code> 的实现类，其 <strong>doInvoke()</strong> 方法是远程调用的直接入口。</p>
<h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程通信客户端数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeClient[] clients;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用的 &#123;<span class="doctag">@link</span> #clients&#125; 的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicPositiveInteger index = <span class="keyword">new</span> AtomicPositiveInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法中使用的jvm 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock destroyLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoker 集合，从&#123;<span class="doctag">@link</span> DubboProtocol#invokers&#125; 获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Invoker&lt;?&gt;&gt; invokers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboInvoker</span><span class="params">(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(serviceType, url, clients, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboInvoker</span><span class="params">(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients, Set&lt;Invoker&lt;?&gt;&gt; invokers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(serviceType, url, <span class="keyword">new</span> String[]&#123;Constants.INTERFACE_KEY, Constants.GROUP_KEY, Constants.TOKEN_KEY, Constants.TIMEOUT_KEY&#125;);</span><br><span class="line">        <span class="keyword">this</span>.clients = clients;</span><br><span class="line">        <span class="comment">// get version.</span></span><br><span class="line">        <span class="keyword">this</span>.version = url.getParameter(Constants.VERSION_KEY, <span class="string">"0.0.0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.invokers = invokers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">        <span class="comment">// 1 获得当前调用的方法名</span></span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="comment">// 2 向Invocation中添加附加信息，这里将URL的path（服务名），version 添加到 attachment 中</span></span><br><span class="line">        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(Constants.VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 选择一个远程通信客户端 ExchangeClient</span></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="comment">// 默认是单一长连接</span></span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 远程调用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4.1 判断是否异步调用</span></span><br><span class="line">            <span class="keyword">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// 4.2 判断是否单向调用</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// 4.3 根据调用的方法名称和配置获取此次调用的超时时间（毫秒），默认是 1s</span></span><br><span class="line">            <span class="keyword">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * - 发送 oneway 请求的方式是send() 方法，而后面发送 twoway 请求的方式是 request() 方法</span></span><br><span class="line"><span class="comment">             * - request() 方法会相应地创建 DefaultFuture 对象以及检测超时的定时任务，而 send() 方法则不会创建这些东西，它是直接将 Invocation 包装成 oneway 类型的 Request 发送出去</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 4.4 单向调用，不需要关注返回值的请求</span></span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 注意，调用的是 ExchangeClient#send(invocation, sent) 方法</span></span><br><span class="line">                currentClient.send(inv, isSent);</span><br><span class="line">                <span class="comment">// 设置 RpcContext.future = null ，无需异步回调</span></span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 返回 空结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4.5 异步调用，需要关注返回值的请求</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *  调用 ExchangeClient#request(invocation, timeout) 方法，发送请求</span></span><br><span class="line"><span class="comment">                 *  DefaultFuture是ResponseFuture的实现类，实际上这里返回的就是DefaultFuture实例，而该实例就是HeaderExchangeChannel.request(Object request, int timeout)返回的future实例</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 1 调用 RpcContext#setFuture(future) 方法，在需要的时候可以使用 Future 进行回调。</span></span><br><span class="line"><span class="comment">                 * 2 将DefaultFuture 对象封装到 FutureAdapter实例中，并将 FutureAdapter实例设置到RpcContext 中，我们可以在需要的地方取出使用 【在合适的地方调用 get方法】</span></span><br><span class="line"><span class="comment">                 * 3 FutureAdapter 是一个适配器，用于将 Dubbo 中的 ResponseFuture 与 JDK 中的 Future 进行适配，这样当用户线程调用 Future 的 get 方法时，经过 FutureAdapter 适配，最终会调用 ResponseFuture 实现类对象的 get 方法，也就是 DefaultFuture 的 get 方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">                <span class="comment">// 返回 空结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4.6 同步调用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 设置 RpcContext.future = null，无需异步回调</span></span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 1 调用 ExchangeClient#request(invocation, timeout) 方法，发送请求</span></span><br><span class="line"><span class="comment">                 * 2 用 ResponseFuture#get() 方法，阻塞等待返回结果</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>DubboInvoker.doInvoke()</code> 方法是调用方使用 <code>ExchangeClient</code> 向服务提供方发起请求的入口，下面对该过程进行分析：</p>
<ol>
<li>向 Invocation 调用信息中添加 <code>path</code>、<code>version</code> 属性。</li>
<li>获取当前调用的超时时间，默认是 1s 。双向调用时是调用端最大等待时长，否则抛出请求超时异常。</li>
<li>判断调用模式，单向调用 or 异步调用 or 同步调用。<ul>
<li>单向调用：使用 <code>ExchangeClient.send</code> 方法，无需关注返回值。RpcContext 中的 Future 置空，无需异步回调。</li>
<li>异步调用：使用 <code>ExchangeClient.request</code> 方法，调用时传入超时时间，作为调用方最大等待时长。返回结果 <code>ResponseFuture</code> 作为 RpcContext 中的 Future ，在需要的时候可以取出 Future 进行回调。</li>
<li>同步调用：和异步调用类似，唯一的区别是，同步调用是拿到返回的 ResponseFuture 后立即调用其 get() 进行调用结果的获取，在结果没有返回时将阻塞业务线程。</li>
</ul>
</li>
</ol>
<h4 id="Invoker-状态"><a href="#Invoker-状态" class="headerlink" title="Invoker 状态"></a>Invoker 状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前 Invoker 的状态 - 是否可用</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ExchangeClient client : clients) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 即使Client处于连接中，但如果 Server 处于正在关闭中，连接也是不可用的，即服务端广播客户端 READONLY_EVENT 事件</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * &#123;<span class="doctag">@link</span> HeaderExchangeServer#sendChannelReadOnlyEvent()&#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (client.isConnected() &amp;&amp; !client.hasAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY)) &#123;</span><br><span class="line">                <span class="comment">//cannot write == not Available ?</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>DubboInvoker.isAvailable()</code> 方法用于检查当前 <strong>DubboInvoker</strong> 是否可用，是否可以体现如下：</p>
<ol>
<li>当前 Invoker 的状态是否是可用的</li>
<li>当前 Invoker 封装的连接是否有可用的</li>
<li>当前 Invoker 封装的连接的对端是否关闭，根据是否广播只读事件</li>
</ol>
<h4 id="销毁-Invoker"><a href="#销毁-Invoker" class="headerlink" title="销毁 Invoker"></a>销毁 Invoker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果已经销毁，则忽略</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.isDestroyed()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// double check to avoid dup close</span></span><br><span class="line">            <span class="comment">// 双重检锁，避免已经销毁</span></span><br><span class="line">            destroyLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 再次检测是否销毁</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">super</span>.isDestroyed()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 标记 DubboInvoker 销毁</span></span><br><span class="line">                <span class="keyword">super</span>.destroy();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从缓存中移除当前Invoker</span></span><br><span class="line">                <span class="keyword">if</span> (invokers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    invokers.remove(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">           </span><br><span class="line">                <span class="comment">// 关闭当前 Invoker 中封装的连接</span></span><br><span class="line">                <span class="keyword">for</span> (ExchangeClient client : clients) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 等待时长内关闭 ExchangeClient</span></span><br><span class="line">                        client.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.warn(t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                destroyLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>销毁 <code>DubboInvoker</code> 首先设置自身的销毁状态，接着关闭封装的连接。</p>
<h1 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h1><p><code>DubboProtocol</code> 的服务暴露和服务引用都设置了编解码 <code>DubboCountCodec</code>，关于编解码器可以参考 <a href="https://gentryhuang.com/posts/61d79ae/">编解码器</a> 一文，这里就不再重复说明。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章主要对 Dubbo 协议下的服务暴露和服务引用的核心流程进行了介绍。服务暴露涉及到 NIO 服务的启动，RpcInvocation 实现，通道处理器的实现以及优化序列实现。服用引用涉及到 <code>Client</code> 的初始化，Dubbo 支持 <code>共享连接</code> 和 <code>独享连接</code>，其中使用 <code>ReferenceCountExchangeClient</code> 和 <code>LazyConnectExchangeClient</code> 对 <code>ExchangeClient</code> 进行装饰，分别实现具有引用计数功能和延时初始化功能的客户端。接着对相关的领域模型 <code>DubboExpoter</code> 和 <code>DubboInvoker</code> 进行了介绍，这两个是非常重要的模型，作为提供方服务暴露实现和消费方服务引用实现。DubboProtocol 相关的编解码由于在之前的文章中已经详细说明，就不再介绍。需要说明的是，在 Dubbo 2.7.x 版本中进行了异步化改造，对消费端和提供的调用进行了优化，关于差异部分会在后面的文章中单独说明。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/a064181a/" title="Dubbo源码分析 - Dubbo协议" target="_blank" rel="external">https://gentryhuang.com/posts/a064181a/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/c5a37c18/" title="Dubbo源码分析 - HTTP协议"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/450e3eda/" title="Dubbo源码分析 - 多协议概览"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2021 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>