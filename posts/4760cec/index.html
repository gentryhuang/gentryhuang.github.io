<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Dubbo源码分析 - 健康检测 | gentryhuang的博客</title>
  <meta name="description" content="概述Dubbo 心跳检测是为了保证连接的可用性，在需要的时候及时采取重连、断开等措施。需要说明的是，Dubbo 心跳检测是针对 TCP 层面的协议（如：Dubbo 协议），HTTP 层面的协议是无需进行连接管理的。心跳检测需要容错，一次心跳失败不能认定连接不通，多次心跳失败才能采取相应措施。此外，心跳检测不应该忙检测，如果一条通道上有频繁的 RPC 调用，会给系统带来额外的负担。 连接长短连接TC">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo源码分析 - 健康检测">
<meta property="og:url" content="https://gentryhuang.com/posts/4760cec/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="概述Dubbo 心跳检测是为了保证连接的可用性，在需要的时候及时采取重连、断开等措施。需要说明的是，Dubbo 心跳检测是针对 TCP 层面的协议（如：Dubbo 协议），HTTP 层面的协议是无需进行连接管理的。心跳检测需要容错，一次心跳失败不能认定连接不通，多次心跳失败才能采取相应措施。此外，心跳检测不应该忙检测，如果一条通道上有频繁的 RPC 调用，会给系统带来额外的负担。 连接长短连接TC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-heartbeat-provider-listen.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-heartbeat-consumer-invoke-provider.jpg">
<meta property="article:published_time" content="2021-05-01T10:56:21.000Z">
<meta property="article:modified_time" content="2021-05-08T08:48:14.312Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="Dubbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-heartbeat-provider-listen.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/4760cec/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.38px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.75px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.13px;">I/O</a> <a href="/tags/JUC/" style="font-size: 13.5px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.25px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.13px;">Lock</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.25px;">Protocol</a> <a href="/tags/RPC/" style="font-size: 13.63px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.13px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.25px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.25px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.88px;">设计模式</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/55ae5a2b/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/55ae5a2b/" class="title">Java基础 - Reference</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-14T02:30:12.000Z" itemprop="datePublished">2021-08-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/1d01ceec/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a>
              </p>
              <p class="item-title">
                <a href="/posts/1d01ceec/" class="title">时间轮算法 - HashedWheelTimer</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-24T02:06:24.000Z" itemprop="datePublished">2021-07-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/f3292e6c/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/f3292e6c/" class="title">并发 - ReentrantReadWriteLock</a>
              </p>
              <p class="item-date">
                <time datetime="2021-07-10T12:46:36.000Z" itemprop="datePublished">2021-07-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/19fe4bc5/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/19fe4bc5/" class="title">Redis原理 - Redis主流程</a>
              </p>
              <p class="item-date">
                <time datetime="2021-06-24T06:59:01.000Z" itemprop="datePublished">2021-06-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/b25f5b99/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a>
              </p>
              <p class="item-title">
                <a href="/posts/b25f5b99/" class="title">网络通信 - IO多路复用</a>
              </p>
              <p class="item-date">
                <time datetime="2021-06-12T02:43:23.000Z" itemprop="datePublished">2021-06-12</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连接"><span class="toc-number">2.</span> <span class="toc-text">连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#长短连接"><span class="toc-number">2.1.</span> <span class="toc-text">长短连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo-中的长连接"><span class="toc-number">2.2.</span> <span class="toc-text">Dubbo 中的长连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连接的保活"><span class="toc-number">2.3.</span> <span class="toc-text">连接的保活</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-KeepAlive"><span class="toc-number">2.3.1.</span> <span class="toc-text">TCP KeepAlive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用层心跳"><span class="toc-number">2.3.2.</span> <span class="toc-text">应用层心跳</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dubbo-心跳检测"><span class="toc-number">3.</span> <span class="toc-text">Dubbo 心跳检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IdleStateHandler"><span class="toc-number">3.1.</span> <span class="toc-text">IdleStateHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IdleSensible"><span class="toc-number">3.2.</span> <span class="toc-text">IdleSensible</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络传输层"><span class="toc-number">3.3.</span> <span class="toc-text">网络传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyServer"><span class="toc-number">3.3.1.</span> <span class="toc-text">NettyServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyClient"><span class="toc-number">3.3.2.</span> <span class="toc-text">NettyClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IdleStateHandler-参数"><span class="toc-number">3.3.3.</span> <span class="toc-text">IdleStateHandler 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyServerHandler"><span class="toc-number">3.3.4.</span> <span class="toc-text">NettyServerHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyClientHandler"><span class="toc-number">3.3.5.</span> <span class="toc-text">NettyClientHandler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信息交换层"><span class="toc-number">3.4.</span> <span class="toc-text">信息交换层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HeaderExchangeServer"><span class="toc-number">3.4.1.</span> <span class="toc-text">HeaderExchangeServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HeaderExchangeClient"><span class="toc-number">3.4.2.</span> <span class="toc-text">HeaderExchangeClient</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#健康检测精度"><span class="toc-number">3.5.</span> <span class="toc-text">健康检测精度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HeartbeatHandler"><span class="toc-number">3.6.</span> <span class="toc-text">HeartbeatHandler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#补充"><span class="toc-number">4.</span> <span class="toc-text">补充</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-rpc/健康检测" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Dubbo源码分析 - 健康检测
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/4760cec/" class="article-date">
	  <time datetime="2021-05-01T10:56:21.000Z" itemprop="datePublished">2021-05-01</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/RPC/">RPC</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Dubbo/" rel="tag">Dubbo</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/4760cec/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 4.5k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 18(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 心跳检测是为了保证连接的可用性，在需要的时候及时采取重连、断开等措施。需要说明的是，Dubbo 心跳检测是针对 TCP 层面的协议（如：Dubbo 协议），HTTP 层面的协议是无需进行连接管理的。心跳检测需要容错，一次心跳失败不能认定连接不通，多次心跳失败才能采取相应措施。此外，心跳检测不应该忙检测，如果一条通道上有频繁的 RPC 调用，会给系统带来额外的负担。</p>
<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="长短连接"><a href="#长短连接" class="headerlink" title="长短连接"></a>长短连接</h2><p>TCP 本身并没有长短连接之分，长短连接与否取决于对它的使用。</p>
<ul>
<li><strong>短连接：</strong> 每次通信时创建一个连接，一次通信结束关闭连接即可。短连接的好处是管理简单，存在的连接都是可用的连接，不需要额外的控制手段。</li>
<li><strong>长连接：</strong> 每次通信完毕后，不会立即关闭连接，这样可以做到连接的复用。长连接的好处是省去了创建连接的开销。</li>
</ul>
<p>长短连接各自的优势，分别是对方的劣势。对于不追求高性能，使用短连接合适，省去了连接状态管理的工作。追求性能最好使用长连接，但是需要额外工作，如端点之间连接的维护和保活。</p>
<h2 id="Dubbo-中的长连接"><a href="#Dubbo-中的长连接" class="headerlink" title="Dubbo 中的长连接"></a>Dubbo 中的长连接</h2><p>Dubbo 协议是基于 TCP 进行网络传输的，它采用的就是长连接。下面分别启动服务提供者应用和服务消费者应用，提供者负责监听本地 <code>20880</code> 端口（Dubbo 默认端口），服务消费者负责发起请求。</p>
<ul>
<li>服务提供方启动完成<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-heartbeat-provider-listen.jpg" alt><br>从上图可知，Dubbo 正在监听本地的 <code>20880</code> 端口，处理发送到本地 <code>20880</code> 端口的请求。</li>
<li>服务消费方发起请求<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-heartbeat-consumer-invoke-provider.jpg" alt><br>从上图可以验证，TCP 是一个双向的通信过程。</li>
</ul>
<h2 id="连接的保活"><a href="#连接的保活" class="headerlink" title="连接的保活"></a>连接的保活</h2><p>当端点间建立长连接后，由于网络问题，建立的连接可能不可用，这时就需要保证连接的可用。保证连接的可用常用的手段就是连接保活。</p>
<h3 id="TCP-KeepAlive"><a href="#TCP-KeepAlive" class="headerlink" title="TCP KeepAlive"></a>TCP KeepAlive</h3><p>TCP KeepAlive 是面向网络的，并不是面向应用的。<strong>连接不可用并不一定是网络问题，可能是由于应用本身的负载过高、GC频繁等导致的，此时应用失去了活性，连接也不可用</strong>。</p>
<h3 id="应用层心跳"><a href="#应用层心跳" class="headerlink" title="应用层心跳"></a>应用层心跳</h3><p>网络层面的 KeepAlive 不足以支撑应用层面的连接可用性，这种情况下应该使用应用层的心跳机制来实现连接保活，这也是业内常用的检测方法。</p>
<h1 id="Dubbo-心跳检测"><a href="#Dubbo-心跳检测" class="headerlink" title="Dubbo 心跳检测"></a>Dubbo 心跳检测</h1><p>介绍完健康检测相关基础后，下面我们详细介绍 Dubbo 是如何设计应用层心跳的。注意，以下讨论的 Dubbo 版本是 2.7.7 。</p>
<p>Dubbo 在改进心跳方案之前是双向心跳设计，客户端会给服务端发送心跳，反之，服务端也会向客户端心跳。关于双向心跳设计可以参见<a href="https://gentryhuang.com/posts/26722deb/#%E4%BB%BB%E5%8A%A1%E9%80%BB%E8%BE%91">心跳任务</a>，这里介绍的是 Dubbo 2.6.x 版本，任务执行没有使用时间轮，依然使用 schedule 方案。</p>
<p>Dubbo 心跳机制改进后，主要分为两类。其一，对于底层使用 Netty 通信的连接检测交给 Netty 本身而非 Dubbo 心跳检测逻辑，即完全使用 <code>IdleStateHandler</code> 来检测连接空闲状态。其二，对于其它 NIO 通信组件，Dubbo 优化了之前的双向心跳设计，改为了客户端在连接空闲时发送单向心跳，服务端定时检测连接可用性。下面我们就结合 Dubbo 心跳检测改进后的版本进行说明。</p>
<h2 id="IdleStateHandler"><a href="#IdleStateHandler" class="headerlink" title="IdleStateHandler"></a>IdleStateHandler</h2><p>Netty 对空闲连接的检测提供了天然的支持，使用 <code>IdleStateHandler</code> 可以很方便的实现空闲检测逻辑。其内部使用了 <code>EventLoop.schedule(task)</code> 来实现定时任务，使用该线程可以保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>, readerIdleTime, writerIdleTime, allIdleTime, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>readerIdleTime：</strong> 读超时时间</li>
<li><strong>writerIdleTime：</strong> 写超时时间</li>
<li><strong>allIdleTime：</strong> 所有类型的超时时间</li>
</ul>
<p>IdleStateHandler 会根据设置的超时参数，循环检测通道 Channel 的读写多久没有调用。当在 Netty 的 Pipeline 中加入 <code>IdleStateHandler</code> 后，可以在此 Pipeline 的任意 Handler 的 <code>userEventTriggered</code> 方法之中检测 <code>IdleStateEvent</code> 空闲事件。</p>
<h2 id="IdleSensible"><a href="#IdleSensible" class="headerlink" title="IdleSensible"></a>IdleSensible</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleSensible</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否具有处理空闲连接的能力</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">canHandleIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dubbo 新增该接口，以区分 Netty 和其它通信组件对空闲连接的处理能力。<code>NettyServer</code> 和 <code>NettyClient</code> 作为 Netty 通信组件的封装类实现了该接口，重写了接口中的方法，返回值为 <code>true</code>，表示具有处理空闲连接的能力。也就是说，如果使用 Netty 作为通信组件，那么监控空闲连接就交给 Netty 底层自己处理。而其它通信组件暂不支持，因此仍然需要 Dubbo 框架的心跳设计方案。</p>
<h2 id="网络传输层"><a href="#网络传输层" class="headerlink" title="网络传输层"></a>网络传输层</h2><p>下面我们先从 Dubbo 的网络传输层分析心跳检测的实现，需要说明的是网络传输层主要针对的是 Netty 组件，其它 NIO 组件几乎没有在网络传输层实现心跳逻辑（这里不包括统一处理心跳交互的 HeartbeatHandler）。</p>
<h3 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyServer</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Init and start netty server</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        bossGroup = NettyEventLoopFactory.eventLoopGroup(<span class="number">1</span>, <span class="string">"NettyServerBoss"</span>);</span><br><span class="line">        workerGroup = NettyEventLoopFactory.eventLoopGroup(getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS), <span class="string">"NettyServerWorker"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> NettyServerHandler nettyServerHandler = <span class="keyword">new</span> NettyServerHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">        channels = nettyServerHandler.getChannels();</span><br><span class="line">        bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NettyEventLoopFactory.serverSocketChannelClass())</span><br><span class="line">                .option(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 1 心跳超时时间，是心跳间隔的 3 倍。心跳间隔默认 60s </span></span><br><span class="line">                        <span class="keyword">int</span> idleTimeout = UrlUtils.getIdleTimeout(getUrl());</span><br><span class="line">                        NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">if</span> (getUrl().getParameter(SSL_ENABLED_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">"negotiation"</span>, SslHandlerInitializer.sslServerHandler(getUrl(), nettyServerHandler));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 2 设置 ChannelPipeline 上的 ChannelHandler</span></span><br><span class="line">                        ch.pipeline()</span><br><span class="line">                                <span class="comment">// 2.1 编解码 Handler</span></span><br><span class="line">                                .addLast(<span class="string">"decoder"</span>, adapter.getDecoder())</span><br><span class="line">                                .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())</span><br><span class="line">                                <span class="comment">// 2.2 心跳检测 Handler，注意超时时间针对所有类型</span></span><br><span class="line">                                .addLast(<span class="string">"server-idle-handler"</span>, <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, idleTimeout, MILLISECONDS))</span><br><span class="line">                                <span class="comment">// 2.3 Netty 融合 Dubbo Handler 的 处理器</span></span><br><span class="line">                                .addLast(<span class="string">"handler"</span>, nettyServerHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// bind</span></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.bind(getBindAddress());</span><br><span class="line">        channelFuture.syncUninterruptibly();</span><br><span class="line">        channel = channelFuture.channel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 IdleSensible 中的方法，表示自己实现心跳检测</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canHandleIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在初始化和启动 Netty Server 时，会为 Pipeline 设置 <code>IdleStateHandler</code> 处理器，用于检测空闲连接。注意，<code>IdleStateHandler</code> 是 Netty 提供的一个工具型 Handler，用于定时心跳请求的功能以及自动关闭长时间空闲连接。<strong>如果超过设置的阈值（超时时间），则会触发 <code>IdleStateEvent</code> 事件并传递给后续的 ChannelHandler 进行处理，后续的 ChannelHandler 的 <code>userEventTriggered()</code> 方法会根据接收到的 <code>IdleStateEvent</code> 事件，决定是关闭空闲连接还是发送心跳探活</strong>。这里提到的 ChannelHandler 其实就是下文要介绍的 <code>NettyServerHandler</code> 和 <code>NettyClientHandler</code> 。</p>
<h3 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyClient</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Init bootstrap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> NettyClientHandler nettyClientHandler = <span class="keyword">new</span> NettyClientHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(NIO_EVENT_LOOP_GROUP)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class="line">                <span class="comment">//.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout())</span></span><br><span class="line">                .channel(socketChannelClass());</span><br><span class="line"></span><br><span class="line">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.max(<span class="number">3000</span>, getConnectTimeout()));</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1 心跳间隔，默认 60s</span></span><br><span class="line">                <span class="keyword">int</span> heartbeatInterval = UrlUtils.getHeartbeat(getUrl());</span><br><span class="line">                <span class="keyword">if</span> (getUrl().getParameter(SSL_ENABLED_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="string">"negotiation"</span>, SslHandlerInitializer.sslClientHandler(getUrl(), nettyClientHandler));</span><br><span class="line">                &#125;</span><br><span class="line">                NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 设置 ChannelPipeline 上的 ChannelHandler</span></span><br><span class="line">                ch.pipeline()<span class="comment">//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug</span></span><br><span class="line">                        <span class="comment">// 2.1 编解码 Handler</span></span><br><span class="line">                        .addLast(<span class="string">"decoder"</span>, adapter.getDecoder())</span><br><span class="line">                        .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())</span><br><span class="line">                        <span class="comment">// 2.2 心跳检测 Handler，注意超时时间针对读类型</span></span><br><span class="line">                        .addLast(<span class="string">"client-idle-handler"</span>, <span class="keyword">new</span> IdleStateHandler(heartbeatInterval, <span class="number">0</span>, <span class="number">0</span>, MILLISECONDS))</span><br><span class="line">                        <span class="comment">// 2.3 Netty 融合 Dubbo Handler 的处理</span></span><br><span class="line">                        .addLast(<span class="string">"handler"</span>, nettyClientHandler);</span><br><span class="line"></span><br><span class="line">                String socksProxyHost = ConfigUtils.getProperty(SOCKS_PROXY_HOST);</span><br><span class="line">                <span class="keyword">if</span> (socksProxyHost != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> socksProxyPort = Integer.parseInt(ConfigUtils.getProperty(SOCKS_PROXY_PORT, DEFAULT_SOCKS_PROXY_PORT));</span><br><span class="line">                    Socks5ProxyHandler socks5ProxyHandler = <span class="keyword">new</span> Socks5ProxyHandler(<span class="keyword">new</span> InetSocketAddress(socksProxyHost, socksProxyPort));</span><br><span class="line">                    ch.pipeline().addFirst(socks5ProxyHandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 IdleSensible 中的方法，表示自己实现心跳检测</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canHandleIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>NettyClient 的初始化逻辑和 NettyServer 类似，这里就不再重复说明。</p>
<h3 id="IdleStateHandler-参数"><a href="#IdleStateHandler-参数" class="headerlink" title="IdleStateHandler 参数"></a>IdleStateHandler 参数</h3><ol>
<li>客户端和服务端配置的超时时间不一致<blockquote>
<p>由于客户端有重试机制，不断发送心跳失败 N 次后才会进行断开、重连。而服务端超时后是直接断开的，留给服务端时间需要长一点，默认情况是服务端超时时间是客户端超时时间的 3 倍。此外，两端都拥有断开连接的能力，但连接的创建是客户端主动发起的，那么客户端也更有权利去主动断开连接。</p>
</blockquote>
</li>
<li>客户端检测的是读超时，服务端检测的是读写超时<blockquote>
<p>这属于心跳的共识。一般情况下客户端先发起心跳（写）[IdleStateHandler 是单向的，客户端-&gt;服务端]，所以整个链路中不通的情况只可能是：（1）服务接收（读） （2）服务端发送（写） （3）客户端接收（读） 。</p>
</blockquote>
</li>
</ol>
<h3 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyServerHandler</span><br><span class="line"><span class="meta">@io</span>.netty.channel.ChannelHandler.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到 IdleStateEvent 事件时会断开连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// server will close channel when server don't receive any heartbeat from client util timeout.</span></span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logger.info(<span class="string">"IdleStateEvent triggered, close channel "</span> + channel);</span><br><span class="line">                <span class="comment">// 断开链接</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>NettyServerHandler 作为 Netty 服务端侧的 ChannelHandler，当收到 <code>IdleStateEvent</code> 事件时会断开连接。</p>
<h3 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyClientHandler</span><br><span class="line"><span class="meta">@io</span>.netty.channel.ChannelHandler.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到 IdleStateEvent 事件会发送心跳消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// send heartbeat when read idle.</span></span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"IdleStateEvent triggered, send heartbeat to channel "</span> + channel);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 发送心跳请求</span></span><br><span class="line">                Request req = <span class="keyword">new</span> Request();</span><br><span class="line">                req.setVersion(Version.getProtocolVersion());</span><br><span class="line">                req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">                req.setEvent(HEARTBEAT_EVENT);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送心跳消息</span></span><br><span class="line">                channel.send(req);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>NettyClientHandler 作为 Netty 客户端侧的 ChannelHandler，当收到 <code>IdleStateEvent</code> 事件时会进行心跳探活。</p>
<h2 id="信息交换层"><a href="#信息交换层" class="headerlink" title="信息交换层"></a>信息交换层</h2><p>信息交换层是触发心跳检测的入口。</p>
<h3 id="HeaderExchangeServer"><a href="#HeaderExchangeServer" class="headerlink" title="HeaderExchangeServer"></a>HeaderExchangeServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeServer</span> <span class="keyword">implements</span> <span class="title">ExchangeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RemotingServer server;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean closed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashedWheelTimer IDLE_CHECK_TIMER = <span class="keyword">new</span> HashedWheelTimer(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-server-idleCheck"</span>, <span class="keyword">true</span>), <span class="number">1</span>,</span><br><span class="line">            TimeUnit.SECONDS, TICKS_PER_WHEEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CloseTimerTask closeTimerTask;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeServer</span><span class="params">(RemotingServer server)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(server, <span class="string">"server == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始心跳检测任务</span></span><br><span class="line">        startIdleCheckTask(getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startIdleCheckTask</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// server 自己是否可以心跳检测，如果自己不能，则启动一个 CloseTimerTask 定时任务，定期关闭长时间空闲的连接</span></span><br><span class="line">        <span class="comment">// NettyServer 是自己完成心跳检测的，具体依赖 NettyServerHandler 和 IdleStateHandler 实现，原理与 NettyClient 类似</span></span><br><span class="line">        <span class="keyword">if</span> (!server.canHandleIdle()) &#123;</span><br><span class="line">            AbstractTimerTask.ChannelProvider cp = () -&gt; unmodifiableCollection(HeaderExchangeServer.<span class="keyword">this</span>.getChannels());</span><br><span class="line">            <span class="comment">// 心跳超时时间</span></span><br><span class="line">            <span class="keyword">int</span> idleTimeout = getIdleTimeout(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据心跳超时时间计算出一个 tick 时间（除以了 3 得到），作为定时任务执行的频率</span></span><br><span class="line">            <span class="keyword">long</span> idleTimeoutTick = calculateLeastDuration(idleTimeout);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建闭关连接的任务</span></span><br><span class="line">            CloseTimerTask closeTimerTask = <span class="keyword">new</span> CloseTimerTask(cp, idleTimeoutTick, idleTimeout);</span><br><span class="line">            <span class="keyword">this</span>.closeTimerTask = closeTimerTask;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务加载到时间轮</span></span><br><span class="line">            IDLE_CHECK_TIMER.newTimeout(closeTimerTask, idleTimeoutTick, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 Exchange 层的 Server 时会开启心跳检测任务，如果使用的是 Netty 通信组件则不会使用 Dubbo 的心跳检测逻辑而是直接使用 Netty 提供的心跳检测机制，如果是其它通信组件则依赖 Dubbo 提供的心跳检测逻辑。</p>
<p>HeaderExchangeServer 启动的心跳检测任务用于服务端侧连接超时关闭连接，这个针对非 Netty 通信组件。Netty 实现的服务端侧心跳检测是交给 <code>IdleStateHandler</code> 完成的， 连接超时关闭连接由 <code>NettyServerHandler</code> 完成。</p>
<p>以上关闭空闲连接相关的定时任务不再展开说明。</p>
<h3 id="HeaderExchangeClient"><a href="#HeaderExchangeClient" class="headerlink" title="HeaderExchangeClient"></a>HeaderExchangeClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeClient</span> <span class="keyword">implements</span> <span class="title">ExchangeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Client client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashedWheelTimer IDLE_CHECK_TIMER = <span class="keyword">new</span> HashedWheelTimer(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-client-idleCheck"</span>, <span class="keyword">true</span>), <span class="number">1</span>, TimeUnit.SECONDS, TICKS_PER_WHEEL);</span><br><span class="line">    <span class="keyword">private</span> HeartbeatTimerTask heartBeatTimerTask;</span><br><span class="line">    <span class="keyword">private</span> ReconnectTimerTask reconnectTimerTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client     封装 Transport 层的 Client 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startTimer 参与控制是否开启心跳定时任务和重连任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeClient</span><span class="params">(Client client, <span class="keyword">boolean</span> startTimer)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="string">"Client can't be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.channel = <span class="keyword">new</span> HeaderExchangeChannel(client);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启心跳定时任务和重连任务</span></span><br><span class="line">        <span class="keyword">if</span> (startTimer) &#123;</span><br><span class="line">            URL url = client.getUrl();</span><br><span class="line">            startReconnectTask(url);</span><br><span class="line">            startHeartBeatTask(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启心跳任务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeartBeatTask</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// client 是否可以自己检测心跳，如果自己可以发送心跳请求，则无须 HeaderExchangeClient 再启动一个定时任务</span></span><br><span class="line">        <span class="comment">// 这里的 client 是 NettyClient ，它依靠 IdleStateHandler 中的定时任务来触发心跳事件，依靠 NettyClientHandler 来发送心跳请求，对于无法自己发送心跳请求的 Client 实现，HeaderExchangeClient 会为其启动 HeartbeatTimerTask 心跳定时任务</span></span><br><span class="line">        <span class="keyword">if</span> (!client.canHandleIdle()) &#123;</span><br><span class="line">            <span class="comment">// 获取客户端测通道</span></span><br><span class="line">            AbstractTimerTask.ChannelProvider cp = () -&gt; Collections.singletonList(HeaderExchangeClient.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取心跳间隔</span></span><br><span class="line">            <span class="keyword">int</span> heartbeat = getHeartbeat(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理心跳间隔，最小间隔不能低于 1s</span></span><br><span class="line">            <span class="keyword">long</span> heartbeatTick = calculateLeastDuration(heartbeat);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建心跳任务</span></span><br><span class="line">            <span class="keyword">this</span>.heartBeatTimerTask = <span class="keyword">new</span> HeartbeatTimerTask(cp, heartbeatTick, heartbeat);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将心跳任务加载到时间轮</span></span><br><span class="line">            IDLE_CHECK_TIMER.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意，无论使用哪种 NIO 组件，重连逻辑使用的都是 Dubbo 提供的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startReconnectTask</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 URL 中读取重连配置，判断是否开启重连</span></span><br><span class="line">        <span class="keyword">if</span> (shouldReconnect(url)) &#123;</span><br><span class="line">            <span class="comment">// 获取客户端测通道</span></span><br><span class="line">            AbstractTimerTask.ChannelProvider cp = () -&gt; Collections.singletonList(HeaderExchangeClient.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 心跳超时时间</span></span><br><span class="line">            <span class="keyword">int</span> idleTimeout = getIdleTimeout(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理心跳超时时间</span></span><br><span class="line">            <span class="keyword">long</span> heartbeatTimeoutTick = calculateLeastDuration(idleTimeout);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建重连任务</span></span><br><span class="line">            <span class="keyword">this</span>.reconnectTimerTask = <span class="keyword">new</span> ReconnectTimerTask(cp, heartbeatTimeoutTick, idleTimeout);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将重连任务加载到时间轮</span></span><br><span class="line">            IDLE_CHECK_TIMER.newTimeout(reconnectTimerTask, heartbeatTimeoutTick, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建 Exchange 层的 Client 时会开启心跳检测任务和重连任务。如果使用的 Netty 通信组件则不会使用 Dubbo 的心跳检测逻辑，同样是使用 Netty 提供的心跳检测机制，如果是其它通信组件则依赖 Dubbo 提供的心跳检测逻辑。重连任务无论是使用 Netty 通信组件还是其它通信组件，都会依赖 Dubbo 提供的重连逻辑。</p>
<p>HeaderExchangeClient 启动的心跳检测任务用于客户端侧连接超时不断发送心跳，这个针对非 Netty 通信组件。Netty 实现客户端侧心跳检测是交给 <code>IdleStateHandler</code> 完成的， 连接超时发送心跳由 <code>NettyClientHandler</code> 完成。HeaderExchangeClient 启动的重连任务针对所有的 NIO 通信组件，它们都依赖 Dubbo 实现的重连逻辑。</p>
<p>以上相关的定时任务不再展开说明。</p>
<h2 id="健康检测精度"><a href="#健康检测精度" class="headerlink" title="健康检测精度"></a>健康检测精度</h2><p>Dubbo 中默认的心跳间隔是 60s ，心跳超时时间是 3 * 60s，<strong>由于时间窗口问题，非健康连接可能不能够被及时检测出来，最坏情况为一个周期</strong>。Dubbo 目前的解决方案是，根据心跳间隔时间和心跳超时时间计算出对应的实际触发频率，使它们的值缩小，通过减少检测间隔时间来增大及时发现非健康状态连接的概率。实际触发频率需要根据场景进行权衡折中，要考虑到资源消耗问题。</p>
<p>注意，几乎所有的定时检测逻辑都会存在时间窗口问题，解决方案就是根据具体的场景合理地计算检测任务的触发频率。</p>
<h2 id="HeartbeatHandler"><a href="#HeartbeatHandler" class="headerlink" title="HeartbeatHandler"></a>HeartbeatHandler</h2><p>HeartbeatHandler 是专门用于心跳消息处理的 ChannelHandler 实现。注意哦，它是一个 ChannelHandler，意味着会接收到各种消息（不仅限心跳消息）并能处理相关消息，它的主要职能就是处理心跳消息。在通信的不同阶段会更新通道中的 <code>读写时间戳</code>(这些读写时间戳是判断超时的依据)，不仅是心跳消息会更新对应值其它消息也会更新。对收到的心跳消息进行处理，如接收到心跳请求，则生成对应的心跳响应并返回；如接收到心跳响应，则打印日志即可；如果接收到其它消息，则传递给底层的通道处理器。 HeartbeatHandler 更多详情可参考 <a href="https://gentryhuang.com/posts/26722deb/#HeartbeatHandler">HeartbeatHandler</a> 。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>介绍完 Dubbo 的心跳检测后，我们再从宏观上对健康检测进行说明。</p>
<p>调用方跟服务集群节点之间的网络状况是瞬息万变的，两者之间可能出现各种情况，保证连接的可靠终极解决方案：<strong>让调用方实时感知到节点的状态变化</strong>。</p>
<ul>
<li><p><strong>应用心跳检测</strong></p>
<blockquote>
<p>应用心跳检测是目前通用的健康检测方案，它能相对及时发现非健康的连接以及非健康的应用，本质上来说还是根据心跳请求结果做判断，这在一定程度上也可以应对应用僵死情况（应用失去活性会影响到心跳请求的响应）。但是对一些相对特殊的情况，应用层心跳检测就不能很好的感知了。比如心跳失败率较高（可能是服务节点网络问题、应用活性等问题），但是总能在阈值内恢复正常，这种情况应用层心跳就显得力不从心了，理论来说该连接或者服务属于不可用的，但是应用层心跳依然认为是正常情况。针对这类情况，就需要其它维度的健康检测。</p>
</blockquote>
</li>
<li><p><strong>业务请求可用率</strong></p>
<blockquote>
<p>判断连接或节点状态只有心跳检测维度是不够完美的，可以增加服务调用可用率来协助检测逻辑，这样健康检测就完整了。</p>
</blockquote>
</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>分布式系统中健康检测是非常有必要的，通过健康检测机制可以及时地发现连接是否可用或服务是否可用，调用方根据检测结果做出正确的选择，如重连、断开连接、将服务移除健康列表等。健康检测可从 <code>TCP KeepAlive</code>、<code>应用心跳</code> 以及 <code>业务请求可用率</code> 等<strong>多维度</strong>进行考虑。应用健康状况不仅包括 TCP 连接状况，还包括应用本身是否存活，很多情况下 TCP 连接没有断开，但应用可能已经“僵死了”。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/4760cec/" title="Dubbo源码分析 - 健康检测" target="_blank" rel="external">https://gentryhuang.com/posts/4760cec/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/fa9a5340/" title="缓存一致性问题"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/6001717d/" title="Gossip 协议"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2021 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>