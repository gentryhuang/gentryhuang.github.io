<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Dubbo源码分析 - 信息交换层 | gentryhuang的博客</title>
  <meta name="description" content="前言前面的几篇文章详细介绍了 Dubbo Remoting 中的 Transport 层，该层只负责单向消息传输，是 Dubbo 中端到端的统一网络传输实现。本篇文章将介绍网络传输层即 Transport 层之上的 Exchange 层，同时它也是 Dubbo Remoting 层的最顶层。 概述信息交换层 Exchange 在传输层之上建立了 Request-Response 模型，实现了在不同">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo源码分析 - 信息交换层">
<meta property="og:url" content="https://gentryhuang.com/posts/26722deb/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="前言前面的几篇文章详细介绍了 Dubbo Remoting 中的 Transport 层，该层只负责单向消息传输，是 Dubbo 中端到端的统一网络传输实现。本篇文章将介绍网络传输层即 Transport 层之上的 Exchange 层，同时它也是 Dubbo Remoting 层的最顶层。 概述信息交换层 Exchange 在传输层之上建立了 Request-Response 模型，实现了在不同">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-outline.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-channel-hierarchy.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-channel-method.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-future.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-handler-hierarchy.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-wrap.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-dispatcher-exception.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-process-conversion.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-client-hierarchy.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-server-hierarchy.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-codec-hierarchy.jpg">
<meta property="article:published_time" content="2020-06-17T16:00:00.000Z">
<meta property="article:modified_time" content="2021-12-02T02:12:50.934Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="Dubbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-outline.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/26722deb/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.38px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.75px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.13px;">I/O</a> <a href="/tags/JMM/" style="font-size: 13px;">JMM</a> <a href="/tags/JUC/" style="font-size: 13.5px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.25px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.13px;">Lock</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.25px;">Protocol</a> <a href="/tags/RPC/" style="font-size: 13.63px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13.25px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.13px;">Redis数据结构</a> <a href="/tags/SPI/" style="font-size: 13.25px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.25px;">Spring</a> <a href="/tags/Thread/" style="font-size: 13.13px;">Thread</a> <a href="/tags/Zookeeper/" style="font-size: 13.13px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 13px;">分布式锁</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.88px;">设计模式</a> <a href="/tags/%E9%99%90%E6%B5%81/" style="font-size: 13px;">限流</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/4eb3381c/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
              </p>
              <p class="item-title">
                <a href="/posts/4eb3381c/" class="title">分布式锁</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-08T02:10:15.000Z" itemprop="datePublished">2022-01-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/f7ccc3b4/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/f7ccc3b4/" class="title">Redis数据结构 - SDS</a>
              </p>
              <p class="item-date">
                <time datetime="2021-12-04T08:34:15.000Z" itemprop="datePublished">2021-12-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/19fe4bc5/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/19fe4bc5/" class="title">Redis原理 - Redis主流程</a>
              </p>
              <p class="item-date">
                <time datetime="2021-11-27T16:00:00.000Z" itemprop="datePublished">2021-11-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/adccc332/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/adccc332/" class="title">Redis 源码结构总览</a>
              </p>
              <p class="item-date">
                <time datetime="2021-11-27T06:59:01.000Z" itemprop="datePublished">2021-11-27</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/32609cb8/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
              </p>
              <p class="item-title">
                <a href="/posts/32609cb8/" class="title">限流算法</a>
              </p>
              <p class="item-date">
                <time datetime="2021-11-23T16:00:00.000Z" itemprop="datePublished">2021-11-24</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Request-Response-模型"><span class="toc-number">3.</span> <span class="toc-text">Request-Response 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Request-模型"><span class="toc-number">3.1.</span> <span class="toc-text">Request 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">3.1.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法"><span class="toc-number">3.1.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#核心方法"><span class="toc-number">3.1.3.</span> <span class="toc-text">核心方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Response-模型"><span class="toc-number">3.2.</span> <span class="toc-text">Response 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#核心方法-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">核心方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MultiMessage"><span class="toc-number">4.</span> <span class="toc-text">MultiMessage</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exchanger"><span class="toc-number">5.</span> <span class="toc-text">Exchanger</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HeaderExchanger"><span class="toc-number">6.</span> <span class="toc-text">HeaderExchanger</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exchangers"><span class="toc-number">7.</span> <span class="toc-text">Exchangers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通道"><span class="toc-number">8.</span> <span class="toc-text">通道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HeaderExchangeChannel"><span class="toc-number">8.1.</span> <span class="toc-text">HeaderExchangeChannel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性-2"><span class="toc-number">8.1.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取-HeaderExchangeChannel"><span class="toc-number">8.1.2.</span> <span class="toc-text">获取 HeaderExchangeChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移除-HeaderExchangeChannel"><span class="toc-number">8.1.3.</span> <span class="toc-text">移除 HeaderExchangeChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关闭"><span class="toc-number">8.1.4.</span> <span class="toc-text">关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#send-方法"><span class="toc-number">8.1.5.</span> <span class="toc-text">send 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#request-方法"><span class="toc-number">8.1.6.</span> <span class="toc-text">request 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ResponseFuture"><span class="toc-number">9.</span> <span class="toc-text">ResponseFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DefaultFuture"><span class="toc-number">9.1.</span> <span class="toc-text">DefaultFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态属性"><span class="toc-number">9.1.1.</span> <span class="toc-text">静态属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扫描超时请求"><span class="toc-number">9.1.2.</span> <span class="toc-text">扫描超时请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象属性"><span class="toc-number">9.1.3.</span> <span class="toc-text">对象属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法-2"><span class="toc-number">9.1.4.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Request-关联属性"><span class="toc-number">9.1.5.</span> <span class="toc-text">Request 关联属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取响应结果"><span class="toc-number">9.1.6.</span> <span class="toc-text">获取响应结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应结果"><span class="toc-number">9.1.7.</span> <span class="toc-text">响应结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连接断开异常"><span class="toc-number">9.1.8.</span> <span class="toc-text">连接断开异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#取消-DefaultFuture"><span class="toc-number">9.1.9.</span> <span class="toc-text">取消 DefaultFuture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置回调"><span class="toc-number">9.1.10.</span> <span class="toc-text">设置回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行回调"><span class="toc-number">9.1.11.</span> <span class="toc-text">执行回调</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#处理器"><span class="toc-number">10.</span> <span class="toc-text">处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HeartbeatHandler"><span class="toc-number">10.1.</span> <span class="toc-text">HeartbeatHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性-3"><span class="toc-number">10.1.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#辅助方法"><span class="toc-number">10.1.2.</span> <span class="toc-text">辅助方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连接建立"><span class="toc-number">10.1.3.</span> <span class="toc-text">连接建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连接断开"><span class="toc-number">10.1.4.</span> <span class="toc-text">连接断开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送消息"><span class="toc-number">10.1.5.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收消息"><span class="toc-number">10.1.6.</span> <span class="toc-text">接收消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HeaderExchangeHandler"><span class="toc-number">10.2.</span> <span class="toc-text">HeaderExchangeHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性-4"><span class="toc-number">10.2.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取被装饰的-ChannelHandler"><span class="toc-number">10.2.2.</span> <span class="toc-text">获取被装饰的 ChannelHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连接建立-1"><span class="toc-number">10.2.3.</span> <span class="toc-text">连接建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连接断开-1"><span class="toc-number">10.2.4.</span> <span class="toc-text">连接断开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送消息-1"><span class="toc-number">10.2.5.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理"><span class="toc-number">10.2.6.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收消息-1"><span class="toc-number">10.2.7.</span> <span class="toc-text">接收消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#只读请求"><span class="toc-number">10.2.7.1.</span> <span class="toc-text">只读请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双向请求"><span class="toc-number">10.2.7.2.</span> <span class="toc-text">双向请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单向请求"><span class="toc-number">10.2.7.3.</span> <span class="toc-text">单向请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理响应"><span class="toc-number">10.2.7.4.</span> <span class="toc-text">处理响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理String类型消息"><span class="toc-number">10.2.7.5.</span> <span class="toc-text">处理String类型消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#兜底处理"><span class="toc-number">10.2.7.6.</span> <span class="toc-text">兜底处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ExchangeHandler"><span class="toc-number">10.3.</span> <span class="toc-text">ExchangeHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ExchangeHandlerAdapter"><span class="toc-number">10.4.</span> <span class="toc-text">ExchangeHandlerAdapter</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异步转同步"><span class="toc-number">11.</span> <span class="toc-text">异步转同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#同步调用"><span class="toc-number">11.1.</span> <span class="toc-text">同步调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步调用"><span class="toc-number">11.2.</span> <span class="toc-text">异步调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转化流程图"><span class="toc-number">11.3.</span> <span class="toc-text">转化流程图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#客户端"><span class="toc-number">12.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ExchangeClient"><span class="toc-number">12.1.</span> <span class="toc-text">ExchangeClient</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HeaderExchangeClient"><span class="toc-number">12.2.</span> <span class="toc-text">HeaderExchangeClient</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性-5"><span class="toc-number">12.2.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法-3"><span class="toc-number">12.2.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开启心跳定时任务"><span class="toc-number">12.2.3.</span> <span class="toc-text">开启心跳定时任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其它方法"><span class="toc-number">12.2.4.</span> <span class="toc-text">其它方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#心跳任务"><span class="toc-number">13.</span> <span class="toc-text">心跳任务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#属性-6"><span class="toc-number">13.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任务逻辑"><span class="toc-number">13.2.</span> <span class="toc-text">任务逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#服务端"><span class="toc-number">14.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ExchangeServer-接口"><span class="toc-number">14.1.</span> <span class="toc-text">ExchangeServer 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HeaderExchangeServer"><span class="toc-number">14.2.</span> <span class="toc-text">HeaderExchangeServer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性-7"><span class="toc-number">14.2.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法-4"><span class="toc-number">14.2.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送消息-2"><span class="toc-number">14.2.3.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开启心跳定时任务-1"><span class="toc-number">14.2.4.</span> <span class="toc-text">开启心跳定时任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优雅关闭"><span class="toc-number">14.2.5.</span> <span class="toc-text">优雅关闭</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#编解码器"><span class="toc-number">15.</span> <span class="toc-text">编解码器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">16.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-rpc/Exchange层" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Dubbo源码分析 - 信息交换层
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/26722deb/" class="article-date">
	  <time datetime="2020-06-17T16:00:00.000Z" itemprop="datePublished">2020-06-18</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/RPC/">RPC</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Dubbo/" rel="tag">Dubbo</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/26722deb/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 18.1k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 77(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的几篇文章详细介绍了 Dubbo Remoting 中的 Transport 层，该层只负责单向消息传输，是 Dubbo 中端到端的统一网络传输实现。本篇文章将介绍网络传输层即 Transport 层之上的 Exchange 层，同时它也是 Dubbo Remoting 层的最顶层。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>信息交换层 Exchange 在传输层之上建立了 Request-Response 模型，实现了在不同传输方式之上都能做到统一的请求-响应处理，实现了同步转异步。以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer 。</p>
<p>一次 RPC 调用，上层请求 Request 只关注对应的响应 Response，至于是同步请求还是异步请求，又或者使用什么传输根本不关心。而 Transport 层以 Message 为中心提供单向消息传输，是无法满足这项诉求的，因此 Dubbo 基于 Transport 层做了更高层次的封装，构建了 Exchange 层。</p>
<p>Exchange 层代码结构如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-outline.jpg" alt></p>
<p>Exchange 层构建于 Transport 层之上，是 Transport 层的使用者，再结合上图中的代码结构不难发现，Exchange 层同样具备端点 Endpoint（Server 和 Client）、通道 Channel、处理器 Handler 以及编解码器 Codec 等组件，区别在于 Exchange 层将 Transport 层的 Message 分成了 Request 和 Response 两种类型，且所有组件都是以这两个模型为中心进行实现。接下来我们从 Request 和 Response 这一对核心类开始，依次介绍 Exchange 层涉及的核心接口和实现类。</p>
<h1 id="Request-Response-模型"><a href="#Request-Response-模型" class="headerlink" title="Request-Response 模型"></a>Request-Response 模型</h1><p>Exchange 层的 Request 和 Response 是对请求和响应的抽象。</p>
<h2 id="Request-模型"><a href="#Request-模型" class="headerlink" title="Request 模型"></a>Request 模型</h2><p>对一次 RPC 调用的请求进行抽象。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEARTBEAT_EVENT = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只读事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String READONLY_EVENT = <span class="string">"R"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求编号自增序列，注意当递增到Long.MAX_VALUE之后，会溢出到Long.MIN_VALUE，但是这不影响继续使用该负数作为消息ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong INVOKE_ID = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求编号 ，注意这个编号用来和该请求对应的响应Response关联，Response中的mId就是该请求的mId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mVersion;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求是否需要响应： true-&gt; 需要  false-&gt; 不需要</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mTwoWay = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件标识，如心跳请求、只读请求。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mEvent = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否异常的请求，主要用于：</span></span><br><span class="line"><span class="comment">     * 服务端收到请求后，如果使用 DecodeHandler 将二进制数据解码成Request对象，这个解码过程可能会出现异常，</span></span><br><span class="line"><span class="comment">     * 如果出现异常，那么就用该属性进行标识，其它 ChannelHandler 可以根据该标志做进一步处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mBroken = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求体，可以是任何类型的数据，也可以是null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object mData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特别说明：</strong>当事件标识为 true 时，可能是<strong>心跳请求</strong>或<strong>只读请求</strong>。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求编号进行赋值</span></span><br><span class="line">    mId = newId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入请求编号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    mId = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM进程内唯一，原子自增</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">newId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INVOKE_ID.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断是否是心跳请求条件：</span></span><br><span class="line"><span class="comment">  * 1. 需要是事件请求</span></span><br><span class="line"><span class="comment">  * 2. 判断请求体是否为 null</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeartbeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mEvent &amp;&amp; HEARTBEAT_EVENT == mData;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置心跳请求信息</span></span><br><span class="line"><span class="comment">  * 1. 设置 mEvent = true ，标志是事件</span></span><br><span class="line"><span class="comment">  * 2. 设置 mData = null</span></span><br><span class="line"><span class="comment">  * 3. 以上两者共同确定是心跳请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> isHeartbeat</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeartbeat</span><span class="params">(<span class="keyword">boolean</span> isHeartbeat)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (isHeartbeat) &#123;</span><br><span class="line">         setEvent(HEARTBEAT_EVENT);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否是事件请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mEvent;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 请求体是否不合法（解码请求体失败时会设置 mBroken = true）</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mBroken;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h2 id="Response-模型"><a href="#Response-模型" class="headerlink" title="Response 模型"></a>Response 模型</h2><p>对一次 RPC 响应进行抽象。</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEARTBEAT_EVENT = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只读事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String READONLY_EVENT = <span class="string">"R"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> OK = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端侧超时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CLIENT_TIMEOUT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端超时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> SERVER_TIMEOUT = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略其它响应状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应编号，和对应的 Request 的 mId 一致。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mId = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前协议的版本号，与请求版本号一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mVersion;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态码，有 OK、CLIENT_TIMEOUT、SERVER_TIMEOUT 等十多种， 默认是OK。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> mStatus = OK;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件标识。注意，只读事件不需要响应，也就不会使用到该属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mEvent = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误响应消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mErrorMsg;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object mResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特别说明：</strong>当事件标识为 true 时，可能是<strong>心跳响应</strong>，<strong>只读请求</strong>不需要响应。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 无参构造函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 响应编号，和对应的请求编号一致</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> id 响应编号</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">     mId = id;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> id      响应编号，和对应的请求编号一致</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> version 当前协议版本号，和对应的请求版本号一致</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">(<span class="keyword">long</span> id, String version)</span> </span>&#123;</span><br><span class="line">     mId = id;</span><br><span class="line">     mVersion = version;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心方法-1"><a href="#核心方法-1" class="headerlink" title="核心方法"></a>核心方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断是否是心跳事件</span></span><br><span class="line"><span class="comment">  * 1. 需要是事件</span></span><br><span class="line"><span class="comment">  * 2. 判断响应体是否为 null</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeartbeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mEvent &amp;&amp; HEARTBEAT_EVENT == mResult;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 只读请求是不需要响应的，心跳请求需要响应</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> isHeartbeat</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Deprecated</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeartbeat</span><span class="params">(<span class="keyword">boolean</span> isHeartbeat)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (isHeartbeat) &#123;</span><br><span class="line">         setEvent(HEARTBEAT_EVENT);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否是事件</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mEvent;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>Exchange 层为框架引入的 Request 和 Response 语义就介绍到这里，需要再次说明，这两个对象是 Exchange 层的核心，整个 Exchange 层都是围绕这两个对象进行任务的处理，在后面的分析过程中会看到。</p>
<h1 id="MultiMessage"><a href="#MultiMessage" class="headerlink" title="MultiMessage"></a>MultiMessage</h1><p>MultiMessage 是对多个消息的封装，实现了 Iterable 接口，支持对封装的消息集合进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiMessage</span> <span class="keyword">implements</span> <span class="title">Iterable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多消息的封装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List messages = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messages.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p>信息交换接口，是 Dubbo 的扩展接口，默认扩展名为 <strong>header</strong> ，对应的默认扩展实现为 HeaderExchanger ，同时也是 Exchanger 接口的唯一有效实现，该接口主要用来封装请求-响应模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(HeaderExchanger.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Exchanger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定一个服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message server  服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.EXCHANGER_KEY&#125;)</span><br><span class="line">    <span class="function">ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务器，即创建一个客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message channel  客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.EXCHANGER_KEY&#125;)</span><br><span class="line">    <span class="function">ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，Exchanger 接口和 Transporter 接口极其相似，因为 Exchanger 是对 Transporter 的封装，接下来通过 HeaderExchanger 就能验证这一点。</p>
<h1 id="HeaderExchanger"><a href="#HeaderExchanger" class="headerlink" title="HeaderExchanger"></a>HeaderExchanger</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchanger</span> <span class="keyword">implements</span> <span class="title">Exchanger</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"header"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务，创建客户端。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面代码可以看出，Exchanger 创建的 HeaderExchangeServer 和 HeaderExchangeClient 分别是对 Transporter 创建的 Server 和 Client 的封装，是 Exchange 层的服务器和客户端，下面对这两个过程进行说明：</p>
<ul>
<li>创建 HeaderExchangeClient <blockquote>
<ol>
<li>默认启动心跳检测</li>
<li>处理器的顺序为：Transporter层的Handler链 =&gt; DecodeHandler =&gt; HeaderExchangeHandler =&gt; ExchangeHandler</li>
<li>将Transporter创建的客户端封装到HeaderExchangeClient中</li>
</ol>
</blockquote>
</li>
<li>创建 HeaderExchangeServer<blockquote>
<ol>
<li>默认启动心跳检测</li>
<li>处理器的顺序为：Transporter层的Handler链 =&gt; DecodeHandler =&gt; HeaderExchangeHandler =&gt; ExchangeHandler</li>
<li>将Transporter创建的服务封装到HeaderExchangeServer中</li>
</ol>
</blockquote>
</li>
</ul>
<p>需要说明的是，截止到 HeaderExchanger 对服务和客户端的创建，一次 RPC 调用 Remoting 层的通道处理器 Handler 已经全部创建完毕，这些 Handler 在 Dubbo 的整个网络通信中发挥着巨大作用。分析完 Exchanger 数据交换接口后，我们继续看 Exchanger 的访问入口类 Exchangers 。</p>
<h1 id="Exchangers"><a href="#Exchangers" class="headerlink" title="Exchangers"></a>Exchangers</h1><p>Exchangers 是数据交换门面类，属于外观模式的实现。<strong>对于 Exchange 的上层来说，Exchange 层的入口正是 Exchangers 这个门面类</strong>，其中提供了多个 bind() 和 connect() 方法的重载，这些方法最终会通过 Dubbo SPI 机制获取 Exchanger 接口的扩展实现。<strong>整体流程和 Transport 层一致，Transport 层的入口也是要通过 Transports 门面类</strong>。下面我们简单看看它的代码实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exchangers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// check duplicate jar package</span></span><br><span class="line">        Version.checkDuplicate(Exchangers<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Exchangers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     URL串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(String url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bind(URL.valueOf(url), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">        <span class="keyword">return</span> getExchanger(url).bind(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     URL串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeClient <span class="title">connect</span><span class="params">(String url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connect(URL.valueOf(url), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">        <span class="keyword">return</span> getExchanger(url).connect(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Exchanger 扩展实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 URL 中获取 exchanger 的值，默认为 header</span></span><br><span class="line">        String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class="line">        <span class="keyword">return</span> getExchanger(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1 获取Exchanger，默认为 HeaderExchanger。</span></span><br><span class="line"><span class="comment">     * 2 紧接着调用 HeaderExchanger的bind方法创建 ExchangeServer实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 扩展名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Exchanger<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">type</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于目前 Dubbo 的 Exchanger 有效扩展实现只有 HeaderExchanger ，因此 Exchangers 中只保留了和 HeaderExchanger 相关的代码。</p>
<p>了解了 Exchange 层的 Request-Response 模型以及入口后，下面我们分别对 Exchange 层的端点 Endpoint、通道 Channel、处理器 Handler 以及编解码器 Codec2 进行详细说明。</p>
<h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>Exchange 层通道 Channel 继承关系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-channel-hierarchy.jpg" alt></p>
<p>在前面的文章中已经详细介绍了 Channel 接口以及 Transport 层对 Channel 接口的实现。Exchange 层基于 Channel 接口抽象出了 ExchangeChannel 接口，表示该层的网路连接，用来发送请求等操作。</p>
<p>ExchangeChannel 接口中的方法如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-channel-method.jpg" alt></p>
<p>上图中的灰色方法继承自 Endpoint 和 Channel 接口，其中 4 个白色的方法是 Exchange 层定义出的方法，request() 方法负责发送请求，getExchangeHandler() 方法用于获取信息交换处理器，close() 方法用于关闭通道。ExchangeChannel 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExchangeChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> future</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> future</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得信息交换处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ExchangeHandler <span class="title">getExchangeHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优雅关闭</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExchangeChannel 接口本身新定义了请求发送 request() 方法、获得信息交换处理器 getExchangeHandler() 方法以及关闭方法，其它方法分别继承自 Endpoint 和 Channel 接口中的方法。下面我们继续看它的 HeaderExchangeChannel 实现类。</p>
<h2 id="HeaderExchangeChannel"><a href="#HeaderExchangeChannel" class="headerlink" title="HeaderExchangeChannel"></a>HeaderExchangeChannel</h2><p>HeaderExchangeChannel 实现了 ExchangeChannel 接口，基于消息头的信息交换通道实现类。<strong>它本身是 Channel 的装饰器，封装了一个 Channel 对象，send() 和 request() 方法的实现都委托给这个 Channel 对象</strong>。</p>
<h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeChannel</span> <span class="keyword">implements</span> <span class="title">ExchangeChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HeaderExchangeChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作为 channel 的属性 key，value 是 HeaderExchangeChannel 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private static final String CHANNEL_KEY = HeaderExchangeChannel.class.getName() + ".CHANNEL";</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被装饰的 Channel，如 NettyChannel、NettyClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HeaderExchangeChannel 是传入channel的装饰器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 被装饰的 Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HeaderExchangeChannel(Channel channel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"channel == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HeaderExchangeChannel 中有 3 个属性，这三个属性都有各自的作用：</strong></p>
<ol>
<li><strong>CHANNEL_KEY:</strong> 静态常量，作为 Channel 存储 HeaderExchangeChannel 对象的 key，保证了同一个 Channel 创建唯一的 HeaderExchangeChannel 对象。</li>
<li><strong>channel:</strong> HeaderExchangeChannel 装饰的 Channel，此 channel 中会存储 HeaderExchangeChannel 对象，key 就是 CHANNEL_KEY 这个常量值。</li>
<li><strong>closed:</strong> 用于标记通道是否关闭，request() 和 send() 方法受该值影响。</li>
</ol>
<h3 id="获取-HeaderExchangeChannel"><a href="#获取-HeaderExchangeChannel" class="headerlink" title="获取 HeaderExchangeChannel"></a>获取 HeaderExchangeChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--- HeaderExchangeChannel</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建HeaderExchangeChannel 对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch Channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> HeaderExchangeChannel <span class="title">getOrAddChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 ch.getAttribute(CHANNEL_KEY) ，保证 ch 绑定唯一的 HeaderExchangeChannel 对象</span></span><br><span class="line">        HeaderExchangeChannel ret = (HeaderExchangeChannel) ch.getAttribute(CHANNEL_KEY);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> HeaderExchangeChannel(ch);</span><br><span class="line">            <span class="comment">// ch 必须是已连接状态，否则不会绑定对应的 HeaderExchangeChannel 对象</span></span><br><span class="line">            <span class="keyword">if</span> (ch.isConnected()) &#123;</span><br><span class="line">                ch.setAttribute(CHANNEL_KEY, ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>getOrAddChannel() 方法用于获取传入的 Channel 对应的 HeaderExchangeChannel 对象，并且 HeaderExchangeChannel 对象会对传入的 Channel 进行封装、装饰。不难看出两者期望是相互绑定关系，但要求 Channel 一方必须是处于连接状态。</strong></p>
<h3 id="移除-HeaderExchangeChannel"><a href="#移除-HeaderExchangeChannel" class="headerlink" title="移除 HeaderExchangeChannel"></a>移除 HeaderExchangeChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- HeaderExchangeChannel</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeChannelIfDisconnected</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ch 断开了连接，则解除邦定的 HeaderExchangeChannel 对象</span></span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span> &amp;&amp; !ch.isConnected()) &#123;</span><br><span class="line">            ch.removeAttribute(CHANNEL_KEY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>removeChannelIfDisconnected() 方法用于解除处于断开连接状态的 Channel 绑定的 HeaderExchangeChannel 对象。</p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 优雅关闭</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果已经关闭，就直接返回</span></span><br><span class="line">     <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 设置关闭标识，防止发起新的请求</span></span><br><span class="line">     closed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 等待请求完成</span></span><br><span class="line">     <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">          <span class="comment">// 请求处理完或者关闭超时，则结束</span></span><br><span class="line">         <span class="keyword">while</span> (DefaultFuture.hasFuture(channel) &amp;&amp; System.currentTimeMillis() - start &lt; timeout) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">10</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 logger.warn(e.getMessage(), e);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 关闭通道</span></span><br><span class="line">     close();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 关闭通道</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 执行 channel 的关闭动作</span></span><br><span class="line">         channel.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         logger.warn(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>HeaderExchangeChannel 优雅关闭主要做了三件事：</strong></p>
<ol>
<li>将自身的关闭标志 closed 设置为 true ，防止发起新的请求。</li>
<li>等待当前 Channel 上的请求被处理完成，除非超时退出。</li>
<li>关闭被装饰的 channel ，即 Transport 层的 Channel 。如 NettyChannel 会先将自身的 closed 字段设置为 true 等其它操作，最后才会关闭底层 Netty 层面的 Channel 。</li>
</ol>
<h3 id="send-方法"><a href="#send-方法" class="headerlink" title="send 方法"></a>send 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Endpoint 方法</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 默认不等待消息发出就返回</span></span><br><span class="line">     send(message, getUrl().getParameter(Constants.SENT_KEY, <span class="keyword">false</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Endpoint 方法</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> sent    true: 会等待消息发出，消息发送失败会抛出异常；  false: 不等待消息发出，将消息放入IO队列，即可返回</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 如果处于关闭状态，则抛出异常</span></span><br><span class="line">     <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">"Failed to send message "</span> + message + <span class="string">", cause: The channel "</span> + <span class="keyword">this</span> + <span class="string">" is closed!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果消息是 Request、Response、String 类型，直接交给 Channel.send() 方法</span></span><br><span class="line">     <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request</span><br><span class="line">             || message <span class="keyword">instanceof</span> Response</span><br><span class="line">             || message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">         channel.send(message, sent);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 构建 Request 对象，并且不需要响应</span></span><br><span class="line">         Request request = <span class="keyword">new</span> Request();</span><br><span class="line">         request.setVersion(Version.getProtocolVersion());</span><br><span class="line">         request.setTwoWay(<span class="keyword">false</span>);</span><br><span class="line">         request.setData(message);</span><br><span class="line">         channel.send(request, sent);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>HeaderExchangeChannel 中的 send() 方法实现是 Endpoint 接口中的方法，该方法比较简单，总体上是直接将消息通过被装饰的 Channel 发送出去，<strong>不关心响应结果</strong> 。</p>
<h3 id="request-方法"><a href="#request-方法" class="headerlink" title="request 方法"></a>request 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发送请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 请求超时时间，默认 1000</span></span><br><span class="line">     <span class="keyword">return</span> request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发送请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> timeout 请求超时时间</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 如果已经关闭，不能发起请求</span></span><br><span class="line">     <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">"Failed to send request "</span> + request + <span class="string">", cause: The channel "</span> + <span class="keyword">this</span> + <span class="string">" is closed!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 创建请求，并初始化请求编号</span></span><br><span class="line">     Request req = <span class="keyword">new</span> Request();</span><br><span class="line">     <span class="comment">// Dubbo 版本</span></span><br><span class="line">     req.setVersion(Version.getProtocolVersion());</span><br><span class="line">     <span class="comment">// 需要响应</span></span><br><span class="line">     req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">     <span class="comment">// 具体数据 为 RpcInvocation</span></span><br><span class="line">     req.setData(request);</span><br><span class="line">     <span class="comment">// 创建DefaultFuture 对象,该对象表示此次请求-响应是否完成</span></span><br><span class="line">     DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, req, timeout);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 使用被装饰的 Channel 发送请求</span></span><br><span class="line">         channel.send(req);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">         <span class="comment">// 发送请求失败就取消 DefaultFuture</span></span><br><span class="line">         future.cancel();</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 返回 DefaultFuture 对象</span></span><br><span class="line">     <span class="keyword">return</span> future;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>request() 方法非常重要，下面对该方法进行说明：</strong></p>
<ol>
<li>创建 Request 对象，创建的过程会初始化一个请求编号，该编号标志当前请求</li>
<li>该方法需要响应，也就是说服务器收到请求后要给对端发送处理后的结果</li>
<li>创建 DefaultFuture 对象，该对象表示此次请求-响应是否完成</li>
<li>请求的发送交给被装饰的 Channel</li>
<li>请求失败就取消 DefaultFuture，并抛出异常</li>
</ol>
<p><strong>发送请求的 request() 方法依赖 DefaultFuture ，关心响应结果，这也是和 send() 方法最大的不同。</strong></p>
<p><strong>特别说明：</strong></p>
<ul>
<li>send() 方法本身不关心响应结果; request() 方法关心响应结果，最终是<strong>通过 DefaultFuture 对象来传递响应结果</strong>。</li>
<li>Dubbo 支持同步和异步两种调用方式，<strong>默认使用同步调用方式，若要使用异步调用，需要服务消费方手动进行配置</strong>。其中异步调用还可细分为<strong>有返回值的异步调用</strong>和<strong>无返回值的异步调用</strong>。</li>
<li>Dubbo 的同步调用发送请求的方法是 request()；无返回值的异步调用发送请求的方法是 send()；有返回值的异步调用发送请求的方法是 request()。</li>
<li>Dubbo 的同步调用和有返回值的异步调用都关心调用结果，因此需要使用关心响应结果的 request() 方法来发送请求。而无返回值的异步调用不关心调用结果，使用不关心响应结果的 send() 方法即可。</li>
</ul>
<p>综上，是同步调用还是异步调用，需要调用结果还是不需要调用结果，这取决于 Exchange 层的使用方。request() 方法会返回一个 DefaultFuture 对象，该对象并不是请求的结果，而是对此次请求-响应的管理。这意味着可以从 DefaultFuture 对象中获取请求对应的响应信息，只不过在响应结果没有返回之前获取动作会处于阻塞状态（除非超时或结果返回），因此，对于同步调用一般是获取到返回的 DefaultFuture 对象后阻塞等待响应结果，在结果返回之前不会进行其它逻辑处理，对于异步调用业务方可以在合适的时机从 DefaultFuture 中获取响应结果。</p>
<p>有关同步调用和异步调用详细细节会在后面的文章中进行介绍，下面对 Exchange 层的 DefaultFuture 相关体系进行详细分析，它是 Dubbo 内部进行调用转换的核心。</p>
<h1 id="ResponseFuture"><a href="#ResponseFuture" class="headerlink" title="ResponseFuture"></a>ResponseFuture</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-future.jpg" alt></p>
<p>Dubbo 中的 Future 关联关系如上图所示，DefaultFuture 实现了 ResponseFuture 接口，request() 方法返回值就是 ResponseFuture 类型，这也意味着<strong>对于 request() 方法来说无论是同步调用还是异步调用，只有返回 ResponseFuture 才算发送操作完成</strong>。需要注意，<strong>request() 方法其实是基于 send() 方法的，我们知道 send() 方法是没有返回值的，因此 request() 方法引入了 DefaultFuture 对象来管理 Request 和 Response 关系</strong>，从上面的继承关系中就可以明确这一点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseFuture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取响应结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定的时间内获取结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutInMillis timeout.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeoutInMillis)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(ResponseCallback callback)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否完成</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> done or not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResponseFuture 有点类似 JDK 中的 Future 接口，支持获取响应结果、判断响应结果是否返回，其中设置回调方法 <strong>setCallback(ResponseCallback callback)</strong> 会在 <strong>FutureFilter</strong> 中使用，主要用于异步调用情况下的事件通知，在后面的文章中会进行介绍，这里不进行展开说明。</p>
<h2 id="DefaultFuture"><a href="#DefaultFuture" class="headerlink" title="DefaultFuture"></a>DefaultFuture</h2><p>DefaultFuture 表示一次请求-响应的结果，<strong>每一个请求（通过request()方法发送的请求）都对应一个 DefaultFuture 对象，DefaultFuture 同时也是所有 DefaultFuture 的管理容器。需要特别说明的是，Dubbo 框架底层数据传输使用的 NIO 组件处理请求理论上是异步的，但是 Dubbo 框架做了异步转同步的处理，DefaultFuture 在这个过程中扮演着重要角色。</strong></p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Request 编号到 Dubbo通道的映射</span></span><br><span class="line"><span class="comment">   * key: 请求编号</span></span><br><span class="line"><span class="comment">   * value: Dubbo 抽象的通道，用来发送请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, Channel&gt; CHANNELS = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, Channel&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Request 编号到 DefaultFuture 的映射</span></span><br><span class="line"><span class="comment">   * key: 请求编号</span></span><br><span class="line"><span class="comment">   * value: DefaultFuture</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, DefaultFuture&gt; FUTURES = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, DefaultFuture&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 启动扫描响应超时任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      Thread th = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RemotingInvocationTimeoutScan(), <span class="string">"DubboResponseTimeoutScanTimer"</span>);</span><br><span class="line">      <span class="comment">// 守护线程</span></span><br><span class="line">      th.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">      th.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>前面说到 DefaultFuture 自身就是个管理容器，原因就在 <strong>FUTURES</strong> 属性上。当 DefaultFuture 加载时会启动扫描响应超时任务线程，下面我们就来看看 <strong>RemotingInvocationTimeoutScan</strong> 这个任务体的逻辑。</p>
<h3 id="扫描超时请求"><a href="#扫描超时请求" class="headerlink" title="扫描超时请求"></a>扫描超时请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RemotingInvocationTimeoutScan</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 遍历请求关联的 DefaultFuture 集合</span></span><br><span class="line">                  <span class="keyword">for</span> (DefaultFuture future : FUTURES.values()) &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 如果 future 为空，或请求已经响应则进行下一个</span></span><br><span class="line">                      <span class="keyword">if</span> (future == <span class="keyword">null</span> || future.isDone()) &#123;</span><br><span class="line">                          <span class="keyword">continue</span>;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 请求没有响应，判断是否超时（请求时间 - 请求超时时间），超时就进入超时处理流程</span></span><br><span class="line">                      <span class="keyword">if</span> (System.currentTimeMillis() - future.getStartTimestamp() &gt; future.getTimeout()) &#123;</span><br><span class="line">                          <span class="comment">// 创建 Request 对应的 超时 Response 对象</span></span><br><span class="line">                          Response timeoutResponse = <span class="keyword">new</span> Response(future.getId());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 设置响应状态，如果请求已经发送则是服务端超时，否则客户端超时</span></span><br><span class="line">                          timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT);</span><br><span class="line">                          <span class="comment">// 异常信息</span></span><br><span class="line">                          timeoutResponse.setErrorMessage(future.getTimeoutMessage(<span class="keyword">true</span>));</span><br><span class="line">                          <span class="comment">// 响应结果，避免客户端等待</span></span><br><span class="line">                          DefaultFuture.received(future.getChannel(), timeoutResponse);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 休眠30 ms</span></span><br><span class="line">                  Thread.sleep(<span class="number">30</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  logger.error(<span class="string">"Exception when scan the timeout invocation of remoting."</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Dubbo 在 DefaultFuture 类加载时会开启一个守护线程，<strong>该线程用于轮询请求关联的 DefaultFuture 集合，及时对超时的请求进行异常结果的响应，尽可能减少客户端的等待时间</strong>。需要说明的是，该任务是对所有的 <strong>twoway</strong> 调用请求进行检测，不管是同步调用还是异步调用，只要超时立即给调用方响应一个超时异常结果，只是一般情况下异步调用不会立刻阻塞等待结果而已。</p>
<h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+--- DefaultFuture</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request request;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invoke id.  请求的编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求的 Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求-响应的超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前 DefaultFuture 创建的开始时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求发送的时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> sent;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Response response;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的选择器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition done = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调，适用于异步请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ResponseCallback callback;</span><br></pre></td></tr></table></figure>

<p>对象属性中的 <strong>Request</strong>、<strong>Response</strong>、<strong>Lock</strong> 以及 <strong>Condition</strong> 是实现异步转同步的必要对象。Dubbo 的异步转同步本质上是利用<strong>等待通知机制</strong>，等到分析 HeaderExchangeHandler 时还会回过头来看这一块的。</p>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 DefaultFuture 时，会把创建的该实例放入 FUTURES 缓存中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel 发送请求的 Channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request 请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 请求-响应的超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    <span class="keyword">this</span>.request = request;</span><br><span class="line">    <span class="comment">// 设置请求id，这个id是request和response映射的依据，非常重要</span></span><br><span class="line">    <span class="keyword">this</span>.id = request.getId();</span><br><span class="line">    <span class="comment">// 设置超时时间，如果传入的 timeout &gt; 0 就取传入的值，否则取 URL 中timeout的值，默认为 1000</span></span><br><span class="line">    <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">    <span class="comment">// Request 编号到 DefaultFuture 的映射，DefaultFuture 管理每个请求关联的DefaultFuture对象。</span></span><br><span class="line">    FUTURES.put(id, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// Request 编号到 Dubbo通道的映射</span></span><br><span class="line">    CHANNELS.put(id, channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 DefaultFuture 对象时会初始化对象属性，其中 <strong>sent</strong> 和 <strong>response</strong> 属性会在 HeaderExchangeHandler 处理方法中进行值的更新。</p>
<h3 id="Request-关联属性"><a href="#Request-关联属性" class="headerlink" title="Request 关联属性"></a>Request 关联属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+--- DefaultFuture</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 request 关联的 DefaultFuture 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 请求id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultFuture <span class="title">getFuture</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FUTURES.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断通道是否有未响应的请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 发送请求的 Channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasFuture</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CHANNELS.containsValue(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求时更新 sent 属性。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HeaderExchangeHandler#sent(com.alibaba.dubbo.remoting.Channel, java.lang.Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Request request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取请求关联的 DefaultFuture 对象</span></span><br><span class="line">        DefaultFuture future = FUTURES.get(request.getId());</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">            future.doSent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新 sent 属性，记录请求发送时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sent = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断调用结果是否返回，即判断 response 字段是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取响应结果"><a href="#获取响应结果" class="headerlink" title="获取响应结果"></a>获取响应结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 超时时间取 timeout 的值</span></span><br><span class="line">    <span class="keyword">return</span> get(timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 默认 1000</span></span><br><span class="line">        timeout = Constants.DEFAULT_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isDone()方法用来判断Response是否有值，即是否有返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">        <span class="comment">// 等待请求结果，计时开始</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待完成或超时</span></span><br><span class="line">            <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待请求结果，释放锁</span></span><br><span class="line">                done.await(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果调用结果成功返回，或等待超时，则跳出while循环继续执行后面逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (isDone() || System.currentTimeMillis() - start &gt; timeout) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未完成，抛出超时异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(sent &gt; <span class="number">0</span>, channel, getTimeoutMessage(<span class="keyword">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回响应</span></span><br><span class="line">    <span class="keyword">return</span> returnFromResponse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回响应</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">returnFromResponse</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    Response res = response;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"response cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.getResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时，抛出超时异常</span></span><br><span class="line">    <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, res.getErrorMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法用于在指定的超时时间内获取请求的响应结果，如果在超时时间内响应结果返回则本次请求完成，否则抛出超时异常。需要注意的是，在超时时间内返回的响应结果不一定是成功状态，因此在响应业务线程结果时，在 <strong>returnFromResponse()</strong> 方法中需要对响应的状态进行判断。<strong>上述代码就是等待通知机制中的等待部分</strong>。</p>
<h3 id="响应结果"><a href="#响应结果" class="headerlink" title="响应结果"></a>响应结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 收到响应结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel  通道</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response 响应结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求与返回结果进行匹配，匹配成功则移除关联的DefaultFuture对象</span></span><br><span class="line">        DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收结果,更新相关字段标识</span></span><br><span class="line">        <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">            future.doReceived(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">"The timeout response finally returned at "</span></span><br><span class="line">                    + (<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>).format(<span class="keyword">new</span> Date()))</span><br><span class="line">                    + <span class="string">", response "</span> + response</span><br><span class="line">                    + (channel == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">", channel: "</span> + channel.getLocalAddress()</span><br><span class="line">                    + <span class="string">" -&gt; "</span> + channel.getRemoteAddress()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 收到结果后，移除关联的的 Channel，它的使命已完成</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        CHANNELS.remove(response.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置响应结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置结果</span></span><br><span class="line">        response = res;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  唤醒等待线程 &#123;<span class="doctag">@link</span> #get()&#125;，然后执行 returnFromResponse 方法返回结果</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (done != <span class="keyword">null</span>) &#123;</span><br><span class="line">            done.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有事件回调，就执行回调逻辑。</span></span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        invokeCallback(callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当请求的响应结果返回时，会找到响应关联的 DefaultFuture 对象（根据请求编号从缓存集合中查找）并调用 doReceived() 方法，进而设置响应结果 <strong>response 属性</strong>的值。<strong>上述代码就是等待通知机制中的通知部分</strong>。</p>
<h3 id="连接断开异常"><a href="#连接断开异常" class="headerlink" title="连接断开异常"></a>连接断开异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当 Channel 断开连接时，应该对其关联的 request 进行异常结果响应，以结束阻塞等待的业务线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel channel to close</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeChannel</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> id : CHANNELS.keySet()) &#123;</span><br><span class="line">        <span class="comment">// 取出断开连接的Channel关联的Request对应的 DefaultFuture</span></span><br><span class="line">        <span class="keyword">if</span> (channel.equals(CHANNELS.get(id))) &#123;</span><br><span class="line">            DefaultFuture future = getFuture(id);</span><br><span class="line">            <span class="comment">// 如果请求结果还没有返回，则返回异常状态的结果</span></span><br><span class="line">            <span class="keyword">if</span> (future != <span class="keyword">null</span> &amp;&amp; !future.isDone()) &#123;</span><br><span class="line">                <span class="comment">// 构造响应 Response ，注意响应编号。</span></span><br><span class="line">                Response disconnectResponse = <span class="keyword">new</span> Response(future.getId());</span><br><span class="line">                disconnectResponse.setStatus(Response.CHANNEL_INACTIVE);</span><br><span class="line">                disconnectResponse.setErrorMessage(<span class="string">"Channel "</span> +</span><br><span class="line">                        channel +</span><br><span class="line">                        <span class="string">" is inactive. Directly return the unFinished request : "</span> +</span><br><span class="line">                        future.getRequest());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置响应结果 response</span></span><br><span class="line">                DefaultFuture.received(channel, disconnectResponse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>closeChannel() 方法比较简单，用于处理连接断开无法正常响应结果给业务线程的情况，和前文的扫描超时任务 RemotingInvocationTimeoutScan 一致，防止业务线程傻等请求结果。</p>
<h3 id="取消-DefaultFuture"><a href="#取消-DefaultFuture" class="headerlink" title="取消 DefaultFuture"></a>取消 DefaultFuture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+---- DefaultFuture</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除当前请求关联的 Channel、DefaultFuture</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建响应结果对象</span></span><br><span class="line">        Response errorResult = <span class="keyword">new</span> Response(id);</span><br><span class="line">        errorResult.setErrorMessage(<span class="string">"request future has been canceled."</span>);</span><br><span class="line">        response = errorResult;</span><br><span class="line">        <span class="comment">// 移除请求关联的 DefaultFuture，Channel</span></span><br><span class="line">        FUTURES.remove(id);</span><br><span class="line">        CHANNELS.remove(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>用于发送请求失败的情况，由于发送请求之前请求关联了 DefaultFuture 和 Channel ，因此需要移除该请求关联的对象。此外，创建一个异常结果，防止有业务线程还在傻傻地等待请求结果。</p>
<h3 id="设置回调"><a href="#设置回调" class="headerlink" title="设置回调"></a>设置回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+--- DefaultFuture</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter#asyncCallback(com.alibaba.dubbo.rpc.Invoker, com.alibaba.dubbo.rpc.Invocation)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(ResponseCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果有响应则立即执行回调</span></span><br><span class="line">        <span class="keyword">if</span> (isDone()) &#123;</span><br><span class="line">            invokeCallback(callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isdone = <span class="keyword">false</span>;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有响应，则先保存回调，收到结果再执行回调逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.callback = callback;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    isdone = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再尝试一次</span></span><br><span class="line">            <span class="keyword">if</span> (isdone) &#123;</span><br><span class="line">                invokeCallback(callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>设置回调是 <strong>FutureFilter</strong> 处理异步调用时使用的，目的是在返回调用结果时执行事件回调。</p>
<h3 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行回调逻辑</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeCallback</span><span class="params">(ResponseCallback c)</span> </span>&#123;</span><br><span class="line">      ResponseCallback callbackCopy = c;</span><br><span class="line">      <span class="keyword">if</span> (callbackCopy == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"callback cannot be null."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Response res = response;</span><br><span class="line">      <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"response cannot be null. url:"</span> + channel.getUrl());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 正常响应</span></span><br><span class="line">      <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 执行回调 - 处理执行结果</span></span><br><span class="line">              callbackCopy.done(res.getResult());</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              logger.error(<span class="string">"callback invoke error .reasult:"</span> + res.getResult() + <span class="string">",url:"</span> + channel.getUrl(), e);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 超时处理 TimeoutException 异常</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              TimeoutException te = <span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());</span><br><span class="line">              <span class="comment">// 执行回调 - 处理 TimeoutException 异常</span></span><br><span class="line">              callbackCopy.caught(te);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              logger.error(<span class="string">"callback invoke error ,url:"</span> + channel.getUrl(), e);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 处理其他异常</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              RuntimeException re = <span class="keyword">new</span> RuntimeException(res.getErrorMessage());</span><br><span class="line">              <span class="comment">// 执行回调 - 处理RuntimeException</span></span><br><span class="line">              callbackCopy.caught(re);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              logger.error(<span class="string">"callback invoke error ,url:"</span> + channel.getUrl(), e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在设置响应结果后，如果设置了事件回调则执行回调逻辑。</p>
<h1 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h1><p>Exchange 层通道处理器继承关系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-handler-hierarchy.jpg" alt></p>
<p>在 Transport 层已经介绍了大量 ChannelHandler，特别是 ChannelHandlerDelegate 类型的 ChannelHandler ，它们属于处理器装饰者接口，在 Exchange 层新定义了两个该类型的处理器 <strong>HeartbeatHandler</strong> 和 <strong>HeaderExchangeHandler</strong>。此外，Exchange 层还定义了一个<strong>供上层使用的 ExchangeHandler 接口及其抽象实现类 ExchangeHandlerAdapter</strong>。无论是发送请求还是处理响应都会涉及到 ChannelHandler。</p>
<h2 id="HeartbeatHandler"><a href="#HeartbeatHandler" class="headerlink" title="HeartbeatHandler"></a>HeartbeatHandler</h2><p>专门处理心跳消息的 ChannelHandler 实现，同样是在原有的 ChannelHandler 的基础上添加一些功能。</p>
<h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatHandler</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HeartbeatHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Channel的读时间戳 的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String KEY_READ_TIMESTAMP = <span class="string">"READ_TIMESTAMP"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Channel的写时间戳 的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String KEY_WRITE_TIMESTAMP = <span class="string">"WRITE_TIMESTAMP"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装饰 ChannelHandler</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeartbeatHandler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置 Channel 读时间戳</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setReadTimestamp</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">     channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置 Channel 写时间戳</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setWriteTimestamp</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">     channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 清理 Channel 中读时间戳</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearReadTimestamp</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">     channel.removeAttribute(KEY_READ_TIMESTAMP);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 清理 Channel 中写时间戳</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearWriteTimestamp</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">     channel.removeAttribute(KEY_WRITE_TIMESTAMP);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否是心跳请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isHeartbeatRequest</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> message <span class="keyword">instanceof</span> Request &amp;&amp; ((Request) message).isHeartbeat();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否是心跳响应</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isHeartbeatResponse</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> message <span class="keyword">instanceof</span> Response &amp;&amp; ((Response) message).isHeartbeat();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接完成时，设置通道的最后读写时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    setReadTimestamp(channel);</span><br><span class="line">    setWriteTimestamp(channel);</span><br><span class="line">    <span class="comment">// 设置最后读写时间后，传递给底层的 ChannelHandler 对象进行处理</span></span><br><span class="line">    handler.connected(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeartbeatHandler 处理连接建立只是记录了通道的最后读写时间。</p>
<h3 id="连接断开"><a href="#连接断开" class="headerlink" title="连接断开"></a>连接断开</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接断开时，清空通道的最后读写时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    clearReadTimestamp(channel);</span><br><span class="line">    clearWriteTimestamp(channel);</span><br><span class="line">    <span class="comment">// 清理读写时间后，传递给底层的 ChannelHandler 对象进行处理</span></span><br><span class="line">    handler.disconnected(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeartbeatHandler 处理连接断开只是清理了最后读写时间。</p>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 发送消息后，设置最后写的时间</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       setWriteTimestamp(channel);</span><br><span class="line">       <span class="comment">// 记录最后写时间后，传递给底层的 ChannelHandler 对象进行处理</span></span><br><span class="line">       handler.sent(channel, message);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>HeartbeatHandler 处理发送消息只是记录了最后的写时间，然后传递给底层的 ChannelHandler 对象继续处理。</p>
<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 收到消息，设置最后读时间</span></span><br><span class="line"><span class="comment">   * 1. 收到心跳请求的时候，会生成相应的心跳响应并返回；</span></span><br><span class="line"><span class="comment">   * 2. 收到心跳响应的时候，会打印相应的日志；</span></span><br><span class="line"><span class="comment">   * 3. 在收到其他类型的消息时，会传递给底层的 ChannelHandler 对象进行处理</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1 设置最后读时间</span></span><br><span class="line">      setReadTimestamp(channel);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2 收到心跳请求，则生成对应的心跳响应并返回</span></span><br><span class="line">      <span class="keyword">if</span> (isHeartbeatRequest(message)) &#123;</span><br><span class="line">          Request req = (Request) message;</span><br><span class="line">          <span class="comment">// 需要响应</span></span><br><span class="line">          <span class="keyword">if</span> (req.isTwoWay()) &#123;</span><br><span class="line">              <span class="comment">// 设置请求id，为了和请求一一对应</span></span><br><span class="line">              Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">              <span class="comment">// 心跳事件</span></span><br><span class="line">              res.setEvent(Response.HEARTBEAT_EVENT);</span><br><span class="line">              <span class="comment">// 心跳响应</span></span><br><span class="line">              channel.send(res);</span><br><span class="line">              <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                  <span class="keyword">int</span> heartbeat = channel.getUrl().getParameter(Constants.HEARTBEAT_KEY, <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                      logger.debug(<span class="string">"Received heartbeat from remote channel "</span> + channel.getRemoteAddress()</span><br><span class="line">                              + <span class="string">", cause: The channel has no data-transmission exceeds a heartbeat period"</span></span><br><span class="line">                              + (heartbeat &gt; <span class="number">0</span> ? <span class="string">": "</span> + heartbeat + <span class="string">"ms"</span> : <span class="string">""</span>));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3 收到心跳响应，则打印日志</span></span><br><span class="line">      <span class="keyword">if</span> (isHeartbeatResponse(message)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">              logger.debug(<span class="string">"Receive heartbeat response in thread "</span> + Thread.currentThread().getName());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4 其它类型消息，则传递给底层的 ChannelHandler 对象进行处理</span></span><br><span class="line">      handler.received(channel, message);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>HeartbeatHandler 在处理接收消息时有几个点需要注意：</strong></p>
<ol>
<li>收到消息会记录最后读的时间。</li>
<li>如果收到的是心跳请求消息，则生成该请求的响应并返回给业务线程，不会再往下传递即HeartbeatHandler后面的ChannelHandler没有机会处理这个消息。</li>
<li>如果收到的是心跳响应消息，则打印日志即可，同样不会再往下传递即HeartbeatHandler后面的ChannelHandler没有机会处理这个消息。</li>
<li>如果不是 2、3 步的情况，则直接传递给底层的 ChannelHandler 对象进行处理。</li>
</ol>
<p>需要注意的是，HeartbeatHandler 定义在 Exchange 层，但是使用是在 transport 层，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无论是Client还是Server，在构造方法中都会将传入的ChannelHandler进行包装，为该 ChannelHandler 增加了 Dubbo 消息派发、心跳处理以及多消息处理的功能。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ChannelHandler <span class="title">wrapInternal</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MultiMessageHandler( <span class="comment">// 多消息处理</span></span><br><span class="line">                <span class="keyword">new</span> HeartbeatHandler( <span class="comment">// 心跳处理</span></span><br><span class="line">                        ExtensionLoader.getExtensionLoader(Dispatcher<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                                .<span class="title">getAdaptiveExtension</span>() </span></span><br><span class="line"><span class="class">                                .<span class="title">dispatch</span>(<span class="title">handler</span>, <span class="title">url</span>) // 返回的是一个 <span class="title">ChannelHandlerDelegate</span> 类型的对象，默认是 <span class="title">AllChannelHandler</span>，确定了具体的线程模型</span></span><br><span class="line"><span class="class">                )</span></span><br><span class="line"><span class="class">        )</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="HeaderExchangeHandler"><a href="#HeaderExchangeHandler" class="headerlink" title="HeaderExchangeHandler"></a>HeaderExchangeHandler</h2><p>HeaderExchangeHandler 是一个装饰者类型的 ChannelHandler，内部封装了 ExchangeHandler 对象，而 ExchangeHandler 是上层与 Exchange 层交互的重要接口，上层调用方可以实现该接口完成特定功能。经过 HeaderExchangeHandler 装饰的 ExchangeHandler 对象具备 Exchange 层处理请求和响应的能力，最后再经过 Transport 层的 ChannelHandler 装饰而具备 Transport 层处理消息的能力。装饰流程如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-wrap.jpg" alt></p>
<p>HeaderExchangeHandler 作为一个装饰器，其 <strong>对 Channel 中的逻辑处理最终都会委托给被装饰的对象即上层提供的 ExchangeHandler 进行处理，HeaderExchangeHandler 本身关注点在于对 Request 和 Response 的处理逻辑</strong>。</p>
<p>下面分析 HeaderExchangeHandler 对 Channel 中的逻辑处理。</p>
<h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeHandler</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HeaderExchangeHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Channel的读时间戳 的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String KEY_READ_TIMESTAMP = HeartbeatHandler.KEY_READ_TIMESTAMP;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Channel的写时间戳 的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String KEY_WRITE_TIMESTAMP = HeartbeatHandler.KEY_WRITE_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被装饰的 ChannelHandler,由上层传入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeHandler</span><span class="params">(ExchangeHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeaderExchangeHandler 实现了 ChannelHandlerDelegate 接口，基于消息头部的信息交换处理器实现类。</p>
<h3 id="获取被装饰的-ChannelHandler"><a href="#获取被装饰的-ChannelHandler" class="headerlink" title="获取被装饰的 ChannelHandler"></a>获取被装饰的 ChannelHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取被装饰的 ChannelHandler</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果被装饰的 ChannelHandler 属于装饰者类型就获取其装饰的 handler</span></span><br><span class="line">     <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelHandlerDelegate) &#123;</span><br><span class="line">         <span class="keyword">return</span> ((ChannelHandlerDelegate) handler).getHandler();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> handler;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接建立-1"><a href="#连接建立-1" class="headerlink" title="连接建立"></a>连接建立</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对连接建立的处理</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> channel 底层的 Dubbo Channel</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">      <span class="comment">// 1. 设置读写时间戳</span></span><br><span class="line">      channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">      channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 创建 channel 相应的 HeaderExchangeChannel 并将两者绑定.</span></span><br><span class="line">      ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 3. 通知上层 ExchangeHandler 处理 connect 事件</span></span><br><span class="line">          handler.connected(exchangeChannel);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 4. 若channel已经断开，则 解绑 channel 与 HeaderExchangeChannel 的联系</span></span><br><span class="line">          HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接断开-1"><a href="#连接断开-1" class="headerlink" title="连接断开"></a>连接断开</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对连接断开的处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 设置读写时间戳</span></span><br><span class="line">    channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">    channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建 channel 相应的 HeaderExchangeChannel 并将两者绑定.</span></span><br><span class="line">    ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 通知上层 ExchangeHandler 处理 disconnect</span></span><br><span class="line">        handler.disconnected(exchangeChannel);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 调用 DefaultFuture.closeChannel 方法通知 DefaultFuture 连接断开了，避免连接断开了还在阻塞业务线程。</span></span><br><span class="line">        <span class="comment">// DefaultFuture 接到连接断开通知后会先获取连接对应的请求，再通过请求找到关联的 DefaultFuture，判断该请求是否响应，没有响应就创建一个状态码为 CHANNEL_INACTIVE 的 Response 并设置到结果属性。</span></span><br><span class="line">        DefaultFuture.closeChannel(channel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 解绑 channel 与 HeaderExchangeChannel 的联系</span></span><br><span class="line">        HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理发送的数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel 底层的 Dubbo Channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 可能是请求/响应 消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 设置写时间</span></span><br><span class="line">        channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">        <span class="comment">// 2. 创建 channel 相应的 HeaderExchangeChannel 并将两者绑定.</span></span><br><span class="line">        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 通知上层 ExchangeHandler 实现的 sent() 方法</span></span><br><span class="line">            handler.sent(exchangeChannel, message);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 4.  若channel已经断开，则 解绑 channel 与 HeaderExchangeChannel 的联系</span></span><br><span class="line">            HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上层 ExchangeHandler 实现的 sent() 方法 执行异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        exception = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 如果是请求，则调用 DefaultFuture.sent() 方法更新请求的具体发送时间</span></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        Request request = (Request) message;</span><br><span class="line">        DefaultFuture.sent(channel, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 如果发送消息出现异常，则进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) exception;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RemotingException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RemotingException) exception;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel.getLocalAddress(), channel.getRemoteAddress(),</span><br><span class="line">                    exception.getMessage(), exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 HeaderExchangeChannel.request() 方法中创建了 DefaultFuture 对象，然后将请求通过装饰的 Dubbo Channel 发送出去。<strong>请求会通过 Channel 进行传输，在传输的过程中会触发沿途的 ChannelHandler.sent() 等方法，HeaderExchangeHandler 的 sent() 处理逻辑包括调用 DefaultFuture.sent() 方法更新 DefaultFuture 中的 sent 的值即更新请求发送时间</strong>。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 捕获到异常</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> channel   底层的 Dubbo Channel</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> exception exception.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1. 当发生 ExecutionException 异常（线程池处理任务异常）</span></span><br><span class="line">     <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ExecutionException) &#123;</span><br><span class="line">         ExecutionException e = (ExecutionException) exception;</span><br><span class="line">         Object msg = e.getRequest();</span><br><span class="line">         <span class="comment">// 1.1 请求消息</span></span><br><span class="line">         <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">             Request req = (Request) msg;</span><br><span class="line">             <span class="comment">// 1.2 如果当前请求需要响应且非心跳请求，则发送异常处理结果给调用方</span></span><br><span class="line">             <span class="keyword">if</span> (req.isTwoWay() &amp;&amp; !req.isHeartbeat()) &#123;</span><br><span class="line">                 <span class="comment">// 发送状态码为 SERVER_ERROR 的响应</span></span><br><span class="line">                 Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">                 res.setStatus(Response.SERVER_ERROR);</span><br><span class="line">                 res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">                 channel.send(res);</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2. 非线程池处理异常时，将异常交给上层 Handler 处理</span></span><br><span class="line">     ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 3. 通知上层 ExchangeHandler 实现的 caught() 方法</span></span><br><span class="line">         handler.caught(exchangeChannel, exception);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 4. 若channel已经断开，则 解绑 channel 与 HeaderExchangeChannel 的联系</span></span><br><span class="line">         HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>HeaderExchangeHandler 属于 Dubbo 的 ChannelHandler 链的一部分，并且是 Transport 层 ChannelHandler 装饰的对象，Transport 层实现了 Dubbo 的线程模型，但是线程池执行时可能会发生异常，而这个异常类型就是 ExecutionException 。</p>
<p><strong>附加说明：</strong>任一 ChannelHandler 处理异常都会被 NIO 底层异常处理捕获到，然后讲异常交给 ChannelHandler 处理。</p>
<p>如果线程池执行任务发生异常就会抛出该异常，HeaderExchangeHandler 最后会捕获到该异常。异常具体位置如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-dispatcher-exception.jpg" alt></p>
<h3 id="接收消息-1"><a href="#接收消息-1" class="headerlink" title="接收消息"></a>接收消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 接收消息</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> channel 底层的 Dubbo Channel</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> message message 消息</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 1. 设置最后的读时间</span></span><br><span class="line">     channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">     <span class="comment">// 2. 创建 channel 相应的 HeaderExchangeChannel 并将两者绑定.</span></span><br><span class="line">     ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 3. 对收到的消息分类</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 3.1 处理请求消息</span></span><br><span class="line">         <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">             Request request = (Request) message;</span><br><span class="line">             <span class="comment">// 3.1.1 只读请求</span></span><br><span class="line">             <span class="keyword">if</span> (request.isEvent()) &#123;</span><br><span class="line">                 <span class="comment">// 在Channel上设置'channel.readonly' 标志</span></span><br><span class="line">                 <span class="comment">// 注意，这里没有再调用 handler.recived 方法，说明不会再往下处理了</span></span><br><span class="line">                 handlerEvent(channel, request);</span><br><span class="line">                 <span class="comment">// 处理普通请求</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 3.1.2 需要响应，要将响应写回请求方</span></span><br><span class="line">                 <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                     <span class="comment">// 处理请求</span></span><br><span class="line">                     Response response = handleRequest(exchangeChannel, request);</span><br><span class="line">                     <span class="comment">// 将调用结果返回给服务消费端</span></span><br><span class="line">                     channel.send(response);</span><br><span class="line">                     </span><br><span class="line">                     <span class="comment">// 3.1.3 不需要响应，直接交给上层实现的 ExchangeHandler 进行处理</span></span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     handler.received(exchangeChannel, request.getData());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 3.2 处理响应响应消息</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">             <span class="comment">// 将关联的 DefaultFuture 设置为完成状态（或是异常完成状态）</span></span><br><span class="line">             handleResponse(channel, (Response) message);</span><br><span class="line">             </span><br><span class="line">             <span class="comment">// 3.3 处理String类型的消息，根据当前服务的角色进行分类处理</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 3.3.1 客户端侧 不支持String</span></span><br><span class="line">             <span class="keyword">if</span> (isClientSide(channel)) &#123;</span><br><span class="line">                 Exception e = <span class="keyword">new</span> Exception(<span class="string">"Dubbo client can not supported string message: "</span> + message + <span class="string">" in channel: "</span> + channel + <span class="string">", url: "</span> + channel.getUrl());</span><br><span class="line">                 logger.error(e.getMessage(), e);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 3.3.2 服务端侧，目前仅有 telnet 命令的情况</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 调用 handler 的 telnet方法，处理telnet命令，并将执行命令的结果发送可客户端。【注意：ExchangeHandler实现了TelnetHandler接口】</span></span><br><span class="line">                 String echo = handler.telnet(channel, (String) message);</span><br><span class="line">                 <span class="keyword">if</span> (echo != <span class="keyword">null</span> &amp;&amp; echo.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                     channel.send(echo);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 3.4 其他情况，直接交给上层实现的 ExchangeHandler 进行处理</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             handler.received(exchangeChannel, message);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 4. 若channel已经断开，则 解绑 channel 与 HeaderExchangeChannel 的联系</span></span><br><span class="line">         HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>由于收到消息的类型可能有多种，不同类型处理逻辑也不相同，下面对消息分类处理进行说明。</p>
<h4 id="只读请求"><a href="#只读请求" class="headerlink" title="只读请求"></a>只读请求</h4><p>只读请求由 handlerEvent() 方法进行处理，它会在 Channel 上设置 <strong>channel.readonly</strong> 标识，客户端收到只读事件请求后，后续不再向对应的服务发送新的请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理只读事件请求</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> channel 底层 Dubbo 通道</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> req     请求</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handlerEvent</span><span class="params">(Channel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">      <span class="comment">// 如果是只读请求 'R' </span></span><br><span class="line">      <span class="keyword">if</span> (req.getData() != <span class="keyword">null</span> &amp;&amp; req.getData().equals(Request.READONLY_EVENT)) &#123;</span><br><span class="line">          <span class="comment">// 客户端收到 READONLY_EVENT 事件请求后记录到通道，后续不再向该服务器发送新的请求。[服务调用时会检查服务的状态]</span></span><br><span class="line">          channel.setAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY, Boolean.TRUE);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="双向请求"><a href="#双向请求" class="headerlink" title="双向请求"></a>双向请求</h4><p>双向请求即需要响应的请求由 handleRequest() 方法进行处理，该方法会先判断请求是否解码失败，如果解码失败则返回异常响应，如果请求解码成功则会将正常解码的请求交给上层实现的 ExchangeHandler 进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理普通请求 - 需要响应</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> channel 底层 Dubbo 通道</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Response <span class="title">handleRequest</span><span class="params">(ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">      <span class="comment">// 创建响应对象</span></span><br><span class="line">      Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果是解码失败的请求，则返回状态为 BAD_REQUEST 的异常结果</span></span><br><span class="line">      <span class="keyword">if</span> (req.isBroken()) &#123;</span><br><span class="line">          <span class="comment">// 请求数据，转成 msg</span></span><br><span class="line">          Object data = req.getData();</span><br><span class="line">          String msg;</span><br><span class="line">          <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">              msg = <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">              msg = StringUtils.toString((Throwable) data);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              msg = data.toString();</span><br><span class="line">          &#125;</span><br><span class="line">          res.setErrorMessage(<span class="string">"Fail to decode request due to: "</span> + msg);</span><br><span class="line">          res.setStatus(Response.BAD_REQUEST);</span><br><span class="line">          <span class="comment">// 返回</span></span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取请求数据，这里一般是 RpcInvocation 对象</span></span><br><span class="line">      Object msg = req.getData();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 交给上层实现的 ExchangeHandler 进行处理</span></span><br><span class="line">          Object result = handler.reply(channel, msg);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 封装请求状态和结果</span></span><br><span class="line">          res.setStatus(Response.OK);</span><br><span class="line">          res.setResult(result);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 上层实现的 ExchangeHandler 处理异常</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 若调用过程出现异常，则设置 SERVICE_ERROR，表示服务端异常</span></span><br><span class="line">          res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">          res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 返回响应</span></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>需要说明的是，在 Dubbo 2.7.x 版本中已经支持服务端的异步处理，通过 Java 8 的 CompletableFuture 来实现。从 2.7.0 开始，Dubbo 的所有异步编程接口开始以 CompletableFuture 为基础 。处理请求的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 创建响应对象</span></span><br><span class="line">    Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">    <span class="comment">// 请求解码失败</span></span><br><span class="line">    <span class="keyword">if</span> (req.isBroken()) &#123; </span><br><span class="line">        Object data = req.getData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置异常信息和响应码，将异常响应返回给对端</span></span><br><span class="line">        res.setErrorMessage(<span class="string">"Fail to decode request due to: "</span> + msg);</span><br><span class="line">        res.setStatus(Response.BAD_REQUEST); </span><br><span class="line">        channel.send(res); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object msg = req.getData();</span><br><span class="line">    <span class="comment">// 交给上层实现的ExchangeHandler进行处理。</span></span><br><span class="line">    <span class="comment">// DubboProtocol 中的 requestHandler 的 reply 方法返回的类型是 CompletableFuture 。</span></span><br><span class="line">    CompletionStage&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求处理后的回调</span></span><br><span class="line">    future.whenComplete((appResult, t) -&gt; &#123; </span><br><span class="line">        <span class="comment">// 返回正常响应</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            res.setStatus(Response.OK);</span><br><span class="line">            res.setResult(appResult);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 处理过程发生异常，设置异常信息和错误码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">            res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送响应</span></span><br><span class="line">        channel.send(res); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单向请求"><a href="#单向请求" class="headerlink" title="单向请求"></a>单向请求</h4><p>单向请求即调用方不需要返回结果，直接交给上层 ExchangeHandler 实现的 received() 方法进行处理。对于 DubboProtocol 来说，received() 方法会依赖 reply() 方法，单向请求不使用 reply() 方法的返回结果而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeHandler</span><br><span class="line"> handler.received(exchangeChannel, request.getData());</span><br><span class="line"></span><br><span class="line">+--- DubboProtocl</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">  <span class="comment">// 判断消息类型是不是 Invocation</span></span><br><span class="line">   <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;</span><br><span class="line">        reply((ExchangeChannel) channel, message);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">super</span>.received(channel, message);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h4><p>处理接收到的 Response 消息，也就是<strong>返回了结果，只需要 HeaderExchangeHandler 调用 handleResponse() 方法将关联的 DefaultFuture 设置为完成状态（或是异常完成状态）</strong>，然后向下传递即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 处理响应 - 客户端收到服务端的响应</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> channel  底层 Dubbo 通道</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> response 响应</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(Channel channel, Response response)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       <span class="comment">// 只处理非心跳事件响应，调用DefaultFuture#received(channel, response) 方法设置响应结果以及唤醒等待请求结果的线程。</span></span><br><span class="line">       <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; !response.isHeartbeat()) &#123;</span><br><span class="line">           DefaultFuture.received(channel, response);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 HeaderExchangeChannel.request() 方法中完成 DefaultFuture 对象的创建后，会将请求通过装饰的 Dubbo Channel 发送出去，发送的过程会触发 Dubbo Channel 中 ChannelHandler 链，至于是 IO 线程处理请求还是通过线程池来处理请求，需要看具体的消息派发策略。服务端处理完请求后，会将结果发送到对端，消费端读取到完整响应后，同样会触发 Dubbo Channel 中 ChannelHandler 链，当响应传递到 HeaderExchangeHandler 时 received() 方法会触发，执行该方法的内部逻辑，也就是调用 handleResponse() 方法设置响应结果并唤醒等待请求结果的线程。</strong></p>
<h4 id="处理String类型消息"><a href="#处理String类型消息" class="headerlink" title="处理String类型消息"></a>处理String类型消息</h4><p>对于 String 类型的消息，HeaderExchangeHandler 会根据当前服务的角色进行分类处理，目前仅支持 <strong>telnet</strong> 命令。</p>
<h4 id="兜底处理"><a href="#兜底处理" class="headerlink" title="兜底处理"></a>兜底处理</h4><p>如果接收的消息不是以上类型，则直接交给上层实现的 ExchangeHandler 进行处理。</p>
<h2 id="ExchangeHandler"><a href="#ExchangeHandler" class="headerlink" title="ExchangeHandler"></a>ExchangeHandler</h2><p>ExchangeHandler 是 Exchange 层定义的供上层使用的信息交换处理器接口，该接口继承了 ChannelHandler 和 TelnetHandler 接口，它同样是一个 ChannelHandler 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExchangeHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span>, <span class="title">TelnetHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> response  返回请求结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object request)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExchangeHandler 新定义了 <strong>reply()</strong> 方法，该方法主要用来处理请求并返回请求结果，上文中的 HeaderExchangeHandler.handleRequest() 方法处理双向请求的过程就是将 <strong>reply()</strong> 方法返回结果设置到 <strong>Response.mResult</strong> 属性中。</p>
<h2 id="ExchangeHandlerAdapter"><a href="#ExchangeHandlerAdapter" class="headerlink" title="ExchangeHandlerAdapter"></a>ExchangeHandlerAdapter</h2><p>信息交换处理器适配器抽象类，实现了 ExchangeHandler 接口并继承了 TelnetHandlerAdapter 类，空实现了 <strong>reply</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">TelnetHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ExchangeHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object msg)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ExchangeHandler 接口虽然属于 ChannelHandler 类型，但是该接口的定位是供 Exchange 层的上层使用，其实就是 Protocol 层。截止到目前，我们不难发现 ExchangeHandler 的实现就是整个 ChannelHandler 链的最尾的一个节点，这意味着上层逻辑的直接处理对象就是该实现。</strong></p>
<p>由于 ExchangeHandlerAdapter 实现了 ExchangeHandler 接口，在 DubboProtocol、ThirftProtocol 中都会基于 ExchangeHandlerAdapter 实现自己的处理器，处理请求并返回结果，如 DubboProtocol 中的处理器实现，用于将请求最终交给对应的 Invoker 对象处理，简化后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line">       <span class="comment">// 用于处理服务消费者的同步调用和异步调用的请求</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;</span><br><span class="line">               <span class="comment">// 转成 Invocation</span></span><br><span class="line">               Invocation inv = (Invocation) message;</span><br><span class="line">               <span class="comment">// 根据调用信息获取 Invoker</span></span><br><span class="line">               Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">               <span class="comment">// 执行调用</span></span><br><span class="line">               <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">         <span class="comment">//... 省略代码</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">           <span class="comment">//... 省略代码</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">          <span class="comment">//... 省略代码</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="异步转同步"><a href="#异步转同步" class="headerlink" title="异步转同步"></a>异步转同步</h1><p>Dubbo 协议下使用的网络通信底层依赖的是 NIO 组件，而这些 NIO 组件是异步通讯机制。此外，TCP 协议本身就是异步的，在 TCP 协议层面发送完 RPC 请求后，线程是不会等待 RPC 的响应结果的。既然底层是异步处理请求，那么 Dubbo 是怎样实现同步调用的呢？其实 Dubbo 异步调用和同步调用差不多，区别在于获取调用结果的时机。在分析异步转同步前，我们先简单说明下 Dubbo 中的同步调用和异步调用。</p>
<h2 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h2><p>同步调用是一种阻塞式的调用方式，消费方发起调用后会处于阻塞等待状态，直到服务提供方返回结果（这里不考虑超时、出错等异常流）。过程如下：</p>
<ol>
<li>消费方业务线程调用远程服务接口，同时当前业务线程处于阻塞状态即阻塞等待调用结果。</li>
<li>服务提供方收到消费方的请求后会对请求进行处理，处理完毕会将结果发送到对端。</li>
<li>消费方收到调用结果后，阻塞的业务线程继续往下执行。</li>
</ol>
<p>上述同步调用过程有 3 个点值得关注：</p>
<ol>
<li>业务线程是怎么进入阻塞状态的</li>
<li>如何定义消费方收到调用结果</li>
<li>业务线程是如何唤醒的</li>
</ol>
<p>要弄清楚上面的问题需要从源码中找线索，我们先下面的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker.doInvoke()</span><br><span class="line">    <span class="comment">// 异步无返回值</span></span><br><span class="line">    <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">       <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">       <span class="comment">// 发送请求</span></span><br><span class="line">       currentClient.send(inv, isSent);</span><br><span class="line">       <span class="comment">// 设置上下文中的 future 为 null</span></span><br><span class="line">       RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">// 返回一个空的 RpcResult</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">      &#125; </span><br><span class="line">                                                </span><br><span class="line">   <span class="comment">// 异步有返回值</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) &#123;</span><br><span class="line">      <span class="comment">// 发送请求，获得 ResponseFuture 实例</span></span><br><span class="line">      ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">      <span class="comment">// 设置 future 到上下文中</span></span><br><span class="line">      RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">      <span class="comment">// 暂时返回一个空结果</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">      &#125; </span><br><span class="line">                                                </span><br><span class="line">   <span class="comment">// 同步调用</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">     RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">// 发送请求，得到一个 ResponseFuture 实例，并调用该实例的 get 方法进行等待</span></span><br><span class="line">     <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>看到上面的代码后，是不是已经有了结论。关键点在消费方调用后会得到一个 ResponseFuture 对象，该对象在前文已经详细介绍过了。同步调用时，业务线程直接执行 ResponseFuture.get() 方法阻塞等待结果返回，一般消费方会定义超时时间（没有定义则使用默认超时时间）。当服务提供方返回结果后，通过执行 received() 方法将结果设置到 ResponseFuture 中，并唤醒阻塞等待的业务线程。如果超过最大等待时间结果还未返回，则业务线程会抛出异常。</p>
<h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><p>Dubbo 默认使用的是同步调用，如果要使用异步调用需要消费方自行配置。Dubbo 的异步调用和同步调用类似，区别在于业务线程获取调用结果的时机是可控的。业务线程发起调用后并没有立即获取调用结果，而是将 ResponseFuture 保存到了 Dubbo 的上线文中，然后继续向下执行其它逻辑，当需要调用结果时可以随时从上下文中取出 ResponseFuture 并执行 get() 方法来获取。</p>
<h2 id="转化流程图"><a href="#转化流程图" class="headerlink" title="转化流程图"></a>转化流程图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-process-conversion.jpg" alt></p>
<p>上图简单描述了 Dubbo 异步转同步的过程，包括了同步调用和异步调用。需要注意的是，图中设置响应结果是 HeaderExchangeHandler 处理的，其实还有一种处理响应结果的方式，也是前文已经说明的，通过定时任务扫描调用超时的请求以及时响应结果，如果是同步调用则可以尽可能减少业务线程阻塞等待的时间。</p>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>Exchange 层的客户端继承关系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-client-hierarchy.jpg" alt></p>
<h2 id="ExchangeClient"><a href="#ExchangeClient" class="headerlink" title="ExchangeClient"></a>ExchangeClient</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExchangeClient</span> <span class="keyword">extends</span> <span class="title">Client</span>, <span class="title">ExchangeChannel</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Exchange 层定义的 Client 接口是个空接口，没有定义任何方法，只是继承了最基本的 Client 和 ExchangeChannel 接口，目前只是充当标记接口角色。为什么说 Client 和 ExchangeChannel 是最基本的接口呢？从 Client 的角度看，Client 接口标识是客户端，这个很好理解。但是继承 ExchangeChannel 接口的目的是什么呢？ 这是因为 ExchangeClient 要使用 ExchangeChannel 来发送消息，因此 ExchangeClient 实例内部会封装一个 ExchangeChannel 实例，基于面向接口开发原则继承 ExchangeChannel 远比自定义发送消息接口要优雅得多。不仅 Exchange 层这样设计，Transport 层的 Client 也是同样的设计方式。 </p>
<p>下面我们看 ExchangeClient 的实现类 HeaderExchangeClient 。</p>
<h2 id="HeaderExchangeClient"><a href="#HeaderExchangeClient" class="headerlink" title="HeaderExchangeClient"></a>HeaderExchangeClient</h2><p>实现了 ExchangeClient 接口，并且间接实现了 ExchangeChannel 和 Client 接口。<strong>HeaderExchangeClient 是 Client 的装饰器，主要为装饰的 Client 添加以下功能：</strong></p>
<ol>
<li>通过定时发送心跳消息来维持与 Server 的长连接状态。</li>
<li>通过定时检查连接状态来实现断线重连功能。</li>
</ol>
<h3 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeClient</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时任务线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor scheduled = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">2</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-remoting-client-heartbeat"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transport 层的 Client 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Client client;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信息交换通道，Client 和 Server 建立的连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeChannel channel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时任务Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; heartbeatTimer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span><br></pre></td></tr></table></figure>

<p><strong>HeaderExchangeClient 中的属性字段说明如下：</strong></p>
<ol>
<li>client ：被装饰的 Client 对象，HeaderExchangeClient 中对 Client 接口的实现都会委托给这个被装饰的对象处理。</li>
<li>channel ：HeaderExchangeClient 中对 ExchangeChannel 接口的实现，都会委托给该对象进行处理。</li>
<li>scheduled ：用于定时 发送心跳消息以维持和 Server 的长连接状态和检查连接状态以实现断线重连功能。</li>
<li>heartbeat 和 heartbeatTimeout ：作为心跳相关的时间属性，以此为依据判断是否要发送心跳和重连。</li>
</ol>
<p>上述属性会在 HeaderExchangeClient 构造方法中完成初始化。</p>
<h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> client        Transport 层的 Client 实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> needHeartbeat 是否开启心跳任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeClient</span><span class="params">(Client client, <span class="keyword">boolean</span> needHeartbeat)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"client == null"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 client 属性</span></span><br><span class="line">      <span class="keyword">this</span>.client = client;</span><br><span class="line">      <span class="comment">// 创建 HeaderExchangeChannel 对象，对 Transport层的Client进行装饰</span></span><br><span class="line">      <span class="keyword">this</span>.channel = <span class="keyword">new</span> HeaderExchangeChannel(client);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取 Dubbo 版本</span></span><br><span class="line">      String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 读取心跳相关的配置,默认开启心跳机制</span></span><br><span class="line">      <span class="keyword">this</span>.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != <span class="keyword">null</span> &amp;&amp; dubbo.startsWith(<span class="string">"1.0."</span>) ? Constants.DEFAULT_HEARTBEAT : <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">this</span>.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 避免心跳间隔太短</span></span><br><span class="line">      <span class="keyword">if</span> (heartbeatTimeout &lt; heartbeat * <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"heartbeatTimeout &lt; heartbeatInterval * 2"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否启动心跳</span></span><br><span class="line">      <span class="keyword">if</span> (needHeartbeat) &#123;</span><br><span class="line">          <span class="comment">// 启动心跳定时任务</span></span><br><span class="line">          startHeartbeatTimer();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>构造方法的第一个参数是 Transport 层的 Client 对象，如 NettyClient 对象，第二参数表示是否开启心跳任务，由前文知该参数在 HeaderExchanger.connect() 方法中传入的是 true，即表示开启客户端侧的心跳定时任务。下面我们重点分析该心跳逻辑。</p>
<h3 id="开启心跳定时任务"><a href="#开启心跳定时任务" class="headerlink" title="开启心跳定时任务"></a>开启心跳定时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 开启心跳定时任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeartbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 开启一个新的心跳定时任务时，需要停止原有的定时任务</span></span><br><span class="line">      stopHeartbeatTimer();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开启新的定时任务</span></span><br><span class="line">      <span class="keyword">if</span> (heartbeat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          heartbeatTimer = scheduled.scheduleWithFixedDelay(</span><br><span class="line">                  <span class="comment">/**</span></span><br><span class="line"><span class="comment">                   * 创建心跳任务</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  <span class="keyword">new</span> HeartBeatTask(<span class="keyword">new</span> HeartBeatTask.ChannelProvider() &#123;</span><br><span class="line">                      <span class="comment">/**</span></span><br><span class="line"><span class="comment">                       * 每个客户端端侧只有一个通道，这里是 HeaderExchangeClient 对象自己</span></span><br><span class="line"><span class="comment">                       * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      <span class="meta">@Override</span></span><br><span class="line">                      <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                          <span class="keyword">return</span> Collections.&lt;Channel&gt;singletonList(HeaderExchangeClient.<span class="keyword">this</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;, heartbeat, heartbeatTimeout),</span><br><span class="line">                  heartbeat, heartbeat, TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>开启心跳定时任务比较简单，主要是创建一个心跳任务 HeartBeatTask 并传入其构造方法所需的参数，Channel(这里是 HeaderExchangeClient 对象)、心跳间隔 heartbeat 和 心跳超时时间 heartbeatTimeout，最后将创建的心跳任务交给定时任务线程池处理。可以看出，不管是心跳检测还是断线重连，核心点是 HeartBeatTask 任务。</p>
<p>关于该任务我们待会详细分析，现在回到 HeaderExchangeClient 类中来。停止心跳定时任务比较简单就不再介绍。下面对剩余的方法分类说明。</p>
<h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeClient</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------ ExchangeChannel 接口方法的实现 -------------------/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel.request(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel.request(request, timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeHandler <span class="title">getExchangeHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel.getExchangeHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ExchangeChannel 对 Endpoint 的 close(int timeout) 方法的重写，HeaderExchangeClient 对其进行实现。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Mark the client into the closure process</span></span><br><span class="line">        startClose(); <span class="comment">// 将 closing 字段设置为true</span></span><br><span class="line">        doClose(); <span class="comment">// 关闭心跳定时任务</span></span><br><span class="line">        channel.close(timeout); <span class="comment">// 关闭 HeaderExchangeChannel</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------- Endpoint 接口方法的实现 ----------------------/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel.getUrl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取底层Channel关联的ChannelHandler。 Channel接口继承Endpoint接口是有原因的哟。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">getChannelHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel.getChannelHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Channel接口继承Endpoint接口是有原因的哟。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">getLocalAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel.getLocalAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        channel.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        channel.send(message, sent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel.isClosed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doClose();</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        channel.startClose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------- Channel 接口方法的实现 -------------------------/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">getRemoteAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel.getRemoteAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel.isConnected();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel.getAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        channel.setAttribute(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        channel.removeAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel.hasAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------- Client 接口方法的实现 ---------------------------/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reconnect</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        client.reconnect();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对 HeaderExchangeClient 中的其它方法做了简单的分类，分类不是目的，目的是想说明一个现象。<strong>Client</strong> 和 <strong>Server</strong> 都是具有语义的端点，两者之间的 TCP 连接抽象为 <strong>Channel</strong>，端点一般不进行数据传输动作，进行数据传输的动作都是由端点的通道执行的，我们会看到端点有实现数据传输的接口方法，但是具体的动作还是交给了其通道执行。通过上面的代码我们也可以看出，被装饰的Client对象只处理了重连动作，这是端点的动作。其它的方法都是交给了被装饰的 ExchangeChannel 对象。</p>
<h1 id="心跳任务"><a href="#心跳任务" class="headerlink" title="心跳任务"></a>心跳任务</h1><p>HeartBeatTask 实现了 Runnable 接口，该任务主要进行心跳检测和断线重连。</p>
<h2 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HeartBeatTask<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于获取需要心跳检测的通道数组的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ChannelProvider channelProvider;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳间隔，单位： 毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳超时时间，单位：毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取通道助手内部接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取需要心跳检测的 Channel，Channel 是双向通信的即不仅仅支持客户端连接服务端，还支持服务端发送数据包给客户端</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> provider         通道助手对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heartbeat        心跳间隔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heartbeatTimeout 心跳超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HeartBeatTask(ChannelProvider provider, <span class="keyword">int</span> heartbeat, <span class="keyword">int</span> heartbeatTimeout) &#123;</span><br><span class="line">        <span class="keyword">this</span>.channelProvider = provider;</span><br><span class="line">        <span class="keyword">this</span>.heartbeat = heartbeat;</span><br><span class="line">        <span class="keyword">this</span>.heartbeatTimeout = heartbeatTimeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>心跳任务有三个核心属性，其中 ChannelProvider 接口是内部接口，供客户端侧和服务端侧实现，以分别获取客户端的通道 Channel 和服务端的通道 Channel 集合。</p>
<h2 id="任务逻辑"><a href="#任务逻辑" class="headerlink" title="任务逻辑"></a>任务逻辑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//从ChannelProvider中获取到需要心跳检测的channel</span></span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channelProvider.getChannels()) &#123;</span><br><span class="line">            <span class="comment">// 通道关闭则不需要检测</span></span><br><span class="line">            <span class="keyword">if</span> (channel.isClosed()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从待处理检测的Channel的附加属性中获取最后一次读、写时间</span></span><br><span class="line">                Long lastRead = (Long) channel.getAttribute(HeaderExchangeHandler.KEY_READ_TIMESTAMP);</span><br><span class="line">                Long lastWrite = (Long) channel.getAttribute(HeaderExchangeHandler.KEY_WRITE_TIMESTAMP);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 最后一次读/写时间超过心跳间隔，就会发送心跳请求</span></span><br><span class="line">                <span class="keyword">if</span> ((lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeat) || (lastWrite != <span class="keyword">null</span> &amp;&amp; now - lastWrite &gt; heartbeat)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 创建心跳请求对象</span></span><br><span class="line">                    Request req = <span class="keyword">new</span> Request();</span><br><span class="line">                    req.setVersion(Version.getProtocolVersion());</span><br><span class="line">                    <span class="comment">// 需要响应</span></span><br><span class="line">                    req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="comment">// 是心跳事件</span></span><br><span class="line">                    req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">                    <span class="comment">// 发送心跳请求</span></span><br><span class="line">                    channel.send(req);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Send heartbeat to remote channel "</span> + channel.getRemoteAddress()</span><br><span class="line">                                + <span class="string">", cause: The channel has no data-transmission exceeds a heartbeat period: "</span> + heartbeat + <span class="string">"ms"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 最后一次读时间超过心跳超时时间（3 * 心跳时间），则客户端重新连接服务端；服务端直接关闭客户端连接。</span></span><br><span class="line">                <span class="keyword">if</span> (lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeatTimeout) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Close channel "</span> + channel</span><br><span class="line">                            + <span class="string">", because heartbeat read idle time out: "</span> + heartbeatTimeout + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 客户端的通道，则重新连接服务端</span></span><br><span class="line">                    <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> Client) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            ((Client) channel).reconnect();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="comment">//do nothing</span></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 服务端通道，则关闭客户端连接</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Exception when heartbeat to remote channel "</span> + channel.getRemoteAddress(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Unhandled exception when heartbeat, cause: "</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>心跳任务主要工作如下：</strong></p>
<ol>
<li>从ChannelProvider中获取不同侧的通道 Channel，客户端侧只有一个 Channel（连接 Server），服务端侧有多个 Channel (接收多个 Client 连接)，任务只针对未关闭的 Channel 。</li>
<li>从待处理的Channel附加属性中获取最后一次读、写时间，然后计算距离当前的时间，如果大于心跳间隔就会发送一个心跳请求给对端，因为这里既可能是客户端侧通道也可能是服务端侧通道。</li>
<li>根据最后一次读时间，计算距离当前的时间是否大于心跳超时时间，如果大于心跳超时时间，客户端侧会进行重连服务端，服务端侧会立即关闭通道。客户端重连没啥说的，服务端关闭通道后下次客户端重新连接即可。</li>
</ol>
<p>其中<strong>第 2 个工作是心跳检测</strong>，<strong>第 3 个工作是断线重连</strong>。值得说明的是，<strong>Channel 附加属性中的读写时间主要是心跳处理器 HeartbeatHandler 记录的</strong>，其 <strong>connected() 记录最后一次读写操作时间</strong>、<strong>sent() 记录最后一次写操作时间</strong>、<strong>received() 记录最后一次读操作时间</strong>，<strong>而 disconnected() 会清理通道 Channel 中的读写时间戳</strong> 。</p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>Exchange 层的服务继承关系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-server-hierarchy.jpg" alt></p>
<p>上图中的 Endpoint、Server 和 Resetable 这三个接口在前面的文章中已经详细介绍过了，这里不再重复，下面对 Exchange 层定义的 Server 进行详细说明。</p>
<h2 id="ExchangeServer-接口"><a href="#ExchangeServer-接口" class="headerlink" title="ExchangeServer 接口"></a>ExchangeServer 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExchangeServer</span> <span class="keyword">extends</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得信息交换通道集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channels</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Collection&lt;ExchangeChannel&gt; <span class="title">getExchangeChannels</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据地址获取信息交换通道</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ExchangeChannel <span class="title">getExchangeChannel</span><span class="params">(InetSocketAddress remoteAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExchangeServer 继承了 Server 接口，在其基础之上新增了两个和信息交换层相关的通道方法。</p>
<h2 id="HeaderExchangeServer"><a href="#HeaderExchangeServer" class="headerlink" title="HeaderExchangeServer"></a>HeaderExchangeServer</h2><p>HeaderExchangeServer 实现了 ExchangeServer 接口，基于消息头的信息交换服务实现类，是 Transport 层 Server 的装饰器，实现自 Server 接口的方法（包括 Server 继承的接口）几乎都是委托给装饰的 Server 对象。<strong>HeaderExchangeServer 主要为其修饰的 Server 添加了定时发送心跳消息的实现，用以关闭长时间没有客户端连接的通道</strong>。</p>
<h3 id="属性-7"><a href="#属性-7" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeServer</span> <span class="keyword">implements</span> <span class="title">ExchangeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳检测 Schedule</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-remoting-server-heartbeat"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被装饰的 Transport 层的服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Server server;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳检测定时器 Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; heartbeatTimer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳间隔时间，毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳超时时间，毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否关闭，默认非关闭状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean closed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键属性 Server、heartbeat 以及 heartbeatTimeout 是在 HeaderExchangeServer 构造方法中完成初始化的。</p>
<h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 构造方法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> server Transport 层的 Server 对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeServer</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"server == null"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// HeaderExchangeServer 的工作都会委托给该对象</span></span><br><span class="line">     <span class="keyword">this</span>.server = server;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 在此之前 Constants.HEARTBEAT_KEY 默认已经有值了， 如果手动配置就使用配置的，如果没有配置默认是 60</span></span><br><span class="line">     <span class="keyword">this</span>.heartbeat = server.getUrl().getParameter(Constants.HEARTBEAT_KEY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// heartbeatTimeout：默认是 heartbeat * 3</span></span><br><span class="line">     <span class="keyword">this</span>.heartbeatTimeout = server.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class="number">3</span>);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 检测心跳超时时间是否合法</span></span><br><span class="line">     <span class="keyword">if</span> (heartbeatTimeout &lt; heartbeat * <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"heartbeatTimeout &lt; heartbeatInterval * 2"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 默认在 heartbeat（默认是60s）内如果没有收到消息，就会发送心跳消息，如果连着3次（默认180s）没有收到心跳响应，provider会关闭 Channel 。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     startHeartbeatTimer();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法主要的工作如下：</strong></p>
<ol>
<li>封装 Transport 层的 Server 对象，此后 HeaderExchangeServer 的服务工作都会交给该对象。</li>
<li>读取心跳相关配置，注意心跳间隔和心跳超时时间的关系，以及各自的默认值</li>
<li>启动心跳检测 Schedule</li>
</ol>
<h3 id="发送消息-2"><a href="#发送消息-2" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeServer</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closed.get()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">"Failed to send message "</span> + message + <span class="string">", cause: The server "</span> + getLocalAddress() + <span class="string">" is closed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        server.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closed.get()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">"Failed to send message "</span> + message + <span class="string">", cause: The server "</span> + getLocalAddress() + <span class="string">" is closed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        server.send(message, sent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送消息是交给装饰的 server 来完成，底层还是利用 Channel 来发送。</strong></p>
<h3 id="开启心跳定时任务-1"><a href="#开启心跳定时任务-1" class="headerlink" title="开启心跳定时任务"></a>开启心跳定时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeServer</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeartbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 关闭原有定时任务</span></span><br><span class="line">        stopHeartbeatTimer();</span><br><span class="line">        <span class="comment">// 发起新的定时任务</span></span><br><span class="line">        <span class="keyword">if</span> (heartbeat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            heartbeatTimer = scheduled.scheduleWithFixedDelay(</span><br><span class="line">                    <span class="keyword">new</span> HeartBeatTask(<span class="keyword">new</span> HeartBeatTask.ChannelProvider() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                             * 获取NettyServer中的全部channel连接，Server 持有多个Client 连接的 Channel</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">return</span> Collections.unmodifiableCollection(HeaderExchangeServer.<span class="keyword">this</span>.getChannels());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, heartbeat, heartbeatTimeout),</span><br><span class="line">                    heartbeat, heartbeat, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>开启心跳定时任务和 HeaderExchangeClient 中的逻辑一样，区别在 HeaderExchangeServer 可以持有多个连接，获取连接代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeServer</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Collection) getExchangeChannels();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取NettyServer中的全部channel连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ExchangeChannel&gt; <span class="title">getExchangeChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;ExchangeChannel&gt; exchangeChannels = <span class="keyword">new</span> ArrayList&lt;ExchangeChannel&gt;();</span><br><span class="line">        <span class="comment">// 获取 server 维护的 Channel 通道集合</span></span><br><span class="line">        Collection&lt;Channel&gt; channels = server.getChannels();</span><br><span class="line">        <span class="keyword">if</span> (channels != <span class="keyword">null</span> &amp;&amp; !channels.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">                <span class="comment">// 根据 Channel 获取 Exchange 层的 Channel</span></span><br><span class="line">                exchangeChannels.add(HeaderExchangeChannel.getOrAddChannel(channel));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exchangeChannels;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>关于心跳任务已经在前文中详细说明，这里不再重复介绍。</p>
<h3 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeServer</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将装饰的server的closing设置为 true，表示当前server处于正在关闭状态，不再与Client建立连接</span></span><br><span class="line">        startClose();</span><br><span class="line">        <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> max = timeout;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送 READONLY 事件给所有 Client ，表示Server不再接收新的消息</span></span><br><span class="line">            <span class="keyword">if</span> (getUrl().getParameter(Constants.CHANNEL_SEND_READONLYEVENT_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="comment">// 广播客户端，READONLY_EVENT 事件消息</span></span><br><span class="line">                sendChannelReadOnlyEvent();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待 Client 与 当前Server 维持的长连接全部断开或超时</span></span><br><span class="line">            <span class="keyword">while</span> (HeaderExchangeServer.<span class="keyword">this</span>.isRunning() &amp;&amp; System.currentTimeMillis() - start &lt; max) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    logger.warn(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭心跳定时任务，且将自身closed设置为true</span></span><br><span class="line">        doClose();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭Transport层的Server</span></span><br><span class="line">        server.close(timeout);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务关闭流程非常重要，下面对 HeaderExchangeServer 优雅关闭的过程进行详细说明：</strong></p>
<ol>
<li>调用 startClose() 方法将被装饰的 Server 的 closing 设置为 true，表示该 Server 端处于正在关闭状态不再与 Client 建立连接。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeServer </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        server.startClose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+--- AbstractServer</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 Server 处于正在关闭状态或关闭状态，则不再接收新连接</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isClosing() || <span class="keyword">this</span>.isClosed()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Close new channel "</span> + ch + <span class="string">", cause: server is closing or has been closed. For example, receive a new connect request while in shutdown process."</span>);</span><br><span class="line">            <span class="comment">// 关闭新建的 Client</span></span><br><span class="line">            ch.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>发送 READONLY 事件给所有 Client ，表示 Server 不再接收新的消息，避免有新的消息发送过来。在收到该消息后，Client 端的 HeaderExchangeHandler 会在 Channel 上添加 key 为 <strong>channel.readonly</strong> 的附加信息，上层调用方会根据该附加信息判断该连接是否可写。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeServer</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendChannelReadOnlyEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 READONLY_EVENT 请求</span></span><br><span class="line">        Request request = <span class="keyword">new</span> Request();</span><br><span class="line">        request.setEvent(Request.READONLY_EVENT);</span><br><span class="line">        <span class="comment">// 只读请求不需要响应</span></span><br><span class="line">        request.setTwoWay(<span class="keyword">false</span>);</span><br><span class="line">        request.setVersion(Version.getProtocolVersion());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送给所有 Client</span></span><br><span class="line">        Collection&lt;Channel&gt; channels = getChannels();</span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (channel.isConnected()) &#123;</span><br><span class="line">                    channel.send(request, getUrl().getParameter(Constants.CHANNEL_READONLYEVENT_SENT_KEY, <span class="keyword">true</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"send cannot write message error."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+--- DubboInvoker</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接是否有效，Server 具有一票否决权</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ExchangeClient client : clients) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 即使Client处于连接中，但如果 Server 处于正在关闭中，连接也是不可用的。[channel.readonly 的附加信息的作用在这里]</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * &#123;<span class="doctag">@link</span> HeaderExchangeServer#sendChannelReadOnlyEvent()&#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (client.isConnected() &amp;&amp; !client.hasAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY)) &#123;</span><br><span class="line">                <span class="comment">//cannot write == not Available ?</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>第 2 步完成后，等待所有的 Client 与 当前 Server 维持的长连接断开或超时。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-- com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeServer#isRunning</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;Channel&gt; channels = getChannels();</span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">            <span class="comment">// 存在任意一个Client与当前Server处于连接状态，Server 都不能不关闭</span></span><br><span class="line">            <span class="keyword">if</span> (channel.isConnected()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>第 3 步完成后，调用 doClose() 方法关闭心跳定时任务，且将 closed 字段更新为 true。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stopHeartbeatTimer();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        scheduled.shutdown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>真正关闭服务器即Transport层的Server ，如使用 Netty 作为 NIO 组件，关闭的就是 NettyServer 。<ul>
<li>NettyServer.close() 方法会先调用 AbstractPeer 的 close() 方法将自身的 closed 字段设置为 true。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">           logger.info(<span class="string">"Close "</span> + getClass().getSimpleName() + <span class="string">" bind "</span> + getBindAddress() + <span class="string">", export "</span> + getLocalAddress());</span><br><span class="line">       &#125;</span><br><span class="line">       ExecutorUtil.shutdownNow(executor, <span class="number">100</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 设置父类中的 closed 字段为true</span></span><br><span class="line">           <span class="keyword">super</span>.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           logger.warn(e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 调用子类实现，关闭具体服务</span></span><br><span class="line">           doClose();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           logger.warn(e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>调用 doClose() 方法关闭 boss Channel 即接收客户端连接的 Channel；关闭与 Client 之间的连接并清理 channels 集合；最后，关闭 bossGroup 和 workerGroup 两个线程组。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 关闭服务器通道</span></span><br><span class="line">            channel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.warn(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭连接到服务器的客户端通道</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Collection&lt;com.alibaba.dubbo.remoting.Channel&gt; channels = getChannels();</span><br><span class="line">        <span class="keyword">if</span> (channels != <span class="keyword">null</span> &amp;&amp; channels.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 依次遍历连接到服务器的客户端通道，然后进行关闭操作</span></span><br><span class="line">            <span class="keyword">for</span> (com.alibaba.dubbo.remoting.Channel channel : channels) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    logger.warn(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.warn(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 优雅关闭线程组</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bootstrap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.warn(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 清空连接到服务器的客户端通道</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channels != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channels.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.warn(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p>HeaderExchangeServer 中的其它方法不是很重要就不一一介绍了，至此 Exchange 层的服务实现部分介绍完毕了，<strong>魔鬼存在于细节之中</strong>。</p>
<h1 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h1><p>Exchange 层编解码器继承关系如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-codec-hierarchy.jpg" alt></p>
<p>TransportCodec 及上层编解码器已经在 Transport 层详细说明，TelnetCodec 继承了 TransportCodec 序列化和反序列化的基本能力，同时还提供了对 Telnet 命令处理的能力。而 ExchangeCodec 是在 TelnetCodec 的基础之上添加了处理协议头的能力。考虑到编解码器在 Dubbo 协议的网络传输中扮演着重要角色，并且逻辑相对比较复杂，因此会单独起一篇文章对整个编解码器体系进行详细分析，这里先不进行展开说明，我们下一篇文章见。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章开篇对 Exchange 层产生的背景进行了简单说明，随后从 Exchange 层的核心模型 Request 和 Response 出发，然后以 Exchanger 接口及其实现为中心引出 Exchange 层的核心组件，先是对 Exchange 层的 Channel 进行说明，同时对其关联的 ResponseFuture 进行了分析，它是实现 Dubbo 调用方式转换的关键。接着对 Exchange 层的 ChannelHandler 进行了深入分析，HeartbeatHandler 和心跳任务 HeartBeatTask 是对心跳检测和断线重连的处理，HeaderExchangeHandler 结合 DefaultFuture 对请求-响应统一处理，ExchangeHandler 是 Exchange 层定义的供上层使用的信息交换处理器。最后对 Exchange 层的 Client 和 Server 进行了说明。文章最后，对 Exchange 层的编解码器进行了简单介绍。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/26722deb/" title="Dubbo源码分析 - 信息交换层" target="_blank" rel="external">https://gentryhuang.com/posts/26722deb/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/61d79ae/" title="Dubbo源码分析 - 编解码器"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/f3cd85ef/" title="Dubbo源码分析 - 线程池"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2022 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>