<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>并发 - LongAdder | gentryhuang的博客</title>
  <meta name="description" content="前言并发场景下通常会使用 AtomicLong 原子类进行计数等操作，在 JDK1.8 中提供了 LongAdder 来实现类似功能。相对于 AtomicLong ，LongAdder 有着更高的性能，可以完全替代 AtomicLong 的计数操作。 下面我们先对 AtomicLong 简单介绍，然后重点分析 LongAdder 的实现。 AtomicLongAtomicLong 相关的类图如下：">
<meta property="og:type" content="article">
<meta property="og:title" content="并发 - LongAdder">
<meta property="og:url" content="https://gentryhuang.com/posts/282602b0/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="前言并发场景下通常会使用 AtomicLong 原子类进行计数等操作，在 JDK1.8 中提供了 LongAdder 来实现类似功能。相对于 AtomicLong ，LongAdder 有着更高的性能，可以完全替代 AtomicLong 的计数操作。 下面我们先对 AtomicLong 简单介绍，然后重点分析 LongAdder 的实现。 AtomicLongAtomicLong 相关的类图如下：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/longadder/long-adder-3.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/longadder/long-adder-1.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/longadder/long-adder-2.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/longadder/long-adder-4.png">
<meta property="article:published_time" content="2022-05-30T02:25:18.000Z">
<meta property="article:modified_time" content="2022-06-02T01:44:00.044Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="LongAdder">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/longadder/long-adder-3.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/282602b0/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.png" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.5px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.75px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.13px;">I/O</a> <a href="/tags/JMM/" style="font-size: 13px;">JMM</a> <a href="/tags/JUC/" style="font-size: 13.75px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.25px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.13px;">Lock</a> <a href="/tags/LongAdder/" style="font-size: 13px;">LongAdder</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.25px;">Protocol</a> <a href="/tags/Queue/" style="font-size: 13.38px;">Queue</a> <a href="/tags/RPC/" style="font-size: 13.63px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13.38px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.13px;">Redis数据结构</a> <a href="/tags/SCAN/" style="font-size: 13px;">SCAN</a> <a href="/tags/SPI/" style="font-size: 13.25px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.25px;">Spring</a> <a href="/tags/Thread/" style="font-size: 13.13px;">Thread</a> <a href="/tags/Zookeeper/" style="font-size: 13.13px;">Zookeeper</a> <a href="/tags/cahce/" style="font-size: 13px;">cahce</a> <a href="/tags/false-sharing/" style="font-size: 13px;">false sharing</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 13px;">分布式锁</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.88px;">设计模式</a> <a href="/tags/%E9%99%90%E6%B5%81/" style="font-size: 13px;">限流</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/c1861d8c/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/c1861d8c/" class="title">Redis原理 - SCAN 原理</a>
              </p>
              <p class="item-date">
                <time datetime="2022-06-26T13:14:47.000Z" itemprop="datePublished">2022-06-26</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/db98efcf/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/db98efcf/" class="title">队列 - DelayQueue</a>
              </p>
              <p class="item-date">
                <time datetime="2022-06-15T12:10:53.000Z" itemprop="datePublished">2022-06-15</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/282602b0/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/282602b0/" class="title">并发 - LongAdder</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-30T02:25:18.000Z" itemprop="datePublished">2022-05-30</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/218dc61f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/218dc61f/" class="title">并发 - ConcurrentHashMap</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-14T02:30:35.000Z" itemprop="datePublished">2022-05-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/9012be3f/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/9012be3f/" class="title">并发 - ScheduledThreadPoolExecutor</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-02T01:55:06.000Z" itemprop="datePublished">2022-05-02</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AtomicLong"><span class="toc-number">2.</span> <span class="toc-text">AtomicLong</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LongAdder"><span class="toc-number">3.</span> <span class="toc-text">LongAdder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析"><span class="toc-number">3.1.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性"><span class="toc-number">3.1.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计数单元"><span class="toc-number">3.1.2.</span> <span class="toc-text">计数单元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计数方法"><span class="toc-number">3.1.3.</span> <span class="toc-text">计数方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#longAccumulate"><span class="toc-number">3.1.4.</span> <span class="toc-text">longAccumulate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sum-方法"><span class="toc-number">3.1.5.</span> <span class="toc-text">sum() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LongAdder-小结"><span class="toc-number">3.1.6.</span> <span class="toc-text">LongAdder 小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-concurrent/LongAdder" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      并发 - LongAdder
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/282602b0/" class="article-date">
	  <time datetime="2022-05-30T02:25:18.000Z" itemprop="datePublished">2022-05-30</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/JDK/">JDK</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/LongAdder/" rel="tag">LongAdder</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/282602b0/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 4.3k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 17(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>并发场景下通常会使用 <code>AtomicLong</code> 原子类进行计数等操作，在 JDK1.8 中提供了 <code>LongAdder</code> 来实现类似功能。相对于 <code>AtomicLong</code> ，<code>LongAdder</code> 有着更高的性能，可以完全替代 <code>AtomicLong</code> 的计数操作。</p>
<p>下面我们先对 <code>AtomicLong</code> 简单介绍，然后重点分析 <code>LongAdder</code> 的实现。</p>
<h2 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h2><p>AtomicLong 相关的类图如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/longadder/long-adder-3.png" alt></p>
<p>AtomicLong 关键的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// setup to use Unsafe.compareAndSwapLong for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicLong.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计计数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>) + <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AtomicLong 底层是使用 <code>Unsafe</code> 的 CAS 来实现的，当操作失败时会以自旋的方式重试，直到成功才会退出自旋。因此在高并发场景下，可能会有很多线程处于重试状态，导致性能下降。具体表现在源码中的部分如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--- Unsafe</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> var6;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var6 = <span class="keyword">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var6;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用 <code>AtomicLong</code> 进行计数操作时，多个线程竞争修改共享资源 <code>value</code> 值时是通过自旋来完成的。在高并发环境下，同一时刻只有一个线程可以 CAS 操作成功，其它线程都会 CAS 失败，从而会不断重试直到成功才会退出自旋，这就是对性能造成影响的原因。</p>
<h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><p>LongAdder 相关类图如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/longadder/long-adder-1.png" alt></p>
<p>LongAdder 本质上是<strong>使用空间换时间的思想</strong>来进行设计的，不过消耗的内存空间可以忽略不计。它维护了一个基础变量 <code>base</code> 作为基础计数器，在竞争比较小的情况下 CAS 操作该数据即可；为了应对竞争激烈的场景，它里面还维护了一组按需分配的计数单元数组 <code>Cell[]</code>，处理计数请求时，不同线程可以映射到不同的计算单元上进行计数，采用<strong>分而治之</strong>的思想减小了线程竞争，将操作单个共享资源的压力分摊到多个计算单元上，提高了并发度。</p>
<p>通过将请求计数压力分摊，LongAdder 可以提供比 AtomicLong 更好的性能。获取计数值时，只要将 <code>base</code> 与 <code>Cell[]</code> 数组中的计数单元累加即可。当然，在并发很低的情况，使用 AtomicLong 更简单直接一些，并且效率稍微高一些。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>LongAdder 源码整体实现如下图所示：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/longadder/long-adder-2.png" alt></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CPU 核数，用于限制 cells 数组的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算单位数组，大小是 2^n；</span></span><br><span class="line"><span class="comment">     * 核心思想是，每个线程会映射自己的 Cell 进行计数，从而减少竞争。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基础计算器，用于最初无竞争的情况下以及初始化计数单元失败的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 CAS 更新该值，标记当前是否有线程在创建或扩容 cells或创建 Cell行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，LongAdder 本身中没有相关属性，它是通过直接继承 Striped64 类中属性。以上四个属性已经详细注释，在对应的场景下再详细介绍。</p>
<h4 id="计数单元"><a href="#计数单元" class="headerlink" title="计数单元"></a>计数单元</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+--- Striped64</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计数属性，使用 volatile 修饰保证可见性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">        Cell(<span class="keyword">long</span> x) &#123;</span><br><span class="line">            value = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * CAS 更新计数值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> cmp 原始值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> val 新值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="comment">// Unsafe 实例</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="comment">// value 字段的偏移量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; ak = Cell<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                        (ak.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>计数单元 <code>Cell</code> 是 Striped64 的内部类，用于某个/某些线程处理计数请求的，也就是一个 <code>Cell</code> 可以对应多个线程。多个线程操作 <code>Cell</code> 数组的原理如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/longadder/long-adder-4.png" alt></p>
<p>通过定义一个 <code>volatile</code> 类型的 <code>value</code> 属性作为计数值，使用 Unsafe 的 CAS 来修改它的值。LongAdder 计数器的值就是所有 Cell 的值加上 base 的值。</p>
<p><strong>注意：</strong>该类使用了 <code>@sun.misc.Contended</code> 注解，这个注解的作用是用来解决伪共享问题的，关于伪共享可参考 <a href="https://gentryhuang.com/posts/88d55383/">「伪共享」</a>。</p>
<h4 id="计数方法"><a href="#计数方法" class="headerlink" title="计数方法"></a>计数方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdder</span> <span class="keyword">extends</span> <span class="title">Striped64</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7249069246863182397L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个初始和为零的新加法器。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongAdder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子累加 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子递减 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add(-<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，计数时无论是递增还是递减，都是调用了 <code>add()</code> 方法，它是计数的核心。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+--- LongAdder</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 累加给定的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x the value to add</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 cells 不为空，说明出现过竞争，cells 已经创建</span></span><br><span class="line">        <span class="comment">// 2 CAS 操作基础计数器 base 失败，说明出现了竞争</span></span><br><span class="line">        <span class="comment">// PS: cells 数组为延迟加载，只有在 CAS 更新 base 失败的情况下才会初始化；即没有竞争时操作的是 base 值，发生竞争时 cells 才起作用</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// true 表示当前没有竞争；false 表示有竞争</span></span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 cells 为空，说明出现竞争，是由于 CAS 操作基础计数器 base 失败才执行到这里</span></span><br><span class="line">            <span class="comment">// 2 当前线程映射的 Cell 为空，说明当前线程还没有对应的 Cell，初始化一个 Cell</span></span><br><span class="line">            <span class="comment">// 3 更新当前线程映射的 Cell 失败，说明其它线程也映射到了这个 Cell，表明存在竞争</span></span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                    <span class="comment">// getProbe() 方法返回的是线程中的 threadLocalRandomProbe 字段，它是通过随机数生成的一个值，对于一个确定的线程，这个值是固定的</span></span><br><span class="line">                    (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                    !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line"></span><br><span class="line">                longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述方法的分支逻辑有点多，不过总体上是根据<strong>是否出现过竞争</strong>来处理的。下面我们进行详细分析：</p>
<ul>
<li><strong>没有出现竞争的情况：</strong>没有出现竞争就意味着 cells 数组为空，此时线程处理计数请求只需要 CAS 操作 base 值即可，操作成功直接结束；操作失败说明存在竞争，此时需要通过计数单元分摊计数请求，此时 <code>as == null</code> 成立，会进入到 <code>longAccumulate</code> 方法； </li>
<li><strong>出现过竞争的情况：</strong>已经出现过竞争就意味着 cells 数组已经存在，此时线程处理计算请求需要映射寻找对应的计数单元完成计数，也就不会操作 base 值了。此时会通过 <code>a = as[getProbe() &amp; m])</code> 来映射对应的计数单元，如果当前线程没有对应的计数单元，或者 CAS 操作计算单元失败「有冲突」，都会进入到 <code>longAccumulate</code> 方法。</li>
</ul>
<p>需要说明的是，线程在映射计数单元时，和 HashMap 中定位哈希桶一样的方式，只是这个 <code>hash</code> 值是线程相关的值。</p>
<p>关于以上两种情况的详细说明，已经在代码中详细注释，就不再展开说明。</p>
<h4 id="longAccumulate"><a href="#longAccumulate" class="headerlink" title="longAccumulate"></a>longAccumulate</h4><p>通过前文我们知道，进入 <code>longAccumulate</code> 方法的情况总得来说有两种，CAS 操作 base 值失败，需要初始化 <code>Cell</code> 计数单元数组；线程没有映射到计数单元或 CAS 操作计数单元失败。也就是该方法集<strong>计数单元数组初始化、创建新的计数单元、竞争更新、扩容计数数组</strong>操作于一体，总体比较复杂。下面我们将该方法分成<strong>已初始化计数单元数组</strong>和<strong>未初始化计数单元数组</strong>进行分析。</p>
<p><strong>已初始化计数单元数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">+--- Striped64</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x              the value 待更新的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fn             更新函数，或 null 用于添加（此约定避免了 LongAdder 中需要额外的字段或函数）。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wasUncontended 进入该方法前，是否 CAS 操作失败，也就是是否有竞争。true 表示没有竞争</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储线程的 probe 值</span></span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// 如果 getProbe() 方法返回 0 ，说明随机数未初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 强制初始化</span></span><br><span class="line">            ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">            <span class="comment">// 重新获取 probe 值</span></span><br><span class="line">            h = getProbe();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 都未初始化，肯定还不存在竞争的情况</span></span><br><span class="line">            wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否发生碰撞，即多个线程映射到同一个 Cell 元素</span></span><br><span class="line">        <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            Cell[] as;</span><br><span class="line">            Cell a;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">long</span> v;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cell 已经初始化过的情况</span></span><br><span class="line">            <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前线程映射的 Cell 为空，那么尝试创建一个 Cell</span></span><br><span class="line">                <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前无其它线程在创建或扩容 cells，也没有线程在创建 Cell</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                        <span class="comment">// 创建一个 Cell，值为当前需要增加的值</span></span><br><span class="line">                        Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 再次检测 cellsBusy 的状态，如果没有其它线程忙碌，那么当前线程 CAS 设置值为 1，相当于获取了锁</span></span><br><span class="line">                        <span class="comment">// spin lock</span></span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                            <span class="comment">// 标记是否创建成功</span></span><br><span class="line">                            <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                                Cell[] rs;</span><br><span class="line">                                <span class="keyword">int</span> m, j;</span><br><span class="line">                                <span class="comment">// 找到当前线程映射到 cells 数组中的位置</span></span><br><span class="line">                                <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                        (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                        rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 将创建的 Cell 放在 cells</span></span><br><span class="line">                                    rs[j] = r;</span><br><span class="line">                                    <span class="comment">// 标记成功</span></span><br><span class="line">                                    created = <span class="keyword">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                <span class="comment">// 相当于释放锁</span></span><br><span class="line">                                cellsBusy = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 创建成功后直接返回</span></span><br><span class="line">                            <span class="keyword">if</span> (created)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 创建不成功，下一轮循环重试</span></span><br><span class="line">                            <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前线程映射的位置为空，自然是没有发生碰撞</span></span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前线程映射的 Cell 不为空且更新失败了，表示有竞争。这里重置为 true ，重置线程的 probe 并自旋重试。</span></span><br><span class="line">                    <span class="comment">// 这里对应调用方法 add() 中的 Cell 冲突更新的情况，设置 wasUncontended 为 true </span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                    wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 执行到这里，至少进行了 1 轮重试</span></span><br><span class="line">                    <span class="comment">// 尝试 CAS 更新当前线程映射的 Cell 的值，如果成功返回即可；失败重置线程的 probe 继续重试。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                        fn.applyAsLong(v, x))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果 cells 数组的长度达到了 CPU 核心数，或者 cells 扩容了，那么重试即可，不进行扩容。</span></span><br><span class="line">                    <span class="comment">// 设置 collide 为 false ，重置线程的 probe 并自旋重试。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                    collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 执行到这里说明发生了碰撞，且竞争失败了，则设置 collide 为 true 表示发生碰撞竞争失败，然后进行自旋重试</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                    collide = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 只有重试一定次数后仍然失败才会扩容</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 检查是否有其它线程已经扩容过了</span></span><br><span class="line">                        <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 新数组大小是原来数组的两倍</span></span><br><span class="line">                            Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 把旧数组元素直接拷贝到新数组</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                                rs[i] = as[i];</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 设置 cells 为新数组</span></span><br><span class="line">                            cells = rs;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 释放资格</span></span><br><span class="line">                        cellsBusy = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 扩容成功后，重置 collide，解除冲突标志</span></span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 使用扩容后的新数组，重新尝试</span></span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新失败或者达到了CPU核心数，重新生成probe，并重试</span></span><br><span class="line">                h = advanceProbe(h);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 未初始化过 cells 数组，尝试获取资格并初始化 cells 数组</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">               <span class="comment">//... 省略</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述方法总体上还是比较复杂的，下面对主要的分支逻辑进行说明：</p>
<ol>
<li>当前线程映射的位置没有对应的计数单元 Cell，则创建 Cell 并加入到对应位置上。加入的过程使用 spin lock；</li>
<li>当前线程调用 add() 方法 CAS 操作映射的 Cell 失败，那么通过重置当前线程 probe 然后自旋重试。<strong>注意：</strong>此时不着急扩容 Cell 数组，这种情况下继续重试；</li>
<li>使用 CAS 尝试更新当前线程映射的 Cell 的值，执行到这里，至少已经经历过了第 2 步。更新成功则结束，更新失败则继续下一步判断；</li>
<li>CAS 尝试更新当前线程映射的 Cell 的值失败，说明多个线程映射到了同一个 Cell 导致冲突，按理说此时最好扩容，但实际上并没有扩容，而是判断 cells 数组的长度是否达到了 CPU 核心数，或者 cells 数组是否已经扩容了。针对这种情况，还是不着急扩容，继续自旋重试。这种情况是合理的，下文会重点分析下；</li>
<li>如果是发生碰撞竞争失败，即多个线程映射到了同一个 Cell 导致更新失败，那么解除碰撞标志，这种情况再给个机会重试下；</li>
<li>最多重试三次后仍然失败，那么就需要扩容 Cell 数组了。扩容的时候使用 CAS 抢占扩容资格 cellsBusy，抢占成功进行扩容；<strong>注意：</strong>扩容并没有完成计数操作，扩容完成后需要继续自旋完成计数，由于扩容了，自旋一次就能成功的可性能很大；</li>
</ol>
<p><strong>特别说明：</strong>如果 cells 数组的长度达到了 CPU 核心数就不会扩容了，即使竞争激烈。我么知道 cells 数组的大小是 2^n ，这就意味着 cells 数组最大只能达到 <code>&gt;=</code> NCPU 的最小2次方；比如服务器是 8 核的，那么 cells 数组的最大只会到 8 ，达到 8 就不会扩容了。因为同一个 CPU 核心同时只能运行一个线程，并发执行的时候，服务器同一时刻能运行的线程数是固定的。</p>
<p><strong>未初始化计数单元数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x              the value 待更新的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn             更新函数，或 null 用于添加（此约定避免了 LongAdder 中需要额外的字段或函数）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wasUncontended 进入该方法前，是否 CAS 操作失败，也就是是否有竞争。true 表示没有竞争</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储线程的 probe 值</span></span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 如果 getProbe() 方法返回 0 ，说明随机数未初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 强制初始化</span></span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">        <span class="comment">// 重新获取 probe 值</span></span><br><span class="line">        h = getProbe();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 都未初始化，肯定还不存在竞争的情况</span></span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否发生碰撞，即多个线程映射到同一个 Cell 元素</span></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        Cell[] as;</span><br><span class="line">        Cell a;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cell 已经初始化过的情况</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           </span><br><span class="line">         <span class="comment">//... 省略</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未初始化过 cells 数组，尝试获取资格并初始化 cells 数组</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="comment">// 标记初始化成功</span></span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="comment">// 检测是否有其它线程初始化过</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    <span class="comment">// 新建一个大小为 2 的 Cell 数组</span></span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到当前线程映射到的位置，并创建对应的 Cell</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将创建的数组赋值给 cells</span></span><br><span class="line">                    cells = rs;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 初始化成功</span></span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放资格</span></span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化成功直接返回，因为增加的值已经同时创建到Cell中了</span></span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果初始化 cells 数组有竞争，就尝试更新基础计数器 base，成功返回即可；失败重试；</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况比较简单，具体流程如上，代码中已经详细注释。需要说明的是，<strong>如果初始化的时候也有竞争，那么竞争失败的线程会尝试更新基础计数器 base，成功直接返回，失败了才会继续重试</strong>。</p>
<h4 id="sum-方法"><a href="#sum-方法" class="headerlink" title="sum() 方法"></a>sum() 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--- LongAdder</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cell[] as = cells; Cell a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始值为基础计数器的值</span></span><br><span class="line">        <span class="keyword">long</span> sum = base;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 cells 不为空，则统计每个计数单元中的值</span></span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回 sum</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>LongAdder 加法器的值包含两部分，将 <code>base</code> 和所有 <code>Cell</code> 的值相加就是结果。</p>
<p>这里需要注意，如果前面已经累加过的 <code>Cell</code> 的 <code>value</code> 有修改，那么就无法计算到了。由此看出，LongAdder 不是强一致性的。</p>
<h4 id="LongAdder-小结"><a href="#LongAdder-小结" class="headerlink" title="LongAdder 小结"></a>LongAdder 小结</h4><p>JDK 不仅提供了支持 long 类型计数器，也提供了 double 类型的 DoubleAdder 计数器，它们都继承了 <code>Striped64</code>，原理是类似的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>LongAdder 通过 <code>base</code> 和 <code>Cell</code> 数组来存储值。当没有竞争的情况下直接 CAS 操作 base 即可；当存在竞争时，采用<strong>分而治之</strong>思想将不同线程处理计数请求映射到不同的 Cell 上以增加并发度。</p>
<p>在并发较小时，使用 AtomicLong 更简单高效；在并发较大时，LongAdder 性能更高，随着扩容 Cell 数组，最终可以达到一种无竞争的状态。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/282602b0/" title="并发 - LongAdder" target="_blank" rel="external">https://gentryhuang.com/posts/282602b0/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/db98efcf/" title="队列 - DelayQueue"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/218dc61f/" title="并发 - ConcurrentHashMap"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2022 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>