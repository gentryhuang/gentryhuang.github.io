<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>集合 - HashMap | gentryhuang的博客</title>
  <meta name="description" content="前言HashMap 是基于哈希表实现的，外层是一个数组，数组中的每个元素封装了一个 key-value 及其他元数据信息，这些元数据信息是为了更好的管理数组中某个位置中的元素，如使用单链表或红黑树组织元素，元数据信息就是对应的指针等信息。对 HashMap 进行增、删、改、查都需要经历两个必须的步骤，先计算 key 的 hash 值，接着根据 hash 值计算出当前键值对位于数组的哪个位置。Has">
<meta property="og:type" content="article">
<meta property="og:title" content="集合 - HashMap">
<meta property="og:url" content="https://gentryhuang.com/posts/8c0fc113/index.html">
<meta property="og:site_name" content="gentryhuang‘s blog">
<meta property="og:description" content="前言HashMap 是基于哈希表实现的，外层是一个数组，数组中的每个元素封装了一个 key-value 及其他元数据信息，这些元数据信息是为了更好的管理数组中某个位置中的元素，如使用单链表或红黑树组织元素，元数据信息就是对应的指针等信息。对 HashMap 进行增、删、改、查都需要经历两个必须的步骤，先计算 key 的 hash 值，接着根据 hash 值计算出当前键值对位于数组的哪个位置。Has">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-7-struct.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-1.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-2.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-3.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-4.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-5.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-6.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-8-struct.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-8-hash-process.png">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-1.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-2.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-3.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-4.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-5.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-6.jpg">
<meta property="og:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-7.jpg">
<meta property="article:published_time" content="2021-01-10T12:30:35.000Z">
<meta property="article:modified_time" content="2021-08-17T12:07:23.340Z">
<meta property="article:author" content="gentryhuang">
<meta property="article:tag" content="HashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-7-struct.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gentryhuang.com/posts/8c0fc113/index.html">
  
    <link rel="alternate" href="/atom.xml" title="gentryhuang‘s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gentryhuang.com" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Gentryhuang&#39;s Blog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      

<script defer="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">

            

            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">32</span></li></ul>
    </div>
  </div>


    
      
<!-- 这里使用 false 关闭右侧标签  -->






    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13.44px;">AQS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/CopyOnWrite/" style="font-size: 13px;">CopyOnWrite</a> <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/Filter/" style="font-size: 13.78px;">Filter</a> <a href="/tags/Gossip/" style="font-size: 13px;">Gossip</a> <a href="/tags/HashMap/" style="font-size: 13px;">HashMap</a> <a href="/tags/HashedWheelTimer/" style="font-size: 13px;">HashedWheelTimer</a> <a href="/tags/I-O/" style="font-size: 13.11px;">I/O</a> <a href="/tags/JMM/" style="font-size: 13px;">JMM</a> <a href="/tags/JUC/" style="font-size: 13.67px;">JUC</a> <a href="/tags/Javassist/" style="font-size: 13.22px;">Javassist</a> <a href="/tags/Lock/" style="font-size: 13.11px;">Lock</a> <a href="/tags/Mina/" style="font-size: 13px;">Mina</a> <a href="/tags/Netty/" style="font-size: 13px;">Netty</a> <a href="/tags/Protocol/" style="font-size: 13.22px;">Protocol</a> <a href="/tags/Queue/" style="font-size: 13.33px;">Queue</a> <a href="/tags/RPC/" style="font-size: 13.56px;">RPC</a> <a href="/tags/Raft/" style="font-size: 13px;">Raft</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.11px;">Redis数据结构</a> <a href="/tags/SCAN/" style="font-size: 13px;">SCAN</a> <a href="/tags/SPI/" style="font-size: 13.22px;">SPI</a> <a href="/tags/Spring/" style="font-size: 13.22px;">Spring</a> <a href="/tags/Thread/" style="font-size: 13.11px;">Thread</a> <a href="/tags/Zookeeper/" style="font-size: 13.11px;">Zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13px;">代理</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">共识算法</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 13px;">分布式锁</a> <a href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" style="font-size: 13px;">慢查询日志</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.89px;">设计模式</a> <a href="/tags/%E9%99%90%E6%B5%81/" style="font-size: 13px;">限流</a>
    </div>
  </div>

    
      <!-- 这里使用 false 关闭右侧归档  -->




    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/3c450cc6/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/posts/3c450cc6/" class="title">MySQL - 乐观锁和悲观锁</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-10T02:46:59.000Z" itemprop="datePublished">2022-04-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/e0c3e79e/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/posts/e0c3e79e/" class="title">MySQL - Double Write</a>
              </p>
              <p class="item-date">
                <time datetime="2022-03-09T08:25:44.000Z" itemprop="datePublished">2022-03-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/c1861d8c/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/posts/c1861d8c/" class="title">Redis原理 - SCAN 原理</a>
              </p>
              <p class="item-date">
                <time datetime="2022-03-01T14:14:47.000Z" itemprop="datePublished">2022-03-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/db98efcf/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/db98efcf/" class="title">队列 - DelayQueue</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-26T00:45:53.000Z" itemprop="datePublished">2022-02-26</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/62ea789a/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JDK/">JDK</a>
              </p>
              <p class="item-title">
                <a href="/posts/62ea789a/" class="title">队列 - PriorityQueue</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-12T03:38:34.000Z" itemprop="datePublished">2022-02-12</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK-7-HashMap"><span class="toc-number">2.</span> <span class="toc-text">JDK 7 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关键属性"><span class="toc-number">2.1.</span> <span class="toc-text">关键属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法"><span class="toc-number">2.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Put方法原理"><span class="toc-number">2.3.</span> <span class="toc-text">Put方法原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化数组"><span class="toc-number">2.3.1.</span> <span class="toc-text">初始化数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加节点到链表中"><span class="toc-number">2.3.2.</span> <span class="toc-text">添加节点到链表中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Get方法原理"><span class="toc-number">2.4.</span> <span class="toc-text">Get方法原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩容"><span class="toc-number">2.5.</span> <span class="toc-text">扩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表成环"><span class="toc-number">2.6.</span> <span class="toc-text">链表成环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK-8-HashMap"><span class="toc-number">3.</span> <span class="toc-text">JDK 8 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关键属性-1"><span class="toc-number">3.1.</span> <span class="toc-text">关键属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体"><span class="toc-number">3.2.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法-1"><span class="toc-number">3.3.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#确定桶位置"><span class="toc-number">3.4.</span> <span class="toc-text">确定桶位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash方法"><span class="toc-number">3.5.</span> <span class="toc-text">hash方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Get方法原理-1"><span class="toc-number">3.6.</span> <span class="toc-text">Get方法原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Put方法原理-1"><span class="toc-number">3.7.</span> <span class="toc-text">Put方法原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩容机制"><span class="toc-number">3.8.</span> <span class="toc-text">扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树化、链化与拆分"><span class="toc-number">3.9.</span> <span class="toc-text">树化、链化与拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#链表树化"><span class="toc-number">3.9.1.</span> <span class="toc-text">链表树化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeNode-链表转红黑树"><span class="toc-number">3.9.1.1.</span> <span class="toc-text">TreeNode 链表转红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#红黑树调整"><span class="toc-number">3.9.1.2.</span> <span class="toc-text">红黑树调整</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#左旋"><span class="toc-number">3.9.1.2.1.</span> <span class="toc-text">左旋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#右旋"><span class="toc-number">3.9.1.2.2.</span> <span class="toc-text">右旋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#情况一"><span class="toc-number">3.9.1.2.3.</span> <span class="toc-text">情况一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#情况二"><span class="toc-number">3.9.1.2.4.</span> <span class="toc-text">情况二</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#情况三"><span class="toc-number">3.9.1.2.5.</span> <span class="toc-text">情况三</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#情况四"><span class="toc-number">3.9.1.2.6.</span> <span class="toc-text">情况四</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#红黑树拆分"><span class="toc-number">3.9.2.</span> <span class="toc-text">红黑树拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#红黑树链化"><span class="toc-number">3.9.3.</span> <span class="toc-text">红黑树链化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-java-base/集合-HashMap" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      集合 - HashMap
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/8c0fc113/" class="article-date">
	  <time datetime="2021-01-10T12:30:35.000Z" itemprop="datePublished">2021-01-10</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/JDK/">JDK</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/HashMap/" rel="tag">HashMap</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/8c0fc113/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 12.6k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 52(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HashMap 是基于哈希表实现的，外层是一个数组，数组中的每个元素封装了一个 <code>key-value</code> 及其他元数据信息，这些元数据信息是为了更好的管理数组中某个位置中的元素，如使用单链表或红黑树组织元素，元数据信息就是对应的指针等信息。对 HashMap 进行增、删、改、查都需要经历两个必须的步骤，先计算 <code>key</code> 的 <code>hash</code> 值，接着根据 <code>hash</code> 值计算出当前键值对位于数组的哪个位置。HashMap 虽然基础，但是其中的思想值得学习。本篇文章将分别对 JDK 7、8 版本下的 HashMap 进行介绍。</p>
<h1 id="JDK-7-HashMap"><a href="#JDK-7-HashMap" class="headerlink" title="JDK 7 HashMap"></a>JDK 7 HashMap</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-7-struct.jpg" alt></p>
<p>JDK 1.7 的 HashMap 结构如上图所示。内部存储结构是数组和链表的结合，在实例化 HashMap 时会创建一个长度为 Capacity 的 Entry 数组，这个长度被称为容量，数组中可以存放元素的位置我们称为<strong>桶（bucket）</strong>，每个 bucket 都有自己的索引下标，系统可以根据索引下标快速查找 bucket 中的元素。每个 bucket 中存储一个元素，即一个 Entry 对象，但每一个 Entry 对象都可以通过指针链接下一个元素，因此，在一个 bucket 中就有可能生成一个 Entry 链。</p>
<h2 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化化容量, 16  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量，即2的30次方  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认负载因子  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap内部的存储结构是一个数组，此处数组为空，即没有初始化之前的状态  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 空的存储实体  </span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//实际存储的 key-value 键值对的个数。注意和容量的区分。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。</span></span><br><span class="line"><span class="comment">// HashMap在进行扩容时需要参考threshold</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子，代表了table的填充度有多少，默认是0.75。</span></span><br><span class="line"><span class="comment">// 为什么是 0.75 ，是根据 泊松统计定义的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的 threshold 值  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure>

<p>注意，<strong>HashMap 数组的每一个元素不止是一个 Entry 对象，也是一个链表的头节点</strong>。每一个 Entry 对象通过 next 指针指向它的下一个 Entry 节点。当新来的 Entry 映射到冲突的数组位置时，只需要插入到对应的链表中即可。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过初始容量和负载因子构造HashMap  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +                                             initialCapacity);  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;  </span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +  </span><br><span class="line">                                           loadFactor);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别赋值 负载因子 和 扩容阈值</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;  </span><br><span class="line">    <span class="comment">// threshold 初始值为初始容量</span></span><br><span class="line">    threshold = initialCapacity;  </span><br><span class="line">    <span class="comment">//init方法在HashMap中没有实际实现</span></span><br><span class="line">    init();</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过扩容阈值构造 HashMap,容量是默认值 16  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子取0.75，容量取16，构造HashMap  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过其他 Map 来初始化HashMap,容量通过其他Map的size来计算，装载因子取0.75  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);  </span><br><span class="line">    <span class="comment">//初始化HashMap底层的数组结构  </span></span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">    <span class="comment">//添加m中的元素  </span></span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Put方法原理"><a href="#Put方法原理" class="headerlink" title="Put方法原理"></a>Put方法原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当插入第一个元素的时候，根据情况先初始化数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 key 为 null，最终会将这个 entry 放到 table[0] 中</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 求 key 的 hash 值</span></span><br><span class="line">    <span class="comment">// 对 key 的 hashcode 进一步计算，确保散列均匀</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 找到对应的数组下标</span></span><br><span class="line">    <span class="comment">// i = h &amp; (table.length-1)，效果同取模运算</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在， 如果有，直接覆盖，put 方法返回旧值就结束了</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 不存在重复的 key，新增一个 entry 并添加到链表中</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述方法可知，确定一个元素的存储位置需要以下步骤：</p>
<ol>
<li>通过元素的 key 获取对应的 hash 值，其中使用到了 key 的 hashcode 值。</li>
<li>通过 hash 值和数组 length 信息计算得到存储的下标索引位置。</li>
<li>知道了对应的下标索引位置后就可以取出对应的元素了，如果该位置的元素有多个，那么需要遍历获取。</li>
</ol>
<h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 保证数组大小一定是 2 的 n 次方，采用向上取整的策略。如 new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 2 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 创建数组</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保证数组大小一定是 2^n 是为了实现一个尽量均匀分布的 Hash 函数。HashMap 采用类似如下的公式计算元素对应的数组位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashCode 并不是 key 的直接 hashcode 值，而是对其处理后的值</span><br><span class="line">&#x2F;&#x2F; length 是 HashMap 的长度</span><br><span class="line">index &#x3D; HashCode(key) &amp; (lenght -1)</span><br></pre></td></tr></table></figure>

<p>可以看到，HashMap 的作者采用了位运算的方式代替取模运算，只要数组大小是 2^n 就可以保证 length - 1 的值的二进制位全是 1，这种情况下，index 的结果等同于 HashCode 后几位的值。只要输入的 HashCode 本身分布均匀，Hash算法的结果就是均匀的。</p>
<h3 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 如果当前 HashMap 大小已经达到了阈值，并且新键值对要插入的数组位置已经有元素了，那么要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.1 扩容，后面会介绍一下</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 1.2 扩容以后，重新计算 hash 值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1.3 重新计算扩容后的新的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 如果需要扩容，是先扩容再插入元素</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新的键值对放到链表的表头，然后 size++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取待插入位置元素</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里执行链接操作，使得新插入的元素指向原有元素。这保证了新插入的元素总是在链表的头  </span></span><br><span class="line">    <span class="comment">// e 赋值给 Entry 中的 next</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素个数+1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在添加元素的过程中需要先判断是否需要扩容，扩容的标准是<strong>当前 HashMap 元素大小达到扩展阈值且要插入的位置已经有元素了</strong>。需要扩容的话先进行扩容，然后再将这个新的键值对插入到扩容后的数组的相应位置处的链表的表头。</p>
<p>注意，新的 Entry 节点插入链表时使用的是 <strong>头插法</strong>，作者认为后插入的 Entry 被查找的可能性更大。</p>
<h2 id="Get方法原理"><a href="#Get方法原理" class="headerlink" title="Get方法原理"></a>Get方法原理</h2><p>相比较 put 过程，get 过程是非常简单的，主要过程如下：</p>
<ol>
<li>根据 key 计算 hash 值</li>
<li>计算相应的数组下标： index = hash &amp; (length - 1)</li>
<li>遍历该数组位置处的链表，直到找到相同的 key 或为 null</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 走查找流程</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回对应的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 通过 hash 函数计算 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 确定数组下标，然后从头开始遍历链表，直到找到为止</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 在对应的数组位置没有找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>HashMap 的容量是有限的，当经过多次元素插入会使得 HashMap 达到一定饱和度时，key 映射位置发生冲突的几率会逐渐提高，这时 HashMap 需要进行扩容。在 put 的过程，如果当前 HashMap 元素个数 size 已经达到了阈值且要插入的数组位置上已经有元素了，那么就会触发扩容，扩容后数组大小是原来的 2 倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 保存旧数组 </span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 保存旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 如果旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 扩容，创建一个新的空数组，长度是原数组的 2 倍</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5 将原来数组中的键值对迁移到新的更大的数组中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 扩容完毕后，用新的数组指向 table</span></span><br><span class="line">    table = newTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7 计算新的扩容阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 作用：将旧数组上的数据（键值对）转移到新 table 中，从而完成扩容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 容量</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两层循环</span></span><br><span class="line">        <span class="comment">// 外层 for 循环 用于遍历数组</span></span><br><span class="line">        <span class="comment">// 内层 while 循环 用于遍历数组中对应位置的链表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123; </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123; </span><br><span class="line"></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;  </span><br><span class="line">                <span class="comment">//如果是重新 Hash，则需要重新计算hash值  </span></span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);  </span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算元素 e 在新数组中的位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 头插入，newTable[i]的值总是最新插入的值</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 继续下一个元素  </span></span><br><span class="line">                e = next;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上扩容代码相对还是比较直观的，整个扩容分为两个步骤：扩容和rehash。</p>
<p>我们知道，在多线程环境中 HashMap 是不安全的，其中一个很大的问题就是数组中某个位置的链表可能成环，这个问题就是发生在 rehash 过程。下面我们对该现象详细分析。</p>
<h2 id="链表成环"><a href="#链表成环" class="headerlink" title="链表成环"></a>链表成环</h2><p>假设一个 HashMap 已经到了扩容的临界点，此时刚好有两个线程 A 和 B 在同一时刻对 HashMap 进行 put 操作，那么两个线程各自进行扩容：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-1.png" alt></p>
<p>接着两个线程都来到 <code>transfer</code> 方法中，其中线程 B 遍历到 Entry3 对象，刚执行完以下代码时就被挂起了。此时线程 B 的状态数据，e = Entry3，next = Entry2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure>
<p>而在线程 B 被挂起期间，线程 A 成功完成了 rehash 过程，结果如下（图中的 e 和 next 分别代表线程 B 持有的两个 Entry 引用）。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-2.png" alt></p>
<p><strong>第一轮</strong></p>
<p>当线程 A 完成 rehash 后线程 B 恢复，继续执行属于它的 rehash 过程。接着执行以下代码，确认 e 对应的元素应该位于新数组哪个索引位置，毫无疑问地 i = 3，因为刚才线程 A 对 Entry3 的映射结果就是 3 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算元素 e 在新数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br></pre></td></tr></table></figure>

<p>接续执行后续的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头插入，newTable[i]的值总是最新插入的值</span></span><br><span class="line">e.next = newTable[i];</span><br><span class="line">newTable[i] = e; </span><br><span class="line"></span><br><span class="line"><span class="comment">//继续下一个元素  </span></span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure>

<p>对应的情况如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-3.png" alt></p>
<p>至此，第一轮执行完毕，此时线程 B 将 Entry3 rehash 到了自己的新数组中，且它的 e 和 next 指针同时指向 Entry2 。注意，线程 B 操作的 Entry 节点还是原来的节点，虽然原来的 Entry 节点被线程 A 进行了 rehash ，但是引用指向没有变。</p>
<p><strong>第二轮</strong></p>
<p>接着执行新的一轮，此时又执行到以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure>
<p>此时，e = Entry2，next = Entry3 ，整体情况如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-4.png" alt></p>
<p>接着继续执行以下三行代码，采用头插法把 Entry2 插入到线程 B 的数组的头节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 头插入，newTable[i]的值总是最新插入的值</span></span><br><span class="line"> e.next = newTable[i];</span><br><span class="line"> newTable[i] = e; </span><br><span class="line"></span><br><span class="line"> <span class="comment">//继续下一个元素  </span></span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure>

<p>整体情况如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-5.png" alt></p>
<p>至此，第二轮执行完毕，此时线程 B 将 Entry2 rehash 到了自己的新数组中，且它的 e 和 next 指针同时指向 Entry3 。</p>
<p><strong>第三轮</strong></p>
<p>接着执行新的一轮，此时又执行到以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure>

<p>此时，e = Entry3,next = null，接着继续执行以下代码，做头插法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头插入，newTable[i]的值总是最新插入的值</span></span><br><span class="line">e.next = newTable[i];</span><br></pre></td></tr></table></figure>
<p>此时，链表出现了环形。相关数据关系如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newTable[i] = Entry2</span><br><span class="line">e = Entry3</span><br><span class="line">Entry2.next = Entry3</span><br><span class="line">Entry3.next = Entry2</span><br></pre></td></tr></table></figure>
<p>整体情况如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-6.png" alt></p>
<p>最后，执行以下代码将新元素设为头，也就是将 Entry3 设置为头。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newTable[i] = e;</span><br></pre></td></tr></table></figure>

<p>至此，第三轮执行完毕，此时线程 B 将 Entry3 和 Entry2 互相使用 next 指针链接起来形成了一个环。由于 next = null ，因此在下一轮开始判断的时候不满足条件，结束数组当前位置数据的 rehash 。</p>
<p>此时，坑已经埋好了，就等调用 get 查找一个不存在的 key ，而这个 key 的 hash 结果映射到桶的位置恰好等于 3 时，由于位置 3 带有环形链表，因此程序会进入死循环。</p>
<p>值得说明的是，在一定程度上链表头插法会<strong>颠倒</strong>原来一个位置上链表的顺序。在并发的时候原来的顺序被线程 A 颠倒了，而被挂起的线程 B 恢复后拿到挂起前的节点和顺序继续完成 rehash，这个过程会将线程 A rehash 后的链表顺序重新排列，最终形成了环。JDK 1.8 之后就不再采用头插法了，而是直接插入链表尾部，因此不会形成环形链表形成死循环，但是在多线程的情况下仍然是不安全的，在put数据时如果出现两个线程同时操作，可能会发生数据覆盖，引发线程不安全。</p>
<h1 id="JDK-8-HashMap"><a href="#JDK-8-HashMap" class="headerlink" title="JDK 8 HashMap"></a>JDK 8 HashMap</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-8-struct.jpg" alt></p>
<p>JDK 1.8 的 HashMap 结构大体上如上图所示，具体细节并没有展示，比如红黑树中的链接指针没有全部显示。JDK 1.7 的 HashMap 采用 <strong>数组+链表</strong> 的方式在大部分情况下都能有不错的性能，但在极端的情况下可能会退化成一个链表，造成 HashMap 性能急剧下降。因此在 JDK 1.8 中采用了 <strong>数组+链表+红黑树</strong>的方式来组织数据，新增红黑树是为了解决哈希碰撞，避免过长链表效率低的问题。</p>
<h2 id="关键属性-1"><a href="#关键属性-1" class="headerlink" title="关键属性"></a>关键属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认容量大小 16，大小必须是 2^N</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量，当两个构造函数中任何一个带参数的函数隐式指定较大的值时使用。一定是2 &lt;= 1&lt;&lt;30的幂。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认负载因子 在构造函数中未指定时使用的负载因子</span></span><br><span class="line"><span class="comment">     * 为什么是 0.75 ，是根据 泊松统计定义的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶的树化阈值： 使用红黑树时元素个数的阈值。在存储数据时，当链表长度 &gt;= 8时，则将链表转换成红黑树。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶的链表还原阈值：红黑树转链表阈值。</span></span><br><span class="line"><span class="comment">     * 当在扩容时，在重新计算存储位置后，当原有的红黑树内数量 &lt;= 6时，则将 红黑树转换成链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小树形化容量阈值：使用红黑树时最小的表容量。当 HashMap 中的容量 &gt; 该值时，才允许树化即将链表转成红黑树。</span></span><br><span class="line"><span class="comment">     * 这样是为了减少形成很满的桶，因为桶的数量很少时，容易造成桶满</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储数据的 Node 数组，长度是 2 的幂。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * table 容纳的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap 被改变的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容的阈值（当前 HashMap 所能容纳键值对数量的最大值，超过该值则需要扩容），等于 capacity * loadFactory</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负载因子，默认为 0.75</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TREEIFY_THRESHOLD</code> 和 <code>UNTREEIFY_THRESHOLD</code> 两个参数是控制链表和红黑树相互转换的阈值，它们中间有个差值 7 可以有效防止链表和树频繁转换。其它属性和 JDK 1.7 版本中的类似。值得说明的是桶数组 table 被申明为 transient ，也就是不会被默认的序列化机制序列化。但 HashMap 通过实现 <code>readObject/writeObject</code> 两个方法自定义了序列化的内容，也就是将键值对序列化，后续可以根据键值对数据重建 HashMap。</p>
<p>这里不直接将 table 进行序列化是为了避免以下问题：</p>
<ol>
<li>table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间</li>
<li>同一个键值对在不同 JVM 下所处的桶位置可能是不同的，这种情况下反序列化 table 可能会发生错误。</li>
</ol>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * HashMap 中元素项，用于链表的情况。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">// key 对应的 hash 值</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">      <span class="comment">// key</span></span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      <span class="comment">// value</span></span><br><span class="line">      V value;</span><br><span class="line">      <span class="comment">// 下一个元素的指针</span></span><br><span class="line">      Node&lt;K, V&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * HashMap 中元素项，用于红黑树的情况。间接继承了 Node </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      TreeNode&lt;K, V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">      TreeNode&lt;K, V&gt; left;</span><br><span class="line">      TreeNode&lt;K, V&gt; right;</span><br><span class="line">      TreeNode&lt;K, V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">      <span class="keyword">boolean</span> red;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定容量大小和负载因子的构造函数，是最基础的构造函数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                   initialCapacity);</span><br><span class="line">       <span class="comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                   loadFactor);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置负载因子</span></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 取大于 cap 且最近的2的整数次幂的数作为扩容的阈值</span></span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 指定容量大小</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用默认属性</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用给定的数据源初始化 HashMap</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在集合初始化时，推荐指定集合初始值大小，在一定程度上可以减少扩容带来的开销。</p>
<h2 id="确定桶位置"><a href="#确定桶位置" class="headerlink" title="确定桶位置"></a>确定桶位置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab[(n -<span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure>

<p>计算方式和 JDK 1.7 HashMap 是一致的。HashMap 的数组长度 <code>length</code> 总是 2^n ，因此 <code>(n - 1) &amp; hash</code> 等价于对 <code>length</code> 取余，由于取余运算效率没有位运算高，这里做了一个优化。此外，<code>length - 1</code> 正好相当于一个低位掩码，<code>&amp;</code> 操作的结果就是 <code>hash</code> 值的高位全部归零，只保留对应的低位值，即定位数组桶的位置取决于 <code>hash</code> 值的低几位。</p>
<h2 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上述方法计算 hash 值没有直接使用 key 的 hashCode 方法生成的 hash 值，而是通过位运算重新计算出一个 hash 值。在 Java 中 hashCode 方法产生的 hash 是 int 类型，也就是 32 位。由于确定数组的桶位置是通过 <code>(n - 1) &amp; hash</code> 计算得到的，这就要求计算 <code>hash</code> 值的算法要具有随机性。因此，在计算 key 的 hashCode 时用其自身 hashCode 与其低 16 位做 <code>^</code> 操作，这让高位也参与到 hash 值的计算中来，进而降低了哈希冲突的风险又不会带来太大的性能问题。此外，重新计算 hash 的另一个好处是可以增加 hash 的复杂度。当我们覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。计算过程如下：</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-8-hash-process.png" alt></p>
<h2 id="Get方法原理-1"><a href="#Get方法原理-1" class="headerlink" title="Get方法原理"></a>Get方法原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据 key 获取对应 value</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      Node&lt;K, V&gt; e;</span><br><span class="line">      <span class="comment">// 根据 key 的 hashCode 计算得到 hash 值，然后利用 pos = （n-1）&amp; hash 计算其在数组中的位置</span></span><br><span class="line">      <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">      Node&lt;K, V&gt;[] tab;</span><br><span class="line">      Node&lt;K, V&gt; first, e;</span><br><span class="line">      <span class="keyword">int</span> n;</span><br><span class="line">      K k;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1 如果 key 对应的数组位置有元素</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">              (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 1.1 先在头节点中找</span></span><br><span class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                  ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 1.2 头节点不是目标元素</span></span><br><span class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 1.2.1 如果是红黑树，则去红黑树中找</span></span><br><span class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 1.2.2 如果不是红黑树，则说明是链表，那么就从链中找</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                          ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Get方法逻辑还是比较简单的。先定位键所在的桶的位置，然后再对链表或红黑树进行查找。</p>
<h2 id="Put方法原理-1"><a href="#Put方法原理-1" class="headerlink" title="Put方法原理"></a>Put方法原理</h2><p>Put方法先定位要插入的键值对属于哪个桶，定位到桶后，再判断桶是否为空。如果为空，则将键值对存入即可。如果不为空，则需将键值对插入到链表最后一个位置或红黑树中，或者更新键值对。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加键值对</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 通过 hash(key) 计算 key 的 hash 值</span></span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 尾插法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> hash         key 的 hash</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key          the key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value        the value to put</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> onlyIfAbsent 如果为 true ，那么只有在不存在该 key 时才会进行 put 操作，默认是 false 即覆盖</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> evict        if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      Node&lt;K, V&gt;[] tab;</span><br><span class="line">      Node&lt;K, V&gt; p;</span><br><span class="line">      <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化数组 table，table 被延迟到插入新数据时再进行初始化</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// key 映射的数组桶位置为空，则创建一个 Node 填充到对应位置即可</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// key 映射的数组桶位置有数据</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          Node&lt;K, V&gt; e;</span><br><span class="line">          K k;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 在该位置的第一个数据的 key 和要插入 遇到相同的 key 了</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                  ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              e = p;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 在红黑树中插入节点</span></span><br><span class="line">              <span class="comment">// a. 往红黑树中插入节点  b. 调整红黑树</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">              e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 在链表中插入节点</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 对链表进行遍历，并统计链表长度</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 链表中不包含要插入的键值对节点，则插入到链表的最后，即尾插法</span></span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 如果链表长度大于或等于树化阈值，则进行树化操作，也就是将链表转换为红黑树</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                          treeifyBin(tab, hash);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 如果在链表中找到了相同的 key</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                          ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="comment">// 此时 break，那么 e 为链表中与要插入的新值的 key 相同的 node</span></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 用于遍历下一个</span></span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 判断要插入的键值对是否存在 HashMap 中</span></span><br><span class="line">          <span class="comment">// e != null 说明存在旧值的 key 与要插入的 key 相同</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              V oldValue = e.value;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span></span><br><span class="line">              <span class="comment">// key 相同进行值覆盖</span></span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 返回旧值</span></span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 增加修改次数</span></span><br><span class="line">      ++modCount;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line"></span><br><span class="line">      afterNodeInsertion(evict);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面对 Put逻辑进行小结：</strong></p>
<ol>
<li>当桶数组 table 为空时，通过扩容的方式初始化 table</li>
<li>查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值</li>
<li>如果不存在，则将键值对插入红黑树或链表中，其中插入到链表的过程还会根据链表的长度决定是否将链表转为红黑树。具体转换会在下文进行介绍。</li>
<li>判断键值对数量是否大于阈值，大于的话则进行扩容操作</li>
</ol>
<h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>在 HashMap 中，桶数组的长度均是 2^n ，当键值对数量超过扩容阈值时，需要进行扩容。HashMap 按当前桶数组长度的 2 倍进行扩容，扩容阈值也更新为原来的 2 倍。扩容之后，需要重新计算键值对的位置，并把它们移动到合适的位置上去。和 JDK 1.7 不同的是，JDK 1.7 是先判断是否需要扩容后插入新值，JDK 1.8 是先插入值再判断是否需要扩容，并且前者是头插法后者是尾插法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化数组或数组扩容</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// table 旧的容量，最开始 table 为空</span></span><br><span class="line">      <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 扩容阈值</span></span><br><span class="line">      <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">      <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldCap &gt; 0 ，说明是对数组扩容</span></span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 超过最大容量，则使用 Integer.MAX_VALUE 的值，不再进行扩容</span></span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 将 数组扩大一倍</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              <span class="comment">// 将 扩容阈值 也增大一倍</span></span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候初始容量设置为 threshold</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候初始容量使用默认值</span></span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          <span class="comment">// 计算扩容阈值，为 12</span></span><br><span class="line">          newThr = (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// newThr 为 0 时，按阈值计算公式进行计算</span></span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">float</span> ft = (<span class="keyword">float</span>) newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>) MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>) ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新扩容阈值</span></span><br><span class="line">      threshold = newThr;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span>&#125;)</span><br><span class="line">      Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node[newCap];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果非扩容而是初始化数组，执行到这里就结束了</span></span><br><span class="line">      table = newTab;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 扩容，进行数据迁移</span></span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 遍历原数组，将键值对映射到新的桶数组中</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K, V&gt; e;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 取出下标 j 的元素</span></span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">// 如果当前数组位置上只有一个 Node 元素，简单迁移即可</span></span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                      <span class="comment">// 通过 hash 值计算出在新数组中所属的位置</span></span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 如果是红黑树，需要对红黑树进行拆分</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K, V&gt;) e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 链表处理</span></span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 将当前链表拆分成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line"></span><br><span class="line">                      <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表</span></span><br><span class="line">                      Node&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 根据e的 hash 值和旧的容量做位与运算是否为 0 来拆分当前链表进行分组，注意之前是 e.hash &amp; (oldCap - 1)</span></span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line"></span><br><span class="line">                          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 将分组后的链表映射到新桶中</span></span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 第一条链表</span></span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 第二条链表的新的位置是 j + oldCap</span></span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面对上述代码流程进行总结：</strong></p>
<ol>
<li>计算新桶数组的容量 newCap 和新扩容阈值 newThr</li>
<li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li>
<li>将遍历的桶数组的键值对节点重新映射到新的桶数组中。如果节点是 TreeNode 类型，则需要拆分红黑树进行分组然后映射；如果是普通节点，也就是链表，则同样需要分组然后映射。注意，以上分组的依据是根据节点的 hash 值和旧的容量做位与运算是否为 0 来限定的。</li>
</ol>
<p>在 JDK 1.8 中，重新映射节点需要考虑节点类型。对于树形节点，需要先拆分分组然后映射；对于链表类型节点，也需要先拆分分组，然后映射。需要注意的是，分组后，组内节点相对位置保持不变。相对与 JDK 1.7 采用每个节点重新 hash 且头插入 ，JDK 1.8 采用尾插法且以分组的方式进行重新映射，避免了链表成环的问题。</p>
<h2 id="树化、链化与拆分"><a href="#树化、链化与拆分" class="headerlink" title="树化、链化与拆分"></a>树化、链化与拆分</h2><p>JDK 1.8 对 HashMap 实现进行了改进。最大的改进莫过于引入红黑树处理频繁的碰撞，同时也增加了代码实现的复杂度。本小结将对 HashMap 中 <code>链表树化</code>、<code>红黑树链化</code>以及<code>红黑树拆分</code> 进行说明。</p>
<h3 id="链表树化"><a href="#链表树化" class="headerlink" title="链表树化"></a>链表树化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K, V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        <span class="comment">// 数组容量小于 MIN_TREEIFY_CAPACITY，优先进行扩容而不是树化</span></span><br><span class="line">        <span class="comment">// 尽可能避免树化，除非桶中元素碰撞严重</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出数组对应位置的头节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// hd 为头节点(head)，tl 为尾节点（tail）</span></span><br><span class="line">            TreeNode&lt;K, V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 将普通节点替换成树形节点</span></span><br><span class="line">                TreeNode&lt;K, V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将普通链表转成由树形节点链表</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将树形链表转换成红黑树</span></span><br><span class="line">            <span class="comment">// hd 是 index 对应桶的首节点</span></span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For treeifyBin</span></span><br><span class="line">    <span class="function">TreeNode&lt;K, V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K, V&gt; p, Node&lt;K, V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将链表转为红黑树需要满足以下两个条件：</p>
<blockquote>
<ol>
<li>链表长度大于等于 <code>TREEIFY_THRESHOLD</code> 8</li>
<li>桶数组容量大于等于 <code>MIN_TREEIFY_CAPACITY</code> 64</li>
</ol>
</blockquote>
<p>上述方法主要的过程是，先将链表转成由 <code>TreeNode</code> 类型节点组成的链表，并在最后调用 <code>treeify</code> 将该链表转为红黑树。TreeNode 继承自 Node ，所以 TreeNode 仍然包含 next 引用，原链表的节点顺序最终通过 next 引用被保存下来。</p>
<p>下面我们重点来介绍链表转红黑树的过程。</p>
<h4 id="TreeNode-链表转红黑树"><a href="#TreeNode-链表转红黑树" class="headerlink" title="TreeNode 链表转红黑树"></a>TreeNode 链表转红黑树</h4><p>将链表转为红黑树需要两个过程，第一个是通过 <code>treeifyBin</code> 方法将普通节点链表转成树形节点链表，也就是 TreeNode 链表；另一个则是 <code>treeify</code> 方法再将第一步得到的树形链表结构转成真正的红黑树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将树形链表转换成红黑树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(HashMap.Node&lt;K, V&gt;[] tab)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 定义红黑树的根节点</span></span><br><span class="line">       HashMap.TreeNode&lt;K, V&gt; root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1 遍历树形链表节点，依次加入到红黑树中。</span></span><br><span class="line">       <span class="comment">// x 指向当前节点，next 指向下一个节点</span></span><br><span class="line">       <span class="keyword">for</span> (HashMap.TreeNode&lt;K, V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">           <span class="comment">// 记录 x 的下一个节点</span></span><br><span class="line">           next = (HashMap.TreeNode&lt;K, V&gt;) x.next;</span><br><span class="line">           <span class="comment">// 左右节点先确保干净</span></span><br><span class="line">           x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 2 如果根节点为空，说明还没有开始构建红黑树，这里开始构建。即将当前节点作为根节点，颜色设为黑色</span></span><br><span class="line">           <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">               x.parent = <span class="keyword">null</span>;</span><br><span class="line">               x.red = <span class="keyword">false</span>;</span><br><span class="line">               root = x;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3 红黑树已经存在，则往该树中添加节点</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 记录当前遍历到的树形节点的 key 和 hash</span></span><br><span class="line">               K k = x.key;</span><br><span class="line">               <span class="keyword">int</span> h = x.hash;</span><br><span class="line">               Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3.1 从根节点遍历，为节点 x 找到空位置并插入</span></span><br><span class="line">               <span class="keyword">for</span> (HashMap.TreeNode&lt;K, V&gt; p = root; ; ) &#123;</span><br><span class="line">                   <span class="comment">// dir 表示方向（左边/右边），ph 表示 hash 值</span></span><br><span class="line">                   <span class="keyword">int</span> dir, ph;</span><br><span class="line">                   K pk = p.key;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">/* 比较大小，定位插入左边/右边*/</span></span><br><span class="line">                   <span class="comment">// 3.1.1 hash 判断</span></span><br><span class="line">                   <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                       dir = -<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                       dir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 3.1.2 根据比较器判断大小</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                           <span class="comment">// Comparable 接口判断</span></span><br><span class="line">                           (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                           (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 3.1.3 通过 k 类名比较</span></span><br><span class="line">                       dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 保存当前遍历的树节点</span></span><br><span class="line">                   HashMap.TreeNode&lt;K, V&gt; xp = p;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 3.2.1 根据 dir 确定放入左边还是右边</span></span><br><span class="line">                   <span class="comment">// 如果根据 dir 确定了位置后，还要判断 p 是不是叶子节点（末节点），如果不是则继续往下找适合节点x插入的位置，也就是 x 节点的父节点</span></span><br><span class="line">                   <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// x 节点找到了父节点</span></span><br><span class="line">                       x.parent = xp;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 将 x 节点挂到它的父节点 xp 下</span></span><br><span class="line">                       <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                           xp.left = x;</span><br><span class="line">                       <span class="keyword">else</span></span><br><span class="line">                           xp.right = x;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 3.2.2 x 节点插入后，可能会导致红黑树不符合规则，因此需要尝试进行调整</span></span><br><span class="line">                       root = balanceInsertion(root, x);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 确保根节点作为第一个节点</span></span><br><span class="line">       moveRootToFront(tab, root);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法做的只有一个工作，遍历 TreeNode 双向链表，将该链表中每个节点构建到红黑中。下面对流程进行分步说明：</p>
<blockquote>
<ol>
<li>遍历第一个节点时，此时红黑树不存在，以第一个节点作为红黑树根节点。</li>
<li>有了红黑树后，此后遍历链表的每个节点时，都要根据规则到红黑树中从根节点开始寻找要插入当前节点的位置，也就是找到一个父节点，将当前节点作为其左节点或右节点。</li>
<li>插入节点后，可能会导致红黑树特性被破坏，因此每次插入节点后要尝试重新调整红黑树。</li>
</ol>
</blockquote>
<p>上述方法完成了 TreeNode 链表中每个节点构建红黑树的过程，一个节点构建到红黑树后并没有结束，还要保证红黑树不能因为新增一个节点就被破坏，而保证的手段就是红黑树调整。</p>
<h4 id="红黑树调整"><a href="#红黑树调整" class="headerlink" title="红黑树调整"></a>红黑树调整</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K, V&gt; HashMap.<span class="function">TreeNode&lt;K, V&gt; <span class="title">balanceInsertion</span><span class="params">(HashMap.TreeNode&lt;K, V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         HashMap.TreeNode&lt;K, V&gt; x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 默认插入红色</span></span><br><span class="line">       x.red = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// xp -&gt; 父节点</span></span><br><span class="line">       <span class="comment">// xpp -&gt; 祖父节点</span></span><br><span class="line">       <span class="comment">// xppl 是祖父节点的左节点（左叔叔节点）</span></span><br><span class="line">       <span class="comment">// xppr 是祖父节点的右节点（右叔叔节点）</span></span><br><span class="line">       <span class="keyword">for</span> (HashMap.TreeNode&lt;K, V&gt; xp, xpp, xppl, xppr; ; ) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 1 x 节点的父节点不存在，说明当前节点是根节点，只需变色为黑色即可</span></span><br><span class="line">           <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               x.red = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 2 x 节点的父节点是黑色，可以在下面直接添加红色节点，不需要调整；x 节点的祖父节点为空，说明 x 的父节点是根节点，可以在下面直接添加红色节点，也不许要调整</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 3 x 的父节点 xp 是红色且 x 祖父节点 xxp 不为空。这样就遇到了两个红色节点相连的情况。这种情况分两种可能</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 3.1 如果父节点 xp 是祖父节点的左节点</span></span><br><span class="line">           <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3.1.1 如果祖父节点的右节点（右叔叔节点）不为空，同时是红色。则：</span></span><br><span class="line">               <span class="comment">// a. 将父节点和右叔叔节点变色 -&gt; 黑色</span></span><br><span class="line">               <span class="comment">// b. 将祖父节点变色 -&gt; 红色</span></span><br><span class="line">               <span class="comment">// c. 将祖父节点作为当前节点 x ，进行下一轮的调整（xxp 节点变成红色后可能与xpp的父节点发生冲突，也就是两个连续的红色节点）</span></span><br><span class="line">               <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                   xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                   xp.red = <span class="keyword">false</span>;</span><br><span class="line">                   xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                   x = xpp;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 3.1.2 如果祖父节点的右节点（右叔叔节点）为空或是黑色。那么就可能对应以下两种情况：</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 3.1.2.1 xpp-&gt;xp(xxp的左节点)-&gt;x(xp的右节点) =&gt; LR 双红</span></span><br><span class="line">                   <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                       <span class="comment">// 将 xp 节点左旋，调整成 LL 双红的情况</span></span><br><span class="line">                       root = rotateLeft(root, x = xp);</span><br><span class="line">                       <span class="comment">// 重置 xp，xxp</span></span><br><span class="line">                       <span class="comment">// 左旋后得到的本来是： xpp-&gt;x(xxp的左节点)-&gt;xp(x的左节点) =&gt; LL 双红</span></span><br><span class="line">                       <span class="comment">// 但是由于 x = xp 了，因此恰巧从变量的角度看是这个样子：xpp-&gt;xp(xxp 的左节点)-&gt;x(xp的左节点) =&gt; LL 双红</span></span><br><span class="line">                       xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 3.1.2.2 xpp-&gt;xp(xxp 的左节点)-&gt;x(xp的左节点) =&gt; LL 双红</span></span><br><span class="line">                   <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 父节点 xp 变色 -&gt; 黑色</span></span><br><span class="line">                       xp.red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 存在祖父节点</span></span><br><span class="line">                       <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="comment">// 祖父节点 xpp 变色 -&gt; 红色</span></span><br><span class="line">                           xpp.red = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// 右旋祖父节点</span></span><br><span class="line">                           <span class="comment">// 特别说明：上一步将祖父节点 xpp 变成红色，为啥这里直接旋转祖父节点 xpp 就可以结束了？因为 xp 变成了黑色，旋转后的结果是 xpp 挂到 xp 的右边成为 xp 的孩子节点，</span></span><br><span class="line">                           <span class="comment">// xp 成为最开始 xpp 的父节点的孩子节点（如果 xpp 是根节点，那么此时 xp 就是新的根节点），因此这里不用考虑 xpp 变色后破坏红黑树特点。简单来说，对于 xpp 的父节点</span></span><br><span class="line">                           <span class="comment">// 而言只是将 xpp 这个孩子节点换成了 xp ，但是节点颜色相比之前是没有变的。</span></span><br><span class="line">                           root = rotateRight(root, xpp);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3.2 父节点 xp 是祖父节点的右节点。和上面的情况相反但操作类似，一个是左节点，另一个是右节点</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3.2.1 如果 x 节点的祖父节点的左节点（左叔叔节点）不为空，同时是红色。则：</span></span><br><span class="line">               <span class="comment">// a. 将父节点和左叔叔节点变色 -&gt; 黑色</span></span><br><span class="line">               <span class="comment">// b. 将祖父节点变色 -&gt; 红色</span></span><br><span class="line">               <span class="comment">// c. 将祖父节点作为当前节点 x ，进行下一轮的调整（xxp 节点变成红色后可能与xpp的父节点发生冲突，也就是两个连续的红色节点）</span></span><br><span class="line">               <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                   xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                   xp.red = <span class="keyword">false</span>;</span><br><span class="line">                   xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                   x = xpp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 3.2.2 如果祖父节点的左节点（左叔叔节点）为空或是黑色。那么就可能对应以下两种情况：</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 3.2.2.1 xpp-&gt;xp(xxp的右节点)-&gt;x(xp的左节点) =&gt; RL 双红</span></span><br><span class="line">                   <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                       <span class="comment">// 将父节点 xp 右旋转，得到 RR 双红</span></span><br><span class="line">                       root = rotateRight(root, x = xp);</span><br><span class="line">                       <span class="comment">// 原因同 3.1.2.2</span></span><br><span class="line">                       xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 3.2.2.2 xpp-&gt;xp(xxp的右节点)-&gt;x(xp的右节点) =&gt; RR 双红</span></span><br><span class="line">                   <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 父节点变色 -&gt; 黑色</span></span><br><span class="line">                       xp.red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 存在祖父节点</span></span><br><span class="line">                       <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// 祖父节点变色 -&gt; 红色</span></span><br><span class="line">                           xpp.red = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// 左旋祖父节点</span></span><br><span class="line">                           <span class="comment">// 特别说明：原因同上</span></span><br><span class="line">                           root = rotateLeft(root, xpp);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h5 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左旋：</span></span><br><span class="line"><span class="comment">     * 1 将节点 p 旋转为其右节点的左节点，即将节点 p 挂到其右节点的左边</span></span><br><span class="line"><span class="comment">     * 2 其右节点的左节点成为节点p 的右节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K, V&gt; HashMap.<span class="function">TreeNode&lt;K, V&gt; <span class="title">rotateLeft</span><span class="params">(HashMap.TreeNode&lt;K, V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    HashMap.TreeNode&lt;K, V&gt; p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// r -&gt; 节点 p 的右节点</span></span><br><span class="line">        <span class="comment">// rl -&gt; 节点 p 的右节点的左节点</span></span><br><span class="line">        <span class="comment">// pp -&gt; 节点 p 的父节点，最后是 p 的右节点的父节点</span></span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; r, pp, rl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p 不为空且右节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 将 p 的右节点的左节点挂到 p 的右节点，这有两个信息</span></span><br><span class="line">            <span class="comment">// a. 断开 p 与其右节点 r 的连接</span></span><br><span class="line">            <span class="comment">// b. 因为 p 要挂到其右节点 r 的左边，因此要把节点 r 原来的左节点挂到 p 的右边</span></span><br><span class="line">            <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// r 节点的左节点的父节点重置为 p</span></span><br><span class="line">                rl.parent = p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 将 p 的父节点设置为 p 的右节点的父节点</span></span><br><span class="line">            <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 如果 p 为 root 节点，那么直接将其右节点设置为 root</span></span><br><span class="line">                (root = r).red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3 确定 r 节点应该挂在 p 的父节点的左边还是右边。这个根据 p 的位置决定</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                pp.left = r;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = r;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 将 p 设置为其右节点的左边</span></span><br><span class="line">            r.left = p;</span><br><span class="line">            <span class="comment">// 5 将 p 的右节点指为其父节点</span></span><br><span class="line">            p.parent = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右旋：</span></span><br><span class="line"><span class="comment">     * 1 将节点 p 旋转为其左节点的右节点，即将节点 p 挂到其左节点的右边</span></span><br><span class="line"><span class="comment">     * 2 其左节点的右节点成为节点 p 的左节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K, V&gt; HashMap.<span class="function">TreeNode&lt;K, V&gt; <span class="title">rotateRight</span><span class="params">(HashMap.TreeNode&lt;K, V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     HashMap.TreeNode&lt;K, V&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// l -&gt; 节点 P 的左节点</span></span><br><span class="line">        <span class="comment">// pp -&gt; 节点 p 的父节点</span></span><br><span class="line">        <span class="comment">// lr -&gt; 节点 p 的左节点的右孩子</span></span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; l, pp, lr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点 p 和 其左节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 将 p 的左节点的右孩子挂到 p 的左边</span></span><br><span class="line">            <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 将 p 指定为 lr 的父节点</span></span><br><span class="line">                lr.parent = p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 将 p 的父节点指定为其右节点的父节点</span></span><br><span class="line">            <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                (root = l).red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.1 确定 p 的右节点应该挂在 p的父节点左边还是右边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">                pp.right = l;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.left = l;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 调整 p 的关系：</span></span><br><span class="line">            <span class="comment">// a.将 p 设置为其左节点的右孩子</span></span><br><span class="line">            <span class="comment">// b.将 p 的父节点指定为其左节点</span></span><br><span class="line">            l.right = p;</span><br><span class="line">            p.parent = l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>红黑树调整的过程完全是红黑树节点插入的过程，由于涉及的情况比较多，下面我们对上述过程分情况分析。再强调一遍，调整过程是红黑树的操作过程，并非 HashMap 自己搞的一套调整逻辑。</p>
<h5 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h5><p>红黑树为空树，插入的新节点 X 作为红黑树的根节点，这种情况下将节点 X 的颜色由红色变成黑色即可。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-1.jpg" alt></p>
<h5 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h5><p>插入的新节点 X 的父节点是黑色，这种情况下不需要调整。</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-2.jpg" alt></p>
<h5 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h5><p>插入的新节点 X 的父节点是红色（节点 P 为红色，其父节点必然为黑色），叔叔节点 U 也是红色。由于 P 和 U 都是红色，不满足每个红色节点必须有两个黑色的子节点，也就是不能同时存在两个连续的红节点。这种情况下需要调整，先将 P 和 U 变为黑色，再将 PP 变为红色。但需要注意的是 PP 变为红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整，也就将 PP 看作新插入节点继续尝试调整。</p>
<p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-3.jpg" alt></p>
<h5 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h5><p>插入节点 X 的父节点为红色，叔叔节点不存在或为黑色（下面的所以情况以黑色为例进行说明）。这里需要根据插入节点 X 的父节点是祖父节点的左子树还是右子树进行讨论，不同的情况处理的逻辑不同。主要不同在于旋转的方向上不同。</p>
<p><strong>父节点为祖父节点左子树</strong></p>
<p>根据插入节点 X 是父节点的左子树还是右子树又可分为两类。</p>
<ul>
<li><p><strong>插入节点是父节点的右子树</strong><br>插入节点 X 的父节点 P 为红色，属于 LR 形。叔叔节点 U 为黑色。节点 X 是 P 的右子树，且节点 P 是 PP 的左子树。此时先对节点 P 进行左旋，调整节点 X 与 P 的位置，变为 LL 形。接下来按照 LL 形进行处理即可，也就是下面的 <strong>插入节点是父节点的左子树</strong> 情况。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-4.jpg" alt></p>
</li>
<li><p><strong>插入节点是父节点的左子树</strong><br>插入节点 X 的父节点 P 为红色，属于 LL 形。叔叔节点 U 为黑色。节点 X 是 P 的左子树，且节点 P 是 PP 的左子树。此时先将 P 变成黑色，PP 变成红色；然后对 PP 进行右旋，调整 P 和 PP 的位置。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-5.jpg" alt></p>
</li>
</ul>
<p><strong>父节点为祖父节点右子树</strong></p>
<p>根据插入节点 X 是父节点的左子树还是右子树又可分为两类。</p>
<ul>
<li><p><strong>插入节点是父节点的左子树</strong><br>插入节点 X 的父节点 P 为红色，属于 RL 形。叔叔节点 U 为黑色。节点 X 是 P 的左子树，且节点 P 是 PP 的右子树。此时先对节点 P 进行右旋，调整节点 X 与 P 的位置，变为 RR 形。接下来按照 RR 形进行处理即可，也就是下面的 <strong>插入节点是父节点的右子树</strong> 情况。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-6.jpg" alt></p>
</li>
<li><p><strong>插入节点是父节点的右子树</strong><br>插入节点 X 的父节点 P 为红色，属于 RR 形。叔叔节点 U 为黑色。节点 X 是 P 的右子树，且节点 P 是 PP 的右子树。此时先将 P 变成黑色，PP 变成红色；然后对 PP 进行左旋，调整 P 和 PP 的位置。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/rb-tree-7.jpg" alt></p>
</li>
</ul>
<p>以上四种情况覆盖了黑树调整的所有可能情况，对应了代码注释的 4 个分支。</p>
<h3 id="红黑树拆分"><a href="#红黑树拆分" class="headerlink" title="红黑树拆分"></a>红黑树拆分</h3><p>在扩容的过程，普通节点需要重新映射，红黑树节点同样也需要。在将普通链表转成红黑树时，HashMap 通过两个额外的引用 next 和 prev 保留了原链表的节点顺序。这样再对红黑树进行重新映射时，完全可以按照映射链表的方式进行，这样就避免了将红黑树转成链后再映射的过程，在一定程度上提高了效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K, V&gt; map, HashMap.Node&lt;K, V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; b = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新链接到 lo 和 hi 列表，保持顺序</span></span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 红黑树节点仍然保留了 next 引用，因此仍可以按链表方式遍历红黑树。下面的循环是对红黑树节点进行分组，与普通链表操作类似</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (HashMap.TreeNode&lt;K, V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">            next = (HashMap.TreeNode&lt;K, V&gt;) e.next;</span><br><span class="line">            e.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                    loHead = e;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    loTail.next = e;</span><br><span class="line">                loTail = e;</span><br><span class="line">                ++lc;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                    hiHead = e;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hiTail.next = e;</span><br><span class="line">                hiTail = e;</span><br><span class="line">                ++hc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 两个 TreeNode 链表分组完毕 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 loHead 不为空，且链表长度小于等于 6，则将红黑树转成链表</span></span><br><span class="line">        <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                tab[index] = loHead.untreeify(map);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = loHead;</span><br><span class="line">                <span class="comment">// hiHead == null 时，表明扩容后，所有节点仍在原位置，树结构不变，无需重新树化</span></span><br><span class="line">                <span class="comment">// 否则，将 TreeNode 链表重新树化</span></span><br><span class="line">                <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                    loHead.treeify(tab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同上面逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index + bit] = hiHead;</span><br><span class="line">                <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                    hiHead.treeify(tab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中可以看到，重新映射红黑树的逻辑和重新映射链表的逻辑基本一致。不同的地方在于，重新映射后，会将红黑树拆分成两条由 TreeNode 组成的链表。如果链表长度小于等于 <code>UNTREEIFY_THRESHOLD</code>，则将链表转换成普通链表。否则根据条件重新将 TreeNode 链表树化。</p>
<h3 id="红黑树链化"><a href="#红黑树链化" class="headerlink" title="红黑树链化"></a>红黑树链化</h3><p>红黑树中仍然保留了原链表节点顺序，有了这个基础再将红黑树转成链表就简单多了，仅需要将 <code>TreeNode</code> 链表转成 Node 类型的链表即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 红黑树中仍然保留了原链表节点顺序。有个这个特点，再将红黑树转成链表就简单多了，仅需将 TreeNode 链表转成 Node 类型的链表即可。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> HashMap.<span class="function">Node&lt;K, V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 用于组织链表的头、尾指针</span></span><br><span class="line">       HashMap.Node&lt;K, V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 遍历 TreeNode 链表，并用 Node 替换</span></span><br><span class="line">       <span class="keyword">for</span> (HashMap.Node&lt;K, V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 替换节点类型</span></span><br><span class="line"><span class="comment">            *    Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">            *            return new Node&lt;&gt;(p.hash, p.key, p.value, next);</span></span><br><span class="line"><span class="comment">            *       &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           HashMap.Node&lt;K, V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">               hd = p;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               tl.next = p;</span><br><span class="line">           tl = p;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> hd;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>感觉没什么可总结的，写的已经很详细了。</p>
<p><strong>参考</strong></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653191907&idx=1&sn=876860c5a9a6710ead5dd8de37403ffc&chksm=8c990c39bbee852f71c9dfc587fd70d10b0eab1cca17123c0a68bf1e16d46d71717712b91509&scene=21#wechat_redirect" target="_blank" rel="noopener">什么是HashMap</a></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://gentryhuang.com/posts/8c0fc113/" title="集合 - HashMap" target="_blank" rel="external">https://gentryhuang.com/posts/8c0fc113/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>



<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gentryhuang.com" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h2 id="name" style="margin: -2px 0 5px 0">
        <a href="https://gentryhuang.com" target="_blank">
           <span class="text-dark">gentryhuang</span>
           <small class="ml-1x">xw</small>
        </a>
      </h2>
        <div>万丈高楼平地起</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/218dc61f/" title="集合 - ConcurrentHashMap"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/d38b32e5/" title="Java基础 - JDK动态代理"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  
<script type="text/javascript">
    var sc_project=12352980; 
    var sc_invisible=0; 
    var sc_security="3d83ff9f"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
</script>

<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/gentryhuang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2019 - 2022 gentryhuang
        
       
        <!-- 统计代码 -->
        <div class="publishby">
            <div class="statcounter">
                <a title="Web Analytics" href="http://statcounter.com/p12352980/summary/?guest=1" target="_blank">
                    <img class="statcounter" src="https://c.statcounter.com/12352980/0/3d83ff9f/0/" alt="Web Analytics">
               </a>
        </div>
    </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>