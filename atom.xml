<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gentryhuang‘s blog</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gentryhuang.com/"/>
  <updated>2022-04-14T09:04:39.765Z</updated>
  <id>https://gentryhuang.com/</id>
  
  <author>
    <name>gentryhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL - 乐观锁和悲观锁</title>
    <link href="https://gentryhuang.com/posts/3c450cc6/"/>
    <id>https://gentryhuang.com/posts/3c450cc6/</id>
    <published>2022-04-10T02:46:59.000Z</published>
    <updated>2022-04-14T09:04:39.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据库的锁机制是并发控制的重要手段，是保证数据正确性的最后的一道屏障。而锁的种类和范围，对并发控制的程度和效率又不大一样。本篇文章将围绕<strong>乐观锁和悲观锁</strong>，结合业务场景对这两个锁的实现进行说明。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设我们有张商品库存表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;item_stock&#96; (</span><br><span class="line">  &#96;id&#96; bigint(19) NOT NULL COMMENT &#39;主键&#39;,</span><br><span class="line">  &#96;account&#96; varchar(18) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;商家编码&#39;,</span><br><span class="line">  &#96;total_stock_num&#96; int(9) NOT NULL COMMENT &#39;总库存&#39;,</span><br><span class="line">  &#96;remain_stock_num&#96; int(9) NOT NULL COMMENT &#39;剩余库存&#39;,</span><br><span class="line">  &#96;extend_fields&#96; varchar(200) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;扩展字段&#39;,</span><br><span class="line">  &#96;gmt_create&#96; bigint(20) NOT NULL COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;gmt_update&#96; bigint(20) NOT NULL COMMENT &#39;更新时间&#39;,</span><br><span class="line">  &#96;last_ver&#96; int(10) NOT NULL COMMENT &#39;版本号&#39;,</span><br><span class="line">  &#96;is_valid&#96; tinyint(4) NOT NULL COMMENT &#39;是否有效&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COMMENT&#x3D;&#39;商品库存&#39;;</span><br></pre></td></tr></table></figure><p>其中商品库存表中有一个字段 <code>remain_stock_num</code> 表示当前该商品的库存量。假设有一个 iphone13 ，其 id 为 100 ，<code>remain_stock_num=10</code>。现在我们按照一般的库存扣减方法进行操作，程序流程如下：</p><ol><li>step1: 查出商品剩余库存量<br>select remain_stock_num from item_stock where id = 100;</li><li>step2: 还有剩余库存，则录单<br>insert into order(id,item_id) values(null,100);</li><li>step3: 扣减商品库存<br>update item_stock set remain_stock_num = #{num} where id = 100;</li></ol><p>上述流程咋一看好像没有问题，在没有并发的情况下确实没有问题。那我们看存在并发的情况，操作序列如下：</p><table><thead><tr><th align="left">序列</th><th align="left">线程 A</th><th align="left">线程 B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">step1 查询还有 10 个</td><td align="left">step1 查询还有 10 个</td></tr><tr><td align="left">2</td><td align="left"></td><td align="left">step2 生成订单</td></tr><tr><td align="left">3</td><td align="left">step2 生成订单</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"></td><td align="left">step3 扣减库存 9 个</td></tr><tr><td align="left">5</td><td align="left">step3 扣减库存 2 个</td><td align="left"></td></tr></tbody></table><p>可以看到，上述流程会造成<strong>超卖</strong>问题。那如何解决上述问题呢，解决方式还是很多的，下面我们分别看如何使用悲观锁和乐观锁解决。</p><h2 id="乐观锁-amp-悲观锁"><a href="#乐观锁-amp-悲观锁" class="headerlink" title="乐观锁 &amp; 悲观锁"></a>乐观锁 &amp; 悲观锁</h2><p>乐观锁和悲观锁是锁的一种思想，并不局限于应用在数据库中。因此，不要把乐观锁和悲观锁狭隘地理解为数据库中的概念，更不要把它们和数据库中提供的锁机制混为一谈。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁是指在数据处理过程中，使数据资源处于锁定状态，<strong>数据库中使用锁机制实现</strong>。</p><p>悲观并发控制主要用于数据竞争激烈的场景，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 </p><h4 id="MySQL中的悲观锁"><a href="#MySQL中的悲观锁" class="headerlink" title="MySQL中的悲观锁"></a>MySQL中的悲观锁</h4><p>对任意记录进行修改前，先尝试为该记录加上排他锁(exclusive locking) 。如果加锁失败，说明该记录正在被修改，那么是选择等待还是抛出异常由业务方决定。</p><p>要使用悲观锁，需要关闭 MySQL 的自动提交属性，因为 MySQL 默认使用 <code>auto commit</code> 模式，也就是说，当执行一个更新操作后，MySQL 会立即提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit&#x3D;0</span><br></pre></td></tr></table></figure><p>我们回到场景中，看使用悲观锁如何解决上述问题。在上面的场景中，商品从查询出来到最后的库存扣减，是没有对这个库存进行持续锁定的，仅仅在扣减的时候会进行锁定，查询的时候使用的是快照读。而使用悲观锁的原理就是，在查询出商品的过程就把当前的数据锁定，直到扣减完库存再解锁。</p><p>这样一来，整个过程中因为数据被锁定了，就不会有其他请求来同时进行修改了。需要说明的是，使用悲观锁的前提是需要将要执行的 SQL 语句放在一个事务中，否则达不到锁定数据的目的。大致过程如下：</p><ol><li>setp0: 开启事务<br>begin;</li><li>step1: 查出商品剩余库存量<br>select remain_stock_num from item_stock where id = 100 for update;</li><li>step2: 还有剩余库存，则录单<br>insert into order(id,item_id) values(null,100);</li><li>step3: 扣减商品库存<br>update item_stock set remain_stock_num = remain_stock_num - #{num} where id = 100;</li><li>step4: 提交事务<br>commit;   </li></ol><p>需要说明的是，上述流程中，使用了 <code>select...for update</code> 的方式实现了悲观锁。此时，商品库存 id=100 的那条记录被锁定了，其它的事务要访问这个数据就必须等本次事务提交之后才能执行，这样就保证了并发修改的问题。</p><p>此外，对于 MySQL 的 InnoDB 引擎来说，它支持行锁，而锁是基于索引的，如果一条语句用不到索引（全表扫描），那么在加锁的时候会把整个表锁住（在默认的 RR 隔离级别下）。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>悲观锁其实是采用<strong>先加锁后访问</strong>的保守策略，为数据处理的安全提供了保证。</p><p>悲观锁的加锁时间可能会过长，这会导致其它事务无法访问，无疑<strong>影响了程序的并发访问性</strong>；此外，这样对数据库<strong>性能开销影响也很大</strong>，特别是对长事务而言，同时还会<strong>增加生产死活的概率</strong>。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁相对悲观锁而言，它认为数据一般情况下不会造成冲突，因此只会在数据进行提交的时候才会进行冲突与否的判断，如果发现冲突了，则返回冲突的信息，让业务方决定如何去做，一般业务方会选择进行重试，这也是乐观锁的由来。</p><h4 id="MySQL中的乐观锁"><a href="#MySQL中的乐观锁" class="headerlink" title="MySQL中的乐观锁"></a>MySQL中的乐观锁</h4><p>实现乐观锁一般有以下两种方式：</p><ul><li>使用版本号实现乐观锁：数据版本号或时间戳；</li><li>使用条件限制实现乐观锁：缩小乐观锁的范围，<strong>适用于只更新时做数据安全校验</strong>；</li></ul><p><strong>注意：</strong></p><ul><li>使用乐观锁进行更新操作，最好用主键或者唯一索引来更新，这样是行锁，否则更新会锁表；</li><li>乐观锁<strong>不依赖数据库的锁机制</strong>，但更新数据库数据是一个写操作，会触发数据库锁机制。</li></ul><h5 id="版本号实现乐观锁"><a href="#版本号实现乐观锁" class="headerlink" title="版本号实现乐观锁"></a>版本号实现乐观锁</h5><p>使用数据版本记录机制实现是乐观锁最常用的一种实现方式。一般是通过为数据表增加一个数字类型的 <code>version</code> 字段来实现。当读取数据时，将 version 的值一同读出，数据每更新一次就对 version 值加 1。当提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 version 值，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。流程如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-s-version-lock.png" alt></p><p>从上图可以看出，如果更新操作顺序执行，则数据的 version 一次递增，不会产生冲突。如果出现不同业务的事务操作同一版本的数据，那么先提交的会成功，后提交的会失败。<strong>注意，如果并发很大，会导致大量失败的情况</strong>。</p><p>使用时间戳也是类似的，就不再介绍。</p><p>需要说明的是，这种方式的乐观锁虽然更通用，但是也不是适用于所有的乐观锁场景，这个时候可以考虑条件限制实现的乐观锁。</p><h5 id="条件限制实现乐观锁"><a href="#条件限制实现乐观锁" class="headerlink" title="条件限制实现乐观锁"></a>条件限制实现乐观锁</h5><p>使用条件限制实现乐观锁，适用于更新时<strong>做数据安全校验</strong>，适合库存模型等，性能更高。</p><p>使用条件限制实现乐观锁还有一个重要原因，就是<strong>缩小锁范围</strong>。比如商品库存扣减时，特别是在秒杀等场景下，如果采用版本号实现的乐观锁，因为对于同一个版本的数据每次只有一个事务能更新成功，业务感知上就是大量操作失败。</p><p>缩小锁范围是指：采用条件限制，只会在不满足条件才会失败，这是一个范围概念，而版本号是等值的概念，后者失败率更高，并且这是可以避免的。</p><h5 id="乐观锁解决并发"><a href="#乐观锁解决并发" class="headerlink" title="乐观锁解决并发"></a>乐观锁解决并发</h5><p>我们回到场景中，看使用乐观锁如何解决上述问题。在上面的场景中，虽然扣减库存的时候会进行锁定，但是没有解决操作上的原子问题，也就是要修改的数据必须是查询到的数据。而使用乐观锁的原理就是，在查询出商品的时候会将数据的 version 也一同查出，然后在提交修改的时候在数据库层面进行 version 的对比，如果数据当前版本号与取出来的 version 值相等，则予以更新，否则认为是过期数据，不予更新。</p><p>使用版本号的乐观锁的大致过程如下：</p><ol><li>step1: 查出商品剩余库存量<br>select remain_stock_num from item_stock where id = 100;</li><li>step2: 还有剩余库存，则录单<br>insert into order(id,item_id) values(null,100);</li><li>step3: 扣减商品库存<br>update item_stock set remain_stock_num = remain_stock_num - #{num},version = version + 1 where id = 100 and version = #{version};</li></ol><p>这种乐观锁实现的并发控制虽然可以解决问题，但是锁的范围太大了，即业务感知上会有大量的操作失败。根本原因是，大量的库存查询确实存在，但是扣减的时候只有一个会成功。那如何尽可能地保证成功呢？可以采用条件限制实现的乐观锁方式，它的锁粒度更小，最大程度的提高并发能力。大概过程如下：</p><ol><li>step1: 查出商品剩余库存量<br>select remain_stock_num from item_stock where id = 100;</li><li>step2: 还有剩余库存，则录单<br>insert into order(id,item_id) values(null,100);</li><li>step3: 扣减商品库存<br>update item_stock set remain_stock_num = remain_stock_num - #{num} where id = 100 and remain_stock_num &gt;= #{num};</li></ol><p>通过 <code>remain_stock_num &gt;= #{num}</code> 条件，既实现了数据安全校验，又提高了并发性能。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>悲观锁和乐观锁各有优缺点，乐观锁适用于读多写少的情况下，即冲突真的很少发生的时候，这样可以省去不少的开销，加大系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致业务方会不断的进行 retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><p>不过随着互联网架构的演进，对并发和性能要求越来越高，悲观锁已经越来越少的被应用到生产环境中了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;数据库的锁机制是并发控制的重要手段，是保证数据正确性的最后的一道屏障。而锁的种类和范围，对并发控制的程度和效率又不大一样。本篇文章将围绕&lt;s
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://gentryhuang.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL - Double Write</title>
    <link href="https://gentryhuang.com/posts/e0c3e79e/"/>
    <id>https://gentryhuang.com/posts/e0c3e79e/</id>
    <published>2022-03-09T08:25:44.000Z</published>
    <updated>2022-04-14T08:54:16.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Double-Write-介绍"><a href="#Double-Write-介绍" class="headerlink" title="Double Write 介绍"></a>Double Write 介绍</h3><p>为了保证数据写入的可靠性，InnoDB 引入了 Double Write 特性。</p><p>具体来说，在刷脏页时先将脏页写入 double write 段中进行备份，写入成功后再将脏页写入数据文件中，保证页面的完整性。</p><h3 id="partial-write"><a href="#partial-write" class="headerlink" title="partial write"></a>partial write</h3><p>InnoDB的数据页默认是 16K ，而文件系统的数据页是 4K，磁盘IO操作是按页为单位进行读写的。这就可能出现数据库对一个 16K 的数据页操作后，触发刷盘动作，在该过程中可能数据库宕机导致没有完全将 16K 数据页写到磁盘，这种页就不是一个完整的页，这种现象称为 <strong>partial write</strong> 。</p><p>要知道，redo log 恢复数据的前提是页是完整的，数据页不完整是没办法使用 redo log 恢复的。那如果发生 <strong>partial write</strong> 该怎么办？为了解决这个问题， InnoDB 引入了 <strong>Double Write</strong> 特性。</p><h3 id="double-write-原理"><a href="#double-write-原理" class="headerlink" title="double write 原理"></a>double write 原理</h3><p>当 InnoDB 中有数据要变动，会先将其在 Buffer Poll 中的 page 进行更新，并且会记录对应的变动信息到 redo log 中，此时 Buffer Pool 中的该 page 就会被标记为 dirty page（脏页）。在适当的时候，如 Buffer Pool不够、dirty page 在 Buffer Pool 中的比例达到阈值设定等，这些 dirty page 会被刷新到磁盘。</p><p>在 dirty page 刷盘过程中，如果突然断电或系统奔溃，16K 的 dirty page 可能只有 4K 或 8K 被写到磁盘上。此时，磁盘上的数据页就被破坏了，是不完整的页，不可使用。</p><p>Double Write 机制就是为了解决这个问题的。当将脏数据刷新到磁盘时，会先将脏数据复制到内存中的 <code>double write buffer</code>，之后将该内存数据分 2 次，每次写入 1M 到共享表空间进行持久化备份。写入成功后，再将 dirty page 从 Buffer Pool 刷新到数据文件。</p><h3 id="Double-Write-恢复流程"><a href="#Double-Write-恢复流程" class="headerlink" title="Double Write 恢复流程"></a>Double Write 恢复流程</h3><p>dirty page 刷盘过程中，如果发生了系统宕机或断电，16K 的数据只有 4K 或者 8K 被写到磁盘上，InnoDB 崩溃恢复时发现 page 损坏（比较页面的checksum），直接从共享表空间的 double write 中找到该页的一个最近的副本，复制到数据文件，再应用 redo log 就完成了恢复过程。因为有副本所以也不担心表空间中数据页是否损坏。</p><p>如果在将 dirty page 从内存的 <code>double write buffer</code> 写到共享表空间过程中发生了宕机情况，此时数据文件中的 page 还是干净的，奔溃恢复时 InnoDB 可以利用 redo log 来进行数据的恢复。</p><h3 id="Double-Write-流程"><a href="#Double-Write-流程" class="headerlink" title="Double Write 流程"></a>Double Write 流程</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-db-write-process.png" alt></p><p>从 Double Write 流程图中可以看出，在奔溃恢复的时候，还使用到了 redo log 。这是因为有些 dirty page 的改动并没有写入到共享表空间的 double write 中，这部分数据需要使用 redo log 来恢复。</p><h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>一般来说，开启 Double Write 的性能会降低5%~25%的样子，但还是建议使用 Double Write 来保证数据写入的可靠性。</p><ul><li><p>是否开启 Double Write</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-db-write-param.jpg" alt></p><p>innodb_doublewrite 参数控制是否打开 Double Write，默认开启状态。</p></li></ul><ul><li><p>Double Write 使用情况</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-db-write-use.jpg" alt></p></li></ul><p>上图显示，从 Buffer Pool 一共将 22842199 个 page 复制到 <code>double write buffer</code> 中，一共刷盘 1959018 次到系统表空间。相当于每次刷盘了 22842199/1959018 ~= 11.67 个数据页。从这里也能看出，开启 Double Write 不会对效率产生很大影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Double-Write-介绍&quot;&gt;&lt;a href=&quot;#Double-Write-介绍&quot; class=&quot;headerlink&quot; title=&quot;Double Write 介绍&quot;&gt;&lt;/a&gt;Double Write 介绍&lt;/h3&gt;&lt;p&gt;为了保证数据写入的可靠性，InnoD
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://gentryhuang.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis原理 - SCAN 原理</title>
    <link href="https://gentryhuang.com/posts/c1861d8c/"/>
    <id>https://gentryhuang.com/posts/c1861d8c/</id>
    <published>2022-03-01T14:14:47.000Z</published>
    <updated>2022-04-14T08:57:00.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SCAN 命令在 Redis 早期版本中就支持，主要是为了解决 Redis 去批量获取 key 时造成的阻塞情况。如 KEYS 命令是获取所有命令，这是一种阻塞操作，这里就可以使用 SCAN 命令来尽可能避免 Redis 的阻塞。</p><p>SCAN 命令的复杂度虽然是 O(N)，但它是分次进行的，不会阻塞线程。</p><h2 id="SCAN-命令集"><a href="#SCAN-命令集" class="headerlink" title="SCAN 命令集"></a>SCAN 命令集</h2><p>SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令<strong>都用于增量地迭代集合类元素</strong>。</p><ul><li>SCAN 命令用于迭代当前数据库中的数据库键；</li><li>SSCAN 命令用于迭代集合键中的元素；</li><li>HSCAN 命令用于迭代哈希键中的键值对；</li><li>ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）;</li></ul><p>以上列出的四个命令都支持<strong>增量式迭代</strong>， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题。当 KEYS 命令被用于处理一个大的数据库时，又或者 SMEMBERS 命令被用于处理一个大的集合键时，它们可能会阻塞服务器达数秒之久。</p><p>不过，增量式迭代命令也有很大的缺点，比如在对键进行增量式迭代的过程中，键可能会被修改；字典在进行 rehash 时，缩容的情况会造成重复读取数据；在增量迭代过程，如果增加或删除元素在一定程度上也会导致问题（如果把增量迭代看作完整的过程）。所以增量式迭代命令只能对被返回的元素提供有限的保证。</p><h2 id="SCAN-命令的基本用法"><a href="#SCAN-命令的基本用法" class="headerlink" title="SCAN 命令的基本用法"></a>SCAN 命令的基本用法</h2><p> SCAN 、 SSCAN 、 HSCAN 和 ZSCAN 四个命令的工作方式都非常相似，它们的区别如下：</p><ul><li>SSCAN 命令、 HSCAN 命令和 ZSCAN 命令的第一个参数总是一个数据库键；</li><li>SCAN 命令则不需要在第一个参数提供任何数据库键 —— 因为它迭代的是当前数据库中的所有数据库键。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> SCAN 命令</span></span><br><span class="line">127.0.0.1:6379&gt; SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]</span><br><span class="line"><span class="meta">#</span><span class="bash"> SSCAN 命令</span></span><br><span class="line">127.0.0.1:6379&gt; SSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><p>SCAN 命令是一个基于游标的迭代器，也就是 SCAN 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。</p><p>当 SCAN 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>以下是一个 SCAN 命令的迭代过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) "17"</span><br><span class="line">2)  1) "key:12"</span><br><span class="line">    2) "key:8"</span><br><span class="line">    3) "key:4"</span><br><span class="line">    4) "key:14"</span><br><span class="line">    5) "key:16"</span><br><span class="line">    6) "key:17"</span><br><span class="line">    7) "key:15"</span><br><span class="line">    8) "key:10"</span><br><span class="line">    9) "key:3"</span><br><span class="line">    10) "key:7"</span><br><span class="line">    11) "key:1"</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 17</span><br><span class="line">1) "0"</span><br><span class="line">2) 1) "key:5"</span><br><span class="line">   2) "key:18"</span><br><span class="line">   3) "key:0"</span><br><span class="line">   4) "key:2"</span><br><span class="line">   5) "key:19"</span><br><span class="line">   6) "key:13"</span><br><span class="line">   7) "key:6"</span><br><span class="line">   8) "key:9"</span><br><span class="line">   9) "key:11"</span><br></pre></td></tr></table></figure><p>从上面的示例可以看到， SCAN 命令的回复是一个包含两个元素的数组， 第一个数组元素是用于进行下一次迭代的新游标， 而第二个数组元素则是一个数组， 这个数组中包含了所有被迭代的元素。</p><p>在第二次调用 SCAN 命令时， 命令返回了游标 0 ， 这表示迭代已经结束， 整个数据集已经被完整遍历过了。以 0 作为游标开始一次新的迭代， 一直调用 SCAN 命令， 直到命令返回游标 0 ， 我们称这个过程为一次完整遍历。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>SCAN 命令、 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都返回一个包含两个元素的 multi-bulk 回复： </p><ul><li>回复的第一个元素是字符串表示的无符号 64 位整数（游标）</li><li>回复的第二个元素是另一个 multi-bulk 回复， 这个 multi-bulk 回复包含了本次被迭代的元素。</li></ul><p>SCAN 命令返回的每个元素都是一个数据库键。</p><p>SSCAN 命令返回的每个元素都是一个集合成员。</p><p>HSCAN 命令返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。</p><p>ZSCAN 命令返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。</p><h3 id="SCAN-选项"><a href="#SCAN-选项" class="headerlink" title="SCAN 选项"></a>SCAN 选项</h3><h4 id="COUNT-选项"><a href="#COUNT-选项" class="headerlink" title="COUNT 选项"></a>COUNT 选项</h4><p>虽然增量式迭代命令不保证每次迭代所返回的元素数量， 但我们可以使用 <code>COUNT</code> 选项， 对命令的行为进行一定程度上的调整。 <code>COUNT</code> 选项的作用就是让用户告知迭代命令， 在每次迭代中应该从数据集里返回多少元素。注意， <code>COUNT</code> 选项只是对增量式迭代命令的一种提示，它只是一个参考值，因为 Redis 扫描数据是以哈希桶为单位的。</p><ul><li><code>COUNT</code> 参数的默认值为 <code>10</code> ；</li><li>在迭代一个足够大的、由哈希表实现的数据库、集合键、哈希键或者有序集合键时， 如果用户没有使用 <code>MATCH</code> 选项， 那么命令返回的元素数量通常和 <code>COUNT</code> 选项指定的一样， 或者比 <code>COUNT</code> 选项指定的数量稍多一些。</li><li>在迭代一个编码为整数集合（intset，一个只由整数值构成的小集合）、 或者编码为压缩列表（ziplist，由不同值构成的一个小哈希或者一个小有序集合）时， 增量式迭代命令通常会无视 <code>COUNT</code> 选项指定的值， 在第一次迭代就将数据集包含的<strong>所有元素</strong>都返回给用户。</li></ul><h4 id="MATCH-选项"><a href="#MATCH-选项" class="headerlink" title="MATCH 选项"></a>MATCH 选项</h4><p>和<code>keys</code>命令一样， 增量式迭代命令也可以通过提供一个 glob 风格的模式参数， 让命令只返回和给定模式相匹配的元素， 这一点可以通过在执行增量式迭代命令时， 通过给定 <code>MATCH &lt;pattern&gt;</code> 参数来实现。</p><p>需要注意的是， 对元素的模式匹配工作是在命令从数据集中取出元素之后， 向客户端返回元素之前的这段时间内进行的， 所以如果被迭代的数据集中只有少量元素和模式相匹配， 那么迭代命令或许会在多次执行中都不返回任何元素。</p><h3 id="SCAN-命令的保证"><a href="#SCAN-命令的保证" class="headerlink" title="SCAN 命令的保证"></a>SCAN 命令的保证</h3><p>SCAN 命令， 以及其他增量式迭代命令， 在进行完整遍历的情况下可以为用户带来以下保证： 从完整遍历开始直到完整遍历结束期间， 一直存在于数据集内的所有元素都会被完整遍历返回； 这意味着， 如果有一个元素， 它从遍历开始直到遍历结束期间都存在于被遍历的数据集当中， 那么 SCAN 命令总会在某次迭代中将这个元素返回给用户。</p><p>然而因为增量式命令<strong>仅仅使用游标来记录迭代状态</strong>， 所以这些命令带有以下缺点：</p><ul><li>同一个元素可能会被返回多次。 处理重复元素的工作交由应用程序负责， 比如说， 可以考虑将迭代返回的元素仅仅用于可以安全地重复执行多次的操作上。</li><li>如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回， 也可能不会。</li></ul><p>因为迭代的所有状态都保存在游标里面， 而服务器无须为迭代保存任何状态， 所以客户端可以在中途停止一个迭代， 而无须对服务器进行任何通知。</p><p>使用间断的（broken）、负数、超出范围或者其他非正常的游标来执行增量式迭代并不会造成服务器崩溃， 但可能会让命令产生未定义的行为。未定义行为指的是， 增量式命令对返回值所做的保证可能会不再为真。只有两种游标是合法的：</p><ol><li>在开始一个新的迭代时， 游标必须为 <code>0</code> 。</li><li>增量式迭代命令在执行之后返回的， 用于延续（continue）迭代过程的游标。</li></ol><h3 id="SCAN-原理"><a href="#SCAN-原理" class="headerlink" title="SCAN 原理"></a>SCAN 原理</h3><p>Redis 使用了 Hash 表作为底层实现：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/data_structure/redis-practice-scan-1.png" alt></p><p>SCAN 命令就是对这个一维数组进行遍历，每次返回的游标值也都是这个数组的索引。如果不考虑字典的扩容缩容，直接按数组下标挨个遍历就行了。COUNT 参数表示遍历数据的数量，该值只是起到一个大致约束的作用，所以返回的结果取决于索引下挂接链表的长度，有些槽位可能是空的，还有些槽位上挂接的链表上的元素可能会有多个。</p><p>如果不考虑扩容与缩容，那么无论是从前遍历还是从后遍历都可以获取所有的key值。但是有扩容、缩容后就需要考虑遍历的<strong>准确性</strong>，是否存在重复遍历，是否存在遗漏的遍历。如果我们<strong>按照低位加法，即从前向后遍历</strong>，当扩容或者缩容时进行的rehash操作使得<strong>数据分散到不同的槽位，这就有可能发生重复遍历与遗漏遍历的情况</strong>。</p><p>因此，Redis 采用了<strong>高位加法进位</strong>计算游标的方式遍历集合，Redis 的 SCAN 命令遍历流程如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/data_structure/redis-practice-scan-2.png" alt></p><p>观察这张图，我们发现<strong>采用高位加法进位计算游标的遍历顺序，rehash 时游标指向的槽位在遍历顺序上是相邻的</strong>。这得益于 Redis rehash 机制:</p><ul><li>扩容时：原来属于 <code>1xx</code>槽位的所有元素分散到 <code>01xx</code>和 <code>11xx</code>槽位中，其中前者是原数组的槽位，后者是扩容的新数组的槽位；</li><li>缩容时：<code>1xx</code>槽位的所有元素由 <code>01xx</code>和11<code>xx</code>槽位中元素融合；</li></ul><p>假设当前即将要遍历 110 这个槽位 (橙色)，那么扩容发生时，当前槽位上所有的元素分散在槽位 0110 和 1110(深绿色)中，也就是在槽位的二进制数增加一个高位 0 或 1，其中 1110 就是通过<strong>高位加法进位</strong>算出的下个要扫描的槽位，该槽位对应了扩容的新数组的位置。这时我们可以直接从 0110 这个槽位开始往后继续遍历，0110 槽位之前的所有槽位都是已经遍历过的，这样就可以避免扩容后对已经遍历过的槽位进行重复遍历。注意，主线程在 <code>SCAN</code> 和 rehash 时只能进行一个。</p><p>再考虑缩容，假设当前即将要遍历 110 这个槽位 (橙色)，那么缩容时，当前槽位所有的元素分散在槽位 10(深绿色)和 110(橙色)中，其中槽位 10 也就是去掉槽位二进制最高位，这是通过<strong>高位加法进位</strong>算出的，该槽位对应了缩容的新数组的位置。这时我们可以直接从 10 这个槽位继续往后遍历，10 槽位之前的所有槽位都是已经遍历过的，但图中 010 这个槽位上的元素已经被遍历过了。可以理解为，对于遍历来说，缩容后 10 槽位的元素是 010 和 110 上挂接的元素的融合。</p><p>在使用SCAN命令时，<strong>不会漏key，但可能会得到重复的key，这主要和Redis的rehash机制有关</strong>。Redis的所有key存在一个全局的哈希表中，如果存入的key慢慢变多，在达到一定阈值后，为了避免哈希冲突导致查询效率降低，这个哈希表会进行扩容。与之对应的，key数量逐渐变少时，这个哈希表会缩容以节省空间。</p><ul><li>为什么不会漏 key：Redis在SCAN遍历全局哈希表时，采用<strong>高位加法进位</strong>的方式遍历哈希桶，当哈希表扩容后，通过这种算法遍历，旧哈希表中的数据映射到新哈希表，<strong>依旧会保留原来的先后顺序</strong>，这样就可以保证遍历时不会遗漏也不会重复。</li><li>为什么会得到重复的key：这个情况主要发生在哈希表缩容。已经遍历过的哈希桶在缩容时，可能会映射到新哈希表没有遍历到的位置，所以继续遍历就会对同一个key返回多次。</li></ul><p>SCAN是遍历整个实例的所有key，另外Redis针对Hash/Set/Sorted Set也提供了HSCAN/SSCAN/ZSCAN命令，用于遍历一个key中的所有元素，建议在获取一个bigkey的所有数据时使用，避免发生阻塞风险。</p><p>Hash/Set/Sorted Set元素数量比较少时，底层会采用intset/ziplist方式存储，如果以这种方式存储，在执行HSCAN/SSCAN/ZSCAN命令时，会无视count参数，直接把所有元素一次性返回。</p><p>在分片集群场景下 SCAN 命令是无法跨节点扫描的，只能是一个节点一个节点的进行扫描。</p><h3 id="SCAN-源码分析"><a href="#SCAN-源码分析" class="headerlink" title="SCAN 源码分析"></a>SCAN 源码分析</h3><p>Redis 对 SCAN 命令集处理的底层函数是 <code>scanGenericCommand</code> 。下面我们对该函数处理的主要过程进行说明。</p><h4 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// 默认是 10</span></span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">10</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 输入类型检查，必须针对 集合类型或者数据库</span></span><br><span class="line">    serverAssert(o == <span class="literal">NULL</span> || o-&gt;type == OBJ_SET || o-&gt;type == OBJ_HASH ||</span><br><span class="line">                 o-&gt;type == OBJ_ZSET);</span><br><span class="line">    <span class="comment">// 设置第一个选项参数的索引位置</span></span><br><span class="line">    <span class="comment">// 0    1      2      3</span></span><br><span class="line">    <span class="comment">// SCAN OPTION &lt;op_arg&gt;         SCAN 命令的选项值从索引 2 开始</span></span><br><span class="line">    <span class="comment">// HSCAN &lt;key&gt; OPTION &lt;op_arg&gt;  而其他 *SCAN 命令的选项值从索引 3 开</span></span><br><span class="line">    i = (o == <span class="literal">NULL</span>) ? <span class="number">2</span> : <span class="number">3</span>; <span class="comment">/* Skip the key argument if needed. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 解析参数</span></span><br><span class="line">    <span class="comment">// 如 zscan key cursor [MATCH pattern] [COUNT count]</span></span><br><span class="line">    <span class="comment">// 如 scan cursor [MATCH pattern] [COUNT count] [TYPE type]</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; c-&gt;argc) &#123;</span><br><span class="line">        j = c-&gt;argc - i;</span><br><span class="line">        <span class="comment">// 1.1 todo COUNT count 参数，指定了扫描哈希桶的个数</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">"count"</span>) &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 1.2 MATCH pattern 参数，指定 key 的匹配模式</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">"match"</span>) &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 1.3 特定类型参数 type ，只能用于 scan DB，也就是 scan 命令，不像 zscan 这种</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">"type"</span>) &amp;&amp; o == <span class="literal">NULL</span> &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 1.4 error 参数项无法识别</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyErrorObject(c, shared.syntaxerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给定了对象 o ，那么它必须是一个哈希对象或者集合对象，如果 o 为 NULL 的话，函数将使用当前数据库作为迭代对象。</p><h4 id="判断要扫描的是否是哈希表"><a href="#判断要扫描的是否是哈希表" class="headerlink" title="判断要扫描的是否是哈希表"></a>判断要扫描的是否是哈希表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/* Handle the case of a hash table. */</span></span><br><span class="line">    <span class="comment">// 处理哈希表的情况</span></span><br><span class="line">    ht = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 扫描数据库</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ht = c-&gt;db-&gt;dict;</span><br><span class="line">        <span class="comment">// set 数据类型，使用哈希表编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET &amp;&amp; o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        ht = o-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash 数据类型，使用哈希表编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH &amp;&amp; o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        ht = o-&gt;ptr;</span><br><span class="line">        count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// zset 数据类型，非压缩编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_ZSET &amp;&amp; o-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = o-&gt;ptr;</span><br><span class="line">        ht = zs-&gt;dict;</span><br><span class="line">        count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line">    &#125;  </span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断要扫描的集合，是否使用内存紧凑型结构。如果对象的底层实现为 ziplist 、intset 而不是哈希表，那么这些对象通常都只包含了少量元素， 因此，为了避免服务器记录迭代状态，我们将 ziplist 或者 intset 里面的所有元素都一次返回给调用者，无视 count 参数，并向调用者返回游标 cursor 0 。</p><h4 id="扫描哈希表"><a href="#扫描哈希表" class="headerlink" title="扫描哈希表"></a>扫描哈希表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"> <span class="comment">// 3.1 哈希表编码情况</span></span><br><span class="line">    <span class="keyword">if</span> (ht) &#123;</span><br><span class="line">        <span class="keyword">void</span> *privdata[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 我们将最大迭代次数设置为指定 COUNT 的 10 倍，因此如果哈希表处于病态状态（非常稀疏），我们可以避免以不返回或返回很少元素为代价而阻塞太多时间。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> maxiterations = count * <span class="number">10</span>;</span><br><span class="line">        privdata[<span class="number">0</span>] = keys;</span><br><span class="line">        privdata[<span class="number">1</span>] = o;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描约 count 数量的数据</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 返回下次扫描的游标</span></span><br><span class="line">            <span class="built_in">cursor</span> = dictScan(ht, <span class="built_in">cursor</span>, scanCallback, <span class="literal">NULL</span>, privdata);</span><br><span class="line">                <span class="comment">// 游标不为 0</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">cursor</span> &amp;&amp; </span><br><span class="line">                 <span class="comment">// 递减迭代次数</span></span><br><span class="line">                 maxiterations-- &amp;&amp; </span><br><span class="line">      <span class="comment">// 扫描数据量达到指定的 count (一般都会大于 count ，因此扫描是以一个桶为单位）。一个桶不够，会扫描多个桶来凑count 大小</span></span><br><span class="line">                 listLength(keys) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) count); </span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果 SCAN 操作的数据结构是哈希表，那么就会采用<strong>高位加法进位的方式遍历哈希表</strong>，具体实现在 <code>dictScan</code>函数中。从以上代码可以看出：</p><ul><li>COUNT 参数项起到大致约束作用，告知 Redis 大约扫描 count 个数据；</li><li>这里设置了最大扫描哈希桶（槽位）的数量为 10*count ，目的是防止遇到过多空的哈希桶，一直达不到 count 的条件阻塞主线程；</li></ul><h5 id="高位加法进位遍历"><a href="#高位加法进位遍历" class="headerlink" title="高位加法进位遍历"></a>高位加法进位遍历</h5><p>由于 Redis 使用的是渐进式 rehash 机制，因此当 SCAN 命令执行时处于 rehash 阶段，就需要同时扫描新表和旧表，然后将结果返回客户端。</p><h6 id="未处于-rehash-过程"><a href="#未处于-rehash-过程" class="headerlink" title="未处于 rehash 过程"></a>未处于 rehash 过程</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v, <span class="comment">// 游标</span></span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanBucketFunction *bucketfn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span> </span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de, *next;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 跳过空字典</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 没有处于迁移过程，迭代只有一个哈希表的字典</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="comment">// 指向哈希表</span></span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 记录哈希表的 mask</span></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向游标 v 对应的哈希桶</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果游标 v 对应的哈希桶非空，则遍历游标 v 对应桶中的所有节点</span></span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        v |= ~m0;</span><br><span class="line">        <span class="comment">// 1）倒置游标 v</span></span><br><span class="line">        v = rev(v);</span><br><span class="line">        <span class="comment">// 2）加 1</span></span><br><span class="line">        v++;</span><br><span class="line">        <span class="comment">// 3）倒置加1后的游标 v</span></span><br><span class="line">        v = rev(v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 正在迁移中，需要迭代两个哈希表</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 返回的游标是使用高位进位加法实现的</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据游标定位到哈希桶后，处理完后会紧接着计算下次使用的游标，而计算方法就是 <strong>高位加法进位</strong>。</p><p>下面举例进行说明：</p><p>假设当前哈希表有 4 个桶，也就是默认桶数量，使用 SCAN 命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCAN 0 MATCH * COUNT 1</span><br></pre></td></tr></table></figure><p>按照正规的操作步骤，假设得到一个完整的桶迭代顺序如下：</p><blockquote><p>0-&gt;2-&gt;1-&gt;3 ，转换成二进制为：00-&gt;10-&gt;01-&gt;11</p></blockquote><p>我们发现每次这个序列变化是，<strong>将游标倒置 -&gt; 加 1 -&gt; 再倒置</strong>。</p><p>要知道，普通二进制的加法，是从右往左相加、进位。而这个序列是从左往右相加、进位的。代码体现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1）倒置游标 v</span></span><br><span class="line">v = rev(v);</span><br><span class="line"><span class="comment">// 2）加 1</span></span><br><span class="line">v++;</span><br><span class="line"><span class="comment">// 3）倒置加1后的游标 v</span></span><br><span class="line">v = rev(v);</span><br></pre></td></tr></table></figure><h6 id="处于-rehash-过程"><a href="#处于-rehash-过程" class="headerlink" title="处于 rehash 过程"></a>处于 rehash 过程</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v, <span class="comment">// 游标</span></span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanBucketFunction *bucketfn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span> </span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de, *next;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 跳过空字典</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">        <span class="comment">// 3 正在迁移中，需要迭代两个哈希表</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 3.1 指向两个哈希表，即 0 号和 1 号哈希表</span></span><br><span class="line">        t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 确保 t0 比 t1 要小，即把字典中的两个哈希表较小的赋值给 t0</span></span><br><span class="line">        <span class="comment">// todo 这个是必须的，因为可能是扩容，也可能缩容。遍历顺序是先小表，再到表。</span></span><br><span class="line">        <span class="comment">// 扩容：小的是原哈希表</span></span><br><span class="line">        <span class="comment">// 缩容：小的是新哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (t0-&gt;<span class="built_in">size</span> &gt; t1-&gt;<span class="built_in">size</span>) &#123;</span><br><span class="line">            t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.3 记录两个哈希表的掩码</span></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line">        m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 注意，rehash 的单位是哈希桶，因此数据要么在 3.3 中取到，要在 3.4 中取到 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.3 迭代 t0哈希表</span></span><br><span class="line">        <span class="comment">// 根据游标 v 定位到桶，并迭代桶中的所有节点</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.4 迭代 t1 哈希表</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">            <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t1-&gt;table[v &amp; m1]);</span><br><span class="line">            <span class="comment">// 根据游标 v 定位到桶，并迭代桶中的所有节点</span></span><br><span class="line">            de = t1-&gt;table[v &amp; m1];</span><br><span class="line">            <span class="keyword">while</span> (de) &#123;</span><br><span class="line">                next = de-&gt;next;</span><br><span class="line">                fn(privdata, de);</span><br><span class="line">                de = next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment the reverse cursor not covered by the smaller mask.*/</span></span><br><span class="line">            v |= ~m1;</span><br><span class="line">            v = rev(v);</span><br><span class="line">            v++;</span><br><span class="line">            v = rev(v);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 当掩码差异覆盖的位不为零时继续</span></span><br><span class="line">            <span class="comment">// ^ 按位异或</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回的游标是使用高位进位加法实现的</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SCAN 命令处于 rehash 过程需要同时扫描新表和旧表，虽然扩容和缩容的情况使用的是同一套流程，但是意义上是不同的。下面对关键流程进行总结：</p><ol><li><p>根据字典中的两个哈希表的大小排序，将小的哈希表赋值给 t0，将大的哈希表赋值给 t1；</p></li><li><p>分别记录 t0、t1 的掩码值，用于后续根据游标计算桶的索引；</p></li><li><p>根据索引先后迭代 t0表、t1表；</p></li></ol><p>把 SCAN 扫描图再拿过来：</p><p><img src="/posts/c1861d8c/redis-practice-54.png" alt></p><p><strong>对于扩容来说，t0 是原数组，t1 是新数组：</strong></p><p>在读取游标 v 110 对应的槽位前，哈希表扩容了，此时原数组 t0 数组的 110 槽位的数据可能还在，也可能已经迁移到了新数组 t1 1110 槽位中。此时，SCAN 顺序是先 t0 的 110 槽位，再 t1 的 1110 槽位。可以看到，通过<strong>高位加法进位</strong>遍历，依旧会保留原来的先后顺序，这种情况可以保证遍历时不会遗漏也不会重复。</p><p><strong>对于缩容来说，t0 是新数组，t1 是原数组：</strong></p><p>在读取游标 v 110 对应的槽位前，哈希表缩容了，此时原数组 t1 数组的 110 槽位的数据可能还在，也可能已经迁移到了新数组 t0 10 槽位中。此时，SCAN 顺序是先 t0 的 10 槽位，再 t1 的 110 槽位。可以看到，通过<strong>高位加法进位</strong>遍历，虽然依旧会保留原来的先后顺序，但是出现了<strong>“往回读一个哈希桶”</strong>，要知道已经遍历过的哈希桶在缩容时，可能会映射到新哈希表没有遍历到的位置，所以继续遍历就会对同一个key返回多次。按照图中的就是，010 槽位的元素会被重复遍历，但 010 之前的都不会。</p><h4 id="扫描内存紧凑型结构"><a href="#扫描内存紧凑型结构" class="headerlink" title="扫描内存紧凑型结构"></a>扫描内存紧凑型结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"> <span class="comment">// 3.2 压缩模式，一次性返回所有数据，忽略 count</span></span><br><span class="line">    <span class="comment">// 3.2.1 整数编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int64_t</span> ll;</span><br><span class="line">        <span class="keyword">while</span> (intsetGet(o-&gt;ptr, pos++, &amp;ll))</span><br><span class="line">            listAddNodeTail(keys, createStringObjectFromLongLong(ll));</span><br><span class="line">        <span class="comment">// 游标返回 0</span></span><br><span class="line">        <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2.2 ziplist b编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH || o-&gt;type == OBJ_ZSET) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ziplistIndex(o-&gt;ptr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vll;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            ziplistGet(p, &amp;vstr, &amp;vlen, &amp;vll);</span><br><span class="line">            listAddNodeTail(keys,</span><br><span class="line">                            (vstr != <span class="literal">NULL</span>) ? createStringObject((<span class="keyword">char</span> *) vstr, vlen) :</span><br><span class="line">                            createStringObjectFromLongLong(vll));</span><br><span class="line">            p = ziplistNext(o-&gt;ptr, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 游标返回 0</span></span><br><span class="line">        <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Not handled encoding in SCAN."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果对象的底层实现为 ziplist 、intset 而不是哈希表，那么这些对象通常都只包含了少量元素， 因此会将 ziplist 或者 intset 里面的所有元素都一次返回给调用者，无视 count 参数。</p><h4 id="匹配过滤"><a href="#匹配过滤" class="headerlink" title="匹配过滤"></a>匹配过滤</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// 4 如果指定了 key 的匹配模式，那么对扫描的结果进行过滤</span></span><br><span class="line">    node = listFirst(keys);</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        robj *kobj = listNodeValue(node);</span><br><span class="line">        nextnode = listNextNode(node);</span><br><span class="line">        <span class="keyword">int</span> filter = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Filter element if it does not match the pattern. */</span></span><br><span class="line">        <span class="keyword">if</span> (use_pattern) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Filter an element if it isn't the type we want. */</span></span><br><span class="line">        <span class="keyword">if</span> (!filter &amp;&amp; o == <span class="literal">NULL</span> &amp;&amp; <span class="keyword">typename</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Filter element if it is an expired key. */</span></span><br><span class="line">        <span class="keyword">if</span> (!filter &amp;&amp; o == <span class="literal">NULL</span> &amp;&amp; expireIfNeeded(c-&gt;db, kobj)) filter = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* Remove the element and its associated value if needed. */</span></span><br><span class="line">        <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">            decrRefCount(kobj);</span><br><span class="line">            listDelNode(keys, node);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        node = nextnode;</span><br><span class="line">    &#125;</span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，对元素的模式匹配工作是在命令从数据集中取出元素之后， 向客户端返回元素之前的这段时间内进行的。</p><h4 id="返回扫描结果"><a href="#返回扫描结果" class="headerlink" title="返回扫描结果"></a>返回扫描结果</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 5 返回给客户端</span></span><br><span class="line">    <span class="comment">// 返回数据项是 2</span></span><br><span class="line">    addReplyArrayLen(c, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 第一项是 cursor</span></span><br><span class="line">    addReplyBulkLongLong(c, <span class="built_in">cursor</span>);</span><br><span class="line">    <span class="comment">// 第二项是值或是键值值，值：set和zset ，键值对：hash</span></span><br><span class="line">    addReplyArrayLen(c, listLength(keys));</span><br><span class="line">    <span class="keyword">while</span> ((node = listFirst(keys)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        robj *kobj = listNodeValue(node);</span><br><span class="line">        addReplyBulk(c, kobj);</span><br><span class="line">        decrRefCount(kobj);</span><br><span class="line">        listDelNode(keys, node);</span><br><span class="line">    &#125;</span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Redis 提供的 SCAN 命令就是用于增量迭代的。这个命令可以每次返回少量的元素，所以非常适合用来处理大的数据集的迭代。常见的使用场景如下：</p><ul><li>替代阻塞式的 <code>KEYS</code> 命令；</li><li>替代复杂度过高的集合查询命令，如 <code>SMEMBERS</code>、<code>LRANGE</code> 等。<br>虽然 SCAN 命令在效率上具有优势，但是也要注意它的缺陷，如有重复读取的可能、扫描过程对键值对的增删支持不友好。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;SCAN 命令在 Redis 早期版本中就支持，主要是为了解决 Redis 去批量获取 key 时造成的阻塞情况。如 KEYS 命令是获取所
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="SCAN" scheme="https://gentryhuang.com/tags/SCAN/"/>
    
  </entry>
  
  <entry>
    <title>队列 - DelayQueue</title>
    <link href="https://gentryhuang.com/posts/db98efcf/"/>
    <id>https://gentryhuang.com/posts/db98efcf/</id>
    <published>2022-02-26T00:45:53.000Z</published>
    <updated>2022-05-10T08:52:29.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>DelayQueue 是一个<strong>线程安全的、无界的、延时阻塞</strong>的队列。线程安全体现在使用 <code>ReentrantLock</code> 保证并发安全；无界队列体现在内部使用 <code>PriorityQueue</code> 优先级队列作为容器维护元素；延时阻塞体现在队列元素必须实现 Delayed 接口，使元素对象成为<strong>延时对象</strong>。此外，Delayed 接口继承了 Comparable 接口，这样元素的优先级也就能保证了。</p><p>DelayQueue 保证<strong>只有在延迟期满时才能从中取出元素</strong>，否则就要阻塞等待剩余的到期时间。DelayQueue 相关的 UML 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/delay-queue-1.png" alt></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>DelayQueue 相关源码结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/delay-queue-2.png" alt></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证线程安全的锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记取元素时是否有线程在排队，减少不必要的竞争</span></span><br><span class="line">    <span class="comment">// leader 不为空，说明有线程在等待元素，后来的线程乖乖地等着就行了，直到被唤醒</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否可获取元素的条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>lock：</strong>用于并发控制的可重入独占锁；</li><li><strong>available：</strong>获取元素时，如果队列为空，则线程进入该条件队列等待队列非空；</li><li><strong>q：</strong>优先级队列，DelayQueue 把元素的存储和维护交给了优先级队列，在上层进行并发控制和延迟处理逻辑；</li><li><strong>leader：</strong>标记在取元素的过程中等待的线程，有了这个标记可以减少不必要的竞争；</li><li><strong>E extends Delayed：</strong>说明队列元素必须实现 Delay 接口，这个是延时的关键；</li></ul><p>从属性可以知道，DelayQueue 主要是用优先级队列 PriorityQueue 来实现，并使用重入锁和条件来控制并发安全。由于优先级队列可以看作是无界的，所以这里只需要一个非空条件就可以了。</p><h3 id="Delayed"><a href="#Delayed" class="headerlink" title="Delayed"></a>Delayed</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在给定的时间单位内返回与此对象关联的剩余延迟</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 剩余的延迟；零或负值表示延迟已经过去</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Delayed 是一个继承自 Comparable 的接口，并且定义了一个 getDelay 方法，用于表示还有多少时间到期，到期了应返回小于等于 0 的数值。DelayQueue 要求其中的元素必须实现 Delayed 接口，这有两个意义：</p><ul><li>DelayQueue 内部是使用 PriorityQueue 这个优先级队列来存放和维护元素的，也就是说元素必须要有一定的顺序，而 DelayQueue 继承了 Comparable 接口，因此有序性就可以交给使用方了；</li><li>DelayQueue 是一个具有延时特性的队列，而 Delayed 接口的 getDelay 方法就可以描述元素的到期时间，元素通过实现该接口成为延迟对象；</li></ul><p><strong>注意：</strong>根据 DelayQueue 队列的意义，一般我们是将元素的剩余延迟时间作为元素优先级的，这样的话在队列头的元素一定具有最小的剩余延时时间（最先过期）。这个逻辑是在 Comparable 接口的比较方法中完成。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个空的 DelayQueue </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定集合创建 DelayQueue </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection of elements to initially contain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment"> *         of its elements are null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DelayQueue 构造方法本身没有什么可说的，我们对隐藏的两个信息进行说明：</p><ul><li>DelayQueue 中封装的 PriorityQueue 在实例化时就创建了，使用的是默认的构造方法；</li><li>DelayQueude 中封装的 PriorityQueue 对象是通过其默认构造方法创建的，也就意味着底层使用的是小顶堆，而且是根据元素自然顺序排序；</li></ul><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>由于 DelayQueue 内部使用的是优先级队列 PriorityQueue ，可以认为它是无界的，所以不会出现队列满了而阻塞入队线程的情况，因此入队的方法其实都是一样的。</p><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此延迟队列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是对 offer 方法的简单封装调用。</p><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此延迟队列。由于队列是无限的，这个方法永远不会阻塞。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是对 offer 方法的简单封装调用。</p><h4 id="超时等待-offer"><a href="#超时等待-offer" class="headerlink" title="超时等待 offer()"></a>超时等待 offer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此延迟队列。由于队列是无限的，这个方法永远不会阻塞。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout This parameter is ignored as the method never blocks 此参数被忽略，因为该方法从不阻塞</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit This parameter is ignored as the method never blocks 此参数被忽略，因为该方法从不阻塞</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="offer"><a href="#offer" class="headerlink" title="offer()"></a>offer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此延迟队列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将元素加入到优先队列中，会自动保证优先级</span></span><br><span class="line">        q.offer(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果添加的元素是堆顶元素</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            <span class="comment">// leader 需要置空，因为现在堆顶出现了新的元素，可能添加的时候就要过期，因此需要让等待的线程尝试获取下，</span></span><br><span class="line">            <span class="comment">// 因此 leader 这个等待获取堆顶元素的标记可以置空了</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒可取条件队列上等待的线程，让其尝试获取元素</span></span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法是入队的核心方法，还是比较简单的，下面对关键点进行说明：</p><ol><li>在添加元素时需要加锁成功才行，保证了线程安全；</li><li>添加元素到优先级队列，一般都会成功，因为优先级队列可以认为是无界的；</li><li><strong>如果添加的元素成为了堆顶元素，就需要特别处理：</strong><ul><li>因为新添加的元素成为了堆顶元素，这个元素可能就要过期，因此需要对等待进行处理；</li><li>将正在等待堆顶的元素的标志置空和唤醒条件队列上等待的线程来<strong>尽可能及时</strong>获取堆顶元素；</li></ul></li><li>释放锁；</li></ol><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>DelayQueue 是一个延时阻塞队列，入队不会出现阻塞的情况，因为内部使用的优先级队列 PriorityQueue 可以认为是无界的。但是出队时可能会遇到队列为空的情况，这时会出现三种情况：阻塞式出队、非阻塞式出队以及阻塞超时出队。下面我们依次说明。</p><h4 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h4><p>出队阻塞方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检索并移除队列的头部元素，如有必要，则阻塞等待直到队列上有一个具有到期的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this queue 队列头部元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125; 中断异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取堆顶元素</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为空则进入等待，阻塞式获取元素</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 堆顶不为空</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取元素的超时时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="comment">// 判断是否到期，到期直接弹出即可</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 执行到这里，说明堆顶元素还没有到期，不能弹出*/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 要进入等待了，需要设置为 null</span></span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检验前面是否已有等待获取元素的线程，有的话就直接进入等待（快速进入等待）</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 还没有等待获取元素的线程，就把自己设置为等待线程，然后进入超时等待</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 等待的时间是，堆顶元素剩余的过期时间</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 唤醒后就把 leader 置空</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 没有等待元素的线程，并且队列还有数据，就唤醒下一个线程来取（如果有的话）</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队本身逻辑还是比较简单的，先判断堆顶元素是否为空，为空就直接阻塞等待；不为空也不能直接弹出，还要先判断堆顶元素是否到期了，没到期就等待剩余过期时间后再尝试获取、判断，到期了就直接弹出即可。</p><p>出于线程安全性、线程通信等方面的考虑，整个逻辑相对更完整和复杂一些：</p><ol><li>只有获取到锁才能进行出队操作；</li><li>判断堆顶元素是否为空，为空的话直接阻塞等待；</li><li>判断堆顶元素是否到期，到期了直接调用优先级队列的poll()弹出元素；</li><li>没到期，再根据等待标志 leader 快速判断前面是否有其它线程在等待，有则直接进入等待直到被唤醒，<strong>以减少不必要的竞争</strong>；</li><li>如果在此之前没有其它线程等待获取元素，则把自己设置为等待标记，这样可以让后续获取元素的线程直接进入等待；然后当前线程等待剩余的过期时间后会再尝试获取元素；</li><li>获取到元素之后再尝试唤醒下一个等待的线程；</li><li>释放锁；</li></ol><p><strong>注意：</strong>该方法使用自旋的作用，一方面是阻塞式获取，必须要返回一个到期的元素；另一方面是防止假唤醒；</p><p>这里我们不难看出，如果所有其他线程因为 leader 标志而阻塞等待，此时刚好进来一个最先过期的元素，那么是不是只能等待线程自动醒来呢？其实不是的，在 offer 方法中会判断这种情况，如果加入的是最先过期的元素，那么会唤醒一个阻塞线程，以通知尽快获取元素。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><p>出队非阻塞方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检索并删除队列的头部元素，如果队列没有具有到期的元素，则返回 null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回到期的元素，否则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从优先队列中获取元素</span></span><br><span class="line">        E first = q.peek();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果为空，或者没有到期，则返回空</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 到期则取出堆顶元素</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> q.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poll 方法相对 take 方法是快速失败，没有元素或元素没有到期不会等待，而是直接返回 null。</p><p>同样的套路，DelayQueue 在 take 方法和 poll 方法之间进行了折中，可以超时等待获取元素。具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 检索并删除队列的头部元素，如有必要，等待直到队列上有一个具有到期的元素，或指定的等待时间过期。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the head of this queue, or &#123;<span class="doctag">@code</span> null&#125; if the</span></span><br><span class="line"><span class="comment">  * specified waiting time elapses before an element with</span></span><br><span class="line"><span class="comment">  * an expired delay becomes available</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="comment">// 计算超时等待的时长</span></span><br><span class="line">     <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 自旋</span></span><br><span class="line">         <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">             <span class="comment">// 获取堆顶元素</span></span><br><span class="line">             E first = q.peek();</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 队列为空，则进入超时等待</span></span><br><span class="line">             <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 等待时间到了，还是为空，则返回 null</span></span><br><span class="line">                 <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                     nanos = available.awaitNanos(nanos);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 队列非空</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 获取元素的超时时间</span></span><br><span class="line">                 <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 判断是否到期，到期直接弹出即可</span></span><br><span class="line">                 <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">return</span> q.poll();</span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">/* 执行到这里，说明堆顶元素还没有到期，还不能弹出*/</span></span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 判断超时时间到了没</span></span><br><span class="line">                 <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                 first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">// 当前超时小于到期剩余时间，或者前面已经有等待的线程了</span></span><br><span class="line">                 <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</span><br><span class="line">                     nanos = available.awaitNanos(nanos);</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                     Thread thisThread = Thread.currentThread();</span><br><span class="line">                     leader = thisThread;</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">                         </span><br><span class="line">                         <span class="comment">// 计算剩余等待时长</span></span><br><span class="line">                         nanos -= delay - timeLeft;</span><br><span class="line">                     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                         <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                             leader = <span class="keyword">null</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">             available.signal();</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取堆顶元素但不删除</span></span><br><span class="line">        <span class="keyword">return</span> q.peek();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 从队列中删除指定元素（如果存在），无论它是否已过期。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 从优先级队列中删除该元素</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> q.remove(o);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 释放锁</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>DelayQueue 主要适用于定时任务。任务调度系统能够相对准确的把握任务的执行时间。为了具有调用行为，存放到 DelayDeque 的元素必须实现 Delayed 接口。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>DelayQueue 是一个线程安全的、无界的、延时阻塞队列，它使用的是优先级队列 PriorityQueue + 时间维度（到期时间）来实现。具体来说，是在队列的基础上增加了时间维度的优先级，然后通过锁和条件变量来控制入队和出队流程。</p><p>DelayQueue 为了减少不必要的竞争，使用了 <code>Thread leader</code> 来进行优化，作为快速进入条件队列等待的标志。</p><p>ScheduledThreadPoolExecutor 同样支持延时任务，它内部使用的阻塞队列是自己定义的内部类 DelayedWorkQueue ，这个内部类的功能和 DelayQueue 基本一样，唯一区别点是 DelayedWorkQueue 没有直接使用优先级队列 PriorityQueue，而是使用数组又实现了一遍优先级队列，本质上是没什么区别的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;DelayQueue 是一个&lt;strong&gt;线程安全的、无界的、延时阻塞&lt;/strong&gt;的队列。线程安全体现在使用 &lt;code&gt;Reent
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
      <category term="Queue" scheme="https://gentryhuang.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>队列 - PriorityQueue</title>
    <link href="https://gentryhuang.com/posts/62ea789a/"/>
    <id>https://gentryhuang.com/posts/62ea789a/</id>
    <published>2022-02-12T03:38:34.000Z</published>
    <updated>2022-05-10T02:39:06.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>队列是一种<strong>先进先出（FIFO）的数据结构</strong>。但有些情况下，操作的数据可能带有优先级，出队时需要优先级高的元素先出队列，这种数据结构就是<strong>优先级队列</strong>，也是我们今天的主角 <code>PriorityQueue</code>。</p><p>一般来说，优先级队列使用堆来实现，关于堆的简单介绍可以参考这里 <a href="https://gentryhuang.com/posts/d917ae55/">堆的简单介绍</a>。PriorityQueue 正是通过堆来实现优先级队列的。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>PriorityQueue 相关源码结构如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/priority-queue-1.png" alt></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7720805057305804111L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级队列中的元素数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较器，如果优先级队列使用元素的自然顺序，则为 null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级队列的写次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">        </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>PriorityQueue 主要有以下五个属性，下面对每个属性的作用进行说明：</p><ul><li><strong>DEFAULT_INITIAL_CAPACITY</strong> PriorityQueue 的默认容量为 11；</li><li><strong>queue:</strong> PriorityQueue 核心是使用堆来组织数据，该数组就是用来存放元素的；</li><li><strong>size:</strong> 用来记录优先级队列中元素的个数，也就是数组中的元素个数；</li><li><strong>comparator:</strong> 元素比较器，在 PriorityQueue 中有两种方式比较元素，一种是元素的自然顺序，这个要求元素实现 Comparable 接口；另一种是通过指定的比较器来比较，如果使用元素自然顺序，则该属性可以为 null；</li><li><strong>modCount:</strong> 记录对 PriorityQueue 进行写操作的次数，用于实现 <code>fast-fail</code>。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个默认初始容量为 11 的 PriorityQueue，它根据元素的自然顺序对其元素进行排序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个指定容量大小的 PriorityQueue，它根据元素的自然顺序对其元素进行排序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity the initial capacity for this priority queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> initialCapacity&#125; is less</span></span><br><span class="line"><span class="comment"> *                                  than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个默认初始容量为 11 的 PriorityQueue，它根据指定的比较器对其元素进行排序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator the comparator that will be used to order this</span></span><br><span class="line"><span class="comment"> *                   priority queue.  If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable</span></span><br><span class="line"><span class="comment"> *                   natural ordering&#125; of the elements will be used.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity  优先级队列的初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator       将用于排序此优先级队列的比较器。如果为 null，将使用元素的 &#123;<span class="doctag">@linkplain</span> Comparable 自然排序&#125;。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> initialCapacity&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">    <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数组容器</span></span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置元素比较器，可以为空</span></span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此优先级队列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException   if the specified element cannot be</span></span><br><span class="line"><span class="comment"> *                              compared with elements currently in this priority queue</span></span><br><span class="line"><span class="comment"> *                              according to the priority queue's ordering</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用 offer 方法</span></span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，add 方法是直接调用 offer 方法的。</p><h4 id="offer"><a href="#offer" class="headerlink" title="offer()"></a>offer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此优先级队列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功返回 true，不成功会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException  要添加的元素不能和队列中的元素比较</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 要添加的元素为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 元素不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递增写次数</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取优先级队列元素个数</span></span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素个数达到最大容量，需要先扩容</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素个数加 1</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列还没有元素，直接插入到数组第一个位置，不需要进行比较、调整堆</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列有元素，做自下而上的堆调整</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>要添加的元素不能为空（空了怎么参与比较呢）；</li><li>在添加元素之前，判断队列中元素个数是否达到队列最大容量阈值；</li><li>将队列中元素个数加 1；</li><li>如果队列中没有元素，那么直接将元素放到数组的第一个位置，也就是下标为 0 的位置，这样就不需要执行比较、调整堆的流程了；</li><li>如果队列中有元素，就执行堆的<strong>自下而上</strong>的调整逻辑；</li></ol><h5 id="grow"><a href="#grow" class="headerlink" title="grow()"></a>grow()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity 所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列原始长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="comment">// 旧容量小于 64 时，容量翻倍 + 2</span></span><br><span class="line">    <span class="comment">// 旧容量大于等于 64 ，容量只增加旧容量的一半</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">            (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">            (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 保证新容量的大小不溢出</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建出一个新容量大小的新数组并把旧数组元素拷贝过去</span></span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grow 方法是 PriorityQueue 内部使用的方法，当队列中的元素个数达到队列容量时，就会使用该方法进行扩容。PriorityQueue 扩容可总结为 <strong>“一策略、一注意事项”</strong>，具体如下：</p><ul><li><strong>扩容策略：</strong>当队列（数组）比较小（小于 64）时，容量扩大一倍 + 2；不小于 64 时，容量扩大一半；</li><li><strong>扩展注意事项：</strong>计算出新的容量后，需要限制最大容量，不能超过 <code>Integer.MAX_VALUE</code>，这个是由 <code>hugeCapacity</code> 方法控制的： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 最大容量限制</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> minCapacity</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 容量不能 &lt; 0</span></span><br><span class="line">     <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 最大使用 Integer.MAX_VALU</span></span><br><span class="line">     <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">             Integer.MAX_VALUE :</span><br><span class="line">             MAX_ARRAY_SIZE;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="siftUp"><a href="#siftUp" class="headerlink" title="siftUp()"></a>siftUp()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k the position to fill 计划要插入的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the item to insert 要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据是否有比较器，使用不同的方法</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 使用比较器排序</span></span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 按照元素自然顺序</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会根据是否指定了元素比较器，进而执行不同的分支<strong>自下而上</strong>调整堆。由于无论是使用元素自然顺序比较，还是使用比较器比较，逻辑是一致的，下面我们以按照元素自然顺序排序（实现 Comparable 接口)为例进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 按照元素自然顺序排序（实现 Comparable 接口）调整堆</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> k 要填补的位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> x 要插入的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 转化类型，这要求元素必须实现 Comparable 接口，否则必然报错</span></span><br><span class="line">       Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">       <span class="comment">// 自下向上调整堆</span></span><br><span class="line">       <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 找到父节点的位置， 因为元素是从0开始的，所以减1之后再除以2</span></span><br><span class="line">           <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 父节点的值</span></span><br><span class="line">           Object e = queue[parent];</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 比较插入的元素的值与父节点的值，如果比父节点大，则跳出循环，否则交换位置</span></span><br><span class="line">           <span class="comment">// todo 从这里也能看出是小顶堆</span></span><br><span class="line">           <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 与父节点交换位置，父节点位置空出来了</span></span><br><span class="line">           queue[k] = e;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 此时，元素要插入的位置移到了父节点的位置，继续与父节点再比较以调整堆</span></span><br><span class="line">           k = parent;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 最后找到应该插入的位置，放入元素</span></span><br><span class="line">       queue[k] = key;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上述方法的逻辑纯粹是堆添加元素时<strong>自下而上</strong>的调整堆的过程，使堆满足堆的特性。下面对该方法的细节之处进行说明：</p><ul><li>参数 k 表示目标元素 x 要插入的位置，这个 k 起始值其实就是数组最后一个元素的下个位置。注意，数组的下标是从 0 开始的，因此在从下往上找父节点时，先要减 1 再除以 2 才能获取正确的父节点的下标；</li><li>从代码来看，如果比父节点小就与父节点交换位置，直到出现比父节点大或者比较到了根节点为止。这也可以看出，默认情况下 PriorityQueue 是一个小顶堆；</li></ul><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><h4 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回堆顶元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取堆顶元素但不删除；</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列元素个数减 1</span></span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列写操作次数递增</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列首元素</span></span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列末元素</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将队列末元素删除</span></span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队后队列中还有元素（因为移除的是堆顶元素，此时堆的特性不能满足，必须需要调整）</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将队列末元素移到队列首，再做自上而下的调整</span></span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回弹出的元素</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>队列为空，直接返回 null 即可；</li><li>队列非空，队列元素个数减 1；</li><li>将队列首元素弹出（此时堆顶元素就没了，堆的特性可能被破坏）；</li><li>取出队列末元素，将其作为<strong>参考的新的堆顶元素</strong>，为后续堆调整做准备；</li><li>如果队列在弹出元素后就为空了，那么就不需要调整堆了，否则需要做<strong>自上而下</strong>的堆调整；</li></ol><p><strong>注意：</strong>在出队的逻辑中，没有涉及到队列缩容的逻辑。</p><h5 id="siftDown"><a href="#siftDown" class="headerlink" title="siftDown()"></a>siftDown()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在位置 k 处插入项 x，即自上而下的堆调整。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k the position to fill 要填补的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the item to insert 要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据是否有比较器，选择不同的方法进行元素的比较，进而调整堆</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，该方法会根据是否指定了元素比较器，进而执行不同的分支<strong>自上而下</strong>调整堆。由于无论是使用元素自然顺序比较，还是使用比较器比较，逻辑是一致的，这次我们以指定比较器的方式进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据比较器，自上而下调整堆</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 本质：将要插入的元素放入到它应该在的位置</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> k 要填补的位置</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> x 要插入的元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 调整的时候，是按照二分的思想往下寻找子节点的，这里只比较一半就可以了</span></span><br><span class="line">     <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 不断往下比较</span></span><br><span class="line">     <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 寻找子节点位置，这里加 1 是因为元素从 0 号位置开始</span></span><br><span class="line">         <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 左子节点的值</span></span><br><span class="line">         Object c = queue[child];</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 右子节点的位置</span></span><br><span class="line">         <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果右子节点存在，那么取左右节点中较小的值</span></span><br><span class="line">         <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                 comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">             c = queue[child = right];</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果要插入元素比子节点都小，则结束，说明找到对应的位置了</span></span><br><span class="line">         <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果比较小的子节点还大，则交换位置</span></span><br><span class="line">         queue[k] = c;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 指针移动到子节点位置，继续往下调整堆</span></span><br><span class="line">         k = child;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 找到正确的位置，放入元素</span></span><br><span class="line">     queue[k] = x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>同样地，上述方法的逻辑存粹是堆删除元素时<strong>自上而下</strong>的调整堆的过程，使堆满足堆的特性。下面堆该方法的细节之处进行说明：</p><ul><li>参数 k 表示目标元素要插入的位置，这个 k <strong>起始值是被删除的元素所在的下标</strong>。从上往下找子节点时先从左子节点开始，由于数组的下标是从 0 开始的，因此要先除以 2 再加 1 才能获取正确的左子节点下标；</li><li>从代码来看，使用的是比较器，因此 PriorityQueue 是小顶堆还是大顶堆取决于比较器；</li></ul><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 从队列中移除指定的元素，如果元素不存在，则返回 false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this queue, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this queue changed as a result of the call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取指定元素在队列中的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果元素不存在，则返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果元素存在，则从队列中移除该元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 PriorityQueue 中移除指定的元素，需要执行两步操作：</p><ul><li>调用 indexOf 方法找到要移除的元素所在的下标；</li><li>调用 removeAt 方法将该下标所在元素置空，即删除该元素，然后从这个下标开始调整堆；</li></ul><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素在优先级队列（数组）中的下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回 -1 表示队列中没有该元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(queue[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="removeAt"><a href="#removeAt" class="headerlink" title="removeAt()"></a>removeAt()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中移除下标为 i 的元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">    <span class="comment">// 优先级队列写操作次数累加</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列数量减 1</span></span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是最后一个元素，直接删除即可</span></span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是最后一个元素，则需要从删除的位置，即下标 i 位置开始调整</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 moved 确实插入到了 i 位置，那么再尝试 自下而上调整堆</span></span><br><span class="line">        <span class="keyword">if</span> (queue[i] == moved) &#123;</span><br><span class="line">            siftUp(i, moved);</span><br><span class="line">            <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素过程涉及到的堆调整，和添加元素或弹出堆顶元素类似，唯一区别是前面两种是从数组末尾或数组的首开始调整，而上述方法是从<strong>中间位置</strong>开始调整的。逻辑都是一样的，唯一区别是在调整的位置。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>PriorityQueue 是一个优先级队列，内部使用数组作为存储数据的容器，<strong>元素的优先级依靠堆排序实现</strong>，排序的规则即可以根据元素自然顺序（元素实现 <code>Comparable</code> 接口），也可以根据自定义的元素比较器 <code>Comparator</code>。此外，该队列是一个无界队列(最大容量是 <code>Integer.MAX_VALUE</code> ，只会扩容不会缩容。</p><p>优先级队列 PriorityQueue 默认情况下是小顶堆，然而可以通过传入自定义的 Comparator 来实现大顶堆。注意，使用元素自然顺序只能实现小顶堆功能，从文中源码部分也能看出。具体如下：</p><blockquote><p>构造小顶堆：PriorityQueue small=new PriorityQueue&lt;&gt;();<br>构造大顶堆：PriorityQueue small=new PriorityQueue&lt;&gt;(Collections.reverseOrder());</p></blockquote><p>优先级队列 PriorityQueue 性能差，主要体现在添加元素、弹出元素时都有可能破坏堆的特性，为了保证堆的特性就需要调整堆。性能是和元素量成反比的。</p><p>优先级队列 PriorityQueue 是线程不安全的，从源码中也可以看出，没有使用锁机制，也没有使用 CAS 机制保证并发安全。与它对应的是 PriorityBlockingQueue 队列，这个队列是线程安全的，但是<strong>两者源码极其相似</strong>，后者使用了 <code>ReentrantLock lock</code> 和对应的 <code>Condition notEmpty</code> 以保证线程安全，其它的都类似。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;队列是一种&lt;strong&gt;先进先出（FIFO）的数据结构&lt;/strong&gt;。但有些情况下，操作的数据可能带有优先级，出队时需要优先级高的元素
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="Queue" scheme="https://gentryhuang.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 - 堆</title>
    <link href="https://gentryhuang.com/posts/d917ae55/"/>
    <id>https://gentryhuang.com/posts/d917ae55/</id>
    <published>2022-02-06T01:34:09.000Z</published>
    <updated>2022-05-10T02:34:29.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>堆是一种特殊的树，它有以下两个特点：</p><ul><li>堆是一颗完全二叉树；</li><li>堆中某个节点的值不大于或不小于父节点的值；</li></ul><p>其中，根节点的值是最大的堆叫做大顶堆，根节点的值是最小的堆叫做小顶堆。具体如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/data-structure/heap/heap-1.png" alt></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>前面也说了，堆是一颗完全二叉树。下图就是一颗完全二叉树，也是一个小顶堆：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/data-structure/heap/heap-2.png" alt></p><p>完全二叉树的节点都是比较紧凑的，并且具有一定的层次关系，所以可以使用数组来存储，这样比较节省空间。上图中的完全二叉树存放到数组中如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/data-structure/heap/heap-3.png" alt></p><p>这里为了方便描述，下标为 0 的位置不存储元素，从下标为 1 的位置开始存储元素。<strong>每层依次从左到右放到数组中，这样就可以保证父子节点的关系了</strong>。</p><ul><li>已知节点 8，那么 8 的父节点就是：5<code>/</code>2=2，也就是 5 这个节点的位置</li><li>已知节点 5，那么 5 的左右子节点分别是：2<code>*</code>2=4，也就是节点 7；2<code>*</code>2<code>+</code>1=5，也就是节点 8；</li></ul><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>堆中插入新的元素后，需要继续满足堆的两个特性：</p><ol><li>堆是一颗完全二叉树；</li><li>堆中某个节点的值要么不大于（或不小于）其父节点的值；</li></ol><p>为了满足特性 1，我们把新元素插入到最后一层的最后一个节点的后面，但是插入之后可能不再满足特性 2 ，这个时候就需要调整堆了。下面我们举例说明。</p><p>我们需要向前面的小顶堆中插入元素 2 ，我们把它放在 9 后面，这时虽然满足特性 1 ，但是不满足特性 2，这个时候就要调整堆。具体过程如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/data-structure/heap/heap-4.png" alt></p><p>上述调整过程的原则是，<strong>自下而上</strong>进行调整。</p><p><strong>从二叉树角度看：</strong>插入的节点与它的父节点相比，如果比父节点小，就交换它们的位置，重复这个过程，一直往上和父节点相比，直到比父节点大或者到根节点为止。<br><strong>从数组角度看：</strong>插入的节点与 <code>n/2</code> 位置的节点相比，如果比 <code>n/2</code> 位置的节点小，就交换它们的位置，再往前与 <code>n/4</code> 位置的节点相比，如果比 <code>n/4</code> 位置的节点小，就交换位置，以此类推，直到比 <code>n/(2^x)</code>位置的节点大或者到顶级父节点为止。</p><p>从插入元素的过程，我们可以知道插入元素的时间复杂度为 O(logn) 。</p><h3 id="弹出堆顶元素"><a href="#弹出堆顶元素" class="headerlink" title="弹出堆顶元素"></a>弹出堆顶元素</h3><p>从堆中弹出元素，同样需要继续满足堆的两个特性：</p><ol><li>堆是一颗完全二叉树；</li><li>堆中某个节点的值要么不大于（或不小于）其父节点的值；</li></ol><p>从堆顶弹出元素后，为了满足特性 1，我们把最有一个元素移到根节点（顶节点）的位置，但是不满足特性 2，这个时候需要调整堆。具体如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/data-structure/heap/heap-5.png" alt></p><p>上述调整过程的原则是，<strong>自上而下</strong>进行调整。</p><p><strong>从二叉树角度看：</strong>把最后一个节点放到堆顶，然后与左右子节点中较小的交换位置，重复这个过程，依次往下，直到其比左右子节点都小的或到达最后一层为止。<br><strong>从数组角度：</strong>把最后一个元素移到下标为 1 的位置，然后与下标为 2 和 3 的元素对比，发现 8 比 2 大，且 2 是下标为 2 和 3 中较小的，然后与 2 交换位置。依次类推，再和下标为 4 和 5 的元素对比，直到没有比其更小的元素或没有左右子节点为止。</p><p>从弹出堆顶元素的过程，我们可以知道对应的时间复杂度为 O(logn) 。</p><h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>建堆的过程其实就是依次插入元素的过程，一个元素的比较次数与它的高度成正比，建堆的时间复杂度为 O(n)。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>对于一个待排序的数组序列，可以将堆顶元素与第 n 个元素交换位置，再把前 n-1 个元素进行调整；再把堆顶元素与第 n-1 个元素交换位置，再把前 n-2 个元素进行调整；…..，以此类推。最后，数组中的元素就整个变成有序的了，排序也就完成了。</p><p>堆排序的时间复杂度为 O(nlogn)。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>堆是一种重要的数据结构，利用堆排序的场景有很多，比如 MySQL order by 语句可能会使用到堆排序；优先级队列会使用堆排序调整元素优先级；等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;堆是一种特殊的树，它有以下两个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆是一颗完全二叉树；&lt;/li&gt;
&lt;li&gt;堆中某个节点的值不大于或不小于父节点
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
  </entry>
  
  <entry>
    <title>并发 - LinkedBlockingQueue</title>
    <link href="https://gentryhuang.com/posts/5d52709c/"/>
    <id>https://gentryhuang.com/posts/5d52709c/</id>
    <published>2022-02-04T01:05:14.000Z</published>
    <updated>2022-05-10T02:31:31.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedBlockingQueue 是一个<strong>基于链表（单链表）</strong>实现的先进先出的阻塞队列，<strong>采用双锁技术</strong>，针对入队和出队操作分别使用了一把可重入的独占锁，在并发度上有一定的提升。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>LinkedBlockingQueue 相关的源码结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/linked-blocking-queue-1.png" alt></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存放的元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        E item;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 后继指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 节点封装元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node(E x) &#123;</span><br><span class="line">            item = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的容量，默认容量是 Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的头节点，其封装的元素一直都是 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的尾节点，last.next 一直是 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队 take、poll 使用的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待出队的条件，即队列非空条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队 put、offer 使用的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待入队的条件，即队列非满条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>LinkedBlockingQueue 用于存放元素的结构是一个<strong>单向链表</strong>，链表中的每个节点是一个 Node 结构。此外，LinkedBlockingQueue 定义了以下的变量来<strong>描述和维护</strong>这个单向链表：</p><ul><li><strong>capacity:</strong> 队列的容量，即约束单向链表节点数量；</li><li><strong>count:</strong> 队列中元素的个数，即单向链表有效节点的数量；</li><li><strong>head:</strong> 单向链表的头节点，不存储元素，起到获取链表节点的作用；</li><li><strong>last:</strong> 单向链表的尾节点，用于添加元素时构建链表；</li><li><strong>takeLock、notEmpty:</strong> 队列元素出队的锁和出队的等待条件；</li><li><strong>putLock、notFull:</strong> 元素入队的锁和入队的等待条件；</li></ul><p>相比 ArrayBlockingQueue 内部定义一个循环数组，出队和入队用的是同一把锁，LinkedBlockingQueue 内部则定义了一个链表结构，入队用的是 putLock 锁，出队用的是 takeLock 锁。可以看出，后者在并发度上更好一些。</p><p>这里我们可能有个疑问，那就是两把锁是怎么保证线程安全的呢？这个问题的答案留在后文。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认无界的队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建给定容量的队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity&#125; is not greater</span></span><br><span class="line"><span class="comment"> *                                  than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 容量大小不能 &lt;= 0</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置队列容量大小</span></span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 LinkedBlockingQueue 的构造方法可知：</p><ul><li>LinkedBlockingQueue 队列默认是无界的，也就是队列大小为 <code>Integer.MAX_VALUE</code> 。在使用的时候，我们最好传入容量，不然会有内存溢出的风险。</li><li><strong>LinkedBlockingQueue 队列内部的链表是在构造方法中初始化的</strong>。</li></ul><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>添加元素的方法，主要的流程是判断队列满的情况的处理，以及添加元素成功后尝试唤醒阻塞等待元素的线程。添加元素是在队列尾部添加。</p><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在此队列的尾部插入指定元素，如有必要，等待空间可用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 要添加的元素不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个节点存元素 e</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取入队锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列中元素个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列满了，则进入非满条件队列进行等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入队，链表操作，尾插法</span></span><br><span class="line">        enqueue(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并更新队列中元素个数</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 c+1 &lt; 队列容量，说明队列还可以继续添加元素，则唤醒在非满条件队列中等待的线程</span></span><br><span class="line">        <span class="comment">// 这里 c+1 是因为前面已经加入了一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放入队锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c == 0 说明原来queue是空的, 现在添加了元素，所以这里 signalNotEmpty 一下, 唤醒正在 poll/take 等待中的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>put 方法主要包括以下流程：</strong></p><ul><li>获取可中断的入队锁；</li><li>判断队列是否满了，满了则进入非满条件队列进行等待；</li><li>元素入队，链表的尾插操作；</li><li>元素入队后，如果队列还没满，那么可以继续添加元素，则唤醒在非满条件队列中等待的线程；</li><li>释放可中断的入队锁；</li><li>如果在添加元素之前，队列是空的，那么尝试唤醒正在 poll/take 等待中的线程；</li></ul><h5 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue()"></a>enqueue()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元素入队底层操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    <span class="comment">// 链表尾插法</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="signalNotEmpty"><a href="#signalNotEmpty" class="headerlink" title="signalNotEmpty()"></a>signalNotEmpty()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒等待获取元素的线程。仅从 put/offer 调用（通常不会锁定 takeLock。）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒前先拿到出队锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 唤醒阻塞在非空条件队列中的某个线程，以使其继续获取元素</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放出队锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="offer"><a href="#offer" class="headerlink" title="offer()"></a>offer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在不超出队列容量的情况下立即在此队列的尾部插入指定元素，成功时返回 true，如果此队列已满则返回 false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要添加的元素不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个节点存元素 e</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取入队锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列没有满，则入队元素，即链表尾插法</span></span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取并更新队列中元素个数</span></span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 c+1 &lt; 队列容量，说明队列还可以继续添加元素，则唤醒在非满条件队列中等待的线程</span></span><br><span class="line">            <span class="comment">// 这里 c+1 是因为前面已经加入了一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放入队锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c == 0 说明原来queue是空的, 现在添加了元素，所以这里 signalNotEmpty 一下, 唤醒正在 poll/take 等待中的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 count.get() &lt; capacity 不成立，直接释放锁，此时 c==-1</span></span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出上述方法和 put 方法基本一致，唯一区别点在，如果队列满了直接返回失败，不阻塞等待。</p><p>LinkedBlockingQueue 基于 offer 方法进行了优化，支持超时添加元素的功能，是在 put 方法和 offer 方法之间取了个折中。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此队列的尾部插入指定元素，如有必要，等待指定的等待时间以使空间可用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 和 put 方法基本类似，唯一区别是，该方法不会一直阻塞等待，有个最大等待时长</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful, or &#123;<span class="doctag">@code</span> false&#125; if</span></span><br><span class="line"><span class="comment"> * the specified waiting time elapses before space is available</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要添加的元素不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时等待时间</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取入队锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列满了，则等待指定的时间，尽最大努力添加元素</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 超时了还没有空的空间，那么就不添加了</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入队，可能条件如下：</span></span><br><span class="line">        <span class="comment">// 1）队列没有满  2）在指定的超时时间内有空的空间了，线程提前被唤醒</span></span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并更新队列中元素个数</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 c+1 &lt; 队列容量，说明队列还可以继续添加元素，则唤醒在非满条件队列中等待的线程</span></span><br><span class="line">        <span class="comment">// 这里 c+1 是因为前面已经加入了一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放入队锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c == 0 说明原来queue是空的, 现在添加了元素，所以这里 signalNotEmpty 一下, 唤醒正在 poll/take 等待中的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>获取元素的方法，主要的流程是判断队列空的情况的处理，以及获取元素成功后尝试唤醒阻塞添加元素的线程。获取元素是从队列头部获取，也就是链表的第一个有效节点（非头节点）。</p><h4 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取可中断出队锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列为空，则进入 notEmpty 等待队列进行等待队列非空</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出队，链表操作</span></span><br><span class="line">        x = dequeue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并更新队列中元素的个数</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明队列中还有元素，唤醒在 notEmpty 等待队列进行等待的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放出队锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c == capacity 说明队列在本次出队之前是满的，现在出队了一个元素，有空的空间了，可以唤醒 put/offer 操作阻塞的线程（如果有的话）</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>take 方法主要包括以下流程：</strong></p><ul><li>获取可中断的出队锁；</li><li>判断队列是否空的，空了则进入非空条件队列进行等待；</li><li>元素出队，链表操作；</li><li>元素出队后，如果队列还是非空的，那么可以继续出队，则唤醒在非空条件队列中等待的线程；</li><li>释放可中断的出队锁；</li><li>如果在获取元素之前，队列是满的，那么尝试唤醒正在 put/offer 等待中的线程；</li></ul><h5 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue()"></a>dequeue()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 出队底层操作</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">     <span class="comment">// assert head.item == null;</span></span><br><span class="line">     Node&lt;E&gt; h = head;            <span class="comment">// head 是一个虚节点</span></span><br><span class="line">     Node&lt;E&gt; first = h.next;      <span class="comment">// 获取虚节点后一个节点，也就是真正的节点</span></span><br><span class="line">     h.next = h;                  <span class="comment">// help GC</span></span><br><span class="line">     head = first;                <span class="comment">// 重新设置 head</span></span><br><span class="line">     E x = first.item;            <span class="comment">// 获取出队的值</span></span><br><span class="line">     first.item = <span class="keyword">null</span>;           <span class="comment">// 置空元素</span></span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="signalNotFull"><a href="#signalNotFull" class="headerlink" title="signalNotFull()"></a>signalNotFull()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 唤醒等待添加元素的线程。仅从 take/poll 调用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 唤醒前先拿到入队锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">     putLock.lock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 唤醒阻塞在非满条件队列中的某个线程</span></span><br><span class="line">         notFull.signal();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 释放入队锁</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         putLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，则直接返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取出队锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列不为空，那么出队</span></span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 出队</span></span><br><span class="line">            x = dequeue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取并更新队列中元素的个数</span></span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 说明队列中还有元素，唤醒在 notEmpty 等待队列进行等待的线程</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放出队锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c == capacity 说明队列在本次出队之前是满的，现在出队了一个元素，有空的空间了，可以唤醒 put/offer 操作阻塞的线程（如果有的话）</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法和 take 方法基本一致，唯一区别点是，队列为空时直接返回，不会阻塞等待元素。</p><p>LinkedBlockingQueue 基于 poll 方法进行了优化，支持超时获取元素的功能，是在 take 和 poll 方法之间取个折中。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 超时出队</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     E x = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 超时等待时长</span></span><br><span class="line">     <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取队列元素的个数</span></span><br><span class="line">     <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取可中断出队锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">     takeLock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 队列为空，则进入超时等待</span></span><br><span class="line">         <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">// 等待超时也没有元素</span></span><br><span class="line">             <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">// 超时等待</span></span><br><span class="line">             nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 出队，可能情况如下：</span></span><br><span class="line">         <span class="comment">// 1）队列没有空  2）在指定的超时时间内队列又有元素了，线程提前被唤醒</span></span><br><span class="line">         x = dequeue();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取并更新队列中元素的个数</span></span><br><span class="line">         c = count.getAndDecrement();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 说明队列中还有元素，唤醒在 notEmpty 等待队列进行等待的线程</span></span><br><span class="line">         <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">             notEmpty.signal();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 释放出队锁</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         takeLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// c == capacity 说明队列在本次出队之前是满的，现在出队了一个元素，有空的空间了，可以唤醒 put/offer 操作阻塞的线程（如果有的话）</span></span><br><span class="line">     <span class="keyword">if</span> (c == capacity)</span><br><span class="line">         signalNotFull();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取但不移除队列头部元素</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 队列为空，直接返回 null</span></span><br><span class="line">     <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取出队锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">     takeLock.lock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 获取有效节点</span></span><br><span class="line">         Node&lt;E&gt; first = head.next;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 返回元素</span></span><br><span class="line">         <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">return</span> first.item;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 释放出队列锁</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         takeLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="遍历链表操作"><a href="#遍历链表操作" class="headerlink" title="遍历链表操作"></a>遍历链表操作</h3><p>前面介绍了 LinkedBlockingQueue 的入队和出队操作，它们也是最核心的方法。其中入队时都会先获取入队锁，获取成功才可以执行后续的入队流程；出队时也是一样，先获取出队锁，获取成功才可以执行后续的出队流程。这两类操作各自用到了一把锁，这两把锁各自独立。</p><p>在涉及到遍历链表的操作时，需要<strong>同时使用两把锁，也就是入队锁和出队锁</strong>，因为遍历链表的过程不能有出队和入队的操作，否则就不安全了。具体方法包括：判断是否包含 contains 、删除元素 remove、清除 clear、toString、toArray 等。</p><p>相比其他操作，入队和出队使用的更频繁。入队和出队虽然各自使用一把锁，但是结合<strong>等待通知机制</strong>，这两个类型操作是安全的。这两类操作外的遍历链表操作，会同时使用两把锁，因此总体还是线程安全的。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/linked-blocking-queue-2.png" alt></p><p>至此，我们就知道了 LinkedBlockingQueue 为什么可以保证线程安全，并且并发度相对更大。</p><h2 id="ArrayBlockingQueue-VS-LinkedBlockingQueue"><a href="#ArrayBlockingQueue-VS-LinkedBlockingQueue" class="headerlink" title="ArrayBlockingQueue VS LinkedBlockingQueue"></a>ArrayBlockingQueue VS LinkedBlockingQueue</h2><ol><li>ArrayBlockingQueue 是有界的，而 LinkedBlockingQueue 默认是无界的。在使用 LinkedBlockingQueue 时要考虑内存实际使用问题，防止内存溢出问题的发生。</li><li>ArrayBlockingQueue 内部使用一个锁来控制元素的添加和取出操作，而 LinkedBlockingQueue 则是使用两个锁来控制。可以看出，前者不管是添加还是获取元素，都可能被阻塞，而后者在添加和获取时分别使用了两个锁，只会相同操作有阻塞可能，因此性能方面后者更强。</li><li>ArrayBlockingQueue 内部使用的是固定内存，而 LinkedBlockingQueue 内部使用的是动态内存，无论是分配内存还是释放内存（甚至GC），动态内存的性能自然都会比固定内存要差。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>LinkedBlockingQueue 是一个基于链表（单链表）实现的先进先出的阻塞队列。在入队和出队时（不含删除、清除），分别使用两把独占锁保证安全，也提高了并发度，其他操作基本都会同时使用两把锁，因此线程安全问题没问题。</p><p>LinkedBlockingQueue 虽然性能比 ArrayBlockingQueue 好，但是在内存处理上却不如后者好。此外，ConcurrentLinkedQueue 不再使用锁机制，而是采用 CAS 的方式，在性能上更强于 LinkedBlockingQueue 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;LinkedBlockingQueue 是一个&lt;strong&gt;基于链表（单链表）&lt;/strong&gt;实现的先进先出的阻塞队列，&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
      <category term="Queue" scheme="https://gentryhuang.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>并发 - ArrayBlockingQueue</title>
    <link href="https://gentryhuang.com/posts/3e4e955c/"/>
    <id>https://gentryhuang.com/posts/3e4e955c/</id>
    <published>2022-01-22T02:03:10.000Z</published>
    <updated>2022-05-10T02:29:54.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ArrayBlockingQueue 是 Java 并发包下一个以<strong>数组</strong>实现的阻塞队列，它是<strong>线程安全</strong>的。</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>ArrayBlockingQueue 是使用一个固定长度的数组来存储元素的，并使用一系列属性来描述这个数组。虽然这个数组是固定大小，但是使用了<strong>复用数组</strong>的设计思想，它的空间可以循环写入。循环写入不是无条件地覆盖式写入，而是采用等待可用空间地方式进行写入。从工作原理来说，它有以下特点：</p><ul><li>循环数组有一个写指针 putIndex，表示在数组 items 中的要写入的位置。如果写指针 putIndex 已经指向了数组末尾，那么此时再写入元素，写指针 putIndex 就会重新指向数组的头部，下次添加元素就可以复用数组了。</li><li>循环数组同时有一个读指针 takeIndex，表示在数组 items 中要读取的位置。如果读指针 takeIndex 指向了数组末尾，那么也会把读指针 takeIndex 重新指向数组头部，下次从数组头部开始继续读取元素。</li></ul><p>下图展示了循环数组的写指针工作机制，读指针也是类似的。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/array-blocking-queue-1.jpg" alt></p><p>循环写入非覆盖式写入，具体体现在下图，当写指针 putIndex 追上读指针 takeIndex（也就是队列满了） ，那么就必须阻塞等待读指针向前推进，只有读指针 takeIndex 向前推进了才能继续写。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/array-blocking-queue-2.jpg" alt></p><p>同理，当读指针 takeIndex 追上写指针 putIndex（也就是队列空了），那么也必须阻塞等待写指针向前推进，保证队列不为空才能继续读取。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>ArrayBlockingQueue 相关源码结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/array-blocking-queue-3.png" alt></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取元素时的下标；</span></span><br><span class="line"><span class="comment">     * 每从队列中取出一个元素，takeIndex 递增 1，到数组尾部会重置为 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素的下标</span></span><br><span class="line"><span class="comment">     * 每向队列添加一个元素，putIndex 递增 1，满了会重置为 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 并发控制使用经典双条件算法。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重入独占锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当队列为空时，会调用 notEmpty 的 wait 方法，让当前线程等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当队列满了，会调用 notFull 的 wait 方法，让当前线程等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  并发控制使用经典双条件算法。 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环数组本身被设计为一个 <strong>Object 类型的素组 items</strong> ，然后 ArrayBlockingQueue 设计了以下的变量来描述循环数组的状态：</p><ul><li><strong>count:</strong> 记录队列中元素的个数。</li><li><strong>putIndex:</strong> 记录循环数组的写指针，即循环数组接下来写数据时应该写入的位置。</li><li><strong>takeIndex:</strong> 记录循环数组的读指针，即循环数组接下来读数据时应该读取的位置。</li><li><strong>lock:</strong> 可重入独占锁，用来保证队列安全的。</li><li><strong>notEmpty:</strong> 数组非空的等待条件，当队列为空时，会调用 notEmpty 的 wait 方法，让当前线程等待。</li><li><strong>notFull:</strong> 数组非满的等待条件，当队列满了，会调用 notFull 的 wait 方法，让当前线程等待。</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 根据指定的大小创建 fair 类型的 ArrayBlockingQueue；这个公平指的是锁的公平性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue  队列大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity &lt; 1&#125; 大小 &lt; 1 抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an &#123;<span class="doctag">@code</span> ArrayBlockingQueue&#125; with the given (fixed)</span></span><br><span class="line"><span class="comment"> * capacity and the specified access policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair     if &#123;<span class="doctag">@code</span> true&#125; then queue accesses for threads blocked</span></span><br><span class="line"><span class="comment"> *                 on insertion or removal, are processed in FIFO order;</span></span><br><span class="line"><span class="comment"> *                 if &#123;<span class="doctag">@code</span> false&#125; the access order is unspecified.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity &lt; 1&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 阻塞队列的大小必须 &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化指定大小的 Object 数组</span></span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可重入锁，是否公平取决于 fair</span></span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建锁的条件对象，用来等待队列非空</span></span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建锁的条件对象，用来等待队列非满</span></span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul><li><strong>add():</strong> 在不超出队列容量的情况下，在队列尾部插入指定的元素，成功返回 true，如果队列已满则抛出异常。其底层使用的是 offer 方法。</li><li><strong>offer():</strong> 在不超出队列容量的情况下，在队列尾部插入指定的元素，成功时返回 true，如果队列已满则返回 false。</li><li><strong>put():</strong> 在队列尾部添加指定元素，如果队列满了，则阻塞等待，直到空间可用。</li></ul><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果可以在不超出队列容量的情况下立即插入指定元素，则在此队列的尾部插入指定元素，</span></span><br><span class="line"><span class="comment"> * 成功时返回 &#123;<span class="doctag">@code</span> true&#125;，如果此队列已满则抛出 &#123;<span class="doctag">@code</span> IllegalStateException&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add 要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;) 添加成功返回 true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if this queue is full 队列满了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException  if the specified element is null 要添加的元素 e 不能为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类的 add 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     public boolean add(E e) &#123;</span></span><br><span class="line"><span class="comment">     *         // 调用 offer 方法</span></span><br><span class="line"><span class="comment">     *         if (offer(e))</span></span><br><span class="line"><span class="comment">     *             return true;</span></span><br><span class="line"><span class="comment">     *         else</span></span><br><span class="line"><span class="comment">     *             throw new IllegalStateException("Queue full");</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="offer"><a href="#offer" class="headerlink" title="offer()"></a>offer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果可以在不超出队列容量的情况下立即插入指定元素，则在此队列的尾部插入指定元素，成功时返回 &#123;<span class="doctag">@code</span> true&#125;，</span></span><br><span class="line"><span class="comment"> * 如果此队列已满则返回 &#123;<span class="doctag">@code</span> false&#125;。此方法通常比方法 &#123;<span class="doctag">@link</span> add&#125; 更可取，后者仅通过抛出异常可能无法插入元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 检查要插入的元素 e 不能为空</span></span><br><span class="line">       checkNotNull(e);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 加锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 如果队列满了，直接返回 false ，不插入元素</span></span><br><span class="line">           <span class="keyword">if</span> (count == items.length)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果队列没有满，则向队列的尾部插入元素 e ，插入成功后返回 true</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               enqueue(e);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 检查要添加的元素 e 不能为空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加获取可中断锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否满了，满了则阻塞在 notFull 等待被唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列不满，则在队列尾部插入元素</span></span><br><span class="line">        enqueue(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue()"></a>enqueue()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在 putIndex 下标位置添加元素；该方法仅在获取到锁时调用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">     <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取全局数组</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 在 putIndex 下标位置添加元素</span></span><br><span class="line">     items[putIndex] = x;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 向后移动 putIndex ，如果队列满了，则重置 putIndex 为 0</span></span><br><span class="line">     <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">         putIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 数组元素个数累加</span></span><br><span class="line">     count++;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 尝试唤醒阻塞在 notEmpty 上等待的线程（如果有的话）</span></span><br><span class="line">     notEmpty.signal();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该方法是添加元素的最底层方法，涉及到写指针 putIndex 的更新，以及尝试唤醒阻塞在 notEmpty 上等待的线程（如果有的话）。需要注意的是，判断队列是否满了的条件是：<code>putIndex==items.length</code>。</p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><ul><li><strong>remove():</strong> 从队列中删除指定元素（如果存在）。</li><li><strong>poll():</strong> 尝试删除并返回队列头部的元素，队列为空返回 null 即可。</li><li><strong>take():</strong> 阻塞式删除并返回队列头部的元素，如果队列为空会一直等待，直到有元素才返回。</li><li><strong>peek():</strong> 返回队列头部元素，但不从队列中删除该元素，队列为空则返回 null。</li></ul><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要删除的元素为空，则返回 false，不进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取全局数组</span></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果队列非空</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">                <span class="keyword">int</span> i = takeIndex;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历数组，找到要删除的元素</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                        <span class="comment">// 删除该元素并移动元素</span></span><br><span class="line">                        removeAt(i);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 数组是循环使用的</span></span><br><span class="line">                    <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                        i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 追上 putIndex ，说明已经遍历完了</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 队列为空，或者没有找到要删除的元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数组下标 removeIndex 处的元素并移动元素使元素连续。仅在获取到锁时调用；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> removeIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        <span class="comment">// assert items[removeIndex] != null;</span></span><br><span class="line">        <span class="comment">// assert removeIndex &gt;= 0 &amp;&amp; removeIndex &lt; items.length;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取全局数组</span></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果要删除下标正好是下一个要取出的元素对应的下标，那么同取出元素操作逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (removeIndex == takeIndex) &#123;</span><br><span class="line">            <span class="comment">// removing front item; just advance</span></span><br><span class="line">            <span class="comment">// 置空</span></span><br><span class="line">            items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 takeIndex 下标</span></span><br><span class="line">            <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">                takeIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新队列元素个数</span></span><br><span class="line">            count--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新迭代器状态</span></span><br><span class="line">            <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">                itrs.elementDequeued();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果要删除的下标非 takeIndex ，那么说明就是"中间位置"，需要移动元素以覆盖删除的位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// an "interior" remove</span></span><br><span class="line">            <span class="comment">// 以要删除的下标 removeIndex 为基准，"向前"移动元素，直到追上 putIndex</span></span><br><span class="line">            <span class="comment">// todo 注意数组循环使用的情况</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = removeIndex; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = i + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 从头开始</span></span><br><span class="line">                <span class="keyword">if</span> (next == items.length)</span><br><span class="line">                    next = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 没有追上 putIndex，就向前移动</span></span><br><span class="line">                <span class="keyword">if</span> (next != putIndex) &#123;</span><br><span class="line">                    items[i] = items[next];</span><br><span class="line">                    i = next;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 后退 putIndex </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    items[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">this</span>.putIndex = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新队列元素个数</span></span><br><span class="line">            count--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新迭代器</span></span><br><span class="line">            <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">                itrs.removedAt(removeIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试唤醒阻塞在 notFull 上等待的线程</span></span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>删除元素相对复杂一些，移动数组元素时要考虑数组是循环使用的。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取队列头部的元素，队列为空返回 null 即可</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 队列为空，返回 null ;队列非空返回 takeIndex 下标位置的元素</span></span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上述方法是快速获取的方式，如果没有就立即返回 null。ArrayBlockingQueue 还支持超时获取元素，尽最大努力获取到元素。该方法是在 poll() 方法的基础上增加了超时等待条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试超时获取元素</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">// 获取元素的超时时间</span></span><br><span class="line">       <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取可中断锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lockInterruptibly();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 如果队列为空，等待 nanos 纳秒时长</span></span><br><span class="line">           <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 等待 nanos 纳秒后，队列还是为空</span></span><br><span class="line">               <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 执行到这里有两种可能： 1）队列非空，直接获取  2）队列为空，但在等待时长内队列又有元素了</span></span><br><span class="line">           <span class="keyword">return</span> dequeue();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 阻塞式获取元素</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">// 获取可中断锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 队列为空，则阻塞等待，直到队列有元素</span></span><br><span class="line">           <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">               notEmpty.await();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 获取 takeIndex 下标位置的元素</span></span><br><span class="line">           <span class="keyword">return</span> dequeue();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>take() 方法相比超时等待的 poll() 方法，前者没有等待时间，会一直等待，直到队列有元素或线程被中断。</p><h4 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取队列头部元素，但不移除该元素；队列为空，则返回 null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接从数组中获取下标为 takeIndex 的元素</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue()"></a>dequeue()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取出 takeIndex 下标位置的元素；该方法仅在获取到锁时调用；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取全局数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 takeIndex 下标位置的元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 null，便于 GC</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 takeIndex ，如果到达了数组的末尾，则重置 takeIndex 为 0 ，即下次从数组头开始取元素</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组元素个数递减</span></span><br><span class="line">    count--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新迭代器状态</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试唤醒阻塞在 notFull 上等待的线程（如果有的话）</span></span><br><span class="line">    notFull.signal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回元素</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是获取元素的最底层方法，涉及到读指针 takeIndex 的更新，以及尝试唤醒阻塞在 notFull 上等待的线程（如果有的话）。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>典型的使用场景就是生产者-消费者问题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章简单介绍了 ArrayBlockingQueue 的模型，并分析了核心的源码。核心点有以下两点：</p><ul><li>以固定大小数组作为元素的容器，并定义系列描述数组的属性。这个固定大小的数组是可以循环使用的。存取数据遵循：队头取、队尾插，从读写指针也可以看出。</li><li>基本的增、删、查都要先加锁才能操作，使用的锁是 Reentrant 保证了安全性，并使用等待通知机制来实现阻塞的功能。<strong>也就是，同一时刻只有一个线程可操作队列。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ArrayBlockingQueue 是 Java 并发包下一个以&lt;strong&gt;数组&lt;/strong&gt;实现的阻塞队列，它是&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
      <category term="Queue" scheme="https://gentryhuang.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="https://gentryhuang.com/posts/4eb3381c/"/>
    <id>https://gentryhuang.com/posts/4eb3381c/</id>
    <published>2022-01-08T02:10:15.000Z</published>
    <updated>2022-01-10T06:04:49.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h1><p>分布式系统中，同一系统的不同主机共享同一资源，在访问的时候需要添加互斥语义以保护资源。这种情况下就需要使用分布式锁，<strong>锁是保存在一个共享存储系统中的，所有进程都可以去该系统上申请加锁和释放锁</strong>。</p><h1 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h1><p>用于存储“锁”的共享存储系统，可以是 <code>MySQL</code>、<code>Redis</code>、<code>Zookeeper</code> 以及 <code>Etcd</code> 等。对应的，每种共享存储系统都可以实现分布式锁。</p><h2 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h2><p>用于实现分布锁的数据表结构定义如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TDistributedLock (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">' 主键 '</span>,</span><br><span class="line">  <span class="string">`lock_key`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">' 锁的键值 '</span>,</span><br><span class="line">  <span class="string">`lock_timeout`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NOW</span>() <span class="keyword">COMMENT</span> <span class="string">' 锁的超时时间 '</span></span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_lock_key`</span> (<span class="string">`lock_key`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">' 分布式锁表 '</span>;</span><br></pre></td></tr></table></figure><p>当进程申请加锁时，只需要插入一条数据即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TDistributedLock(lock_key, lock_timeout) <span class="keyword">values</span>(<span class="string">'order_lock_key'</span>, <span class="string">'2022-01-07 20:30:00'</span>);</span><br></pre></td></tr></table></figure><p>当对共享资源的操作完毕后，可以释放锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> TDistributedLock <span class="keyword">where</span> lock_key=<span class="string">'order_lock_key'</span>;</span><br></pre></td></tr></table></figure><p>基于数据库实现的方案简单、方便，核心点是利用数据库表的<strong>唯一索引</strong>约束，保证多个进程同时申请加锁时，只有一个能获得锁。</p><p>虽然基于数据库实现的方案简单，但是存在一些问题。下面我们对问题进行说明，并给出解决方式。</p><ul><li>获得锁的进程意外 crash ，来不及释放锁。<blockquote><p>在插入锁记录时，同时设置了锁的过期时间 lock_timeout ，可以启动一个扫描清理线程 lock_cleaner，将超时的锁记录删除。</p></blockquote></li><li>如何支持可重入锁<blockquote><p>可以在锁记录表中增加一个字段，记录当前获取锁的主机信息和进程信息，在获取锁时先判断是否是重入锁。如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给它就可以了。此时需要考虑业务的复杂程度，判断是否要延长锁的更新时间。</p></blockquote></li><li>锁的可靠性怎么保证<blockquote><p>数据库支持主从、一主多从、多主多从等复制方案，可保证一个数据库实例宕机，其它实例可以接管过来继续提供服务。但是，有些复制方案是异步的，可能会导致锁丢失，进而导致分布锁失效。</p></blockquote></li></ul><h2 id="基于-Zookeeper-实现"><a href="#基于-Zookeeper-实现" class="headerlink" title="基于 Zookeeper 实现"></a>基于 Zookeeper 实现</h2><p>Zookeeper 是一个分布式协调框架，以目录结构的形式存储数据。基于 Zookeeper 的一些特性，实现分布式锁的逻辑如下：</p><ol><li>使用 Zookeeper 的临时有序节点，每个进程获取锁需要在 Zookeeper 上创建一个临时有序节点，如在 /lock/ 目录下；</li><li>创建节点成功后，获取 /lock 目录下的所有临时节点，再判断当前进程创建的节点是否是所有的节点中序号最小的节点；</li><li>如果当前进程创建的节点是所有节点序号最小的节点，则获取锁成功。</li><li>如果当前进程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。 比如当前进程获取到的节点序号为/lock/003,然后所有的节点列表为 [/lock/001,/lock/002,/lock/003],则对 /lock/002 这个节点添加一个事件监听器。</li></ol><p>当进程处理完共享资源后，就可以释放锁了，也就是删除它创建的临时节点。Zookeeper 添加其上的监听器会捕捉到移除事件，然后唤醒下一个序号的节点，然后执行第 3 步，继续抢锁。比如/lock/001 被删除了，/lock/002 监听到事件，此时节点集合为[/lock/002,/lock/003],则 /lock/002 为最小序号节点，获取到锁。</p><p><strong>注意：</strong>不使用 Zookeeper 的持久节点，是避免加锁成功后出现异常，节点来不及删除，导致后面的节点会一直等待节点删除，从而出现死锁，临时节点因为会随着客户端的下线被删除，可以避免死锁的问题。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Zookeeper <strong>无需考虑锁的过期时间问题</strong>，它采用的是临时节点和主动删除策略。客户端获取到锁后，只要连接不断开，除非主动删除临时节点，否则一直持有锁。即使客户端异常宕机，因为是临时节点，因此会自动删除，避免了死锁。</p><p>没有锁过期的问题，而且还能在异常时自动释放锁。一切看起来很安全，但是我们考虑下客户端获取到锁后，连接断开的情况。</p><p>我们知道，客户端和 Zookeeper 之间的连接是通过客户端<strong>定时心跳</strong>来维持的，如果 Zookeeper 长时间收不到客户端的心跳，就认为这个连接过期了，会把这个临时节点删除。对于长时间的 GC ，客户端应用程序就无法给 Zookeeper 发送心跳，一旦超时 Zookeeper 就会把锁节点删除，GC 结束后其它客户端也来获取锁，也获取到了。此时，同时有两个客户端持有锁，这是有问题的。</p><p>可以知道，<strong>Zookeeper 在进程 GC、网络延迟异常场景下的安全性得不到保证</strong>。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>优点</strong></p><ul><li>数据一致性得到保证</li><li>不需要考虑锁的过期时间</li><li>使用 watch 机制，避免了等候锁的客户端不停地轮循锁是否可用，当锁的状态发生变化时可以自动得到通知。</li></ul><p><strong>劣势</strong></p><ul><li>性能问题，体现在读写和数据同步上</li><li>客户端与 Zookeeper 长时间失联，锁被释放问题</li><li>羊群效应，要尽量避免大量节点监控一个节点的行为，做到按需监听</li></ul><h2 id="基于单个-Redis-节点实现"><a href="#基于单个-Redis-节点实现" class="headerlink" title="基于单个 Redis 节点实现"></a>基于单个 Redis 节点实现</h2><p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁。而且 Redis 的读写性能高，可以应对高并发的锁操作场景。</p><h3 id="SETNX-实现"><a href="#SETNX-实现" class="headerlink" title="SETNX 实现"></a>SETNX 实现</h3><p>SETNX 命令在执行时会判断键是否存在，如果不存在，就设置键值对，如果存在，就不做任何设置。</p><p>我们可以用 SETNX 和 DEL 命令组合来实现加锁和释放锁操作。下面的伪代码示例显示了锁操作的过程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">SETNX lock_key <span class="number">1</span></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">DO THINGS</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure><p>不难看出，上述方案存在很多问题，如下：</p><ul><li>没有过期时间，进程异常退出会导致死锁</li><li>不能区分来自不同客户端的锁操作，容易导致误删锁</li></ul><p>避免死锁的一个最直接的方法就是设置一个过期时间，也就是租期。假设业务逻辑不会超过 3s，那么在加锁时，可以设置 3s 过期时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">SETNX lock_key <span class="number">1</span></span><br><span class="line"><span class="comment">// 设置 3s 租期</span></span><br><span class="line">EXPIRE lock_key <span class="number">3</span></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">DO THINGS</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure><p>设置了租期后，也不能保证不会死锁。因为加锁、设置过期是 2 个操作，可能只执行了第一个操作，第二个操作没有执行，这种情况就有潜在的风险，死锁仍然可能发生。</p><p>好在 Redis 扩展了 SET 命令，可以使用一条命令替换上述存在问题的两条命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁并设置 3s 租期</span></span><br><span class="line">SET lock_key <span class="number">1</span> EX <span class="number">3</span> NX</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">DO THINGS</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure><p>这样就解决了死锁问题。</p><h3 id="SET-实现"><a href="#SET-实现" class="headerlink" title="SET 实现"></a>SET 实现</h3><p>为了能达到和 SETNX 命令一样的效果，Redis 扩展了 SET 命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [EX seconds | PX milliseconds]  [NX]</span><br></pre></td></tr></table></figure><p>虽然 SET 命令可以解决 SETNX 命令中存在的<strong>死锁问题</strong>，但是没有解决误删锁问题。这个问题的主要原因是，每个客户端在释放锁时，都是直接操作，<strong>没有检查锁是否还是自己持有</strong>。如以下场景：</p><ol><li>客户端 A 加锁成功，开始操作共享资源；</li><li>客户端 A 操作共享资源的时间超过了锁的过期时间，执行还没有完成，锁就自动释放了；</li><li>客户端 B 加锁成功，开始操作共享资源；</li><li>客户端 A 执行完成，释放锁，此时释放的事客户端 B 的锁。</li></ol><p>导致以上问题的关键有两个：</p><ul><li><strong>锁过期</strong>：客户端 A 执行时间过长，导致锁提前释放了，之后被客户端 B 持有。</li><li><strong>误释放锁</strong>：客户端 A 执行完成后，以为还是自己的锁，结果释放了客户端 B 的锁。</li></ul><p>下面我们对以上两个潜在问题进行分析并解决。</p><h4 id="解决锁被被人释放问题"><a href="#解决锁被被人释放问题" class="headerlink" title="解决锁被被人释放问题"></a>解决锁被被人释放问题</h4><p>在加锁操作中，每个客户端都使用一个唯一标识，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// $uuid 是当前客户端的唯一标识</span><br><span class="line">127.0.0.1:6379&gt; SET lock_key $uuid EX 3 NX</span><br></pre></td></tr></table></figure><p>在释放锁操作时，我们需要判断锁变量的值，是否等于执行释放锁操作的客户端的唯一标识，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放锁 比较unique_value是否相等，避免误释放</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">end</span></span><br></pre></td></tr></table></figure><p>上面是使用 Lua 脚本（unlock.script）实现的释放锁操作的伪代码，其中，KEYS[1]表示 lock_key，ARGV[1]是当前客户端的唯一标识，这两个值都是我们在执行 Lua 脚本时作为参数传入的。</p><p><strong>在释放锁操作中，我们使用了 Lua 脚本，这是因为，释放锁操作的逻辑也包含了读取锁变量、判断值、删除锁变量的多个操作，而 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</strong></p><h4 id="锁提前过期问题"><a href="#锁提前过期问题" class="headerlink" title="锁提前过期问题"></a>锁提前过期问题</h4><p>锁的过期时间如果评估不好，那么就会有提前释放的风险。但是，面对不同的业务场景过期时间很难精确预估。这个时候，我们可以使用<strong>续租</strong>的方式，延续锁的过期时间。</p><p>在加锁时，先设置一个过期时间，然后启动一个后台线程，定时检测锁的实效时间，如果锁快要过期了，但操作共享资源还没有处理完成，那么就对锁进行续期，重新设置过期时间。Java 中的 Redission 在使用分布式锁时，就采用了自动续期的方式来避免锁提前过期，这个后台线程一般称做<strong>看门狗线程</strong>。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><p>下面对基于 Redis 实现的分布式锁出现的问题以及解决方案进行梳理：</p><ul><li>针对死锁问题，可以通过设置过期时间来解决；</li><li>针对锁提前释放，可以使用自动续期来解决；</li><li>针对锁被误删除，可以通过检查锁的唯一标识来决定是否可以释放。</li></ul><h2 id="基于多个-Redis-节点实现"><a href="#基于多个-Redis-节点实现" class="headerlink" title="基于多个 Redis 节点实现"></a>基于多个 Redis 节点实现</h2><p>在使用 Redis 时，为了可靠性，一般会采用哨兵或集群的方式部署。那这种可靠性对于分布式锁有什么影响呢？我们以哨兵模式为例，分析主从切换对分布式锁的影响。</p><ol><li>客户端 A 在主库上执行 SET 命令申请加锁成功；</li><li>主库异常宕机，申请加锁的 SET 命令还未同步到从库上；</li><li>从库被提升为新主库，此时锁的数据在新的主库上丢失了；</li><li>其它客户端向主库申请加锁也会成功，此时分布式锁失效了。</li></ol><p>可以看到，因为 Redis 的主从复制是异步的，高可用机制不能保证锁的可靠性。因此，Redis 的作者提出了 Redlock 方案。</p><h3 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h3><p>Redlock 算法的基本思路，是让客户端和多个独立的 Redis 实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，并且总耗时不超过锁的有效时间，那么就认为客户端成功地获得分布式锁了，否则加锁失败。这样一来，即使有单个 Redis 实例发生故障，还有其它实例，锁的可靠性得到了保障。</p><p>可以看出，Redlock 的特点如下：</p><ul><li>不是部署主从库，而是只部署主库；</li><li>主库要部署多个，官方推荐至少 5 个实例；</li></ul><p>也就是说，Redlock 要求至少部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>Redlock 算法的步骤一共分为 5 步：</p><ol><li>客户端获取当前时间戳。</li><li>客户端按顺序依次向 N 个 Redis 实例执行加锁操作。这里的加锁操作和在单实例上执行的加锁操作一样，使用 SET 命令，带上 NX，EX/PX 选项，以及带上客户端的唯一标识。为了保证某个实例加锁失败（实例宕机、网络超时、锁被其它客户端持有） Redlock 算法能够继续运行，需要给加锁操作设置一个超时时间。如果客户端在和一个 Redis 实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个 Redis 实例继续请求加锁。加锁操作的超时时间需要远远地小于锁的有效时间，一般也就是设置为几十毫秒。</li><li>客户端只有在满足下面的这两个条件时，才能认为是加锁成功。<ul><li>客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁；</li><li>计算客户端获取锁的总耗时，必须没有超过锁的有效时间。</li></ul></li><li>加锁成功，操作共享资源。</li><li>加锁失败，向全部节点发起释放锁的请求。和在单实例上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。</li></ol><h4 id="关键步骤分析"><a href="#关键步骤分析" class="headerlink" title="关键步骤分析"></a>关键步骤分析</h4><p>Redlock 算法的关键如下：</p><ul><li>必须是大多数节点加锁成功；<blockquote><p>为了实现容错功能。</p></blockquote></li><li>大多数节点加锁的总耗时要小于锁设置的过期时间；<blockquote><p>即使大多数节点加锁成功，但如果加锁的累计耗时已经超过了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁也就没有意义了。</p></blockquote></li><li>释放锁要向全部节点发起释放锁请求。<blockquote><p>可能存在实例上加锁成功了，但是获取响应结果时是失败的，如网络问题导致超时。</p></blockquote></li></ul><h4 id="Redlock-存在问题"><a href="#Redlock-存在问题" class="headerlink" title="Redlock 存在问题"></a>Redlock 存在问题</h4><h5 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h5><p>为了效率可以使用单节点 Redis ，即使偶尔发生锁失效（宕机、主从切换），有些业务不会产生严重后果，最差可以做幂等。毕竟，使用 Redlock 太重了。</p><h5 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h5><p>在进程暂停、时钟跳跃、节点奔溃恢复等情况下，Redlock 是不安全的。</p><h6 id="进程暂停"><a href="#进程暂停" class="headerlink" title="进程暂停"></a>进程暂停</h6><p>在 Java 中进行 GC 时，会使进程暂停，时间序列如下：</p><ol><li>客户端 1 依次向节点 A、B、C、D、E 请求加锁；</li><li>客户端 1 获得锁后，进入 GC ，这个时间假设很长；</li><li>大多数或全部 Redis 节点上的锁都过期了；</li><li>客户端 2 依次向节点 A、B、C、D、E 请求加锁，获取锁成功；</li><li>客户端 1 和客户端 2 都获取到了锁，发生了冲突。</li></ol><h6 id="时钟跳跃"><a href="#时钟跳跃" class="headerlink" title="时钟跳跃"></a>时钟跳跃</h6><p>当多个 Redis 节点时钟发生问题时，也会导致 Redlock 锁失效。</p><ol><li>客户端 1 依次向节点 A、B、C、D、E 请求加锁，获取到了节点 A、B、C 上的锁，但由于网络问题，无法访问 D 和 E；</li><li>节点 C 上的时钟向前跳跃，导致锁过期了。</li><li>客户端 2 依次向节点 A、B、C、D、E 请求加锁，获取节点 C、D、E 上的锁，由于网络问题，无法访问 A 和 B；</li><li>客户端 1 和客户端 2 都获取到了锁，发生了冲突。</li></ol><p>机器的时钟发生错误，是很有可能发生的，比如：</p><ul><li>系统管理员手动修改了机器时钟</li><li>机器时钟在同步 NTP 时间时，发生了大的跳跃</li></ul><p>Redis 节点奔溃重启，如果锁信息没有持久化，那么也会造成和时钟跳跃一样的问题。</p><h4 id="解决-Redlock-问题"><a href="#解决-Redlock-问题" class="headerlink" title="解决 Redlock 问题"></a>解决 Redlock 问题</h4><h5 id="时钟跳跃问题"><a href="#时钟跳跃问题" class="headerlink" title="时钟跳跃问题"></a>时钟跳跃问题</h5><p>针对时钟问题，Redlock 并不需要完全一致的时钟，只需要大体一致就可以了。避免手动修改机器时钟，并通过正确的运维保证机器时钟不会大幅度跳跃。</p><h5 id="进程暂停问题"><a href="#进程暂停问题" class="headerlink" title="进程暂停问题"></a>进程暂停问题</h5><p>对于 Redlock 来说，如果进程暂停、网络延迟发生在获得锁之前，那么 Redlock 是可以检测出来的，如果超出了锁设置的过期时间，就认为加锁失败，之后释放所有节点的锁；如果发生在获得锁之后，也就是在客户端操作共享资源的过程发生问题导致锁失效，那 Redlock 确实没有办法了，但是这不仅仅是 Redlock 的问题，其它分布式锁实现也有类似问题，比如 Zookeeper 实现的分布式锁也会因一定时间没有保持心跳而断开连接，导致分布式锁失效。</p><p>总的来说，Redlock 在保证时钟正确的基础上，是可以保证正确性的。</p><h4 id="Redlock-实践"><a href="#Redlock-实践" class="headerlink" title="Redlock 实践"></a>Redlock 实践</h4><p>追求性能，并能容忍一定的可靠性和安全，可以直接使用单节点的 Redis；对可靠性有追求，可以考虑使用 Redis 的可靠性机制。毕竟，Redlock 较重，而且部署成本高，时钟跳跃问题也不是那么容易解决或避免。</p><h2 id="基于-Etcd-实现"><a href="#基于-Etcd-实现" class="headerlink" title="基于 Etcd 实现"></a>基于 Etcd 实现</h2><p>Etcd 是 CoreOS 团队于 2013 年 6 月发起的开源项目，它的目标是构建一个高可用的分布式键值 (key-value) 数据库。Etcd 内部基于 raft 一致性算法，使用 Go 语言实现。</p><p>Etcd 分布式锁的逻辑如下：</p><ul><li>Lease 机制:即租约机制(TTL，Time To Live)，etcd 可以为存储的 KV 对设置租约，当租约到期，KV 将失效删除;同时也支持续约， 即 KeepAlive。</li><li>Revision 机制:每个 key 带有一个 Revision 属性值，etcd 每进行一次事务对应的全局 Revision 值都会加一，因此每个 key 对应的 Revision 属性值都是全局唯一的。通过比较 Revision 的大小就可以知道进行写操作的顺序。 </li><li>在实现分布式锁时，多个程序同时抢锁，根据 Revision 值大小依次获得锁，可以避免 “羊群效应” (也称 “惊群效应”)，实现公平 锁。</li><li>Prefix 机制:即前缀机制，也称目录机制。可以根据前缀(目录)获取该目录下所有的 key 及对应的属性(包括 key, value 以及 revision 等)。</li><li>Watch 机制:即监听机制，Watch 机制支持 Watch 某个固定的 key，也支持 Watch 一个目录(前缀机制)，当被 Watch 的 key 或目录 发生变化，客户端将收到通知。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章对分布式锁的几种实现方式进行了介绍，重点分析了 Redis 分布式锁的实现方式，通过不断演进，最终出现了 Redlock ，并对 Redlock 存在的问题进行了说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么需要分布式锁？&quot;&gt;&lt;a href=&quot;#为什么需要分布式锁？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要分布式锁？&quot;&gt;&lt;/a&gt;为什么需要分布式锁？&lt;/h1&gt;&lt;p&gt;分布式系统中，同一系统的不同主机共享同一资源，在访问的时候需要添加互斥语义以
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式锁" scheme="https://gentryhuang.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构 - SDS续</title>
    <link href="https://gentryhuang.com/posts/1a7fe47d/"/>
    <id>https://gentryhuang.com/posts/1a7fe47d/</id>
    <published>2021-12-12T03:10:07.000Z</published>
    <updated>2022-01-19T11:02:30.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://gentryhuang.com/posts/f7ccc3b4/">SDS</a> 中，我们对 Redis 中的简单动态字符串进行了说明。本篇文章将对 SDS 的使用进行简单介绍，主要对 String 类型的 Set 命令、字符串对象的编码、字符串对象的缩容这三个方面进行分析。</p><h2 id="Set命令的实现"><a href="#Set命令的实现" class="headerlink" title="Set命令的实现"></a>Set命令的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-- t_string.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *expire = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> unit = UNIT_SECONDS;</span><br><span class="line">    <span class="keyword">int</span> flags = OBJ_NO_FLAGS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 解析并设置选项参数</span></span><br><span class="line">    <span class="keyword">if</span> (parseExtendedStringArgumentsOrReply(c, &amp;flags, &amp;unit, &amp;expire, COMMAND_SET) != C_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 尝试对值对象进行编码优化，以节省内存</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 执行 set 通用命令方法</span></span><br><span class="line">    setGenericCommand(c, flags, c-&gt;argv[<span class="number">1</span>], c-&gt;argv[<span class="number">2</span>], expire, unit, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数是 SET 命令的处理函数，主要的步骤已经标注，其中 2、3 两步涉及的内容有点多，我们先对涉及的字符串对象编码情况以及缩容进行说明。</p><h2 id="字符串对象的编码"><a href="#字符串对象的编码" class="headerlink" title="字符串对象的编码"></a>字符串对象的编码</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/f7ccc3b4/&quot;&gt;SDS&lt;/a&gt; 中，我们对 Redi
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构 - SDS</title>
    <link href="https://gentryhuang.com/posts/f7ccc3b4/"/>
    <id>https://gentryhuang.com/posts/f7ccc3b4/</id>
    <published>2021-12-04T08:34:15.000Z</published>
    <updated>2021-12-08T11:31:09.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>字符串作为我们日常开发常见的数据类型，几乎任何地方都可能用到，这就要求字符串的实现需要满足以下要求：</p><ul><li>能支持丰富且高效的字符串操作，如字符串追加、获取长度等。</li><li>能保存任意二进制数据，比如图片等</li><li>能尽可能地节省内存开销</li></ul><h1 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C 字符串"></a>C 字符串</h1><p>在 C 语言中可以使用 <strong>char* 字符数组</strong> 来实现字符串，本质就是<strong>一块连续的内存空间，依次存放了字符串中的每个字符</strong>。比如，下图显示的就是字符串“redis”的char*数组结构：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/data_structure/redis-sds-c-array.jpg" alt></p><p>从图中可以看到，字符数组的最后一个字符是“\0”，这个字符的作用是什么呢？其实，C 语言在对字符串进行操作时，<strong>char* 指针只是指向字符数组的起始位置，而字符数组的结尾位置就用“\0”表示，意思是指字符串的结束</strong>。</p><p>C 语言标准库 <code>string.h</code>中也定义了多种字符串的操作函数，比如字符串比较函数 strcmp、字符串长度计算函数 strlen、字符串追加函数 strcat 等，这样就便于开发者直接调用这些函数来完成字符串操作。从以上角度来看，Redis 好像完全可以复用 C 语言中对字符串的实现。但 C 字符串没有很好地解决系列问题。</p><h2 id="字符串高效操作"><a href="#字符串高效操作" class="headerlink" title="字符串高效操作"></a>字符串高效操作</h2><p>C 语言标准库中字符串的操作函数，是通过检查字符数组中是否有<code>\0</code>来判断字符串是否结束，基于此 C 语言操作函数复杂度是不可观的。比如：</p><ul><li>strlen 函数：该函数需要遍历字符数组中的每一个字符，才能得到字符串长度，所以这个操作函数的复杂度是 O(N)。</li><li>strcat 函数：将一个源字符串 src 追加到一个目标字符串的末尾，一方面要先遍历目标字符串找到末尾，然后再遍历源字符串才能完成追加。另一方面，还需要确认目标字符串具有足够的可用空间，否则就无法追加。</li></ul><p>操作函数的复杂度一旦增加，就会影响字符串的操作效率，这就<strong>不符合 Redis 对字符串高效操作的需求了</strong>。</p><h2 id="二进制数安全"><a href="#二进制数安全" class="headerlink" title="二进制数安全"></a>二进制数安全</h2><p>C 语言中 char* 字符串以<code>\0</code>表示字符串的结束，这样决定了它存储数据的局限性。如果我们要保存的数据中本身就有<code>\0</code>，那么数据在<code>\0</code>处就会被截断，这<strong>不符合 Redis 希望保存任意二进制数据的需求</strong>。</p><h2 id="内存分配与释放"><a href="#内存分配与释放" class="headerlink" title="内存分配与释放"></a>内存分配与释放</h2><p>C 语言中 char* 字符串的长度和底层数组的长度之间存在<strong>关联性</strong>，每次增加或者缩短一个 C 字符串，程序都需对保存这个 C 字符串的数组进行一次分配操作，该过程涉及到内存分配和释放。内存操作通常是个比较耗时的操作，这<strong>不符合 Redis 对字符串高效操作的需求了</strong>。</p><h1 id="Redis-中字符串"><a href="#Redis-中字符串" class="headerlink" title="Redis 中字符串"></a>Redis 中字符串</h1><p>综合 C 语言中字符串的不足，Redis 对字符串的实现进行了设计和考虑：</p><ul><li><strong>操作效率高：</strong>Redis 专门设计了 SDS 数据结构，在字符数组的基础上，增加了字符数组存储数据长度和分配空间大小等元数据。这样一来，需要<strong>基于字符串长度</strong>进行的追加、复制、比较等操作，就可以直接读取元数据，效率也就提升了。</li><li><strong>二进制安全：</strong>SDS 数据结构定义了字符数组存储数据长度和分配空间大小等元数据，不需要通过字符数组中的<code>\0</code>字符判断字符串结束，所以可存储包含 \0 的数据，这样就可以存储图片等二进制数据。</li><li><strong>优化内存操作：</strong>SDS 为了避免频繁操作字符串时带来的内存开销，使用了内存预分配和惰性空间释放（多余内存不释放）。</li><li><strong>节省内存空间：</strong>SDS通过设计不同的 SDS 类型来表示不同大小的字符串，并使用<code>__attribute__ ((__packed__))</code>编译优化来实现紧凑型内存布局，达到节省内存的目的。</li><li><strong>兼容C字符串：</strong>可以直接使用 C 语言标准库函数。</li></ul><h2 id="SDS-结构设计"><a href="#SDS-结构设计" class="headerlink" title="SDS 结构设计"></a>SDS 结构设计</h2><p>由于 Redis 是使用 C 语言开发的，所以<strong>为了保证能尽量复用 C 标准库中的字符串操作函数，Redis 保留了使用字符数组来保存实际的数据。但是和 C 语言仅用字符数组不同，Redis 还专门设计了 SDS（即简单动态字符串）的数据结构，内部存储数据使用的还是 C 语言中的字符数组，但定义了几个描述字符数组的元数据</strong>。SDS 结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/data_structure/redis-sds-struct.jpg" alt></p><p>首先，SDS 结构里包含了一个<strong>字符数组 buf[]，用来保存实际数据</strong>。同时，SDS 结构里还包含了三个元数据，分别是<strong>字符数组现有长度 len</strong>、<strong>分配给字符数组的空间长度 alloc</strong>，以及 <strong>SDS 类型 flags</strong>。其中，<strong>Redis 给 len 和 alloc 这两个元数据定义了多种数据类型，进而可以用来表示不同类型的 SDS</strong>。<strong>注意：</strong>sds 可用的（空闲的）长度:  avail = alloc - len 。</p><p>此外，Redis 使用 typedef 给 char* 类型定义了一个别名，这个别名就是 sds ，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型别名，是 SDS 中用于存储字符数据的属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>SDS 本质上还是一个字符数组，因为<strong>核心的存储数据还是使用 C 语言中的字符数组，只是在字符数组的基础上增加了额外的元数据。</strong>在 Redis 中需要用到字符数组时，就直接使用 sds 这个别名，它是 SDS 结构体中用于存储字符的属性。<strong>注意 sds 和 SDS 结构体的区别与联系。</strong></p><h2 id="创建-SDS"><a href="#创建-SDS" class="headerlink" title="创建 SDS"></a>创建 SDS</h2><p>了解了 SDS 结构设计后，我们简单看下 Redis 是如何创建字符串的。Redis 会调用 SDS 中的创建函数 sdsnewlen 新建 SDS 结构体，并把 SDS 结构体中的数组 buf[] 赋给 sds 类型变量，然后把要创建的字符串拷贝给 sds 变量。下面的代码显示了创建 SDS 的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的 SDS 字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param init 初始化字符串指针</span></span><br><span class="line"><span class="comment"> * @param initlen 初始化字符串长度</span></span><br><span class="line"><span class="comment"> * @param trymalloc</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sds _sdsnewlen(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen, <span class="keyword">int</span> trymalloc) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向 SDS 结构体的指针</span></span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sds 类型变量，即 char* 字符数组</span></span><br><span class="line">    sds s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据初始化字符串长度选择对应类型的 sds</span></span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8 since type 5 is not good at this. */</span></span><br><span class="line">    <span class="comment">// 创建空字符串通常是为了追加。利用 类型8 因为 类型5 不擅长这个。</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  type 对应的 SDS 结构体中元数据的长度</span></span><br><span class="line">    <span class="comment">// todo hdrlen 是SDS结构体中元数据的长度</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line">    <span class="keyword">size_t</span> usable;</span><br><span class="line"></span><br><span class="line">    assert(initlen + hdrlen + <span class="number">1</span> &gt; initlen); <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据是否尝试 malloc，新建SDS结构，并分配内存空间</span></span><br><span class="line">    <span class="comment">// todo sh 指向当前新建的 SDS 结构，即 sh指向SDS结构体起始位置</span></span><br><span class="line">    sh = trymalloc ?</span><br><span class="line">         s_trymalloc_usable(hdrlen + initlen + <span class="number">1</span>, &amp;usable) :</span><br><span class="line">         s_malloc_usable(hdrlen + initlen + <span class="number">1</span>, &amp;usable);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区相关</span></span><br><span class="line">    <span class="keyword">if</span> (init == SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有初始化内容</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen + initlen + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sh + hdrlen 表示将指向 SDS 结构的指针移动到 SDS 结构体中的 buf</span></span><br><span class="line">    <span class="comment">// todo 把 SDS 结构体中的数组 buf[] 赋给 sds 类型变量</span></span><br><span class="line">    s = (<span class="keyword">char</span> *) sh + hdrlen;</span><br><span class="line"></span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *) s) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防御性编程，防止超过当前 SDS 能表示的字符数组长度</span></span><br><span class="line">    usable = usable - hdrlen - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (usable &gt; sdsTypeMaxSize(type))</span><br><span class="line">        usable = sdsTypeMaxSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型，为 SDS 结构体属性赋值</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="comment">// 已废弃</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// 根据不同的 SDS 类型，初始化 SDS 结构体属性</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们拷贝给 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以 \0 结尾，表示字符串结束，用于兼容 C 字符串</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 SDS 结构</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SDS-操作效率"><a href="#SDS-操作效率" class="headerlink" title="SDS 操作效率"></a>SDS 操作效率</h2><p>因为 SDS 结构中<strong>记录了字符数组已占用的空间和被分配的空间</strong>，这就比传统 C 语言实现的字符串基础长度操作会带来更高的操作效率。</p><p>以字符串追加操作为例进行介绍。Redis 中实现字符串追加的函数是 sds.c 文件中的 sdscatlen 函数。这个函数的参数一共有三个，分别是目标字符串 s、源字符串 t 和要追加的长度 len，源码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将长度为 len 的字符串 t 追加到 sds 的字符串末尾</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 目标字符串</span></span><br><span class="line"><span class="comment"> * @param t 源字符串</span></span><br><span class="line"><span class="comment"> * @param len 要追加的字符串长度</span></span><br><span class="line"><span class="comment"> * @return 追加成功返回新 sds ，失败返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取目标字符串s的当前长度</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    <span class="comment">//根据要追加的长度len和目标字符串s的现有长度，判断是否要扩容</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将源字符串t中len长度的数据拷贝到目标字符串结尾</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    <span class="comment">//设置目标字符串的最新长度：拷贝前长度curlen加上拷贝长度</span></span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    <span class="comment">//拷贝后，在目标字符串结尾加上\0</span></span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，和 C 语言中的字符串操作相比，SDS 通过记录字符数组的使用长度和分配空间大小，避免了对字符串的遍历操作，降低了操作开销，进一步就可以帮助诸多字符串操作更加高效地完成，比如创建、追加、复制、比较等。</p><h2 id="内存预分配"><a href="#内存预分配" class="headerlink" title="内存预分配"></a>内存预分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对 SDS 中 buf 的长度进行扩展，确保在函数执行之后，buf 至少会有 addlen + 1 长度的空余空间。</span></span><br><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s buf</span></span><br><span class="line"><span class="comment"> * @param addlen 预计新增的字符串长度</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 获取 sds 目前可用的空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 s 对应的 SDS 类型（在创建 SDS 时，内部属性 buf[-1] 保存的就是 SDS 类型）</span></span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line">    <span class="keyword">size_t</span> usable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 sds 目前的剩余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-- 执行到这里，说明 sds 剩余空间不足，需要进行扩容 ----*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 获取 sds 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 获取 sds 所在的 SDS 结构体</span></span><br><span class="line">    sh = (<span class="keyword">char</span> *) s - sdsHdrSize(oldtype);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 获取新的长度，sds 当前长度 + addlen</span></span><br><span class="line">    newlen = (len + addlen);</span><br><span class="line">    assert(newlen &gt; len);   <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 判断是否需要扩容，以实现预分配</span></span><br><span class="line">    <span class="comment">// todo 小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7 根据预扩容的大小，获取对应类型的 SDS</span></span><br><span class="line">    <span class="comment">// todo 为了有效节省内存空间，使用不同的 SDS 类型保存相应大小的数据</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SDS_TYPE_5 已经废弃，如果是 SDS_TYPE_5 ，则默认使用 SDS_TYPE_8</span></span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*---- 确定了 SDS 类型，就可以进行空间分配了 --------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8 获取结构头的大小，即 SDS 结构体的元数据大小</span></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    assert(hdrlen + newlen + <span class="number">1</span> &gt; len);  <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.1 如果 SDS 类型还是之前的类型</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype == type) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结构头大小不变，无需要将字符串向前移动，即无需数据拷贝</span></span><br><span class="line">        <span class="comment">// 新的指向 SDS 指针</span></span><br><span class="line">        newsh = s_realloc_usable(sh, hdrlen + newlen + <span class="number">1</span>, &amp;usable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内容不足，分配失败</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 SDS 中的 char buf[]</span></span><br><span class="line">        s = (<span class="keyword">char</span> *) newsh + hdrlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.2 如果 SDS 类型是新的类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于结构头大小改变，需要将字符串向前移动，不能使用 realloc</span></span><br><span class="line">        <span class="comment">// 新的指向 SDS 指针</span></span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,and can't use realloc */</span></span><br><span class="line">        newsh = s_malloc_usable(hdrlen + newlen + <span class="number">1</span>, &amp;usable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内容不足，分配失败</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原来的字符串数据拷贝到新的 SDS 中的 buf 中</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span> *) newsh + hdrlen, s, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的 SDS 结构体</span></span><br><span class="line">        s_free(sh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 SDS 中的 char buf[]</span></span><br><span class="line">        s = (<span class="keyword">char</span> *) newsh + hdrlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// todo 标记 buf 属于哪种 SDS 类型</span></span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 sds 实际长度</span></span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9 获取 SDS 结构体最大可存储字符串的长度，这里 -1 是包括数组最后一位 \0</span></span><br><span class="line">    usable = usable - hdrlen - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防御性编程</span></span><br><span class="line">    <span class="keyword">if</span> (usable &gt; sdsTypeMaxSize(type))</span><br><span class="line">        usable = sdsTypeMaxSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 sds 分配的长度，注意，这里并不是直接使用扩容后的 newlen ,而是使用计算得来。</span></span><br><span class="line">    <span class="comment">// 注意，分配的长度不包括 \0 占用的字符</span></span><br><span class="line">    sdssetalloc(s, usable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用内存预分配，可以减少连续执行字符串增长操作所需的内存重新分配次数，也可以避免缓冲区溢出。</p><h2 id="紧凑型字符串结构"><a href="#紧凑型字符串结构" class="headerlink" title="紧凑型字符串结构"></a>紧凑型字符串结构</h2><p>SDS 结构中有一个元数据 flags，表示的是 SDS 类型。事实上，SDS 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。这 5 种类型的<strong>主要区别就在于：</strong>它们数据结构中的<strong>字符数组现有长度 len 和分配空间长度 alloc，这两个元数据的数据类型不同</strong>。下面以 sdshdr8 为例，它的定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="comment">// 字符数组现有长度。 8 位无符号整型，占用 1 字节的内存空间</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="comment">// 字符数组已经分配的长度, 不包括结构体和\0结束符</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="comment">// SDS 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="comment">// 字符数组，用来保存实际数据</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到，现有长度 len 和已分配空间 alloc 的数据类型都是 uint8_t，它是 8 位无符号整型，会占用 1 字节的内存空间。当字符串类型是 sdshdr8 时，<strong>它能表示的字符数组长度（包括数组最后一位\0）不会超过 256 字节（2 的 8 次方等于 256）</strong>。</p><p>实际上，<strong>SDS 之所以设计不同的结构头（即不同类型），是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。因为在保存不同大小的字符串时，结构头占用的内存空间也不一样，这样一来，在保存小字符串时，结构头占用空间也比较少。</p><h2 id="使用编译优化来节省内存空间"><a href="#使用编译优化来节省内存空间" class="headerlink" title="使用编译优化来节省内存空间"></a>使用编译优化来节省内存空间</h2><p>除了设计不同类型的结构头，Redis 在编程上还 <strong>使用了专门的编译优化来节省内存空间</strong>。</p><p>在定义不同类型的结构头时，使用了 <code>__attribute__ ((__packed__))</code> ，目的是告诉编译器，在编译结构时，不要使用字节对齐的方式，而是<strong>采用紧凑的方式分配内存</strong>。下面以 sdshdr8 结构定义为例进行分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span></span></span><br></pre></td></tr></table></figure><p>在默认情况下，编译器会按照 8 字节对齐的方式，给变量分配内存。也就是说，即使一个变量的大小不到 8 个字节，编译器也会给它分配 8 个字节。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>针对 C 语言中 char* 实现字符串的缺陷，Redis 基于 char* 基础之上设计了 SDS 结构。这一设计是从 <code>操作效率</code>、<code>二进制安全</code>、<code>内存开销</code> 以及<code>兼容 C 字符串</code> 方面思考的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;字符串作为我们日常开发常见的数据类型，几乎任何地方都可能用到，这就要求字符串的实现需要满足以下要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能支持丰富且
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - Redis主流程</title>
    <link href="https://gentryhuang.com/posts/19fe4bc5/"/>
    <id>https://gentryhuang.com/posts/19fe4bc5/</id>
    <published>2021-11-27T16:00:00.000Z</published>
    <updated>2021-12-07T03:19:06.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇文章将从源码层面对 Redis 主干轮廓进行说明。以主线程执行流程为主干，对途径的枝枝蔓蔓简单介绍，不会过度展开，后续将针对每一个模块进行详细分析。由于 Redis 是用 C 语言实现的，当然应该从 main 函数开启阅读源码旅程。</p><h1 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h1><p>Redis 服务器启动的入口是 main 函数，其它的无需多说，下面直接上代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis Server 启动入口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *  Redis是用C语言实现的，从 main 函数启动。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">char</span> config_from_stdin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    <span class="comment">// 1 初始化库</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 检查服务器是否以 Sentinel 模式启动</span></span><br><span class="line">    <span class="comment">// 这一点非常重要，因为 Sentinel 和普通的实例不同</span></span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3  初始化服务器配置</span></span><br><span class="line">    initServerConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 ACL 初始化（6.0 对 ACL 进行了功能丰富）</span></span><br><span class="line">    ACLInit(); <span class="comment">/* The ACL subsystem must be initialized ASAP because the</span></span><br><span class="line"><span class="comment">                  basic networking code and client creation depends on it. */</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 5 如果服务器以 Sentinel 模式启动，那么需要进行 Sentinel 功能相关的初始化，并为要监视的主服务器创建一些相应的数据结构</span></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        <span class="comment">// Sentinel 所属的属性覆盖服务器默认的属性</span></span><br><span class="line">        initSentinelConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哨兵模式初始化</span></span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 6 是否需要在 redis-check-rdb/aof模式下启动，这样可以校验持久化文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>], <span class="string">"redis-check-rdb"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_rdb_main(argc, argv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>], <span class="string">"redis-check-aof"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_aof_main(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7 检查用户是否指定了配置文件，或者配置选项</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">background</span> = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8 将服务器设置为守护进程运行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">background</span>) daemonize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9 创建并初始化服务器</span></span><br><span class="line">    initServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🌟 服务器不是运行在 SENTINEL 模式，那么执行以下代码</span></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 10  bio 和 io 线程的初始化</span></span><br><span class="line">        InitServerLast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11 从 AOF 文件或者 RDB 文件中载入数据</span></span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                          <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                          <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 以 SENTINEL 模式运行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        <span class="comment">// bio 和 io 线程的初始化</span></span><br><span class="line">        InitServerLast();</span><br><span class="line">        <span class="comment">// Sentinel 准备就绪后执行</span></span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12 🌟 启动事件处理循环</span></span><br><span class="line">    <span class="comment">// 主要围绕 IO多路复用 展开的，驱动注册的时间事件回调和 IO 事件回调</span></span><br><span class="line">    aeMain(server.el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12 退出事件循环，回收内存</span></span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retun 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 服务启动后，主线程 main 会依次执行以上流程，直到进入 <strong>aeMain</strong> 事件处理循环方法中。需要说明的是，上述代码片段删除掉了不关心的逻辑，本篇文章我们只关注以下两个逻辑：</p><ul><li>执行各种初始化</li><li>执行事件循环</li></ul><p>Redis 服务器初始化逻辑较为复杂，从底层的数据结构到服务器不同的角色，初始化的逻辑和属性都不一样，这里就不展开了。下面对流程进行概括：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/themory/redis-outline-main-process.jpg" alt></p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>事件循环逻辑是 Redis 核心的直接体现，它就是在这个循环中不断处理网络请求和内部自身逻辑的。下面我们直接上代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;<span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程进入主循环，一直处理事件，直到服务器关闭</span></span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;<span class="built_in">stop</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始处理事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS |</span><br><span class="line">                                   AE_CALL_BEFORE_SLEEP |</span><br><span class="line">                                   AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只要事件循环 <code>aeEventLoop</code> 没有被停止，主线程 main 就会一直自旋，不断执行 <code>aeProcessEvents</code> 方法。不难看出 <code>aeProcessEvents</code> 方法封装了 Redis 的所有功能逻辑，这里提前说下，Redis 的功能逻辑总共两大类：一个是网络事件，也称为文件事件；另一个是时间事件；前者用于处理网络中的交互，后者用于处理 Redis 自身的一些逻辑。</p><p>下面继续贴出 <code>aeProcessEvents</code> 方法的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line">        <span class="keyword">int64_t</span> usUntilTimer = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取最近的时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            usUntilTimer = usUntilEarliestTimer(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1 使用 usUntilTimer 来决定文件事件的阻塞时间</span></span><br><span class="line">        <span class="keyword">if</span> (usUntilTimer &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            tv.tv_sec = usUntilTimer / <span class="number">1000000</span>;</span><br><span class="line">            tv.tv_usec = usUntilTimer % <span class="number">1000000</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2 执行到这里，说明没有时间事件。那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                <span class="comment">// 设置文件事件不阻塞</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                <span class="comment">// 文件事件阻塞直到有事件到达为止</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">            tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2 前置回调函数 - beforeSleep */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">        <span class="number">3</span> 调用多路复用 API，只会在超时或某些事件触发时返回。即等待事件产生</span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* 4 后置回调函数 - beforeSleep */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.1 从已就绪数组中获取文件描述符信息</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.2 如果是套接字上发生读事件，调用读事件处理器处理读事件</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                fired++;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Fire the writable event. */</span></span><br><span class="line">            <span class="comment">// 5.3 如果是套接字上发生写事件，调用写事件处理器处理写事件</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">             * after the writable one.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 如果需要反转调用，在可写事件之后触发可读事件</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (invert) &#123;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">                <span class="keyword">if</span> ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp;</span><br><span class="line">                    (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc)) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 6 如果是时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        <span class="comment">// 执行时间事件</span></span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码片段中也可以看到，主线程在不断轮询时间事件和文件事件，找到就尝试执行。上述代码虽然简短，但是却几乎包含了 Redis 的所有功能，秘密就在以下几个组件中：</p><ul><li>前置处理器 beforeSleep </li><li>IO多路复用库（及多种回调函数）</li><li>后置处理器 afterSleep</li></ul><p>关于以上代码片段背后的信息，会在后面的文章中介绍 Redis 事件一文中详细说明，这里先不展开。下面对以上方法进行概括：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/themory/redis-outline-multi-process.jpg" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章简单介绍了 Redis 启动的入口以及执行的主干流程，这里有个印象即可，后续会对每个模块展开说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本篇文章将从源码层面对 Redis 主干轮廓进行说明。以主线程执行流程为主干，对途径的枝枝蔓蔓简单介绍，不会过度展开，后续将针对每一个模块进
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 源码结构总览</title>
    <link href="https://gentryhuang.com/posts/adccc332/"/>
    <id>https://gentryhuang.com/posts/adccc332/</id>
    <published>2021-11-27T06:59:01.000Z</published>
    <updated>2021-12-07T03:20:43.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从本篇文章开始，将对 Redis 核心原理以及相关源码进行分析，需要说明的是，笔者阅读的 Redis 版本是 <code>#define REDIS_VERSION &quot;6.2.4&quot;</code>，之所以选择较新的版本，因为笔者对 Redis 一些新特性比较感兴趣，特别是 Redis 在 6.0 版本中提出的 IO 多线程。</p><h1 id="Redis-源码结构"><a href="#Redis-源码结构" class="headerlink" title="Redis 源码结构"></a>Redis 源码结构</h1><p>了解源码的整体目录结构是快速对代码进行认知的一个行之有效的方法。下面我们对 Redis 的源码目录进行简单介绍。</p><h2 id="Redis-源码整体结构"><a href="#Redis-源码整体结构" class="headerlink" title="Redis 源码整体结构"></a>Redis 源码整体结构</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-summary-struct.jpg" alt></p><p>对于 Redis 来说，在它的源码总目录下，一共包含了 <strong>deps</strong>、<strong>src</strong>、<strong>tests</strong>、<strong>utils</strong> 四个子目录，这四个子目录分别对应了 Redis 中发挥不同作用的代码，下面我们具体来看看。</p><h3 id="deps-目录"><a href="#deps-目录" class="headerlink" title="deps 目录"></a>deps 目录</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-deps-struct.jpg" alt></p><p>这个目录<strong>主要包含了 Redis 依赖的第三方代码库</strong>，包括 Redis 的 C 语言版本客户端代码 hiredis、jemalloc 内存分配器代码、readline 功能的替代代码 linenoise，以及 lua 脚本代码。</p><p>这部分代码的一个显著特点，就是<strong>它们可以独立于 Redis src 目录下的功能源码进行编译</strong>，也就是说，它们可以独立于 Redis 存在和发展。</p><h3 id="src-目录"><a href="#src-目录" class="headerlink" title="src 目录"></a>src 目录</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-src-struct.jpg" alt></p><p>目录里面包含了 Redis 所有功能模块的代码文件，也是 Redis 源码的重要组成部分。src 目录下只有一个 modules 子目录，剩余的源码文件都是在 src 目录下，没有再分下一级子目录。因为 Redis 的功能模块实现是典型的 C 语言风格，不同功能模块之间不再设置目录分隔，而是通过头文件包含来相互调用。</p><h3 id="tests-目录"><a href="#tests-目录" class="headerlink" title="tests 目录"></a>tests 目录</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-tests-struct.jpg" alt></p><p>在 Redis 的代码目录中，将功能测试和单元测试分代码用一个 tests 目录统一管理了起来。Redis 实现的测试代码可以分成四部分，分别是单元测试（对应 unit 子目录），Redis Cluster 功能测试（对应 cluster 子目录）、哨兵功能测试（对应 sentinel 子目录）、主从复制功能测试（对应 integration 子目录）。这些子目录中的测试代码使用了 Tcl 语言（通用的脚本语言）进行编写，主要目的就是方便进行测试。</p><p>在 tests 目录中，除了有针对特定功能模块的测试代码外，还有一些代码是用来支撑测试功能的，这些代码在 assets、helpers、modules、support 四个目录中。</p><h3 id="utils-目录"><a href="#utils-目录" class="headerlink" title="utils 目录"></a>utils 目录</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-utils-struct.jpg" alt></p><p>在 Redis 开发过程中，还有一些功能属于辅助性功能，包括用于创建 Redis Cluster 的脚本、用于测试 LRU 算法效果的程序，以及可视化 rehash 过程的程序。在 Redis 代码结构中，这些功能代码都被归类到了 utils 目录中统一管理。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Redis 源码的整体结构相对还是比较简单的，但定义的这些包结构涵盖了一个应用软件所具备的所有功能。通过本篇文章先从代码结构层面对 Redis 有个了解，后续将针对核心模块进行原理介绍，以及源码的阅读。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>笔者刚入门编程时学习的就是 C 语言，虽然掌握了 Redis 的核心模块的工作原理，但也只是停留在记忆和理解层面，也曾尝试过阅读 Redis 的源码，但并不系统。偶然的机会，看见极客时间推出的 Redis 源码课程，就决定重新对 Redis 源码进行梳理和补充，最终的目标就是 <strong>知其原理，懂其源码！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从本篇文章开始，将对 Redis 核心原理以及相关源码进行分析，需要说明的是，笔者阅读的 Redis 版本是 &lt;code&gt;#define R
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>限流算法</title>
    <link href="https://gentryhuang.com/posts/32609cb8/"/>
    <id>https://gentryhuang.com/posts/32609cb8/</id>
    <published>2021-11-23T16:00:00.000Z</published>
    <updated>2021-11-30T09:26:37.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>限流顾名思义是限制流量，目的是为了保障服务稳定运行，避免服务被流量冲垮。</p><p>为什么要限流？因为再厉害的系统总有所能承载的能力上限，一旦流量突破这个上限，就会引起实例宕机，进而发生系统雪崩，带来灾难性后果。限流是系统自我保护的最直接手段，当流量超出服务处理能力时，部分请求将会被限流组件拦截，根据具体业务场景选择丢失。</p><h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>计算器算法的思想很简单，每当一个请求到来时，就将计数器加一，当计数器数值超过阈值后，就拒绝接收到的请求。在指定周期内，计数器会重置，开始新一轮的计数。计数器算法简单粗暴，易于实现。但是缺点也是很大的，容易造成前一个时间段非常忙碌，下一时间段又非常空闲。</p><h2 id="漏通算法"><a href="#漏通算法" class="headerlink" title="漏通算法"></a>漏通算法</h2><p>漏桶算法由流量容器、流量入口和流量出口组成。流量入口一般就是业务请求，流量容器用于暂存一定大小的业务流量，流量出口则是我们设定的限速值，比如 1000 QPS。漏桶算法如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/current_limiting/current-limiting-bucket.png" alt></p><p>如上图，流入漏桶流量的流速是不可控的，但流出流量的速度是恒定的，而漏桶的容量是有限的，这就会导致一旦流入流量超出漏桶容量，这部分流量只能被丢弃了。</p><p>漏桶算法可以通过暂存一定的流量达到流量整形的目的，但是漏桶不能处理突发流量。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶和漏桶算法既有相似之处，又有很大的不同，不同之处也是令牌桶算法能够支持突发流量的原因。</p><p>令牌桶算法需要一个令牌工厂以一定周期向令牌桶中放入令牌，当令牌桶满了之后，多出的令牌会被丢弃。每当一个请求到来时都会先从令牌桶中取令牌，由于令牌桶中可能存放了很多令牌，因此允许多个请求同时取令牌，如果令牌够多就可以在一定程度上支持突发流量。当令牌桶中没有令牌后，无法获取到令牌的请求可以丢弃，或者重试。令牌桶算法如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/current_limiting/current-limiting-token.png" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章简单介绍了常见的三种限流算法，它们被落地到不同的实现中，如 Dubbo 中的 <code>TpsLimitFilter</code> 使用的就是计算器限流算法，Google 提供的 <code>RateLimiter</code> 开源包使用的是基于令牌桶算法。</p><p><strong>总体来说，限流既可以是在客户端限流，也可以是在服务端限流。此外，限流的实现方式既可支持 URL 以及方法级别的限流，也可支持基于 QPS 和线程的限流。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;限流顾名思义是限制流量，目的是为了保障服务稳定运行，避免服务被流量冲垮。&lt;/p&gt;
&lt;p&gt;为什么要限流？因为再厉害的系统总有所能承载的能力上限
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="限流" scheme="https://gentryhuang.com/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>并发 - JMM</title>
    <link href="https://gentryhuang.com/posts/11b0627b/"/>
    <id>https://gentryhuang.com/posts/11b0627b/</id>
    <published>2021-09-20T01:14:12.000Z</published>
    <updated>2022-01-07T07:54:44.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章将对 Java 的内存模型（JMM）进行介绍，本质上它是一种编程语言规范，用于尝试统一一个能够在各种处理器架构中为并发提供一致语义的内存模型（不同处理器架构一般具有不同强度的模型）。驱动 Java 内存模型产生的原因有很多，如编译器优化、处理器乱序执行和缓存等，这些因素导致并发程序中有些行为是非法的。因此，在介绍 Java 内存模型之前，我们先对并发编程相关概念进行说明，然后再引出 Java 内存模型。</p><h1 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h1><p>了解现代计算机硬件架构对理解 Java 内存模型非常重要，常见的硬件内存架构图如下：</p><p><img src="/posts/11b0627b/computer-hardware-memory-architecture.jpg" alt></p><p>下面我们重点对硬件内存架构的组成，缓存一致性问题进行介绍。</p><h2 id="硬件内存组成"><a href="#硬件内存组成" class="headerlink" title="硬件内存组成"></a>硬件内存组成</h2><p>现代计算机内存架构包括：多CPU、CPU寄存器、CPU缓存以及共享的内存。</p><p><strong>多CPU</strong></p><blockquote><p>现代计算机通常有 2 个或更多 CPU ，其中一些 CPU 可能具有多个核。当只有一个 CPU 时，要运行多个程序（进程）的话，就意味着要经常进行进程上下文切换。尽管单 CPU 是多核，也只是多个处理器核心，其他设备都是共用的，所以多个进程就必然要经常进行进程上下文切换，这个代价是很高的。</p></blockquote><p><strong>CPU多核</strong></p><blockquote><p>一个多核的 CPU 也就是一个 CPU 上有多个处理器核心。</p></blockquote><p><strong>CPU寄存器</strong></p><blockquote><p>每个 CPU 都包含一组寄存器，它们是 CPU 内存的基础。CPU 在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为 CPU 访问寄存器的速度远大于主存。</p></blockquote><p><strong>CPU缓存</strong></p><blockquote><p>每个 CPU 还可能有一个 CPU 缓存存储器层。事实上，大多数现代 CPU 都有一定大小的缓存层，位于 CPU 与主内存间的一种容量较小但速度很高的存储器，但通常不如访问其内部寄存器的速度快。由于 CPU 的速度远高于主内存，CPU 直接从主内存中存取数据要等待一定时间周期。CPU 缓存中保存着 CPU 刚用过或循环使用的一部分数据，当 CPU 再次使用该部分数据时可从缓存中直接获取, 减少了 CPU 的等待时间，提高了系统的效率。</p></blockquote><p>一些 CPU 可能有多个缓存层，具体如下：</p><blockquote><ul><li><strong>一级缓存(L1 Cache)</strong>: 容量最小，速度最快，每个核独有。针对指令和数据分为数据缓存和指令缓存</li><li><strong>二级缓存(L2 Cache)</strong>: 容量比 L1 大，速度比 L1 慢，每个核独有</li><li><strong>三级缓存(L3 Cache)</strong>: 容量最大，速度最慢，<strong>多个核共享</strong></li></ul></blockquote><p>由于Cache的容量很小，一般都是充分的利用局部性原理，按<strong>行/块</strong>来和主存进行批量数据交换，以提升数据的访问效率。</p><p><strong>内存</strong></p><blockquote><p>计算机还包含一个主存储区 (RAM)，所有 CPU 都可以访问它。主内存区域通常比 CPU 的高速缓存大得多。</p></blockquote><p><strong>读取数据</strong></p><blockquote><ul><li><strong>取寄存器中的值</strong>: 只需要一步，直接读取即可。</li><li><strong>取L1中的值</strong>: 先锁住<strong>缓存行</strong>，然后取出数据，最后解锁。如果没有锁住说明慢了。</li><li><strong>取L2中的值</strong>: 先到 L1 中取，L1 中不存在再到 L2 中取。L2 开始加锁，将 L2 中的数据复制到 L1 ，再执行从 L1 中读取数据的步骤，解锁 L2。</li><li><strong>取L3中的值</strong>: 同样地，先将数据由 L3 复制到 L2，然后从 L2 复制到 L1 ，从 L1 读取数据。</li></ul></blockquote><p>CPU 在读取数据时，先在 L1 中寻找，再从 L2 中寻找，再从 L3 中寻找，然后是内存，最后是外存储器。</p><h2 id="CPU优化手段"><a href="#CPU优化手段" class="headerlink" title="CPU优化手段"></a>CPU优化手段</h2><p>为了提高程序运行的性能，现代 CPU 在很多方面对程序进行了优化。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>CPU 高速缓存，尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存提高性能。</p><p><img src="/posts/11b0627b/cpu-cache-level.jpg" alt></p><h3 id="运行时指令重排"><a href="#运行时指令重排" class="headerlink" title="运行时指令重排"></a>运行时指令重排</h3><p>为了提高 CPU 处理性能，CPU 可能会乱序执行。如，当 CPU 写缓存时发现缓存曲块正被其它 CPU 占用，为了提高 CPU 处理性能，可能将后面的读缓存命令优先执行。</p><p><img src="/posts/11b0627b/cpu-command-process.jpg" alt></p><p>注意，CPU 指令重排并非随意重排，需要遵守 <strong>as-if-serial语义</strong> ，该语义表示：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，运行时和处理器都必须遵守 <strong>as-if-serial 语义</strong>。也就是说，编译器和处理器<strong>不会对存在数据依赖关系的操作做重排序</strong>。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>基于高速缓存很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题-<strong>缓存一致性(CacheCoherence)</strong>。缓存中的数据与主内存的数据并不是实时同步的，各 CPU（或 CPU 核）间缓存的数据也不是实时同步。也就是说，在同一个时间点，各 CPU 所看到同一内存地址的数据的值可能不一致。如，当多个处理器执行的任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，这样不一致的情况如果同步回主内存时以哪个处理为准呢？</p><p><img src="/posts/11b0627b/computer-hardware-memory-architecture-issue.jpg" alt></p><p>运行在左侧 CPU 上的一个线程将共享对象复制到其 CPU 缓存中，并将其count变量更改为 2。此更改对运行在右侧 CPU 上的其他线程不可见，因为更新的count尚未刷新回主内存.</p><h3 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h3><p>所有内存的传输都发生在一条共享的总线上，所有的处理器都会使用该总线。虽然 CPU 缓存各自是独立的，但是主存是共享的，所有的内存访问都要经过总线加锁机制来决定是否可以进行内存的读写，也就是说在同一个指令周期中，只可能有一个 CPU 可以读写内存。</p><p>所谓总线锁就是使用处理器提供的一个 <code>LOCK#信号</code> ，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，只有该处理器可以独占共享内存。</p><h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>总线锁虽然可以保证缓存数据的一致性，但是它比较粗暴，当某个 CPU 对总线进行加锁后，所有后续其它 CPU 对主存的操作都是阻塞的，这样机制就必定会降低性能。因此，缓存一致性协议出现了，它是硬件程序的产物，用来保证缓存之间可见。</p><p>缓存一致性协议有多种，如 <strong>MSI</strong>、<strong>MESI</strong> 等，多数 CPU 厂商对缓存一致性协议进行了实现。下面我们以 <strong>MESI</strong> 协议为例，对其进行介绍。</p><p><strong>MESI协议</strong>规定每个缓存行有个状态位，同时定义了下面四个状态：</p><h4 id="专有态-Exclusive"><a href="#专有态-Exclusive" class="headerlink" title="专有态(Exclusive)"></a>专有态(Exclusive)</h4><p>锁住的缓存行内容只存在当前 CPU 缓存中且同于主存，不出现于其它缓存中，所以当 CPU 发现自己缓存中的共享数据是<strong>专有态(Exclusive)</strong>时，说明该数据是最新的，可以直接读取。</p><p>当缓存行处于<strong>专有态(Exclusive)</strong>时，在任何时刻当有其它 CPU 缓存了该数据时，那么缓存行会由<strong>专有态(Exclusive)</strong>变成<strong>共享态(Shared)</strong>。</p><h4 id="共享态-Shared"><a href="#共享态-Shared" class="headerlink" title="共享态(Shared)"></a>共享态(Shared)</h4><p>锁住的缓存行同于主存，且该缓存行可能被多个 CPU 缓存，各个缓存与主内存数据一致，所以当 CPU 发现自己缓存中的共享数据是<strong>共享态(Shared)</strong>时，说明该数据是最新值，可以直接读取。</p><p>当缓存行处于<strong>共享态(Shared)</strong>时，当任一个 CPU 修改缓存行时，其它 CPU 中该缓存行变成<strong>无效态(Invalid)</strong>。</p><h4 id="修改态-Modified"><a href="#修改态-Modified" class="headerlink" title="修改态(Modified)"></a>修改态(Modified)</h4><p>锁住的缓存行已被修改（脏行），内容已不同于主存。该状态是一个中间状态，缓存行的数据需要在未来某个时间点写回主内存，当被写回主内存之后，该缓存行就会变成专有状态。</p><p>当 CPU 对缓存行进行修改时，变为<strong>修改态(Modified)</strong>，并且同时会向其他缓存了该数据的 CPU 缓存发送一条 Invalid 指令，告诉其他缓存自己对数据进行了修改，让它们把数据对应的缓存行置为<strong>无效态(Invalid)</strong>； 当收到其它 CPU 缓存 Invalid 指令的成功响应时，当前 CPU 缓存会就会把数据同步到主存里面去，然后自己的缓存行由<strong>修改态(Modified)</strong>变为<strong>专有态(Exclusive)</strong>，当有其他 CPU 缓存从主存中读取到了最新的数据时，数据状态会变为<strong>共享态(Shared)</strong>。</p><h4 id="无效态-Invalid"><a href="#无效态-Invalid" class="headerlink" title="无效态(Invalid)"></a>无效态(Invalid)</h4><p>当缓存行处于<strong>无效态(Invalid)</strong>时，说明对应的数据已经被其它 CPU 修改过了，当前锁住的缓存行无效，必须从主存中重新读取。</p><p>无效态(Invalid)是由于收到其它 CPU 发来的 Invalid 指令，收到该指令的 CPU 缓存会把对应的缓存行状态标记为<strong>无效态(Invalid)</strong>，所以当数据处于<strong>无效态(Invalid)</strong>时表示数据已经被别人修改了，当前数据是无效的。</p><p>多处理器时，单个 CPU 对缓存中数据进行改动需要通知给其他 CPU 。也就意味着在缓存一致性协议下，CPU 处理要控制自己的读写操作，还要监听（嗅探）其它 CPU 发出的通知，从而保证<strong>最终一致</strong>。</p><p>这里需要说明下，MESI协议可以在 CPU 修改数据时向其他 CPU 发送消息，但不会出现两个CPU同时修改数据，进而向其他CPU进行消息通知。这样的并发修改通过缓存锁定机制解决的，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性。只有在数据修改的时候才会需要加缓存锁，修改数据的时候先锁定缓存行，不让其他CPU同时修改，其他CPU读取数据是允许的。缓存是否失效是由缓存一致性协议来处理的，它解决一个 CPU 修改其它 CPU 看不到的问题。缓存锁解决几个 CPU 并发修改的问题。</p><p><strong>以下两种情况下处理器会使用总线锁：</strong></p><ul><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时</li><li>处理器不支持缓存锁定</li></ul><h4 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h4><p>前文在描述 MESI 协议时，如果对缓存行进行修改需要经历以下过程：</p><ol><li>某个CPU修改自己缓存的值</li><li>修改缓存后通知其它CPU，等待其它CPU响应</li><li>收到所有CPU的响应</li><li>将缓存中的数据同步到主存</li></ol><p>可以看到，以上整个过程都是同步的，CPU 发送完通知后必须同步等待所有其它 CPU 的响应，而这个过程中当前 CPU 又无法释放出来，所以为了避免这种 CPU 运算资源的浪费，就需要一种方式来进行优化了，此时 <strong>Store Buffer</strong> 就出来了。</p><p><img src="/posts/11b0627b/cpu-store-buffer.png" alt></p><p>当 CPU 对某个共享变量修改时，向其他 CPU 发出 Invalid 指令后不同步等待其他 CPU 指令的响应了，而是直接把最新值写入 Store Bufferes 缓冲区里，然后直接可以去干别的事情了，直到所有的 CPU 都对 Invalid 指令响应后，再把共享变量的值从 Store Buffere 里拿出来，然后写入到自己的缓存里同时同步到主存中。</p><h4 id="Store-Forward"><a href="#Store-Forward" class="headerlink" title="Store Forward"></a>Store Forward</h4><p>Store Forward 称为存储转发。具体是：当 CPU 读取数据时需要先检查它的 Store Buffer 缓冲区中有没有，如果有则直接读取该缓冲区中的值，没有才会读取自己缓存中的值。解决了 Store Buffer 优化过程中由于只读取缓存导致的缓存脏数据问题。</p><p><img src="/posts/11b0627b/cpu-store-buffer-forward.png" alt></p><p>至此，Store Buffer 优化提升了 CPU 效率。但由于修改共享变量先是放到了 Store Buffer 中，只有等到其它 CPU 返回 Invalid OK 后才会同步到缓冲和主存。可以看出执行写操作不是立即生效的，对于有相互依赖的共享数据相关指令，可能会出现CPU乱序执行的现象。解决手段是利用<strong>内存屏障</strong>禁用CPU缓存优化，也就是更新数据时必须立即更新到主存（也就是把store buffer里的指令全部执行完）。</p><h4 id="Invalid-Queue"><a href="#Invalid-Queue" class="headerlink" title="Invalid Queue"></a>Invalid Queue</h4><p>因为 Store Buffer 空间很小，如果有大量的变量修改，它会存储不下，那么这个时候又回到同步通知的状态。此外，有时候其它 CPU 很繁忙并不能马上进行响应，因此为了避免同步等待响应的时间太长，就为每个 CPU 加一个失效队列，当 Store Buffer 存不下的时候，就把失效通知发送到其它 CPU 的失效队列里，只要队列成功接收到了发送的消息就进行响应（发送 Invalid 指令的 CPU 就可以将修改同步到主存了），等到其他CPU闲下来了就从各自的失效队列里读取消息然后失效掉CPU的缓存数据。</p><p>MESI 优化到了 Invalid Queue 阶段，一般来说性能已经很高了，但是在极端的情况下会出现缓存可见性问题。具体来说就是，接收到 Invalid 指令的 CPU 没有来得及处理它的实效队列中的消息，没有及时失效掉对应的缓存行，导致继续使用了本应该失效的缓存数据。这种因为CPU缓存优化而导致后面的指令查看不到前面指令的执行结果，就好像指令之间的执行顺序错乱了一样，这类现象也就是我们俗称的<strong>CPU乱序执行</strong>。解决方法很简单，直接禁用 CPU 缓存优化即可，也就是修改共享数据的指令都同步完成就能保证数据的可见性了，但是这样又会降低整体的性能，这样有点得不偿失，因为毕竟大部分情况下数据都不存在这种共享的问题。不过我们必须要为这种场景提供一种手段来禁用CPU缓存优化，而这种手段同样也是<strong>内存屏障</strong>机制，读取数据时必须读取最新的数据（也就是必须先把失效队列的数据先读取应用完）。</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>前文我们说的内存屏障可以同时作用于 Store Buffer 和 Invalidate Queue 。而实际上，对于写操作只需关心 Store Buffer ，读操作只需关心 Invalidate Queue 。因此，大多数 CPU 架构将内存屏障分为了读屏障和写屏障。内存屏障本质上是 CPU 提供的一组指令，不同的操作系统有不同的实现。</p><p><strong>读屏障:</strong> 任何读屏障前的读操作都会先于读屏障后的读操作完成，即读屏障指令执行后就能保证后面的读取数据指令一定能读取到最新的数据。<br><strong>写屏障:</strong> 任何写屏障前的写操作都会先于写屏障后的写操作完成，即遇到写屏障指令就必须把该指令之前的所有写入指令执行完毕才可以往下执行，这样就可以让CPU修改的数据及时暴露给其它CPU。<br><strong>全屏障:</strong> 同时包含读屏障和写屏障的作用</p><p>实际的 CPU 架构中，可能提供多种内存屏障，常见的如下：</p><ul><li>LoadLoad: 相当于前面说的读屏障</li><li>LoadStore: 任何该屏障前的读操作都会先于该屏障后的写操作完成</li><li>StoreLoad: 任何该屏障前的写操作都会先于该屏障后的读操作完成</li><li>StoreStore: 相当于前面说的写屏障</li></ul><p>实现原理都是类似的，如作用于Store Buffer和Invalidate Queue 。</p><h3 id="指令重排问题"><a href="#指令重排问题" class="headerlink" title="指令重排问题"></a>指令重排问题</h3><p>CPU 指令重排虽然遵守了 <strong>as-if-serial</strong> 语义，但仅在单 CPU 执行的情况下能保证结果正确。在多核多线程中，指令逻辑无法分辨因果关联，为了更好地利用流水线可能出现<strong>乱序执行</strong>，导致程序运行结果错误。</p><p>前文中谈的是内存屏障的可见性功能，它能够让屏障前的操作（读/写）及时执行、刷新，被其它 CPU 看到。而内存屏障还有个功能就是限制指令重排（读/写指令），否则即使内存屏障可以保证可见性，但由于不能保证指令重排，保证可见性意义也不大。</p><p>也就是说，内存屏障提供了一套解决CPU缓存优化而导致的顺序性和可见性问题的方案，但是由于不同的硬件系统提供的内存屏障指令可能都不一样，因此像 JAVA 这种高级编程语言就把不同的内存屏障指令统一进行了封装，让开发者不需要关心到系统的底层，而封装这套解决方案的模型就是Java内存模型(Java Memory Model)。</p><p>注意，除了运行期间 CPU 的指令重排，编译器在编译期间，可能也对指令进行重排，以使其对CPU更友好。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>了解了硬件内存架构后，从本小节开始，我们简单聊聊并发。</p><h2 id="并发编程关键问题"><a href="#并发编程关键问题" class="headerlink" title="并发编程关键问题"></a>并发编程关键问题</h2><p>在并发编程中需要处理两个关键问题：线程之间如何通信及线程之间如何同步。</p><p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种，共享内存和消息传递。共享内存通信机制中，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行<strong>隐式通信</strong>。消息传递通信机制中，线程之间没有公共状态，线程之间必须通过发送消息来<strong>显式通信</strong>。</p><p>同步是指程序中用于控制不同线程间操作发生的相对顺序的机制。在共享内存并发模型中，同步是显式进行的，也就是说程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型中，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p>Java 的并发采用的是<strong>共享内存模型</strong>，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><h2 id="并发特性"><a href="#并发特性" class="headerlink" title="并发特性"></a>并发特性</h2><p>随着 CPU、内存、I/O设备都在不断迭代，不断朝着更快的方向努力的同时，有一个核心矛盾一直存在，那就是这三者的速度差异。为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统和编译程序都做出了贡献，具体体现为：</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异。</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O设备的速度差异。</li><li>编译程序优化指令执行次序</li></ul><p><strong>总结起来就是：</strong>硬件增加缓存、软件增加线程、编译程序优化指令顺序。</p><p>以上优化带来好处的同时，也给并发程序埋下了祸根。带来的问题可以总结为：</p><ul><li>缓存导致可见性问题 </li><li>线程切换导致原子性问题 </li><li>指令优化导致有序性问题</li></ul><p>下面我们对以上问题详细说明。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>。</p><p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。</p><p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存，它们是无法直接通信的。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一个或者多个操作在 CPU 执行的过程中不被中断的特性称为<strong>原子性</strong>。</p><p>Java 并发程序都是基于多线程的，自然会涉及到线程切换，切换的时机大多数是在时间片结束的时候。操作系统做任务切换，可以发生在任何一条<strong>CPU 指令</strong>执行完，注意是 CPU 指令而非高级语言中的一条语句，因为高级语言中的一条语句可能包含多条 CPU 指令。<strong>也就是说，CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言级别。因此，很多时候需要我们自己在高级语言层面保证操作的原子性</strong>。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性指的是程序按照代码的先后顺序执行。但编译器、处理器为了优化性能有时会改变程序执行的次序，而这也是导致问题的原因。</p><p>缓存、线程、编译优化的目的都是提高程序性能的，但是技术在解决一个问题的同时，可能会带来另外一个问题，所以在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避。</p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>Java 的内存模型（JMM）本质上是一种编程语言规范，屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 Java 程序员呈现了一个一致的内存模型。不同点在于，JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型。JMM 通过定义多项规则对编译器和处理器进行限制，主要围绕原子性、有序性、可见性展开，具体来说包括 <strong>volatitle、synchronized 和 fianl 这三个关键字，以及系列 happens-before 原则</strong>。</p><p><strong>注意：</strong>JVM 内存模型和 Java 内存模型是完全不同的两个东西。JVM内存模型是一种内存逻辑划分，便于JVM 管理内存；JMM内存模型是对计算机硬件（处理器模型）的统一抽象，用来屏蔽差异。</p><h2 id="细化规范"><a href="#细化规范" class="headerlink" title="细化规范"></a>细化规范</h2><p>JMM 描述了程序的可能行为，程序执行产生的结果都可以由内存模型预测，它决定了在程序的每个点上可以读取什么值（读写是相互的，也就是写了后，读必须要读取到，这就要求写必须刷新到主内存）。既然 JMM 是一种规范，就需要给 JVM 开发者和厂商实现，需要细化规范。</p><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>可以在线程之间共享的内存称为共享内存或堆内存。所有实例字段，静态字段和数组元素都存储在堆内存中。Java 内存模型的抽象示意图如下：</p><p><img src="/posts/11b0627b/jmm-model.jpg" alt></p><p>JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本，线程对变量的所有操作都必须在本地内存中进行，而不能直接操作主内存中的变量。注意，本地内存是 JMM 的一个抽象概念，并不真实存在。</p><p>如果线程 A 与线程 B 之间要通信的话，必须经历以下2个步骤：</p><ul><li>线程 A 把本地内存中更新过的共享变量刷新到主内存中去。</li><li>线程 B 到主内存中去读取线程 A 之前已更新过的共享变量</li></ul><p>关于主内存与本地内存之间的具体交互，即一个变量如何从主内存拷贝到本地内存、如何从本地内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成。  </p><blockquote><ol><li><strong>lock</strong>：作用于主内存，把变量标识为线程独占状态</li><li><strong>unlock</strong>：作用于主内存，解除独占状态</li><li><strong>read</strong>：作用主内存，把一个变量的值从主内存传输到线程的本地内存</li><li><strong>load</strong>：作用于本地内存，把 read 操作传过来的变量值放入本地内存的变量副本中</li><li><strong>use</strong>：作用本地内存，把本地内存当中的一个变量值传给执行引擎</li><li><strong>assign</strong>：作用本地内存，把一个从执行引擎接收到的值赋值给本地内存的变量</li><li><strong>store</strong>：作用于本地内存的变量，把本地内存的一个变量的值传送到主内存中</li><li><strong>write</strong>：作用于主内存的变量，把 store 操作传来的变量的值放入主内存的变量中</li></ol></blockquote><p>如果要把一个变量从主内存中复制到本地内存中，就需要按顺序地执行read和load操作， 如果把变量从本地内存中同步到主内存中，就需要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</p><p>如前所述，Java 内存模型和硬件内存架构是不同的。不管是本地内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一 个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。具体如下图所示：</p><p><img src="/posts/11b0627b/jmm-cpu-memory-relation.jpg" alt></p><p>当对象和变量可以存储在计算机中各种不同的内存区域时，可能会出现某些问题，两个主要问题是：</p><ul><li>线程更新（写入）共享变量的可见性</li><li>读取、检查和写入共享变量时的竞争条件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章将对 Java 的内存模型（JMM）进行介绍，本质上它是一种编程语言规范，用于尝试统一一个能够在各种处理器架构中为并发提供一致语义的
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JMM" scheme="https://gentryhuang.com/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>网络通信 - Reactor模型</title>
    <link href="https://gentryhuang.com/posts/ae5dbc38/"/>
    <id>https://gentryhuang.com/posts/ae5dbc38/</id>
    <published>2021-09-12T13:10:23.000Z</published>
    <updated>2021-09-12T05:53:02.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Reactor 模型是高性能网络系统实现高并发请求处理的一个解决方案，具体来说就是网络服务端处理高并发网络 IO 请求的一种编程模型。Reactor 编程模型具有以下特征：</p><ul><li><strong>三种事件类型：</strong>连接事件、读事件、写事件</li><li><strong>三种关键角色：</strong> Reactor、Acceptor、Handler </li></ul><p>Reactor 模型就是基于以上三种事件和三种角色来处理网络IO请求的，这就它工作的机制。</p><h1 id="演化"><a href="#演化" class="headerlink" title="演化"></a>演化</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-classic-service-design-.jpg" alt></p><p>上图是传统阻塞IO模型，每个处理程序在自己的线程中运行。</p><p><strong>缺点如下：</strong></p><p>每个连接都需要独立线程处理，当并发数大时会创建多个线程，过度消耗资源。由于每个连接都对应一个线程，当连接没有就绪时线程就会阻塞等待。</p><p><strong>优化方案：</strong></p><ul><li>基于 IO 多路复用模型，多个连接可以共用一个线程。</li><li>使用线程池，将业务逻辑交给线程池处理。</li></ul><p>基于以上问题，为了高效处理网络 IO 的事件，演化出了 Reactor 模型，该模型的思想就是基于IO多路复用和线程池的结合。</p><h1 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h1><p>Reactor 模型处理的是客户端和服务器端的交互过程，而<strong>连接事件</strong>、<strong>读事件</strong>、<strong>写事件</strong>对应了客户端和服务器端交互过程中不同类型的请求在服务器端引发的待处理事件。</p><p>具体引发的待处理事件如下：</p><ul><li>客户端向服务器端发送连接请求以建立连接，这对应了服务器端的一个<strong>连接事件</strong>。</li><li>连接建立后，客户端会给服务器端发送读或写请求，服务器端需要从客户端读取请求内容，这对应了服务器端的<strong>读事件</strong>。</li><li>服务器端在处理完请求后，需要向客户端写回数据，这对应了服务器端的<strong>写事件</strong>。</li></ul><h1 id="关键角色"><a href="#关键角色" class="headerlink" title="关键角色"></a>关键角色</h1><p>Reactor 模型中的不同类型事件的处理是由对应的角色完成的，三种关键角色的任务如下：</p><ul><li>Acceptor 用于处理客户端连接事件，负责接收连接。</li><li>Handler 用于处理读写事件。</li><li>Reactor 负责监听和分派事件。当有连接请求时，Reactor 将产生的连接事件交给 Acceptor 处理；当有读写请求时，Reactor 将读写事件交给 Handler 处理。</li></ul><p>需要注意的是，以上三种角色是 Reactor 模型中实现功能的<strong>抽象</strong>。遵循 Reactor 模型进行服务器端网络框架开发时，需要对 Reactor、Acceptor 以及 Handler 进行逻辑实现。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>根据 Reactor 的数量和处理资源的线程数量的不同，可以分为三类：</p><ul><li>单 Reactor 单线程模型</li><li>单 Reactor 多线程模型</li><li>多 Reactor 多线程模型</li></ul><p>下面依次介绍以上三种 Reactor 线程模型。</p><h2 id="单Reactor单线程模型"><a href="#单Reactor单线程模型" class="headerlink" title="单Reactor单线程模型"></a>单Reactor单线程模型</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-basic-design.jpg" alt></p><p>在单 Reactor 单线程模型下，监听、分派事件由 Reactor 完成，处理连接事件由 Acceptor 完成，处理读写事件和业务逻辑由 Handler 完成，但<strong>始终只有一个线程去完成所有的工作</strong>。</p><p><strong>缺点如下：</strong></p><ul><li>仅使用一个线程完成所有工作，不能充分利用多核机器资源</li><li>当处理任务导致线程负载过高，处理速度会下降，任务会堆积。请求并发量比较低的时候还是可以抗住的，一旦高并发可能将不堪重负</li><li>单线程不能保证可靠性</li></ul><h2 id="单Reactor多线程模型"><a href="#单Reactor多线程模型" class="headerlink" title="单Reactor多线程模型"></a>单Reactor多线程模型</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-worker-thread-pool.jpg" alt></p><p>单 Reactor 多线程模型下，不再采用所有工作都由 Reactor 线程独自完成。监听、分派事件由 Reactor 完成，处理连接事件由 Acceptor 完成，处理读写事件由 Handler 完成，这些操作由 Reactor 线程执行。<strong>对于业务逻辑的处理交给线程池（多线程），不再是 Reactor 线程</strong>。相比 单 Reactor 单线程模型，充分利用多核机器的资源、提高性能并且增加可靠性。</p><p><strong>缺点如下：</strong><br>Reactor 线程承担了所有事件的处理，没有解决高并发场景下单线程存在的性能问题。如并发太高，Reactor 线程来不及处理连接请求和读写数据。</p><h2 id="多Reactor多线程模型"><a href="#多Reactor多线程模型" class="headerlink" title="多Reactor多线程模型"></a>多Reactor多线程模型</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-multiple-reactor.jpg" alt></p><p>多 Reactor 多线程模型是将 Reactor 拆分成了 mainReactor 和 subReactor 两个部分。主要有一个 mainReactor，多个 subReactor 以及每个 subReactor 附带一个线程池。mainReactor 主要负责监听客户端的连接请求，当有连接请求到达会分派给 Acceptor（位于 mainReactor 中）处理，并将产生的连接信息交给 subReactor ，后续 subReactor 监听到读写事件后，分派给 Handler 处理，业务逻辑交给线程池处理。</p><h1 id="事件驱动框架"><a href="#事件驱动框架" class="headerlink" title="事件驱动框架"></a>事件驱动框架</h1><p>至此，我们已经了解了 Reactor 模型的组件和工作机制，但是 Reactor 中的角色和事件是怎么联动起来的呢？这就需要事件驱动框架了。</p><p>在实现 Reactor 模型时，利用事件驱动框架对整体流程进行控制。事件驱动框架在设计时包括但不限于以下内容：</p><ul><li>事件定义及初始化</li><li>事件监听、分派(分派给对应的程序处理)、处理</li><li>轮询（一般是循环逻辑）</li></ul><h2 id="事件初始化"><a href="#事件初始化" class="headerlink" title="事件初始化"></a>事件初始化</h2><p>Reactor 模型是基于事件和角色工作的，事件驱动框架的实现自然也离不开事件的定义以及初始化。事件初始化的作用主要是创建需要监听的事件类型，并为该类型事件关联对应的处理程序，也就是处理连接事件的 Acceptor、处理读写事件的 Handler以及处理业务逻辑的其它处理程序。</p><h2 id="事件分派、处理"><a href="#事件分派、处理" class="headerlink" title="事件分派、处理"></a>事件分派、处理</h2><p>监听、分派事件是由 Reactor 来完成的，在事件驱动框架中通常会用一个<strong>主循环程序</strong>实现。在这个主循环中，监听发生的事件，并根据事件类型将待处理的事件分派给与之关联的 Acceptor 和 Handler 处理。</p><h2 id="串联部件"><a href="#串联部件" class="headerlink" title="串联部件"></a>串联部件</h2><p>Reactor 模型的工作机制：客户端不同类型请求和服务器端结果处理会在服务器端触发连接、读、写事件，这三类事件的监听、分派和处理又是由 Reactor、Acceptor、Handler 三类角色来完成的，这三类角色会通过事件驱动框架来实现交互和事件处理。不难发现，实现一个 Reactor 模型的关键就是要实现一个事件驱动框架串联起 Reactor 所有部件。</p><p><strong>Reactor 模型的工作机制整体流程图如下：</strong></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-event-process.jpg" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Reactor 模型进行了介绍。先是对 Reactor 中涉及的部件及功能进行说明，接着对 Reactor 的演化进行了简单介绍，然后分别对不同种类的 Reactor 进行了逐一说明，最后介绍了事件驱动框架，它是串联 Reactor 模型下所有部件的关键程序。</p><p><strong>参考：</strong><br><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Reactor 模型是高性能网络系统实现高并发请求处理的一个解决方案，具体来说就是网络服务端处理高并发网络 IO 请求的一种编程模型。Rea
      
    
    </summary>
    
    
      <category term="网络通信" scheme="https://gentryhuang.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>并发 - ThreadLocal</title>
    <link href="https://gentryhuang.com/posts/151f44ae/"/>
    <id>https://gentryhuang.com/posts/151f44ae/</id>
    <published>2021-09-03T04:30:12.000Z</published>
    <updated>2021-09-13T15:06:41.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ThreadLocal 提供了线程局部变量，它是将线程需要访问的数据存储在线程对象自身中，从而避免多线程的数据竞争问题。ThreadLocal 实现原理如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-struct.png" alt></p><p>理解 ThreadLocal 原理，其实就是理解 <strong>Thread</strong>、<strong>ThreadLocal</strong> 以及 <strong>ThreadLocalMap</strong> 三者之间的关系。线程类 Thread 内部持有 ThreadLocalMap 的成员变量，而 ThreadLocalMap 是 ThreadLocal 的内部类，ThreadLocal 对外暴露操作数据的 API 都是操作 ThreadLocalMap 中的数据。<strong>总得来说，线程 Thread 在向 ThreadLocal 中设置值时，其实都是向自己所持有的 ThreadLocalMap 中设置数据；读的时候同理，先是从线程自身中取出持有的 ThreadLocalMap ，然后再根据 ThreadLocal 引用作为 key 取出对应的元素 Entry 进而取出 value</strong>。因此 ThreadLocal 可以轻松实现变量的线程隔离，毕竟变量都是维护在各个线程中的，自然没有竞争。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>根据前文中的 ThreadLocal 实现原理图可以发现 ThreadLocal 是 Thread 使用的一个工具，下面我们剥离出 Thread 中相关 ThreadLocal 信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 与此线程相关的 ThreadLocal 值，这个映射由 ThreadLocal 类维护 */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 与此线程相关的 InheritableThreadLocal 值。这个映射由 InheritableThreadLocal 类维护。*/</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread 中维护了两个 ThreadLocalMap 类型的变量，<strong><code>threadLocals</code> 用于存储当前线程使用的 ThreadLocal 相关信息；<code>inheritableThreadLocals</code> 用于存储当前线程使用的 InheritableThreadLocal 相关信息。使用 InheritableThreadLocal 可以实现多个线程访问 ThreadLocal 的值，即父线程中创建一个 InheritableThreadLocal 的实例，然后在子线程中就可以得到这个 InheritableThreadLocal 中设置的值</strong>。关于共享线程的 ThreadLocal 数据将在下面的内容中分析。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><strong>ThreadLocal 相关的 UML 类图如下所示：</strong></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-uml.jpg" alt></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1 作为 ThreadLocal 实例的变量，私有、不可变。每当创建 ThreadLocal 时这个值都会累加 HASH_INCREMENT</span></span><br><span class="line"><span class="comment">    * 2 主要为了多个 ThreadLocal 实例的情况下，让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二进制：-10011110001101110111100110111001</span></span><br><span class="line"><span class="comment">    * 十进制：-2654435769</span></span><br><span class="line"><span class="comment">    * 说明：</span></span><br><span class="line"><span class="comment">    * 1 Entry[] table 的大小必须是 2^N，那 2^N-1 的二进制表示就是低位连续的N个1，</span></span><br><span class="line"><span class="comment">    * 2 key.threadLocalHashCode &amp; (len-1) 的值就是 threadLocalHashCode 的低 N 位，这里使用位运算实现取模，和 HashMap 计算下标类似</span></span><br><span class="line"><span class="comment">    * 3 要求 threadLocalHashCode 的值要均匀，这里给出 0x61c88647 就能达到。</span></span><br><span class="line"><span class="comment">    * 原因：</span></span><br><span class="line"><span class="comment">    * 取该值与fibonacci hashing(斐波那契散列法)以及黄金分割有关，目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是Entry[] table中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 作为 ThreadLocal 类变量</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 基于当前 ThreadLocal ，下一个要给出的哈希码，自动更新，从 0 开始计数。</span></span><br><span class="line"><span class="comment">    * 每次获取当前值并加上固定的 HASH_INCREMENT</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回下一个 ThreadLocal 的 hash</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 关键属性分为两类。一类是 ThreadLocal 实例变量，另一类是 ThreadLocal 类变量。其中类变量在 ThreadLocal 类加载过程就进行初始化，也就是 <code>nextHashCode</code> 的初始化，后续实例变量 <code>threadLocalHashCode</code> 随着对象的创建而调用 <code>nextHashCode</code> 方法进行赋值，可以看出每次递增为 <strong>HASH_INCREMENT</strong> ，至于为什么选择这个值，是和斐波那契散列法以及黄金分割有关，目的就是为了让哈希码能均匀的分布在 2^n 次方的数组里，这个和 HashMap 中 hash 实现目的是一致的。</p><p>了解了核心属性后，下面以几个方法做为入口分析 ThreadLocal 源码。</p><h3 id="Set-方法"><a href="#Set-方法" class="headerlink" title="Set 方法"></a>Set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置当前线程变量的值 value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据当前线程获取其成员变量 threadLocals 所指向的 ThreadLocalMap 对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 判断当前线程的 ThreadLocalMap 是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 3.1 如果不为空，说明当前线程内部已经有ThreadLocalMap对象了</span></span><br><span class="line">            <span class="comment">// 那么直接将当前对应的 ThreadLocal 对象的引用作为键，存入的 value 作为值存储到 ThreadLocalMap 中</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 3.2 创建一个 ThreadLocalMap 对象并将值存入到该对象中，并赋值给当前线程的threadLocals成员变量</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>ThreadLocal 中的增、删、查方法基本都会有三个步骤。下面对 Set 方法进行小结:</strong></p><blockquote><ol><li>获取当前线程</li><li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li><li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 set 方法放入数据，映射表不存在则先创建映射表再放入数据</li></ol></blockquote><h3 id="Get-方法"><a href="#Get-方法" class="headerlink" title="Get 方法"></a>Get 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程的线程副本变量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据当前线程获取其 ThreadLocalMap 实例</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果当前线程的 ThreadLocalMap 不为空</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T) e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果当前线程的 ThreadLocalMap 为空或 ThreadLocalMap 中没有当前 ThreadLocal 对应的元素，则调用 initialValue() 方法初始化值</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对 Get 方法进行小结:</strong></p><blockquote><ol><li>获取当前线程</li><li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li><li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 getEntry 方法查询数据；映射表不存在或从映射表中没有找到当前 ThreadLocal 对应的元素，则调用 setInitialValue 方法完成映射表的创建或初始值的获取</li></ol></blockquote><p>Get 方法相比 Set 方法会涉及查询不到元素的情况，如果当前线程持有的映射表还没有或者找不到元素，那么 ThreadLocal 会尝试以初始化值的方式进行兜底处理，初始值的情况通过方法 <code>initialValue()</code> 交给具体实现。</p><h4 id="setInitialValue-方法"><a href="#setInitialValue-方法" class="headerlink" title="setInitialValue 方法"></a>setInitialValue 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置初始化值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 调用 initialValue() 方法获取指定的初始化值，默认为 null</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取当前线程的 ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果 ThreadLocalMap 不为空，则直接将初始值设置到 ThreadLocalMap 中</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 如果 ThreadLocalMap 为空，则创建 ThreadLocalMap 对象，并设置初始值</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化值，子类覆盖</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Remove-方法"><a href="#Remove-方法" class="headerlink" title="Remove 方法"></a>Remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程持有的 ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 删除 ThreadLocalMap 中当前 ThreadLocal 相关的信息</span></span><br><span class="line">        <span class="comment">// 包括清理对应的引用和值</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对 Remove 方法进行小结:</strong></p><blockquote><ol><li>获取当前线程</li><li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li><li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 remove 方法根据当前 ThreadLocal 清理对应数据，可以防止内存泄漏</li></ol></blockquote><h3 id="createMap-方法"><a href="#createMap-方法" class="headerlink" title="createMap 方法"></a>createMap 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为线程 t 初始化 ThreadLocalMap 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t          当前线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>线程中的 ThreadLocalMap 使用的是延迟初始化，即第一次调用 get() 或者 set() 方法的时候才会进行初始化。</p><h3 id="getMap-方法"><a href="#getMap-方法" class="headerlink" title="getMap 方法"></a>getMap 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">// 返回线程 t 的 threadLocals</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于获取每个线程持有自身的 ThreadLocalMap 实例，因此它们是不存在并发竞争的，这就是我们说的每个线程都有自己的变量副本。</p><p>至此，ThreadLocal 相关属性以及暴露的方法已经分析完毕。可以看出，ThreadLocal 中并没有持有 ThreadLocalMap 的引用，该引用是在 Thread 类中。此外，ThreadLocal 暴露的 API 操作都是基于 ThreadLocalMap 的。因此，我们理解了 ThreadLocalMap 才算是掌握了 ThreadLocal 。下面我们重点对 ThreadLocalMap 进行分析。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，本质上是一个 Map ，和 HashMap 类似，依然是 key-value 的形式，具体由 Entry 结构封装。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-map-struct.jpg" alt></p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储数据的 Entry 数组，长度是 2 的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中元素的个数，初始值为 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组扩容阈值，默认为0，创建了 ThreadLocalMap 对象后会被重新设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置调整大小阈值，以保持在最坏 2/3 的负载因子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ThreadLocalMap使用 开放地址法-线性探测法 来解决哈希冲突 */</span></span><br><span class="line"><span class="comment">// 向后一个位置找，注意从头开始的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向前一个位置找，注意跳到尾部的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体属性类似 HashMap ，各个值的含义已经详细注释就不再说明。需要注意的是，由于 ThreadLocalMap 使用的是线性探测法解决 hash 冲突，因此定义向前和向后探测的方法以便于寻找合适的位置及定位元素。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 与传入 ThreadLocal 关联的值，也就是线程局部变量值</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Entry的 key 是对 ThreadLocal 的弱引用，当抛弃掉 ThreadLocal 对象时，垃圾收集器会忽略这个 key 的引用而清理掉 ThreadLocal 对象。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一个线程可以使用多个 ThreadLocal 将不同的值存储到当前线程的 ThreadLocalMap 中。熟悉 HashMap 存储结构的可以发现，ThreadLocalMap 中的存储结构有两大不同点：</p><ul><li>没有链表相关的指针，更没有树节点的左右链接</li><li>元素节点结构 Entry 继承了 <code>WeakReference</code> 类，以实现弱引用功能</li></ul><p>作为一个映射表，必然会有元素冲突的可能，虽然和 HashMap 结构类似，但是没有 HashMap 中链表和树形结构，那么 ThreadLocalMap 是怎么解决 hash 冲突的呢？答案是<strong>线性探测法</strong>。关于 Entry 继承 <code>WeakReference</code> 的原因我们在后面的文章中进行分析。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstKey   ThreadLocal 引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue 设置的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">// 1 初始化 Entry 数组，大小为 16</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取 ThreadLocal 的 hash 值(该值是累加的)</span></span><br><span class="line">        <span class="comment">// 计算当前 key 对应的数组下标位置， 和 HashMap 的位运算代替取模原理一样</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 将 Entry 对象存入到数组指定的位置</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 记录数组元素个数</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 初始化扩容阈值</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当线程 Thread 持有的 ThreadLocalMap 还没有初始化时，在使用 ThreadLocal 存储或获取数据时都会先创建一个 ThreadLocalMap 对象然后挂载到当前线程 Thread 上，后续不管该线程使用了多少个 ThreadLocal ，都会使用创建的 ThreadLocalMap 进行储存相应值，有冲突就使用<strong>线性探测法</strong>解决。</p><p>了解了 ThreadLocalMap 的底层数据结构后，下面我们依然从它的核心操作方法出发分析底层实现。</p><h3 id="getEntry-方法"><a href="#getEntry-方法" class="headerlink" title="getEntry 方法"></a>getEntry 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取与 key 关联的 Entry</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 根据 key 计算下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 根据下标获取 Entry</span></span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 通过下标直接得到的 Entry 不是要找的，那么就线性探测找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>获取线程局部变量值的 getEntry 方法是 ThreadLocal 暴露的 get() 方法的底层实现，它的主要流程如下：</p><ul><li>根据 ThreadLocal 引用计算对应的数组下标，这个和 HashMap 类似</li><li>根据计算得到的下标尝试直接获取对应的 Entry，如果当前 Entry 为空或对应的 key 不是当前传入的 key ，那么进行线性探测获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * getEntry方法的版本，用于在键未在其直接散列槽中找到时使用。</span></span><br><span class="line"><span class="comment">         * 注意，该方法会清理无效 Entry</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i   the table index for key's hash code</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e   the entry at table[i]</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 线性探测</span></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取 Entry 的 key</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.1 命中，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="comment">// 2.2 无效 Entry，执行连续段删除</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3 获取下个位置</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3 遍历完也没查到，返回 null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>之所以要进行线性探测获取其实是和链表查询一样，可能目标元素由于 hash 冲突放到了后续位置。<strong>注意：查询流程也就是 get() 方法可能也会清理无效的元素，以防止内存泄漏，但不能保证</strong>。关于连续段清理无效元素逻辑暂略过。</p><h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置与 key 关联的值</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * ThreadLocal 的 set 方法，就是为了将指定的值存入到指定线程的 ThreadLocalMap 对象中，具体还是通过 ThreadLocalMap 的 set 方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key   the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 获取数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 计算当前 ThreadLocal 对象引用作为键在数组中的下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 根据获取到的下标进行线性探测，寻找空的位置。</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 中的 key ，即 ThreadLocal 的引用，注意是弱引用。</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 判断和当前的 ThreadLocal 对象是否是同一个对象，如果是，那么直接进行值替换，并结束方法，</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.3 判断当前 Entry 是否失效，即是否被回收（弱引用），如果失效，说明当前位置可以重新使用，就使用新的 key-value 将其替换</span></span><br><span class="line">                <span class="comment">// 该过程还会进行连续段删除其它无效的 entry</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 找到某个空位置，直接将键值对设置到该位置上。</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 尝试随机清理无效 entry ，如果没有可清理的 entry 且数组元素大小 &gt;= 扩容阈值，则进行 rehash</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>设置线程局部变量值的 set 方法稍微复杂点，下面对其主要流程进行说明：</strong></p><blockquote><ol><li>根据传入的 key 计算数组下标位置</li><li>根据计算得到的下标进行线性探测，寻找空的位置以存放元素<ul><li>检测到存在相同 key 的元素，进行值覆盖，然后结束流程即可</li><li>检测到无效的元素，则重用无效元素位置，并尝试清理无效的元素</li><li>在某个空位置存放数据</li></ul></li><li>如果不是值覆盖或重用无效元素位置的情况，那么需要判断是否需要 rehash  </li></ol></blockquote><p>下面我们对上述关联的核心方法进行拆解分析。</p><h4 id="replaceStaleEntry-方法"><a href="#replaceStaleEntry-方法" class="headerlink" title="replaceStaleEntry 方法"></a>replaceStaleEntry 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 替换无效 Entry ，并尝试删除其它无效的 Entry。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> staleSlot 无效 entry 的位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标志 Table 中是否存在无效 Entry。slotToExpunge != staleSlot 说明 table 中存在无效 Entry 需要进行清理，否则说明没有。</span></span><br><span class="line">            <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 根据传入的无效 Entry 的位置 staleSlot 向前扫描一段连续非空的 Entry ，并记录最后一个无效的 Entry 的位置。或者扫描完也没有找到。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = prevIndex(i, len))</span><br><span class="line">                <span class="comment">// 2.1 如果是无效 Entry ，则更新删除标记 slotToExpunge</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 根据传入的无效 Entry 向后扫描一段连续的 Entry（根据线性探测，具有相同的 key 的元素一定是从后找的） ,以寻找是否有相同 key 的 Entry，以及在需要时更新删除标记位 slotToExpunge</span></span><br><span class="line">            <span class="comment">// 找到相同 key 的元素或末尾的空槽，以最先出现的为准</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 的 key</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 如果找到了具有相同的 key ，则更新其值。也就是更新其值并将其与传入的无效 Entry 替换，即与 table[staleSlot] 进行替换</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    <span class="comment">// 3.2.1 更新为传入的 value</span></span><br><span class="line">                    e.value = value;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.2.2 使用相同 key 的 Entry 重用失效位置以避免新创建一个 Entry，以维持散列表的顺序。</span></span><br><span class="line">                    tab[i] = tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.2.3 如果向前查找没有找到无效的 Entry，则更新删除标记位 slotToExpunge 为当前位置 i，此时 i 位置对应的是无效 Entry</span></span><br><span class="line">                    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                        slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.3.4 将新过时的槽或在其上面遇到的任何其他过时槽发送到expungeStaleEntry，以删除或重新散列运行中的所有其他条目。</span></span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果向前查找没有找到无效 entry，并且当前向后扫描的entry无效，则更新 slotToExpunge 为当前值 i</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 执行到这里，说明 table 中不存在相同 key 的 Entry，此时只需直接重用无效位置即可</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 slotToExpunge != staleSlot 说明 table 中存在无效 Entry 需要进行清理</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>重用无效 Entry 位置有两种可能：</strong></p><ul><li>如果扫描到的 Table 中存在和要插入的 key 相同的 Entry，那么就使用更新 value 后的该 Entry 替换无效 Entry 以避免新创建 Entry，同时该 Entry 成为了无效 Entry，只需等待后续删除即可。</li><li>如果扫描到的 Table 中不存在和要插入的 key 相同的 Entry ，那么直接创建 Entry 替换无效 Entry 即可。</li></ul><p>此外，上述方法还会对无效 Entry 进行清理，触发条件就是检测到其它无效 Entry 的存在。</p><h4 id="rehash-操作"><a href="#rehash-操作" class="headerlink" title="rehash 操作"></a>rehash 操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * rehash 操作</span></span><br><span class="line"><span class="comment">         * 1 扫描整个 Table ，删除无效的 Entry</span></span><br><span class="line"><span class="comment">         * 2 执行清理后，如果还需要扩容，则将表扩大一倍</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 清理所有无效 Entry</span></span><br><span class="line">            expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  2 threshold - threshold / 4 = 1en / 2，降低扩容阈值是因为上面做了一次全清理 size 可能会减小</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Table 容量扩大为原来 2 倍</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] oldTab = table;</span><br><span class="line">            <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 容量扩大为原来 2 倍</span></span><br><span class="line">            <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">            Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 重新映射旧数组中的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">                Entry e = oldTab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 清理无效 Entry</span></span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 线性探测重新设置值</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, newLen);</span><br><span class="line">                        newTab[h] = e;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 设置新的阈值</span></span><br><span class="line">            setThreshold(newLen);</span><br><span class="line">            size = count;</span><br><span class="line">            table = newTab;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>新增数据后，如果达到阈值就会触发 rehash 流程，进行<strong>数组扩容和数据重新映射</strong>，这个没什么可说的。</p><h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 计算 key 对应的下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 进行线性探测，查找正确的 Entry</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到对应的 Entry</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    <span class="comment">// 调用 WeakReference.clear() 方法清除对应的引用</span></span><br><span class="line">                    e.clear();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 连续段删除 Entry</span></span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上述方法是 ThreadLocal 暴露的 remove() 方法的底层实现，用来清理当前 ThreadLocal 关联的信息。具体清理信息如下：</p><ul><li>清除对当前 ThreadLocal 的弱引用</li><li>清除当前 ThreadLcoal 对应的 Entry 中的 value </li><li>清除当前 ThreadLocal 对应的 Entry </li></ul><h3 id="expungeStaleEntry-方法"><a href="#expungeStaleEntry-方法" class="headerlink" title="expungeStaleEntry 方法"></a>expungeStaleEntry 方法</h3><p>expungeStaleEntry 方法用于彻底删除指定位置的 Entry 所以信息，接着向后连续段扫描删除无效 Entry ，并对可能存在 hash 冲突的 Entry 进行 rehash 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除过期的元素，是连续段方式的删除</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 清理 staleSlot 位置的无效 Entry ，并递减元素个数</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 从 stateSlot 开始向后扫描一段连续的非空的 Entry</span></span><br><span class="line">            <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 的 k</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 如果遇到key为null,表示无效entry，进行清理.</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// value 置空</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 元素置空</span></span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 元素个数递减</span></span><br><span class="line">                    size--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.3 如果 key 不为 null ，则对可能存在 hash 冲突的 Entry 进行 rehash</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 计算 key 对应的下标，如果与现在所在位置不一致，认为存在 hash 冲突，置空当前 table[i] ，</span></span><br><span class="line">                    <span class="comment">// 并从 h 开始向后线性探测到第一个空的 slot，把当前的 entry 移动过去。</span></span><br><span class="line">                    <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                        tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                        <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                        <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        tab[h] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下一个为空的下标</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于删除过期的元素，具体删除策略如下：</p><ul><li>根据传入的 stateSlot 清理对应的无效 Entry，这个是绝对删除。</li><li>根据传入的 stateSlot 向后扫描一段连续非空的 Entry ，对可能存在 hash 冲突的 Entry 进行 rehash ，并且清理遇到的无效 Entry 。</li></ul><h3 id="expungeStaleEntries-方法"><a href="#expungeStaleEntries-方法" class="headerlink" title="expungeStaleEntries 方法"></a>expungeStaleEntries 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描整个 Table ，删除无效的 Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="comment">// 无效 Entry ，则调用 expungeStaleEntry 方法删除对应位置及连坐删除 Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是在 expungeStaleEntry 方法的基础上，对整个 Table 中无效元素进行清理，一定会清理截止到当前 Table 中所有的无效 Entry 。需要说明的是，ThreadLocal 的所有一些列操作都是单线程的，也就是当前线程。</p><h3 id="cleanSomeSlots-方法"><a href="#cleanSomeSlots-方法" class="headerlink" title="cleanSomeSlots 方法"></a>cleanSomeSlots 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 启发式的扫描清除，扫描次数由传入的参数n决定</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i 从i向后开始扫描（不包括i，因为索引为i的Slot肯定为null）</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> n  控制扫描次数，正常情况下为 log2(n) ，如果找到了无效 Entry ，会将 n 重置为 table 的长度 len 进行阶段删除</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> true if any stale entries have been removed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 删除标志</span></span><br><span class="line">            <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 i 位置向后遍历，删除无效的 Entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">                Entry e = tab[i];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前 Entry 无效，则进行清理并进行连坐</span></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    n = len;</span><br><span class="line">                    removed = <span class="keyword">true</span>;</span><br><span class="line">                    i = expungeStaleEntry(i);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 无符号的右移动，可以用于控制扫描次数在log2(n)</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> removed;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>启发式扫描删除具有随机性，启发式思想也用在其他代码中，如 Redis 中的定期删除逻辑。</p><p>自此，ThreadLocalMap 的源码实现分析完毕。</p><h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><p>一般来说 ThreadLocal 数据都是线程独享的，但是 ThreadLocal 继承体系支持子线程共享父线程的变量副本数据。共享线程的 ThreadLocal 数据可以使用 <strong>InheritableThreadLocal</strong> 来实现。通过在父线程中创建一个 <strong>InheritableThreadLocal</strong> 的实例，然后在子线程中就可以获取该实例中设置的值。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 创建 InheritableThreadLocal 对象</span></span><br><span class="line">    ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 创建的 ThreadLocalMap 挂载到当前 Thread 的 inheritableThreadLocals 属性</span></span><br><span class="line">    threadLocal.set(<span class="string">"小芒果!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 创建并启动子线程</span></span><br><span class="line">    Runnable runnable = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 打印子线程 ThreadLocal 的线程变量值</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt; "</span> + threadLocal.get());</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印父线程（这里是主线程） ThreadLocal 的线程变量值</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt; "</span> + threadLocal.get());</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main-&gt; 小芒果!</span><br><span class="line">Thread-0-&gt; 小芒果!</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>线程变量传递逻辑很简单，它隐藏在 Thread 的 init 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- Thread</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 获取初始化当前线程的线程</span></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果 parent 线程使用了 InheritableThreadLocal ，那么就把 parent 的 inheritableThreadLocals 给当前线程的 inheritableThreadLocals 。</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 设置到当前线程的 inheritableThreadLocals 属性中</span></span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从线程初始化逻辑中可以看出，如果父线程 ThreadLocalMap 类型的变量 <code>inheritableThreadLocals</code> 不为空，那么就把父线程的该属性设置给当前线程的 <code>inheritableThreadLocals</code> 属性。具体设置逻辑在 ThreadLocal 的 createInheritedMap 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">// 继承式创建 ThreadLocal</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅由 createInheritedMap 方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocal.ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取 parentMap 的 Table 信息</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建新的 Table</span></span><br><span class="line">        table = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 将 parentMap 中的数据依次映射到新创建的 Table 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 3.1 获取当前 Entry</span></span><br><span class="line">            ThreadLocal.ThreadLocalMap.Entry e = parentTable[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 获取 Entry 中的 key</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.3 Entry 有效的话就进行映射</span></span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 用于获取父线程变量值的转换，默认就是父线程 Entry.value 值</span></span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 线性探测存储元素</span></span><br><span class="line">                    ThreadLocal.ThreadLocalMap.Entry c = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line">                    <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line"></span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过以上逻辑可以发现，如果要使用线程变量共享需要使用到 <strong>InheritableThreadLocal</strong> 类，线程 Thread 的映射属性使用 <code>inheritableThreadLocals</code> 而非 <code>threadLocals</code> 。</p><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认是 Entry 的 value 值，使用方可继承 InheritableThreadLocal 覆盖该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentValue the parent thread's value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the child thread's initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程 t 的 ThreadLocalMap ，注意取的是 inheritableThreadLocals 属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建当前线程 t 的 ThreadLocalMap ，注意设置的是 inheritableThreadLocals 属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InheritableThreadLocal 继承了 ThreadLocal ，重写了以上三个方法，主要是将映射表挂在到 Thread 的 <code>inheritableThreadLocals</code> 属性上，用以实现线程变量的共享。注意，线程变量独享使用的是 Thread 中的 <code>threadLocals</code> 属性。InheritableThreadLocal 对比 ThreadLocal 唯一不同是子线程会继承父线程变量，并支持自定义赋值函数。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>ThreadLocalMap 使用 ThreadLocal 的弱引用做为元素 Entry 的 key ,如果一个 ThreadLocal 没有外部强引用来引用它，那么系统 GC 时这个 ThreadLocal 会被回收。此时，ThreadLocalMap 中就会出现 key 为 null 的 Entry ，这样就没有办法访问这些 Entry，这些 Entry 理论上属于无效的，应该被 GC 回收。但是，如果存在持有这些 Entry 的线程迟迟不结束（如使用线程池），那么这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链 <strong>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</strong>，导致无法回收，造成内存泄漏。</p><p>ThreadLocal 为了尽可能避免内存泄漏问题，在 <code>get()</code>、<code>set()</code> 以及 <code>remove()</code> 方法中都有清除线程的 ThreadLocalMap 中 key 为 null 的 value 逻辑。<strong>注意，其中 get()、set() 两个方法都不能完全防止内存泄漏，存在无效 Entry 无法扫描到的情况，因为只有在线性探测流程中才会尝试连续段清理无效 Entry 。最好的方式是每次使用完 ThreadLocal 都手动 remove 一下</strong>。</p><p>此外，以下措施会增加内存泄漏的风险：</p><ul><li>使用 static 的 ThreadLocal ，这种方式延长了 ThreadLocal 的生命周期</li><li>分配使用了 ThreadLocal ，而不再调用其 <code>get()</code>、<code>set()</code> 以及 <code>remove()</code> 方法</li></ul><h2 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h2><ul><li><strong>key 使用强引用：</strong>ThreadLocal 对象没有外部引用，但是 ThreadLocalMap 持有 ThreadLocal 的强引用，如果没有手动删除，ThreadLocal 不会被回收，这会导致 Entry 内存泄漏。</li><li><strong>key 使用弱引用：</strong>ThreadLocal 对象没有外部引用，由于 ThreadLocalMap 持有 ThreadLocal 的弱引用，即使没有手动删除，ThreadLcoal 也可以被回收。value 在下一次执行方法时被清除。 </li></ul><p>Entry 继承 WeakReference，并且使用 ThreadLocal 的弱引用作为 key，这样可以将 ThreadLocal 对象的生命周期和线程生命周期解绑。持有弱引用可以使得 ThreadLocal 在没有其他强引用的时候被回收掉，这样可以避免因为线程得不到销毁导致 ThreadLocal 对象无法被回收。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>每次使用完 ThreadLocal 都应该调用它的 remove() 方法，进行数据清理，防止内存泄漏。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>多线程之间需要拥有同一个信息，那么通常可以采用 <code>initialValue()</code> 方法进行初始化，直接将需要拥有的变量副本存储到 ThreadLocal 中。</li><li>多个线程中存储不同的信息，那么需要使用 set() 方法设置变量副本到 ThreadLocal 中。</li></ul><p>上述描述<strong>存储到 ThreadLocal 中</strong>是不对的，需要注意，数据其实是存储到线程持有的 ThreadLocalMap 对象中，该对象是一个散列表。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 ThreadLocal 进行了深入的分析，它能保证数据安全是因为每个线程都有自己的线程变量，不会发生多个线程共享变量的情况。首先对 ThreadLocal 的关系进行了介绍，从总体上认识 ThreadLocal 。接着对 ThreadLocal 进行了分析，从其属性到暴露的 API 。然后对 ThreadLocal 底层的支持类 ThreadLocalMap 进行了分析，同样从属性到支撑上层的方法的分析。最后对父子线程就 ThreadLocal 如何共享线程变量进行了分析。在文章的最后，对内存泄漏问题进行了介绍。</p><p><strong>参考资料</strong><br><a href="https://www.cnblogs.com/lqlqlq/p/13302901.html" target="_blank" rel="noopener">https://www.cnblogs.com/lqlqlq/p/13302901.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;ThreadLocal 提供了线程局部变量，它是将线程需要访问的数据存储在线程对象自身中，从而避免多线程的数据竞争问题。ThreadLoca
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="Thread" scheme="https://gentryhuang.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Java基础 - Reference</title>
    <link href="https://gentryhuang.com/posts/55ae5a2b/"/>
    <id>https://gentryhuang.com/posts/55ae5a2b/</id>
    <published>2021-08-21T02:30:12.000Z</published>
    <updated>2021-09-13T15:06:20.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 Java 中有 4 种引用类型，主要是在垃圾回收时 JVM 会根据不同的引用类型采取不同的措施。下面分别对这四种类型进行说明，特别是弱引用，将会结合示例进行分析。</p><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>Java 中的四种引用类型如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/reference/java-reference-uml.jpg" alt></p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用是 Java 默认的引用类型。如果一个对象具有强引用，当内存空间不足时，JVM 宁可抛出 <strong>OutOfMemoryError</strong> 错误使程序异常终止，也不会回收具有强引用的对象来解决内存不足问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，在一个方法中有一个强引用 <code>object</code> ，该引用保存在栈中，而真正的引用内容 <code>Object</code> 对象保存在堆中。当上述方法运行完成后退出方法栈，强引用 <code>object</code> 就不存在了，引用的 <code>Object</code> 对象就会被回收。 注意，如果 <code>Object object = new Object();</code> 是全局的，那么在不使用该对象时需要设置 <code>object = null</code> 以帮助垃圾收集器回收该对象。</p><p>也就是说，一个对象从根路径能找到强引用指向它，JVM 就不会回收。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>如果一个对象只具有软引用，在内存空间足够的情况下 JVM 就不会回收它；如果内存空间不足就会回收这些对象。更准确地来说，进行 Young GC 不会触发软引用所指向对象的回收；但如果触发Full GC，则软引用所指向的对象将被回收。前提是除了软引用之外没有其他强引用引用的情况下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">String str = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="comment">// 软引用</span></span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(str);       </span><br><span class="line"><span class="comment">// 内存不足</span></span><br><span class="line"><span class="keyword">if</span>(isNotFullMemeory())&#123;</span><br><span class="line">     str = <span class="keyword">null</span>;</span><br><span class="line">     System.gc();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如上所示，在内存不足时会回收软引用。软引用可用来实现高速缓存。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>如果一个对象只有弱引用指向它，当进行年轻代垃圾回收时，一旦发现该引用指向的对象就会立刻回收，不管当前内存空间是否足够。注意，由于垃圾回收器是一个优先级很低的线程，因此不一定及时发现那些具有弱引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">String str = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(str);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 垃圾回收</span></span><br><span class="line">str = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><p>如上所示，在进行垃圾回收时发现弱引用立即回收。如果想使用一个对象且不想介入这个对象的生命周期，这时就可以使用弱引用。注意，下面的代码可以转为强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String  str = weakReference.get();</span><br></pre></td></tr></table></figure><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">String str = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="comment">// 虚引用</span></span><br><span class="line">PhantomReference phantomReference = <span class="keyword">new</span> PhantomReference(str,<span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">str = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 随时可能会输</span></span><br></pre></td></tr></table></figure><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中，该队列就是前文类图中的 <code>ReferenceQueue</code> 。</p><h1 id="再谈弱引用"><a href="#再谈弱引用" class="headerlink" title="再谈弱引用"></a>再谈弱引用</h1><p>由于在看 <strong>ThreadLocal</strong> 源码时考虑到涉及 <strong>弱引用</strong> ，因此单独拿出来说明下。下面对 <strong>WeakReference</strong> 类进行分析。</p><h2 id="WeakReference"><a href="#WeakReference" class="headerlink" title="WeakReference"></a>WeakReference</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个指向给定对象的弱引用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent 给定对象的引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent 给定对象的引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q 对象被回收后会把弱引用对象，也就是WeakReference对象或者其子类的对象，放入队列ReferenceQueue中，注意不是被弱引用的对象，被弱引用的对象已经被回收了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过上述代码强调两个概念：</strong></p><blockquote><p>1 弱引用对象是指 WeakReference 实例或其子类实例。<br>2 被弱引用的对象是指需要通过 WeakReference 封装的对象，<strong>形如：</strong><code>WeakReference&lt;Xxx&gt; appleWeakReference = new WeakReference&lt;&gt;(xxx)</code>。这个时候我们说，持有了 <code>xxx</code> 指向对象的弱引用，也就是说当 <code>xxx</code> 也不再引用（可能不止 xxx 引用）时，就剩下弱引用，此时垃圾回收时是可以把对应的对象回收掉。</p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><strong>Fruit 类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        log.info(name + <span class="string">"finalize !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Fruit&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强引用</span></span><br><span class="line">        Fruit fruit = <span class="keyword">new</span> Fruit(<span class="string">"小芒果"</span>);</span><br><span class="line">        <span class="comment">// 创建弱引用对象</span></span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal(fruit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 WeakReference.get() 方法获取对应的对象</span></span><br><span class="line">        log.info(<span class="string">"Fruit: "</span> + animal.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消除强引用，确保只有弱引用（不消除强引用，不会回收）</span></span><br><span class="line">        fruit = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证 GC 的发生</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小芒果被回收 - 因此只有弱引用</span></span><br><span class="line">        log.info(animal.get() == <span class="keyword">null</span> ? <span class="string">" Fruit is Cleared"</span> : animal.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 WeakReference ，持有 Fruit 的弱引用。</span></span><br><span class="line"><span class="comment">     * 当垃圾回收时，回收的是弱引用 referent 指向的对象，而非 Animal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(Fruit referent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(referent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO com.code.concurrent.Client - Fruit: Fruit&#123;name&#x3D;&#39;小芒果&#39;&#125;</span><br><span class="line">[Finalizer] INFO com.code.concurrent.Fruit - 小芒果finalize !</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 5242K-&gt;752K(76288K)] 5242K-&gt;760K(251392K), 0.0008122 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 752K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;534K(175104K)] 760K-&gt;534K(251392K), [Metaspace: 3371K-&gt;3371K(1056768K)], 0.0042356 secs] [Times: user&#x3D;0.03 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[main] INFO com.code.concurrent.Client -  Fruit is Cleared</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 7209K [0x000000076ab00000, 0x0000000770000000, 0x00000007c0000000)</span><br><span class="line">  eden space 65536K, 11% used [0x000000076ab00000,0x000000076b20a738,0x000000076eb00000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076eb00000,0x000000076eb00000,0x000000076f580000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)</span><br><span class="line"> ParOldGen       total 175104K, used 534K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)</span><br><span class="line">  object space 175104K, 0% used [0x00000006c0000000,0x00000006c0085bf8,0x00000006cab00000)</span><br><span class="line"> Metaspace       used 3857K, capacity 4704K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 428K, capacity 464K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强引用</span></span><br><span class="line">        Fruit fruit = <span class="keyword">new</span> Fruit(<span class="string">"小芒果"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建弱引用对象及引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Fruit&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal(fruit, referenceQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 WeakReference.get() 方法获取对应的对象</span></span><br><span class="line">        log.info(<span class="string">"Fruit 对象信息: "</span> + animal.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC 前</span></span><br><span class="line">        log.info(<span class="string">"GC 前"</span>);</span><br><span class="line">        <span class="keyword">if</span> (referenceQueue.poll() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"没有回收被弱引用的对象，不会加入队列中"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录弱引用对象地址，用于回收前后对比</span></span><br><span class="line">        log.info(<span class="string">"弱引用对象地址："</span>+ animal.toString());</span><br><span class="line">        <span class="comment">// 消除强引用，确保只有弱引用（不消除强引用，不会回收）</span></span><br><span class="line">        fruit = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发垃圾回收</span></span><br><span class="line">        log.info(<span class="string">"GC 中"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 保证 GC 的发生</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC 后</span></span><br><span class="line">        log.info(<span class="string">"GC 后"</span>);</span><br><span class="line">        <span class="comment">// 小芒果被回收 - 因此只有弱引用</span></span><br><span class="line">        log.info(animal.get() == <span class="keyword">null</span> ? <span class="string">" Fruit is Cleared"</span> : animal.get().toString());</span><br><span class="line"></span><br><span class="line">        Reference reference = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((reference = referenceQueue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"回收被弱引用的对象，弱引用对象加入队列中，地址为："</span> + reference.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 WeakReference ，持有 Fruit 的弱引用。</span></span><br><span class="line"><span class="comment">     * 当垃圾回收时，回收的是弱引用 referent 指向的对象，而非 Animal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(Fruit referent, ReferenceQueue referenceQueue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(referent, referenceQueue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO com.code.concurrent.Client - Fruit 对象信息: Fruit&#123;name&#x3D;&#39;小芒果&#39;&#125;</span><br><span class="line">[main] INFO com.code.concurrent.Client - GC 前</span><br><span class="line">[main] INFO com.code.concurrent.Client - 没有回收被弱引用的对象，不会加入队列中</span><br><span class="line">[main] INFO com.code.concurrent.Client - 弱引用对象地址：com.code.concurrent.Client$Animal@a09ee92</span><br><span class="line">[main] INFO com.code.concurrent.Client - GC 中</span><br><span class="line">[Finalizer] INFO com.code.concurrent.Fruit - 小芒果finalize !</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 5242K-&gt;736K(76288K)] 5242K-&gt;744K(251392K), 0.0006983 secs] [Times: user&#x3D;0.00 sys&#x3D;0.01, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 736K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;535K(175104K)] 744K-&gt;535K(251392K), [Metaspace: 3380K-&gt;3380K(1056768K)], 0.0035821 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[main] INFO com.code.concurrent.Client - GC 后</span><br><span class="line">[main] INFO com.code.concurrent.Client -  Fruit is Cleared</span><br><span class="line">[main] INFO com.code.concurrent.Client - 回收被弱引用的对象，弱引用对象加入队列中，地址为：com.code.concurrent.Client$Animal@a09ee92</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 7209K [0x000000076ab00000, 0x0000000770000000, 0x00000007c0000000)</span><br><span class="line">  eden space 65536K, 11% used [0x000000076ab00000,0x000000076b20a738,0x000000076eb00000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076eb00000,0x000000076eb00000,0x000000076f580000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)</span><br><span class="line"> ParOldGen       total 175104K, used 535K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)</span><br><span class="line">  object space 175104K, 0% used [0x00000006c0000000,0x00000006c0085e60,0x00000006cab00000)</span><br><span class="line"> Metaspace       used 3856K, capacity 4704K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 428K, capacity 464K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Java 中的 4 种引用进行了介绍，重点对弱引用进行了详细分析，理解了弱引用再去看 <code>ThreadLocal</code> 就能更好地理解其内存泄漏问题。下一篇文章将对 <code>ThreadLocal</code> 进行分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在 Java 中有 4 种引用类型，主要是在垃圾回收时 JVM 会根据不同的引用类型采取不同的措施。下面分别对这四种类型进行说明，特别是弱引
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
  </entry>
  
  <entry>
    <title>并发 - Thread</title>
    <link href="https://gentryhuang.com/posts/dbdf391f/"/>
    <id>https://gentryhuang.com/posts/dbdf391f/</id>
    <published>2021-08-14T13:50:21.000Z</published>
    <updated>2021-09-15T03:11:19.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>现代操作系统在运行一个程序时，会为其创建一个进程，进程是分配系统资源的最小单位。例如，启动一个 Java 程序时，操作系统就会创建一个 Java 进程。现代操作系统调度 CPU 的最小单位是线程，一个进程可能包含一个或多个线程，这些线程都拥有各自的栈空间和局部变量等属性，并且能够访问共享的内存变量。</p><h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><p><strong>Java 中的线程本质上就是一块内存（对象），不等于操作系统的线程。</strong></p><p>下面是一段 Java 中的线程相关的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 创建线程 Thread</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        log.info(Thread.currentThread().getName() + <span class="string">"is running!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 启动线程</span></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Java 语言来说，上述程序有两个动作，分别是<strong>创建线程</strong>和<strong>启动线程</strong>。但对于底层系统来说，Java 中的线程对象 Thread 执行 <strong>start()</strong> 方法后会间接调用操作系统函数库创建一个操作系统层面的线程并等待 CPU 调度。关于 Java 线程映射操作系统线程在下文会详细分析，我们先对 Java 线程的创建过程进行说明。</p><h2 id="创建Java线程"><a href="#创建Java线程" class="headerlink" title="创建Java线程"></a>创建Java线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化一个 Java 线程</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> g 线程所属的线程组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target 任务体</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 线程名</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> stackSize 线程堆栈大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> acc the AccessControlContext to inherit, or</span></span><br><span class="line"><span class="comment">   *            AccessController.getContext() if null</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> inheritThreadLocals if &#123;<span class="doctag">@code</span> true&#125;, inherit initial values for</span></span><br><span class="line"><span class="comment">   *            inheritable thread-locals from the constructing thread</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="comment">// 当前线程是该线程（要创建的线程）的父线程</span></span><br><span class="line">      Thread parent = currentThread();</span><br><span class="line">      SecurityManager security = System.getSecurityManager();</span><br><span class="line">      <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">              g = security.getThreadGroup();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 使用父线程组</span></span><br><span class="line">          <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">              g = parent.getThreadGroup();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      g.checkAccess();</span><br><span class="line">      <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">              security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      g.addUnstarted();</span><br><span class="line">      <span class="keyword">this</span>.group = g;</span><br><span class="line">      <span class="comment">// 将 daemon、priority 属性设置为父线程的对应属性</span></span><br><span class="line">      <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">      <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 类加载器</span></span><br><span class="line">      <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">          <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">      <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">              acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">      <span class="keyword">this</span>.target = target;</span><br><span class="line">      setPriority(priority);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将父线程的 InheritableThreadLocal 复制过来，ThreadLocal 的使用</span></span><br><span class="line">      <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                  ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">      <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">      <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 分配一个线程 ID</span></span><br><span class="line">      tid = nextThreadID();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在创建 Thread 对象时会调用上面的 init 方法进行 Java 线程初始化。</p><h2 id="启动Java线程"><a href="#启动Java线程" class="headerlink" title="启动Java线程"></a>启动Java线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动线程方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用该方法启动 Java 线程；Java 虚拟机会调用该线程的 run 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 多次启动一个线程是不合法的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 特别是，线程一旦完成执行，就不能重新启动。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  IllegalThreadStateException  if the thread was already</span></span><br><span class="line"><span class="comment"> *               started.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        #run()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        #stop()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 native 方法</span></span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// native 方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们知道的是，Java 线程调用 <code>start</code> 方法后就启动了，获取到 CPU 资源就可以执行任务。那么这和底层系统线程是怎么对应的呢？下面我们就来详细分析 Java 线程是怎么映射操作系统线程的。在分析 Java 线程是怎么映射到操作系统线程之前，我们需要先说明 JDK 的组成。JDK 的代码有两部分，一部分是 Java 语言库，另一部分是实现更底层功能的本地方法，他们由 C++ 实现，位于 openJdk 代码中。</p><h2 id="映射系统线程"><a href="#映射系统线程" class="headerlink" title="映射系统线程"></a>映射系统线程</h2><p>下面我们从调用本地方法 <code>start0</code> 出发，对执行链路进行跟踪，跟踪代码是 openJdk 中的源码。</p><ol><li>Thread.c<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"start0"</span>,           <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">"stop0"</span>,            <span class="string">"("</span> OBJ <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">"isAlive"</span>,          <span class="string">"()Z"</span>,        (<span class="keyword">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">"suspend0"</span>,         <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">"resume0"</span>,          <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">"setPriority0"</span>,     <span class="string">"(I)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">"yield"</span>,            <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;<span class="string">"sleep"</span>,            <span class="string">"(J)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;<span class="string">"currentThread"</span>,    <span class="string">"()"</span> THD,     (<span class="keyword">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">"interrupt0"</span>,       <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">"holdsLock"</span>,        <span class="string">"("</span> OBJ <span class="string">")Z"</span>, (<span class="keyword">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">"getThreads"</span>,        <span class="string">"()["</span> THD,   (<span class="keyword">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"dumpThreads"</span>,      <span class="string">"(["</span> THD <span class="string">")[["</span> STE, (<span class="keyword">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"setNativeName"</span>,    <span class="string">"("</span> STR <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>可以看到，Thread 中的本地方法 <code>start0</code> 维护在一个方法表中，对应的处理函数是 <strong>JVM_StartThread</strong>，下面我们看这个函数的作用。</li><li>jvm.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Thread::start 方法调用执行，必须先释放 Threads_lock</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 确保 C++ Thread 和 OSThread结构 在我们操作之前没有被释放。</span></span><br><span class="line">  <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 忽略</span></span><br><span class="line">  <span class="keyword">if</span> (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    jlong <span class="built_in">size</span> =</span><br><span class="line">           java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">    NOT_LP64(<span class="keyword">if</span> (<span class="built_in">size</span> &gt; SIZE_MAX) <span class="built_in">size</span> = SIZE_MAX;)</span><br><span class="line">    <span class="keyword">size_t</span> sz = <span class="built_in">size</span> &gt; <span class="number">0</span> ? (<span class="keyword">size_t</span>) <span class="built_in">size</span> : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 JavaThread 对象</span></span><br><span class="line">    native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建完 JavaThread 后，启动 JavaThread </span></span><br><span class="line">Thread::start(native_thread);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>可以看到，在执行本地方法 <code>start0</code> 后会创建一个 C++ JavaThread 对象，创建后才会启动 JavaThread 并执行 thread_entry 函数。</li><li>jvm.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line"><span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line"><span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, thread-&gt;threadObj())</span></span>;</span><br><span class="line"><span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line"><span class="comment">//   thread_entry 中 JavaCalls::call_virtual 就是通过 JVM 调用 run 方法的</span></span><br><span class="line">JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                       obj,</span><br><span class="line">                       vmClasses::Thread_klass(),</span><br><span class="line">                       <span class="comment">//  vmSymbols::run_method_name() 映射的就是 run 方法</span></span><br><span class="line">                       vmSymbols::run_method_name(),</span><br><span class="line">                       vmSymbols::void_method_signature(),</span><br><span class="line">                       THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到，JavaThread 执行的回调函数 thread_entry 是关联 Java 线程的直接入口，是通过 Java 虚拟机调用 Thread 对象的 run 方法的。至此，从 Java 线程到 C++ 线程就结束了，不过这两个都不是真正意义上的线程。下面我们继续跟，寻找创建操作系统线程的信息，其实操作系统线程的创建与启动的线索都在创建 C++ JavaThread 对象的逻辑中。</li><li>thread.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JavaThread::JavaThread(ThreadFunction entry_point, <span class="keyword">size_t</span> stack_sz) : JavaThread() &#123;</span><br><span class="line">_jni_attach_state = _not_attaching_via_jni;</span><br><span class="line"><span class="comment">// 1 为 JavaThread 设置运行函数 entry_point</span></span><br><span class="line">set_entry_point(entry_point);</span><br><span class="line"><span class="comment">// Create the native thread itself.</span></span><br><span class="line"><span class="comment">// %note runtime_23</span></span><br><span class="line">os::ThreadType thr_type = os::java_thread;</span><br><span class="line">thr_type = entry_point == &amp;CompilerThread::thread_entry ? os::compiler_thread :</span><br><span class="line">                                                         os::java_thread;</span><br><span class="line"><span class="comment">// 2 根据不同的操作系统，调用对应底层函数创建线程</span></span><br><span class="line">os::create_thread(<span class="keyword">this</span>, thr_type, stack_sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>哇，终于要见到了操作系统创建线程的流程了。在创建 C++ 的线程对象 JavaThread 时会根据不同的操作系统调用不同的函数创建线程。</li><li>os_linux.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread-&gt;JavaThread</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">os::create_thread</span><span class="params">(Thread* thread, ThreadType thr_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">size_t</span> req_stack_size)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建 OSThread </span></span><br><span class="line">OSThread* osthread = <span class="keyword">new</span> OSThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (osthread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// set the correct thread state</span></span><br><span class="line">osthread-&gt;set_thread_type(thr_type);</span><br><span class="line"><span class="comment">// Initial state is ALLOCATED but not INITIALIZED</span></span><br><span class="line">osthread-&gt;set_state(ALLOCATED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 JavaThread 设置 OSThread</span></span><br><span class="line">thread-&gt;set_osthread(osthread);</span><br><span class="line">ThreadState state;</span><br><span class="line">&#123;</span><br><span class="line"> ResourceMark rm;</span><br><span class="line"> <span class="keyword">pthread_t</span> tid;</span><br><span class="line"> <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> limit = <span class="number">3</span>;</span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">   <span class="comment">// 我们的线程来了</span></span><br><span class="line">   <span class="comment">// 调用 Linux 操作系统函数创建真正意义上的线程并运行函数 thread_native_entry，该函数参数是 JavaThread</span></span><br><span class="line">   ret = pthread_create(&amp;tid, &amp;attr, (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*)) thread_native_entry, thread);</span><br><span class="line"> &#125; <span class="keyword">while</span> (ret == EAGAIN &amp;&amp; limit-- &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>这里以 Linux 操作系统为例，我们看到调用 Linux 的 <strong>pthread_create 库函数</strong> 创建线程并执行回调函数 thread_native_entry 。该回调用函数涉及到操作系统线程的状态。</li><li>os_linux.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 所有在 Linux 操作系统下新创建的线程运行的函数。</span></span><br><span class="line"> <span class="comment">// 也就是当在 Java 中创建一个线程并执行 start 方法，后续会创建对应的操作系统线程并执行该方法</span></span><br><span class="line"> <span class="comment">// thread-&gt;JavaThread</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_native_entry</span><span class="params">(Thread *thread)</span> </span>&#123;</span><br><span class="line"> thread-&gt;record_stack_base_and_size();</span><br><span class="line"> thread-&gt;initialize_thread_current();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取 JavaThread 中的 OSThread</span></span><br><span class="line"> OSThread* osthread = thread-&gt;osthread();</span><br><span class="line"> Monitor* sync = osthread-&gt;startThread_lock();</span><br><span class="line"> osthread-&gt;set_thread_id(os::current_thread_id());</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (UseNUMA) &#123;</span><br><span class="line">     <span class="keyword">int</span> lgrp_id = os::numa_get_group_id();</span><br><span class="line">     <span class="keyword">if</span> (lgrp_id != <span class="number">-1</span>) &#123;</span><br><span class="line">     thread-&gt;set_lgrp_id(lgrp_id);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// initialize signal mask for this thread</span></span><br><span class="line"> PosixSignals::hotspot_sigmask(thread);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// initialize floating point control register</span></span><br><span class="line"> os::Linux::init_thread_fpu_state();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// handshaking with parent thread</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="function">MutexLocker <span class="title">ml</span><span class="params">(sync, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">   <span class="comment">// notify parent thread</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置OSThread 为初始状态</span></span><br><span class="line">   osthread-&gt;set_state(INITIALIZED);</span><br><span class="line">   sync-&gt;notify_all();</span><br><span class="line">   <span class="comment">// wait until os::start_thread()</span></span><br><span class="line">   <span class="comment">// 如果 OSThread 是初始化状态，则让它阻塞。</span></span><br><span class="line">    <span class="keyword">while</span> (osthread-&gt;get_state() == INITIALIZED) &#123;</span><br><span class="line">     sync-&gt;wait_without_safepoint_check();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// OSThread 从阻塞中醒来，调用 JavaThread.call_run 方法</span></span><br><span class="line"> thread-&gt;call_run();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到，Linux 在创建线程后先是将状态设置为了 <strong>INITIALIZED</strong>，然后阻塞自己，等待执行 <strong>os::start_thread()</strong> 唤醒自己。醒来后会间接调用 C++ 的 JavaThread 对象的回调函数，进而通过 JVM 调用 Java 的 Thread 对象的 run 方法。至此，C++ 的 JavaThread 对象创建完毕，接着执行它的 start 方法去唤醒阻塞的 OSThread。</li><li>thread.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// thread -&gt; JavaThread</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Thread::start</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// Start is different from resume in that its safety is guaranteed by context or</span></span><br><span class="line"> <span class="comment">// being called from a Java method synchronized on the Thread object.</span></span><br><span class="line"> <span class="keyword">if</span> (thread-&gt;is_Java_thread()) &#123;</span><br><span class="line">   <span class="comment">// Initialize the thread state to RUNNABLE before starting this thread.</span></span><br><span class="line">  <span class="comment">// Can not set it after the thread started because we do not know the</span></span><br><span class="line">      <span class="comment">// exact thread state at that time. It could be in MONITOR_WAIT or</span></span><br><span class="line">     <span class="comment">// in SLEEPING or some other state.</span></span><br><span class="line">     java_lang_Thread::set_thread_status(JavaThread::cast(thread)-&gt;threadObj(),</span><br><span class="line">                                     JavaThreadStatus::RUNNABLE);</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 根据不同的操作系统，调用 start_thread 函数</span></span><br><span class="line"> <span class="comment">// 注意 OS线程还在等待该函数执行</span></span><br><span class="line"> os::start_thread(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到，C++ 的 JavaThread 对象的启动方法 start 会调用 os::start_thread 方法通过设置 OSThread 的状态为 <strong>RUNNABLE</strong> 进而唤醒阻塞的 OSThread ，下面我们依次看更新状态和唤醒方法。</li><li>os.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thead-&gt;JavaThread</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">os::start_thread</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 从 JavaThread 中取出 OSThread</span></span><br><span class="line"> OSThread* osthread = thread-&gt;osthread();</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 设置 OSThread 状态为 RUNNABLE</span></span><br><span class="line"> osthread-&gt;set_state(RUNNABLE);</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 启动线程</span></span><br><span class="line"> pd_start_thread(thread);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">os::pd_start_thread</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line"> OSThread * osthread = thread-&gt;osthread();</span><br><span class="line"> <span class="comment">// 检查 OSThread 状态</span></span><br><span class="line"> Monitor* sync_with_child = osthread-&gt;startThread_lock();</span><br><span class="line"> <span class="function">MutexLocker <span class="title">ml</span><span class="params">(sync_with_child, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 唤醒阻塞的OSThread （阻塞在 thread_native_entry 函数中）</span></span><br><span class="line"> sync_with_child-&gt;notify();</span><br><span class="line"> <span class="comment">// OSThread 被唤醒后会执行 JavaThread.call_run 方法</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>thread.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::call_run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">register_thread_stack_with_NMT();</span><br><span class="line">MACOS_AARCH64_ONLY(<span class="keyword">this</span>-&gt;init_wx());</span><br><span class="line">JFR_ONLY(Jfr::on_thread_start(<span class="keyword">this</span>);)</span><br><span class="line"><span class="keyword">this</span>-&gt;pre_run();</span><br><span class="line"><span class="comment">// JavaThread.run</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">this</span>-&gt;post_run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JavaThread::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// initialize thread-local alloc buffer related fields</span></span><br><span class="line">initialize_tlab();</span><br><span class="line">_stack_overflow_state.create_stack_guard_pages();</span><br><span class="line">cache_global_variables();</span><br><span class="line">set_thread_state(_thread_in_vm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaThread.thread_main_inner</span></span><br><span class="line"><span class="comment">// 运行可以执行 Java 线程的函数</span></span><br><span class="line">thread_main_inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>thread.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">JavaThread::thread_main_inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;has_pending_exception() &amp;&amp;</span><br><span class="line">   !java_lang_Thread::is_stillborn(<span class="keyword">this</span>-&gt;threadObj())) &#123;</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="function">ResourceMark <span class="title">rm</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="keyword">this</span>-&gt;set_native_thread_name(<span class="keyword">this</span>-&gt;name());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function">HandleMark <span class="title">hm</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 调用 JavaThread 的运行函数 thread_entry</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;entry_point()(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以上方法用于执行创建 C++ 的 JavaThread 对象时指定的回调函数。目的只有一个，那就是利用 JVM 调用 Java 中我们创建的 Thread 对象的 run 方法。</li></ol><p><strong>至此，Java 线程映射 OS 线程就介绍完毕了。下面我们进行简单小结：</strong></p><blockquote><ol><li>Java 中的 Thread 对象初始化完毕后调用 start 方法开始映射内核线程。注意，Thread 对象创建完毕后调用 start 方法之前和底层线程一毛钱的关系都没有。</li><li>通过调用本地方法 start0 创建 C++ 的 JavaThread 对象，并设置内核线程启动后触发的用于使用 JVM 执行的 Thread 对象的 run 方法的函数。</li><li>JavaThread 会创建底层操作系统的 native thread</li><li>底层的 native thread 开始运行，通过 JVM 调用 Thread 的 run() 方法</li><li>当 Thread 的run()方法执行完毕返回后,或者抛出异常终止后，终止 native thread</li></ol></blockquote><p>可以看出，<strong>Java 中的线程是和内核线程一一对应的，几乎对线程的所有操作都需要借助系统调用完成</strong>。Java 线程映射内核线程的关系图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/java-thread-relatio-os-thread.png" alt></p><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程也有自己的生命周期，Java 中的线程有六种状态，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+--- Thread</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 新建状态，线程尚未启动</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可运行状态。</span></span><br><span class="line"><span class="comment">         * 处于可运行状态的线程正在Java虚拟机中执行，但它可能正在等待操作系统的其他资源，如处理器。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 阻塞状态，等待对象监视器锁</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计时等待</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 终止状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线程的状态。</span></span><br><span class="line"><span class="comment">     * 注意：线程在任何时刻只可能处于 1 种状态。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this thread's state.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// get current thread state</span></span><br><span class="line">        <span class="keyword">return</span> sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>Java 线程中的 <strong>BLOCKED</strong>、<strong>WAITING</strong>、<strong>TIMED_WAITING</strong> 统称为阻塞状态（非 BLOCKED），这三种状态永远没有 CPU 的使用权。了解了线程的六个状态后，下面我们对状态之间的转换进行说明。</p><h3 id="NEW-新建"><a href="#NEW-新建" class="headerlink" title="NEW 新建"></a>NEW 新建</h3><p>NEW 新建表示线程被创建但尚未启动的状态，当我们 new Thread() 新建一个线程时，在线程运行 start() 方法之前，那么它的状态就是 <code>NEW</code>。而一旦线程调用了 start() 方法，它的状态就会从 <code>NEW</code> 变成 <code>RUNNABLE</code>。新建状态的展示如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-new-state.png" alt></p><h3 id="从-NEW-到-RUNNABLE-状态"><a href="#从-NEW-到-RUNNABLE-状态" class="headerlink" title="从 NEW 到 RUNNABLE 状态"></a>从 NEW 到 RUNNABLE 状态</h3><p><strong>NEW 状态的线程，不会被操作系统调度，因此不会执行。Java 线程要执行，就必须转换到 RUNNABLE 状态</strong>。从 NEW 状态转换到 RUNNABLE 状态很简单，只要调用线程对象的 start() 方法就可以了。Java 中的 <code>RUNNABLE</code> 状态对应操作系统线程状态中的两种状态，分别是 <strong>Running</strong> 和 <strong>Ready</strong> 。也就是说，Java 中处于 <code>RUNNABLE</code> 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。因此，对于处于 <code>RUNNABLE</code> 状态的 Java 线程来说，即使当它的 CPU 时间片使用完了导致该线程不能使用，它的状态依然不会改变，还是 <code>RUNNABLE</code> 状态。转换图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-runnable-state.png" alt></p><h3 id="RUNNABLE-与-BLOCKED-的状态转换"><a href="#RUNNABLE-与-BLOCKED-的状态转换" class="headerlink" title="RUNNABLE 与 BLOCKED 的状态转换"></a>RUNNABLE 与 BLOCKED 的状态转换</h3><p><strong>从 RUNNABLE 状态进入到 BLOCKED 状态只有一种可能，就是线程等待 synchronized 的隐式锁</strong>。synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态。转换图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-block-state.png" alt></p><p>想要从 BLOCKED 状态进入 RUNNABLE 状态，需要等待的线程获得 synchronized 隐式锁，获得锁后就又会从 BLOCKED 转换到 RUNNABLE 状态。转换图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-block-to-runnable.png" alt></p><h3 id="RUNNABLE-与-WAITING-的状态转换"><a href="#RUNNABLE-与-WAITING-的状态转换" class="headerlink" title="RUNNABLE 与 WAITING 的状态转换"></a>RUNNABLE 与 WAITING 的状态转换</h3><p>线程进入 Waiting 状态有三种可能性，具体如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-waiting-state.png" alt></p><p><strong>下面对三种可能进行描述：</strong></p><blockquote><ul><li><strong>Object.wait()：</strong>获得 synchronized 隐式锁的线程，调用无参的 Object.wait() 方法，会进入到当前锁对象的 ObjectMonitor 中的 <strong>WaitSet</strong> 等待队列中，当前线程状态由 RUNNABLE 转换为 WAITING 状态。</li><li><strong>Thread.join()：</strong>其中的 join() 是一种线程同步方法，如有一个线程对象 A，当调用 A.join() 的时候，执行这条语句的线程会等待 A 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 A 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE 。</li><li><strong>LockSupport.park()：</strong>调用 LockSupport.park() 方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用 LockSupport.unpark(Thread thread) 可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE 。</li></ul></blockquote><p><strong>注意：</strong>从 WAITING 状态流转到其他状态则比较特殊，因为 WAITING 是不限时的，也就是说无论过了多长时间它都不会主动恢复。</p><p><strong>这里分情况进行讨论：</strong></p><blockquote><ul><li>执行了 LockSupport.unpark() 进入 RUNNABLE 状态</li><li>join 的线程运行结束进入 RUNNABLE 状态。</li><li>被中断进入 RUNNABLE 状态。</li><li>其他线程调用 notify() 或 notifyAll()来唤醒它，它会直接进入 BLOCKED 状态。因为唤醒 WAITING 线程的线程如果调用 notify() 或 notifyAll()，要求必须首先持有 synchronized 的隐式锁，所以处于 WAITING 状态的线程被唤醒时拿不到该锁，就会进入 BLOCKED 状态，直到执行了 notify()/notifyAll() 的唤醒它的线程执行完毕并释放 synchronized 的隐式锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 BLOCKED 状态回到 RUNNABLE 状态。</li></ul></blockquote><p><strong>具体流转图如下：</strong></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-waiting-to-some.png" alt></p><h3 id="RUNNABLE-与-TIMED-WAITING-的状态转换"><a href="#RUNNABLE-与-TIMED-WAITING-的状态转换" class="headerlink" title="RUNNABLE 与 TIMED_WAITING 的状态转换"></a>RUNNABLE 与 TIMED_WAITING 的状态转换</h3><p>线程进入 TIMED_WAITING 有五种可能，具体如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-timed-waiting-state.png" alt></p><p><strong>下面对五种可能进行描述：</strong></p><blockquote><ul><li>调用带超时参数的 Thread.sleep(long millis) 方法</li><li>获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法</li><li>调用带超时参数的 Thread.join(long millis) 方法</li><li>调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法</li><li>调用带超时参数的 LockSupport.parkUntil(long deadline) 方法</li></ul></blockquote><p>这里可以发现 TIMED_WAITING 和 WAITING 状态的区别，仅仅是触发条件多了超时参数。</p><p>同样地，TIMED_WAITING 进入其它状态和 WAITING 类似，只是在其基础上增加了超时限制，也就是超时时间到达时将会返回到 RUNNABLE 状态，注意调用带超时参数的 Object.wait(long timeout) 方法，即使超时时间到了也是先进入阻塞状态（自行进入阻塞队列），获取到锁后才会返回到 RUNNABLE 状态。</p><p><strong>具体流转图如下：</strong></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-timed-waiting-to-some.png" alt></p><h3 id="从-RUNNABLE-到-TERMINATED-状态"><a href="#从-RUNNABLE-到-TERMINATED-状态" class="headerlink" title="从 RUNNABLE 到 TERMINATED 状态"></a>从 RUNNABLE 到 TERMINATED 状态</h3><p>线程进入 TERMINATED 状态有两种情况，具体如下：</p><ul><li>线程执行完 run() 方法后，会自动转换到 TERMINATED 状态</li><li>执行 run() 方法的时候异常抛出，也会导致线程终止</li></ul><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-terminated-state.png" alt></p><p>此外，有时候我们需要强制终止 run() 方法的执行，Java 的 Thread 类中提供了 stop() 方法，不过已经标记为 @Deprecated，所以不建议使用了。正确的姿势是利用线程中断进行交互。</p><h3 id="状态小结"><a href="#状态小结" class="headerlink" title="状态小结"></a>状态小结</h3><ul><li>线程生命周期不可逆，一旦进入 RUNNABLE 状态就不能回到 NEW 状态</li><li>一旦被终止就不可能再有任何状态的变化</li><li>一个线程只能有一次 NEW 和 TERMINATED 状态，只有处于中间状态才可以相互转换，注意相互转换的方向和时机</li></ul><h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><p><strong>并发</strong></p><blockquote><p>如果某个系统支持两个或多个动作<strong>同时存在</strong>，那么这个系统就是一个并发系统。处理器在不同线程之间高速切换，让使用者感觉到这些线程在同时执行。</p></blockquote><p><strong>并行</strong></p><blockquote><p>如果某个系统支持两个或多个动作<strong>同时执行</strong>，那么这个系统就是一个并行系统。</p></blockquote><p>并发系统与并行系统这两个定义之间的差异在于是<strong>同时存在</strong>还是<strong>同时执行</strong>。对于单核 CPU 并发执行任务，这些任务是同时存在的，CPU 会在不同任务之间进行切换，直到所有任务执行完成。并行意味着一定在多核 CPU 上，多个任务（线程）会被分配到独立的处理器上，因此可以同时运行。并行其实是并发的一个子集</p><h1 id="理解中断"><a href="#理解中断" class="headerlink" title="理解中断"></a>理解中断</h1><p>Java 中的中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。注意，中断某个线程，并不是说该线程就立即停止运行了，仅仅对该线程打了个标记。每个线程都关联了一个中断标识位，是一个 boolean 类型的变量，初始值为 false 。</p><p>关于线程中断，在 Thread 类中定义了以下几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 中断线程，即设置线程的中断状态为 true</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@spec</span> JSR-51</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">         checkAccess();</span><br><span class="line">     <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">         Interruptible b = blocker;</span><br><span class="line">         <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">             interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">             b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     interrupt0();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Thread 类中的静态方法，用于检测调用该方法的线程的中断状态，并重置中断标识位</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>  如果当前线程已经被中断过了，那么返回 true ，否则返回 false</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Thread 类中的实例方法，检测线程的中断状态。注意，不会重置中断标识位。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>   如果当前线程已经被中断过了，那么返回 true ，否则返回 false</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 检测线程是否已被中断。检测后是否重置中断状态基于传入的 参数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p>我们说中断线程，其实就是将线程的中断标识位置为 true ，至于被中断的线程怎么处理那就是线程自己的事了。线程通过检查自身是否被中断来进行响应，通过方法 <code>isInterrupted()</code> 判断是否被中断，通过调用静态方法 <code>Thread.interupted()</code> 对当前线程的中断标识位进行重置。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有被中断就执行任务，被中断则结束执行任务</span></span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted())&#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在 Java 提供的抛出 <code>InterruptedException</code> 方法在被调用抛出这个中断异常之前，Java 虚拟机会先把该线程的中断标识位清除然后抛出中断异常。</p><blockquote><p>Object: wait() 系列方法<br>Thread: join() 系列方法、sleep() 系列方法</p></blockquote><p>如上 JDK 提供的几个可中断方法，它们会让线程阻塞。如果线程阻塞在这些方法上，这个时候如果其他线程对这个线程进行了中断，那么这个线程会从这些方法中立即返回，抛出中断异常，同时重置中断状态为 false。日常开发中我们也可以根据需要，自定义可中断方法，在必要的时候通过线程中断实现特定功能。</p><p>此外，如果线程阻塞在 <code>LockSupport.park(Object obj)</code> 方法上，此时如果其他线程对该线程进行中断也会唤醒该阻塞线程，但是唤醒后不会重置中断状态。</p><p><strong>安全地终止线程：</strong>线程中断是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Java 中的线程进行了介绍。先是从线程的创建与启动出发，分析了 Java 线程与内核线程的关系；然后对 Java 中的线程状态及流转进行了详细说明；最后对线程的中断进行了介绍，它是停止线程的正确姿势，也是线程通信的一种方式。</p><p><strong>参考：</strong></p><p>Java编发编程的艺术书籍<br>Java并发编程78讲专栏</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;现代操作系统在运行一个程序时，会为其创建一个进程，进程是分配系统资源的最小单位。例如，启动一个 Java 程序时，操作系统就会创建一个 Ja
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="Thread" scheme="https://gentryhuang.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>时间轮算法 - HashedWheelTimer</title>
    <link href="https://gentryhuang.com/posts/1d01ceec/"/>
    <id>https://gentryhuang.com/posts/1d01ceec/</id>
    <published>2021-07-24T02:06:24.000Z</published>
    <updated>2021-10-12T15:49:10.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>时间轮是一种高效利用线程资源来进行批量化调度的一种调度模型。将大批量的调度任务全部都绑定到同一个调度器上，使用这一调度器来进行所有任务的管理、触发以及执行。本篇文章将对 HashedWheelTimer 进行分析。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>编码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.util.HashedWheelTimer;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.Timeout;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.Timer;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimerClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 创建一个 HashedWheelTimer，内部参数全部使用默认值</span></span><br><span class="line">        Timer timer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 编写 TimeTask 任务</span></span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"is working !"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 提交任务</span></span><br><span class="line">        <span class="comment">// 创建 HashedWheelTimeout 对象，并将该对象放入任务队列中，等待被加入到 Hash 轮中被调用。</span></span><br><span class="line">        Timeout timeout = timer.newTimeout(timerTask, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调度结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1is working !</span><br></pre></td></tr></table></figure><h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>时间轮调度模型如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/hashedwheeltimer/hash-wheel-timer-model.jpeg" alt></p><p><strong>HashedWheelTimer</strong> 时间轮算法可以通过上图来描述。假设时间轮大小为 8 即 8 个格子，1s 转一格，每格都对应一个链表，链表每个节点都保存着待执行的任务。某一时刻，时间轮走到编号为 2 的格子，此时添加了一个 3s 后执行的任务，对应 3 个格子，则 2 + 3 = 5，在编号为 5 的格子对应链表中添加一个任务节点即可，轮次 round 为 0 ；如果添加一个 10s 后执行的任务，同理得 (2 + 10) % 8 = 4，在编号为 4 的格子对应的链表中添加一个任务节点，并标识轮次 round 为 1，当时间轮第二次经过编号为 4 的格子时就会执行该任务。注意，时间轮只会执行 round = 0 的任务，并会把该格子上的其他任务的 round 减 1 。</p><p>时间轮算法的原理还是非常容易理解的，下面我们从源码层面进行分析。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>HashedWheelTimer 相关的核心类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/hashedwheeltimer/hash-wheel-timer-uml.jpg" alt></p><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>HashedWheelTimer 是接口 io.netty.util.Timer 的实现，Timer 是任务调度器，负责对延时任务进行管理、触发和调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调度指定的 TimerTask ，在指定的延迟后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 与指定任务相关联的句柄</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException      if this timer has been &#123;<span class="doctag">@linkplain</span> #stop() stopped&#125; already</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the pending timeouts are too many and creating new timeout</span></span><br><span class="line"><span class="comment">     *                                    can cause instability in the system.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止所有的还没被执行的定时任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 与被此方法取消的任务相关联的句柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h2><p>延时任务，由业务方自行实现。Timer 会在触发时间对延时任务进行调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Timer 调度的任务，由业务方实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executed after the delay specified with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Timer#newTimeout(TimerTask, long, TimeUnit)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 任务执行的时候会将该任务对应的 Timeout 传进来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h2><p>Timeout 是一个非常重要的接口，它的唯一实现类是 HashedWheelTimer 内部类 HashedWheelTimeout ，该内部类聚合了时间轮主要的核心对象，关于该内部类下文会详细分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与&#123;<span class="doctag">@link</span> TimerTask&#125;关联的句柄，由&#123;<span class="doctag">@link</span> Timer&#125;返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回创建此句柄的&#123;<span class="doctag">@link</span> Timer&#125;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Timer <span class="title">timer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TimerTask <span class="title">task</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当且仅当与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;已过期时返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当且仅当与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;已被取消时返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试取消与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;。如果任务已经被执行或取消，它将返回而没有副作用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果取消成功，则为 true，否则为 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashedWheelTimer"><a href="#HashedWheelTimer" class="headerlink" title="HashedWheelTimer"></a>HashedWheelTimer</h2><p>HashedWheelTimer 是对 Timer 的实现，也就是我们说的时间轮。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimer</span> <span class="keyword">implements</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimer 实例统计原子变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger INSTANCE_COUNTER = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过多 HashedWheelTimer 阈值开关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicBoolean WARNED_TOO_MANY_INSTANCES = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimer 数量的阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTANCE_COUNT_LIMIT = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小延时时间，默认是 1 毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MILLISECOND_NANOS = TimeUnit.MILLISECONDS.toNanos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ResourceLeakDetector&lt;HashedWheelTimer&gt; leakDetector = ResourceLeakDetectorFactory.instance()</span><br><span class="line">            .newResourceLeakDetector(HashedWheelTimer<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间轮状态，可以控制工作线程执行任务的状态。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimer&gt; WORKER_STATE_UPDATER =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class, "workerState");</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceLeakTracker&lt;HashedWheelTimer&gt; leak;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread workerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态  0 - init, 1 - started, 2 - shut down</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_INIT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_STARTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_SHUTDOWN = <span class="number">2</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unused"</span>, <span class="string">"FieldMayBeFinal"</span>&#125;)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> workerState; <span class="comment">// 0 - init, 1 - started, 2 - shut down</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走一个 bucket 需要花费的纳秒时长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> tickDuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bucket 数组，用于存储任务，即 HashedWheelTimeout 实例们</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelBucket[] wheel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 掩码，用于 与运算 ，计算属于 wheel 哪个下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 newTimeout 方法线程等待工作线程 workerThread 开启执行任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startTimeInitialized = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimeout 任务队列。MPSC 队列，适用于这里的多生产线程，单消费线程的场景</span></span><br><span class="line">    <span class="comment">// 提交的任务会先进入到该队列中，每次 tick 才会将队列中的任务（一次最多 10 万个）加入到 bucket 中的链表里</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; timeouts = PlatformDependent.newMpscQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimeout 任务取消队列</span></span><br><span class="line">    <span class="comment">// 取消的任务会加入到该队列中，此次 tick 会将该队列中的任务从 bucket 中移除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; cancelledTimeouts = PlatformDependent.newMpscQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间轮中处于等待执行的任务数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong pendingTimeouts = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许最大的等待任务数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxPendingTimeouts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程启动时间，作为时间轮的基准时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> startTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*----------------- 系列构造方法 -------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Executors.defaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(<span class="keyword">long</span> tickDuration, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Executors.defaultThreadFactory(), tickDuration, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(<span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Executors.defaultThreadFactory(), tickDuration, unit, ticksPerWheel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory, <span class="keyword">long</span> tickDuration, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, <span class="number">512</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, ticksPerWheel, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel, <span class="keyword">boolean</span> leakDetection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, ticksPerWheel, leakDetection, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 HashedWheelTimer 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory      线程工厂，用于创建执行 TimerTask 任务的工作线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tickDuration       tick 之间的持续时间，即一次 tick 的时间长度。默认是 100</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit               tickDuration 的时间单位。默认是 毫秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticksPerWheel      定义一圈有多少个 bucket 。 默认是 512</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leakDetection      用于追踪内存泄漏</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxPendingTimeouts 最大允许等待的任务数，也就是 Timeout 实例数（调用 newTimeout 方法产生），可以根据该参数控制不允许太多的任务等待。</span></span><br><span class="line"><span class="comment">     *                           如果未执行任务数达到阈值，那么再次提交任务会抛出 RejectedExecutionException 异常。如果该值为 0 或 负数，则不限制。</span></span><br><span class="line"><span class="comment">     *                           默认不限制。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel, <span class="keyword">boolean</span> leakDetection,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> maxPendingTimeouts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 参数校验</span></span><br><span class="line">        ObjectUtil.checkNotNull(threadFactory, <span class="string">"threadFactory"</span>);</span><br><span class="line">        ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line">        ObjectUtil.checkPositive(tickDuration, <span class="string">"tickDuration"</span>);</span><br><span class="line">        ObjectUtil.checkPositive(ticksPerWheel, <span class="string">"ticksPerWheel"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建时间轮 bucket 结构，这里做向上取整，保证 bucket 数组长度是 2 的 n 次方</span></span><br><span class="line">        <span class="comment">// wheel 就是一个个 bucket。时间轮会以循环的方式走这个 wheel 数组</span></span><br><span class="line">        wheel = createWheel(ticksPerWheel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 掩码，bucket - 1，用来做取模，计算任务应该放到哪个 bucket 中</span></span><br><span class="line">        <span class="comment">// HashMap 在进行 hash 之后，进行index的hash寻址寻址的算法也是和这个一样的</span></span><br><span class="line">        mask = wheel.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 将延迟时间统一转为纳秒</span></span><br><span class="line">        <span class="keyword">long</span> duration = unit.toNanos(tickDuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 防止延迟时间溢出</span></span><br><span class="line">        <span class="keyword">if</span> (duration &gt;= Long.MAX_VALUE / wheel.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">"tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d"</span>,</span><br><span class="line">                    tickDuration, Long.MAX_VALUE / wheel.length));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 延迟时间不能小于 1 毫秒</span></span><br><span class="line">        <span class="keyword">if</span> (duration &lt; MILLISECOND_NANOS) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Configured tickDuration &#123;&#125; smaller then &#123;&#125;, using 1ms."</span>,</span><br><span class="line">                    tickDuration, MILLISECOND_NANOS);</span><br><span class="line">            <span class="keyword">this</span>.tickDuration = MILLISECOND_NANOS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.tickDuration = duration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 根据线程工厂创建线程。注意，这里并没有立即启动线程，启动线程是在第一次提交延迟任务的时候。</span></span><br><span class="line">        workerThread = threadFactory.newThread(worker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追踪内存泄露的，略</span></span><br><span class="line">        leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8 最大允许等待的 Timeout 实例数</span></span><br><span class="line">        <span class="keyword">this</span>.maxPendingTimeouts = maxPendingTimeouts;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9  如果超过 64 个 HashedWheelTimer 实例，它会打印错误日志提醒你</span></span><br><span class="line">        <span class="comment">// 因为时间轮是一个非常耗费资源的结构，所以一个 jvm 中的实例数目不能太高</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</span><br><span class="line">                WARNED_TOO_MANY_INSTANCES.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// 打印错误日志</span></span><br><span class="line">            reportTooManyInstances();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过以上构造方法可以初始化一个时间轮对象，默认情况下，时间轮大小是 512，也就是一圈有 512 个 bucket，走一个 bucket 需要时间为 100ms 。</p><h3 id="初始化-bucket"><a href="#初始化-bucket" class="headerlink" title="初始化 bucket"></a>初始化 bucket</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时间轮 bucket 数组，用来存储任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticksPerWheel 一圈有多少个 bucket ，默认是 512</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashedWheelBucket[] createWheel(<span class="keyword">int</span> ticksPerWheel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"ticksPerWheel must be greater than 0: "</span> + ticksPerWheel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间轮 tick 不能多大</span></span><br><span class="line">        <span class="keyword">if</span> (ticksPerWheel &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"ticksPerWheel may not be greater than 2^30: "</span> + ticksPerWheel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  标准化时间轮大小</span></span><br><span class="line">        ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 HashedWheelBucket 数组</span></span><br><span class="line">        HashedWheelBucket[] wheel = <span class="keyword">new</span> HashedWheelBucket[ticksPerWheel];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wheel.length; i++) &#123;</span><br><span class="line">            wheel[i] = <span class="keyword">new</span> HashedWheelBucket();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wheel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标准化时间轮大小，原则：向上取整，达到 2 的 n 次方</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticksPerWheel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">normalizeTicksPerWheel</span><span class="params">(<span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> normalizedTicksPerWheel = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取第一个大于 ticksPerWheel 的 2 的 n 次方的值</span></span><br><span class="line">        <span class="keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;</span><br><span class="line">            <span class="comment">// 左移一位，即 扩大 2 倍</span></span><br><span class="line">            normalizedTicksPerWheel &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> normalizedTicksPerWheel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>初始化 bucket 的过程就是初始化时间轮的格子，每个格子用于管理落在当前位置的延时任务们，这些任务由链表组织起来，且任务具有轮次的语义，只有任务的轮次为 0 时才能被时间轮执行。注意，<strong>时间轮中的每个 bucket 和延时时间是通过 tick 来间接关联的</strong>，通过延时任务的时间可以计算出它对应 N 个 tick ，而 tick 数对 bucket 数组长度取模运算就能确定具体的 bucket。延时任务完成 Bucket 分配后，时间轮不断进行 tick 的过程就可以通过计算找到 tick 对应的 Bucket ，进而处理延时任务。</p><h2 id="HashedWheelTimeout"><a href="#HashedWheelTimeout" class="headerlink" title="HashedWheelTimeout"></a>HashedWheelTimeout</h2><p>延时任务的包装类，该类聚合了时间轮所有的核心对象及属性，也就是说通过该对象可以拿到所有核心的对象和属性，并且该类包含了延时任务执行的方法<strong>expire()</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimeout</span> <span class="keyword">implements</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_INIT = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 取消</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_CANCELLED = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 到期</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_EXPIRED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用CAS方式更新任务状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; STATE_UPDATER =</span><br><span class="line">                AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.class, "state");</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Timer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelTimer timer;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * TimerTask</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TimerTask task;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 任务触发时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> deadline;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unused"</span>, <span class="string">"FieldMayBeFinal"</span>, <span class="string">"RedundantFieldInitialization"</span>&#125;)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = ST_INIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 离任务执行的轮数，0 表示当前轮次执行。当任务从队列加入 bucket 时会计算这个值。</span></span><br><span class="line">        <span class="comment">// 对与轮次非 0 的任务，那么时间轮执行到对应的 bucket 时会将该任务的该属性值 -1 </span></span><br><span class="line">        <span class="keyword">long</span> remainingRounds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这将用于通过双向链表在 hashhedwheeltimerbucket 中链接超时 的前后指针</span></span><br><span class="line">        HashedWheelTimeout next;</span><br><span class="line">        HashedWheelTimeout prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前 HashedWheelTimeout 所在的 bucket</span></span><br><span class="line">        HashedWheelBucket bucket;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashedWheelTimeout 用于封装 HashedWheelTimer、TimerTask 以及 deadLine 触发时间</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> timer</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> deadline</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HashedWheelTimeout(HashedWheelTimer timer, TimerTask task, <span class="keyword">long</span> deadline) &#123;</span><br><span class="line">            <span class="keyword">this</span>.timer = timer;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.deadline = deadline;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+---HashedWheelTimeout</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 到期并执行任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_EXPIRED)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行 TimerTask.run 方法</span></span><br><span class="line">                task.run(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"An exception was thrown by "</span> + TimerTask<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>() + '.', <span class="title">t</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行任务本质上是调用 HashedWheelTimeout 对象中封装的 TimerTask 对象的 run 方法。需要注意的是，即使任务执行过程抛出异常工作线程也不会退出；为了提高时间轮的精准度，任务执行最好使用异步方式。</p><h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---HashedWheelTimeout</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 取消任务</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里只是修改状态为取消，实际会在下次tick的时候移除</span></span><br><span class="line">     <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_CANCELLED)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">           </span><br><span class="line">     <span class="comment">// 加入到时间轮的全局待取消队列，并在每次tick的时候，从相应 bucket 中移除。 </span></span><br><span class="line">      timer.cancelledTimeouts.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>取消任务只是将待执行的 HashedWheelTimeout 对象加入到全局取消队列中，在后续的 tick 过程才会从对应的 bucket 中删除。</p><h3 id="移除任务"><a href="#移除任务" class="headerlink" title="移除任务"></a>移除任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimeout</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前 Timeout 从对应的 bucket 链表中移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   HashedWheelBucket bucket = <span class="keyword">this</span>.bucket;</span><br><span class="line">     <span class="keyword">if</span> (bucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">          bucket.remove(<span class="keyword">this</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          timer.pendingTimeouts.decrementAndGet();</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>将 HashedWheelTimeout 对象从对应的 bucket 中删除。</p><h2 id="HashedWheelBucket"><a href="#HashedWheelBucket" class="headerlink" title="HashedWheelBucket"></a>HashedWheelBucket</h2><p>用来存放包装任务的 HashedWheelTimeout ，以链表结构的形式进行管理，链表中的每一个节点都是 HashedWheelTimeout。</p><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelBucket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 头指针</span></span><br><span class="line">       <span class="keyword">private</span> HashedWheelTimeout head;</span><br><span class="line">       <span class="comment">// 尾指针</span></span><br><span class="line">       <span class="keyword">private</span> HashedWheelTimeout tail;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Add &#123;<span class="doctag">@link</span> HashedWheelTimeout&#125; to this bucket.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 添加 HashedWheelTimeout 到 当前 bucket 中，即加入到链中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTimeout</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">assert</span> timeout.bucket == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 设置 timeout 的桶，即聚合桶对象</span></span><br><span class="line">           timeout.bucket = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 维护桶中的 HashedWheelTimeout</span></span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">               head = tail = timeout;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               tail.next = timeout;</span><br><span class="line">               timeout.prev = tail;</span><br><span class="line">               tail = timeout;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将 timeout 从链表中移除</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> HashedWheelTimeout <span class="title">remove</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</span><br><span class="line">           HashedWheelTimeout next = timeout.next;</span><br><span class="line">           <span class="comment">// remove timeout that was either processed or cancelled by updating the linked-list</span></span><br><span class="line">           <span class="keyword">if</span> (timeout.prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">               timeout.prev.next = next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (timeout.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">               timeout.next.prev = timeout.prev;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (timeout == head) &#123;</span><br><span class="line">               <span class="comment">// if timeout is also the tail we need to adjust the entry too</span></span><br><span class="line">               <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">                   tail = <span class="keyword">null</span>;</span><br><span class="line">                   head = <span class="keyword">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   head = next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">               <span class="comment">// if the timeout is the tail modify the tail to be the prev node.</span></span><br><span class="line">               tail = timeout.prev;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// null out prev, next and bucket to allow for GC.</span></span><br><span class="line">           timeout.prev = <span class="keyword">null</span>;</span><br><span class="line">           timeout.next = <span class="keyword">null</span>;</span><br><span class="line">           timeout.bucket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// timeout 对应的 timer 的等待任务数减 1</span></span><br><span class="line">           timeout.timer.pendingTimeouts.decrementAndGet();</span><br><span class="line">           <span class="keyword">return</span> next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行任务-1"><a href="#执行任务-1" class="headerlink" title="执行任务"></a>执行任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelBucket</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Expire all &#123;<span class="doctag">@link</span> HashedWheelTimeout&#125;s for the given &#123;<span class="doctag">@code</span> deadline&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 执行 bucket 中的到期任务。注意，只执行 bucket 中轮次为 0 且到期的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireTimeouts</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取时间任务链表的头</span></span><br><span class="line">        HashedWheelTimeout timeout = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理链表上的所有 timeout 实例</span></span><br><span class="line">        <span class="keyword">while</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            HashedWheelTimeout next = timeout.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调整当前 bucket 的任务链表</span></span><br><span class="line">                next = remove(timeout);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 到达触发时间</span></span><br><span class="line">                <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 执行具体的任务，即执行 timeout 中的 TimerTask.run 方法</span></span><br><span class="line">                    timeout.expire();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不可能进入到这个分支</span></span><br><span class="line">                    <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line">                            <span class="string">"timeout.deadline (%d) &gt; deadline (%d)"</span>, timeout.deadline, deadline));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务被取消了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</span><br><span class="line">                next = remove(timeout);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 轮次减 1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout.remainingRounds--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理下个任务</span></span><br><span class="line">            timeout = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>工作线程 tick 时会找到当前 tick 对应的 bucket ，然后执行上述方法进而调度延时任务。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>Worker 是工作线程的任务体，里面封装了时间轮任务触发和执行的逻辑。一旦工作线程启动后，就会不停地 “滴答” bucket ，直到时间轮关闭。</p><h3 id="任务体"><a href="#任务体" class="headerlink" title="任务体"></a>任务体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录没有处理的时间任务</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="keyword">new</span> HashSet&lt;Timeout&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录走了几个 bucket ，不拥堵的情况下每隔 tickDuration 时间走一个 bucket</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> tick;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化启动时间。</span></span><br><span class="line">            <span class="comment">// 注意，在 HashedWheelTimer 中用的都是相对时间，因此需要以启动时间为基准。这里使用 volatile 修饰</span></span><br><span class="line">            startTime = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 因为 startTime = 0 作为工作线程未开始执行任务的标志。这里开始执行了，需要设置非 0</span></span><br><span class="line">                startTime = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个提交任务的线程在 start() 处等待，需要唤醒它</span></span><br><span class="line">            startTimeInitialized.countDown();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * do-while 执行任务逻辑：</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 工作线程是逐个 bucket 顺序处理的，所以即使有些任务执行时间超过了一次 tick 时间，也没关系，这些任务并不会被漏掉。</span></span><br><span class="line"><span class="comment">             * 但是可能被延迟执行，毕竟工作线程是单线程。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待下次 tick 到来，理论上每次等待 tickDuration 就会返回，然后继续往下走</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> deadline = waitForNextTick();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前 tick 下 bucket 数组对应 index，即哪个 bucket</span></span><br><span class="line">                    <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (tick &amp; mask);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理已经取消的任务</span></span><br><span class="line">                    processCancelledTasks();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取当前 tick 对应的桶</span></span><br><span class="line">                    HashedWheelBucket bucket = wheel[idx];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将 timeouts 队列中的 HashedWheelTimeout 转移到相应的桶中</span></span><br><span class="line">                    transferTimeoutsToBuckets();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 执行进入到 bucket 中的任务</span></span><br><span class="line">                    bucket.expireTimeouts(deadline);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 记录走了多少个 tick</span></span><br><span class="line">                    tick++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 执行到这里，说明当前 Timer 要关闭了，做一些清理工作 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将所有 bucket 中没有执行的任务，添加到 unprocessedTimeouts 这个 HashSet 中，用于 stop() 方法返回。</span></span><br><span class="line">            <span class="keyword">for</span> (HashedWheelBucket bucket : wheel) &#123;</span><br><span class="line">                <span class="comment">// 将当前 bucket 上链表节点任务都加入到 unprocessedTimeouts</span></span><br><span class="line">                bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务队列中的任务也添加到 unprocessedTimeouts 中</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!timeout.isCancelled()) &#123;</span><br><span class="line">                    unprocessedTimeouts.add(timeout);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理已经取消的任务</span></span><br><span class="line">            processCancelledTasks();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程启动的第一步是初始化全局的 <code>startTime</code>，它将作为时间轮的基准时间，用来计算延时任务的触发时间。并调用 <code>countDown</code> 方法来通知阻塞在 <code>start</code> 方法上的线程。接着进入主循环中，循环中的行为是每隔一段时间（tickDuration）走一个 bucket ，下面我们拆解执行部分。</p><h3 id="waitForNextTick"><a href="#waitForNextTick" class="headerlink" title="waitForNextTick"></a>waitForNextTick</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- Worker</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitForNextTick</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 计算当前 tick 下的 deadline，这值是确定的。即一次 tick 期限是一个固定值</span></span><br><span class="line">            <span class="comment">// 注意，这里就体现了时间轮的核心，理论上每隔 tickDuration 就会 "滴答" 一次</span></span><br><span class="line">            <span class="keyword">long</span> deadline = tickDuration * (tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 等待当前 tick 时间到达</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.1 基于 startTime 计算距离当前时间的时间戳，该值的理论值认为等于 dealine ，但由于任务执行时间没法控制，实际值一般大于 deadline </span></span><br><span class="line">                <span class="comment">// 注意，startTime 值是固定的，在工作线程启动就定了</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime() - startTime;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.2 判断是否可以进行 tick</span></span><br><span class="line">                <span class="comment">// 标准是：tick 触发的时间值 - currentTime &lt;= 0，没有到触发时间则休眠 sleepTimeMs 毫秒</span></span><br><span class="line">                <span class="comment">// 这里加 999999 是补偿精度，不足 1ms 的补足 1ms</span></span><br><span class="line">                <span class="keyword">long</span> sleepTimeMs = (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3 因为每次执行任务消耗的时间是不受控制的，因此计算出来的 sleepTimeMs 可能为负数</span></span><br><span class="line">                <span class="comment">// 当为负数时，说明前面的任务执行时间过长，导致本该 tick 的时候错过了。这个时候不需要休眠等待，需要立刻处理</span></span><br><span class="line">                <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -Long.MAX_VALUE;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 返回值是基于 startTime 计算的距离当前时间的时间戳</span></span><br><span class="line">                        <span class="keyword">return</span> currentTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// windows 平台特别处理。先除以10再乘以10，是因为windows平台下最小调度单位是10ms，如果不处理成10ms的倍数，可能导致sleep更不准了</span></span><br><span class="line">                <span class="keyword">if</span> (PlatformDependent.isWindows()) &#123;</span><br><span class="line">                    sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">if</span> (sleepTimeMs == <span class="number">0</span>) &#123;</span><br><span class="line">                        sleepTimeMs = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2.4 没有到 tick 时间，则休眠</span></span><br><span class="line">                    Thread.sleep(sleepTimeMs);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    <span class="comment">// 如果工作线程已经关闭，那么返回 Long.MIN_VALUE</span></span><br><span class="line">                    <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Long.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>waitForNextTick 方法的逻辑已经详细注释，该方法就是用来控制每隔一定的时间 “滴答” 一次即跳一个 bucket，此外还处理了因上一个 tick 处理任务时间过长问题，采用的是立即触发执行的方式。不难看出，当遇到较长时间执行的任务时，会打乱原本正常 tick 的节奏，导致其他任务延期执行。 <code>tickDuration</code> 控制着时间的精准度，值越小精准度越高，工作线程则越繁忙。</p><h3 id="processCancelledTasks"><a href="#processCancelledTasks" class="headerlink" title="processCancelledTasks"></a>processCancelledTasks</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- Worker</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理已经取消的任务。将已经取消的任务从对应的 bucket 中移除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCancelledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 遍历任务取消队列</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = cancelledTimeouts.poll();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// all processed</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 将 timeout 从对应的 bucket 中移除</span></span><br><span class="line">                    <span class="comment">// 通过 timeout 持有的 bukcet 进行的操作，即从bucket 链表中删除该 timeout </span></span><br><span class="line">                    timeout.remove();</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"An exception was thrown while process a cancellation task"</span>, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>该方法是为了处理那些被取消的任务，将被取消的任务从队列和 bucket 中分别移除。</p><h3 id="transferTimeoutsToBuckets"><a href="#transferTimeoutsToBuckets" class="headerlink" title="transferTimeoutsToBuckets"></a>transferTimeoutsToBuckets</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+--- Worker</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将 HashedWheelTimeout 队列中的任务加入到相应的 bucket 中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferTimeoutsToBuckets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 限制每 tick 最大转移 10 万个 HashedWheelTimeout 到 bucket，以免阻塞工作线程</span></span><br><span class="line">            <span class="comment">// todo 如果有 100万 个，并且 tickDuration 时间为几分钟级别，那这种情况下就会有一批任务延迟。从侧面说明一个时间轮不能一下子添加特别多的任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">                <span class="comment">// 队列为空</span></span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// all processed</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 被取消了</span></span><br><span class="line">                <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;</span><br><span class="line">                    <span class="comment">// Was cancelled in the meantime.</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">/*---   将任务放到相应的 bucket 中 ----*/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算任务触发时间需要经过多少个 tick</span></span><br><span class="line">                <span class="keyword">long</span> calculated = timeout.deadline / tickDuration;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算任务所属的轮次</span></span><br><span class="line">                timeout.remainingRounds = (calculated - tick) / wheel.length;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果任务在 timeouts 队列里面放久了, 以至于已经过了执行时间(calculated &lt; tick), 这个时候就使用当前 tick 对应的 bucket，从而让那些本应该在过去执行的任务在当前 tick 快速执行掉。</span></span><br><span class="line">                <span class="comment">// 此方法调用完后就会立即执行当前 tick 对应的 bucket 中的任务</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ticks = Math.max(calculated, tick); <span class="comment">// Ensure we don't schedule for past.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算 ticks 对应 bucket</span></span><br><span class="line">                <span class="keyword">int</span> stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask);</span><br><span class="line">                HashedWheelBucket bucket = wheel[stopIndex];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 单个 bucket 是由 HashedWheelTimeout 实例组成的一个链表，单个线程不存在并发</span></span><br><span class="line">                <span class="comment">// 这里将 timeout 加入到 bucket 的链表中</span></span><br><span class="line">                bucket.addTimeout(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在每次执行 tick 对应的 bucket 中的延时任务时，会先将全局任务队列中待执行的任务加入到对应的 bucket 中。</p><h3 id="expireTimeouts"><a href="#expireTimeouts" class="headerlink" title="expireTimeouts"></a>expireTimeouts</h3><p>一次 tick 到来后找到对应的 Bucket，然后就可以处理当前 Bucket 中的延时任务了，具体实现见前文。expireTimeouts 方法中会间接执行 <code>TimeTask.run</code> 方法，如果延时任务执行时间过久则会阻塞工作线程，进一步拖慢超时检测流程。</p><p>以上对 HashedWheelTimer 主要源码进行了分析，但没有串起来。下面我们以执行过程的形式进一步说明。</p><h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task  任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delay 延时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit  延迟时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 校验参数</span></span><br><span class="line">        ObjectUtil.checkNotNull(task, <span class="string">"task"</span>);</span><br><span class="line">        ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 校验等待任务数是否达到阈值</span></span><br><span class="line">        <span class="keyword">long</span> pendingTimeoutsCount = pendingTimeouts.incrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> (maxPendingTimeouts &gt; <span class="number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;</span><br><span class="line">            pendingTimeouts.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Number of pending timeouts ("</span></span><br><span class="line">                    + pendingTimeoutsCount + <span class="string">") is greater than or equal to maximum allowed pending "</span></span><br><span class="line">                    + <span class="string">"timeouts ("</span> + maxPendingTimeouts + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果工作线程没有启动，则启动工作线程。一般由第一个提交任务的线程负责工作线程的启动</span></span><br><span class="line">        start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将任务添加到队列中，该队列将在下一个 tick 时进行处理，在处理过程中，所有排队的 HashedWheelTimeout 将被添加到正确的 HashedWheelBucket 中 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 deadline 是一个相对时间，相对于工作线程启动时间。</span></span><br><span class="line">        <span class="comment">// 注意，该值作为延时任务触发的时间，后续流程虽然会判断，但是貌似用处不大。主要还是用在根据该值计算 tick 进而确定将任务分配到哪个 Bucket，因为任务触发是跟着 tick 走的。</span></span><br><span class="line">        <span class="keyword">long</span> deadline = System.nanoTime() + unit.toNanos(delay) - startTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Guard against overflow.</span></span><br><span class="line">        <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; deadline &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            deadline = Long.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 创建 HashedWheelTimeout 对象，进一步封装任务对象</span></span><br><span class="line">        HashedWheelTimeout timeout = <span class="keyword">new</span> HashedWheelTimeout(<span class="keyword">this</span>, task, deadline);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 加入到 timeouts 队列中，等待被加入到 Bucket 中</span></span><br><span class="line">        <span class="comment">// 注意，还没有加入到时间轮中</span></span><br><span class="line">        timeouts.add(timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> timeout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间轮在初始化后就可以接收业务方提交的延时任务请求了，任务的处理都是交给工作线程这个后台线程。提交任务的流程主要包含 3 个关键步骤：</p><blockquote><p>1 尝试启动工作线程 workerThread<br>2 计算延时任务的触发时间，创建 HashedWheelTimeout 对象进一步封装任务对象<br>3 将创建的 HashedWheelTimeout 对象加入到任务队列</p></blockquote><p>值得一提的是启动工作线程的逻辑，源码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动工作线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if this timer has been</span></span><br><span class="line"><span class="comment">     *                               &#123;<span class="doctag">@linkplain</span> #stop() stopped&#125; already</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果是初始化状态</span></span><br><span class="line">            <span class="keyword">case</span> WORKER_STATE_INIT:</span><br><span class="line">                <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;</span><br><span class="line">                    <span class="comment">// 启动工作线程</span></span><br><span class="line">                    workerThread.start();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WORKER_STATE_STARTED:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WORKER_STATE_SHUTDOWN:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cannot be started once stopped"</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Invalid WorkerState"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，直到 startTime 被工作线程初始化</span></span><br><span class="line">        <span class="keyword">while</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                startTimeInitialized.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                <span class="comment">// Ignore - it will be ready very soon.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到上述方法是 public 修饰的，也就是说用户可以显示的调用，而无需等待第一次提交任务时再启动。但一般没必要显示调用，没有任务提交没必要启动。</p><h2 id="执行任务-2"><a href="#执行任务-2" class="headerlink" title="执行任务"></a>执行任务</h2><p>前文也说了，时间轮中的任务都是由工作线程触发执行的。具体是<strong>一次 tick 到来</strong>后找到对应的 Bucket，然后就可以处理当前 Bucket 中的延时任务了。源码见前文。</p><h2 id="取消任务-1"><a href="#取消任务-1" class="headerlink" title="取消任务"></a>取消任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimeout</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// only update the state it will be removed from HashedWheelBucket on next tick.</span></span><br><span class="line">     <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_CANCELLED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 加入到取消任务队列中</span></span><br><span class="line">         timer.cancelledTimeouts.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>未到期但被取消的任务会放到 <code>cancelledTimeouts</code> 队列中，工作线程周期性调用 <code>processCancelledTasks()</code> 会从 bucket 中删除对应的 HashedWheelTimeout。</p><h2 id="终止时间轮"><a href="#终止时间轮" class="headerlink" title="终止时间轮"></a>终止时间轮</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 工作线程不能停止时间轮</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == workerThread) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    HashedWheelTimer<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>() +</span></span><br><span class="line">                            ".stop() cannot be called from " +</span><br><span class="line">                            TimerTask<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试 CAS 替换当前状态为 “停止：</span></span><br><span class="line">        <span class="keyword">if</span> (!WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) &#123;</span><br><span class="line">            <span class="comment">// workerState can be 0 or 2 at this moment - let it always be 2.</span></span><br><span class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.getAndSet(<span class="keyword">this</span>, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">                <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">assert</span> closed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 中断 worker线程，尝试把正在进行任务的线程中断掉,如果某些任务正在执行则会抛出interrupt异常，并且任务会尝试立即中断</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (workerThread.isAlive()) &#123;</span><br><span class="line">                workerThread.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    workerThread.join(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前前程会等待stop的结果</span></span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">assert</span> closed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回未处理的任务</span></span><br><span class="line">        <span class="keyword">return</span> worker.unprocessedTimeouts();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/hashedwheeltimer/hash-wheel-timer-process.jpg" alt></p><p>HashWheelTimer 是基于时间轮算法，提交的任务会被封装成 <code>HashedWheelTimeout</code> 对象并存放到全局任务队列中。时间轮的格子是用 bucket 数组表示，bucket 内部维护一个 <code>HashedWheelTimeout</code> 类型的双向链表，每一个节点都是一个 HashedWheelTimeout 对象。其内部使用一个工作线程自旋地进行 tick ，tick 到来后会先将全局任务队列中的任务添加到对应的 bucket 中，接着轮训当前 tick 对应 bucket 中的任务链表，执行轮次为 0 的任务，轮次非 0 的任务将其轮次减 1 。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p><strong>优点</strong></p><blockquote><p>1 本地机器直接执行，效率非常高。<br>2 无需扫描所有任务。通过将环切成 N 份，将查询到期延时任务的耗时降到 1/N，N 视任务量的大小可以灵活设置(1024,2048 等)</p></blockquote><p><strong>缺点</strong></p><blockquote><p>1 可靠性：<br>    -  机器重启，数据即丢失，可以使用 MySQL 等持久化存储，机器重启时从数据库 load 进内存。<br>    -  机器宕机，数据丢失，需要使用方自行处理，如由其它机器接管宕机机器的任务<br>2 时间轮调度器的时间精度可能不是很高，对于精度要求特别高的调度任务可能不太合适。因为时间轮算法的精度取决于一次 tick 的时间。<br>3 时间轮是通过单线程实现的，如果在执行任务的过程中出现阻塞，会影响后面任务执行。这个缺点也就是缺点 2 的直接体现。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>时间轮算法不难理解，但 HashedWheelTimer 源码中有很多细节需要注意。任务的管理，体现在任务队列和 bucket 数组的使用；任务的触发，体现在工作线程自旋进行 tick ；任务的执行，体现在工作线程轮询 bucket 的任务链表，对 TimerTask.run 的执行；需要注意的是，整个时间轮的调度都是在一个线程中完成的，因此对于那些耗时较大的定时任务会影响其他任务的正常触发和执行，但任务执行异常并不会导致工作线程退出，这是不同于 JDK 中的 Timer 。</p><p><strong>参考：</strong><br><a href="https://www.javadoop.com/post/HashedWheelTimer" target="_blank" rel="noopener">https://www.javadoop.com/post/HashedWheelTimer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;时间轮是一种高效利用线程资源来进行批量化调度的一种调度模型。将大批量的调度任务全部都绑定到同一个调度器上，使用这一调度器来进行所有任务的管理
      
    
    </summary>
    
    
      <category term="任务调度" scheme="https://gentryhuang.com/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
    
      <category term="HashedWheelTimer" scheme="https://gentryhuang.com/tags/HashedWheelTimer/"/>
    
  </entry>
  
</feed>
