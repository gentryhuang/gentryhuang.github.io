<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gentryhuang‘s blog</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gentryhuang.com/"/>
  <updated>2020-08-14T08:57:43.413Z</updated>
  <id>https://gentryhuang.com/</id>
  
  <author>
    <name>gentryhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis原理 - 链表</title>
    <link href="https://gentryhuang.com/posts/2362a8ea/"/>
    <id>https://gentryhuang.com/posts/2362a8ea/</id>
    <published>2020-07-08T11:33:59.000Z</published>
    <updated>2020-08-14T08:57:43.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol><li><p>redis中的链表</p><p>链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置这中数据结构，所以redis构建了自己的链表实现。</p></li><li><p>redis链表节点的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">  <span class="comment">// 前置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="comment">// 后置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">// 节点的值 (可用于保存各种不同类型的值)</span></span><br><span class="line">  <span class="keyword">void</span> *value</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>redis链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数，用于复制链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数，用于释放链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数，用于对比链表节点所保存的值和其他值是否相等</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>redis链表的特点</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)</span><br><span class="line">- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</span><br><span class="line">- 带表头和表尾指针：使用list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)</span><br><span class="line">- 带链表长度计数器：程序使用list结构的len属性标记链表中节点的个数，程序获取链表中节点个数的复杂度为O(1)</span><br><span class="line">- 多态：链表可以保存各种不同类型的值</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>链表在redis中的应用</p><p>链表被广泛用于实现redis的各种功能，如：列表键、发布与订阅、慢查询、监视器，redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;redis中的链表&lt;/p&gt;
&lt;p&gt;链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 简单动态字符串</title>
    <link href="https://gentryhuang.com/posts/aa1d8127/"/>
    <id>https://gentryhuang.com/posts/aa1d8127/</id>
    <published>2020-07-08T11:00:50.000Z</published>
    <updated>2020-08-14T08:57:43.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><ol><li><p>初识动态字符串</p><p>redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS作为redis的默认字符串表示。 <code>在redis中，c字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如日志。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，redis就会使用SDS来表示字符串值。</code> 值的注意的是，对于redis中的key都是使用SDS来实现的。此外，SDS除了用来保存Redis数据库中的字符串值之外，SDS还被用作缓冲区（buffer）: AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区。</p></li><li><p>sds的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">  <span class="comment">// 记录buf数组中已使用字节的数量等价于sds所保存字符串的长度</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">  <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">  <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>sds遵循c字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在sds的len属性中，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由sds函数自动完成的。遵循空字符结尾的好处是，sds可以直接使用一部分C字符串函数库里面的函数。</p></li><li><p>sds与c字符串的区别</p><p>c语言使用的简单字符串表示方式，并不能满足redis对字符串在安全性、效率以及功能方面的要求。</p><p>3.1  常数复杂度获取字符串长度</p><blockquote><p>因为c字符串并不记录自身的长度信息，所以要获取长度就必须遍历整个字符串，故获取字符串长度的复杂度为O(N)。而redis的sds结构中通过len属性记录了sds的长度，故获取字符串长度的复杂度为O(1)。注意，设置和更新sds长度的工作是由sds的API在执行时自动完成的，使用sds无须进行任何手动修改长度的操作。</p></blockquote><p>3.2 避免缓冲区溢出</p><blockquote><p>c字符串不记录自身长度，很容易造成缓冲区溢出。与c字符串不同，sds的空间分配策略完全杜绝了发生缓冲区溢出的可能性，当sds api需要对sds进行修改时，api会先检查sds的空间是否满足需要，如果不满足的话，api会自动将sds的空间扩展至执行所需的大小，然后才执行实际的修改操作，因此使用sds既不需要手动修改sds的空间大小，也不会出现c字符串中可能出现的缓冲区溢出问题。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    <span class="comment">//追加时先进行扩容，后面详细说明</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//拼接字符串</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s:原数组     </span></span><br><span class="line"><span class="comment">//strlen(t) 需拼接的目标数组的长度</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>3.3 内存分配与释放</p><p>因为c字符串的长度和底层数组的长度之间存在着关联性，所以<code>每次增加或者缩短一个c字符串，程序都总要对保存这个c字符串的数字进行一次分配操作</code>，但是内存分配操作涉及到复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，为了避免c字符串的这种缺陷，sds通过未使用空间解除了字符串长度和底层数组长度之间的关联，通过未使用空间，sds实现了空间预分配和惰性空间释放两种优化策略。</p><ul><li><p>空间预分配</p><p>空间预分配用于优化sds的字符串增长操作：当sds的api对一个sds进行修改，并且需要对sds进行空间扩展的时候，程序不仅会为sds分配修改所必须要的空间，还会为sds分配额外的未使用空间。通过空间预分配策略，redis可以减少连续执行字符串增长操作所需的内存重新分配次数，在扩展sds空间之前，sds api 会先检查未使用空间是否足够，如果足够就直接使用未使用空间，而不需要执行内存重新分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis 扩容源码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span><br><span class="line"><span class="comment"> * buf 至少会有 addlen + 1 长度的空余空间</span></span><br><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：扩展成功返回扩展后的 sds</span></span><br><span class="line"><span class="comment"> *        扩展失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额外分配未使用空间数量的计算策略：</p><blockquote><ol><li>对sds修改后，sds的长度（即len属性的值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时sds的len属性的值将和free属性的值相同。例如：修改后sds的len变成10字节，那么程序也会分配10字节的未使用空间，sds的buf数组的实际长度：10 + 10 + 1 = 21字节</li><li>对sds修改后，sds的长度大于等于1MB，那么程序会分配1MB的未使用空间。例如：修改后sds的len变成30MB，那么程序会分配1MB的未使用空间，sds的buf数组的时间长度：30MB + 1MB + 1byte</li></ol></blockquote></li><li><p>惰性空间释放</p><p>惰性空间释放用于优化sds的字符串缩短操作：当sds的api需要缩短sds保存的字符串时，程序并不立即使用内存重分配来回收缩短后多来的字节，而是使用free属性将这些字节的数量纪录起来，用于将来对sds进行增长操作时，这些未使用空间可能就派上用场了。注意，sds也提供了相应的api，可以真正地释放sds的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p></li></ul><p>3.4 二进制安全</p><blockquote><p>c字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里不能包含空字符，否则在读取的时候会被默认为结束字符，这些限制使得c字符串只能保存文本数据，不能保存图片、音视频、压缩文件这类的二进制数据。sds的api都是二进制安全的，所有的sds api都会以<code>二进制的方式处理sds存放在buf数组里的数据</code>,程序不会对其中的数据做任何限制、过滤，数据写入时是什么样，它被读取时就是什么样。<code>这也是将sds的buf属性称为字节数组的原因，redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据</code>。</p></blockquote></li><li><p>c字符串和sds之间的区别</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         C字符串                                    SDS</span><br><span class="line">- 获取字符串长度的复杂度为O（n）                 获取字符串长度的复杂度O（1）</span><br><span class="line">- API是不安全的，可能造成缓冲区溢出                      API是安全的</span><br><span class="line">- 修改字符串长度N次，必然要执行N次内存重分配     修改字符长度N次，最多执行N次内存重分配</span><br><span class="line">- 只能保存文本数据                                 可以保存文本或者二进制数据</span><br><span class="line">- 可使用&lt;string.h&gt;库中的函数                   可使用一部分&lt;string.h&gt;库中的函数</span><br></pre></td></tr></table></figure></li><li><p>sds更多的api可参考源码</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单动态字符串&quot;&gt;&lt;a href=&quot;#简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串&quot;&gt;&lt;/a&gt;简单动态字符串&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初识动态字符串&lt;/p&gt;
&lt;p&gt;redis没有直接使用C语言传统的字符串表示（以空字
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 优雅停机</title>
    <link href="https://gentryhuang.com/posts/ef4cfe7a/"/>
    <id>https://gentryhuang.com/posts/ef4cfe7a/</id>
    <published>2020-05-09T16:00:00.000Z</published>
    <updated>2020-09-03T01:23:40.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>优雅停机仅存在于服务重启、下线这样的部署阶段，优雅停机是一个应用生命周期的一部分，它保障了应用的健壮性。dubbo是通过jdk的ShutdownHook来完成优雅停机的，所以如果用户使用 kill -9 pid 等强制关闭指令，是不会执行优雅停机的，只有通过 kill pid 即正常退出进程，才会执行。</p><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><ul><li>优雅停机的服务端有正在处理中的请求，不能被停机指令中断，除非超时</li><li>优雅停机的消费端不应该再发起新的请求</li><li>消费端不应该请求已经下线的服务提供者</li></ul><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>应用的重新启动、停机等操作，避免了对业务的连续性造成影响，如：集群中的某个应用存在逻辑上的bug，需要修改程序，这时候就可以使用优雅停机平滑下线，不会造成调用方异常问题。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/shutdownhook.png" alt></p><p><font color="#c7254e"> dubbo中实现优雅停机主要包含以下步骤 </font></p><ol><li>收到kill 9 进程退出信号时，spring容器会触发容器销毁事件  (其实是spring注册的jvm钩子程序执行的，后面会看到)</li><li>provider端会取消注册服务元数据信息</li><li>consumer端会收到最新地址列表（准备停机地址不在该地址列表中）</li><li>dubbo协议会发送readonly事件报文通知consumer服务不可用</li><li>服务端等待已经执行的任务结束并不再处理新的请求</li></ol><p><strong>说明</strong></p><ul><li>上图中的流程是使用spring构建的dubbo应用</li><li>上图中的流程没有体现出优雅停机的消费端角色，该角色做的工作相对简单，主要是不再发起新的调用请求和等待响应返回，超时才会强制关闭</li><li>注册中心已经通知了最新服务列表，发送readonly事件主要考虑到注册中心推送服务有网络延迟以及客户端计算服务列表也需要时间。消费端收到后会设置对应的provider为不可用状态，下次负载均衡就不会调用这个下线的服务</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>dubbo对优雅停机的实现在不同的版本中有所差异，下面从2.5.x、2.6.x以及2.7.x这三个版本分别分析。</p><h4 id="2-5-x的优雅停机"><a href="#2-5-x的优雅停机" class="headerlink" title="2.5.x的优雅停机"></a>2.5.x的优雅停机</h4><p>注册shutdown hook</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 省略其它代码    </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 销毁资源</span></span><br><span class="line"><span class="comment">                     * 1 注册中心数据销毁： 删除注册中心中本节点对应的提供者地址以及订阅数据</span></span><br><span class="line"><span class="comment">                     * 2 协议流程数据销毁： 取消该协议所有已经暴露和引用的服务，释放协议所占用的所有资源，比如连接和端口</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    ProtocolConfig.destroyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"DubboShutdownHook"</span>));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p> ProtocolConfig.destroyAll()方法是用来释放资源的，由于dubbo支持多注册中心和多协议，因此具体销毁实现细节取决于具体的注册中心和具体的协议，这里不再展开说明。</p><h4 id="2-6-x的优雅停机"><a href="#2-6-x的优雅停机" class="headerlink" title="2.6.x的优雅停机"></a>2.6.x的优雅停机</h4><p> spring也依赖shutdown hook完成优雅停机，其注册jvm钩子的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a shutdown hook with the JVM runtime, closing this context</span></span><br><span class="line"><span class="comment"> * on JVM shutdown unless it has already been closed at that time.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Delegates to &#123;<span class="doctag">@code</span> doClose()&#125; for the actual closing procedure.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Runtime#addShutdownHook</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #close()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doClose()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No shutdown hook registered yet.</span></span><br><span class="line"><span class="keyword">this</span>.shutdownHook = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (startupShutdownMonitor) &#123;</span><br><span class="line">doClose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// 注册jvm钩子</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">this</span>.shutdownHook);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring的shutdownhook具体任务如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Actually performs context closing: publishes a ContextClosedEvent and</span></span><br><span class="line"><span class="comment">  * destroys the singletons in the bean factory of this application context.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Called by both &#123;<span class="doctag">@code</span> close()&#125; and a JVM shutdown hook, if any.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> org.springframework.context.event.ContextClosedEvent</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #destroyBeans()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #close()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #registerShutdownHook()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.active.get() &amp;&amp; <span class="keyword">this</span>.closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Closing "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiveBeansView.unregisterApplicationContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Publish shutdown event   // 注意容器关系事件的发布</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> ContextClosedEvent(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception thrown from ApplicationListener handling ContextClosedEvent"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop all Lifecycle beans, to avoid delays during individual destruction.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor.onClose();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception thrown from LifecycleProcessor on context close"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy all cached singletons in the context's BeanFactory.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close the state of this context itself.</span></span><br><span class="line">closeBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let subclasses do some final clean-up if they wish...</span></span><br><span class="line">onClose();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo2.6.x支持使用spring构建dubbo应用时，能够安全使用优雅停机。由于dubbo注册了jvm停止的钩子，<font color="#c7254e"> spring可能 </font> 也注册了jvm停机的钩子，这种情况下两个并发执行的线程可能引用已经销毁的资源，导致优雅停机失效。比如，dubbo正在执行的任务需要引用spring中的bean，但此时spring钩子已经关闭spring上下文，导致访问spring资源都会报错。因此对于这种情况，dubbo在2.6.3中新增ShutdownHookListener 类用来解决并发问题，该类实现了ApplicationListener接口，当进程退出时jvm钩子会被触发，此时spring和dubbo注册的jvm钩子都会被回调，spring注册的jvm钩子程序中spring发出容器关闭事件，ShutdownHookListener接收到关闭事件后执行dubbo的jvm钩子程序进行资源的释放，这样就避免使用无效spring bean的问题，从而完成优雅停机。</p><p><font color="#c7254e"> ShutdownHookListener </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            <span class="comment">// 使用spring框架时也不应该删除dubbo shutdown hook，因为spring可能没有注册ContextClosed 事件</span></span><br><span class="line">            DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook();</span><br><span class="line">            shutdownHook.destroyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e"> AbstractConfig中依然保留JVM停止钩子 </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 省略无关代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.name"</span>, <span class="string">"dubbo.service.protocol"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.host"</span>, <span class="string">"dubbo.service.server.host"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.port"</span>, <span class="string">"dubbo.service.server.port"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.threads"</span>, <span class="string">"dubbo.service.max.thread.pool.size"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.timeout"</span>, <span class="string">"dubbo.service.invoke.timeout"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.retries"</span>, <span class="string">"dubbo.service.max.retry.providers"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.check"</span>, <span class="string">"dubbo.service.allow.no.provider"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.service.url"</span>, <span class="string">"dubbo.service.address"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this is only for compatibility</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Dubbo 的优雅停机 ShutdownHook 在 AstractConfig 的静态代码块中，这保证了ShutdownHook能够给被初始化。</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 1 Dubbo 是 通过 JDK的ShutdownHook来完成优雅停机的</span></span><br><span class="line"><span class="comment">         * 2 ShutdownHook本质上是一个线程，任务体在对应的run方法中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e">DubboShutdownHook </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboShutdownHook</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DubboShutdownHook<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook,类属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DubboShutdownHook dubboShutdownHook = <span class="keyword">new</span> DubboShutdownHook(<span class="string">"DubboShutdownHook"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubboShutdownHook <span class="title">getDubboShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dubboShutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Has it already been destroyed or not?</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 是否已经被销毁标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean destroyed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DubboShutdownHook</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook的任务体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        destroyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Destroy all the resources, including registries and protocols.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 销毁所有的资源，包括 Registry相关 和 Protocol相关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果已经销毁则忽略</span></span><br><span class="line">        <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁所有的 Registry,取消应用程序中的服务提供者和消费者的订阅与注册</span></span><br><span class="line">        AbstractRegistryFactory.destroyAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 销毁所有的 Protocol</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 这里的Protocol比较多，大体上可以分两类：</span></span><br><span class="line"><span class="comment">         * 1 和Registry相关的Protocol，RegistryProtocol关注服务的注册</span></span><br><span class="line"><span class="comment">         * 2 具体协议，如 DubboProtocol、httpProtocol等,关注服务的暴露和引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String protocolName : loader.getLoadedExtensions()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Protocol protocol = loader.getLoadedExtension(protocolName);</span><br><span class="line">                <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    protocol.destroy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e">DubboShutdownHook与protocol、registry的关系图 </font></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/shutdownhook-process.jpg" alt></p><p><font color="#c7254e"> 图解(以dubbo协议和zookeeper注册中心为例) <font></font></font></p><p><font color="#c7254e"> Registry相关 <font></font></font></p><ul><li>AbstractRegistryFactory#destroyAll方法，遍历所有的Registry并调用Registry#destroy方法。然后清空Registry缓存集合。</li><li>AbstractRegistry 实现了公用的销毁逻辑：取消注册和订阅。服务提供者和消费者都会执行注册和订阅，因此都需要进行取消。</li><li>FailbackRegistry实现销毁公用的重试任务</li><li>ZookeeperRegistry销毁其对应的客户端连接</li></ul><p><font color="#c7254e"> Protocol相关 <font></font></font></p><ul><li>AbstractProtocol#destroy方法，销毁协议对应的服务消费者拥有的Invoker， 销毁协议对应的服务提供者的所有Exporter。</li><li>DubboProtocol销毁所有通信 ExchangeClient 和 ExchangeServer</li></ul><p><strong>小结</strong></p><ul><li>dubbo2.6.3在spring环境中注册两个钩子的情况，ShutdownHookListener解决了并发执行问题</li><li>使用ShutdownHookListener也不能移除调dubbo注册的jvm钩子，因为不能保证应用中一定会注册spring的shutdown hook</li></ul><h4 id="2-7-x优雅停机"><a href="#2-7-x优雅停机" class="headerlink" title="2.7.x优雅停机"></a>2.7.x优雅停机</h4><p>从dubbo的2.6.3版本开始，解决了使用spring构建的dubbo可能发生优雅停机并发执行shutdown hook的问题。但是还是存在一个问题，那就是如果在spring环境下没有注册spring的jvm钩子，虽然没有大问题，但是还是有不完整的。dubbo2.7.x进行显示地注册spring的jvm钩子，并且移除dubbo的jvm钩子，解决了当前问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ApplicationContext&gt; CONTEXTS = <span class="keyword">new</span> ConcurrentHashSet&lt;ApplicationContext&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ApplicationListener SHUTDOWN_HOOK_LISTENER = <span class="keyword">new</span> ShutdownHookListener();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addApplicationContext</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        CONTEXTS.add(context);</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableApplicationContext) &#123;</span><br><span class="line">            <span class="comment">// 显示注册spring的jvm钩子</span></span><br><span class="line">            ((ConfigurableApplicationContext) context).registerShutdownHook();</span><br><span class="line">            <span class="comment">// 显示移除dubbo的jvm钩子</span></span><br><span class="line">            DubboShutdownHook.getDubboShutdownHook().unregister();</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactoryUtils.addApplicationListener(context, SHUTDOWN_HOOK_LISTENER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">                DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook();</span><br><span class="line">                shutdownHook.doDestroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>dubbo2.7.x优雅停机的实现，解决了spring环境下两个钩子并发的问题，并且显示注册spring的jvm钩子。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优雅停机并不是java中的概念，也不是只有dubbo框架进行了扩展实现，springboot、docker等都有涉及到优雅停机。dubbo中的优雅停机是不断优化的，2.5.x中的存在一定的问题，2.6.x在一般场景下是没有问题的，2.7.x是对之前版本的完善和优化。如果 ShutdownHook 不能生效，可以在需要的时机自行调用DubboShutdownHook.destroyAll()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;优雅停机仅存在于服务重启、下线这样的部署阶段，优雅停机是一个应用生命周期的一部分，它保障了应用的健壮性。dubbo是通过jdk的Shutdo
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="JDK" scheme="https://gentryhuang.com/tags/JDK/"/>
    
      <category term="Spring" scheme="https://gentryhuang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 本地服务导出</title>
    <link href="https://gentryhuang.com/posts/c2df2fc6/"/>
    <id>https://gentryhuang.com/posts/c2df2fc6/</id>
    <published>2020-04-30T16:00:00.000Z</published>
    <updated>2020-09-14T15:33:18.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>理解 Dubbo 服务导出需要先理解 Dubbo SPI 、Dubbo 配置以及 Dubbo 的注册中心实现，有了这些准备，无论是 Dubbo 的本地导出和远程导出都简单了很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;理解 Dubbo 服务导出需要先理解 Dubbo SPI 、Dubbo 配置以及 Dubbo 的注册中心实现，有了这些准备，无论是 Dubb
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Redis注册中心</title>
    <link href="https://gentryhuang.com/posts/b2453481/"/>
    <id>https://gentryhuang.com/posts/b2453481/</id>
    <published>2020-04-25T16:00:00.000Z</published>
    <updated>2020-09-29T13:02:04.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://gentryhuang.com/posts/dafcd048/">注册中心总览</a> 中介绍了 Dubbo 的注册中心抽象层，包括注册中心及其工厂。本篇文章将介绍 Dubbo 的 Redis 注册中心及其工厂。<br><br></p><p><img src="/posts/b2453481/dubbo-redis-registry.png" alt></p><p>UML 图中的 RedisRegistry 类中实现了 Redis 作为注册中心的逻辑，其中 Redis 的客户端使用的是 Jedis 。</p><h2 id="Dubbo-中的-Redis-注册中心"><a href="#Dubbo-中的-Redis-注册中心" class="headerlink" title="Dubbo 中的 Redis 注册中心"></a>Dubbo 中的 Redis 注册中心</h2><br><p><img src="/posts/b2453481/dubb-redis-meta.jpg" alt></p><p>Redis 注册中心也沿用了 Dubbo 抽象的 Root、Service、Type、URL 四层结构。在 Redis 中数据都是以键值对的形式保存的，并不能像 Zookeeper 一样直接实现树形目录结构。因此，Redis 使用了 <code>key/Map</code> 结构存储数据：</p><blockquote><p>主key：Root、Service、Type 组合成的值，即服务名和类型，对应图中 /dubbo/com.foo.BarService/providers<br>主key的值Map中的key：URL串，对应图中 dubbo://10.20.153.10:123/barService=13658…<br>主key的值Map中的value: 过期时间</p></blockquote><p>Zookeeper 是基于监听器来感知数据的变化，而 Redis 使用基于 Publish/Subscribe 事件通知数据变更：</p><blockquote><p>通过事件的值区分事件消息类型：register,unregister<br>普通消费者订阅指定的服务提供者的Key，只会收到指定服务的 register,unregister 事件<br>监控中心订阅 /dubbo/*，会收到所有服务的所有变更事件</p></blockquote><p>注意事项：</p><ul><li>当前 Dubbo 版本的 Redis注册中心只会发送两种事件，分别对应服务提供者、服务消费者、动态配置、路由配置的注册与反注册，发送这两个事件的通道Channel是由服务接口决定的。</li><li>服务实例的启动或关闭，会写入或删除对应的数据，并通过通道发布对应的 <code>register</code>，<code>unregister</code> 事件消息，从而保证实时性。</li><li>如果使用监控中心（会订阅/dubbo/*）,Redis 注册中心会定时调度触发清理逻辑，保证未正常关闭的服务实例的 URL 的删除，并发起对应的 <code>unregister</code> 事件消息，从而保证数据的最终一致性。</li><li>不使用 Redis 的自动过期机制，而是通过监控中心实现过期机制，因为 Redis 的key自动过期不存在相应的事件消息通知。</li></ul><br><p>选项</p><ul><li>可通过 &lt;dubbo:registry group=”dubbo” /&gt; 设置 redis 中 key 的前缀，缺省为 dubbo。</li><li>可通过 &lt;dubbo:registry cluster=”replicate” /&gt; 设置 redis 集群策略，缺省为 failover。failover: 只写入和读取任意一台，失败时重试另一台，需要服务器端自行配置数据同步，replicate: 在客户端同时写入所有服务器，只读取单台，服务器端不需要同步，注册中心集群增大，性能压力也会更大。</li></ul><h2 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h2><p>订阅与通知是注册中心非常重要的功能，使用 Redis 作为注册中心，其订阅与通知实现方式与 Zookeeper 不同。Redis 订阅通知机制使用的是 <code>过期机制</code> 和 <code>Publish/Subscribe</code> 机制。</p><h3 id="服务提供者启动"><a href="#服务提供者启动" class="headerlink" title="服务提供者启动"></a>服务提供者启动</h3><p>服务提供者启动时，首先会在 Redis 中创建约定的k-v键值对，然后在通道（Root + Service + Type）中发布一条 <code>register</code> 事件消息。接着服务提供者会订阅动态配置信息，也就是在订阅URL中设置 <code>category=configurators</code> 。但是需要说明的是，Redis 的订阅实现方式不同 Zookeeper ，Zookeeper 可以直接注册子节点监听器直接监听 <code>.../configurators</code> 下的子节点变化，并且首次订阅就可以返回全量数据。而 Redis 每次订阅并没有订阅详细的Channel，如 <code>/dubbo/com.foo.BarService/configurators</code>，而是统一订阅 <code>Root + Service + *</code>，如 <code>Channel:/dubbo/com.alibaba.dubbo.demo.DemoService/*</code> ,这样一来任何只要是 <code>Root + Service</code> 匹配到的通道有消息都可以被订阅通知对象感知到。除此以外，使用 Redis 作为注册中心进行首次订阅的时候，当前订阅URL的 <code>Root + Service</code> 没有对应的通知器时会为其创建通知器，这个通知器就是用来订阅通道的， 由于 Redis 没有像 Zookeeper 那样绑定监听器，因此首次订阅需要主动使用 Redis 客户端获取 <code>Root + Service</code> 下的所有分类即 <code>Type</code>，然后再根据每个具体的分类获取其对应的 <code>URL</code> 列表，最后就是 Dubbo 的通知逻辑了。</p><h3 id="服务消费者启动"><a href="#服务消费者启动" class="headerlink" title="服务消费者启动"></a>服务消费者启动</h3><p>服务消费者启动的流程和服务提供者几乎一致，不同的是，在 Redis 中创建的k-v队是消费者的，消费者订阅的信息除了动态配置信息，还包括服务提供者信息和路由信息。</p><h3 id="监控中心启动"><a href="#监控中心启动" class="headerlink" title="监控中心启动"></a>监控中心启动</h3><p>监控中心(dubbo-admin)启动的时候只会进行订阅，而且订阅的是所有服务信息，即订阅的通道为 <code>/dubbo/*</code>，也就是说它会订阅所有服务的 providers、consumers、configurators和routers。通过监控中心进行服务治理时，如 设置配置参数、设置路由规则、调整权重、设置黑白名单等才会涉及注册与反注册操作。当订阅的通道有数据变动时，就会触发回调操作。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="RedisRegistryFactory"><a href="#RedisRegistryFactory" class="headerlink" title="RedisRegistryFactory"></a>RedisRegistryFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRegistryFactory</span> <span class="keyword">extends</span> <span class="title">AbstractRegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册中心地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 RedisRegistry 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisRegistry(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedisRegistry 工厂比较简单，没有其它逻辑，仅仅创建了一个 RedisRegistry 对象。</p><h3 id="RedisRegistry"><a href="#RedisRegistry" class="headerlink" title="RedisRegistry"></a>RedisRegistry</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RedisRegistry<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_REDIS_PORT = <span class="number">6379</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认redis的key的根据节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_ROOT = <span class="string">"dubbo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis Key 延时过期执行器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService expireExecutor = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboRegistryExpireTimer"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis Key 延时过期任务的Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledFuture&lt;?&gt; expireFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JedisPool 集合</span></span><br><span class="line"><span class="comment">     * key: ip:port</span></span><br><span class="line"><span class="comment">     * value: JedisPool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, JedisPool&gt; jedisPools = <span class="keyword">new</span> ConcurrentHashMap&lt;String, JedisPool&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知器集合，用于Redis Publish/Subscribe机制中的订阅，本质是调用 Jedis的psubscribe方法进行订阅通道</span></span><br><span class="line"><span class="comment">     * key: Root + Service,例如： /dubbo/com.alibaba.dubbo.demo.DemoService</span></span><br><span class="line"><span class="comment">     * value: 通知器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Notifier&gt; notifiers = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Notifier&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连周期，单位：毫秒</span></span><br><span class="line"><span class="comment">     * 订阅发生Redis连接异常时，Notifier sleep，等待重连</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> reconnectPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期周期，单位：毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> expirePeriod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否使用了监控中心，使用了监控中心该属性会被设置 true</span></span><br><span class="line"><span class="comment">     * 用于判断脏数据，脏数据由监控中心删除&#123;<span class="doctag">@link</span> #clean(Jedis)&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> admin = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否复制模式，缺省是failover</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> replicate;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">RedisRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">        <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建 GenericObjectPoolConfig 对象</span></span><br><span class="line">        GenericObjectPoolConfig config = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">        <span class="comment">// 连接从pool中获取，使用前会被验证，通过ping命令检测</span></span><br><span class="line">        config.setTestOnBorrow(url.getParameter(<span class="string">"test.on.borrow"</span>, <span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">// 连接在被归还给pool前，会验证连接的有效性，通过ping命令来检测</span></span><br><span class="line">        config.setTestOnReturn(url.getParameter(<span class="string">"test.on.return"</span>, <span class="keyword">false</span>));</span><br><span class="line">        <span class="comment">// 打开空闲连接存活和回收，周期性检测</span></span><br><span class="line">        config.setTestWhileIdle(url.getParameter(<span class="string">"test.while.idle"</span>, <span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pool中最大的空闲连接数；达到后pool会开始回收空闲连接，直到空闲连接数达到Mindle个数。 主要避免空连接占用，资源浪费</span></span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"max.idle"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setMaxIdle(url.getParameter(<span class="string">"max.idle"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  pool中保持最小的空闲可用连接数，这部分不被回收。可防止流量增量时，连接创建不及时</span></span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"min.idle"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setMinIdle(url.getParameter(<span class="string">"min.idle"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pool可分配的连接数</span></span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"max.active"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setMaxTotal(url.getParameter(<span class="string">"max.active"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前pool可并发的最大连接数</span></span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"max.total"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setMaxTotal(url.getParameter(<span class="string">"max.total"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接的最大等待时间</span></span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"max.wait"</span>, url.getParameter(<span class="string">"timeout"</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setMaxWaitMillis(url.getParameter(<span class="string">"max.wait"</span>, url.getParameter(<span class="string">"timeout"</span>, <span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"num.tests.per.eviction.run"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setNumTestsPerEvictionRun(url.getParameter(<span class="string">"num.tests.per.eviction.run"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"time.between.eviction.runs.millis"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setTimeBetweenEvictionRunsMillis(url.getParameter(<span class="string">"time.between.eviction.runs.millis"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"min.evictable.idle.time.millis"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setMinEvictableIdleTimeMillis(url.getParameter(<span class="string">"min.evictable.idle.time.millis"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否复制模式</span></span><br><span class="line">        String cluster = url.getParameter(<span class="string">"cluster"</span>, <span class="string">"failover"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"failover"</span>.equals(cluster) &amp;&amp; !<span class="string">"replicate"</span>.equals(cluster)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported redis cluster: "</span> + cluster + <span class="string">". The redis cluster only supported failover or replicate."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        replicate = <span class="string">"replicate"</span>.equals(cluster);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析</span></span><br><span class="line">        List&lt;String&gt; addresses = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        addresses.add(url.getAddress());</span><br><span class="line">        <span class="comment">// ULR中设置了从库地址</span></span><br><span class="line">        String[] backups = url.getParameter(Constants.BACKUP_KEY, <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (backups != <span class="keyword">null</span> &amp;&amp; backups.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            addresses.addAll(Arrays.asList(backups));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建JedisPool对象</span></span><br><span class="line">        <span class="keyword">for</span> (String address : addresses) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = address.indexOf(<span class="string">':'</span>);</span><br><span class="line">            String host;</span><br><span class="line">            <span class="keyword">int</span> port;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                host = address.substring(<span class="number">0</span>, i);</span><br><span class="line">                port = Integer.parseInt(address.substring(i + <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                host = address;</span><br><span class="line">                port = DEFAULT_REDIS_PORT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.jedisPools.put(address, <span class="keyword">new</span> JedisPool(config, host, port,</span><br><span class="line">                    url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT), StringUtils.isEmpty(url.getPassword()) ? <span class="keyword">null</span> : url.getPassword(),</span><br><span class="line">                    url.getParameter(<span class="string">"db.index"</span>, <span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析重连周期</span></span><br><span class="line">        <span class="keyword">this</span>.reconnectPeriod = url.getParameter(Constants.REGISTRY_RECONNECT_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RECONNECT_PERIOD);</span><br><span class="line">        <span class="comment">// 获得Redis 根节点</span></span><br><span class="line">        String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">        <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">            group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!group.endsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">            group = group + Constants.PATH_SEPARATOR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = group;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析会话过期时间</span></span><br><span class="line">        <span class="keyword">this</span>.expirePeriod = url.getParameter(Constants.SESSION_TIMEOUT_KEY, Constants.DEFAULT_SESSION_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建实现Redis Key 过期机制的任务</span></span><br><span class="line">        <span class="keyword">this</span>.expireFuture = expireExecutor.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 延时过期时间</span></span><br><span class="line">                    deferExpired();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Defensive fault tolerance</span></span><br><span class="line">                    logger.error(<span class="string">"Unexpected exception occur at defer expire time, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, expirePeriod / <span class="number">2</span>, expirePeriod / <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedisRegistry 构造方法做了两件事，初始化 JedisPool 和 创建 Redis key的延迟过期的任务。初始化 JedisPool 没有什么好说的，主要是设置一些参数，下面我们来看 deferExpired 方法是怎么做到延时key过期的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 被Key过期机制执行器expireExecutor定时调用，用来延时过期时间.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deferExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">         JedisPool jedisPool = entry.getValue();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Jedis jedis = jedisPool.getResource();</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 循环已注册的URL集合</span></span><br><span class="line">                 <span class="keyword">for</span> (URL url : <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered())) &#123;</span><br><span class="line">                     <span class="comment">// 是否是动态节点，只有动态节点需要延长过期时间</span></span><br><span class="line">                     <span class="keyword">if</span> (url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                         <span class="comment">// 获得分类路径，如：/dubbo/com.foo.BarService/providers</span></span><br><span class="line">                         String key = toCategoryPath(url);</span><br><span class="line">                         <span class="comment">/**</span></span><br><span class="line"><span class="comment">                          * 1 写入Redis Map中，更新过期时间</span></span><br><span class="line"><span class="comment">                          * 2 注意，如果过期时间更新的时候返回值为1，说明key已经被删除了，这次算重新发布，因此需要在通道key 中发布 register 事件消息</span></span><br><span class="line"><span class="comment">                          */</span></span><br><span class="line">                         <span class="keyword">if</span> (jedis.hset(key, url.toFullString(), String.valueOf(System.currentTimeMillis() + expirePeriod)) == <span class="number">1</span>) &#123;</span><br><span class="line">                             <span class="comment">// 发布 register 事件</span></span><br><span class="line">                             jedis.publish(key, Constants.REGISTER);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 如果是监控中心（admin = true），就负责删除过期脏数据。admin默认为false,可能修改的地方在 doSubscribe 方法中</span></span><br><span class="line">                 <span class="keyword">if</span> (admin) &#123;</span><br><span class="line">                     clean(jedis);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 如果Redis集群策略为 failover，则操作一台Redis即可。</span></span><br><span class="line">                 <span class="keyword">if</span> (!replicate) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;<span class="comment">//  If the server side has synchronized data, just write a single machine</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 jedis.close();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">             logger.warn(<span class="string">"Failed to write provider heartbeat to redis registry. registry: "</span> + entry.getKey() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>服务的 key 写入Redis 后，需要周期性地刷新key过期时间，RedisRegistry 构造方法中启动了一个定时调度线程池，不断调用该方法延续key的过期时间。前面也说明了，Redis 的key自动过期不存在相应的事件通知（订阅者无法感知到key已经不存在），如果提供者宕机而非主动下线，则会造成没有发布 <code>unregister</code> 事件，这时订阅方是不知道服务已经下线的，此外，Redis 的 publish/subscribe 并不是绝对可靠的，如果 Redis 的集群策略设置为 <code>failover</code> 模式，消费者订阅了从节点，某一时刻主节点还没有完成数据同步给从节点就宕机了，那么消费者也是不知道服务已经下线的。因此，如果使用 Redis 作为注册中心，会依赖服务治理中心，使用了服务治理中心，Redis 注册中心就会定时触发清理逻辑，下面我们来看下 Redis 注册中心清理脏数据的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 监控中心负责清理过期脏数据</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获得所有的 Root + Service + Type</span></span><br><span class="line">       Set&lt;String&gt; keys = jedis.keys(root + Constants.ANY_VALUE);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; !keys.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">               <span class="comment">// 获得分类下的Map,key-&gt;URL,value-&gt;过期时间</span></span><br><span class="line">               Map&lt;String, String&gt; values = jedis.hgetAll(key);</span><br><span class="line">               <span class="keyword">if</span> (values != <span class="keyword">null</span> &amp;&amp; values.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">boolean</span> delete = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                   <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : values.entrySet()) &#123;</span><br><span class="line">                       <span class="comment">// 获取URL</span></span><br><span class="line">                       URL url = URL.valueOf(entry.getKey());</span><br><span class="line">                       <span class="comment">// 动态节点</span></span><br><span class="line">                       <span class="keyword">if</span> (url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                           <span class="comment">// 获取URL对应的过期时间</span></span><br><span class="line">                           <span class="keyword">long</span> expire = Long.parseLong(entry.getValue());</span><br><span class="line">                           <span class="comment">// 已经过期</span></span><br><span class="line">                           <span class="keyword">if</span> (expire &lt; now) &#123;</span><br><span class="line">                               jedis.hdel(key, entry.getKey());</span><br><span class="line">                               delete = <span class="keyword">true</span>;</span><br><span class="line">                               <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                                   logger.warn(<span class="string">"Delete expired key: "</span> + key + <span class="string">" -&gt; value: "</span> + entry.getKey() + <span class="string">", expire: "</span> + <span class="keyword">new</span> Date(expire) + <span class="string">", now: "</span> + <span class="keyword">new</span> Date(now));</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 若发生删除行为，说明存在URL过期了，需要向key通道发布 `unregister`事件</span></span><br><span class="line">                   <span class="keyword">if</span> (delete) &#123;</span><br><span class="line">                       jedis.publish(key, Constants.UNREGISTER);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>clean 方法主要做了两件事，把过期的key删除并在通道key中发布 <code>unregister</code> 事件，保证了未正常下线的服务信息的删除，从而保证数据的最终一致性。但这里还有一个问题没有解决，如果 Redis 的集群策略设置为 <code>failover</code> 模式，消费者订阅了从节点，某一时刻提供者下线了，主节点还没有完成数据同步给从节点就宕机了，那么消费者也是不知道服务已经下线的，那这样情况怎么解决呢？问题先抛出来。</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取分类路径 Root + Service + Type</span></span><br><span class="line">       String key = toCategoryPath(url);</span><br><span class="line">       <span class="comment">// 获得URL字符串作为Value</span></span><br><span class="line">       String value = url.toFullString();</span><br><span class="line">       <span class="comment">// 计算过期时间，这会作为Redis Map的值</span></span><br><span class="line">       String expire = String.valueOf(System.currentTimeMillis() + expirePeriod);</span><br><span class="line">       <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">       RpcException exception = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 向Redis注册</span></span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">           JedisPool jedisPool = entry.getValue();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Jedis jedis = jedisPool.getResource();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 写入Redis hash 中，注意，过期时间是作为Map的值。</span></span><br><span class="line">                   jedis.hset(key, value, expire);</span><br><span class="line">                   <span class="comment">// 发布Redis 注册事件。 key为通道， Constants.REGISTER-&gt;register为事件消息，订阅该通道的就会实时从Redis读取最新消息</span></span><br><span class="line">                   jedis.publish(key, Constants.REGISTER);</span><br><span class="line">                   success = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="comment">// 如果非replicate模式，只需要写入单台机器，结束循环。否则，就继续循环，向所有的Redis写入</span></span><br><span class="line">                   <span class="keyword">if</span> (!replicate) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   jedis.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               exception = <span class="keyword">new</span> RpcException(<span class="string">"Failed to register service to redis registry. registry: "</span> + entry.getKey() + <span class="string">", service: "</span> + url + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 处理异常</span></span><br><span class="line">       <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (success) &#123;</span><br><span class="line">               logger.warn(exception.getMessage(), exception);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> exception;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注册方法主要做了两件事，把信息写到 Redis 中，然后发布注册事件。这里注册不仅是服务提供者和消费者，还可能是动态配置，路由规则等。</p><h4 id="反注册"><a href="#反注册" class="headerlink" title="反注册"></a>反注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUnregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取分类路径 Root + Service + Type</span></span><br><span class="line">    String key = toCategoryPath(url);</span><br><span class="line">    <span class="comment">// 获得URL字符串作为Value</span></span><br><span class="line">    String value = url.toFullString();</span><br><span class="line">    RpcException exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">        JedisPool jedisPool = entry.getValue();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Jedis jedis = jedisPool.getResource();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 删除 Redis Map 建</span></span><br><span class="line">                jedis.hdel(key, value);</span><br><span class="line">                <span class="comment">// 发布Redis 取消注册事件 key为通道 ， Constants.UNREGISTER-&gt;unregister 为事件消息</span></span><br><span class="line">                jedis.publish(key, Constants.UNREGISTER);</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 如果非replicate模式，只需操作单台机器，因此结束循环。否则，就继续循环，向所有的Redis写入</span></span><br><span class="line">                <span class="keyword">if</span> (!replicate) &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//  If the server side has synchronized data, just write a single machine</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            exception = <span class="keyword">new</span> RpcException(<span class="string">"Failed to unregister service to redis registry. registry: "</span> + entry.getKey() + <span class="string">", service: "</span> + url + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            logger.warn(exception.getMessage(), exception);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反注册主要也做了两件事，从Redis 中删除数据，然后发布 unregister 为事件。当服务消费者或服务提供者关闭时，会调用该方法，取消注册，因为正常情况下，无需使用监控中心做脏数据删除的工作。同样，这里反注册不仅是服务提供者和消费者，还可能是动态配置，路由规则等。</p><h4 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得服务路径 Root + Service 如： /dubbo/com.alibaba.dubbo.demo.DemoService</span></span><br><span class="line">    String service = toServicePath(url);</span><br><span class="line">    <span class="comment">// 获得服务路径对应的通知器 Notifier 对象,不存在对应的通知器，则创建Notifier对象</span></span><br><span class="line">    Notifier notifier = notifiers.get(service);</span><br><span class="line">    <span class="keyword">if</span> (notifier == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  创建服务路径对应的通知器Notifier对象，即基于 Root + Service 开启订阅线程，如果服务很多，就意味着有很多此类线程，创建线程是消耗资源的，而且还是那种阻塞不释放的。</span></span><br><span class="line"><span class="comment">         *  说明：</span></span><br><span class="line"><span class="comment">         *  zk是直接调用客户端API绑定监听器实现订阅，redis是使用多个独立的订阅线程，使用pub/sub机制进行处理，因为redis的pub/sub是基于channel进行的长连接通信，因此每个服务只能使用单独的线程。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Notifier newNotifier = <span class="keyword">new</span> Notifier(service);</span><br><span class="line">        notifiers.putIfAbsent(service, newNotifier);</span><br><span class="line">        notifier = notifiers.get(service);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证并发的情况下，有且仅有一个启动</span></span><br><span class="line">        <span class="keyword">if</span> (notifier == newNotifier) &#123;</span><br><span class="line">            <span class="comment">// 启动线程（订阅了通道，有消息发布就会被通知订阅对象收到，然后进行后续的通知处理），需要注意：Jedis的订阅是阻塞的，因此需要开启线程，不然主线程会阻塞。</span></span><br><span class="line">            notifier.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    RpcException exception = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环 jedisPools,仅从一个Redis获取数据，然后进行通知，直到成功</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">        JedisPool jedisPool = entry.getValue();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Jedis jedis = jedisPool.getResource();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理 Root + * 的订阅，一般是监听中心的订阅</span></span><br><span class="line">                <span class="keyword">if</span> (service.endsWith(Constants.ANY_VALUE)) &#123;</span><br><span class="line">                    <span class="comment">// 标记admin = true,监控中心才会清理脏数据</span></span><br><span class="line">                    admin = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 调用Jedis#keys(pattern)方法根据`/dubbo/*` 通配符获得分类层集合。始终记住 Redis 作为注册中心时，key是分类，如： /dubbo/com.alibaba.dubbo.demo.DemoService/providers</span></span><br><span class="line">                    Set&lt;String&gt; keys = jedis.keys(service);</span><br><span class="line">                    <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; !keys.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// key: Root + Service  value: Root + Service + Type</span></span><br><span class="line">                        Map&lt;String, Set&lt;String&gt;&gt; serviceKeys = <span class="keyword">new</span> HashMap&lt;String, Set&lt;String&gt;&gt;();</span><br><span class="line">                        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                            <span class="comment">// 获取Root + Service，如：/dubbo/com.alibaba.dubbo.demo.DemoService</span></span><br><span class="line">                            String serviceKey = toServicePath(key);</span><br><span class="line">                            Set&lt;String&gt; sk = serviceKeys.get(serviceKey);</span><br><span class="line">                            <span class="keyword">if</span> (sk == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                sk = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">                                serviceKeys.put(serviceKey, sk);</span><br><span class="line">                            &#125;</span><br><span class="line">                            sk.add(key);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 循环serviceKeys</span></span><br><span class="line">                        <span class="keyword">for</span> (Set&lt;String&gt; sk : serviceKeys.values()) &#123;</span><br><span class="line">                            <span class="comment">// 通知监听器</span></span><br><span class="line">                            doNotify(jedis, sk, url, Arrays.asList(listener));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理指定 Root + Service 的订阅 </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 1 调用Jedis#keys(pattern)方法，获得所有分类，例如：/dubbo/com.alibaba.dubbo.demo.DemoService/providers</span></span><br><span class="line"><span class="comment">                     * 2 通知监听器</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    doNotify(jedis, jedis.keys(service + Constants.PATH_SEPARATOR + Constants.ANY_VALUE), url, Arrays.asList(listener));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 标记成功</span></span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// Just read one server's data</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Try the next server</span></span><br><span class="line">            exception = <span class="keyword">new</span> RpcException(<span class="string">"Failed to subscribe service from redis registry. registry: "</span> + entry.getKey() + <span class="string">", service: "</span> + url + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            logger.warn(exception.getMessage(), exception);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务提供者、服务消费者、和服务治理中心都会使用注册中心的订阅功能。在订阅时，如果是首次订阅，则会先创建一个 Notifier 通知器，它是一个线程类，以异步方式进行通道的订阅。在启动通知器的同时，主线程会继续往下执行，全量拉取注册中心上和本次订阅相关的数据信息。后续注册中心上的信息变更则通过通知器订阅的通道来实现，发生变更订阅器会收到。此外，这里有两个分支，第一个是处理监控中心的订阅即 <code>Root + *</code>，第二个是处理指定<code>Root + Service + *</code> 的订阅，如果是监控中心的订阅会开启脏数据的清理任务。有了订阅，下面我们来看通知器的实现。</p><h4 id="Notifier-通知器"><a href="#Notifier-通知器" class="headerlink" title="Notifier 通知器"></a>Notifier 通知器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知器类，是一个线程对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Notifier</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 服务名 Root + Service</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String service;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 需要忽略连接的次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger connectSkip = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 已经忽略连接的次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger connectSkiped = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 随机对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Jedis</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Jedis jedis;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是否首次</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是否运行中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 连接次数随机数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> connectRandom;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Notifier</span><span class="params">(String service)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">super</span>.setName(<span class="string">"DubboRedisSubscribe"</span>);</span><br><span class="line">            <span class="keyword">this</span>.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重置忽略连接的信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetSkip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 重置需要忽略连接的次数</span></span><br><span class="line">            connectSkip.set(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 重置已忽略次数和随机数</span></span><br><span class="line">            connectSkiped.set(<span class="number">0</span>);</span><br><span class="line">            connectRandom = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断是否忽略本次对Redis的连接</span></span><br><span class="line"><span class="comment">         * 原则是：连接失败的次数越多，每一轮加大需要忽略的总次数</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSkip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 获得需要忽略的连接数，如果超过10，则加上一个10以内的随机数</span></span><br><span class="line">            <span class="keyword">int</span> skip = connectSkip.get(); <span class="comment">// Growth of skipping times</span></span><br><span class="line">            <span class="keyword">if</span> (skip &gt;= <span class="number">10</span>) &#123; <span class="comment">// If the number of skipping times increases by more than 10, take the random number</span></span><br><span class="line">                <span class="keyword">if</span> (connectRandom == <span class="number">0</span>) &#123;</span><br><span class="line">                    connectRandom = random.nextInt(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                skip = <span class="number">10</span> + connectRandom;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自增忽略次数，若忽略次数不够，则继续忽略</span></span><br><span class="line">            <span class="keyword">if</span> (connectSkiped.getAndIncrement() &lt; skip) &#123; <span class="comment">// Check the number of skipping times</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 增加需要忽略的次数</span></span><br><span class="line">            connectSkip.incrementAndGet();</span><br><span class="line">            <span class="comment">// 重置已忽略次数和随机数</span></span><br><span class="line">            connectSkiped.set(<span class="number">0</span>);</span><br><span class="line">            connectRandom = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里的循环处理是为了避免网络等异常的发生，便于重新尝试连接redis 订阅channel</span></span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 是否跳过本次Redis连接 todo</span></span><br><span class="line">                    <span class="keyword">if</span> (!isSkip()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 循环连接池</span></span><br><span class="line">                            <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">                                JedisPool jedisPool = entry.getValue();</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                                    jedis = jedisPool.getResource();</span><br><span class="line">                                    <span class="keyword">try</span> &#123;</span><br><span class="line">                                        <span class="comment">// 如果是监控中心的订阅</span></span><br><span class="line">                                        <span class="keyword">if</span> (service.endsWith(Constants.ANY_VALUE)) &#123;</span><br><span class="line">                                            <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">                                                first = <span class="keyword">false</span>;</span><br><span class="line">                                                <span class="comment">// 获取分类集合</span></span><br><span class="line">                                                Set&lt;String&gt; keys = jedis.keys(service);</span><br><span class="line">                                                <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; !keys.isEmpty()) &#123;</span><br><span class="line">                                                    <span class="keyword">for</span> (String s : keys) &#123;</span><br><span class="line">                                                        doNotify(jedis, s);</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line"></span><br><span class="line">                                              <span class="comment">// 由于连接过程允许一定量的失败，调用该方法重置计数器</span></span><br><span class="line">                                                resetSkip();</span><br><span class="line">                                            &#125;</span><br><span class="line">                                          </span><br><span class="line">                                            <span class="comment">// 订阅给定模式的通道，当订阅的通道有发布消息时，NotifySub对象的回调方法就能接收到。需要注意的是，订阅方法是阻塞的。</span></span><br><span class="line">                                            jedis.psubscribe(<span class="keyword">new</span> NotifySub(jedisPool), service); <span class="comment">// blocking</span></span><br><span class="line"></span><br><span class="line">                                            <span class="comment">// 服务提供者或者消费者</span></span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                            <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">                                                first = <span class="keyword">false</span>;</span><br><span class="line">                                                doNotify(jedis, service);</span><br><span class="line">                                                <span class="comment">// 由于连接过程允许一定量的失败，调用该方法重置计数器</span></span><br><span class="line">                                                resetSkip();</span><br><span class="line">                                            &#125;</span><br><span class="line"></span><br><span class="line">                                            jedis.psubscribe(<span class="keyword">new</span> NotifySub(jedisPool), service + Constants.PATH_SEPARATOR + Constants.ANY_VALUE); <span class="comment">// blocking</span></span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                        jedis.close();</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Retry another server</span></span><br><span class="line"></span><br><span class="line">                                    logger.warn(<span class="string">"Failed to subscribe service from redis registry. registry: "</span> + entry.getKey() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                                    <span class="comment">// If you only have a single redis, you need to take a rest to avoid overtaking a lot of CPU resources</span></span><br><span class="line">                                    sleep(reconnectPeriod);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                            logger.error(t.getMessage(), t);</span><br><span class="line">                            sleep(reconnectPeriod);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 停止 Notifier，关闭redis订阅相关工作的关键。它是通过设置停止循环标识，以及关闭redis连接实现的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 设置停止标识</span></span><br><span class="line">                running = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 断开redis连接，它还会停止psubscribe的调用，从而间接中止订阅</span></span><br><span class="line">                jedis.disconnect();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知器是一个线程，它是 RedisRegistry的内部类，每一个服务（Root + Service）对应一个通知器，如果存在大量订阅请求并且订阅URL都不是同一个服务，那么就要创建大量的线程。不仅如此，由通知器类还可以发现其任务方法中调用了订阅方法 <code>jedis.psubscribe</code> ，这个方法是阻塞的。因此，使用 Redis 注册中心要考虑线程资源。目前为止，Redis 的发布我们已经知道了，主要在注册和反注册的方法中，如果使用了监控中心，还会在脏数据清理方法中。订阅接收对象依然没有出现，请注意，通知器并非是订阅器，但是通知器创建了订阅器 NotifySub，我们继续跟进该类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RedisRegistry 的内部类，继承 redis.clients.jedis.JedisPubSub 抽象类，它是个通知订阅实现类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifySub</span> <span class="keyword">extends</span> <span class="title">JedisPubSub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NotifySub</span><span class="params">(JedisPool jedisPool)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.jedisPool = jedisPool;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 订阅后的通知回调方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key 订阅的key，一般为类目，如：/dubbo/com.alibaba.dubbo.demo.DemoService/providers</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> msg 事件消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String key, String msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"redis event: "</span> + key + <span class="string">" = "</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 收到register/unregister事件，调用#doNotify方法，组装目标URL然后通知监听器，从而实现实时更新</span></span><br><span class="line">            <span class="keyword">if</span> (msg.equals(Constants.REGISTER) || msg.equals(Constants.UNREGISTER)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Jedis jedis = jedisPool.getResource();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 进行通知，这里不是真正意义上的通知</span></span><br><span class="line">                        doNotify(jedis, key);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        jedis.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// TODO Notification failure does not restore mechanism guarantee</span></span><br><span class="line">                    logger.error(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPMessage</span><span class="params">(String pattern, String key, String msg)</span> </span>&#123;</span><br><span class="line">            onMessage(key, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(String key, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPSubscribe</span><span class="params">(String pattern, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUnsubscribe</span><span class="params">(String key, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPUnsubscribe</span><span class="params">(String pattern, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NotifySub 继承 <code>redis.clients.jedis.JedisPubSub</code> 抽象类，这样它就具有了订阅的功能，它也是 RedisRegistry 的内部类。当 <code>jedis.psubscribe(JedisPubSub,channel)</code> 订阅了通道（支持通配符）后，一旦该通道有事件消息发布 NotifySub 的通知回调方法就会调用，就能拿到具体的通道和在通道中发布的事件消息。至此， Redis 注册中心的两大核心角色就有了，下面我们简单梳理下整个过程。</p><ol><li>服务提供者、消费者在启动过程会进行服务的注册和订阅</li></ol><blockquote><p>1 注册的过程会先把服务信息写入到Redis中，并且通过分类路径 ‘Root + Service + Type’ 这个通道发布注册事件消息 register<br>2 订阅的过程会先创建一个通知器线程并启动，这个通知器线程会订阅服务路径 ‘Root + Service + *’ 这个通道，订阅后就坐等该通道的事件消息，NotifySub 对象就是用来接收通道消息的。然后会主动从Redis注册中心拉取 服务路径 ‘Root + Service + *’ 下的所有分类。</p></blockquote><ol start="2"><li>有服务下线会进行反注册</li></ol><blockquote><p>1 反注册会先把服务信息从Redis中删除，并且通过分类路径 ‘Root + Service + Type’ 这个通道发布反注册事件消息 unregister<br>2 如果通知已经被订阅，那么NotifySub就会接收通道发来的 反注册事件消息 unregister</p></blockquote><ol start="3"><li>监控中心启动会订阅所有服务</li></ol><blockquote><p>订阅的过程会先创建一个通知器线程并启动，这个通知器线程会订阅服务路径 ‘Root + *’ 这个通道，订阅后就坐等该通道的事件消息。然后会从Redis注册中心拉取所有数据并分类存储在缓存中</p></blockquote><ol start="4"><li>监控中心进行服务治理</li></ol><blockquote><p>服务治理涉及到注册和反注册，如：创建提供者、设置动态配置、设置路由规则等，都会向对应的通道发送消息。这些都会触发 NotifySub 通知回调</p></blockquote><p>以上分析主要是针对 注册（反注册）和订阅的分析，我们还少了一步通知，前文订阅的过程会调用通知方法，下面我们就来分析 Redis 注册中心的通知是怎么做的。</p><h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>需要说明的是，Zookeeper 由于可以注册监听器进而直接拿到订阅关注的全量数据，但是 Redis 订阅后得到的通知结果并不是订阅关注的数据而是大Key，需要多做一步查询大Key对应的目标URL集合，即 使用 doNotify 方法将 Redis 中的数据接入到应用中，然后回调监听器的方法完成通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key   分类，NotifySub获取到的，例如： /dubbo/com.alibaba.dubbo.demo.DemoService/providers</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">(Jedis jedis, String key)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 调用getSubscribed()方法，获得所有 订阅 URL 的监听器集合</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed()).entrySet()) &#123;</span><br><span class="line">          doNotify(jedis, Arrays.asList(key), entry.getKey(), <span class="keyword">new</span> HashSet&lt;NotifyListener&gt;(entry.getValue()));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> jedis     Jedis</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> keys      分类数组 ，如 /dubbo/com.alibaba.dubbo.demo.DemoService/providers （首次会拉取某个Service层下的所有分类）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> url       订阅URL</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> listeners 订阅URL对应的监听器集合</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">(Jedis jedis, Collection&lt;String&gt; keys, URL url, Collection&lt;NotifyListener&gt; listeners)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (keys == <span class="keyword">null</span> || keys.isEmpty() || listeners == <span class="keyword">null</span> || listeners.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前时间</span></span><br><span class="line">      <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 目标URL集合</span></span><br><span class="line">      List&lt;URL&gt; result = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 获得订阅URL的分类，不同的角色关注不同的分类数据【zookeeper也是如此】</span></span><br><span class="line"><span class="comment">       * 1 服务提供者，关注configurators</span></span><br><span class="line"><span class="comment">       * 2 服务消费者，关注providers,configurators.routers</span></span><br><span class="line"><span class="comment">       * 3 监控中心关注所有</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      List&lt;String&gt; categories = Arrays.asList(url.getParameter(Constants.CATEGORY_KEY, <span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 订阅URL映射的服务接口名 ，Root + Service</span></span><br><span class="line">      String consumerService = url.getServiceInterface();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 循环分类数组，如： /dubbo/com.alibaba.dubbo.demo.DemoService/providers</span></span><br><span class="line">      <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (!Constants.ANY_VALUE.equals(consumerService)) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 获取分类对应的服务接口名 ，Root + Service</span></span><br><span class="line">              String prvoiderService = toServiceName(key);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 分离对应的服务接口名是否匹配订阅URL映射的服务接口名,不匹配直接返回，说明不是订阅URl关注的分类</span></span><br><span class="line">              <span class="keyword">if</span> (!prvoiderService.equals(consumerService)) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果订阅URL不关注该分类，则直接返回</span></span><br><span class="line">          String category = toCategoryName(key);</span><br><span class="line">          <span class="keyword">if</span> (!categories.contains(Constants.ANY_VALUE) &amp;&amp; !categories.contains(category)) &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">         </span><br><span class="line">          List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 获得分类下所有URL数组，如： /dubbo/com.alibaba.dubbo.demo.DemoService/providers 下的所有提供者URL及其过期时间</span></span><br><span class="line">          Map&lt;String, String&gt; values = jedis.hgetAll(key);</span><br><span class="line">          <span class="keyword">if</span> (values != <span class="keyword">null</span> &amp;&amp; values.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : values.entrySet()) &#123;</span><br><span class="line">                  URL u = URL.valueOf(entry.getKey());</span><br><span class="line">                  <span class="comment">// 过滤掉已过期的动态节点 [动态节点才可能会变化，把动态节点收集起来，去和原来的节点对比，看是否有变化，有变化就需要做些操作，如 服务重新暴露]</span></span><br><span class="line">                  <span class="keyword">if</span> (!u.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>) || Long.parseLong(entry.getValue()) &gt;= now) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">                          urls.add(u);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 若不存在匹配，则创建 `empty://` 的 URL</span></span><br><span class="line">          <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">              urls.add(url.setProtocol(Constants.EMPTY_PROTOCOL)</span><br><span class="line">                      .setAddress(Constants.ANYHOST_VALUE)</span><br><span class="line">                      .setPath(toServiceName(key))</span><br><span class="line">                      .addParameter(Constants.CATEGORY_KEY, category));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          result.addAll(urls);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">              logger.info(<span class="string">"redis notify: "</span> + key + <span class="string">" = "</span> + urls);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span> || result.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 回调父类的notify方法，进行通知，这里才是真正通知监听器的入口。接下来的流程和 Zookeeper 一致</span></span><br><span class="line">      <span class="keyword">for</span> (NotifyListener listener : listeners) &#123;</span><br><span class="line">          notify(url, listener, result);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法需要注意一个点，分类不一定能够匹配上订阅URL，因此需要过滤。造成原因就一个，Redis 是使用Root + Service 获取分类的，主动获取和订阅都是这样。该方法看着逻辑不少，不过主要做了三个工作：</p><ol><li>根据订阅URL选出匹配的分类，因为 Redis 是根据订阅URL的Root + Service 获取其下的所有分类，但是订阅URL中也许没有指定那么多，就是订阅URL的category参数的值。</li><li>选出匹配的分类后，获取分类下的URL集合，然后筛选出没有过期的URL。如果没有预期的URL，就创建一个 empty://… </li><li>回调NotifyListener，进行通知。如 服务重新暴露，服务目录更新等</li></ol><p>至此，Redis 注册中心的 注册（反注册）、订阅、通知分析完毕，值得一说的是 Redis 的取消订阅什么都没有做是个空方法，在ZookeeperRegistry的该方法中，是移除了对应的监听器，这里理论上 Redis 应该解除订阅，不过 Redis 把这个收尾操作放到了 destroy 方法中了，我们一起来看看这个收尾方法。</p><h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 父类关闭</span></span><br><span class="line">    <span class="keyword">super</span>.destroy();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 取消定时任务，过期时间不会更新</span></span><br><span class="line">        expireFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭通知器，依次调用 shutdown方法，停止订阅工作。</span></span><br><span class="line">        <span class="keyword">for</span> (Notifier notifier : notifiers.values()) &#123;</span><br><span class="line">            notifier.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭连接池</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">        JedisPool jedisPool = entry.getValue();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedisPool.destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to destroy the redis registry client. registry: "</span> + entry.getKey() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后优雅关闭过期扫描定时任务线程池，即 shutdown()..awaitTermination()的应用。</span></span><br><span class="line">    ExecutorUtil.gracefulShutdown(expireExecutor, expirePeriod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁方法主要做了以下工作：</p><ol><li>调用父类FailbackRegistry的 destroy 方法</li><li>取消延时key过期的任务</li><li>关闭通知器线程，停止订阅工作</li><li>关闭JedisPool，释放资源</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Redis 作为注册中心与 Zookeeper 作为注册的前置操作都是一样的，其核心是基于 Redis 的 Publish/Subscribe 。和 Zookeeper 相比较，Redis 功能实现会相对繁琐一些，并且其可靠性依赖于 Redis 本身的可靠性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/dafcd048/&quot;&gt;注册中心总览&lt;/a&gt; 中介绍了 Du
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Redis" scheme="https://gentryhuang.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Zookeeper客户端</title>
    <link href="https://gentryhuang.com/posts/817d6a19/"/>
    <id>https://gentryhuang.com/posts/817d6a19/</id>
    <published>2020-04-19T16:00:00.000Z</published>
    <updated>2020-09-29T17:03:02.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://gentryhuang.com/posts/f70c2f2e/">Dubbo源码分析 - Zookeeper注册中心</a> 中介绍的是 Dubbo 的 Zookeeper 注册中心实现，但是并没有涉及到 Zookeeper 客户端的操作，下面我们介绍 Zookeeper 在 Dubbo 框架中具体实现。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/posts/817d6a19/dubbo-zookeeper-client.png" alt></p><p>上图的 UML 描述了 Dubbo 封装的 Zookeeper 注册中心和 Zookeeper 相关实现的关系。</p><p>Dubbo 对 Zookeeper 客户端的封装是在 dubbo-remoting-zookeeper 模块中，该模块对 Zookeeper 客户端接口进行了抽象。</p><p><img src="/posts/817d6a19/dubb-zookeeper-module.jpg" alt></p><p>目前支持 ZkClient 和 Curator 两种 Zookeeper 客户端实现：</p><ul><li><p>Curator 实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">...</span> <span class="attr">client</span>=<span class="string">"curator"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>ZkClient 实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">...</span> <span class="attr">client</span>=<span class="string">"zkclient"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意:</strong>  </p><ul><li>在2.7.x的版本中已经移除了zkclient的实现,如果要使用zkclient客户端,需要显示配置。下面分析上图的 UML 中涉及的接口和实现类。</li><li>无论服务提供者还是消费者，或者服务治理中心，任何一个节点连接到 Zookeeper 注册中心都需要使用一个客户端。</li></ul><h2 id="ZookeeperTransporter"><a href="#ZookeeperTransporter" class="headerlink" title="ZookeeperTransporter"></a>ZookeeperTransporter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"curator"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ZookeeperTransporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接创建 ZookeeperClient 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册中心地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ZookeeperClient 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">ZookeeperClient <span class="title">connect</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口是 Dubbo 的扩展点，是 Zookeeper 客户端工厂，默认是使用 CuratorZookeeperTransporter 创建 ZookeeperClient ，后面会详细分析 ZookeeperClient 继承体系。</p><h2 id="StateListener"><a href="#StateListener" class="headerlink" title="StateListener"></a>StateListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StateListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已断开</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> DISCONNECTED = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> CONNECTED = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已重连</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> RECONNECTED = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态变更回调方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connected 状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> connected)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口不是真正意义上的监听器，它的实现是一个匿名内部类，在 ZookeeperRegistry 的构造方法中，作为 ZookeeperClient 的状态变化（会话）的回调，具体调用入口是 <code>AbstractZookeeperClient#stateChanged(int)</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter，由SPI确定具体的实例。创建好Zookeeper客户端，意味着注册中心的创建完成【Zookeeper服务端必需先启动，Dubbo应用作为Zookeeper的客户端进行连接，然后操作Zookeeper】</span></span><br><span class="line">        zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加 StateListener 状态监听器，该监听器在重连时，调用恢复方法 recover()，重新发起注册和订阅【将之前已经注册和订阅的数据进行重试】</span></span><br><span class="line"><span class="comment">         * 注意：</span></span><br><span class="line"><span class="comment">         *  StateListener 不是真正意义上的监听器，这里就是创建了一个匿名对象，其中的 #stateChanged 方法触发需要主动调用该匿名对象的该方法 &#123;<span class="doctag">@link</span> AbstractZookeeperClient#stateChanged(int)&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        zkClient.addStateListener(<span class="keyword">new</span> StateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (state == RECONNECTED) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        recover();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ChildListener"><a href="#ChildListener" class="headerlink" title="ChildListener"></a>ChildListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChildListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子节点发生变化的回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> children 最新的子节点列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">childChanged</span><span class="params">(String path, List&lt;String&gt; children)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口只是一个普通的接口，具体实现是一个匿名内部类，入口在 ZookeeperRegistry 实现类的 doSubscribe 方法中，该接口的对象最终会用于 Zookeeper 客户端的某个节点下子节点变化的回调方法中，下面我们再分析两种客户端的不同实现。</p><h2 id="ZookeeperClient"><a href="#ZookeeperClient" class="headerlink" title="ZookeeperClient"></a>ZookeeperClient</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ephemeral 是否临时节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(String path, <span class="keyword">boolean</span> ephemeral)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子节点路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加 ChildListener</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 子节点列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">addChildListener</span><span class="params">(String path, ChildListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除 ChildListener</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeChildListener</span><span class="params">(String path, ChildListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加 StateListener</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStateListener</span><span class="params">(StateListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除 StateListener</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStateListener</span><span class="params">(StateListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获得注册中心 URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZookeeperClient 接口是对 Zookeeper 客户端接口的抽象，定义了一系列的操作方法，它的具体子类中封装了 Zookeeper 的客户端对象。</p><h3 id="AbstractZookeeperClient"><a href="#AbstractZookeeperClient" class="headerlink" title="AbstractZookeeperClient"></a>AbstractZookeeperClient</h3><p>ZookeeperClient 接口的抽象类，主要实现了通用的逻辑，如，创建节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 ZookeeperClient 接口，Zookeeper 客户端抽象类，实现通用的逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;TargetChildListener&gt; 泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">TargetChildListener</span>&gt; <span class="keyword">implements</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractZookeeperClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心 URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StateListener 状态监听器集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;StateListener&gt; stateListeners = <span class="keyword">new</span> CopyOnWriteArraySet&lt;StateListener&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ChildListener 集合</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * key1：节点路径</span></span><br><span class="line"><span class="comment">     * key2：ChildListener 对象</span></span><br><span class="line"><span class="comment">     * value ：监听器具体对象，不同 Zookeeper 客户端，实现会不同。CuratorZookeeperClient的是CuratorWatcher;ZkclientZookeeperClient 的是 IZkChildListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConcurrentMap&lt;ChildListener, TargetChildListener&gt;&gt; childListeners = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;ChildListener, TargetChildListener&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractZookeeperClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该抽象类中的属性主要四个，其中 stateListeners 属性是当 Zookeeper的状态变化时要通知的对象，childListeners 属性比较关键，是节点路径到其子节点监听器的映射。</p><h3 id="create-创建节点"><a href="#create-创建节点" class="headerlink" title="create 创建节点"></a>create 创建节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">TargetChildListener</span>&gt; <span class="keyword">implements</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String path, <span class="keyword">boolean</span> ephemeral)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ephemeral) &#123;</span><br><span class="line">            <span class="comment">// 如果要创建的节点类型非临时节点，那么这里要检测节点是否存在。临时节点有序号，不需要考虑覆盖问题</span></span><br><span class="line">            <span class="keyword">if</span> (checkExists(path)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = path.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归创建上一级路径</span></span><br><span class="line">            create(path.substring(<span class="number">0</span>, i), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据 ephemeral 的值创建临时或持久节点</span></span><br><span class="line">        <span class="keyword">if</span> (ephemeral) &#123;</span><br><span class="line">            createEphemeral(path);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createPersistent(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StateListener-操作方法"><a href="#StateListener-操作方法" class="headerlink" title="StateListener 操作方法"></a>StateListener 操作方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">TargetChildListener</span>&gt; <span class="keyword">implements</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入 StateListener 到缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener StateListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStateListener</span><span class="params">(StateListener listener)</span> </span>&#123;</span><br><span class="line">        stateListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除缓存中的 StateListener</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeStateListener</span><span class="params">(StateListener listener)</span> </span>&#123;</span><br><span class="line">        stateListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存中的 StateListener </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;StateListener&gt; <span class="title">getSessionListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stateListeners;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历StateListener 数组，回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state 状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (StateListener sessionListener : getSessionListeners()) &#123;</span><br><span class="line">            sessionListener.stateChanged(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StateListener 操作方法很简单，需要注意的是 addStateListener 和 stateChanged 方法，前者是在 ZookeeperRegistry 构造方法中被调用，前文已经说明。后者是当 Zookeeper 客户端的会话变化时会主动调用，下文会说明。</p><h3 id="addChildListener"><a href="#addChildListener" class="headerlink" title="addChildListener"></a>addChildListener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">TargetChildListener</span>&gt; <span class="keyword">implements</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path     订阅url 映射的目录，如 .../providers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 订阅url 映射的目录下子节点变化时执行回调的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addChildListener</span><span class="params">(String path, <span class="keyword">final</span> ChildListener listener)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取/创建：ConcurrentMap&lt;categorypath, ConcurrentMap&lt;ZookeeperRegistry的内部类ChildListener实例, TargetChildListener&gt;&gt; childListeners，这里主要是创建TargetChildListener</span></span><br><span class="line">        ConcurrentMap&lt;ChildListener, TargetChildListener&gt; listeners = childListeners.get(path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">            childListeners.putIfAbsent(path, <span class="keyword">new</span> ConcurrentHashMap&lt;ChildListener, TargetChildListener&gt;());</span><br><span class="line">            listeners = childListeners.get(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得是否已经有该监听器</span></span><br><span class="line">        TargetChildListener targetListener = listeners.get(listener);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// zk监听器对象不存在，进行创建</span></span><br><span class="line">        <span class="keyword">if</span> (targetListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1 创建一个监听path下子节点的watcher【CuratorZookeeperClient实现】或 IZkChildListener 【ZkclientZookeeperClient实现】</span></span><br><span class="line"><span class="comment">             * 2 当path下有子节点变化时，调用listener（即传入的ZookeeperRegistry的内部类ChildListener实例的childChanged(String parentPath, List&lt;String&gt; currentChilds)方法）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            listeners.putIfAbsent(listener, createTargetChildListener(path, listener));</span><br><span class="line">            targetListener = listeners.get(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向 Zookeeper ，真正发起订阅，即为 path添加TargetChildListener监听器实例</span></span><br><span class="line">        <span class="keyword">return</span> addTargetChildListener(path, targetListener);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的核心就是为订阅 URL 映射的节点绑定一个子节点监听器，子节点发生变化时会被子节点监听器捕捉到，然后将变化的数据信息通过 ChildListener 匿名对象的方法传递出去，下面会结合具体的 Zookeeper 客户端说明。</p><h3 id="removeChildListener"><a href="#removeChildListener" class="headerlink" title="removeChildListener"></a>removeChildListener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">TargetChildListener</span>&gt; <span class="keyword">implements</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeChildListener</span><span class="params">(String path, ChildListener listener)</span> </span>&#123;</span><br><span class="line">        ConcurrentMap&lt;ChildListener, TargetChildListener&gt; listeners = childListeners.get(path);</span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TargetChildListener targetListener = listeners.remove(listener);</span><br><span class="line">            <span class="keyword">if</span> (targetListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 向 Zookeeper ，真正发起取消订阅</span></span><br><span class="line">                removeTargetChildListener(path, targetListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用于解除 path 目录的子节点变化监听器。</p><h3 id="目录的子节点变化监听器操作"><a href="#目录的子节点变化监听器操作" class="headerlink" title="目录的子节点变化监听器操作"></a>目录的子节点变化监听器操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">TargetChildListener</span>&gt; <span class="keyword">implements</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 抽象方法，创建真正的 ChildListener 对象。因为，每个 Zookeeper 的库，实现不同。</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> TargetChildListener <span class="title">createTargetChildListener</span><span class="params">(String path, ChildListener listener)</span></span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 向 Zookeeper ，真正发起订阅</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;String&gt; <span class="title">addTargetChildListener</span><span class="params">(String path, TargetChildListener listener)</span></span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 向 Zookeeper ，真正发起取消订阅</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeTargetChildListener</span><span class="params">(String path, TargetChildListener listener)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三个方法是用来对 path 目录下的子节点的监听器进行操作的，具体逻辑交给子类实现。下面我们详细分析 AbstractZookeeperClient 的两个具体实现类。</p><h3 id="CuratorZookeeperClient"><a href="#CuratorZookeeperClient" class="headerlink" title="CuratorZookeeperClient"></a>CuratorZookeeperClient</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">CuratorWatcher</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Zookeeper 的 Curator 客户端对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CuratorZookeeperClient 构造方法主要用于创建和启动 CuratorFramework 实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CuratorZookeeperClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 CuratorFramework 构造器</span></span><br><span class="line">            CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()</span><br><span class="line">                    <span class="comment">// 连接地址</span></span><br><span class="line">                    .connectString(url.getBackupAddress())</span><br><span class="line">                    <span class="comment">// 重试策略: 重试次数：1，每次重试间隔： 1000 ms</span></span><br><span class="line">                    .retryPolicy(<span class="keyword">new</span> RetryNTimes(<span class="number">1</span>, <span class="number">1000</span>))</span><br><span class="line">                    <span class="comment">// 连接超时时间</span></span><br><span class="line">                    .connectionTimeoutMs(<span class="number">5000</span>);</span><br><span class="line">            String authority = url.getAuthority();</span><br><span class="line">            <span class="keyword">if</span> (authority != <span class="keyword">null</span> &amp;&amp; authority.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                builder = builder.authorization(<span class="string">"digest"</span>, authority.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 构建 CuratorFramework 实例</span></span><br><span class="line">            client = builder.build();</span><br><span class="line">            <span class="comment">// 添加连接监听器。在连接状态发生变化时，调用#stateChange(state)方法，进行StateListener的回调</span></span><br><span class="line">            client.getConnectionStateListenable().addListener(<span class="keyword">new</span> ConnectionStateListener() &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 在连接状态发生变化时，调用 #stateChange(state) 方法，进行 StateListener 的回调。</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState state)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (state == ConnectionState.LOST) &#123;</span><br><span class="line">                        CuratorZookeeperClient.<span class="keyword">this</span>.stateChanged(StateListener.DISCONNECTED);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == ConnectionState.CONNECTED) &#123;</span><br><span class="line">                        CuratorZookeeperClient.<span class="keyword">this</span>.stateChanged(StateListener.CONNECTED);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == ConnectionState.RECONNECTED) &#123;</span><br><span class="line">                        CuratorZookeeperClient.<span class="keyword">this</span>.stateChanged(StateListener.RECONNECTED);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 启动客户端 (当连接不上zk服务时，默认将一直重试)</span></span><br><span class="line">            client.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 CuratorZookeeperClient 的属性中，可以得到上文中的一个答案，stateChanged 方法调用的入口，CuratorZookeeperClient 构造方法执行完毕，Zookeeper 的 Curator 客户端连接创建完毕。</p><h4 id="操作节点方法"><a href="#操作节点方法" class="headerlink" title="操作节点方法"></a>操作节点方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">CuratorWatcher</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 path 持久节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPersistent</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.create().forPath(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NodeExistsException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 path 临时节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEphemeral</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.create().withMode(CreateMode.EPHEMERAL).forPath(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NodeExistsException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 path 节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.delete().forPath(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoNodeException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 path 节点下的子节点列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> client.getChildren().forPath(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoNodeException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查 path 节点是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkExists</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (client.checkExists().forPath(path) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接是否已经关闭</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getZookeeperClient().isConnected();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CuratorZookeeperClient 中的操作节点的方法很简单，直接调用 Curator 的 API 即可。</p><h4 id="子节点监听器"><a href="#子节点监听器" class="headerlink" title="子节点监听器"></a>子节点监听器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">CuratorWatcher</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个监听path子节点的watcher 注意：这里只是创建一个CuratorWatcher监听器，并没有对节点进行绑定</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorWatcher <span class="title">createTargetChildListener</span><span class="params">(String path, ChildListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CuratorWatcherImpl(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为path节点绑定CuratorWatcher监听器，并返回path的子路径列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addTargetChildListener</span><span class="params">(String path, CuratorWatcher listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> client.getChildren().usingWatcher(listener).forPath(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoNodeException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTargetChildListener</span><span class="params">(String path, CuratorWatcher listener)</span> </span>&#123;</span><br><span class="line">        ((CuratorWatcherImpl) listener).unwatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现CuratorWatcher接口，实现监听器功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorWatcherImpl</span> <span class="keyword">implements</span> <span class="title">CuratorWatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ChildListener 匿名对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> ChildListener listener;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CuratorWatcherImpl</span><span class="params">(ChildListener listener)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.listener = listener;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unwatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.listener = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 当path节点下的子节点发生变化的时候，会首先调用TargetChildListener的process(WatchedEvent event)方法，</span></span><br><span class="line"><span class="comment">         * 2 在该方法中又会调用ChildListener实例的childChanged(String parentPath, List&lt;String&gt; currentChilds)方法</span></span><br><span class="line"><span class="comment">         * 3 配置信息还是通过客户端拉取</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String path = event.getPath() == <span class="keyword">null</span> ? <span class="string">""</span> : event.getPath();</span><br><span class="line">                <span class="comment">// 主动调用ChildListener 匿名对象的方法</span></span><br><span class="line">                listener.childChanged(path,</span><br><span class="line">                        <span class="comment">// if path is null, curator using watcher will throw NullPointerException.</span></span><br><span class="line">                        <span class="comment">// if client connect or disconnect to server, zookeeper will queue</span></span><br><span class="line">                        <span class="comment">// watched event(Watcher.Event.EventType.None, .., path = null).</span></span><br><span class="line">                        StringUtils.isNotEmpty(path)</span><br><span class="line">                                ? client.getChildren().usingWatcher(<span class="keyword">this</span>).forPath(path) <span class="comment">// 重新发起连接，并传入最新的子节点列表</span></span><br><span class="line">                                : Collections.&lt;String&gt;emptyList());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子节点监听器，核心是实现 CuratorWatcher 接口，实现监听器功能，当监听的节点下的子节点发生变化时，会在监听器的回调方法中主动调用 ChildListener 匿名对象的 childChanged 方法，这是 Dubbo 中订阅的核心点。</p><h3 id="ZkclientZookeeperClient"><a href="#ZkclientZookeeperClient" class="headerlink" title="ZkclientZookeeperClient"></a>ZkclientZookeeperClient</h3><p>ZkclientZookeeperClient 并没有直接封装 ZkClient 对象，而是通过 ZkClientWrapper 封装了 ZkClient 对象，我们先来分析 ZkClientWrapper。</p><h4 id="ZkClientWrapper"><a href="#ZkClientWrapper" class="headerlink" title="ZkClientWrapper"></a>ZkClientWrapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkClientWrapper</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(ZkClientWrapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Zookeeper 的 ZkClient 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ZkClient client;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> KeeperState state;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FutureTask</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListenableFutureTask&lt;ZkClient&gt; listenableFutureTask;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverAddr Zookeeper 服务端地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout    超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZkClientWrapper</span><span class="params">(<span class="keyword">final</span> String serverAddr, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        listenableFutureTask = ListenableFutureTask.create(<span class="keyword">new</span> Callable&lt;ZkClient&gt;() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 通过回调创建 Zookeeper 的 ZkClient 客户端</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ZkClient <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ZkClient(serverAddr, Integer.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Z ookeeper 的 ZkClient 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">            Thread connectThread = <span class="keyword">new</span> Thread(listenableFutureTask);</span><br><span class="line">            connectThread.setName(<span class="string">"DubboZkclientConnector"</span>);</span><br><span class="line">            connectThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            connectThread.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client = listenableFutureTask.get(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.error(<span class="string">"Timeout! zookeeper server can not be connected in : "</span> + timeout + <span class="string">"ms!"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">"Zkclient has already been started!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置客户端监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(<span class="keyword">final</span> IZkStateListener listener)</span> </span>&#123;</span><br><span class="line">        listenableFutureTask.addListener(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    client = listenableFutureTask.get();</span><br><span class="line">                    client.subscribeStateChanges(listener);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    logger.warn(Thread.currentThread().getName() + <span class="string">" was interrupted unexpectedly, which may cause unpredictable exception!"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Got an exception when trying to create zkclient instance, can not connect to zookeeper server, please check!"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ZkClient 是否处理连接状态</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client != <span class="keyword">null</span> &amp;&amp; state == KeeperState.SyncConnected;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ZkClient AIP 创建持久节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPersistent</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        client.createPersistent(path, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ZkClient AIP 创建临时节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEphemeral</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        client.createEphemeral(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ZkClient AIP 删除节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        client.delete(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ZkClient AIP 获取 path 节点下的子节点列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        <span class="keyword">return</span> client.getChildren(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ZkClient AIP 判断是否存在 path 节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        <span class="keyword">return</span> client.exists(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开 Zookeeper 连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为 path 节点绑定其子节点的监听器，用于监听 path 节点下子节点的变化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">subscribeChildChanges</span><span class="params">(String path, <span class="keyword">final</span> IZkChildListener listener)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        <span class="keyword">return</span> client.subscribeChildChanges(path, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 path 节点的子节点监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribeChildChanges</span><span class="params">(String path, IZkChildListener listener)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        client.unsubscribeChildChanges(path, listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZkClientWrapper 用来创建 Zookeeper 的 ZkClient 客户端，并调用 ZkClient API 操作节点以及绑定监听器，代码已经详细注释。下面我们继续看 ZkclientZookeeperClient 实现类。</p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkclientZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">IZkChildListener</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装了 Zookeeper 的 ZkClient 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZkClientWrapper client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> KeeperState state = KeeperState.SyncConnected;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ZkclientZookeeperClient 构造方法主要用于创建和启动 ZkClient 实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZkclientZookeeperClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ZkClientWrapper 【包装了ZkClient,实现监听】</span></span><br><span class="line">        client = <span class="keyword">new</span> ZkClientWrapper(url.getBackupAddress(), <span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听器到 ZkClient 对象</span></span><br><span class="line">        client.addListener(<span class="keyword">new</span> IZkStateListener() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 处理状态变化</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStateChanged</span><span class="params">(KeeperState state)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ZkclientZookeeperClient.<span class="keyword">this</span>.state = state;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 状态变更进行回调 &#123;<span class="doctag">@link</span> StateListener#stateChanged(int)&#125;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (state == KeeperState.Disconnected) &#123;</span><br><span class="line">                    stateChanged(StateListener.DISCONNECTED);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == KeeperState.SyncConnected) &#123;</span><br><span class="line">                    stateChanged(StateListener.CONNECTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 处理新会话 （处理失败重连），最终会回调&#123;<span class="doctag">@link</span> StateListener#stateChanged(int)&#125;</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNewSession</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                stateChanged(StateListener.RECONNECTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client 属性对应的 ZkClientWrapper 中封装了 ZkClient 客户端对象，构造方法主要做了两件事，创建 ZkClient 并为其绑定状态监听器。</p><h4 id="操作节点方法-1"><a href="#操作节点方法-1" class="headerlink" title="操作节点方法"></a>操作节点方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkclientZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">IZkChildListener</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用 ZkClientWrapper 的 createPersistent 方法，以下同理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPersistent</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.createPersistent(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZkNodeExistsException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEphemeral</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.createEphemeral(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZkNodeExistsException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.delete(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZkNoNodeException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> client.getChildren(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZkNoNodeException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkExists</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> client.exists(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state == KeeperState.SyncConnected;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子节点监听器-1"><a href="#子节点监听器-1" class="headerlink" title="子节点监听器"></a>子节点监听器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkclientZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">IZkChildListener</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建节点监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IZkChildListener <span class="title">createTargetChildListener</span><span class="params">(String path, <span class="keyword">final</span> ChildListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IZkChildListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 监听的子节点发生变化会回调该方法，方法主动调用 ChildListener的匿名对象的方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> parentPath 父节点</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> currentChilds 子节点列表</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleChildChange</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                listener.childChanged(parentPath, currentChilds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为 path 节点绑定子节点监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener path的子节点监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addTargetChildListener</span><span class="params">(String path, <span class="keyword">final</span> IZkChildListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.subscribeChildChanges(path, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除 path 节点绑定的子节点监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener path的子节点监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTargetChildListener</span><span class="params">(String path, IZkChildListener listener)</span> </span>&#123;</span><br><span class="line">        client.unsubscribeChildChanges(path, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现上和 Curator 客户端有所差别，但本质上是相同的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Dubbo 中的 Zookeeper 客户端主要两部分操作，节点的操作和节点监听器的操作，节点的操作主要是注册服务的元数据信息，节点监听器的操作主要是用于订阅通知，订阅通知依赖服务节点的元数据变化信息，这正是监听器来完成的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/f70c2f2e/&quot;&gt;Dubbo源码分析 - Zookee
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Zookeeper注册中心</title>
    <link href="https://gentryhuang.com/posts/f70c2f2e/"/>
    <id>https://gentryhuang.com/posts/f70c2f2e/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-09-29T16:58:31.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://gentryhuang.com/posts/dafcd048/">注册中心总览</a> 中介绍了 Dubbo 的注册中心抽象层，包括注册中心及其工厂。本篇文章将介绍 Dubbo 的 Zookeeper 注册中心及其工厂。</p><p><img src="/posts/f70c2f2e/dubb-zookeeper.png" alt></p><p>UML 图中 <code>ZookeeperRegistryFactory</code> 中有个 <code>ZookeeperTransporter</code> 属性，该属性就是创建 Zookeeper 客户端的关键对象，下一篇文章会详细介绍 Dubbo 对 Zookeeper 客户端的封装。</p><h2 id="Dubbo-中的-Zookeeper-注册中心"><a href="#Dubbo-中的-Zookeeper-注册中心" class="headerlink" title="Dubbo 中的 Zookeeper 注册中心"></a>Dubbo 中的 Zookeeper 注册中心</h2><p>Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。下图是 Dubbo 使用 Zookeeper 作为注册中心的元数据信息：</p><p><img src="/posts/f70c2f2e/dubb-zookeeper-meta.jpg" alt></p><br><p><strong>Dubbo 中的 Zookeeper 注册中心说明</strong></p><p>Zookeeper 是树形结构的注册中心，每个节点的类型分为持久节点、持久顺序节点、临时节点和临时顺序节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">持久节点：服务注册后保证节点不会丢失，注册中心重启也会存在。</span><br><span class="line">持久顺序节点：在持久节点特性的基础上增加了节点先后顺序的特点。</span><br><span class="line">临时节点：节点注册后，如果客户端与服务端的连接断开或会话超时，节点会自动被删除。</span><br><span class="line">临时顺序节点：在临时节点特性的基础上增加了节点先后属性的特点。</span><br></pre></td></tr></table></figure><p>Dubbo 使用 Zookeeper 作为注册中心时，只会创建持久节点和临时节点，不关心节点的顺序。</p><p><strong>节点路径说明</strong></p><ul><li>Root 层：Zookeeper的根目录，默认是 dubbo ，也可以进行设置。对应图中的dubbo。</li><li>Service 层：服务接口的全路径名，对应图中的 <em>com.foo.BarService</em> 。</li><li>Type 层：目录，对于 Dubbo 而言就是分类，目前 Dubbo 有四个分类，服务提供者列表（providers）、服务消费者列表（consumers）、路由规则列表（routers）和 配置规则列表(configurators)</li><li>URL 层：Dubbo 的 URL，可以是服务提供者 URL、服务消费者 URL、路由规则 URL、以及配置规则 URL，具体哪类，看在哪个 Type 层下。</li></ul><p>注意，URL 层的元数据信息是临时节点，其上层的节点是持久节点。</p><p><strong>树形结构的关系</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dubbo</span><br><span class="line">  +-- service</span><br><span class="line">    +-- providers</span><br><span class="line">    +-- consumers</span><br><span class="line">    +-- routers</span><br><span class="line">    +-- configurators</span><br></pre></td></tr></table></figure><ul><li>树的根节点默认是dubbo，下面有多个服务接口，根节点可以手动设置。</li><li>服务接口下包含四种子目录，分别是 providers、consumers、routers、configurators，这些路径是持久节点。</li><li>服务提供者目录[/dubbo/service/providers]下面包含的接口有多个服务提供者URL元数据信息</li><li>服务消费者目录[/dubbo/service/consumers]下面包含的接口有多个消费者URL元数据信息</li><li>路由规则目录[/dubbo/service/routers]下面包含多个用于消费者路由策略URL元数据信息</li><li>动态配置目录[/dubbo/service/configurators]下面包含多个用于服务提供者动态配置URL元数据信息</li></ul><p>在 Dubbo 框架启动启动时，会根据用户配置的服务，在 Zookeeper 注册中心中创建4个目录，这里说的 Dubbo 框架启动包括提供者和消费者启动。</p><p><strong>流程简单说明：</strong></p><ul><li>服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址</li><li>服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址</li><li>监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址</li></ul><p><font color="#c7254e">注意:</font> 上面描述的并不是完整的流程，只是根据图进行简单说明，比如，服务提供者不仅写入了自己的 URL 地址，还订阅了 <strong>configurators</strong> 目录下的 URL 地址，消费者除了订阅 <strong>providers</strong> 目录下的 URL 地址，还订阅了 <strong>routers</strong> 和 <strong>configurators</strong> 目录下的 URL 地址。 在 Dubbo 框架进行服务调用时，用户可以通过服务治理平台在运行时改变服务参数，服务端会通过订阅机制决定是否需要重新暴露服务，消费端通过订阅机制决定是否更新服务目录等。</p><p><strong>支持但不限于以下功能：</strong></p><ul><li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息</li><li>当注册中心重启时，能自动恢复注册数据，以及订阅请求</li><li>当会话过期时，能自动恢复注册数据，以及订阅请求</li><li>当设置 &lt;dubbo:registry check=”false” /&gt; 时，记录失败注册和订阅请求，后台定时重试</li><li>可通过 &lt;dubbo:registry username=”admin” password=”1234” /&gt; 设置 zookeeper 登录信息</li><li>可通过 &lt;dubbo:registry group=”dubbo” /&gt; 设置 zookeeper 的根节点，不配置将使用默认的根节点。</li><li>支持 * 号通配符 &lt;dubbo:reference group=”*” version=”*” /&gt;，可订阅服务的所有分组和所有版本的提供者</li></ul><h2 id="ZookeeperRegistryFactory"><a href="#ZookeeperRegistryFactory" class="headerlink" title="ZookeeperRegistryFactory"></a>ZookeeperRegistryFactory</h2><p>实现 AbstractRegistryFactory 抽象类，ZookeeperRegistry 的工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistryFactory</span> <span class="keyword">extends</span> <span class="title">AbstractRegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zookeeperTransporter 由 SPI 在运行时注入，类型为 ZookeeperTransporter$Adaptive。 是Zookeeper的客户端工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ZookeeperTransporter zookeeperTransporter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Zookeeper客户端 工厂，该方法通过Dubbo IOC 注入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zookeeperTransporter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZookeeperTransporter</span><span class="params">(ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zookeeperTransporter = zookeeperTransporter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ZookeeperRegistry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZookeeperRegistryFactory 就是用来创建 ZookeeperRegistry 对象的，而 ZookeeperRegistry 对象需要依赖创建 Zookeeper 客户端的 ZookeeperTransporter 对象，该对象是通过 Dubbo IOC 注入的，详细可参考 <a href="https://gentryhuang.com/posts/5d81f464/"> Dubbo SPI</a> 。 下面我们来看看 ZookeeperRegistry 的实现。</p><h2 id="ZookeeperRegistry"><a href="#ZookeeperRegistry" class="headerlink" title="ZookeeperRegistry"></a>ZookeeperRegistry</h2><p>该类继承抽象类 FailbackRegistry ，具有重试功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZookeeperRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ZookeeperRegistry<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Zookeeper 默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_ZOOKEEPER_PORT = <span class="number">2181</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 元数据写入Zookeeper上的根节点，默认值是 dubbo </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_ROOT = <span class="string">"dubbo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Zookeeper 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service 接口全名集合。该属性适合用于监控中心，订阅整个Service层，因为Service层是动态的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; anyServices = <span class="keyword">new</span> ConcurrentHashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听器集合，建立NotifyListener和ChildListener的映射关系，k1为订阅URL,k2为监听器,value为ChildListener【真正起作用的对象】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt; zkListeners = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Zookeeper 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZookeeperClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取组名，默认为 'dubbo'，url.parameters.group 参数值，即Zookeeper的根节点</span></span><br><span class="line">        String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">        <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">            <span class="comment">// 订正路径： group = "/" + group;</span></span><br><span class="line">            group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定根路径，以组名作为根路径</span></span><br><span class="line">        <span class="keyword">this</span>.root = group;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter，由SPI确定具体的实例。创建好Zookeeper客户端，意味着注册中心的创建完成【Zookeeper服务端必需先启动，Dubbo应用作为Zookeeper的客户端进行连接，然后操作Zookeeper】</span></span><br><span class="line">        zkClient = zookeeperTransporter.connect(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加 StateListener 状态监听器，该监听器在重连时，调用恢复方法 recover()，重新发起注册和订阅【将之前已经注册和订阅的数据进行重试】</span></span><br><span class="line"><span class="comment">         * 注意：</span></span><br><span class="line"><span class="comment">         *  StateListener 不是真正意义上的监听器，这里就是创建了一个匿名对象，其中的 #stateChanged 方法触发需要主动调用该匿名对象的该方法 &#123;<span class="doctag">@link</span> AbstractZookeeperClient#stateChanged(int)&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        zkClient.addStateListener(<span class="keyword">new</span> StateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (state == RECONNECTED) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        recover();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doRegister-注册"><a href="#doRegister-注册" class="headerlink" title="doRegister 注册"></a>doRegister 注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZookeeperRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用Zookeeper客户端创建服务节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1 通过 Zookeeper 客户端创建节点，节点路径由 toUrlPath 方法生成，路径格式如下: /$&#123;group&#125;/$&#123;serviceInterface&#125;/&#123;Type&#125;/$&#123;url&#125;</span></span><br><span class="line"><span class="comment">             * 比如： /dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F127.0.0.1......</span></span><br><span class="line"><span class="comment">             * 2 url.parameters.dynamic ,是否动态数据。若为false，该数据为持久数据，当注册方退出时，数据仍然保存在注册中心</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to register "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>该方法是实现了其父类 FailbackRegistry 的模版方法，使用 Zookeeper 客户端进行节点的创建。服务提供者和消费者都需要把自己注册到注册中心，服务提供者的注册是为了让消费者发现自己从而发起远程调用。也让治理中心感知有新的服务提供者上线。消费者的发布是为了让服务治理中心发现自己。</p><h3 id="doUnregister-取消注册"><a href="#doUnregister-取消注册" class="headerlink" title="doUnregister 取消注册"></a>doUnregister 取消注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZookeeperRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 取消注册，删除节点</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUnregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             zkClient.delete(toUrlPath(url));</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to unregister "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>该方法是实现了其父类 FailbackRegistry 的模版方法，使用 Zookeeper 客户端进行节点的删除。</p><h3 id="doSubscribe-订阅"><a href="#doSubscribe-订阅" class="headerlink" title="doSubscribe 订阅"></a>doSubscribe 订阅</h3><p>订阅通常有 pull 和 push 两种方式，一种是客户端定时轮询注册中心拉取配置，另一种是注册中心主动推送数据给客户端。目前 Dubbo 采用的是 <strong>第一次拉取方式，后续接收事件重新拉取数据</strong>。在服务暴露时，服务提供者会订阅 <code>configurators</code> 用于监听动态配置。在消费端启动时，消费者会订阅 <code>providers</code>,<code>routers</code> 和 <code>configurators</code> 这三个目录，用于分别监听服务提供者、路由规则和动态配置。Zookeeper 注册中心采用的是 <strong>事件通知 + 客户端拉取</strong> 的方式，第一次订阅时会把对应目录下的全量数据都拉取过来（客户端拉取），并在订阅的节点上注册监听器监听其子节点的变化。客户端与注册中心之间保持 TCP 长连接，后续每个订阅节点有任何数据变化（子节点变化也属于该节点变化）时，注册中心会根据监听器的回调主动通知客户端（事件通知），即子节点变化时监听器捕捉到事件后会回调它的方法，该回调方法会调用<code>childChanged</code>方法，而<code>childChanged</code>方法会把对应节点下的全量数据都拉取过来（客户端拉取）。使用 Zookeeper 作为注册中心，获取配置信息采用的都是客户端拉取的方式。</p><p>订阅有两种情况，一种是服务治理中心会处理所有Service层订阅，Service被设置成统配符，另一种是某一个Service层的订阅。</p><h4 id="服务治理中心订阅"><a href="#服务治理中心订阅" class="headerlink" title="服务治理中心订阅"></a>服务治理中心订阅</h4><p>服务治理中心订阅最终的处理还是会走某个Service层的订阅逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ----------------- 订阅所有Service层的节点，例如监控中心的订阅</span></span><br><span class="line">            <span class="keyword">if</span> (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; <span class="comment">// service 层是 *</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据节点</span></span><br><span class="line">                String root = toRootPath();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获的订阅的url 对应的监听器集合</span></span><br><span class="line">                ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不存在，进行创建</span></span><br><span class="line">                <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;());</span><br><span class="line">                    listeners = zkListeners.get(url);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ChildListener zkListener = listeners.get(listener);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不存在ChildListener 对象，进行创建ChildListener对象</span></span><br><span class="line">                <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    listeners.putIfAbsent(listener, <span class="keyword">new</span> ChildListener() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 节点变化回调，根节点下的子节点有变化就回调。</span></span><br><span class="line"><span class="comment">                         * <span class="doctag">@param</span> parentPath 根节点</span></span><br><span class="line"><span class="comment">                         * <span class="doctag">@param</span> currentChilds 根节点下的 service 层节点列表</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childChanged</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 遍历子节点列表</span></span><br><span class="line">                            <span class="keyword">for</span> (String child : currentChilds) &#123;</span><br><span class="line">                                <span class="comment">// 解码</span></span><br><span class="line">                                child = URL.decode(child);</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 如果存在子节点还未被订阅，则说明是新的节点，则发起该Service层的订阅，走另一个分支</span></span><br><span class="line">                                <span class="keyword">if</span> (!anyServices.contains(child)) &#123;</span><br><span class="line">                                    anyServices.add(child);</span><br><span class="line">                                    <span class="comment">// 处理 service 订阅</span></span><br><span class="line">                                    subscribe(url.setPath(child).addParameters(Constants.INTERFACE_KEY, child, Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), listener);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    zkListener = listeners.get(listener);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建Service 节点，该节点为持久化节点</span></span><br><span class="line">                zkClient.create(root, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 向Zookeeper service节点发起订阅</span></span><br><span class="line">                List&lt;String&gt; services = zkClient.addChildListener(root, zkListener);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 首次全量数据获取完成时，发起某个Service 层的订阅，调用subscribe(url,listener)</span></span><br><span class="line">                <span class="keyword">if</span> (services != <span class="keyword">null</span> &amp;&amp; !services.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String service : services) &#123;</span><br><span class="line">                        service = URL.decode(service);</span><br><span class="line">                        anyServices.add(service);</span><br><span class="line">                        subscribe(url.setPath(service).addParameters(Constants.INTERFACE_KEY, service, Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), listener);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// $&#123;某个Service 层订阅&#125;</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该分支是订阅根节点下的所有Service层数据，当Service层发生变更时，若变更的有新增Service接口，即新增服务，则调用subscribe(url,listener)方法发起订阅，走处理指定Service层节点的逻辑。</p><h4 id="订阅指定Service层节点"><a href="#订阅指定Service层节点" class="headerlink" title="订阅指定Service层节点"></a>订阅指定Service层节点</h4><p>该方法会根据订阅 URL 中的 category 属性获取具体的分类，然后拉取该类别下的子节点的数据进行通知。</p><ul><li>如果是providers类别的数据，则订阅方（一般是消费者）会更新本地的服务目录。</li><li>如果是routers类别的数据，则订阅方会更新本地路由规则列表。</li><li>如果是configurators类别的数据，则订阅方会更新或覆盖本地动态参数列表。</li><li>如果是consumers类别的数据，则服务治理中心会更新缓存中的数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//----------------- 订阅所有Service层的节点，例如监控中心的订阅</span></span><br><span class="line">            <span class="keyword">if</span> (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; <span class="comment">// service 层是 *</span></span><br><span class="line">              <span class="comment">// $&#123;所有Service 层订阅&#125;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * ConcurrentMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt; zkListeners</span></span><br><span class="line"><span class="comment">                 * 1 根据url获取ConcurrentMap&lt;NotifyListener, ChildListener&gt;，没有就创建</span></span><br><span class="line"><span class="comment">                 * 2 根据listener从ConcurrentMap&lt;NotifyListener, ChildListener&gt;获取ChildListener，没有就创建</span></span><br><span class="line"><span class="comment">                 * 3 创建path持久化节点</span></span><br><span class="line"><span class="comment">                 * 4 创建path子节点监听器</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 子节点数据数组</span></span><br><span class="line">                List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环分类数组，其中，调用toCategoriesPath(url)方法，解析订阅url获得分类数组，如：/dubbo/com.alibaba.dubbo.demo.DemoService/configurators </span></span><br><span class="line">                <span class="keyword">for</span> (String path : toCategoriesPath(url)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获得分类路径（由订阅的url得到的） 对应的监听器映射</span></span><br><span class="line">                    ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 不存在，进行创建</span></span><br><span class="line">                    <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;());</span><br><span class="line">                        listeners = zkListeners.get(url);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 获得listener(NotifyListener)对应的ChildListener对象，没有就会创建。注意：ChildListener的childChanged方法实际上就是</span></span><br><span class="line"><span class="comment">                     * 当parentPath[即toCategoriesPath方法处理后的path]下的currentChilds发生变化时回调的方法，该方法内部又会回调NotifyListener#notify方法</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line"></span><br><span class="line">                    ChildListener zkListener = listeners.get(listener);</span><br><span class="line">                    <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listeners.putIfAbsent(listener, <span class="keyword">new</span> ChildListener() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childChanged</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span> </span>&#123; </span><br><span class="line">                                <span class="comment">// 变更时，调用 notity方法，回调 NotifyListener</span></span><br><span class="line">                                ZookeeperRegistry.<span class="keyword">this</span>.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        zkListener = listeners.get(listener);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 创建 Type 节点，该节点为持久节点，如： /dubbo/com.alibaba.dubbo.demo.DemoService/configurators</span></span><br><span class="line">                    zkClient.create(path, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 向Zookeeper path节点发起订阅，并返回该节点下的子路径</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 添加到urls 中</span></span><br><span class="line">                    <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        urls.addAll(toUrlsWithEmpty(url, path, children));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 首次全量数据获取完成时，调用NofityListener#notify(url,listener,currentChilds)方法，回调NotifyListener的逻辑</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                notify(url, listener, urls);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>订阅时涉及到的绑定监听器以及 ChildListener 匿名对象方法回调，会在下一章节 Zookeeper 客户端详细说明。订阅的核心是为指定的类目绑定监听器，该监听器用于监听类目下的子节点变化，发生变化则会调用 ChildListener 匿名对象方法，传递类目下变更后的子节点列表，有个这个新的子节点列表，就可以根据需要进行服务的重新暴露、服务目录重新生成等。</p><h3 id="doUnsubscribe-取消订阅"><a href="#doUnsubscribe-取消订阅" class="headerlink" title="doUnsubscribe 取消订阅"></a>doUnsubscribe 取消订阅</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZookeeperRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真正取消订阅的逻辑，删除对应的监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUnsubscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ChildListener zkListener = listeners.get(listener);</span><br><span class="line">            <span class="keyword">if</span> (zkListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">                    String root = toRootPath();</span><br><span class="line">                    zkClient.removeChildListener(root, zkListener);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String path : toCategoriesPath(url)) &#123;</span><br><span class="line">                        zkClient.removeChildListener(path, zkListener);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>该方法是实现了其父类 FailbackRegistry 的模版方法，使用 Zookeeper 客户端删除订阅 URL 对应的监听器。</p><h3 id="订阅时辅助方法"><a href="#订阅时辅助方法" class="headerlink" title="订阅时辅助方法"></a>订阅时辅助方法</h3><h4 id="获取Root层路径"><a href="#获取Root层路径" class="headerlink" title="获取Root层路径"></a>获取Root层路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获得根目录</span></span><br><span class="line"><span class="comment">   * root</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">toRootDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root.equals(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">          <span class="keyword">return</span> root;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> root + Constants.PATH_SEPARATOR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Root</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 根路径</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">toRootPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="获取Service层路径"><a href="#获取Service层路径" class="headerlink" title="获取Service层路径"></a>获取Service层路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获得服务路径 ， Root + service</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> String <span class="title">toServicePath</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       String name = url.getServiceInterface();</span><br><span class="line">       <span class="keyword">if</span> (Constants.ANY_VALUE.equals(name)) &#123;</span><br><span class="line">           <span class="keyword">return</span> toRootPath();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> toRootDir() + URL.encode(name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="获得分类路径"><a href="#获得分类路径" class="headerlink" title="获得分类路径"></a>获得分类路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得分类路径 如： 到 providers/consumers/routes/configurations 的路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分类路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">toCategoryPath</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toServicePath(url) + Constants.PATH_SEPARATOR + url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获得URL路径"><a href="#获得URL路径" class="headerlink" title="获得URL路径"></a>获得URL路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得URL 路径，即 要注册到注册中心上的完整路径</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Root + Service + Type + URL</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 被 &#123;<span class="doctag">@link</span> #doRegister(URL)&#125; 和 &#123;<span class="doctag">@link</span> #doUnregister(URL)&#125; 调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toUrlPath</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toCategoryPath(url) + Constants.PATH_SEPARATOR + URL.encode(url.toFullString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="URL匹配"><a href="#URL匹配" class="headerlink" title="URL匹配"></a>URL匹配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获得providers 中，和consumer 匹配的URL数组</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> consumer  订阅URL 如：provider://10.1.22.101:20880/com.alibaba.dubbo.demo.DemoService?key=value&amp;...</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> providers 订阅URL映射的路径的子路径集合</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 匹配的URL数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> List&lt;URL&gt; <span class="title">toUrlsWithoutEmpty</span><span class="params">(URL consumer, List&lt;String&gt; providers)</span> </span>&#123;</span><br><span class="line">     List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">     <span class="keyword">if</span> (providers != <span class="keyword">null</span> &amp;&amp; !providers.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 遍历子路径</span></span><br><span class="line">         <span class="keyword">for</span> (String provider : providers) &#123;</span><br><span class="line">             <span class="comment">// 解码</span></span><br><span class="line">             provider = URL.decode(provider);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 是URL的路径才会处理</span></span><br><span class="line">             <span class="keyword">if</span> (provider.contains(<span class="string">"://"</span>)) &#123;</span><br><span class="line">                 <span class="comment">// 将字符串转为URL</span></span><br><span class="line">                 URL url = URL.valueOf(provider);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 子路径URL是否匹配订阅URL，以关键属性进行匹配，如服务接口名、类目、服务group、服务version等</span></span><br><span class="line">                 <span class="keyword">if</span> (UrlUtils.isMatch(consumer, url)) &#123;</span><br><span class="line">                     urls.add(url);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> urls;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="筛选URL"><a href="#筛选URL" class="headerlink" title="筛选URL"></a>筛选URL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1 从providers中筛选和consumer匹配的URL集合</span></span><br><span class="line"><span class="comment">   * 2 如果URL集合不为空，直接返回这个集合</span></span><br><span class="line"><span class="comment">   * 3 如果URL集合为空，首先从path中获取category的值，然后将consumer的协议换成empty并添加参数category=path中的category的值。</span></span><br><span class="line"><span class="comment">   * 形式：'empty://' 的URL返回，通过这样的方式，可以处理类似服务提供者为空的情况</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> consumer  订阅URL 如：provider://10.1.22.101:20880/com.alibaba.dubbo.demo.DemoService?key=value&amp;...</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> path      订阅URL映射的路径 如：/dubbo/com.alibaba.dubbo.demo.DemoService/configurators</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> providers 订阅URL映射的路径的子路径集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> List&lt;URL&gt; <span class="title">toUrlsWithEmpty</span><span class="params">(URL consumer, String path, List&lt;String&gt; providers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从providers中筛选和consumer 匹配的URL数组</span></span><br><span class="line">      List&lt;URL&gt; urls = toUrlsWithoutEmpty(consumer, providers);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果不存在匹配的，则创建 'empty://' 的URL返回</span></span><br><span class="line">      <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">int</span> i = path.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">          String category = i &lt; <span class="number">0</span> ? path : path.substring(i + <span class="number">1</span>);</span><br><span class="line">          URL empty = consumer.setProtocol(Constants.EMPTY_PROTOCOL).addParameter(Constants.CATEGORY_KEY, category);</span><br><span class="line">          urls.add(empty);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> urls;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="获得Type层路径"><a href="#获得Type层路径" class="headerlink" title="获得Type层路径"></a>获得Type层路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获得分类路径数组</span></span><br><span class="line"><span class="comment">  * Root + Service + Type</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> url 订阅URL</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 分类路径数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String[] toCategoriesPath(URL url) &#123;</span><br><span class="line">     String[] categories;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果category的值为 * ，表示分别订阅：providers,consumers,routers,configurators</span></span><br><span class="line">     <span class="keyword">if</span> (Constants.ANY_VALUE.equals(url.getParameter(Constants.CATEGORY_KEY))) &#123;</span><br><span class="line">         categories = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                 Constants.PROVIDERS_CATEGORY,</span><br><span class="line">                 Constants.CONSUMERS_CATEGORY,</span><br><span class="line">                 Constants.ROUTERS_CATEGORY,</span><br><span class="line">                 Constants.CONFIGURATORS_CATEGORY</span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果category的值不为 * ，就取出 category的值，如果没有值，就把providers作为默认值。注意，当category的值不为空时会使用 ',' 分割category的值，为数组</span></span><br><span class="line">         categories = url.getParameter(Constants.CATEGORY_KEY, <span class="keyword">new</span> String[]&#123;Constants.DEFAULT_CATEGORY&#125;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获得分类路径数组</span></span><br><span class="line">     String[] paths = <span class="keyword">new</span> String[categories.length];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; categories.length; i++) &#123;</span><br><span class="line">         <span class="comment">// 构建分类路径</span></span><br><span class="line">         paths[i] = toServicePath(url) + Constants.PATH_SEPARATOR + categories[i];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> paths;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="销毁方法"><a href="#销毁方法" class="headerlink" title="销毁方法"></a>销毁方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZookeeperRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>.destroy();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 关闭 Zookeeper 客户端连接</span></span><br><span class="line">             zkClient.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             logger.warn(<span class="string">"Failed to close zookeeper client "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>重写了父类 FailbackRegistry 的销毁方法，使用 Zookeeper 客户端关闭会话，该方法会先调用父类的销毁方法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章主要介绍了 Dubbo 封装的 ZookeeperRegistry，该注册中心类将具体操作任务交给内部封装的 Zookeeper 客户端去完成，自己本身只是处理 Zookeeper 客户端操作前的逻辑，如调用父类方法、解析URL的所属类目等，其中创建 Zookeeper 客户端的直接入口就在该类的构造方法中。此外，该类中的一些方法没有分析到，它们和订阅与通知相关，会和订阅通知一起分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://gentryhuang.com/posts/dafcd048/&quot;&gt;注册中心总览&lt;/a&gt; 中介绍了 Dubb
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Zookeeper" scheme="https://gentryhuang.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 注册中心总览</title>
    <link href="https://gentryhuang.com/posts/dafcd048/"/>
    <id>https://gentryhuang.com/posts/dafcd048/</id>
    <published>2020-04-12T16:00:00.000Z</published>
    <updated>2020-09-29T15:15:46.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Dubbo 体系中，注册中心是核心组件之一。Dubbo 通过注册中心实现了分布式环境中各服务之间的注册与发现，是各个分布式节点之间的纽带。主要作用如下：</p><ol><li>动态加入。服务提供方通过注册中心记录自己的信息并动态地把自己暴露给其他消费者。</li><li>动态发现。一个消费者可以动态地感知新的配置、路由规则、新的服务，无需重新启动服务。</li><li>动态调整。注册中心支持参数的动态调整，新参数自动更新到相关服务节点。</li></ol><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>服务提供者启动时，会向注册中心写入自己的元数据信息，并订阅配置元数据信息。</li><li>消费者启动时，也会向注册中心写入自己的元数据信息，并订阅服务提供者、路由会配置元数据信息。</li><li>服务治理中心(dubbo-admin)启动时，会同时订阅所有服务提供者、服务消费者、路由和配置元数据信息。</li><li>服务提供者下线或新的服务提供者加入时，注册中心服务提供者目录会发生变化，变化信息会动态通知给消费者、服务治理中心。</li><li>消费方发起服务调用时，会异步将调用、统计信息等上报给监控中心。</li></ol><p>需要注意的是，Dubbo 中的注册中心总体流程相同，但是不同的注册中心有不同的实现方式，其数据结构也不相同。</p><h2 id="注册中心抽象API"><a href="#注册中心抽象API" class="headerlink" title="注册中心抽象API"></a>注册中心抽象API</h2><p>Dubbo服务暴露、服务引用以及服务调用等几乎都会使用到注册中心，这篇文章对Dubbo 的注册中心抽象API进行说明。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-registry-struct-outline.jpg" alt></p><p>上图是Dubbo的注册中心抽象API代码结构图，红框中的代码都是抽象API的基础代码，黄框是具体的注册中心抽象API。</p><h2 id="注册中心核心抽象API的UML"><a href="#注册中心核心抽象API的UML" class="headerlink" title="注册中心核心抽象API的UML"></a>注册中心核心抽象API的UML</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-registry-outline.png" alt></p><p>UML图非常清楚，注册中心核心抽象API中主要有三个角色，注册中心、注册中心工厂、注册中心的监听器。它们之间采用继承、组合、以及工厂的方式联系在一起，需要注意的是该图中的 <code>ZookeeperRegistry</code> 注册中心实现没有涉及到具体的客户端，关于 Dubbo 的 Zookeeper 客户端会单独写一篇文章进行详细说明。从UML图可以看出当前 Dubbo 版本支持四种注册中心的实现。Zookeeper 是官方推荐的注册中心，在生产环境中有过实际使用。Redis 注册中心并没有经过长时间运行的可靠性验证，其稳定性依赖 Redis 本身。Simple 注册中心是一个简单的基于内存的注册中心实现，它本身就是一个标准的PRC服务，不支持集群。Multicast 模块则不需要启动任何注册中心，只要通过广播地址，就可以互相发现，不推荐生产环境使用。下面分别介绍该UML图中涉及到的组件。</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取URL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> url.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否可用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> available.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 接口是一个顶级接口，Dubbo 中的核心组件几乎都继承该接口，只封装了三个和节点相关的方法。</p><h2 id="RegistryService"><a href="#RegistryService" class="headerlink" title="RegistryService"></a>RegistryService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册数据，如：提供者地址，消费者地址，路由规则，覆盖规则等数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin          </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  取消注册数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅符合条件的已注册数据，当有注册数据变更时自动推送。在 URL的category 属性上，表示订阅的数据分类。目前有四种类型：</span></span><br><span class="line"><span class="comment">     * 1 consumers 服务消费者列表</span></span><br><span class="line"><span class="comment">     * 2 providers 服务提供者列表</span></span><br><span class="line"><span class="comment">     * 3 routers 路由规则列表</span></span><br><span class="line"><span class="comment">     * 4 configurations 配置规则列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener A listener of the change event, not allowed to be empty</span></span><br><span class="line"><span class="comment">     *                </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  取消订阅</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener A listener of the change event, not allowed to be empty</span></span><br><span class="line"><span class="comment">     *                </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询符合条件的已注册数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url Query condition, is not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The registered information list, which may be empty, the meaning is the same as the parameters of &#123;<span class="doctag">@link</span> com.alibaba.dubbo.registry.NotifyListener#notify(List&lt;URL&gt;)&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.registry.NotifyListener#notify(List)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;URL&gt; <span class="title">lookup</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RegistryService 接口也是一个顶级接口，是注册中心服务接口，定义了节点的注册/反注册、订阅/反订阅以及查询三种操作方法。Dubbo 在上层进行了抽象，具体的实现细节交给不同的注册中心。</p><h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registry. (SPI, Prototype, ThreadSafe)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.registry.RegistryFactory#getRegistry(com.alibaba.dubbo.common.URL)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.registry.support.AbstractRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Registry</span> <span class="keyword">extends</span> <span class="title">Node</span>, <span class="title">RegistryService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册中心接口，该接口中没有定义方法只是继承了 Node 和 RegistryService 接口，因此具备了注册、订阅、查询等操作，注册中心具体实现都要继承该接口。</p><h2 id="AbstractRegistry"><a href="#AbstractRegistry" class="headerlink" title="AbstractRegistry"></a>AbstractRegistry</h2><p>Registry 的抽象类，实现了通用的注册、订阅、查询以及通知等方法。其中，实现了注册数据持久化到文件，该文件主要用于当消费者无法从注册中心拉取服务提供者列表信息时就从该文件中获取，支持了即使注册中心宕机消费者仍然可以和提供者通信。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log output</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// URL地址分割符，用于文件缓存中，分割URL</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> URL_SEPARATOR = <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// URL地址分隔正则表达式，用于解析文件缓存中URL列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL_SPLIT = <span class="string">"\\s+"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本地磁盘缓存</span></span><br><span class="line"><span class="comment">     * 1 其中特殊的 key值 .registries 记录注册中心列表， 其他的均为&#123;<span class="doctag">@link</span> #notified&#125; 服务提供者列表</span></span><br><span class="line"><span class="comment">     * 2 数据流向： 创建注册中心实例时从file读取数据到 properties中；监听到注册中心数据发生变更时，修改properties对应的值，并写入file</span></span><br><span class="line"><span class="comment">     * 3 数据的键-值对</span></span><br><span class="line"><span class="comment">     * （1）大多数情况下，键为订阅者的服务键 &#123;<span class="doctag">@link</span> URL#getServiceKey()&#125;,值为服务提供者列表/路由规则列表/配置规则列表</span></span><br><span class="line"><span class="comment">     * （2）特殊情况下是 .registries</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// Local disk cache, where the special key value.registies records the list of registry centers, and the others are the list of notified service providers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心数据缓存线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService registryCacheExecutor = Executors.newFixedThreadPool(<span class="number">1</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboSaveRegistryCache"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * properties发生变更时，是否同步写入文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> syncSaveFile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据版本号 &#123;<span class="doctag">@link</span> #properties&#125;，用于并发处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastCacheChanged = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已注册 URL 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;URL&gt; registered = <span class="keyword">new</span> ConcurrentHashSet&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅 URL 的监听器集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; subscribed = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知的URL到监听器监听到数据变化后的 结果URL集合</span></span><br><span class="line"><span class="comment">     * key1: 订阅的URL，例如消费者的URL，和 &#123;<span class="doctag">@link</span> #subscribed&#125; 的键一致</span></span><br><span class="line"><span class="comment">     * key2: 分类，如： providers,consumers,routes,configurators。【一般是无consumers,因为消费者不会去订阅另外的消费者的列表</span></span><br><span class="line"><span class="comment">     * value: 新的URL集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt; notified = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心 URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> URL registryUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存数据的磁盘文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> File file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，每次创建注册中心都会同步磁盘文件数据到缓存中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        setUrl(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可以指定注册中心磁盘缓存文件，配置方式：</span></span><br><span class="line"><span class="comment">         * 1 使用file属性指定  &lt;dubbo:registry address="xxx" file="/opt/xxx"/&gt;</span></span><br><span class="line"><span class="comment">         * 2 使用save.file属性指定 &lt;dubbo:registry address="xxx" save.file="/opt/xxx"/&gt;</span></span><br><span class="line"><span class="comment">         * 3 不显示指定的话，使用默认值：System.getProperty("user.home") + "/.dubbo/dubbo-registry-" + 应用名 + "-" + url.getAddress() + ".cache"</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Start file save timer</span></span><br><span class="line">        syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 获得 file</span></span><br><span class="line">        String filename = url.getParameter(Constants.FILE_KEY, System.getProperty(<span class="string">"user.home"</span>) + <span class="string">"/.dubbo/dubbo-registry-"</span> + url.getParameter(Constants.APPLICATION_KEY) + <span class="string">"-"</span> + url.getAddress() + <span class="string">".cache"</span>);</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isNotEmpty(filename)) &#123;</span><br><span class="line">            file = <span class="keyword">new</span> File(filename);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists() &amp;&amp; file.getParentFile() != <span class="keyword">null</span> &amp;&amp; !file.getParentFile().exists()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!file.getParentFile().mkdirs()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid registry store file "</span> + file + <span class="string">", cause: Failed to create directory "</span> + file.getParentFile() + <span class="string">"!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.file = file;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载本地磁盘缓存文件到内存缓存，即 properties.load(in)，到properties属性中</span></span><br><span class="line">        loadProperties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知监听器，URL 变化结果 。 为什么构造方法要通知，zk连接都没有建立，监听器更没有注册，即 subscribed 里面还没有值</span></span><br><span class="line">        notify(url.getBackupUrls());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractRegistry 抽象类中的属性大致有四类，注册的URL、缓存数据相关的、订阅URL的监听器、通知URL对应的变更URL。其中构造方法会加载本地磁盘缓存文件到内存中。</p><h3 id="注册-反注册"><a href="#注册-反注册" class="headerlink" title="注册/反注册"></a>注册/反注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先添加到 registered 缓存中，进行状态的维护。再由子类 FailbackRegistry类 真正注册</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"register url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Register: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        registered.add(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先从 registered 缓存中移除，再由子类 FailbackRegistry 真正取消注册</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unregister url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Unregister: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        registered.remove(url);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractRegistry 抽象类中的注册和反注册方法只是操作缓存，真正的实现交给子类 FailbackRegistry 完成。</p><h3 id="订阅-反订阅"><a href="#订阅-反订阅" class="headerlink" title="订阅/反订阅"></a>订阅/反订阅</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先缓存到 subscribed 中，再通过子类 FailbackRegistry 具体执行订阅逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      订阅条件，不允许为空，如：consumer://10.10.10.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 变更事件监听器，不允许为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"subscribe url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"subscribe listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Subscribe: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 从ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; subscribed中获取key为url的集合Set&lt;NotifyListener&gt;</span></span><br><span class="line"><span class="comment">         * 2 如果该集合存在，直接将当前的NotifyListener实例存入该集合,如果集合不存在，先创建，之后放入subscribed中，并将当前的NotifyListener实例存入刚刚创建的集合</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;NotifyListener&gt; listeners = subscribed.get(url);</span><br><span class="line">        <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscribed.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashSet&lt;NotifyListener&gt;());</span><br><span class="line">            listeners = subscribed.get(url);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先从缓存中移除，再通过子类 FailbackRegistry 具体执行取消订阅的逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener A listener of the change event, not allowed to be empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unsubscribe url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unsubscribe listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Unsubscribe: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;NotifyListener&gt; listeners = subscribed.get(url);</span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listeners.remove(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractRegistry 抽象类中的订阅和反订阅方法只是操作缓存，真正的实现交给子类 FailbackRegistry 完成。</p><h3 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和注册中心断开，重连成功会调用该方法，恢复注册和订阅</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// register</span></span><br><span class="line">        Set&lt;URL&gt; recoverRegistered = <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered());</span><br><span class="line">        <span class="keyword">if</span> (!recoverRegistered.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Recover register url "</span> + recoverRegistered);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (URL url : recoverRegistered) &#123;</span><br><span class="line">                <span class="comment">// 放入缓存</span></span><br><span class="line">                register(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// subscribe</span></span><br><span class="line">        Map&lt;URL, Set&lt;NotifyListener&gt;&gt; recoverSubscribed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed());</span><br><span class="line">        <span class="keyword">if</span> (!recoverSubscribed.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Recover subscribe url "</span> + recoverSubscribed.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : recoverSubscribed.entrySet()) &#123;</span><br><span class="line">                URL url = entry.getKey();</span><br><span class="line">                <span class="keyword">for</span> (NotifyListener listener : entry.getValue()) &#123;</span><br><span class="line">                    subscribe(url, listener);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>AbstractRegistry 抽象类中的断线重连逻辑是，与注册中心断开后重新连接时会从缓存中取出已经注册的URL集合，然后放入缓存，订阅同理。</p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 订阅URL映射的节点对应的子节点发生变化时，通知监听器</span></span><br><span class="line"><span class="comment">    * @param url      订阅URL</span></span><br><span class="line"><span class="comment">    * @param listener 监听器</span></span><br><span class="line"><span class="comment">    * @param urls     订阅URL映射的路径下的子路径集合（全量数据）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((urls == <span class="keyword">null</span> || urls.isEmpty()) &amp;&amp; !Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Ignore empty notify urls for subscribe url "</span> + url);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Notify urls for subscribe url "</span> + url + <span class="string">", urls: "</span> + urls);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 将 `urls` 按照 URL中的 'category` 参数进行分类，添加到Map集合result中</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;String, List&lt;URL&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 子路径URL是否匹配订阅URL</span></span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">                <span class="comment">// 获取分类，默认为 providers</span></span><br><span class="line">                String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加入到结果集</span></span><br><span class="line">                List&lt;URL&gt; categoryList = result.get(category);</span><br><span class="line">                <span class="keyword">if</span> (categoryList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    categoryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">                    result.put(category, categoryList);</span><br><span class="line">                &#125;</span><br><span class="line">                categoryList.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得订阅URL对应的缓存`notified`,即通知的 URL 变化结果（全量数据），会把result中的值放入到 categoryNotified中</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url);</span><br><span class="line">        <span class="keyword">if</span> (categoryNotified == <span class="keyword">null</span>) &#123;</span><br><span class="line">            notified.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;());</span><br><span class="line">            categoryNotified = notified.get(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理通知的 URL 变化结果（全量数据），即按照分类，循环处理通知的URL变化结果（全量数据）</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 获得分类名</span></span><br><span class="line">            String category = entry.getKey();</span><br><span class="line">            <span class="comment">// 获得分类名对应的通知ULR列表</span></span><br><span class="line">            List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">            <span class="comment">// 1 将result 覆盖到 `notified`缓存【更新notified集合中的通知ULR列表】，需要注意：当某个分类的数据为空时，会依然有URL，如 empty://...` ，通过这种方式统一处理所有订阅URL对应的数据为空的情况。</span></span><br><span class="line">            categoryNotified.put(category, categoryList);</span><br><span class="line">            <span class="comment">// 2 保存订阅url对应的被通知的URL到 properties和文件 中 // 在循环中的保存的原因是，订阅url对应的通知url可能是变动的，上一步的操作会更新notified集合，为了让 properties和文件中的 订阅-通知关系正确就需要不断更新。</span></span><br><span class="line">            saveProperties(url);</span><br><span class="line">            <span class="comment">// 3 调用传入的listener的notify()方法</span></span><br><span class="line">            listener.notify(categoryList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>需要说明的是，向注册中心发起订阅后，会获取到订阅URL所对应的全量数据，接着调用该上述方法；当注册中心监控的数据发生变更时，会调用上述方法，虽然变化的是增量的，但是从注册中心拉取的是全量的数据，即最新的数据。该方法的使用主要在服务暴露过程中服务提供者订阅配置信息，便于配置发生改变时通过监听器进行捕捉然后回调该方法，最终完成服务重新暴露。在服务引用过程中消费者订阅服务信息、配置信息等最终完成服务引用。该方法在 Dubbo 整个生命周期内发挥重要的作用，在分析完服务暴露和服务引用后会单独写一篇文章详细说明。</p><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Destroy registry:"</span> + getUrl());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消注册逻辑</span></span><br><span class="line">        Set&lt;URL&gt; destroyRegistered = <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered());</span><br><span class="line">        <span class="keyword">if</span> (!destroyRegistered.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (URL url : <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 取消注册，操作缓存，具体实现交给子类</span></span><br><span class="line">                        unregister(url);</span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Destroy unregister url "</span> + url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"Failed to unregister url "</span> + url + <span class="string">" to registry "</span> + getUrl() + <span class="string">" on destroy, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消订阅，操作缓存，具体实现交给子类</span></span><br><span class="line">        Map&lt;URL, Set&lt;NotifyListener&gt;&gt; destroySubscribed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed());</span><br><span class="line">        <span class="keyword">if</span> (!destroySubscribed.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : destroySubscribed.entrySet()) &#123;</span><br><span class="line">                <span class="comment">// 订阅URL</span></span><br><span class="line">                URL url = entry.getKey();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 订阅URL对应的监听器列表</span></span><br><span class="line">                <span class="keyword">for</span> (NotifyListener listener : entry.getValue()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 取消订阅</span></span><br><span class="line">                        unsubscribe(url, listener);</span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Destroy unsubscribe url "</span> + url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"Failed to unsubscribe url "</span> + url + <span class="string">" to registry "</span> + getUrl() + <span class="string">" on destroy, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>主要是取消注册和订阅。需要注意的是，无论是服务提供者还是消费者，都会向Registry发起注册和订阅，所以在JVM关闭示，都要进行取消。</p><h3 id="保存订阅变更数据"><a href="#保存订阅变更数据" class="headerlink" title="保存订阅变更数据"></a>保存订阅变更数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 订阅URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveProperties</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// notified 缓存的值： 订阅URL 对应的映射集合，只要订阅URL关联的路径下有节点变化，就会不断刷新，最新最全数据。</span></span><br><span class="line">            Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (categoryNotified != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (List&lt;URL&gt; us : categoryNotified.values()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (buf.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            buf.append(URL_SEPARATOR);</span><br><span class="line">                        &#125;</span><br><span class="line">                        buf.append(u.toFullString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            properties.setProperty(url.getServiceKey(), buf.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 版本号，使用CAS</span></span><br><span class="line">            <span class="keyword">long</span> version = lastCacheChanged.incrementAndGet();</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 保存变更数据到磁盘文件</span></span><br><span class="line">            <span class="keyword">if</span> (syncSaveFile) &#123;</span><br><span class="line">                doSaveProperties(version);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                registryCacheExecutor.execute(<span class="keyword">new</span> SaveProperties(version));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>该方法用于保存订阅URL对应的变更数据先到内存中的 <code>Properties</code> 中，然后在同步或异步保存到磁盘文件中，同步或异步根据 <code>syncSaveFile</code> 参数值。接着分析保存变更数据到磁盘文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version 版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSaveProperties</span><span class="params">(<span class="keyword">long</span> version)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 安全措施：</span></span><br><span class="line"><span class="comment">         * 1 CAS判断：</span></span><br><span class="line"><span class="comment">         *   在saveProperties(URL url)方法中执行了long version = lastCacheChanged.incrementAndGet();</span></span><br><span class="line"><span class="comment">         * 这里进行if (version &lt; lastCacheChanged.get())判断，如果满足这个条件，说明当前线程在进行doSaveProperties(long version)时，</span></span><br><span class="line"><span class="comment">         * 已经有其他线程执行了saveProperties(URL url)，马上就要执行doSaveProperties(long version)，所以当前线程放弃操作，让后边的这个线程来做保存操作。</span></span><br><span class="line"><span class="comment">         * 2 文件锁 FileLock：</span></span><br><span class="line"><span class="comment">         *   FileLock 是进程文件锁，用于进程间并发，控制不同程序（JVM）对同一文件的并发访问，文件锁可以解决多个进程并发访问、可以通过对一个可写文件加锁，保证同时只有一个进程可以拿到文件锁，这个进程从而可以对文件进行操作，</span></span><br><span class="line"><span class="comment">         *   而其它拿不到锁的进程要么被挂起等待，要么可以去做一些其它事情，这种机制保证了进程间文件的并发安全操作。修改同一个文件的问题，但不能解决多线程并发访问、修改同一文件的问题。FileLock 文件锁的效果是与操作系统相关的，是由操作系统底层来实现。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (version &lt; lastCacheChanged.get()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Save</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File lockfile = <span class="keyword">new</span> File(file.getAbsolutePath() + <span class="string">".lock"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!lockfile.exists()) &#123;</span><br><span class="line">                lockfile.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(lockfile, <span class="string">"rw"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileChannel channel = raf.getChannel();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 对文件加锁，默认为排它锁，没有获取到锁的进程阻塞等待</span></span><br><span class="line">                    FileLock lock = channel.tryLock();</span><br><span class="line">                    <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Can not lock the registry cache file "</span> + file.getAbsolutePath() + <span class="string">", ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Save</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                            file.createNewFile();</span><br><span class="line">                        &#125;</span><br><span class="line">                        FileOutputStream outputFile = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            properties.store(outputFile, <span class="string">"Dubbo Registry Cache"</span>);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            outputFile.close();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 释放文件锁</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                raf.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (version &lt; lastCacheChanged.get()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                registryCacheExecutor.execute(<span class="keyword">new</span> SaveProperties(lastCacheChanged.incrementAndGet()));</span><br><span class="line">            &#125;</span><br><span class="line">            logger.warn(<span class="string">"Failed to save registry store file, cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>该方法用于将 <code>Properties</code> 文件中的变更数据保存到磁盘文件中，在保存的时候做了并发处理操作，详细见代码注释。</p><h3 id="加载变更数据到内存"><a href="#加载变更数据到内存" class="headerlink" title="加载变更数据到内存"></a>加载变更数据到内存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span> &amp;&amp; file.exists()) &#123;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                properties.load(in);</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Load registry store file "</span> + file + <span class="string">", data: "</span> + properties);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Failed to load registry store file "</span> + file, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        in.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        logger.warn(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>该方法用于将磁盘文件中的变更数据加载到内存中的 <code>Properties</code> 中。</p><h3 id="获取订阅URL对应的变更URL列表"><a href="#获取订阅URL对应的变更URL列表" class="headerlink" title="获取订阅URL对应的变更URL列表"></a>获取订阅URL对应的变更URL列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> url 订阅URL</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;URL&gt; <span class="title">getCacheUrls</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">             <span class="comment">// 映射URL</span></span><br><span class="line">             String key = (String) entry.getKey();</span><br><span class="line">             <span class="comment">// 映射URL 对应的 通知URL串</span></span><br><span class="line">             String value = (String) entry.getValue();</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">if</span> (key != <span class="keyword">null</span> &amp;&amp; key.length() &gt; <span class="number">0</span> &amp;&amp; key.equals(url.getServiceKey()) &amp;&amp; (Character.isLetter(key.charAt(<span class="number">0</span>)) || key.charAt(<span class="number">0</span>) == <span class="string">'_'</span>) &amp;&amp; value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">// 对通知的URL串 以 '空格' 进行分割成字符串</span></span><br><span class="line">                 String[] arr = value.trim().split(URL_SPLIT);</span><br><span class="line">                 List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line"> </span><br><span class="line">                 <span class="keyword">for</span> (String u : arr) &#123;</span><br><span class="line">                     <span class="comment">// 解析URL串</span></span><br><span class="line">                     urls.add(URL.valueOf(u));</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">return</span> urls;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><h2 id="FailbackRegistry"><a href="#FailbackRegistry" class="headerlink" title="FailbackRegistry"></a>FailbackRegistry</h2><p>继承了 AbstractRegistry 抽闲类，支持失败重试的 Registry 抽象类。AbstractRegistry 中的注册、订阅操作更多的是操作缓存，并没有和注册中心交互。FailbackRegistry 在 AbstractRegistry 的基础上提供了注册和订阅的模版方法由具体子类去实现逻辑，并支持失败重试操作。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时任务执行器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService retryExecutor = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboRegistryFailedRetryTimer"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败重试ScheduledFuture，定时检查是否有请求失败，如有，无限次重试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledFuture&lt;?&gt; retryFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册失败的URL集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;URL&gt; failedRegistered = <span class="keyword">new</span> ConcurrentHashSet&lt;URL&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消注册失败的URL集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;URL&gt; failedUnregistered = <span class="keyword">new</span> ConcurrentHashSet&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅失败的监听器集合 key: 订阅URL value: 监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; failedSubscribed = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订阅失败的监听器集合 key: 订阅URL value: 监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; failedUnsubscribed = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知失败的URL集合 key1: 订阅URL key2: 监听器  value: 订阅URL对应的变更数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt; failedNotified = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The time in milliseconds the retryExecutor will wait // 重试频率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> retryPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailbackRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行父类构造方法， 加载本地磁盘缓存文件到内存缓存，即 properties.load(in)，到properties属性中。</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 这个很重要，注册中心宕机的情况下，依赖缓存文件中的信息可以构建Invoker，不影响服务的调用，只是不能调用新的服务了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重试频率，单位 毫秒</span></span><br><span class="line">        <span class="keyword">this</span>.retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建失败重试定时器【就是将一堆失败记录进行对应的重试操作】</span></span><br><span class="line">        <span class="keyword">this</span>.retryFuture = retryExecutor.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Check and connect to the registry</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行重试操作</span></span><br><span class="line">                    retry();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Defensive fault tolerance</span></span><br><span class="line">                    logger.error(<span class="string">"Unexpected error occur at failed retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==== Template method ====</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doUnregister</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doUnsubscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该抽象类主要维护了注册/取消注册失败、订阅/取消订阅失败、通知失败的缓存，以及提供者了注册/取消注册、订阅/取消订阅的模版方法。进行注册或订阅操作时，会先调用其父类 AbstractRegistry 中的方法进行缓存操作，然后再调用其具体子类的方法。</p><h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类操作缓存的方法</span></span><br><span class="line">        <span class="keyword">super</span>.register(url);</span><br><span class="line">        failedRegistered.remove(url);</span><br><span class="line">        failedUnregistered.remove(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发起注册请求到注册中心服务器，具体由子类实现，通过注册中心客户端连接到服务端</span></span><br><span class="line">            doRegister(url);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果开启了启动时检测，则直接抛出异常</span></span><br><span class="line">            <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">            <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">            <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                    t = t.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to register "</span> + url + <span class="string">" to registry "</span> + getUrl().getAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to register "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录注册失败的URL到注册失败的列表中，为了以后定时重试</span></span><br><span class="line">            failedRegistered.add(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unregister"><a href="#unregister" class="headerlink" title="unregister"></a>unregister</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类操作缓存的方法</span></span><br><span class="line">        <span class="keyword">super</span>.unregister(url);</span><br><span class="line">        failedRegistered.remove(url);</span><br><span class="line">        failedUnregistered.remove(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发起取消注册请求到注册中心服务器，具体由子类实现，通过注册中心客户端连接到服务端</span></span><br><span class="line">            doUnregister(url);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class="line">            <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">            <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">            <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                    t = t.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to unregister "</span> + url + <span class="string">" to registry "</span> + getUrl().getAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to uregister "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class="line">            failedUnregistered.add(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 调用父类 将listener实例加入到url所对应的监听器集合中 &#123;<span class="doctag">@link</span> #subscribed &#125; 中 */</span></span><br><span class="line">        <span class="keyword">super</span>.subscribe(url, listener);</span><br><span class="line">        <span class="comment">// 将listener从failedSubscribed/failedUnsubscribed中删除 ，接着从failedNotified获取当前url的通知失败Map&lt;NotifyListener, List&lt;URL&gt;&gt;，然后从中 删除掉listener 到 需要通知的所有url 的映射</span></span><br><span class="line">        removeFailedSubscribed(url, listener);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向服务端发送订阅请求,具体请求处理由子类实现 </span></span><br><span class="line">            doSubscribe(url, listener);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** 如果在订阅的过程抛出异常，那么尝试获取缓存url，如果有缓存url，则进行失败通知。之后“将失败的订阅请求记录到失败列表，定时重试”，如果没有缓存url，</span></span><br><span class="line"><span class="comment">             * 若开启了启动时检测或者直接抛出的异常是SkipFailbackWrapperException，则直接抛出异常，不会“将失败的订阅请求记录到失败列表，定时重试”</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 从Properties缓存文件中取出通知URL集合</span></span><br><span class="line"><span class="comment">             * 【注意：这些URL是由注册中心维护的，每次订阅方请求订阅时，注册中心都会把对应的要通知的URL列表记录到properties文件中，然后写入磁盘，注意 empty://的情况】</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            List&lt;URL&gt; urls = getCacheUrls(url);</span><br><span class="line">            <span class="keyword">if</span> (urls != <span class="keyword">null</span> &amp;&amp; !urls.isEmpty()) &#123;</span><br><span class="line">                notify(url, listener, urls);</span><br><span class="line">                logger.error(<span class="string">"Failed to subscribe "</span> + url + <span class="string">", Using cached list: "</span> + urls + <span class="string">" from cache file: "</span> + getUrl().getParameter(Constants.FILE_KEY, System.getProperty(<span class="string">"user.home"</span>) + <span class="string">"/dubbo-registry-"</span> + url.getHost() + <span class="string">".cache"</span>) + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果开启了启动时检测check=true,则直接抛出异常</span></span><br><span class="line">                <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>) &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                        t = t.getCause();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to subscribe "</span> + url + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.error(<span class="string">"Failed to subscribe "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将失败的订阅请求记录到失败列表，定时重试</span></span><br><span class="line">            addFailedSubscribed(url, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中向服务端发送订阅请求会交给子类处理，失败时会进入到 <code>catch</code> 块中的逻辑，注册中心维护的通知URL列表用在了这里，即当订阅发生异常时，会取出缓存中的通知ULR列表，调用 notify 方法进行通知。该逻辑也解释了即使注册中心宕机了，无论是消费方在注册中心宕机前启动完成还是宕机后启动，只要消费方缓存中的服务提供者可用，就可以实现服务调用。</p><h3 id="unsubscribe"><a href="#unsubscribe" class="headerlink" title="unsubscribe"></a>unsubscribe</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订阅，移除相关的缓存。真正的取消订阅由子类执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener A listener of the change event, not allowed to be empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类方法，移除url对应的listener实例</span></span><br><span class="line">        <span class="keyword">super</span>.unsubscribe(url, listener);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除相关的 订阅/取消订阅失败缓存，以及失败通知缓存</span></span><br><span class="line">        removeFailedSubscribed(url, listener);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 向服务端发送取消订阅请求,具体请求处理由子类实现 </span></span><br><span class="line">            doUnsubscribe(url, listener);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class="line">            <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">            <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                    t = t.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to unsubscribe "</span> + url + <span class="string">" to registry "</span> + getUrl().getAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to unsubscribe "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录取消订阅，便于重试</span></span><br><span class="line">            Set&lt;NotifyListener&gt; listeners = failedUnsubscribed.get(url);</span><br><span class="line">            <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                failedUnsubscribed.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashSet&lt;NotifyListener&gt;());</span><br><span class="line">                listeners = failedUnsubscribed.get(url);</span><br><span class="line">            &#125;</span><br><span class="line">            listeners.add(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      订阅URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls     通知的URL变化结果（全量数据）【注意：全量指的是至少要是一个分类的全量[动态类型的]，而不一定是全部数据】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进行通知</span></span><br><span class="line">            doNotify(url, listener, urls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception t) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将失败的通知请求记录到失败列表中，定时重试</span></span><br><span class="line">            Map&lt;NotifyListener, List&lt;URL&gt;&gt; listeners = failedNotified.get(url);</span><br><span class="line">            <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                failedNotified.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;NotifyListener, List&lt;URL&gt;&gt;());</span><br><span class="line">                listeners = failedNotified.get(url);</span><br><span class="line">            &#125;</span><br><span class="line">            listeners.put(listener, urls);</span><br><span class="line">            logger.error(<span class="string">"Failed to notify for subscribe "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会调用父类的通知方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      订阅URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls     订阅URL映射路径 下的子路径集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.notify(url, listener, urls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FailbackRegistry 中的 notify方法 本质上还是调用 AbstractRegistry 中的 notify 方法，区别在于 FailbackRegistry 会收集失败通知请求并记录到缓存中，便于重试。</p><h3 id="断线重连-1"><a href="#断线重连-1" class="headerlink" title="断线重连"></a>断线重连</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           <span class="comment">// register</span></span><br><span class="line">           Set&lt;URL&gt; recoverRegistered = <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered());</span><br><span class="line">           <span class="keyword">if</span> (!recoverRegistered.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                   logger.info(<span class="string">"Recover register url "</span> + recoverRegistered);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">for</span> (URL url : recoverRegistered) &#123;</span><br><span class="line">                   failedRegistered.add(url);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// subscribe</span></span><br><span class="line">           Map&lt;URL, Set&lt;NotifyListener&gt;&gt; recoverSubscribed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed());</span><br><span class="line">           <span class="keyword">if</span> (!recoverSubscribed.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                   logger.info(<span class="string">"Recover subscribe url "</span> + recoverSubscribed.keySet());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : recoverSubscribed.entrySet()) &#123;</span><br><span class="line">                   URL url = entry.getKey();</span><br><span class="line">                   <span class="keyword">for</span> (NotifyListener listener : entry.getValue()) &#123;</span><br><span class="line">                       addFailedSubscribed(url, listener);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FailbackRegistry 完全覆写父类方法(即不像前几个方法，会调用父类的方法)，将已注册和订阅的URL添加到 {@link #failedRegistered} ,{@link #failedSubscribed} 属性中，这样在{@link #retry()}方法中会进行重试。</p><h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重新注册没有注册成功的URL集合</span></span><br><span class="line">        <span class="keyword">if</span> (!failedRegistered.isEmpty()) &#123;</span><br><span class="line">            Set&lt;URL&gt; failed = <span class="keyword">new</span> HashSet&lt;URL&gt;(failedRegistered);</span><br><span class="line">            <span class="keyword">if</span> (failed.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Retry register "</span> + failed);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL url : failed) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            doRegister(url);</span><br><span class="line">                            failedRegistered.remove(url);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                            logger.warn(<span class="string">"Failed to retry register "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                    logger.warn(<span class="string">"Failed to retry register "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新取消注册没有取消注册成功的URL集合</span></span><br><span class="line">        <span class="keyword">if</span> (!failedUnregistered.isEmpty()) &#123;</span><br><span class="line">            Set&lt;URL&gt; failed = <span class="keyword">new</span> HashSet&lt;URL&gt;(failedUnregistered);</span><br><span class="line">            <span class="keyword">if</span> (!failed.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Retry unregister "</span> + failed);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL url : failed) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            doUnregister(url);</span><br><span class="line">                            failedUnregistered.remove(url);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                            logger.warn(<span class="string">"Failed to retry unregister  "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                    logger.warn(<span class="string">"Failed to retry unregister  "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 重新订阅 之前订阅失败的URL</span></span><br><span class="line"><span class="comment">         *1 把要订阅的URL映射的路径与监听器绑定</span></span><br><span class="line"><span class="comment">         *2 创建该监听器关联的ChildListener，底层又会使用TargetChildListener去包裹ChildListener，注意，TargetChildListener的实现会有不同</span></span><br><span class="line"><span class="comment">         *3 TargetChildListener直接监听订阅的URL映射路径的子路径，当子路径有变化，先触发TargetChildListener的方法，然后该方法会调用ChildListener的childChanged方法，接着调用监听的notify方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * TargetChildListener</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!failedSubscribed.isEmpty()) &#123;</span><br><span class="line">            Map&lt;URL, Set&lt;NotifyListener&gt;&gt; failed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failedSubscribed);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failed).entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue() == <span class="keyword">null</span> || entry.getValue().size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    failed.remove(entry.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (failed.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Retry subscribe "</span> + failed);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : failed.entrySet()) &#123;</span><br><span class="line">                        URL url = entry.getKey();</span><br><span class="line">                        Set&lt;NotifyListener&gt; listeners = entry.getValue();</span><br><span class="line">                        <span class="keyword">for</span> (NotifyListener listener : listeners) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                doSubscribe(url, listener);</span><br><span class="line">                                listeners.remove(listener);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                                logger.warn(<span class="string">"Failed to retry subscribe "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                    logger.warn(<span class="string">"Failed to retry subscribe "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新移除URL映射路径下的子路径关联的监听器</span></span><br><span class="line">        <span class="keyword">if</span> (!failedUnsubscribed.isEmpty()) &#123;</span><br><span class="line">            Map&lt;URL, Set&lt;NotifyListener&gt;&gt; failed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failedUnsubscribed);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failed).entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue() == <span class="keyword">null</span> || entry.getValue().isEmpty()) &#123;</span><br><span class="line">                    failed.remove(entry.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (failed.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Retry unsubscribe "</span> + failed);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : failed.entrySet()) &#123;</span><br><span class="line">                        URL url = entry.getKey();</span><br><span class="line">                        Set&lt;NotifyListener&gt; listeners = entry.getValue();</span><br><span class="line">                        <span class="keyword">for</span> (NotifyListener listener : listeners) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                doUnsubscribe(url, listener);</span><br><span class="line">                                listeners.remove(listener);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                                logger.warn(<span class="string">"Failed to retry unsubscribe "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                    logger.warn(<span class="string">"Failed to retry unsubscribe "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新通知【看通知的URL列表（发生改变的URL列表）和原始的URL列表对比，看是否改变，改变了就需要重新暴露服务】</span></span><br><span class="line">        <span class="keyword">if</span> (!failedNotified.isEmpty()) &#123;</span><br><span class="line">            Map&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt; failed = <span class="keyword">new</span> HashMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt;(failedNotified);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt; entry : <span class="keyword">new</span> HashMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt;(failed).entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue() == <span class="keyword">null</span> || entry.getValue().size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    failed.remove(entry.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (failed.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Retry notify "</span> + failed);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Map&lt;NotifyListener, List&lt;URL&gt;&gt; values : failed.values()) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;NotifyListener, List&lt;URL&gt;&gt; entry : values.entrySet()) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                NotifyListener listener = entry.getKey();</span><br><span class="line">                                List&lt;URL&gt; urls = entry.getValue();</span><br><span class="line">                                listener.notify(urls);</span><br><span class="line">                                values.remove(listener);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                                logger.warn(<span class="string">"Failed to retry notify "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                    logger.warn(<span class="string">"Failed to retry notify "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重试方法就是遍历缓存中五个 failedXxx属性，重试对应的操作，很清晰。</p><h3 id="销毁-1"><a href="#销毁-1" class="headerlink" title="销毁"></a>销毁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父方法，取消注册和订阅</span></span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 取消重试任务</span></span><br><span class="line">            retryFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优雅关闭线程池</span></span><br><span class="line">        ExecutorUtil.gracefulShutdown(retryExecutor, retryPeriod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取消注册和订阅，并关闭重试任务。取消注册和订阅还是调用其父类 AbstractRegistry 的 destroy 的方法，在父类基础上增加了对任务取消操作以及关闭重试线程池。</p><h2 id="RegistryFactory"><a href="#RegistryFactory" class="headerlink" title="RegistryFactory"></a>RegistryFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RegistryFactory. (SPI, Singleton, ThreadSafe) 注册中心工厂接口，创建的注册中心，包含注册中心客户端。注意和注册中心客户端工厂的区别。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.registry.support.AbstractRegistryFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取注册中心</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册中心地址，不允许为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注册中心引用，总不返回空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;<span class="string">"protocol"</span>&#125;)</span><br><span class="line">    <span class="function">Registry <span class="title">getRegistry</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册中心工厂，它是一个 Dubbo 的扩展点，默认扩展名是 <code>dubbo</code> ，即默认的扩展实现是 DubboRegistryFactory 。</p><h2 id="AbstractRegistryFactory"><a href="#AbstractRegistryFactory" class="headerlink" title="AbstractRegistryFactory"></a>AbstractRegistryFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractRegistryFactory. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.registry.RegistryFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistryFactory</span> <span class="keyword">implements</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log output</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AbstractRegistryFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LOCK 锁，用于 #destroyAll() 和 #getRegistry(url) 方法，处理对 REGISTRIES 属性访问的竞争。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock LOCK = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registry 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Registry&gt; REGISTRIES = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Registry&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get all registries</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> all registries</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Registry&gt; <span class="title">getRegistries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableCollection(REGISTRIES.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁所有的Registry对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">"Close all registries "</span> + getRegistries());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得锁</span></span><br><span class="line">        <span class="comment">// Lock up the registry shutdown process</span></span><br><span class="line">        LOCK.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 循环调用 destroy() 方法</span></span><br><span class="line">            <span class="keyword">for</span> (Registry registry : getRegistries()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// AbstractRegistry 实现了公用的销毁逻辑，取消注册和订阅</span></span><br><span class="line">                    registry.destroy();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    LOGGER.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清空缓存</span></span><br><span class="line">            REGISTRIES.clear();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Release the lock</span></span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        url = url.setPath(RegistryService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span></span><br><span class="line"><span class="class">                .<span class="title">addParameter</span>(<span class="title">Constants</span>.<span class="title">INTERFACE_KEY</span>, <span class="title">RegistryService</span>.<span class="title">class</span>.<span class="title">getName</span>()) // 设置<span class="title">interface</span> 属性在后来的订阅通知很有用</span></span><br><span class="line"><span class="class">                .<span class="title">removeParameters</span>(<span class="title">Constants</span>.<span class="title">EXPORT_KEY</span>, <span class="title">Constants</span>.<span class="title">REFER_KEY</span>)</span>;</span><br><span class="line">        String key = url.toServiceString();</span><br><span class="line">        <span class="comment">// Lock the registry access process to ensure a single instance of the registry</span></span><br><span class="line">        LOCK.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 访问缓存</span></span><br><span class="line">            Registry registry = REGISTRIES.get(key);</span><br><span class="line">            <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> registry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缓存未命中，创建Registry 实例，交给具体子类实现</span></span><br><span class="line">            registry = createRegistry(url);</span><br><span class="line">            <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create registry "</span> + url);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写入缓存</span></span><br><span class="line">            REGISTRIES.put(key, registry);</span><br><span class="line">            <span class="keyword">return</span> registry;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Release the lock</span></span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建注册中心的模版方法，由具体子类实现，过程包括：</span></span><br><span class="line"><span class="comment">     * 1 创建注册中心客户端</span></span><br><span class="line"><span class="comment">     * 2 启动客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册中心地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Registry 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 RegistryFactory 接口，是RegistryFactory 抽象类，主要两个工作，将获取的注册中心放入到缓存和实现了实现了公用的销毁逻辑，取消注册和订阅。</p><h2 id="NotifyListener"><a href="#NotifyListener" class="headerlink" title="NotifyListener"></a>NotifyListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NotifyListener. (API, Prototype, ThreadSafe)  通知监听器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.registry.RegistryService#subscribe(URL, NotifyListener)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NotifyListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当收到订阅URL对应的数据发生变化，通知触发</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls 已注册信息列表，总不为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口的实现类主要分为两大类，RegistryDirectory 和 匿名类内部类，具体的作用在订阅通知章节说明。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章主要介绍了注册的抽象层，接下来的文章会分析 Zookeeper 和 Redis 的实现，其他两种不做分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 Dubbo 体系中，注册中心是核心组件之一。Dubbo 通过注册中心实现了分布式环境中各服务之间的注册与发现，是各个分布式节点之间的纽带
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 服务容器</title>
    <link href="https://gentryhuang.com/posts/714ea63d/"/>
    <id>https://gentryhuang.com/posts/714ea63d/</id>
    <published>2020-04-09T16:00:00.000Z</published>
    <updated>2020-09-04T07:39:03.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面的 Dubbo SPI、Dubbo配置等文章描述的几乎都只是服务暴露、服务引用、服务调用之前的准备工作，有了这些准备工作后，下面介绍Dubbo的服务容器，通过Dubbo服务容器可以非常方便启动一个Dubbo服务。</p><h2 id="Dubbo服务容器"><a href="#Dubbo服务容器" class="headerlink" title="Dubbo服务容器"></a>Dubbo服务容器</h2><p>Dubbo的服务容器只是一个简单的Main，类似SpringBoot,负责初始化和启动不同功能的 <font color="#c7254e"> Container </font>，如果说dubbo的服务容器是一个简单的Main方法，那么承载不同功能的Container就是服务容器的具体实现，可以有不同的类型。uml关系图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/main-container.jpg" alt></p><h2 id="容器扩展点"><a href="#容器扩展点" class="headerlink" title="容器扩展点"></a>容器扩展点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Container. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 服务容器接口，Dubbo的扩展点，默认为 spring</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(<span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * start. 启动容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * stop. 体制容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动器Main"><a href="#启动器Main" class="headerlink" title="启动器Main"></a>启动器Main</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Main<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Container的配置项，如 dubbo.container=spring,log4j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTAINER_KEY = <span class="string">"dubbo.container"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 优雅停机配置项，如 dubbo.shutdown.hook=true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SHUTDOWN_HOOK_KEY = <span class="string">"dubbo.shutdown.hook"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Container扩展点的加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExtensionLoader&lt;Container&gt; loader = ExtensionLoader.getExtensionLoader(Container<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock LOCK = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Condition STOP = LOCK.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 启动参数，可以在启动时指定要加载的容器，如 java com.alibaba.dubbo.container.Main spring log4j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 main 方法的参数没有传入值，则从配置中加载。如果获取不到就使用Container 默认扩展 spring</span></span><br><span class="line">            <span class="keyword">if</span> (args == <span class="keyword">null</span> || args.length == <span class="number">0</span>) &#123;</span><br><span class="line">                String config = ConfigUtils.getProperty(CONTAINER_KEY, loader.getDefaultExtensionName());</span><br><span class="line">                args = Constants.COMMA_SPLIT_PATTERN.split(config);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> List&lt;Container&gt; containers = <span class="keyword">new</span> ArrayList&lt;Container&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 使用Dubbo SPI 加载 Container ,并把加载的Container 放入到List中</span></span><br><span class="line">                containers.add(loader.getExtension(args[i]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">"Use container type("</span> + Arrays.toString(args) + <span class="string">") to run dubbo serivce."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当配置JVM启动参数带有 -Ddubbo.shutdown.hook=true时，添加关闭的ShutdownHook</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"true"</span>.equals(System.getProperty(SHUTDOWN_HOOK_KEY))) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 优雅停机</span></span><br><span class="line">                Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="string">"dubbo-container-shutdown-hook"</span>) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (Container container : containers) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 关闭容器</span></span><br><span class="line">                                container.stop();</span><br><span class="line">                                logger.info(<span class="string">"Dubbo "</span> + container.getClass().getSimpleName() + <span class="string">" stopped!"</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                                logger.error(t.getMessage(), t);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 获得 ReentrantLock</span></span><br><span class="line">                                LOCK.lock();</span><br><span class="line">                                <span class="comment">// 唤醒 Main 主线程的等待</span></span><br><span class="line">                                STOP.signal();</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                <span class="comment">// 释放 LOCK</span></span><br><span class="line">                                LOCK.unlock();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动容器</span></span><br><span class="line">            <span class="keyword">for</span> (Container container : containers) &#123;</span><br><span class="line">                container.start();</span><br><span class="line">                logger.info(<span class="string">"Dubbo "</span> + container.getClass().getSimpleName() + <span class="string">" started!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"[yyyy-MM-dd HH:mm:ss]"</span>).format(<span class="keyword">new</span> Date()) + <span class="string">" Dubbo service server started!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发生异常，打印错误日志，并JVM退出</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得 LOCK 锁</span></span><br><span class="line">            LOCK.lock();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 释放锁，进入等待，直到被唤醒</span></span><br><span class="line"><span class="comment">             * 作用：线程不结束，不触发JVM退出，这样Dubbo就不会退出。如果不等待，main方法执行完成，就会触发JVM退出，导致Dubbo服务退出</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            STOP.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Dubbo service server stopped, interrupted by other thread!"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放 LOCK</span></span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li>dubbo服务容器只是一个简单Main 方法，默认情况下只会加载一个简单的Spring容器，用于暴露服务。Dubbo服务容器的加载内容可以扩展，即可通过容器扩展点进行扩展，如：spring、logback等。</li><li>dubbo服务容器是dubbo服务的启动器，它的本质是启动时加载dubbo的相关内容【通过spring配置，log4j配置等体现】然后启动Container。但是 实际生产中，一般不会直接使用dubbo的服务容器，更多主流的是使用Spring或者SpringBoot</li></ul><h2 id="SpringContainer"><a href="#SpringContainer" class="headerlink" title="SpringContainer"></a>SpringContainer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringContainer. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * 实现Container接口，Spring容器实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringContainer</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SpringContainer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 配置属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_CONFIG = <span class="string">"dubbo.spring.config"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认配置文件地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SPRING_CONFIG = <span class="string">"classpath*:META-INF/spring/*.xml"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 上下文 ，静态属性，全局唯一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> ClassPathXmlApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassPathXmlApplicationContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得Spring 配置文件的地址【先优先从JVM参数中取，没有再从dubbo.properties文件中取】</span></span><br><span class="line">        String configPath = ConfigUtils.getProperty(SPRING_CONFIG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有配置就使用默认路径下的配置文件</span></span><br><span class="line">        <span class="keyword">if</span> (configPath == <span class="keyword">null</span> || configPath.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            configPath = DEFAULT_SPRING_CONFIG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Spring 上下文</span></span><br><span class="line">        context = <span class="keyword">new</span> ClassPathXmlApplicationContext(configPath.split(<span class="string">"[,\\s]+"</span>), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听器 [dubbo服务暴露、服务销毁以及优雅停机的关键]</span></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> DubboApplicationListener());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听容器关闭 [注册优雅停机钩子]</span></span><br><span class="line">        context.registerShutdownHook();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新Spring容器</span></span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 启动Spring容器，加载Dubbo的配置，从而启动Dubbo 服务</span></span><br><span class="line">        context.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 停止上下文，会触发 ContextStoppedEvent 事件</span></span><br><span class="line">                context.stop();</span><br><span class="line">                <span class="comment">// 关闭上下文，会触发 ContextClosedEvent 事件</span></span><br><span class="line">                context.close();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 置空，便于被回收</span></span><br><span class="line">                context = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li>DubboApplicationListener实现了ApplicationListener接口，用于监听Spring容器的起停，在启动和销毁的时候分别执行服务暴露和取消服务暴露以及执行优雅停机</li><li>创建DubboApplicationListener对象的时候，都会创建DubboBootstrap对象，该对象主要完成服务暴露、取消服务暴露、注册与移除jdk shutdownhook</li><li>在创建DubboBootstrap对象时，会为该类注入DubboShutdownHook对象，该对象继承了Thread，将释放资源的方法作为任务体，该对象是真正要注册到系统中的钩子，当JVM退出时该钩子会回调它的任务体</li></ul><p><strong>关系图如下</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/container-hook.jpg" alt></p><h3 id="DubboApplicationListener"><a href="#DubboApplicationListener" class="headerlink" title="DubboApplicationListener"></a>DubboApplicationListener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An application listener that listens the ContextClosedEvent.</span></span><br><span class="line"><span class="comment"> * Upon the event, this listener will do the necessary clean up to avoid memory leak.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo引导程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DubboBootstrap dubboBootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboApplicationListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建DubboBootstrap</span></span><br><span class="line">        dubboBootstrap = <span class="keyword">new</span> DubboBootstrap(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboApplicationListener</span><span class="params">(DubboBootstrap dubboBootstrap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboBootstrap = dubboBootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听spring事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationEvent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// spring容器刷新完成</span></span><br><span class="line">        <span class="keyword">if</span> (applicationEvent <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">            dubboBootstrap.start();</span><br><span class="line">            <span class="comment">// spring容器销毁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (applicationEvent <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            dubboBootstrap.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DubboBootstrap"><a href="#DubboBootstrap" class="headerlink" title="DubboBootstrap"></a>DubboBootstrap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A bootstrap class to easily start and stop Dubbo via programmatic API.</span></span><br><span class="line"><span class="comment"> * The bootstrap class will be responsible to cleanup the resources during stop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务配置对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ServiceConfig&gt; serviceConfigList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动期间是否注册 钩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> registerShutdownHookOnStart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在嵌入式环境下[Main方法]运行Dubbo时使用的 钩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DubboShutdownHook shutdownHook;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取DubboShutdownHook，并注入到该类中</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">true</span>, DubboShutdownHook.getDubboShutdownHook());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBootstrap</span><span class="params">(<span class="keyword">boolean</span> registerShutdownHookOnStart)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 获取DubboShutdownHook，并注入到该类中</span></span><br><span class="line">        <span class="keyword">this</span>(registerShutdownHookOnStart, DubboShutdownHook.getDubboShutdownHook());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBootstrap</span><span class="params">(<span class="keyword">boolean</span> registerShutdownHookOnStart, DubboShutdownHook shutdownHook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceConfigList = <span class="keyword">new</span> ArrayList&lt;ServiceConfig&gt;();</span><br><span class="line">        <span class="keyword">this</span>.shutdownHook = shutdownHook;</span><br><span class="line">        <span class="keyword">this</span>.registerShutdownHookOnStart = registerShutdownHookOnStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register service config to bootstrap, which will be called during &#123;<span class="doctag">@link</span> DubboBootstrap#stop()&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceConfig the service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the bootstrap instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DubboBootstrap <span class="title">registerServiceConfig</span><span class="params">(ServiceConfig serviceConfig)</span> </span>&#123;</span><br><span class="line">        serviceConfigList.add(serviceConfig);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dubbo引导程序 - start</span></span><br><span class="line"><span class="comment">     * 1 是否注册shutdown hook</span></span><br><span class="line"><span class="comment">     * 2 服务暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动期间是否注册过shutdown hook</span></span><br><span class="line">        <span class="keyword">if</span> (registerShutdownHookOnStart) &#123;</span><br><span class="line">            registerShutdownHook();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果DubboShutdown hook 已经注册到系统中，需要移除掉</span></span><br><span class="line">            removeShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环服务配置对象，依次进行服务暴露</span></span><br><span class="line">        <span class="keyword">for</span> (ServiceConfig serviceConfig: serviceConfigList) &#123;</span><br><span class="line">            serviceConfig.export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dubbo引导程序 - stop</span></span><br><span class="line"><span class="comment">     * 1 取消服务暴露</span></span><br><span class="line"><span class="comment">     * 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ServiceConfig serviceConfig: serviceConfigList) &#123;</span><br><span class="line">            serviceConfig.unexport();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行 shutdown hook 释放资源</span></span><br><span class="line">        shutdownHook.destroyAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果启动期已经注册过，则从系统中移除 todo ??? 为什么还要注册到系统，直接根据spring销毁事件然后执行释放任务不就可以了吗？</span></span><br><span class="line">        <span class="keyword">if</span> (registerShutdownHookOnStart) &#123;</span><br><span class="line">            removeShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 shutdown hook</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除 shutdown hook</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().removeShutdownHook(shutdownHook);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            <span class="comment">// ignore - VM is already shutting down</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DubboShutdownHook"><a href="#DubboShutdownHook" class="headerlink" title="DubboShutdownHook"></a>DubboShutdownHook</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The shutdown hook thread to do the clean up stuff.</span></span><br><span class="line"><span class="comment"> * This is a singleton in order to ensure there is only one shutdown hook registered.</span></span><br><span class="line"><span class="comment"> * Because &#123;<span class="doctag">@link</span> ApplicationShutdownHooks&#125; use &#123;<span class="doctag">@link</span> java.util.IdentityHashMap&#125;</span></span><br><span class="line"><span class="comment"> * to store the shutdown hooks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboShutdownHook</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DubboShutdownHook<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook,类属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DubboShutdownHook dubboShutdownHook = <span class="keyword">new</span> DubboShutdownHook(<span class="string">"DubboShutdownHook"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubboShutdownHook <span class="title">getDubboShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dubboShutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Has it already been destroyed or not?</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 是否已经被销毁标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean destroyed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DubboShutdownHook</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook的任务体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        destroyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Destroy all the resources, including registries and protocols.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 销毁所有的资源，包括 Registry相关 和 Protocol相关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果已经销毁则忽略</span></span><br><span class="line">        <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁所有的 Registry,取消应用程序中的服务提供者和消费者的订阅与注册</span></span><br><span class="line">        AbstractRegistryFactory.destroyAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 销毁所有的 Protocol</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 这里的Protocol比较多，大体上可以分两类：</span></span><br><span class="line"><span class="comment">         * 1 和Registry相关的Protocol，RegistryProtocol关注服务的注册</span></span><br><span class="line"><span class="comment">         * 2 具体协议，如 DubboProtocol、httpProtocol等,关注服务的暴露和引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String protocolName : loader.getLoadedExtensions()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Protocol protocol = loader.getLoadedExtension(protocolName);</span><br><span class="line">                <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    protocol.destroy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LogbackContainer"><a href="#LogbackContainer" class="headerlink" title="LogbackContainer"></a>LogbackContainer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LogbackContainer. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * 实现 Container 接口，Logback 容器实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogbackContainer</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGBACK_FILE = <span class="string">"dubbo.logback.file"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志文件级别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGBACK_LEVEL = <span class="string">"dubbo.logback.level"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志保留天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGBACK_MAX_HISTORY = <span class="string">"dubbo.logback.maxhistory"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认日志级别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LOGBACK_LEVEL = <span class="string">"ERROR"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 logback 配置的日志文件路径</span></span><br><span class="line">        String file = ConfigUtils.getProperty(LOGBACK_FILE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span> &amp;&amp; file.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获得日志级别</span></span><br><span class="line">            String level = ConfigUtils.getProperty(LOGBACK_LEVEL);</span><br><span class="line">            <span class="keyword">if</span> (level == <span class="keyword">null</span> || level.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                level = DEFAULT_LOGBACK_LEVEL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得日志保留天数，如果是0则永久保留</span></span><br><span class="line">            <span class="keyword">int</span> maxHistory = StringUtils.parseInteger(ConfigUtils.getProperty(LOGBACK_MAX_HISTORY));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 logback</span></span><br><span class="line">            doInitializer(file, level, maxHistory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止为空，因为不需要关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 logback</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file       日志文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> level      日志级别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxHistory 日志保留天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInitializer</span><span class="params">(String file, String level, <span class="keyword">int</span> maxHistory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取日志工厂</span></span><br><span class="line">        LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过工厂获取Logger</span></span><br><span class="line">        Logger rootLogger = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);</span><br><span class="line">        rootLogger.detachAndStopAllAppenders();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建日志追加器</span></span><br><span class="line">        RollingFileAppender&lt;ILoggingEvent&gt; fileAppender = <span class="keyword">new</span> RollingFileAppender&lt;ILoggingEvent&gt;();</span><br><span class="line">        fileAppender.setContext(loggerContext);</span><br><span class="line">        fileAppender.setName(<span class="string">"application"</span>);</span><br><span class="line">        fileAppender.setFile(file);</span><br><span class="line">        fileAppender.setAppend(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建滚动策略</span></span><br><span class="line">        TimeBasedRollingPolicy&lt;ILoggingEvent&gt; policy = <span class="keyword">new</span> TimeBasedRollingPolicy&lt;ILoggingEvent&gt;();</span><br><span class="line">        policy.setContext(loggerContext);</span><br><span class="line">        policy.setMaxHistory(maxHistory);</span><br><span class="line">        policy.setFileNamePattern(file + <span class="string">".%d&#123;yyyy-MM-dd&#125;"</span>);</span><br><span class="line">        policy.setParent(fileAppender);</span><br><span class="line">        policy.start();</span><br><span class="line">        fileAppender.setRollingPolicy(policy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式</span></span><br><span class="line">        PatternLayoutEncoder encoder = <span class="keyword">new</span> PatternLayoutEncoder();</span><br><span class="line">        encoder.setContext(loggerContext);</span><br><span class="line">        encoder.setPattern(<span class="string">"%date [%thread] %-5level %logger (%file:%line\\) - %msg%n"</span>);</span><br><span class="line">        encoder.start();</span><br><span class="line">        fileAppender.setEncoder(encoder);</span><br><span class="line"></span><br><span class="line">        fileAppender.start();</span><br><span class="line"></span><br><span class="line">        rootLogger.addAppender(fileAppender);</span><br><span class="line">        rootLogger.setLevel(Level.toLevel(level));</span><br><span class="line">        rootLogger.setAdditive(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Log4jContainer"><a href="#Log4jContainer" class="headerlink" title="Log4jContainer"></a>Log4jContainer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Log4jContainer. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * 实现Container接口，Log4j容器实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jContainer</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志文件路径配置，如 dubbo.log4j.file=/opt/log/access.log</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG4J_FILE = <span class="string">"dubbo.log4j.file"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志级别 如： dubbo.log4j.level=WARN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG4J_LEVEL = <span class="string">"dubbo.log4j.level"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志子路径配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG4J_SUBDIRECTORY = <span class="string">"dubbo.log4j.subdirectory"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认日志级别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LOG4J_LEVEL = <span class="string">"ERROR"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动配置log4j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 log4j 配置的日志文件路径</span></span><br><span class="line">        String file = ConfigUtils.getProperty(LOG4J_FILE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取日志级别</span></span><br><span class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span> &amp;&amp; file.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String level = ConfigUtils.getProperty(LOG4J_LEVEL);</span><br><span class="line">            <span class="keyword">if</span> (level == <span class="keyword">null</span> || level.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                level = DEFAULT_LOG4J_LEVEL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建PropertyConfigurator所需的 Properties 对象，</span></span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.rootLogger"</span>, level + <span class="string">",application"</span>);</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.appender.application"</span>, <span class="string">"org.apache.log4j.DailyRollingFileAppender"</span>);</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.appender.application.File"</span>, file);</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.appender.application.Append"</span>, <span class="string">"true"</span>);</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.appender.application.DatePattern"</span>, <span class="string">"'.'yyyy-MM-dd"</span>);</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.appender.application.layout"</span>, <span class="string">"org.apache.log4j.PatternLayout"</span>);</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.appender.application.layout.ConversionPattern"</span>, <span class="string">"%d [%t] %-5p %C&#123;6&#125; (%F:%L) - %m%n"</span>);</span><br><span class="line">            PropertyConfigurator.configure(properties);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得日志子目录，用于多进程启动时，避免冲突</span></span><br><span class="line">        String subdirectory = ConfigUtils.getProperty(LOG4J_SUBDIRECTORY);</span><br><span class="line">        <span class="keyword">if</span> (subdirectory != <span class="keyword">null</span> &amp;&amp; subdirectory.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取 Logger 列表</span></span><br><span class="line">            Enumeration&lt;org.apache.log4j.Logger&gt; ls = LogManager.getCurrentLoggers();</span><br><span class="line">            <span class="keyword">while</span> (ls.hasMoreElements()) &#123;</span><br><span class="line">                org.apache.log4j.Logger l = ls.nextElement();</span><br><span class="line">                <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 拿到当前Logger 的追加器</span></span><br><span class="line">                    Enumeration&lt;Appender&gt; as = l.getAllAppenders();</span><br><span class="line">                    <span class="keyword">while</span> (as.hasMoreElements()) &#123;</span><br><span class="line">                        Appender a = as.nextElement();</span><br><span class="line">                        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> FileAppender) &#123;</span><br><span class="line">                            FileAppender fa = (FileAppender) a;</span><br><span class="line">                            String f = fa.getFile();</span><br><span class="line">                            <span class="keyword">if</span> (f != <span class="keyword">null</span> &amp;&amp; f.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">int</span> i = f.replace(<span class="string">'\\'</span>, <span class="string">'/'</span>).lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">                                String path;</span><br><span class="line">                                <span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    path = subdirectory;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    path = f.substring(<span class="number">0</span>, i);</span><br><span class="line">                                    <span class="keyword">if</span> (!path.endsWith(subdirectory)) &#123;</span><br><span class="line">                                        path = path + <span class="string">"/"</span> + subdirectory;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    f = f.substring(i + <span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 设置新的文件名</span></span><br><span class="line">                                fa.setFile(path + <span class="string">"/"</span> + f);</span><br><span class="line">                                <span class="comment">// 生效配置</span></span><br><span class="line">                                fa.activateOptions();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空方法，无需关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h2><ul><li><p>通过加载properties配置文件加载目标容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo.container&#x3D;spring,logback,log4j</span><br></pre></td></tr></table></figure></li><li><p>缺省只加载spring容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java org.apache.dubbo.container.Main</span><br></pre></td></tr></table></figure></li><li><p>通过main方法参数传入要加载的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java org.apache.dubbo.container.Main spring logback log4j</span><br></pre></td></tr></table></figure></li><li><p>通过 JVM 启动参数传入要加载的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java org.apache.dubbo.container.Main -Ddubbo.container&#x3D;spring,jetty,log4j</span><br></pre></td></tr></table></figure></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然实际生产中一般不会直接使用dubbo的服务容器，但是它的实现机制我们可以学习下。了解了Dubbo服务容器后，我们从源码层面上重新认识了Dubbo的启停流程，从下一篇文章开始正式进入到Dubbo的核心模块源码分析阶段。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面的 Dubbo SPI、Dubbo配置等文章描述的几乎都只是服务暴露、服务引用、服务调用之前的准备工作，有了这些准备工作后，下面介绍Du
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Spring" scheme="https://gentryhuang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 注解配置</title>
    <link href="https://gentryhuang.com/posts/1a889dcd/"/>
    <id>https://gentryhuang.com/posts/1a889dcd/</id>
    <published>2020-04-01T16:00:00.000Z</published>
    <updated>2020-09-04T07:15:55.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://gentryhuang.com/posts/a8d76a91/">Dubbo源码分析 - XML配置</a> 中，详细介绍了Dubbo的XML配置方式，本篇文章介绍Dubbo注解配置方式，使用示例见 <a href="https://gentryhuang.com/posts/7202a9c0/">Dubbo示例 - 注解配置</a>。</p><h2 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationProvider</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Java Config + 注解的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"com.alibaba.dubbo.examples.annotation.impl"</span>)</span><br><span class="line">    <span class="meta">@PropertySource</span>(<span class="string">"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-provider.properties"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里通过Java Config显示组装Bean，会注入给Dubbo服务，即标注有<span class="doctag">@Service</span>的类。如果不显示装配，Dubbo会默认创建内置的配置类定义，创建内置的配置类定义的前提是配置了相关的属性，否则不会创建。其他配置类似。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ProviderConfig <span class="title">providerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ProviderConfig providerConfig = <span class="keyword">new</span> ProviderConfig();</span><br><span class="line">            providerConfig.setTimeout(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> providerConfig;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 <a href="https://gentryhuang.com/posts/7202a9c0/">Dubbo示例 - 注解配置</a> 中的提供者配置进行说明。当Spring启动后，会先获取配置类上的 <code>@PropertySource</code> 注解，把外部配置进行解析然后放入Spring环境中，为之后流程中的Dubbo配置类的对象进行属性赋值。Spring会递归获取配置类的 <code>@Import</code> 注解，即搜集配置相关的所有<code>@Import</code>注解，以获取使用该注解引入的Selector或Registrar类，这些类是用来给Spring容器导入组件的。Dubbo的注解实现包括两大部分，一个是外部化配置，另一个是注解驱动，它们的能力是由Selector或Registrar类导入所需组件实现的，笔者调试这块花了很多时间，细节点还是挺多的，由于这些都是Spring源码的知识点就不进行分析了。</p><h2 id="注解配置代码结构"><a href="#注解配置代码结构" class="headerlink" title="注解配置代码结构"></a>注解配置代码结构</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-annotation-struct.jpg" alt></p><p>在 Dubbo 2.5.7之前的版本 ，Dubbo 提供了两个核心注解 <code>@Service</code> 以及 <code>@Reference</code>，分别用于Dubbo 服务提供和 Dubbo 服务引用。<code>@Service</code> 作为 XML配置&lt;dubbo:service&gt;的替代，与 Spring Framework @Service 类似，用于服务暴露。<code>@Reference</code> 则是替代&lt;dubbo:reference &gt; ，类似于 Spring 中的 <code>@Autowired</code>，引用服务。但2.5.7之前Dubbo注解是基于AnnotationBean实现的，主要存在以下几个问题：</p><ul><li>注解支持不充分，需要XML配置&lt;dubbo:annotation&gt;</li><li>@Service 不支持Spring AOP</li><li>@Reference 不支持字段继承性</li></ul><p>基于原来实现思路的基础上无法解决历史遗留问题，从2.5.7开始Dubbo的注解实现已经完全重写，AnnotationBean已经被废弃。</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>Spring Framework 3.1 引入了 <code>@ComponentScan</code> 完全替代了 XML 元素 &lt;context:component-scan&gt; 。同样地， <code>@DubboComponentScan</code> 作为 Dubbo 2.5.7 新增的 Annotation，也是XML 元素 &lt;dubbo:annotation&gt; 的替代方案，与注解驱动相关。 <code>@DubboComponentScan</code> 相对比较繁重，原因在于处理Dubbo <code>@Service</code> 标注的类暴露Dubbo服务外，还要支持Spring Bean的 <code>@Reference</code> 字段或方法注入Dubbo服务代理，即 <code>@DubboComponentScan</code> 除了扫描 Dubbo @Service 组件以外，还需要处理 @Reference注入。需要注意的是，如果 <code>@Reference</code> 字段或方法所在的类不是 Spring Bean 的话， <code>@DubboComponentScan</code> 不会处理 <code>@Reference</code> 注入，其原理与 Spring <code>@Autowired</code> 一致。<code>@EnableDubboConfig</code> 用于支持Dubbo的外部化配置，常用于显示指定Dubbo的配置。需要注意的是Dubbo框架中的dubbo.properties从某种意义上来说是特殊的Dubbo的外部化配置，框架默认情况下会加载类路径下的该配置文件，详细参见 <a href="http://localhost:4000/posts/1d3295e6/" target="_blank" rel="noopener">属性配置</a>。</p><h2 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a>注解介绍</h2><h3 id="Service-注解"><a href="#Service-注解" class="headerlink" title="@Service 注解"></a>@Service 注解</h3><p><code>@Service</code> 用来配置Dubbo的服务提供方，通过 <code>@Service</code> 上提供的属性，可以进一步的定制化 Dubbo 的服务提供者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; interfaceClass() <span class="keyword">default</span> <span class="keyword">void</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">version</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">group</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">path</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">export</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">token</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">deprecated</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dynamic</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">accesslog</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">executes</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">document</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delay</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">local</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">stub</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">cluster</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">proxy</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">connections</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">callbacks</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">onconnect</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">ondisconnect</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">owner</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">layer</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">retries</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">loadbalance</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">async</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">actives</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sent</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">mock</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">validation</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">cache</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    String[] filter() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] listener() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] parameters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">String <span class="title">application</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">module</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">provider</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    String[] protocol() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">String <span class="title">monitor</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    String[] registry() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Service定义在一个类上，表示一个服务的具体实现，比较重要的属性：</p><blockquote><p>interfaceClass：指定服务提供方实现的 interface 的类<br> interfaceName：指定服务提供方实现的 interface 的类名<br> version：指定服务的版本号<br> group：指定服务的分组<br> export：是否暴露服务<br> registry：是否向注册中心注册服务<br> application：应用配置<br> module：模块配置<br> provider：服务提供方配置<br> protocol：协议配置<br> monitor：监控中心配置<br> registry：注册中心配置</p></blockquote><p>其中，application、module、provider、protocol、monitor、registry属性需要提供的是对应的Spring Bean的名字，Bean组装方式可以通过XML配置，也可以通过Java Config配置。</p><h3 id="Reference-注解"><a href="#Reference-注解" class="headerlink" title="@Reference 注解"></a>@Reference 注解</h3><p><code>@Reference</code> 用来配置Dubbo的服务消费方，通过 <code>@Reference</code> 上提供的属性，可以进一步的定制化 Dubbo 的服务消费方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reference</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reference &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; interfaceClass() <span class="keyword">default</span> <span class="keyword">void</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">version</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">group</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">url</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">client</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">generic</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">injvm</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">lazy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">stubevent</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">reconnect</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sticky</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">proxy</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">stub</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">cluster</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">connections</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">callbacks</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">onconnect</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">ondisconnect</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">owner</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">layer</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">retries</span><span class="params">()</span> <span class="keyword">default</span> 2</span>;</span><br><span class="line">    <span class="function">String <span class="title">loadbalance</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">async</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">actives</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sent</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">mock</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">validation</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">cache</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    String[] filter() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] listener() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] parameters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">String <span class="title">application</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">module</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">consumer</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">monitor</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    String[] registry() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Reference 可以定义在类中的一个字段上，也可以定义在一个方法上，甚至可以用来修饰另一个 annotation，表示一个服务引用。一般多把@Reference 定义在一个字段上，该注解有以下重要属性：</p><blockquote><p>interfaceClass：指定服务的 interface 的类<br> interfaceName：指定服务的 interface 的类名<br> version：指定服务的版本号<br> group：指定服务的分组<br> url：通过指定服务提供方的 URL 地址直接绕过注册中心发起调用<br> application：应用配置<br> module：模块配置<br> consumer：服务消费方配置<br> protocol：协议配置<br> monitor：监控中心配置<br> registry：注册中心配置</p></blockquote><p>其中，application、module、consumer、protocol、monitor、registry属性需要提供的是对应的Spring Bean的名字，Bean组装方式可以通过XML配置，也可以通过Java Config配置。</p><h3 id="EnableDubbo-注解"><a href="#EnableDubbo-注解" class="headerlink" title="@EnableDubbo 注解"></a>@EnableDubbo 注解</h3><p><code>@EnableDubbo</code> 注解是 <code>@EnableDubboConfig</code> 和 <code>@DubboComponentScan</code> 两者组合的便捷表达方式。与注解驱动相关的是 <code>@DubboComponentScan</code>，与外部化配置相关的是 <code>@EnableDubboConfig</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@EnableDubboConfig</span>  <span class="comment">// 开启Dubbo Config 【DubboConfig对象的创建和DubboConfig中的属性设置】</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span> <span class="comment">// 扫描Dubbo 的@Service 和 @Reference 注解的包或者类，从而创建Bean对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDubbo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 配置<span class="doctag">@DubboComponentScan</span> 注解 扫描的包</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Base packages to scan for annotated <span class="doctag">@Service</span> classes.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Use &#123;<span class="doctag">@link</span> #scanBasePackageClasses()&#125; for a type-safe alternative to String-based</span></span><br><span class="line"><span class="comment">     * package names.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> DubboComponentScan#basePackages()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(annotation = DubboComponentScan<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"basePackages"</span>)</span><br><span class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 配置 <span class="doctag">@DubboComponentScan</span> 注解 扫描的类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Type-safe alternative to &#123;<span class="doctag">@link</span> #scanBasePackages()&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment">     * scan for annotated <span class="doctag">@Service</span> classes. The package of each class specified will be</span></span><br><span class="line"><span class="comment">     * scanned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> classes from the base packages to scan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> DubboComponentScan#basePackageClasses</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(annotation = DubboComponentScan<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"basePackageClasses"</span>)</span><br><span class="line">    Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置 <span class="doctag">@EnableDubboConfig</span> 注解，是否将配置属性绑定到多个Spring Bean 上</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It indicates whether &#123;<span class="doctag">@link</span> AbstractConfig&#125; binding to multiple Spring Beans.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the default value is &lt;code&gt;false&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> EnableDubboConfig#multiple()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(annotation = EnableDubboConfig<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"multiple"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">multipleConfig</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@EnableDubbo</code> 可以通过 <strong>scanBasePackages属性</strong> 指定要扫描的包，通过 <strong>scanBasePackageClasses属性</strong> 指定要扫描的类[最后还是会转为扫描包的方式]，进而扫描Dubbo 的服务提供者（以 @Service 标注）以及 Dubbo 的服务消费者（以 Reference 标注）。扫描到 Dubbo 的服务提供方和消费者之后，对其做相应的组装并初始化，并最终完成服务暴露或者引用的工作。如果不使用外部化配置的话，也可以直接使用 @DubboComponentScan。</p><h3 id="EnableDubboConfig-注解"><a href="#EnableDubboConfig-注解" class="headerlink" title="@EnableDubboConfig 注解"></a>@EnableDubboConfig 注解</h3><p>该注解用于开启Dubbo配置，支持外部化配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * As  a convenient and multiple &#123;<span class="doctag">@link</span> EnableDubboConfigBinding&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigConfiguration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigConfigurationSelector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 开启Dubbo配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(DubboConfigConfigurationSelector<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableDubboConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置是否绑定到多个Spring Bean上，即表示是否支持多Dubbo配置Bean的绑定，默认值为false，即单Dubbo 配置Bean的绑定。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It indicates whether binding to multiple Spring Beans.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the default value is &lt;code&gt;false&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@revised</span> 2.5.9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">multiple</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解有一个核心的属性，<code>multiple</code> 属性用于支持多Dubbo配置Bean的数据绑定。<code>@Import</code> 的value属性值 <code>DubboConfigConfigurationSelector</code> 用于给Spring容器导入组件，导入的组件是 <code>DubboConfigConfiguration.Single</code> 或 <code>DubboConfigConfiguration.Multiple</code>，具体导入哪个组件取决于 <code>multiple</code> 的值。</p><h4 id="DubboConfigConfigurationSelector"><a href="#DubboConfigConfigurationSelector" class="headerlink" title="DubboConfigConfigurationSelector"></a>DubboConfigConfigurationSelector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigConfigurationSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> importingClassMetadata <span class="doctag">@Import</span>(DubboConfigConfigurationSelector.class) 所标注的注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 @EnableDubboConfig注解的属性</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(</span><br><span class="line">                importingClassMetadata.getAnnotationAttributes(EnableDubboConfig<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//获得multiple属性</span></span><br><span class="line">        <span class="keyword">boolean</span> multiple = attributes.getBoolean(<span class="string">"multiple"</span>);</span><br><span class="line">        <span class="comment">// 如果为true，则注册 DubboConfigConfiguration.Multiple Bean对象</span></span><br><span class="line">        <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">            <span class="keyword">return</span> of(DubboConfigConfiguration.Multiple<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果为false，则注册 DubboConfigConfiguration.Single Bean对象</span></span><br><span class="line">            <span class="keyword">return</span> of(DubboConfigConfiguration.Single<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T[] of(T... values) &#123;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HIGHEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类实现了Spring的ImportSelector接口，功能如下：</p><ol><li>利用ImportSelector要导入哪些组件，只需要返回要导入组件的全限定类名，即 selectImports方法返回值。</li><li>如果selectImports方法返回值对应的类，它里面有使用@Bean注解的方法，那么此时给容器中导入的不只有当前返回值对应类的实例，还有该类型中加了@Bean对应的实例。</li><li>给容器导入的不是 DubboConfigConfigurationSelector，因为它实现了ImportSelector接口，导入的是该类的selectImports方法中返回的值对应的类。</li></ol><p>通过以上规则可以知道，该类就是给Spring容器导入 <code>DubboConfigConfiguration.Single</code> 或 <code>DubboConfigConfiguration.Multiple</code> 组件。可以看出它们都是 DubboConfigConfiguration 类的内部类，下面我们看下该类的具体信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dubbo &#123;<span class="doctag">@link</span> AbstractConfig Config&#125; &#123;<span class="doctag">@link</span> Configuration&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Configuration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBindings</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ApplicationConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ModuleConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> RegistryConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ProtocolConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> MonitorConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ProviderConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConsumerConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Single Dubbo &#123;<span class="doctag">@link</span> AbstractConfig Config&#125; Bean Binding</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@EnableDubboConfigBinding</span> 注解 prefix 都是单数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@EnableDubboConfigBindings</span>(&#123;</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.application"</span>, type = ApplicationConfig<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            @<span class="title">EnableDubboConfigBinding</span>(<span class="title">prefix</span> </span>= <span class="string">"dubbo.module"</span>, type = ModuleConfig<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            @<span class="title">EnableDubboConfigBinding</span>(<span class="title">prefix</span> </span>= <span class="string">"dubbo.registry"</span>, type = RegistryConfig<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            @<span class="title">EnableDubboConfigBinding</span>(<span class="title">prefix</span> </span>= <span class="string">"dubbo.protocol"</span>, type = ProtocolConfig<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            @<span class="title">EnableDubboConfigBinding</span>(<span class="title">prefix</span> </span>= <span class="string">"dubbo.monitor"</span>, type = MonitorConfig<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            @<span class="title">EnableDubboConfigBinding</span>(<span class="title">prefix</span> </span>= <span class="string">"dubbo.provider"</span>, type = ProviderConfig<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            @<span class="title">EnableDubboConfigBinding</span>(<span class="title">prefix</span> </span>= <span class="string">"dubbo.consumer"</span>, type = ConsumerConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    &#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">static</span> <span class="title">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Multiple Dubbo &#123;<span class="doctag">@link</span> AbstractConfig Config&#125; Bean Binding</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@EnableDubboConfigBinding</span> 注解 prefix 都是复数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@EnableDubboConfigBindings</span>(&#123;</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.applications"</span>, type = ApplicationConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>),</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.modules"</span>, type = ModuleConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>),</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.registries"</span>, type = RegistryConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>),</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.protocols"</span>, type = ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>),</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.monitors"</span>, type = MonitorConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>),</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.providers"</span>, type = ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>),</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.consumers"</span>, type = ConsumerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DubboConfigConfiguration 类中没有属性和方法，只有两个静态内部类，具体导入哪个类上面已经介绍过了，下面我们来详介绍下 <code>@EnableDubboConfigBindings</code> 和 <code>@EnableDubboConfigBinding</code> 注解。</p><h4 id="EnableDubboConfigBindings-注解"><a href="#EnableDubboConfigBindings-注解" class="headerlink" title="@EnableDubboConfigBindings 注解"></a>@EnableDubboConfigBindings 注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Multiple &#123;<span class="doctag">@link</span> EnableDubboConfigBinding&#125; &#123;<span class="doctag">@link</span> Annotation&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(DubboConfigBindingsRegistrar<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableDubboConfigBindings</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of &#123;<span class="doctag">@link</span> EnableDubboConfigBindings&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EnableDubboConfigBinding[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解有一个value属性，类型是 <code>EnableDubboConfigBinding[]</code> ，即 <code>@EnableDubboConfigBinding</code> 数组。该注解上使用 <code>@Import</code> 注解，使用DubboConfigBindingsRegistrar 类给Spring容器导入组件，下面我们继续跟进，看下具体导入哪些组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AbstractConfig Dubbo Config&#125; binding Bean registrar for &#123;<span class="doctag">@link</span> EnableDubboConfigBindings&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBindings</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingRegistrar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingsRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> importingClassMetadata 标注类注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry Bean定义注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获得 EnableDubboConfigBindings 注解</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">// 获得EnableDubboConfigBindings 注解的value 属性值（这里是 EnableDubboConfigBinding 注解数组）</span></span><br><span class="line">        AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray(<span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">// 创建DubboConfigBindignRegistrar 对象，并设置环境变量</span></span><br><span class="line">        DubboConfigBindingRegistrar registrar = <span class="keyword">new</span> DubboConfigBindingRegistrar();</span><br><span class="line">        registrar.setEnvironment(environment);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次遍历 EnableDubboConfigBinding 注解集合，调用 DubboConfigBindingRegistrar的注册Bean方法进行组件注册</span></span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes element : annotationAttributes) &#123;</span><br><span class="line">            <span class="comment">// 根据 EnableDubboConfigBinding 注解信息，进行对应组件的注册</span></span><br><span class="line">            registrar.registerBeanDefinitions(element, registry);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        Assert.isInstanceOf(ConfigurableEnvironment<span class="class">.<span class="keyword">class</span>, <span class="title">environment</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.environment = (ConfigurableEnvironment) environment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的类主要做了三件事情：</p><ol><li>获取 @EnableDubboConfigBindings 注解信息，并获取该注解的value属性值，即获取的是 @EnableDubboConfigBinding 注解数组。</li><li>创建 DubboConfigBindingRegistrar对象。</li><li>遍历@EnableDubboConfigBinding 注解数组，调用DubboConfigBindingRegistrar对象的 registerBeanDefinitions方法。</li></ol><p>我们可以发现，@EnableDubboConfigBindings利用DubboConfigBindingsRegistrar导入组件逻辑很简单，因为整个导入逻辑都封装在了DubboConfigBindingRegistrar对象的 registerBeanDefinitions方法中。我们接着分析DubboConfigBindingsRegistrar类，需要说明的是@EnableDubboConfigBinding注解就是通过@Import注解使用该类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;其他代码&#125;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attributes <span class="doctag">@EnableDubboConfigBinding</span>注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry Bean定义注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationAttributes attributes, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得prefix 属性（因为有可能有占位符，需要要解析）</span></span><br><span class="line">        String prefix = environment.resolvePlaceholders(attributes.getString(<span class="string">"prefix"</span>));</span><br><span class="line">        <span class="comment">// 获得type属性，即AbstractConfig的实现类，这就是要导入的组件。需要特别说明的是，使用注解方式创建Dubbo的配置Bean，Dubbo Config 都是固定写在@EnableDubboConfigBinding注解属性中。</span></span><br><span class="line">        Class&lt;? extends AbstractConfig&gt; configClass = attributes.getClass(<span class="string">"type"</span>);</span><br><span class="line">        <span class="comment">// 获的multiple属性，决定配置是否用于多BeanDefinition</span></span><br><span class="line">        <span class="keyword">boolean</span> multiple = attributes.getBoolean(<span class="string">"multiple"</span>);</span><br><span class="line">        <span class="comment">// 注册Dubbo Config Bean</span></span><br><span class="line">        registerDubboConfigBeans(prefix, configClass, multiple, registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可以看出DubboConfigBindingsRegistrar就是使用 <code>DubboConfigBindingRegistrar</code> 对象解析@EnableDubboConfigBinding 注解信息，即配置属性的前缀和配置属性对应的Dubbo Config类，接着调用registerDubboConfigBeans 方法执行注册Bean定义逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册dubbo Config Bean对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix      配置属性前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configClass 配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> multiple    是否支持多Bean配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry    Spring注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBeans</span><span class="params">(String prefix,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;? extends AbstractConfig&gt; configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> multiple,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得prefix 开头的配置属性，以map形式返回 【environment.getPropertySources() 获得是系统属性、系统变量和@ResourceProperty注解导入的propertis配置属性】</span></span><br><span class="line">        Map&lt;String, Object&gt; properties = getSubProperties(environment.getPropertySources(), prefix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置类没有配置相关属性，则不创建对应的BeanDefinition</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(properties)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">"There is no property for binding to dubbo config class ["</span> + configClass.getName()</span><br><span class="line">                        + <span class="string">"] within prefix ["</span> + prefix + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 获得配置类的Bean名称，Bean名称生成规则取决与 multiple 的值</span></span><br><span class="line">        Set&lt;String&gt; beanNames = multiple ? resolveMultipleBeanNames(properties) : Collections.singleton(resolveSingleBeanName(properties, configClass, registry));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历Bean名字集合</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 注册Dubbo Config的Bean 对象【没有设置属性值】</span></span><br><span class="line">            registerDubboConfigBean(beanName, configClass, registry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 注册Dubbo Config的Bean对象对应的DubboConfigBindingBeanPostProcessor对象，即Dubbo配置属性绑定的后置处理器【注意，每一个Dubbo Config的Bean对象都对应一个绑定配置的后置处理器】</span></span><br><span class="line">            registerDubboConfigBindingBeanPostProcessor(prefix, beanName, multiple, registry);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册Dubbo ConfigBean对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName Bean的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configClass 配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry 注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBean</span><span class="params">(String beanName, Class&lt;? extends AbstractConfig&gt; configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 configClass对应的Bean定义Builder [该过程Bean定义已经创建]</span></span><br><span class="line">        BeanDefinitionBuilder builder = rootBeanDefinition(configClass);</span><br><span class="line">        <span class="comment">// 由 Bean定义Builder 获取Bean定义</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// 注册到 Spring 的注册表中</span></span><br><span class="line">        registry.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(<span class="string">"The dubbo config bean definition [name : "</span> + beanName + <span class="string">", class : "</span> + configClass.getName() +</span><br><span class="line">                    <span class="string">"] has been registered."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建的Dubbo Config的Bean对象的DubboConfigBindingBeanPostProcessor对象 【目的：实现对Dubbo Config的Bean对象的配置属性设置】</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix   配置属性前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName Bean的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> multiple 是否支持多Bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry Spring注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBindingBeanPostProcessor</span><span class="params">(String prefix, String beanName, <span class="keyword">boolean</span> multiple,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Dubbo配置绑定 Bean后置处理器对应的BeanDefinitionBuilder对象</span></span><br><span class="line">        Class&lt;?&gt; processorClass = DubboConfigBindingBeanPostProcessor<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        BeanDefinitionBuilder builder = rootBeanDefinition(processorClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法的参数为 actualPrefix 和 beanName，即创建DubboConfigBindingBeanPostProcessor对象需要这两个参数，后面属性绑定会用到这两个属性。</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> DubboConfigBindingBeanPostProcessor#DubboConfigBindingBeanPostProcessor(java.lang.String, java.lang.String)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String actualPrefix = multiple ? normalizePrefix(prefix) + beanName : prefix;</span><br><span class="line">        builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 DubboConfigBindingBeanPostProcessor 的 BeanDefinition 对象</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// 设置rol属性</span></span><br><span class="line">        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        <span class="comment">// 注册到注册表</span></span><br><span class="line">        registerWithGeneratedName(beanDefinition, registry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(<span class="string">"The BeanPostProcessor bean definition ["</span> + processorClass.getName()</span><br><span class="line">                    + <span class="string">"] for dubbo config bean [name : "</span> + beanName + <span class="string">"] has been registered."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略代码&#125; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerDubboConfigBeans 方法主要完成了两个核心的工作，创建Dubbo Config的Bean定义和Dubbo Config的属性绑定后置处理器。Dubbo Config是约定好的配置类，具体约定的配置类可以参见 <code>DubboConfigConfiguration</code>，并且指定了这些配置类的外部配置属性的前缀。这个过程还涉及到Dubbo Config的Bean定义的名称生成，我们来看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得配置类对应的Bean 名称的集合。配置用于多个Bean的情况</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 例如： dubbo.application.$&#123;beanName&#125;.name=dubbo-demo-annotation-provider，$&#123;beanName&#125;就是配置类对应的Bean的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties 配置属性集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;String&gt; <span class="title">resolveMultipleBeanNames</span><span class="params">(Map&lt;String, Object&gt; properties)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; beanNames = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String propertyName : properties.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 获取$&#123;beanName&#125; 字符串</span></span><br><span class="line">            <span class="keyword">int</span> index = propertyName.indexOf(<span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                String beanName = propertyName.substring(<span class="number">0</span>, index);</span><br><span class="line"></span><br><span class="line">                beanNames.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得配置类对应的Bean 名称</span></span><br><span class="line"><span class="comment">     * 例如： dubbo.application.name=dubbo-demo-annotation-provider</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">resolveSingleBeanName</span><span class="params">(Map&lt;String, Object&gt; properties, Class&lt;? extends AbstractConfig&gt; configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Bean的名称</span></span><br><span class="line">        String beanName = (String) properties.get(<span class="string">"id"</span>);</span><br><span class="line">        <span class="comment">// 没有没有定义，就基于Spring提供的机制生成对应的Bean的名字。 如： org.apache.dubbo.config.ApplicationConfig#0</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            BeanDefinitionBuilder builder = rootBeanDefinition(configClass);</span><br><span class="line">            beanName = BeanDefinitionReaderUtils.generateBeanName(builder.getRawBeanDefinition(), registry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出，配置用于多个Bean的时候Bean的名称直接从配置属性值中获取，即获取${beanName} 的值作为Bean名称，Bean的名称可能会有多个。配置用于单个Bean的时候Bean的名称先尝试使用id属性值，没有配置id属性就自动生成。这两种情况可能一下子不好理解，下文还会详细说明。上面的过程中Bean定义是注册到了注册表中，但是Bean的属性还没有设置，下面我们来分析 DubboConfigBindingBeanPostProcessor 是如何进行属性绑定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dubbo Config Binding &#123;<span class="doctag">@link</span> BeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingRegistrar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 处理Dubbo AbstractConfig Bean的配置属性注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性配置前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Binding Bean Name  // Bean的名字，每个配置类的Bean都有自己的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 配置属性绑定器 ，用来绑定配置属性到Dubbo Config中 （内部使用Spring DataBinder完成属性绑定）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DubboConfigBinder dubboConfigBinder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否忽略未知的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ignoreUnknownFields = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否忽略类型不对的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ignoreInvalidFields = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，属性前缀和配置类的Bean是通过构造方法传入进来的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix   the prefix of Configuration Properties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName the binding Bean Name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboConfigBindingBeanPostProcessor</span><span class="params">(String prefix, String beanName)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(prefix, <span class="string">"The prefix of Configuration Properties must not be null"</span>);</span><br><span class="line">        Assert.notNull(beanName, <span class="string">"The name of bean must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">        <span class="keyword">this</span>.beanName = beanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean后处理器的 前置处理方法。将配置属性绑定到Dubbo Config中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 选择bean的名称是 this.beanName【针对注解机制创建Bean定义，其他方式创建的Bean定义不符合条件】，并且是AbstractConfig类型的 Bean定义</span></span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="keyword">this</span>.beanName) &amp;&amp; bean <span class="keyword">instanceof</span> AbstractConfig) &#123;</span><br><span class="line"></span><br><span class="line">            AbstractConfig dubboConfig = (AbstractConfig) bean;</span><br><span class="line">            <span class="comment">// 设置prefix开头的配置属性到 DubboConfig中</span></span><br><span class="line">            dubboConfigBinder.bind(prefix, dubboConfig);</span><br><span class="line">            <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(<span class="string">"The properties of bean [name : "</span> + beanName + <span class="string">"] have been binding by prefix of "</span> +</span><br><span class="line">                        <span class="string">"configuration properties : "</span> + prefix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean后处理器的后置处理方法，这里直接返回Dubbo Config的Bean对象，不做其他的处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 Dubbo 配置属性绑定器，注意它的触发时机。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得DubboConfigBinder对象</span></span><br><span class="line">        <span class="keyword">if</span> (dubboConfigBinder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dubboConfigBinder = applicationContext.getBean(DubboConfigBinder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException ignored) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(<span class="string">"DubboConfigBinder Bean can't be found in ApplicationContext."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Use Default implementation // 创建默认的配置绑定器</span></span><br><span class="line">                dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 是否忽略未知/无效的属性</span></span><br><span class="line">        dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields);</span><br><span class="line">        dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create &#123;<span class="doctag">@link</span> DubboConfigBinder&#125; instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> DefaultDubboConfigBinder&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DubboConfigBinder <span class="title">createDubboConfigBinder</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建DefaultDubboConfigBinder对象</span></span><br><span class="line">        DefaultDubboConfigBinder defaultDubboConfigBinder = <span class="keyword">new</span> DefaultDubboConfigBinder();</span><br><span class="line">        <span class="comment">// 设置environment属性</span></span><br><span class="line">        defaultDubboConfigBinder.setEnvironment(environment);</span><br><span class="line">        <span class="keyword">return</span> defaultDubboConfigBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIgnoreUnknownFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ignoreUnknownFields;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIgnoreUnknownFields</span><span class="params">(<span class="keyword">boolean</span> ignoreUnknownFields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ignoreUnknownFields = ignoreUnknownFields;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIgnoreInvalidFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ignoreInvalidFields;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIgnoreInvalidFields</span><span class="params">(<span class="keyword">boolean</span> ignoreInvalidFields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ignoreInvalidFields = ignoreInvalidFields;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DubboConfigBinder <span class="title">getDubboConfigBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dubboConfigBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDubboConfigBinder</span><span class="params">(DubboConfigBinder dubboConfigBinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboConfigBinder = dubboConfigBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo Config的属性绑定后置处理器逻辑不算复杂，就是从Spring环境中获取配置属性，然后利用Spring的数据绑定器DataBinder完成Dubbo Config的Bean属性的绑定，逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default &#123;<span class="doctag">@link</span> DubboConfigBinder&#125; implementation based on Spring &#123;<span class="doctag">@link</span> DataBinder&#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 使用Spring DataBinder，将配置属性设置到Dubbo Config对象中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDubboConfigBinder</span> <span class="keyword">extends</span> <span class="title">AbstractDubboConfigBinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;C extends AbstractConfig&gt; <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(String prefix, C dubboConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将Dubbo Config包装成 DataBinder对象</span></span><br><span class="line">        DataBinder dataBinder = <span class="keyword">new</span> DataBinder(dubboConfig);</span><br><span class="line">        <span class="comment">// 是否忽略无效和未知属性</span></span><br><span class="line">        dataBinder.setIgnoreInvalidFields(isIgnoreInvalidFields());</span><br><span class="line">        dataBinder.setIgnoreUnknownFields(isIgnoreUnknownFields());</span><br><span class="line">        <span class="comment">// 从PropertySources中获取prefix开头的配置属性 [getPropertySources() : 系统属性，系统环境和@ProperSources的属性k-v]</span></span><br><span class="line">        Map&lt;String, Object&gt; properties = getSubProperties(getPropertySources(), prefix);</span><br><span class="line">        <span class="comment">// 根据配置属性集合 创建 MutablePropertyValues对象</span></span><br><span class="line">        MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues(properties);</span><br><span class="line">        <span class="comment">// 绑定配置属性到 Dubbo的配置对象中</span></span><br><span class="line">        dataBinder.bind(propertyValues);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring的后置处理器的方法中会调用 DefaultDubboConfigBinder#bind方法进行Dubbo Config的Bean的属性设置，本质是使用Spring的DataBinder完成属性设置。至此，<code>@EnableDubboConfigBindings</code>涉及的处理逻辑分析完毕，这个过程创建了Dubbo Config的Bean，并且创建了该Bean对应的属性绑定Bean后置处理器，在Spring的生命周期中该Bean后置处理器会回调对应的方法以完成属性的绑定。接下来我们再来分析 <code>@EnableDubboConfigBinding</code> 注解，该注解是 <code>@EnableDubboConfigBindings</code> 注解的属性数组的类型， <code>@EnableDubboConfigBindings</code> 注解的逻辑处理基本就是  <code>@EnableDubboConfigBinding</code> 注解的逻辑处理。</p><h4 id="EnableDubboConfigBinding-注解"><a href="#EnableDubboConfigBinding-注解" class="headerlink" title="@EnableDubboConfigBinding 注解"></a><code>@EnableDubboConfigBinding</code> 注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enables Spring's annotation-driven &#123;<span class="doctag">@link</span> AbstractConfig Dubbo Config&#125; from &#123;<span class="doctag">@link</span> PropertySources properties&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Default , &#123;<span class="doctag">@link</span> #prefix()&#125; associates with a prefix of &#123;<span class="doctag">@link</span> PropertySources properties&#125;, e,g. "dubbo.application."</span></span><br><span class="line"><span class="comment"> * or "dubbo.application"</span></span><br><span class="line"><span class="comment"> * &lt;pre class="code"&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingRegistrar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBindings</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(DubboConfigBindingRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableDubboConfigBinding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置属性的前缀，用于映射到 AbstractConfig 中的属性</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The name prefix of the properties that are valid to bind to &#123;<span class="doctag">@link</span> AbstractConfig Dubbo Config&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the name prefix of the properties to bind</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo Config 配置类，这是一个约定，Dubbo Config配置类有哪些是固定的，这个配置必须是AbstractConfig的实现子类。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The binding type of &#123;<span class="doctag">@link</span> AbstractConfig Dubbo Config&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AbstractConfig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ApplicationConfig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ModuleConfig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> RegistryConfig</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends AbstractConfig&gt; type();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持配置用于多个Bean</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * It indicates whether &#123;<span class="doctag">@link</span> #prefix()&#125; binding to multiple Spring Beans.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the default value is &lt;code&gt;false&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">multiple</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解有三个属性，每个属性的作用已经注释过了，我们直接来看 <code>@Import(DubboConfigBindingRegistrar.class)</code>，DubboConfigBindingRegistrar的主要逻辑已经在上面分析过了，我们在简单看下没有分析到的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AbstractConfig Dubbo Config&#125; binding Bean registrar</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 处理 <span class="doctag">@EnableDubboConfigBinding</span> 注解，注册相应的 Dubbo AbstractConfig 到Spring 容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 @EnableDubboConfigBinding注解信息</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBinding<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 根据 @EnableDubboConfigBinding注解信息 注册配置对应的 BeanDefinition 对象</span></span><br><span class="line">        registerBeanDefinitions(attributes, registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<code>@EnableDubboConfig</code> 注解已经分析完了，该注解就是用于开启Dubbo的配置，创建Dubbo框架内置的配置类的Bean，并且创建配置类的Bean对应的属性绑定Bean后置处理器，Spring应用上下文启动后，就可以实现配置对象的创建与初始化。但是需要注意的是，并不是指定了配置类就会创建对应的Bean，只有当规约的外部配置存在时，配置类才会提升为Spring Bean。</p><h4 id="Dubbo配置Bean绑定及自定义配置Bean绑定"><a href="#Dubbo配置Bean绑定及自定义配置Bean绑定" class="headerlink" title="Dubbo配置Bean绑定及自定义配置Bean绑定"></a>Dubbo配置Bean绑定及自定义配置Bean绑定</h4><p>这块内容还是不少的，这里就不详细说明了。我们直接看 Dubbo PMC 的文章 <a href="https://segmentfault.com/a/1190000012661402#articleHeader4" target="_blank" rel="noopener">Dubbo 新编程模型之外部化配置</a>，里面详细介绍了多配置Bean的属性绑定以及自定义Bean的属性绑定。</p><h3 id="DubboComponentScan-注解"><a href="#DubboComponentScan-注解" class="headerlink" title="@DubboComponentScan 注解"></a>@DubboComponentScan 注解</h3><p>该注解用于配置要扫描 <code>@Service</code> 和 <code>@Reference</code> 注解的包或类，进而创建对应的Bean对象。注解扫描是委托给Spring的，本质上使用ASM库进行字节码扫描注解元数据。当用户使用注解 <code>@DubboComponentScan</code> 时，会激活 <code>DubboComponentScanRegistrar</code>，这个类就是实现服务提供者通过注解 <code>@Service</code> 进行服务暴露的，对消费者通过注解 <code>@Reference</code> 进行服务引用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dubbo Component Scan &#123;<span class="doctag">@link</span> Annotation&#125;,scans the classpath for annotated components that will be auto-registered as</span></span><br><span class="line"><span class="comment"> * Spring beans. Dubbo-provided &#123;<span class="doctag">@link</span> Service&#125; and &#123;<span class="doctag">@link</span> Reference&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Reference</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(DubboComponentScanRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">DubboComponentScan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alias for the &#123;<span class="doctag">@link</span> #basePackages()&#125; attribute. Allows for more concise annotation</span></span><br><span class="line"><span class="comment">     * declarations e.g.: &#123;<span class="doctag">@code</span> <span class="doctag">@DubboComponentScan</span>("org.my.pkg")&#125; instead of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@DubboComponentScan</span>(basePackages="org.my.pkg")&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 和 basePackages 等价</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base packages to scan for annotated <span class="doctag">@Service</span> classes. &#123;<span class="doctag">@link</span> #value()&#125; is an</span></span><br><span class="line"><span class="comment">     * alias for (and mutually exclusive with) this attribute.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Use &#123;<span class="doctag">@link</span> #basePackageClasses()&#125; for a type-safe alternative to String-based</span></span><br><span class="line"><span class="comment">     * package names.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 要扫描包的数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages()&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment">     * scan for annotated <span class="doctag">@Service</span> classes. The package of each class specified will be</span></span><br><span class="line"><span class="comment">     * scanned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> classes from the base packages to scan</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 要扫描的类的数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解的属性作用已经注释，我们重点关注下@Import的value属性值 <code>DubboComponentScanRegistrar</code> ，它用于处理DubboComponentScan注解，为Spring容器注册ServiceAnnotation和ReferenceAnnotation的Bean后置处理器，进而创建ServiceBean和ReferenceBean对象。下面我们就来详细分析Dubbo注解实现的这个核心类。</p><h4 id="DubboComponentScanRegistrar"><a href="#DubboComponentScanRegistrar" class="headerlink" title="DubboComponentScanRegistrar"></a>DubboComponentScanRegistrar</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dubbo &#123;<span class="doctag">@link</span> DubboComponentScan&#125; Bean Registrar</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboComponentScan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ServiceAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ReferenceAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.7</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> importingClassMetadata <span class="doctag">@DubboComponentScan</span> 注解的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry               Bean定义注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 获得要扫描的包</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2. 创建 ServiceAnnotationBeanPostProcessor Bean 对象，后续扫描 `<span class="doctag">@Service</span>` 注解的类，创建对应的 Service Bean 对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        registerServiceAnnotationBeanPostProcessor(packagesToScan, registry);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3. 创建 ReferenceAnnotationBeanPostProcessor Bean 对象，后续扫描 `<span class="doctag">@Reference</span>` 注解的类，创建对应的 Reference Bean 对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        registerReferenceAnnotationBeanPostProcessor(registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// $&#123;省略其他的代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DubboComponentScanRegistrar 实现 ImportBeanDefinitionRegistrar接口，用来处理 @DubboComponentScan注解，注册 ServiceAnnotationBeanPostProcessor 和 ReferenceAnnotationBeanPostProcessor 到Spring容器，Spring应用上下文启动后，就可以实现Service Bean对象和Reference Bean对象的创建。下面我们依次分析以上三个步骤的具体逻辑。</p><h4 id="获取要扫描的包"><a href="#获取要扫描的包" class="headerlink" title="获取要扫描的包"></a>获取要扫描的包</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得 DubboComponentScan注解扫描的包</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadata</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;String&gt; <span class="title">getPackagesToScan</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 @DubboComponentScan 注解</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(DubboComponentScan<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">// 获得basePackages 属性值</span></span><br><span class="line">        String[] basePackages = attributes.getStringArray(<span class="string">"basePackages"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得basePackageClasses属性值</span></span><br><span class="line">        Class&lt;?&gt;[] basePackageClasses = attributes.getClassArray(<span class="string">"basePackageClasses"</span>);</span><br><span class="line">        <span class="comment">// 获得默认属性（basePackages的默认属性）</span></span><br><span class="line">        String[] value = attributes.getStringArray(<span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">// 将属性添加到 packagesToScan 集合中</span></span><br><span class="line">        Set&lt;String&gt; packagesToScan = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(Arrays.asList(value));</span><br><span class="line">        packagesToScan.addAll(Arrays.asList(basePackages));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 扫描的类的数组 ，得到每个类的包名，然后添加到 包路径数组中</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; basePackageClass : basePackageClasses) &#123;</span><br><span class="line">            packagesToScan.add(ClassUtils.getPackageName(basePackageClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// packagesToScan 为空的话，则默认使用DubboComponentScan注解类所在的包做为扫描包</span></span><br><span class="line">        <span class="keyword">if</span> (packagesToScan.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.singleton(ClassUtils.getPackageName(metadata.getClassName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> packagesToScan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取要扫描的包逻辑还是很直观的，将配置的扫描包路径和配置的扫描类对应的包路径聚合在一起作为目标包路径，需要注意的是当配置扫描类时需要获取扫描类的包名，即还是会转为包扫描。如果没有配置扫描包及扫描类，那么就是使用DubboComponentScan注解类所在的包做为扫描包。</p><h4 id="创建扫描-Service-注解的后置处理器"><a href="#创建扫描-Service-注解的后置处理器" class="headerlink" title="创建扫描 @Service 注解的后置处理器"></a>创建扫描 @Service 注解的后置处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Registers &#123;<span class="doctag">@link</span> ServiceAnnotationBeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> packagesToScan packages to scan without resolving placeholders</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> registry       &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment">      * &lt;p&gt;</span></span><br><span class="line"><span class="comment">      * 创建 ServiceAnnotationBeanPostProcessor Bean 对象，后续扫描 <span class="doctag">@Service</span> 注解的类，创建对应的 Service Bean 对象</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceAnnotationBeanPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 创建ServiceAnnotationBeanPostProcessor的BeanDefinitionBuilder 对象</span></span><br><span class="line">         BeanDefinitionBuilder builder = rootBeanDefinition(ServiceAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">         <span class="comment">// 设置构造方法参数为 packagesToScan</span></span><br><span class="line">         builder.addConstructorArgValue(packagesToScan);</span><br><span class="line">         <span class="comment">// 设置 role 属性</span></span><br><span class="line">         builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">         <span class="comment">// 获得 AbstractBeanDefinition 对象</span></span><br><span class="line">         AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">         <span class="comment">// 注册到注册表中</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建扫描 @Service 注解的类的后置处理器逻辑很简单，就是创建一个Bean定义然后注册到注册表中。下面我们重点分析这个后置处理的逻辑，看它是如何将 <code>@Service</code> 标注的类提升为Spring Bean的。</p><h4 id="ServiceAnnotationBeanPostProcessor"><a href="#ServiceAnnotationBeanPostProcessor" class="headerlink" title="ServiceAnnotationBeanPostProcessor"></a>ServiceAnnotationBeanPostProcessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Service&#125; Annotation</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor Bean Definition Registry Post Processor&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要扫描的包的集合，通过构造方法进行设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; packagesToScan;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceAnnotationBeanPostProcessor</span><span class="params">(String... packagesToScan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Arrays.asList(packagesToScan));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceAnnotationBeanPostProcessor</span><span class="params">(Collection&lt;String&gt; packagesToScan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> LinkedHashSet&lt;String&gt;(packagesToScan));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceAnnotationBeanPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.packagesToScan = packagesToScan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略其他逻辑代码&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ServiceAnnotationBeanPostProcessor 实现 BeanDefinitionRegistryPostProcessor、EnvironmentAware、ResourceLoaderAware、BeanClassLoaderAware 接口，具备了Spring的特定功能，如Spring容器中所有Bean注册之后回调 <code>postProcessBeanDefinitionRegistry</code> 方法。该类主要是将 <code>@Service</code> 标注的类提升为Spring Bean，主要的逻辑如下：</p><ol><li>解析扫描包集合，处理存在占位符的包名。</li><li>创建DubboClassPathBeanDefinitionScanner对象，用于扫描指定包下的 @Service 标注的类并注册该类的Bean定义到注册表。</li><li>为每个@Service标注的类创建对应的 ServiceBean，并注册到注册表。</li></ol><p><strong>解析扫描包集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry 注册表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 解析 packagesToScan集合，包名可能存在占位符的情况</span></span><br><span class="line">        Set&lt;String&gt; resolvedPackagesToScan = resolvePackagesToScan(packagesToScan);</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(resolvedPackagesToScan)) &#123;</span><br><span class="line">            <span class="comment">// 扫描 packagesToScan 包，创建对应的 Spring BeanDefinition 对象，从而触发 Dubbo ServiceBean 定义和注册</span></span><br><span class="line">            registerServiceBeans(resolvedPackagesToScan, registry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"packagesToScan is empty , ServiceBean registry will be ignored!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要处理包名存在占位符的情况，同时上面的方法也是Spring的Bean后处理器的回调方法，在Spring的生命周期内进行回调。接下我们看扫描Dubbo的 <code>@Service</code> 注解的逻辑。</p><p><strong>扫描Dubbo的 <code>@Service</code> 注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 扫描 packagesToScan 包，创建对应的 Spring BeanDefinition 对象，从而创建 Dubbo Service Bean 对象</span></span><br><span class="line"><span class="comment">      * &lt;p&gt;</span></span><br><span class="line"><span class="comment">      * Registers Beans whose classes was annotated &#123;<span class="doctag">@link</span> Service&#125;</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> packagesToScan 要扫描的包集合</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> registry      注册表</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBeans</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 创建 Dubbo的类路径Bean定义扫描对象，该类继承了Spring的 ClassPathBeanDefinitionScanner，即用于扫描指定包下符合条件的类，将符合条件的类创建对应的BeanDefinition对象</span></span><br><span class="line">         DubboClassPathBeanDefinitionScanner scanner = <span class="keyword">new</span> DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 获得 BeanNameGenerator 对象，并设置 beanNameGenerator 到 scanner 中</span></span><br><span class="line">         BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);</span><br><span class="line">         scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 指定扫描器扫描带有Dubbo的@Service注解的类，不会扫描Spring的@Service注解</span></span><br><span class="line">         scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(Service<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 遍历扫描的包集合</span></span><br><span class="line">         <span class="keyword">for</span> (String packageToScan : packagesToScan) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 执行扫描，并注册目标类的Bean定义到注册表，使用beanNameGenerator生成Bean的名称</span></span><br><span class="line">             scanner.scan(packageToScan);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 创建每个被扫描的类的BeanDefinitionHolder对象，返回BeanDefinitionHolder集合，用于生成ServiceBean定义【注意，这里也会创建扫描的类的Bean定义，也是使用 beanNameGenerator 生成名称，但没有注册到注册表】</span></span><br><span class="line">             Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders = findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);</span><br><span class="line"> </span><br><span class="line">             <span class="comment">// 为每个@Service标注的类创建对应的 ServiceBean，并注册到注册表。</span></span><br><span class="line">             <span class="keyword">if</span> (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123;</span><br><span class="line">                     registerServiceBean(beanDefinitionHolder, registry, scanner);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                     logger.info(beanDefinitionHolders.size() + <span class="string">" annotated Dubbo's @Service Components &#123; "</span> +</span><br><span class="line">                             beanDefinitionHolders +</span><br><span class="line">                             <span class="string">" &#125; were scanned under package["</span> + packageToScan + <span class="string">"]"</span>);</span><br><span class="line">                 &#125;</span><br><span class="line"> </span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                     logger.warn(<span class="string">"No Spring Bean annotating Dubbo's @Service was found under package["</span></span><br><span class="line">                             + packageToScan + <span class="string">"]"</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码主要做了四件事情，如下：</p><ol><li>创建类路径扫描器 DubboClassPathBeanDefinitionScanner，指定扫描的注解包含Dubbo的@Service注解。</li><li>获取BeanNameGenerator对象，用于 @Service 标注类的Bean定义名称。</li><li>使用扫描器扫描包，提升@Service标注的类为Spring Bean，并注册到注册表中。</li><li>获取第3步的Spring Bean的BeanDefinitionHolder集合，将用于创建Dubbo的ServiceBean对象。</li></ol><p>代码中的主要逻辑已经详细标注，胖友自己瞅瞅，下面我们简单分析下扫描器的原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">ClassPathBeanDefinitionScanner#scan(String... basePackages) &#123;</span><br><span class="line">    <span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">// 扫描逻辑                                                                      </span></span><br><span class="line">    doScan(basePackages);                                                       </span><br><span class="line">    <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">       &#125;                                                               </span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 扫描包逻辑</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">     Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        <span class="comment">// 从包中获取候选BeanDefinition</span></span><br><span class="line">     Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">   <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">  ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">  candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">              <span class="comment">// 使用beanNameGenerator 生成BeanDefinition的名称</span></span><br><span class="line">   String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">   <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">  postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">  AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">    &#125;</span><br><span class="line">               <span class="comment">// 是否是候选BeanDefinition</span></span><br><span class="line">    <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">  BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">  definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">  beanDefinitions.add(definitionHolder);</span><br><span class="line">                 <span class="comment">// 注册到注册表</span></span><br><span class="line">  registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从包中获取BeanDefinition集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">  * Scan the class path for candidate components.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> basePackage the package to check for annotated classes</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> a corresponding Set of autodetected bean definitions</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line"> Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinition&gt;();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 类路径下的指定包下的所有.class文件 （如：classpath*:com/code/resource/reading/consumer/annotation/consumer/**/*.class）</span></span><br><span class="line"> String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line"> Resource[] resources = <span class="keyword">this</span>.resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line"> <span class="keyword">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line"> <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"> <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line"> <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line"> logger.trace(<span class="string">"Scanning "</span> + resource);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> MetadataReader metadataReader = <span class="keyword">this</span>.metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                         <span class="comment">// 是否是候选 BeanDefinition</span></span><br><span class="line"> <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                            <span class="comment">// 创建 BeanDefinition</span></span><br><span class="line"> ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line"> sbd.setResource(resource);</span><br><span class="line"> sbd.setSource(resource);</span><br><span class="line"> <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line"> <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line"> logger.debug(<span class="string">"Identified candidate component class: "</span> + resource);</span><br><span class="line"> &#125;</span><br><span class="line"> candidates.add(sbd);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line"> logger.debug(<span class="string">"Ignored because not a concrete top-level class: "</span> + resource);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line"> logger.trace(<span class="string">"Ignored because not matching any filter: "</span> + resource);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"> <span class="string">"Failed to read candidate component class: "</span> + resource, ex);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line"> logger.trace(<span class="string">"Ignored because not readable: "</span> + resource);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> candidates;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们只要大致了解下扫描器是怎么把指定包下的注解标注的类提升为Spring Bean就可以了。有了目标类的Bean定义，接下来我们分析Dubbo是如何创建该目标类对应的ServiceBean对象的。</p><p><strong>创建ServiceBean并注册到注册表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers &#123;<span class="doctag">@link</span> ServiceBean&#125; from new annotated &#123;<span class="doctag">@link</span> Service&#125; &#123;<span class="doctag">@link</span> BeanDefinition&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinitionHolder <span class="doctag">@Service</span>标注的类的BeanDefinitionHolder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry             注册表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scanner              扫描器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ServiceBean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BeanDefinition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBean</span><span class="params">(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     DubboClassPathBeanDefinitionScanner scanner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从holder中取出BeanDefinition，并解析出对应的类</span></span><br><span class="line">        Class&lt;?&gt; beanClass = resolveClass(beanDefinitionHolder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得@Service 注解</span></span><br><span class="line">        Service service = findAnnotation(beanClass, Service<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得注解标注类的接口</span></span><br><span class="line">        Class&lt;?&gt; interfaceClass = resolveServiceInterfaceClass(beanClass, service);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得Bean的名字</span></span><br><span class="line">        String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  创建AbstractBeanDefinition 对象 ，这里真正创建ServiceBean</span></span><br><span class="line">        AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新生成Bean 的名字 【格式：ServiceBean:$&#123;interfaceClassName&#125;:$&#123;version&#125;:$&#123;group&#125;】，重新创建的ServiceBean名称是把上面的BeanDefinition注册到注册表中，需要一个名称</span></span><br><span class="line">        String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验在 注册表 中是否已经存在beanName，若不存在则进行注册</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.checkCandidate(beanName, serviceBeanDefinition)) &#123; </span><br><span class="line">            <span class="comment">// 注册</span></span><br><span class="line">            registry.registerBeanDefinition(beanName, serviceBeanDefinition);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"The BeanDefinition["</span> + serviceBeanDefinition +</span><br><span class="line">                        <span class="string">"] of ServiceBean has been registered with name : "</span> + beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"The Duplicated BeanDefinition["</span> + serviceBeanDefinition +</span><br><span class="line">                        <span class="string">"] of ServiceBean[ bean name : "</span> + beanName +</span><br><span class="line">                        <span class="string">"] was be found , Did @DubboComponentScan scan to same package in many times?"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法主要是为创建ServiceBean提供条件，如：获取Dubbo的@Service标注类的Class及接口、获取@Service信息、获取Dubbo的@Service标注类的Bean定义的名称。有了这些信息，就可以创建目标服务类（Dubbo的@Service标注的类）的ServiceBean。在分析创建ServiceBean之前，我们先来看下目标服务类的接口获取逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得<span class="doctag">@Service</span> 注解的类的接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotatedServiceBeanClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; resolveServiceInterfaceClass(Class&lt;?&gt; annotatedServiceBeanClass, Service service) &#123;</span><br><span class="line">        <span class="comment">// 从注解属性中获取</span></span><br><span class="line">        Class&lt;?&gt; interfaceClass = service.interfaceClass();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">interfaceClass</span>)) </span>&#123;</span><br><span class="line">            interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获得@Service 注解的interfaceName 属性</span></span><br><span class="line">            String interfaceClassName = service.interfaceName();</span><br><span class="line">            <span class="comment">// 如果存在，获得其对应的类</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(interfaceClassName)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ClassUtils.isPresent(interfaceClassName, classLoader)) &#123;</span><br><span class="line">                    interfaceClass = resolveClassName(interfaceClassName, classLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从注解属性中获得不到，则从被注解的类上获得其实现的第一个接口</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取接口列表</span></span><br><span class="line">            Class&lt;?&gt;[] allInterfaces = annotatedServiceBeanClass.getInterfaces();</span><br><span class="line">            <span class="comment">// 存在的话取第一个接口</span></span><br><span class="line">            <span class="keyword">if</span> (allInterfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                interfaceClass = allInterfaces[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(interfaceClass,<span class="string">"@Service interfaceClass() or interfaceName() or interface class must be present!"</span>);</span><br><span class="line">        Assert.isTrue(interfaceClass.isInterface(),<span class="string">"The type that was annotated @Service is not an interface!"</span>);</span><br><span class="line">        <span class="keyword">return</span> interfaceClass;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取目标服务类的接口规则是先从@Service注解属性中取，没有设置再获取目标服务类的第一个实现接口。下面我们来分析下ServiceBean的定义如何生成，可以对比下XML配置的生成规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建AbstraceBeanDefinition对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service                  <span class="doctag">@Service</span> 注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaceClass           目标服务类的接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotatedServiceBeanName 目标服务类的Bean定义的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">buildServiceBeanDefinition</span><span class="params">(Service service, Class&lt;?&gt; interfaceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              String annotatedServiceBeanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ServiceBean的BeanDefinitionBuilder对象</span></span><br><span class="line">        BeanDefinitionBuilder builder = rootBeanDefinition(ServiceBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得ServiceBean的AbstractBeanDefinition 对象</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 MutablePropertyValues对象，后续可以通过它为ServiceBean添加属性</span></span><br><span class="line">        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建AnnotationPropertyValuesAdapter 对象，添加到propertyValues中。注意是将注解上的属性设置到PropertyValues中，并且指定哪些属性要忽略。被忽略的属性会单独设置。</span></span><br><span class="line">        String[] ignoreAttributeNames = of(<span class="string">"provider"</span>, <span class="string">"monitor"</span>, <span class="string">"application"</span>, <span class="string">"module"</span>, <span class="string">"registry"</span>, <span class="string">"protocol"</span>, <span class="string">"interface"</span>);</span><br><span class="line">        propertyValues.addPropertyValues(<span class="keyword">new</span> AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置ServiceBean ref 属性，即@Service标注的类的Bean定义名称</span></span><br><span class="line">        addPropertyReference(builder, <span class="string">"ref"</span>, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置ServiceBean的 interface 属性</span></span><br><span class="line">        builder.addPropertyValue(<span class="string">"interface"</span>, interfaceClass.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加ServiceBean的 provider 属性</span></span><br><span class="line">        String providerConfigBeanName = service.provider();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(providerConfigBeanName)) &#123;</span><br><span class="line">            addPropertyReference(builder, <span class="string">"provider"</span>, providerConfigBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 添加ServiceBean的monitor属性</span></span><br><span class="line">        String monitorConfigBeanName = service.monitor();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(monitorConfigBeanName)) &#123;</span><br><span class="line">            addPropertyReference(builder, <span class="string">"monitor"</span>, monitorConfigBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加ServiceBean 的 application 属性</span></span><br><span class="line">        String applicationConfigBeanName = service.application();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(applicationConfigBeanName)) &#123;</span><br><span class="line">            addPropertyReference(builder, <span class="string">"application"</span>, applicationConfigBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 添加ServiceBean的 module 属性对应的 ModuleConfig Bean 对象</span></span><br><span class="line">        String moduleConfigBeanName = service.<span class="keyword">module</span>();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(moduleConfigBeanName)) &#123;</span><br><span class="line">            addPropertyReference(builder, <span class="string">"module"</span>, moduleConfigBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//-------------- 下面两个属性和上面的不一样，因为可能会有多个 ，即多注册中心，多协议的情况-------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加ServiceBean的 registries 属性</span></span><br><span class="line">        String[] registryConfigBeanNames = service.registry();</span><br><span class="line">        List&lt;RuntimeBeanReference&gt; registryRuntimeBeanReferences = toRuntimeBeanReferences(registryConfigBeanNames);</span><br><span class="line">        <span class="keyword">if</span> (!registryRuntimeBeanReferences.isEmpty()) &#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">"registries"</span>, registryRuntimeBeanReferences);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加ServiceBean的 protocols 属性</span></span><br><span class="line">        String[] protocolConfigBeanNames = service.protocol();</span><br><span class="line">        List&lt;RuntimeBeanReference&gt; protocolRuntimeBeanReferences = toRuntimeBeanReferences(protocolConfigBeanNames);</span><br><span class="line">        <span class="keyword">if</span> (!protocolRuntimeBeanReferences.isEmpty()) &#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">"protocols"</span>, protocolRuntimeBeanReferences);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.getBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是为ServiceBean设置简单属性值和引用类型的值，当ServiceBean的属性是引用类型时，解析器会依据依赖bean的name创建一个RuntimeBeanReference对像，将这个对像放入ServiceBean的BeanDefinition的MutablePropertyValues中。ServiceBean的Bean定义创建完成后，接着就把该Bean定义注册到注册表中。至此，扫描 <code>@Service</code> 注解的Bean后置处理器逻辑已经分析完毕。下面我们开始分析扫描 <code>@Reference</code> 注解的后置处理器。</p><h4 id="创建扫描-Reference-注解的后置处理器"><a href="#创建扫描-Reference-注解的后置处理器" class="headerlink" title="创建扫描 @Reference 注解的后置处理器"></a>创建扫描 @Reference 注解的后置处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers &#123;<span class="doctag">@link</span> ReferenceAnnotationBeanPostProcessor&#125; into &#123;<span class="doctag">@link</span> BeanFactory&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerReferenceAnnotationBeanPostProcessor</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register @Reference Annotation Bean Processor</span></span><br><span class="line">        BeanRegistrar.registerInfrastructureBean(registry, ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建扫描 <code>@Reference</code> 注解的后置处理器需要注意该Bean定义的名称是 <code>referenceAnnotationBeanPostProcessor</code>，是常量维护的。下面我们开始分析ReferenceAnnotationBeanPostProcessor的逻辑，看它又是如何为 <code>@Reference</code> 注解的属性或方法引入代理对象。</p><h4 id="ReferenceAnnotationBeanPostProcessor"><a href="#ReferenceAnnotationBeanPostProcessor" class="headerlink" title="ReferenceAnnotationBeanPostProcessor"></a>ReferenceAnnotationBeanPostProcessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor&#125; implementation</span></span><br><span class="line"><span class="comment"> * that Consumer service &#123;<span class="doctag">@link</span> Reference&#125; annotated fields</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">AnnotationInjectedBeanPostProcessor</span>&lt;<span class="title">Reference</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bean name of &#123;<span class="doctag">@link</span> ReferenceAnnotationBeanPostProcessor&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"referenceAnnotationBeanPostProcessor"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cache size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE = Integer.getInteger(BEAN_NAME + <span class="string">".cache.size"</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ReferenceBean 缓存 Map,key:Reference Bean 的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ReferenceBean&lt;?&gt;&gt; referenceBeanCache = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ReferenceBeanInvocationHandler 缓存 Map，key：Reference Bean的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ReferenceBeanInvocationHandler&gt; localReferenceBeanInvocationHandlerCache = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ReferenceBeanInvocationHandler&gt;(CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用属性进行注入的 <span class="doctag">@Reference</span> Bean 的缓存 Map。（这种方式使用的较多）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; injectedFieldReferenceBeanCache = <span class="keyword">new</span> ConcurrentHashMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用方法进行注入的 <span class="doctag">@Reference</span> Bean 的缓存 Map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; injectedMethodReferenceBeanCache = <span class="keyword">new</span> ConcurrentHashMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets all beans of &#123;<span class="doctag">@link</span> ReferenceBean&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null read-only &#123;<span class="doctag">@link</span> Collection&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5.9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;ReferenceBean&lt;?&gt;&gt; getReferenceBeans() &#123;</span><br><span class="line">        <span class="keyword">return</span> referenceBeanCache.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get &#123;<span class="doctag">@link</span> ReferenceBean&#125; &#123;<span class="doctag">@link</span> Map&#125; in injected field.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null &#123;<span class="doctag">@link</span> Map&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5.11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; getInjectedFieldReferenceBeanMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(injectedFieldReferenceBeanCache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get &#123;<span class="doctag">@link</span> ReferenceBean&#125; &#123;<span class="doctag">@link</span> Map&#125; in injected method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null &#123;<span class="doctag">@link</span> Map&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5.11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; getInjectedMethodReferenceBeanMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(injectedMethodReferenceBeanCache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是扫描 <code>@Reference</code> 注解的后置处理器的属性信息，该类继承了AnnotationInjectedBeanPostProcessor抽象类，该类中有几个很重要的方法和类，它们属于Spring源码的知识点，为了使整个逻辑完整我们还是一起来看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationInjectedBeanPostProcessor</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> <span class="keyword">implements</span> <span class="title">MergedBeanDefinitionPostProcessor</span>, <span class="title">PriorityOrdered</span>,</span></span><br><span class="line"><span class="class">        <span class="title">BeanFactoryAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略其他的代码&#125;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1. Bean后置处理器的回调方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取BeanType中的字段和方法上的注解，即对于Dubbo框架来说就是查找Bean所有标注了@Reference的字段和方法。</span></span><br><span class="line">            InjectionMetadata metadata = findInjectionMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">            metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 创建Bean对象的过程中需要填充Bean对象的属性值，会调用该方法。即在Spring的Bean初始化前会触发该方法。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Bean对象的类中的字段和方法的注解对象 - AnnotatedInjectionMetadata，即对于Dubbo框架来说就是查找Bean所有标注了@Reference的字段和方法。</span></span><br><span class="line">        InjectionMetadata metadata = findInjectionMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用AnnotatedInjectionMetadata的inject方法，对字段或方法进行反射绑定</span></span><br><span class="line">            metadata.inject(bean, beanName, pvs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of @"</span> + getAnnotationType().getName()</span><br><span class="line">                    + <span class="string">" dependencies is failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4. 属性和方法注解包装对象</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> A&#125; &#123;<span class="doctag">@link</span> InjectionMetadata&#125; implementation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedInjectionMetadata</span> <span class="keyword">extends</span> <span class="title">InjectionMetadata</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字段注解对象集合</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;AnnotatedFieldElement&gt; fieldElements;</span><br><span class="line">        <span class="comment">// 方法注解对象集合</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;AnnotatedMethodElement&gt; methodElements;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AnnotatedInjectionMetadata</span><span class="params">(Class&lt;?&gt; targetClass, Collection&lt;AnnotatedFieldElement&gt; fieldElements,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Collection&lt;AnnotatedMethodElement&gt; methodElements)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(targetClass, combine(fieldElements, methodElements));</span><br><span class="line">            <span class="keyword">this</span>.fieldElements = fieldElements;</span><br><span class="line">            <span class="keyword">this</span>.methodElements = methodElements;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;AnnotatedFieldElement&gt; <span class="title">getFieldElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fieldElements;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;AnnotatedMethodElement&gt; <span class="title">getMethodElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> methodElements;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 方法注解</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> A&#125; &#123;<span class="doctag">@link</span> Method&#125; &#123;<span class="doctag">@link</span> InjectionMetadata.InjectedElement&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedMethodElement</span> <span class="keyword">extends</span> <span class="title">InjectionMetadata</span>.<span class="title">InjectedElement</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">        <span class="comment">// 注解</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> A annotation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Object object;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">AnnotatedMethodElement</span><span class="params">(Method method, PropertyDescriptor pd, A annotation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(method, pd);</span><br><span class="line">            <span class="keyword">this</span>.method = method;</span><br><span class="line">            <span class="keyword">this</span>.annotation = annotation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// 获取属性类型</span></span><br><span class="line">            Class&lt;?&gt; injectedType = pd.getPropertyType();</span><br><span class="line">            <span class="comment">// H偶去依赖</span></span><br><span class="line">            Object injectedObject = getInjectedObject(annotation, bean, beanName, injectedType, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 设置可访问</span></span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">            <span class="comment">// 反射注入依赖</span></span><br><span class="line">            method.invoke(bean, injectedObject);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 属性注解</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> A&#125; &#123;<span class="doctag">@link</span> Field&#125; &#123;<span class="doctag">@link</span> InjectionMetadata.InjectedElement&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedFieldElement</span> <span class="keyword">extends</span> <span class="title">InjectionMetadata</span>.<span class="title">InjectedElement</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Field field;</span><br><span class="line">        <span class="comment">// 注解</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> A annotation;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Object bean;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">AnnotatedFieldElement</span><span class="params">(Field field, A annotation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(field, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.field = field;</span><br><span class="line">            <span class="keyword">this</span>.annotation = annotation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// 获取属性类型</span></span><br><span class="line">            Class&lt;?&gt; injectedType = field.getType();</span><br><span class="line">            <span class="comment">// 获取依赖</span></span><br><span class="line">            Object injectedObject = getInjectedObject(annotation, bean, beanName, injectedType, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 设置可访问</span></span><br><span class="line">            ReflectionUtils.makeAccessible(field);</span><br><span class="line">            <span class="comment">// 反射设置值</span></span><br><span class="line">            field.set(bean, injectedObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectionMetadata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 遍历注入元素对象（可能是字段，也可能是方法），完成注入</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line"> Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line"> (<span class="keyword">this</span>.checkedElements != <span class="keyword">null</span> ? <span class="keyword">this</span>.checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line"> <span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line"> <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"> <span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line"> <span class="keyword">if</span> (debug) &#123;</span><br><span class="line"> logger.debug(<span class="string">"Processing injected element of bean '"</span> + beanName + <span class="string">"': "</span> + element);</span><br><span class="line"> &#125;</span><br><span class="line"> element.inject(target, beanName, pvs);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码执行的顺序已经标注，执行顺序比较粗略，先查找服务引用的字段或方法，然后触发字段或方法值的反射注入。但是目的已经达到了，从代码中我们可以看出注解信息已经收集完毕，接下来就是获取依赖对象了，找到依赖对象就可以通过反射注入，对于@Reference注解而言，获取依赖的方法就是 <code>ReferenceAnnotationBeanPostProcessor#doGetInjectedBean</code>。下面我们开始分析 ReferenceAnnotationBeanPostProcessor 中的逻辑。</p><p><strong>获取要注入的依赖Bean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">AnnotationInjectedBeanPostProcessor</span>&lt;<span class="title">Reference</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略代码&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得要注入的 依赖</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reference       <span class="doctag">@Reference</span>注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean            <span class="doctag">@Reference</span>注解标注属性或方法所在的类的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName        <span class="doctag">@Reference</span>注解标注属性或方法所在的类的对象名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> injectedType    要注入依赖的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> injectedElement 注入元信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doGetInjectedBean</span><span class="params">(Reference reference, Object bean, String beanName, Class&lt;?&gt; injectedType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       InjectionMetadata.InjectedElement injectedElement)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获得要注入依赖的名字</span></span><br><span class="line">        String referencedBeanName = buildReferencedBeanName(reference, injectedType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建ReferenceBean 对象 [比较复杂]</span></span><br><span class="line">        ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referencedBeanName, reference, injectedType, getClassLoader());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 缓存到 injectedFieldReferenceBeanCache 或 injectedMethodReferenceBeanCache</span></span><br><span class="line">        cacheInjectedReferenceBean(referenceBean, injectedElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 创建 Proxy 代理</span></span><br><span class="line">        Object proxy = buildProxy(referencedBeanName, referenceBean, injectedType);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;省略代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doGetInjectedBean 方法主要完成以上4个流程，我们重点分析创建ReferenceBean和Proxy代理流程。</p><p><strong>创建ReferenceBean对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">AnnotationInjectedBeanPostProcessor</span>&lt;<span class="title">Reference</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略代码&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得 ReferenceBean 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referencedBeanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referencedType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ReferenceBean <span class="title">buildReferenceBeanIfAbsent</span><span class="params">(String referencedBeanName, Reference reference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     Class&lt;?&gt; referencedType, ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先从缓存中获得referencedBeanName 对应的 ReferenceBean 对象</span></span><br><span class="line">        ReferenceBean&lt;?&gt; referenceBean = referenceBeanCache.get(referencedBeanName);</span><br><span class="line">        <span class="comment">// 如果不存在，则进行创建，然后添加到缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (referenceBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder</span><br><span class="line">                    .create(reference, classLoader, applicationContext)</span><br><span class="line">                    <span class="comment">// 引用类型作为接口类型</span></span><br><span class="line">                    .interfaceClass(referencedType);</span><br><span class="line">            <span class="comment">// 创建ReferenceBean【1. 创建ReferenceBean对象 2.ReferenceBean 配置】</span></span><br><span class="line">            referenceBean = beanBuilder.build();</span><br><span class="line">            referenceBeanCache.put(referencedBeanName, referenceBean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> referenceBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;省略代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buildReferenceBeanIfAbsent 方法基本没有核心逻辑，所有的逻辑都封装在了 ReferenceBeanBuilder 中，它是ReferenceBean的构建器，我们继续跟进该类。</p><p><strong>ReferenceBean对象的构建器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceBeanBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">Reference</span>, <span class="title">ReferenceBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将注解的属性设置到ReferenceBean，忽略以下属性，这些属性会单独处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] IGNORE_FIELD_NAMES = of(<span class="string">"application"</span>, <span class="string">"module"</span>, <span class="string">"consumer"</span>, <span class="string">"monitor"</span>, <span class="string">"registry"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ReferenceBeanBuilder</span><span class="params">(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(annotation, classLoader, applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建ReferenceBeanBuilder</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReferenceBeanBuilder <span class="title">create</span><span class="params">(Reference annotation, ClassLoader classLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ReferenceBean 的构建器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReferenceBeanBuilder(annotation, classLoader, applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>由于很多属性都在其父类 <code>AbstractAnnotationConfigBeanBuilder</code> 中，如上面的interfaceClass，以及很重要的build方法。我们再分析下该类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>, <span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractInterfaceConfig</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> A annotation;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Object bean;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span><span class="params">(A annotation, ClassLoader classLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(annotation, <span class="string">"The Annotation must not be null!"</span>);</span><br><span class="line">        Assert.notNull(classLoader, <span class="string">"The ClassLoader must not be null!"</span>);</span><br><span class="line">        Assert.notNull(applicationContext, <span class="string">"The ApplicationContext must not be null!"</span>);</span><br><span class="line">        <span class="keyword">this</span>.annotation = annotation;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> &lt;T extends AbstractAnnotationConfigBeanBuilder&lt;A, B&gt;&gt; <span class="function">T <span class="title">bean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.bean = bean;</span><br><span class="line">         <span class="keyword">return</span> (T) <span class="keyword">this</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="comment">// 设置接口</span></span><br><span class="line">     <span class="keyword">public</span> &lt;T extends AbstractAnnotationConfigBeanBuilder&lt;A, B&gt;&gt; <span class="function">T <span class="title">interfaceClass</span><span class="params">(Class&lt;?&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.interfaceClass = interfaceClass;</span><br><span class="line">         <span class="keyword">return</span> (T) <span class="keyword">this</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码比较简单，只需注意设置的接口即可，下面我们分析创建ReferenceBean的build方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>, <span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractInterfaceConfig</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Build &#123;<span class="doctag">@link</span> B&#125;  构造泛型B对象，此处就是构造ReferenceBean对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> B <span class="title">build</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 校验依赖，目前是个空方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        checkDependencies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建 Bean 对象，具体实现交给子类</span></span><br><span class="line">        B bean = doBuild();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 配置Bean 对象</span></span><br><span class="line">        configureBean(bean);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"The bean[type:"</span> + bean.getClass().getSimpleName() + <span class="string">"] has been built."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码使用了模版方法模式，我们先看doBuild()方法的具体实现，然后再分析配置Bean对象的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceBeanBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">Reference</span>, <span class="title">ReferenceBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ReferenceBeanBuilder#build的方法调用，用来创建Reference对象。【对父类方法的重写】</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ReferenceBean <span class="title">doBuild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ReferenceBean对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReferenceBean&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行代码就搞定了，直接创建ReferenceBean对象，我们接着分析配置Bean逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>, <span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractInterfaceConfig</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 配置ReferenceBean对象</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureBean</span><span class="params">(B bean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 前置配置Bean逻辑，具体实现交给子类</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         preConfigureBean(annotation, bean);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 尝试从Spring中获取<span class="doctag">@Reference</span>注解中配置的registry属性值对应的RegistryConfig对象集合，然后设置到的ReferenceBean对象的registries属性中</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         configureRegistryConfigs(bean);</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 设置ReferenceBean的monitor属性，原理同上</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         configureMonitorConfig(bean);</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 设置ReferenceBean的application属性，原理同上</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         configureApplicationConfig(bean);</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 设置 ReferenceBean的module属性，原理同上</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         configureModuleConfig(bean);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 后置配置Bean逻辑，具体实现交给子类</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         postConfigureBean(annotation, bean);</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也是使用模版方法模式，其中ReferenceBean的registries、monitor、application、module属性的值是通过该方法进行设置的，前置配置Bean和后置配置Bean的逻辑是由子类实现的，我们继续跟进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceBeanBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">Reference</span>, <span class="title">ReferenceBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * ReferenceBean 的前置配置</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> reference</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> referenceBean</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preConfigureBean</span><span class="params">(Reference reference, ReferenceBean referenceBean)</span> </span>&#123;</span><br><span class="line">          Assert.notNull(interfaceClass, <span class="string">"The interface class must set first!"</span>);</span><br><span class="line">          <span class="comment">// 创建DataBinder对象,将ReferenceBean包装成DataBinder,进行属性绑定，绑定到的对象就是ReferenceBean</span></span><br><span class="line">          DataBinder dataBinder = <span class="keyword">new</span> DataBinder(referenceBean);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Register CustomEditors for special fields   // 注册指定属性的自定义Editor</span></span><br><span class="line">          dataBinder.registerCustomEditor(String.class, "filter", new StringTrimmerEditor(true));</span><br><span class="line">          dataBinder.registerCustomEditor(String.class, "listener", new StringTrimmerEditor(true));</span><br><span class="line">          dataBinder.registerCustomEditor(Map.class, "parameters", new PropertyEditorSupport() &#123;</span><br><span class="line">  </span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> java.lang.IllegalArgumentException </span>&#123;</span><br><span class="line">                  <span class="comment">// Trim all whitespace</span></span><br><span class="line">                  String content = StringUtils.trimAllWhitespace(text);</span><br><span class="line">                  <span class="keyword">if</span> (!StringUtils.hasText(content)) &#123; <span class="comment">// No content , ignore directly</span></span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// replace "=" to ","</span></span><br><span class="line">                  content = StringUtils.replace(content, <span class="string">"="</span>, <span class="string">","</span>);</span><br><span class="line">                  <span class="comment">// replace ":" to ","</span></span><br><span class="line">                  content = StringUtils.replace(content, <span class="string">":"</span>, <span class="string">","</span>);</span><br><span class="line">                  <span class="comment">// String[] to Map</span></span><br><span class="line">                  Map&lt;String, String&gt; parameters = CollectionUtils.toStringMap(commaDelimitedListToStringArray(content));</span><br><span class="line">                  setValue(parameters);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">/** Bind annotation attributes 将注解的属性设置到ReferenceBean中，排除 &#123;<span class="doctag">@link</span> IGNORE_FIELD_NAMES&#125; 属性，这些属性后续单独处理 &#123;<span class="doctag">@link</span> AbstractAnnotationConfigBeanBuilder#configureBean(com.alibaba.dubbo.config.AbstractInterfaceConfig) */</span></span><br><span class="line">          dataBinder.bind(<span class="keyword">new</span> AnnotationPropertyValuesAdapter(reference, applicationContext.getEnvironment(), IGNORE_FIELD_NAMES));</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ReferenceBean 的后置配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postConfigureBean</span><span class="params">(Reference annotation, ReferenceBean bean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 设置 Spring 上下文到 ReferenceBean 中，并且 将 Dubbo 和 Spring容器打通，即 设置SpringExtensionFactory中的上下文</span></span><br><span class="line">        bean.setApplicationContext(applicationContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置服务接口</span></span><br><span class="line">        configureInterface(annotation, bean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从Spring中获取@Reference注解中配置的consumer属性值对应的ConsumerConfig对象，然后设置到的ReferenceBean对象的consumer属性中</span></span><br><span class="line">        configureConsumerConfig(annotation, bean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主动触发 ReferenceBean 的 afterPropertiesSet 方法</span></span><br><span class="line">        bean.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，创建ReferenceBean对象分析完毕，我们再回过头分析 ReferenceAnnotationBeanPostProcessor#doGetInjectedBean 方法中的创建 <code>Proxy</code> 对象的逻辑。</p><p><strong>创建Proxy对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">AnnotationInjectedBeanPostProcessor</span>&lt;<span class="title">Reference</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Proxy代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referencedBeanName </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referenceBean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> injectedType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">buildProxy</span><span class="params">(String referencedBeanName, ReferenceBean referenceBean, Class&lt;?&gt; injectedType)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 创建ReferenceBeanInvocationHandler对象</span></span><br><span class="line">        InvocationHandler handler = buildInvocationHandler(referencedBeanName, referenceBean);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 使用JDK的动态代理创建服务接口的代理对象</span></span><br><span class="line">        Object proxy = Proxy.newProxyInstance(getClassLoader(), <span class="keyword">new</span> Class[]&#123;injectedType&#125;, handler);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建ReferenceBeanInvocationHandler对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referencedBeanName 注入依赖的名字，即服务的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referenceBean ReferenceBean对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> InvocationHandler <span class="title">buildInvocationHandler</span><span class="params">(String referencedBeanName, ReferenceBean referenceBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从缓存中获取对应的 handler对象</span></span><br><span class="line">        ReferenceBeanInvocationHandler handler = localReferenceBeanInvocationHandlerCache.get(referencedBeanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不存在则创建ReferenceBean的 InvocationHandler 对象</span></span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler = <span class="keyword">new</span> ReferenceBeanInvocationHandler(referenceBean);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 如果应用上下文中已经初始化了，说明引入的服务是本地的@Service Bean ，则将引入的Dubbo服务的InvocationHandler添加到本地缓存中，不进行初始化（要想初始化，引入的服务必须是已经暴露的状态）</span></span><br><span class="line">        <span class="keyword">if</span> (applicationContext.containsBean(referencedBeanName)) &#123;</span><br><span class="line">            <span class="comment">// ReferenceBeanInvocationHandler's initialization has to wait for current local @Service Bean has been exported.</span></span><br><span class="line">            localReferenceBeanInvocationHandlerCache.put(referencedBeanName, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果应用上下文中没有，则说明是引入的是远程的服务对象，则立即初始化</span></span><br><span class="line">            handler.init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;省略代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码只做了一件事情，为服务接口创建一个代理对象，创建代理对象是使用JDK的动态代理。其中代理对象的执行逻辑封装在ReferenceBeanInvocationHandler对象中，下面我们就来详细分析该Handler。</p><p><strong>ReferenceBeanInvocationHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现了 Dubbo 的 InvocationHandler接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBeanInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * ReferenceBean对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> ReferenceBean referenceBean;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Bean 对象(引用的服务)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">ReferenceBeanInvocationHandler</span><span class="params">(ReferenceBean referenceBean)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.referenceBean = referenceBean;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">           <span class="comment">// 调用 Bean 的对应的方法</span></span><br><span class="line">           <span class="keyword">return</span> method.invoke(bean, args);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1 通过初始化方法，获得 ReferenceBean.ref (引用的服务)，即代理对象</span></span><br><span class="line"><span class="comment">        * 2 调用ReferenceBean#get()方法，进行引用的Bean的初始化，最后返回服务接口代理对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.bean = referenceBean.get();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ReferenceBeanInvocationHandler是ReferenceAnnotationBeanPostProcessor的静态内部类，实现了InvocationHander接口。其中referenceBean属性值是通过构造方法设置的，bean属性的值就是引用的服务，即服务接口代理对象。invoke方法是回调方法，当消费方通过创建的proxy调用服务方法就会回调。至此，<code>@Reference</code> 所需要的依赖已经创建完毕，通过反射设置到所需组件中即可。</p><h2 id="Dubbo注解配置流程总结"><a href="#Dubbo注解配置流程总结" class="headerlink" title="Dubbo注解配置流程总结"></a>Dubbo注解配置流程总结</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-annotation-summary.jpg" alt></p><p>前面已经详细分析Dubbo注解配置的流程，这里进行小结。Dubbo的注解解析机制主要依赖上图中的核心组件。如果用户使用了配置文件，则Dubbo框架按需生成对应的Bean。Dubbo框架会将所有使用Dubbo的注解@Service标注的类提升为Bean，为使用@Reference注解的字段或方法注入代理对象。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码量远比预计得多，写的还是有点混乱的。从代码整个流程可以看出，虽然注解使用更加简洁、方便，但是背后的工作一点都没有少，甚至更多更复杂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/a8d76a91/&quot;&gt;Dubbo源码分析 - XML配置&lt;
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - XML配置</title>
    <link href="https://gentryhuang.com/posts/a8d76a91/"/>
    <id>https://gentryhuang.com/posts/a8d76a91/</id>
    <published>2020-03-28T16:00:00.000Z</published>
    <updated>2020-09-03T03:12:53.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 <a href="https://gentryhuang.com/posts/1d3295e6/">Dubbo源码分析 - API和属性配置</a> 中介绍了Dubbo的配置承载对象，分析了核心的配置类及方法。了解了API配置后XML配置就容易多了，XML配置相比较API配置的区别在配置对象创建及其属性的设置是由Spring管理的，Dubbo和Spring XML融合是关键。</p><h3 id="Dubbo和Spring融合"><a href="#Dubbo和Spring融合" class="headerlink" title="Dubbo和Spring融合"></a>Dubbo和Spring融合</h3><p>Dubbo框架直接集成了Spring的能力，利用Spring配置文件扩展出自定义的解析方式，即使用Spring的自定标签。关于Spring自定标签的示例，在<a href="https://gentryhuang.com/posts/eee3e639/">Spring自定义标签</a> 中有详细介绍，Dubbo基于schema的设计也是如此，下面我们就来分析下Dubbo是怎么和Spring融合的。</p><h4 id="Dubbo的配置对象模型"><a href="#Dubbo的配置对象模型" class="headerlink" title="Dubbo的配置对象模型"></a>Dubbo的配置对象模型</h4><p>Dubbo的配置对象模型已经在 [Dubbo源码分析 - API和属性配置] 中详细介绍过了，在Dubbo的命名空间处理器中也可以具体看到哪些配置类和Spring进行交互，这里就不再介绍。</p><h4 id="Dubbo的xsd文件"><a href="#Dubbo的xsd文件" class="headerlink" title="Dubbo的xsd文件"></a>Dubbo的xsd文件</h4><p>dubbo.xsd文件是用来约束使用XML配置时的标签和对应的属性，如Dubbo中的&lt;dubbo:service&gt;标签等。由于当前分析的dubbo版本是2.6.5，Dubbo已经捐给了Apache组织，为了遵循Apache标准和兼容Dubbo原来的版本，会出现两个xsd文件，这篇文章还是按照Dubbo原来的版本进行相关描述。</p><ul><li>dubbo.xsd总览</li></ul><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-schema.jpg" alt></p><p>Dubbo设计的粒度很多都是针对方法级别的，如方法级别的timeout、retries等特性。具体的每个复杂类型的详细使用可以参考:<a href="http://dubbo.apache.org/zh-cn/docs/user/references/xml/introduction.html" target="_blank" rel="noopener">官方文档</a></p><ul><li>dubbo.xsd中的类型关系</li></ul><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-schema-relation.jpg" alt></p><p>上图的类型继承关系和Dubbo的配置类之间的关系几乎保持一致，因为这里定义的复杂类型就是要映射到配置类的属性上，即schema中的字段对应Config类中的属性和get/set方法。</p><h4 id="Dubbo的spring-schemas文件"><a href="#Dubbo的spring-schemas文件" class="headerlink" title="Dubbo的spring.schemas文件"></a>Dubbo的spring.schemas文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http\:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&#x3D;META-INF&#x2F;dubbo.xsd</span><br><span class="line">http\:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&#x3D;META-INF&#x2F;compat&#x2F;dubbo.xsd</span><br></pre></td></tr></table></figure><p>spring.schemas文件用来指明约束文件的具体路径。</p><h4 id="Dubbo的spring-handlers"><a href="#Dubbo的spring-handlers" class="headerlink" title="Dubbo的spring.handlers"></a>Dubbo的spring.handlers</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http\:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x3D;com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</span><br><span class="line">http\:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x3D;com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</span><br></pre></td></tr></table></figure><p>spring.handlers文件用来指明Dubbo的XML命名空间处理器，即使用DubboNamespaceHandler来解析Dubbo自定义的标签。</p><h4 id="Dubbo的DubboNamespaceHandler"><a href="#Dubbo的DubboNamespaceHandler" class="headerlink" title="Dubbo的DubboNamespaceHandler"></a>Dubbo的DubboNamespaceHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法中定义了每个&lt;xsd:element/&gt;对应的BeanDefinitionParser 【Dubbo Bean定义解析器】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"module"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"registry"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"monitor"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"protocol"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>))</span>;</span><br><span class="line">        <span class="comment">// 注解已经重写，AnnotationBeanDefinitionParser 已经废弃，即@DubboComponentScan 作为 Dubbo 2.5.7 新增的 Annotation，是XML 元素 &lt;dubbo:annotation&gt; 的替代方案。</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation"</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo解析配置的入口是在 DubboNamespaceHandler类中完成的，该类主要把不同的标签关联到解析实现类中，registerBeanDefinitionParser方法约定在遇到Dubbo自定的标签如application、registry、protocol等都会委托给Dubbo的命名空间处理器DubboNamespaceHandler处理，该处理器又会把解析任务交给DubboBeanDefinitionParser来处理。</p><h4 id="Dubbo的DubboBeanDefinitionParser"><a href="#Dubbo的DubboBeanDefinitionParser" class="headerlink" title="Dubbo的DubboBeanDefinitionParser"></a>Dubbo的DubboBeanDefinitionParser</h4><p>实现了Spring的BeanDefinitionParser接口，是真正用来解析自定的Dubbo标签，将标签解析成对应的Bean定义并注册到Spring上下文中。</p><h4 id="使用Dubbo标签"><a href="#使用Dubbo标签" class="headerlink" title="使用Dubbo标签"></a>使用Dubbo标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- provider's application name, used for tracing dependency relationship --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span> <span class="attr">owner</span>=<span class="string">"gentryhuang"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- use multicast registry center to export service --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:registry address="multicast://224.5.6.7:1234" protocol="test"/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- use dubbo protocol to export service on port 20880 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- service implementation, as same as regular local bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.dubbo.demo.provider.DemoServiceImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- declare the service interface to be exported --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上就是Dubbo和Spring的XML配置进行融合的过程，与 <a href="https://gentryhuang.com/posts/eee3e639/">Spring自定义标签</a> 文章中的流程是一样的。总的来说，Dubbo框架先以流的形式装载Spring的XML配置文件，在将流解析成DOM的过程中会加载<code>spring.schemas</code>文件，然后读取该文件中指定的的xsd约束文件，接着使用xsd中的约束规则对每个标签及其属性进行校验，不合法则抛出异常，整个配置文件符合约束规则则生成DOM对象。和<code>spring.handlers</code>文件。<code>spring.schema</code>文件指定了配置约束文件的位置，加载<code>spring.schemas</code>文件的目的就是用来校验Spring的XML配置文件内容是否合法。加载<code>spring.handlers</code>文件的目的是，当解析Spring的XML配置文件中的标签时,会查找该文件中指定的DubboNamespaceHandler类来进行自定义标签的初始化和解析。</p><h3 id="解析准备"><a href="#解析准备" class="headerlink" title="解析准备"></a>解析准备</h3><h4 id="加载-spring-schemas-文件"><a href="#加载-spring-schemas-文件" class="headerlink" title="加载 spring.schemas 文件"></a>加载 spring.schemas 文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory)&#123;</span><br><span class="line">   <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">  <span class="comment">// resource loading environment.</span></span><br><span class="line">  beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">  beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 设置 'META-INF/spring.schemas' 到 ResourceEntityResolver</span></span><br><span class="line">  beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">  <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">  initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">  loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就设置 spring.schemas 文件路径，为接下来加载 spring.schemas 文件做准备。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">XmlBeanDefinitionReader#doLoadBeanDefinitions(InputSource inputSource, Resource resource)&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加载 META-INF/spring.schemas 中xsd文件，在构建Dom时进行校验XML配置内容是否正确</span></span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">    <span class="comment">// 加载 META-INF/spring.handlers 中的命名空间处理器，初始化并放入缓存</span></span><br><span class="line"><span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是注册XML中的Bean的大流程入口，分别是加载 META-INF/spring.schemas 中xsd文件，用于构建DOM时校验XML配置内容是否正确，加载 META-INF/spring.handlers 中的命名空间处理器，用于处理标签和BeanDefinitionParser的映射关系以及解析标签。下面我们来看Spring是如何加载spring.schemas文件内容的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PluggableSchemaResolver#getSchemaMappings()&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.schemaMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.schemaMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"> logger.debug(<span class="string">"Loading schema mappings from ["</span> + <span class="keyword">this</span>.schemaMappingsLocation + <span class="string">"]"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从 META-INF/spring.schemas 中读取xsd文件路径</span></span><br><span class="line"> Properties mappings = PropertiesLoaderUtils.loadAllProperties(<span class="keyword">this</span>.schemaMappingsLocation, <span class="keyword">this</span>.classLoader);</span><br><span class="line"> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"> logger.debug(<span class="string">"Loaded schema mappings: "</span> + mappings);</span><br><span class="line">   &#125;</span><br><span class="line"> Map&lt;String, String&gt; schemaMappings = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;(mappings.size());</span><br><span class="line">        <span class="comment">// 放入缓存中</span></span><br><span class="line"> CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);</span><br><span class="line"> <span class="keyword">this</span>.schemaMappings = schemaMappings;</span><br><span class="line">  &#125;<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to load schema mappings from location ["</span> + <span class="keyword">this</span>.schemaMappingsLocation + <span class="string">"]"</span>, ex);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.schemaMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> publicId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> systemId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PluggableSchemaResolver#resolveEntity(String publicId, String systemId)&#123;</span><br><span class="line"> <span class="keyword">if</span> (systemId != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 根据 spring.schemas中配置的xxx.xsd找到对应的xsd文件</span></span><br><span class="line">String resourceLocation = getSchemaMappings().get(systemId);</span><br><span class="line"><span class="keyword">if</span> (resourceLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载xsd文件</span></span><br><span class="line">Resource resource = <span class="keyword">new</span> ClassPathResource(resourceLocation, <span class="keyword">this</span>.classLoader);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputSource source = <span class="keyword">new</span> InputSource(resource.getInputStream());</span><br><span class="line">source.setPublicId(publicId);</span><br><span class="line">source.setSystemId(systemId);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Found XML schema ["</span> + systemId + <span class="string">"] in classpath: "</span> + resourceLocation);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> source;</span><br><span class="line">&#125;<span class="keyword">catch</span> (FileNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Couldn't find XML schema ["</span> + systemId + <span class="string">"]: "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是Spring在启动时加载spring.schemas中配置的xsd文件的几个代码片段，将XML配置文件解析成DOM的过程中，对每个标签及其属性进行校验，依据就是xsd中的约束条件。由于是Spring的源码部分，这里不进行深入分析，感兴趣的胖友可以自行调试。</p><h4 id="加载-spring-handlers-文件"><a href="#加载-spring-handlers-文件" class="headerlink" title="加载 spring.handlers 文件"></a>加载 spring.handlers 文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> doc 配置文件对应的DOM对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource 配置文件资源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XmlBeanDefinitionReader#registerBeanDefinitions(Document doc, Resource resource)&#123;</span><br><span class="line">  <span class="comment">// 创建Bean定义的DOMReader，用来读取、解析DOM，接着创建对应的Bean</span></span><br><span class="line">  BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">  <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">  <span class="comment">// 读取、解析DOM、创建对应的Bean</span></span><br><span class="line">  documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">  <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerBeanDefinitions方法是将Spring的XML配置文件中定义的有关标签进行创建并注册到Spring的注册表中。注意，这里所说的能够创建Bean的有关标签必须有对应的BeanDefinitionParser，否则不会对该标签进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource 配置文件资源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XmlBeanDefinitionReader#createReaderContext(Resource resource)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(</span><br><span class="line">        resource, </span><br><span class="line">        <span class="keyword">this</span>.problemReporter, </span><br><span class="line">        <span class="keyword">this</span>.eventListener,</span><br><span class="line">  <span class="keyword">this</span>.sourceExtractor, </span><br><span class="line">        <span class="keyword">this</span>, </span><br><span class="line">        <span class="comment">// 读取 META-INF/spring.handlers 文件</span></span><br><span class="line">         getNamespaceHandlerResolver()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createReaderContext 方法用来创建 XmlReaderContext，该对象中包含的核心属性如下：<br><br></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-spring-handlers.jpg" alt></p><p>由XmlReaderContext对象中的属性可知，在创建该对象的过程中对 META-INF/spring.handlers 文件进行了读取。现在有了配置文件的DOM对象、Bean定义工厂以及spring.handlers文件中各种NamespaceHandler，接下来就可以解析DOM树，创建并注册相应的Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DefaultBeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)&#123;</span><br><span class="line">  <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">  logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">  <span class="comment">// 获取DOM的根元素，一般是 beans</span></span><br><span class="line">  Element root = doc.getDocumentElement();</span><br><span class="line">  <span class="comment">// 解析入口</span></span><br><span class="line">  doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要是获取DOM对象的根元素，然后以这个根元素作为起点进行解析，下面我们接着解析代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment">* "import", "alias", "bean".</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> root DOM的根元素</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> delegate Bean定义解析器代理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">DefaultBeanDefinitionDocumentReader#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line"> <span class="comment">// 判读根元素是不是默认的命名空间 'http://www.springframework.org/schema/beans'</span></span><br><span class="line"> <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="comment">// 获取根元素下的子元素列表</span></span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line">        <span class="comment">// 判断是否是元素</span></span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">  Element ele = (Element) node;</span><br><span class="line">          <span class="comment">// 当前元素的命名空间如果是默认的命名空间即Spring自身的命名空间，则通过Spring自身逻辑进行解析</span></span><br><span class="line">  <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line"> parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">// 当前元素的命名空间非默认的命名空间即自定义的标签，则通过自定义逻辑进行解析</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的主要逻辑是判断要解析的DOM元素即标签，是否是Spring内置的，如果是Spring内置则整个解析逻辑使用Spring自身的那一套，如果是自定义的，则解析逻辑交给开发者。Spring自身的解析逻辑忽略，下面我们来分析下自定义的标签的处理流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element ele)&#123;</span><br><span class="line">  <span class="keyword">return</span> parseCustomElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ele DOM的根元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> containingBd </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element ele, org.springframework.beans.factory.config.BeanDefinition containingBd)&#123;</span><br><span class="line">        <span class="comment">// 获取元素即标签的命名空间</span></span><br><span class="line">        String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">        <span class="comment">// 使用 XmlReaderContext中的 DefaultNamespaceHandlerResolver获取命名空间对应的 NamespaceHandler对象</span></span><br><span class="line">    NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">     <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 使用 NamespaceHandler 对象解析标签</span></span><br><span class="line">    <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码先是获取当前元素的命名空间，然后通过该命名空间获取对应 NamespaceHandler对象，最后通过该对象解析当前元素。下面我们依次分析这两个步骤的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">DefaultNamespaceHandlerResolver#resolve(String namespaceUri)&#123;</span><br><span class="line"><span class="comment">// 获取 DefaultNamespaceHandlerResolver#handlerMappings属性，即命名空间到NamespaceHandler的映射，注意这里的NamespaceHandler可能是还没有进行实例化的字符串</span></span><br><span class="line"> Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line"><span class="comment">// 从缓存中获取 NamespaceHandler</span></span><br><span class="line"> Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line"> <span class="keyword">if</span> (handlerOrClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 如果当前命名空间对应的 NamespaceHandler 就是 NamespaceHandler对象，则需要进行实例化，直接返回即可</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line"> <span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 当前命名空间对应的 NamespaceHandler 还是字符串，需要反射创建对象</span></span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> String className = (String) handlerOrClassName;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 获取当前 当前命名空间对应的 NamespaceHandler 串 的 Class</span></span><br><span class="line"> Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line"> <span class="keyword">if</span> (!NamespaceHandler<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">handlerClass</span>)) </span>&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Class ["</span> + className + <span class="string">"] for namespace ["</span> + namespaceUri +</span><br><span class="line"> "] does not implement the [" + NamespaceHandler.class.getName() + "] interface");</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line"> NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">    <span class="comment">// 执行 init 方法，进行标签和BeanDefinitionParser 的关联 </span></span><br><span class="line"> namespaceHandler.init();</span><br><span class="line">    <span class="comment">// 加入缓存</span></span><br><span class="line"> handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line"> <span class="keyword">return</span> namespaceHandler;</span><br><span class="line"> &#125;<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"NamespaceHandler class ["</span> + className + <span class="string">"] for namespace ["</span> +</span><br><span class="line"> namespaceUri + <span class="string">"] not found"</span>, ex);</span><br><span class="line"> &#125;<span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Invalid NamespaceHandler class ["</span> + className + <span class="string">"] for namespace ["</span> +</span><br><span class="line"> namespaceUri + <span class="string">"]: problem with handler class file or dependent class"</span>, err);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码核心是获取当前命名空间对应的 NamespaceHandler ，如果 NamespaceHandler 还是个字符串，那么就通过反射创建对象，接着调用该对象的 <code>init()</code>,进行标签和 BeanDefinitionParser 的关联 ，方法如果已经创建过了对象则直接返回该 NamespaceHandler 对象。由于Dubbo自定义标签的命名空间对应的NamespaceHandler是 DubboNamespaceHandler，我们在前面已经分析过了它的源码，这里再详细说明下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法中定义了每个&lt;xsd:element/&gt;对应的BeanDefinitionParser 【Dubbo Bean定义解析器】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"module"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"registry"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"monitor"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"protocol"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation"</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码比较直观，一个标签对应一个 DubboBeanDefinitionParser 对象，同时也对应这一个Dubbo的配置承载类。我们接下主要看registerBeanDefinitionParser方法是怎么把标签和DubboBeanDefinitionParser关联到一起的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamespaceHandlerSupport</span> <span class="keyword">implements</span> <span class="title">NamespaceHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 标签名 到 BeanDefinitionParser 映射集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinitionParser&gt; parsers = <span class="keyword">new</span> HashMap&lt;String, BeanDefinitionParser&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 关联 标签名 到 BeanDefinitionParser</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitionParser</span><span class="params">(String elementName, BeanDefinitionParser parser)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parsers.put(elementName, parser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来如此简单，就是调用父类 NamespaceHandlerSupport 的registerBeanDefinitionParser方法，将标签名到BeanDefinitionParser的映射保存到缓存中。到了这里所有解析前的工作已经准备就绪，终于可以进入到这篇文章的核心部分了。之所以用了那么多的铺垫，就是想把整个过程串起来，如果一下子进入到Dubbo自定义标签的解析感觉还是挺奇怪的，毕竟笔者对Spring的源码也不熟悉，就按部就班吧。</p><h3 id="解析标签"><a href="#解析标签" class="headerlink" title="解析标签"></a>解析标签</h3><p>解析准备是特意为解析标签做的铺垫，有了这个铺垫下面的解析逻辑就容易很多了。我们接着解析准备中的 <code>parseCustomElement</code> 方法继续分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 1. 获取DOM元素即标签对应的命名空间</span></span><br><span class="line">   String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">   <span class="comment">// 2. 获取命名空间映射的 NamespaceHandler对象</span></span><br><span class="line">   NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">// 3. 调用 NamespaceHandler对象 的parse方法进行解析</span></span><br><span class="line"><span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的第3步才正式进入到标签的解析，这里的 NamespaceHandler 就 DubboNamespaceHandler对象，<code>parse</code> 方法是其父类 NamespaceHandlerSupport 中的方法，我们来看看逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1. 获取标签的名称关联的 BeanDefinitionParser</span></span><br><span class="line"><span class="comment">        * 2. 使用 BeanDefinitionParser解析标签</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="keyword">return</span> findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取标签名</span></span><br><span class="line">String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">       <span class="comment">// 从缓存中获取标签名对应的 BeanDefinitionParser对象，即 DubboBeanDefinitionParser对象</span></span><br><span class="line">BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line"><span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">parserContext.getReaderContext().fatal(</span><br><span class="line"><span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是从 标签名 到 BeanDefinitionParser 映射集合parsers中获取标签名对应的BeanDefinitionParser对象，该映射集合是在 DubboNamespaceHandler#init 方法执行时维护的。下面我们接着分析DubboBeanDefinitionParser类。</p><h4 id="Dubbo-Bean定义解析器"><a href="#Dubbo-Bean定义解析器" class="headerlink" title="Dubbo Bean定义解析器"></a>Dubbo Bean定义解析器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标签元素对应的对象类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; beanClass;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否需要Bean的 id 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> required;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass Bean 对象的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> required  是否需要在Bean对象的编号（id）不存在时自动生成编号。无需被其他应用引用的配置对象，无需自动生成编号。 eg：&lt;dubbo:reference/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBeanDefinitionParser</span><span class="params">(Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClass = beanClass;</span><br><span class="line">        <span class="keyword">this</span>.required = required;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring解析标签的入口方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element       标签元素对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parserContext 解析上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parse(element, parserContext, beanClass, required);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略的代码&#125;</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DubboBeanDefinitionParser实现了Spring的BeanDefinitionParser接口，即Spring的Bean定义解析器。该类中有两个重要属性，<code>beanClass</code> 和 <code>required</code>，这两个属性的值是在创建Dubbo的Bean定义解析器时通过构造方法传入的，分别是标签元素对应的配置类和在创建配置Bean的时候可能需要i的d属性。<code>parse</code>方法是解析XML元素的主流程的入口，其中 parserContext 参数是XML解析的上下文，它包含了 XmlReaderContext 这个重要对象，而该对象中又包含了BeanFactory等信息，具体如下图:<br><br></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-parsercontext.jpg" alt></p><p>有了BeanFactory就可以实现Bean的定义了，接下来我们继续分析Dubbo是如何处理自定义标签与对应的配置类之间的关系，以及怎样创建标签对应的Bean定义的。</p><h4 id="创建Bean定义并注册到Spring上下文"><a href="#创建Bean定义并注册到Spring上下文" class="headerlink" title="创建Bean定义并注册到Spring上下文"></a>创建Bean定义并注册到Spring上下文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> element       标签对应的DOM</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parserContext spring 解析上下文</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> beanClass     标签对应的配置类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> required 在创建Bean定义的时候是否需要id</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 标签对应的配置类的Bean定义</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 生成Spring的Bean定义，指定beanClass交给Spring反射创建实例</span></span><br><span class="line">      RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">      beanDefinition.setBeanClass(beanClass);</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 设置Bean初始化方式，默认设置为延迟加载。</span></span><br><span class="line"><span class="comment">       * 需要说明的是，引用缺省是延迟初始化的，只有引用被注入到其它Bean或者getBean() 获取才会初始化。如果需要立即初始化可以配置： &lt;dubbo:reference init="true"/&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      beanDefinition.setLazyInit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//--------------------------- 确保Spring 容器中没有重复的Bean定义 开始  ------------------------/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析标签对象的id属性</span></span><br><span class="line">      String id = element.getAttribute(<span class="string">"id"</span>);</span><br><span class="line">      <span class="comment">// 标签没有设置id属性，并且创建的Bean定义需要id时，就执行生成id的逻辑。需要注意的是，Dubbo的reference标签对应Bean定义不需要id</span></span><br><span class="line">      <span class="keyword">if</span> ((id == <span class="keyword">null</span> || id.length() == <span class="number">0</span>) &amp;&amp; required) &#123;</span><br><span class="line">          <span class="comment">// 1. 取name属性值</span></span><br><span class="line">          String generatedBeanName = element.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">          <span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span> || generatedBeanName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 2. 也没有设置name属性，此时如果当前标签是Protocol，那么id的值就直接设置为 'dubbo'，非Protocol协议则尝试取标签的interface属性值</span></span><br><span class="line">              <span class="keyword">if</span> (ProtocolConfig<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">beanClass</span>)) </span>&#123;</span><br><span class="line">                  generatedBeanName = <span class="string">"dubbo"</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  generatedBeanName = element.getAttribute(<span class="string">"interface"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 3. 以上过程都没有生成id，则最后使用标签对应的配置类的类名</span></span><br><span class="line">          <span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span> || generatedBeanName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">              generatedBeanName = beanClass.getName();</span><br><span class="line">          &#125;</span><br><span class="line">          id = generatedBeanName;</span><br><span class="line">          <span class="keyword">int</span> counter = <span class="number">2</span>;</span><br><span class="line">          <span class="comment">// 检查Spring注册表中是否存在标识id，存在就通过自增序列继续处理id,使其唯一</span></span><br><span class="line">          <span class="keyword">while</span> (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class="line">              id = generatedBeanName + (counter++);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate spring bean id "</span> + id);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 把标签对应的配置类的Bean定义注册到Spring，Bean 名称为id</span></span><br><span class="line">          parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);</span><br><span class="line">          <span class="comment">// 为Bean追加id属性</span></span><br><span class="line">          beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"id"</span>, id);</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">// $&#123;省略的代码&#125;</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="特殊处理protocol标签"><a href="#特殊处理protocol标签" class="headerlink" title="特殊处理protocol标签"></a>特殊处理protocol标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element       标签对应的DOM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parserContext spring 解析上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass     标签对应的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> required 在创建Bean定义的时候是否需要id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 标签对应的配置类的Bean定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// $&#123;省略的代码&#125;    </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ProtocolConfig<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">beanClass</span>)) </span>&#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 以下代码逻辑需要满足：</span></span><br><span class="line"><span class="comment">                * 顺序需要这样：</span></span><br><span class="line"><span class="comment">                * 1 &lt;dubbo:service interface="com.xxx.xxxService protocol="dubbo" ref="xxxServiceImpl"/&gt;</span></span><br><span class="line"><span class="comment">                * 2 &lt;dubbo:protocol id ="dubbo" name="dubbo" port="20880"/&gt;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="comment">// 获取Bean注册表中所有的Bean id</span></span><br><span class="line">               <span class="keyword">for</span> (String name : parserContext.getRegistry().getBeanDefinitionNames()) &#123;</span><br><span class="line">                   <span class="comment">// 根据id获取Bean定义</span></span><br><span class="line">                   BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);</span><br><span class="line">                   <span class="comment">// 获取当前Bean定义的属性对象集合，并尝试获取属性名为 'protocol' 的属性对象</span></span><br><span class="line">                   PropertyValue property = definition.getPropertyValues().getPropertyValue(<span class="string">"protocol"</span>);</span><br><span class="line">                   <span class="keyword">if</span> (property != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 获取属性值</span></span><br><span class="line">                       Object value = property.getValue();</span><br><span class="line">                       <span class="comment">// 如果当前遍历的Bean定义中的属性满足条件，就更新该Bean的 protocol 属性值，即名称为id的RuntimeBeanReference对象</span></span><br><span class="line">                       <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) &#123;</span><br><span class="line">                           definition.getPropertyValues().addPropertyValue(<span class="string">"protocol"</span>, <span class="keyword">new</span> RuntimeBeanReference(id));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// $&#123;省略的代码&#125; </span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的代码用来处理框架中那些属性名为’protocol’且属性类型为为ProtocolConfig的Bean，如果该Bean符合条件就更新该Bean的protocol属性值。</p><h4 id="特殊处理service标签"><a href="#特殊处理service标签" class="headerlink" title="特殊处理service标签"></a>特殊处理service标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element       标签对应的DOM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parserContext spring 解析上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass     标签对应的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> required 在创建Bean定义的时候是否需要id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 标签对应的配置类的Bean定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// $&#123;省略的代码&#125;    </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ServiceBean<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">beanClass</span>)) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果&lt;dubbo:service&gt;配置了class属性，那么为具体class配置的类创建Bean定义，并且把该定义注入到Service的 ref属性。一般不这么使用。</span></span><br><span class="line">            <span class="comment">// eg: &lt;dubbo:service interface="com.alibaba.dubbo.demo.DemoService class="com.alibaba.dubbo.demo.provider.DemoServiceImpl"/&gt;</span></span><br><span class="line">            String className = element.getAttribute(<span class="string">"class"</span>);</span><br><span class="line">            <span class="keyword">if</span> (className != <span class="keyword">null</span> &amp;&amp; className.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                RootBeanDefinition classDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">                classDefinition.setBeanClass(ReflectUtils.forName(className));</span><br><span class="line">                classDefinition.setLazyInit(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 解析 &lt;dubbo:service class="xxx"/&gt; 情况下内嵌的&lt;property/&gt;标签，然后设置到classDefinition的属性中</span></span><br><span class="line">                parseProperties(element.getChildNodes(), classDefinition);</span><br><span class="line">                <span class="comment">// 设置ref属性，相当于设置 &lt;dubbo:service ref=""/&gt;属性</span></span><br><span class="line">                beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"ref"</span>, <span class="keyword">new</span> BeanDefinitionHolder(classDefinition, id + <span class="string">"Impl"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略的代码&#125;    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码用来处理 <code>service标签</code> 中有 class 属性的情况，处理逻辑就是创建class对应的Bean定义，然后设置到 <code>service标签</code> 对应的Bean的ref属性中。我们再来看看对service的子标签 <code>property</code> 的解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析 &lt;dubbo:service class="xxx"/&gt; 情况下内嵌的&lt;property/&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodeList       子元素数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanDefinition Bean定义对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseProperties</span><span class="params">(NodeList nodeList, RootBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeList != <span class="keyword">null</span> &amp;&amp; nodeList.getLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">            Node node = nodeList.item(i);</span><br><span class="line">            <span class="comment">// 只解析&lt;property/&gt;标签</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"property"</span>.equals(node.getNodeName())</span><br><span class="line">                        || <span class="string">"property"</span>.equals(node.getLocalName())) &#123;</span><br><span class="line">                    String name = ((Element) node).getAttribute(<span class="string">"name"</span>);</span><br><span class="line">                    <span class="comment">// 优先使用value属性，其次使用ref属性</span></span><br><span class="line">                    <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        String value = ((Element) node).getAttribute(<span class="string">"value"</span>);</span><br><span class="line">                        String ref = ((Element) node).getAttribute(<span class="string">"ref"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            beanDefinition.getPropertyValues().addPropertyValue(name, value);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ref != <span class="keyword">null</span> &amp;&amp; ref.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            beanDefinition.getPropertyValues().addPropertyValue(name, <span class="keyword">new</span> RuntimeBeanReference(ref));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 属性不全，抛出异常</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Unsupported &lt;property name=\""</span> + name + <span class="string">"\"&gt; sub tag, Only supported &lt;property name=\""</span> + name + <span class="string">"\" ref=\"...\" /&gt; or &lt;property name=\""</span> + name + <span class="string">"\" value=\"...\" /&gt;"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码用来解析service的property标签，目的是为service标签的class属性对应的Bean定义设置属性，比较简单。</p><h4 id="特殊处理provider-consumer标签"><a href="#特殊处理provider-consumer标签" class="headerlink" title="特殊处理provider/consumer标签"></a>特殊处理provider/consumer标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element       标签对应的DOM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parserContext spring 解析上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass     标签对应的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> required 在创建Bean定义的时候是否需要id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 标签对应的配置类的Bean定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// $&#123;省略的代码&#125;   </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ProviderConfig<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">beanClass</span>)) </span>&#123;</span><br><span class="line">        <span class="comment">// 解析 &lt;dubbo:provider/&gt; 的内嵌子元素&lt;dubbo:service/&gt;</span></span><br><span class="line">       parseNested(element, parserContext, ServiceBean.class, true, "service", "provider", id, beanDefinition);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ConsumerConfig<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">beanClass</span>)) </span>&#123;</span><br><span class="line">       <span class="comment">// 解析 &lt;dubbo:consumer/&gt; 的内嵌子元素&lt;dubbo:reference/&gt;</span></span><br><span class="line">       parseNested(element, parserContext, ReferenceBean.class, false, "reference", "consumer", id, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略的代码&#125;</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，特殊处理provider/consumer标签就是处理它有service/reference子标签的情况，代码过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析内嵌的标签</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> element        父标签对象 - provider/consumer标签对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parserContext  Spring解析上下文</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanClass      内嵌子元素的Bean类 - ServiceBean/ReferenceBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> required       是否需要Bean的id属性</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> tag            子元素标签名  service/reference</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> property       父Bean对象在子元素中的属性名 provider/consumer</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ref            父Bean的id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanDefinition 父Bean定义对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseNested</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required, String tag, String property, String ref, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取子节点列表</span></span><br><span class="line">       NodeList nodeList = element.getChildNodes();</span><br><span class="line">       <span class="keyword">if</span> (nodeList != <span class="keyword">null</span> &amp;&amp; nodeList.getLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">               <span class="comment">// 获取子节点</span></span><br><span class="line">               Node node = nodeList.item(i);</span><br><span class="line">               <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                   <span class="comment">// 当前节点是否是指定的子节点，这里可能是service/reference节点</span></span><br><span class="line">                   <span class="keyword">if</span> (tag.equals(node.getNodeName()) || tag.equals(node.getLocalName())) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                           first = <span class="keyword">false</span>;</span><br><span class="line">                           <span class="comment">// 获取父节点的default的属性值 [暂时不知道有什么用]</span></span><br><span class="line">                           String isDefault = element.getAttribute(<span class="string">"default"</span>);</span><br><span class="line">                           <span class="keyword">if</span> (isDefault == <span class="keyword">null</span> || isDefault.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                               beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"default"</span>, <span class="string">"false"</span>);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 解析子元素，创建BeanDefinition 对象 （递归）</span></span><br><span class="line">                       BeanDefinition subDefinition = parse((Element) node, parserContext, beanClass, required);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 设置子BeanDefinition的指向，指向父BeanDefinition</span></span><br><span class="line">                       <span class="keyword">if</span> (subDefinition != <span class="keyword">null</span> &amp;&amp; ref != <span class="keyword">null</span> &amp;&amp; ref.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           subDefinition.getPropertyValues().addPropertyValue(property, <span class="keyword">new</span> RuntimeBeanReference(ref));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要处理provider/consumer标签内部嵌套的标签，内部嵌套的标签对象会自动持有外层标签的对象。</p><h4 id="设置标签的属性到-BeanDefinition"><a href="#设置标签的属性到-BeanDefinition" class="headerlink" title="设置标签的属性到 BeanDefinition"></a>设置标签的属性到 BeanDefinition</h4><p>前面处理的逻辑属于特殊的情况，接下来我们分析标签的属性是如何设置到配置对象中的。本质上是通过遍历配置对象的get、set和is前缀方法，通过反射将标签属性设置到配置对象中。总体上分为两种情况：</p><ul><li>如果标签属性和方法名相同，则通过反射调用设置标签的值到配置对象中。</li><li>如果标签属性不能匹配到配置对象中的方法名称，则将标签属性当作parameter参数设置到配置对象中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element       标签对应的DOM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parserContext spring 解析上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass     标签对应的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> required 在创建Bean定义的时候是否需要id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 标签对应的配置类的Bean定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// $&#123;省略的代码&#125;   </span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 用来保存已遍历的配置对象的属性集合，用来判断标签中哪些属性没有匹配上</span></span><br><span class="line">        Set&lt;String&gt; props = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 专门存放&lt;dubbo:parameters/&gt; 标签下子标签属性信息。最后都设置到Bean定义中</span></span><br><span class="line">        ManagedMap parameters = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取配置对象所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method setter : beanClass.getMethods()) &#123;</span><br><span class="line">            String name = setter.getName();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 选择所有set前缀方法，并且只有一个参数的 public 方法</span></span><br><span class="line">            <span class="keyword">if</span> (name.length() &gt; <span class="number">3</span> &amp;&amp; name.startsWith(<span class="string">"set"</span>) &amp;&amp; Modifier.isPublic(setter.getModifiers()) &amp;&amp; setter.getParameterTypes().length == <span class="number">1</span>) &#123;</span><br><span class="line">               </span><br><span class="line">                <span class="comment">// 获取方法的参数类型</span></span><br><span class="line">                Class&lt;?&gt; type = setter.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 3. 提取set对应的属性名字，eg: setTimeout-&gt;timeout,setBeanName-&gt;bean-name</span></span><br><span class="line">                String property = StringUtils.camelToSplitName(name.substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + name.substring(<span class="number">4</span>), <span class="string">"-"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保存到属性 props 集合中</span></span><br><span class="line">                props.add(property);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4. 尝试获取属性对应的getter方法</span></span><br><span class="line">                Method getter = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    getter = beanClass.getMethod(<span class="string">"get"</span> + name.substring(<span class="number">3</span>), <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; <span class="comment">// 没有setter对应的getter方法，尝试获取is方法，is方法在功能上是同getter</span></span><br><span class="line">                        getter = beanClass.getMethod(<span class="string">"is"</span> + name.substring(<span class="number">3</span>), <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchMethodException e2) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 校验属性是否有对应的getter/is前缀方法，没有就跳过</span></span><br><span class="line">                <span class="keyword">if</span> (getter == <span class="keyword">null</span></span><br><span class="line">                        || !Modifier.isPublic(getter.getModifiers())</span><br><span class="line">                        || !type.equals(getter.getReturnType())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6. 解析 &lt;dubbo:parameter/&gt; 标签，将当前标签element的子标签 &lt;dubbo:parameter/&gt; 的属性键值对保存到parameters中</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"parameters"</span>.equals(property)) &#123;</span><br><span class="line">                    parameters = parseParameters(element.getChildNodes(), beanDefinition);</span><br><span class="line">                    <span class="comment">// 7. 解析 &lt;dubbo:method/&gt; 标签，将当前标签element的子标签  &lt;dubbo:method/&gt; 进行解析，将解析得到的对应BeanDefiniton放入到ManagedList集合中，最后作为 beanDefiniton的methods属性值。</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"methods"</span>.equals(property)) &#123;</span><br><span class="line">                    parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);</span><br><span class="line">                    <span class="comment">// 8. 解析 &lt;dubbo:argument/&gt;标签，将当前标签element的子标签 &lt;dubbo:argument/&gt; 进行解析，将解析得到的对应的BeanDefinition放入到ManagedList集合中，最后作为 beanDefinition的arguments属性值。</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"arguments"</span>.equals(property)) &#123;</span><br><span class="line">                    parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 9. 获取标签属性的值 【前面的步骤之所以单独处理，是因为当前配置配置对象对应的属性不是一个标签属性，而是一个子标签】</span></span><br><span class="line">                    String value = element.getAttribute(property);</span><br><span class="line">                    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        value = value.trim();</span><br><span class="line">                        <span class="keyword">if</span> (value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 9.1 标签中配置了 registry=N/A, 不想注册到的情况</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="string">"registry"</span>.equals(property) &amp;&amp; RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) &#123;</span><br><span class="line">                                RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">                                <span class="comment">// RegistryConfig的地址设置 N/A</span></span><br><span class="line">                                registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);</span><br><span class="line">                                beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);</span><br><span class="line">                                <span class="comment">// 9.2 多注册中心情况，将多个注册中心处理成一个集合，然后设置到 beanDefiniton 中，属性名为 'registries'</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"registry"</span>.equals(property) &amp;&amp; value.indexOf(<span class="string">','</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                parseMultiRef(<span class="string">"registries"</span>, value, beanDefinition, parserContext);</span><br><span class="line">                                <span class="comment">// 9.3 多服务提供者情况，将多个服务提供者处理成一个集合，然后设置到 beanDefinition 中，属性为 'providers'</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"provider"</span>.equals(property) &amp;&amp; value.indexOf(<span class="string">','</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                parseMultiRef(<span class="string">"providers"</span>, value, beanDefinition, parserContext);</span><br><span class="line">                                <span class="comment">// 9.4 多协议情况，将多个协议处理成一个集合，然后设置到 beanDefinition 中，属性为 'protocols'</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"protocol"</span>.equals(property) &amp;&amp; value.indexOf(<span class="string">','</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                parseMultiRef(<span class="string">"protocols"</span>, value, beanDefinition, parserContext);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                Object reference;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 10. 属性类型为基本类型的情况</span></span><br><span class="line">                                <span class="keyword">if</span> (isPrimitive(type)) &#123;</span><br><span class="line">                                    <span class="comment">// 兼容性处理【一些设置了但是意义不大的属性就把值设置为null】</span></span><br><span class="line">                                    <span class="keyword">if</span> (<span class="string">"async"</span>.equals(property) &amp;&amp; <span class="string">"false"</span>.equals(value)</span><br><span class="line">                                            || <span class="string">"timeout"</span>.equals(property) &amp;&amp; <span class="string">"0"</span>.equals(value)</span><br><span class="line">                                            || <span class="string">"delay"</span>.equals(property) &amp;&amp; <span class="string">"0"</span>.equals(value)</span><br><span class="line">                                            || <span class="string">"version"</span>.equals(property) &amp;&amp; <span class="string">"0.0.0"</span>.equals(value)</span><br><span class="line">                                            || <span class="string">"stat"</span>.equals(property) &amp;&amp; <span class="string">"-1"</span>.equals(value)</span><br><span class="line">                                            || <span class="string">"reliable"</span>.equals(property) &amp;&amp; <span class="string">"false"</span>.equals(value)) &#123;</span><br><span class="line">                                        <span class="comment">// backward compatibility for the default value in old version's xsd</span></span><br><span class="line">                                        value = <span class="keyword">null</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    reference = value;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//11. 处理在&lt;dubbo:provider/&gt; 或者 &lt;dubbo:service/&gt; 上定义了 protocol 属性的兼容性，目前已经不推荐这样使用了，应该单独配置 &lt;dubbo:protocol/&gt;</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"protocol"</span>.equals(property)</span><br><span class="line">                                        &amp;&amp; ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">value</span>)</span></span><br><span class="line"><span class="class">                                        &amp;&amp; (!<span class="title">parserContext</span>.<span class="title">getRegistry</span>().<span class="title">containsBeanDefinition</span>(<span class="title">value</span>)</span></span><br><span class="line"><span class="class">                                        || !<span class="title">ProtocolConfig</span>.<span class="title">class</span>.<span class="title">getName</span>().<span class="title">equals</span>(<span class="title">parserContext</span>.<span class="title">getRegistry</span>().<span class="title">getBeanDefinition</span>(<span class="title">value</span>).<span class="title">getBeanClassName</span>()))) </span>&#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (<span class="string">"dubbo:provider"</span>.equals(element.getTagName())) &#123;</span><br><span class="line">                                        logger.warn(<span class="string">"Recommended replace &lt;dubbo:provider protocol=\""</span> + value + <span class="string">"\" ... /&gt; to &lt;dubbo:protocol name=\""</span> + value + <span class="string">"\" ... /&gt;"</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="comment">// backward compatibility</span></span><br><span class="line">                                    ProtocolConfig protocol = <span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">                                    protocol.setName(value);</span><br><span class="line">                                    reference = protocol;</span><br><span class="line"></span><br><span class="line">                              <span class="comment">//------- 12. 事件通知: 在调用前，调用后，出现异常，会触发oninvoke，onreturn,onthrow三个事件，可以配置当事件发生时，通知哪个类的哪个方法  ------//</span></span><br><span class="line">                              <span class="comment">/*</span></span><br><span class="line"><span class="comment">                              // 格式：实现Bean.方法</span></span><br><span class="line"><span class="comment">                              &lt;bean id="demoCallBack" class = "com.alibaba.dubbo.callback.implicit.NofifyImpl"/&gt;</span></span><br><span class="line"><span class="comment">                              &lt;dubbo:reference id = "demoService" interface="com.alibaba.dubbo.IDemoService"&gt;</span></span><br><span class="line"><span class="comment">                                  &lt;dubbo:method name="get" onreturn="demoCallBack.xxxMethod" onthrow="demoCallBack.xMethod"/&gt;</span></span><br><span class="line"><span class="comment">                              &lt;/dubbo:reference&gt;</span></span><br><span class="line"><span class="comment">                               */</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 12.1 处理 onreturn 属性</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"onreturn"</span>.equals(property)) &#123;</span><br><span class="line">                                    <span class="comment">// 按照 . 拆分</span></span><br><span class="line">                                    <span class="keyword">int</span> index = value.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">                                    <span class="comment">// 获取实例名</span></span><br><span class="line">                                    String returnRef = value.substring(<span class="number">0</span>, index);</span><br><span class="line">                                    <span class="comment">// 获取实例的方法</span></span><br><span class="line">                                    String returnMethod = value.substring(index + <span class="number">1</span>);</span><br><span class="line">                                    <span class="comment">// 创建 RuntimeBeanReference，指向回调的对象</span></span><br><span class="line">                                    reference = <span class="keyword">new</span> RuntimeBeanReference(returnRef);</span><br><span class="line">                                    <span class="comment">// 设置 onreturnMethod 到 BeanDefinition 的属性值</span></span><br><span class="line">                                    beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"onreturnMethod"</span>, returnMethod);</span><br><span class="line">                                    <span class="comment">// 12.2 处理 onthrow 属性</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"onthrow"</span>.equals(property)) &#123;</span><br><span class="line">                                    <span class="keyword">int</span> index = value.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">                                    String throwRef = value.substring(<span class="number">0</span>, index);</span><br><span class="line">                                    String throwMethod = value.substring(index + <span class="number">1</span>);</span><br><span class="line">                                    <span class="comment">// 创建 RuntimeBeanReference，指向回调的对象</span></span><br><span class="line">                                    reference = <span class="keyword">new</span> RuntimeBeanReference(throwRef);</span><br><span class="line">                                    <span class="comment">// 设置 onthrowMethod 到 BeanDefinition 的属性值</span></span><br><span class="line">                                    beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"onthrowMethod"</span>, throwMethod);</span><br><span class="line">                                    <span class="comment">//12.3  处理oninvoke 属性</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"oninvoke"</span>.equals(property)) &#123;</span><br><span class="line">                                    <span class="keyword">int</span> index = value.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">                                    String invokeRef = value.substring(<span class="number">0</span>, index);</span><br><span class="line">                                    String invokeRefMethod = value.substring(index + <span class="number">1</span>);</span><br><span class="line">                                    reference = <span class="keyword">new</span> RuntimeBeanReference(invokeRef);</span><br><span class="line">                                    beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"oninvokeMethod"</span>, invokeRefMethod);</span><br><span class="line">                                 </span><br><span class="line">                              <span class="comment">//-----------------------------  事件通知结束 ------------------------------//</span></span><br><span class="line">                                  </span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// 13. 属性名没有匹配到对应的标签名，都会到这里</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//13.1 如果属性名是ref, ref 对应的Bean 必须是单例的 </span></span><br><span class="line">                                    <span class="keyword">if</span> (<span class="string">"ref"</span>.equals(property) &amp;&amp; parserContext.getRegistry().containsBeanDefinition(value)) &#123;</span><br><span class="line">                                        BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);</span><br><span class="line">                                        <span class="keyword">if</span> (!refBean.isSingleton()) &#123;</span><br><span class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The exported service ref "</span> + value + <span class="string">" must be singleton! Please set the "</span> + value + <span class="string">" bean scope to singleton, eg: &lt;bean id=\""</span> + value + <span class="string">"\" scope=\"singleton\" ...&gt;"</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="comment">// 创建RuntimeBeanReference</span></span><br><span class="line">                                    reference = <span class="keyword">new</span> RuntimeBeanReference(value);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 设置Bean定义的属性</span></span><br><span class="line">                                beanDefinition.getPropertyValues().addPropertyValue(property, reference);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将标签中自定义的属性（不是Dubbo Schema 约定好的）也加入到 parameters 集合中</span></span><br><span class="line">        NamedNodeMap attributes = element.getAttributes();</span><br><span class="line">        <span class="keyword">int</span> len = attributes.getLength();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            Node node = attributes.item(i);</span><br><span class="line">            String name = node.getLocalName();</span><br><span class="line">            <span class="keyword">if</span> (!props.contains(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parameters == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    parameters = <span class="keyword">new</span> ManagedMap();</span><br><span class="line">                &#125;</span><br><span class="line">                String value = node.getNodeValue();</span><br><span class="line">                parameters.put(name, <span class="keyword">new</span> TypedStringValue(value, String<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">            beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"parameters"</span>, parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的代码是把属性注入到标签对应的BeanDefinition，如果属性是引用对象，Dubbo默认会创建 <code>RuntimeBeanReference</code> 类型注入，运行时由Spring注入引用对象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Dubbo框架解析配置文件生成BeanDefinition其实是生成标签对应的配置类的Bean定义，Bean定义中的属性值主要来源于标签的属性值，Dubbo对标签属性只是进行了提取，标签的内嵌标签处理也是如此，运行时属性注入和转换都还是Spring来完成的，Dubbo框架生成的BeanDefinition最终会委托Spring创建对应的对象，这个属于Spring的流程就不多说了。dubbo.xsd文件中定义的类型都会有与之对应的配置承载类中的属性，我们已经在API配置中介绍过了。XML配置解析还是挺复杂的，分支流比较多，下一章要分析的注解配置稍微比这个复杂一些。随着后面深入的分析就会发现这些东西都是基础，结合Dubbo的整个过程就很容易理解了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/1d3295e6/&quot;&gt;Dubbo源码分析 - API和属性
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - API和属性配置</title>
    <link href="https://gentryhuang.com/posts/1d3295e6/"/>
    <id>https://gentryhuang.com/posts/1d3295e6/</id>
    <published>2020-03-24T16:00:00.000Z</published>
    <updated>2020-09-03T03:12:53.647Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们通过 <a href="https://gentryhuang.com/posts/46f95e97/">Dubbo URL统一模型</a> 已经了解了Dubbo URL是Duboo的配置总线，贯穿整个Dubbo的生命周期。虽然Dubbo URL直接决定了Dubbo组件的角色并控制Dubbo的行为，但是Dubbo URL中的信息需要Dubbo的配置承对象来提供，而配置承载对象中的数据来源于多种配置和设置。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-config.jpg" alt></p><p>目前Dubbo框架同时支持4种配置方式：API硬编码配置、XML配置、注解配置、属性配置。而所有的配置项分为三大类:</p><ul><li>服务注册和发现：表示该配置项用于服务的注册和发现。</li><li>服务治理：表示该配置项用于治理服务间的关系，或为开发测试提供便利条件。</li><li>性能调优：表示该配置项用于调优性能，不同的选项对性能会产生影响。</li></ul><p>注意：所有配置最终都会转换为Dubbo URL</p><h3 id="配置承载对象"><a href="#配置承载对象" class="headerlink" title="配置承载对象"></a>配置承载对象</h3><p>不管是注解还是XML配置都需要配置对象来承载，XML配置、注解配置、属性配置都是和配置对象或其属性相映射的，为什么这里没有说API配置和配置对象的映射关系呢？其实API配置就是直接操作配置对象，而XML配置和注解配置都是由Spring来创建配置对象并设置属性的，而我们的属性配置是在配置对象已经存在的基础上，为其设置指定的属性值。下面是Dubbo的属性配置类的结构：<br><br></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-config-detail.jpg" alt></p><p>上图中我使用了黄色框和红色框分别对抽象配置类和配置实现类进行了标注，其中DubboShutdownHook先忽略。红色框中的配置类是直接的配置承载类，黄色框中的抽象配置类是配置承载类的父类。下面是配置承载类的UML图：</p><ul><li>直观图</li></ul><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-config-uml.jpg" alt></p><ul><li>依赖关系图</li></ul><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-config-uml-relation.png" alt></p><p>通过上面的关系图我们可以很清楚地了解到每个配置之间的关系，我们接下来就顺着关系图分别介绍核心的配置类。</p><h4 id="AbstractConfig-抽象配置类"><a href="#AbstractConfig-抽象配置类" class="headerlink" title="AbstractConfig 抽象配置类"></a>AbstractConfig 抽象配置类</h4><p>除了ArgumentConfig配置类，几乎其他的所有配置类都直接或间接继承该类，该类主要提供配置解析与校验相关的工具方法。</p><h5 id="格式校验"><a href="#格式校验" class="headerlink" title="格式校验"></a>格式校验</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------- 格式检验 -----------------------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LENGTH = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PATH_LENGTH = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATTERN_NAME = Pattern.compile(<span class="string">"[\\-._0-9a-zA-Z]+"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATTERN_MULTI_NAME = Pattern.compile(<span class="string">"[,\\-._0-9a-zA-Z]+"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATTERN_METHOD_NAME = Pattern.compile(<span class="string">"[a-zA-Z][0-9a-zA-Z]*"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATTERN_PATH = Pattern.compile(<span class="string">"[/\\-$._0-9a-zA-Z]+"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATTERN_NAME_HAS_SYMBOL = Pattern.compile(<span class="string">"[:*,/\\-._0-9a-zA-Z]+"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATTERN_KEY = Pattern.compile(<span class="string">"[*,\\-._0-9a-zA-Z]+"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkExtension</span><span class="params">(Class&lt;?&gt; type, String property, String value)</span> </span>&#123;</span><br><span class="line">            checkName(property, value);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; !ExtensionLoader.getExtensionLoader(type).hasExtension(value)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such extension "</span> + value + <span class="string">" for "</span> + property + <span class="string">"/"</span> + type.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMultiExtension</span><span class="params">(Class&lt;?&gt; type, String property, String value)</span> </span>&#123;</span><br><span class="line">            checkMultiName(property, value);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                String[] values = value.split(<span class="string">"\\s*[,]+\\s*"</span>);</span><br><span class="line">                <span class="keyword">for</span> (String v : values) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v.startsWith(Constants.REMOVE_VALUE_PREFIX)) &#123;</span><br><span class="line">                        v = v.substring(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (Constants.DEFAULT_KEY.equals(v)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!ExtensionLoader.getExtensionLoader(type).hasExtension(v)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such extension "</span> + v + <span class="string">" for "</span> + property + <span class="string">"/"</span> + type.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkLength</span><span class="params">(String property, String value)</span> </span>&#123;</span><br><span class="line">            checkProperty(property, value, MAX_LENGTH, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkPathLength</span><span class="params">(String property, String value)</span> </span>&#123;</span><br><span class="line">            checkProperty(property, value, MAX_PATH_LENGTH, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkName</span><span class="params">(String property, String value)</span> </span>&#123;</span><br><span class="line">            checkProperty(property, value, MAX_LENGTH, PATTERN_NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkNameHasSymbol</span><span class="params">(String property, String value)</span> </span>&#123;</span><br><span class="line">            checkProperty(property, value, MAX_LENGTH, PATTERN_NAME_HAS_SYMBOL);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkKey</span><span class="params">(String property, String value)</span> </span>&#123;</span><br><span class="line">            checkProperty(property, value, MAX_LENGTH, PATTERN_KEY);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMultiName</span><span class="params">(String property, String value)</span> </span>&#123;</span><br><span class="line">            checkProperty(property, value, MAX_LENGTH, PATTERN_MULTI_NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkPathName</span><span class="params">(String property, String value)</span> </span>&#123;</span><br><span class="line">            checkProperty(property, value, MAX_PATH_LENGTH, PATTERN_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMethodName</span><span class="params">(String property, String value)</span> </span>&#123;</span><br><span class="line">            checkProperty(property, value, MAX_LENGTH, PATTERN_METHOD_NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkParameterName</span><span class="params">(Map&lt;String, String&gt; parameters)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parameters == <span class="keyword">null</span> || parameters.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : parameters.entrySet()) &#123;</span><br><span class="line">                checkNameHasSymbol(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkProperty</span><span class="params">(String property, String value, <span class="keyword">int</span> maxlength, Pattern pattern)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value.length() &gt; maxlength) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid "</span> + property + <span class="string">"=\""</span> + value + <span class="string">"\" is longer than "</span> + maxlength);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Matcher matcher = pattern.matcher(value);</span><br><span class="line">                <span class="keyword">if</span> (!matcher.matches()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid "</span> + property + <span class="string">"=\""</span> + value + <span class="string">"\" contains illegal "</span> +</span><br><span class="line">                            <span class="string">"character, only digit, letter, '-', '_' or '.' is legal."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractConfig的子类会调用这里的方法进行相关的参数校验。</p><h5 id="添加属性（属性和系统参数配置）"><a href="#添加属性（属性和系统参数配置）" class="headerlink" title="添加属性（属性和系统参数配置）"></a>添加属性（属性和系统参数配置）</h5><p>读取启动参数变量和Properties配置文件中属性到配置承载对象中，该方法其实就是<code>属性配置</code> 和 <code>系统参数配置</code>的逻辑。这个逻辑非常重要，无论是API配置还是XML配置，以及注解配置，都会使用该逻辑为配置承载对象设置系统参数值以及配置属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1 id 属性，Bean定义的名称，适用于除了API配置之外的三种配置（属性配置，xml配置,注解配置）方式，可用于对象之间的引用</span></span><br><span class="line"><span class="comment">     * 2 不适用API配置，是因为API配置直接setter(xxx)对象即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String id;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取带有配置项名前缀的启动参数变量和properties配置到 配置承载对象中。</span></span><br><span class="line"><span class="comment">     * 说明：在此之前配置承载对象中只可能有xml配置的属性值，或者注解配置的属性值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config 配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendProperties</span><span class="params">(AbstractConfig config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得配置项前缀（使用配置类的类名，获得对应的属性标签）-&gt; dubbo.tag.</span></span><br><span class="line">        String prefix = <span class="string">"dubbo."</span> + getTagName(config.getClass()) + <span class="string">"."</span>;</span><br><span class="line">        <span class="comment">// 获得配置类的所有方法，用于下面通过反射获得配置项的属性名，再用属性名去读取启动参数变量和.properties配置到配置对象</span></span><br><span class="line">        Method[] methods = config.getClass().getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 拿到方法名</span></span><br><span class="line">                String name = method.getName();</span><br><span class="line">                <span class="comment">// 选择方法是 【public &amp;&amp; setter &amp;&amp; 唯一参数为基本类型】 的方法</span></span><br><span class="line">                <span class="keyword">if</span> (name.length() &gt; <span class="number">3</span> &amp;&amp; name.startsWith(<span class="string">"set"</span>) &amp;&amp; Modifier.isPublic(method.getModifiers())</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == <span class="number">1</span> &amp;&amp; isPrimitive(method.getParameterTypes()[<span class="number">0</span>])) &#123;</span><br><span class="line">                    <span class="comment">// 获得属性名 如： ApplicationConfig#setName(...) 方法，对应的属性名为 name</span></span><br><span class="line">                    String property = StringUtils.camelToSplitName(name.substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + name.substring(<span class="number">4</span>), <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//----------- 读取的覆盖策略： JVM -D &gt; XML &gt; .properties   ----------/</span></span><br><span class="line"></span><br><span class="line">                    String value = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【启动参数变量】优先从带有 id属性的XxxConfig的配置中获取，例如 dubbo.application.demo-provider.name</span></span><br><span class="line">                    <span class="keyword">if</span> (config.getId() != <span class="keyword">null</span> &amp;&amp; config.getId().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// id字段</span></span><br><span class="line">                        String pn = prefix + config.getId() + <span class="string">"."</span> + property;</span><br><span class="line">                        value = System.getProperty(pn);</span><br><span class="line">                        <span class="keyword">if</span> (!StringUtils.isBlank(value)) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Use System Property "</span> + pn + <span class="string">" to config dubbo"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//【启动参数变量】获取不到，再从不带 id属性 的XxxConfig的配置中获取，例如：dubbo.application.name</span></span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 没有id字段</span></span><br><span class="line">                        String pn = prefix + property;</span><br><span class="line">                        value = System.getProperty(pn);</span><br><span class="line">                        <span class="keyword">if</span> (!StringUtils.isBlank(value)) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Use System Property "</span> + pn + <span class="string">" to config dubbo"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 配置优先级以及覆盖： 启动参数变量 &gt; XML配置[注解/java配置] &gt; properties配置 。因此需要使用getter判断XML是否已经配置</span></span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        Method getter;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            getter = config.getClass().getMethod(<span class="string">"get"</span> + name.substring(<span class="number">3</span>));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                getter = config.getClass().getMethod(<span class="string">"is"</span> + name.substring(<span class="number">3</span>));</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (NoSuchMethodException e2) &#123;</span><br><span class="line">                                getter = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (getter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 使用getter 判断XML是否已经设置过，如果没有设置的话就从.properties文件中读取</span></span><br><span class="line">                            <span class="keyword">if</span> (getter.invoke(config) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// [properties配置] 优先从带有 id 属性的配置中获取，例如：dubbo.application.demo-provider.name</span></span><br><span class="line">                                <span class="keyword">if</span> (config.getId() != <span class="keyword">null</span> &amp;&amp; config.getId().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    value = ConfigUtils.getProperty(prefix + config.getId() + <span class="string">"."</span> + property);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// [properties配置]获取不到，再从不带 id 属性的配置中获取，例如：dubbo.application.name</span></span><br><span class="line">                                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                                    value = ConfigUtils.getProperty(prefix + property);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// [properties配置]获取不到，这里进行老版本兼容，从不带id属性的配置中获取</span></span><br><span class="line">                                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                                    String legacyKey = legacyProperties.get(prefix + property);</span><br><span class="line">                                    <span class="keyword">if</span> (legacyKey != <span class="keyword">null</span> &amp;&amp; legacyKey.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                        value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 获取到值（系统参数配置或者.properties文件中的，不包含xml配置，xml配置有单独的设置方法）</span></span><br><span class="line">                    <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        method.invoke(config, convertPrimitive(method.getParameterTypes()[<span class="number">0</span>], value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要就是为已经实例化好的配置承载对象设置属性值，主要逻辑如下：</p><ol><li>根据配置对象获取属性配置的前缀，如 dubbo.application.</li><li>遍历配置承载对象中的所有方法找到符合条件的setter方法</li><li>根据配置覆盖策略的优先级，设置配置承载对象的属性值</li></ol><h5 id="配置对象的属性到参数集合"><a href="#配置对象的属性到参数集合" class="headerlink" title="配置对象的属性到参数集合"></a>配置对象的属性到参数集合</h5><p>将配置承载对象的属性添加到参数集合中，用于构建Dubbo URL，如在服务暴露和引用是构建相关的URL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将配置对象的属性添加到参数集合</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> parameters</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendParameters</span><span class="params">(Map&lt;String, String&gt; parameters, Object config)</span> </span>&#123;</span><br><span class="line">           appendParameters(parameters, config, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将配置对象的属性添加到参数集合，主要逻辑：</span></span><br><span class="line"><span class="comment">        * &lt;p&gt;</span></span><br><span class="line"><span class="comment">        * 1 通过反射获取目标对象的getter方法，并调用该方法获取属性值，然后再通过getter方法名解析出属性名，如：从方法名getName中可解析出属性name，如果用户传入了属性名前缀，此时需要将属性名加入前缀内容。</span></span><br><span class="line"><span class="comment">        * 2 将 属性名-属性值 键值对存入到map中就可以了</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> parameters 参数集合，该集合会用于URL</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> config     配置对象</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> prefix     属性前缀。用于配置项添加到参数集合中时的前缀</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendParameters</span><span class="params">(Map&lt;String, String&gt; parameters, Object config, String prefix)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 获得所有方法的数组，为下面通过反射获得配置项的值做准备</span></span><br><span class="line">           Method[] methods = config.getClass().getMethods();</span><br><span class="line">           <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   String name = method.getName();</span><br><span class="line">                   <span class="comment">// 选择方法为 返回值为基本类型 + public的getter/is方法 （和解析到配置类的过滤添加呼应）</span></span><br><span class="line">                   <span class="keyword">if</span> ((name.startsWith(<span class="string">"get"</span>) || name.startsWith(<span class="string">"is"</span>))</span><br><span class="line">                           &amp;&amp; !<span class="string">"getClass"</span>.equals(name)</span><br><span class="line">                           &amp;&amp; Modifier.isPublic(method.getModifiers())</span><br><span class="line">                           &amp;&amp; method.getParameterTypes().length == <span class="number">0</span></span><br><span class="line">                           &amp;&amp; isPrimitive(method.getReturnType())) &#123;</span><br><span class="line">                       <span class="comment">// 尝试获取方法上的@Parameter注解</span></span><br><span class="line">                       Parameter parameter = method.getAnnotation(Parameter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                       <span class="comment">// 方法返回类型是Object的或者方法的@Parameter(excluded = true)的， 不统计对应的值到参数集合</span></span><br><span class="line">                       <span class="keyword">if</span> (method.getReturnType() == Object<span class="class">.<span class="keyword">class</span> || <span class="title">parameter</span> !</span>= <span class="keyword">null</span> &amp;&amp; parameter.excluded()) &#123;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 获得属性名</span></span><br><span class="line">                       <span class="keyword">int</span> i = name.startsWith(<span class="string">"get"</span>) ? <span class="number">3</span> : <span class="number">2</span>;</span><br><span class="line">                       String prop = StringUtils.camelToSplitName(name.substring(i, i + <span class="number">1</span>).toLowerCase() + name.substring(i + <span class="number">1</span>), <span class="string">"."</span>);</span><br><span class="line">                       String key;</span><br><span class="line">                       <span class="comment">// @Parameter注解有配置key属性就取出该值</span></span><br><span class="line">                       <span class="keyword">if</span> (parameter != <span class="keyword">null</span> &amp;&amp; parameter.key().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           key = parameter.key();</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           key = prop;</span><br><span class="line">                       &#125;</span><br><span class="line">   </span><br><span class="line">                       <span class="comment">// 利用反射获得属性的值</span></span><br><span class="line">                       Object value = method.invoke(config);</span><br><span class="line">                       String str = String.valueOf(value).trim();</span><br><span class="line">                       <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 是否转移，默认不转译</span></span><br><span class="line">                           <span class="keyword">if</span> (parameter != <span class="keyword">null</span> &amp;&amp; parameter.escaped()) &#123;</span><br><span class="line">                               str = URL.encode(str);</span><br><span class="line">                           &#125;</span><br><span class="line">   </span><br><span class="line">                           <span class="comment">// @Parameter注解有配置append属性，就进行拼接</span></span><br><span class="line">                           <span class="keyword">if</span> (parameter != <span class="keyword">null</span> &amp;&amp; parameter.append()) &#123;</span><br><span class="line">                               <span class="comment">// 1. 看参数集合中是否有key为： default.key的值(默认属性值),有就拼接到属性值前面</span></span><br><span class="line">                               String pre = parameters.get(Constants.DEFAULT_KEY + <span class="string">"."</span> + key);</span><br><span class="line">                               <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                   str = pre + <span class="string">","</span> + str;</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="comment">// 2. 看参数集合中是否有key对应的值，有就拼接到属性值前面</span></span><br><span class="line">                               pre = parameters.get(key);</span><br><span class="line">                               <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                   str = pre + <span class="string">","</span> + str;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 如果指定了属性前缀就拼接上去，就在属性名前面加上前缀</span></span><br><span class="line">                           <span class="keyword">if</span> (prefix != <span class="keyword">null</span> &amp;&amp; prefix.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                               key = prefix + <span class="string">"."</span> + key;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 把最后处理的属性值加入参数集合中</span></span><br><span class="line">                           parameters.put(key, str);</span><br><span class="line">                           <span class="comment">// 当配置对象的属性getter方法加了@Parameter(required=true)时，校验配置项非空</span></span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameter != <span class="keyword">null</span> &amp;&amp; parameter.required()) &#123;</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(config.getClass().getSimpleName() + <span class="string">"."</span> + key + <span class="string">" == null"</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 当方法为public Map getParameters()&#123;...&#125;时，就以此将Map中的key-value加入到参数集合</span></span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"getParameters"</span>.equals(name)</span><br><span class="line">                           &amp;&amp; Modifier.isPublic(method.getModifiers())</span><br><span class="line">                           &amp;&amp; method.getParameterTypes().length == <span class="number">0</span></span><br><span class="line">                           &amp;&amp; method.getReturnType() == Map<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                       <span class="comment">// 通过 getParameters()方法，获取动态设置的配置项</span></span><br><span class="line">                       Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) method.invoke(config, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">                       <span class="keyword">if</span> (map != <span class="keyword">null</span> &amp;&amp; map.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           String pre = (prefix != <span class="keyword">null</span> &amp;&amp; prefix.length() &gt; <span class="number">0</span> ? prefix + <span class="string">"."</span> : <span class="string">""</span>);</span><br><span class="line">                           <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                               parameters.put(pre + entry.getKey().replace(<span class="string">'-'</span>, <span class="string">'.'</span>), entry.getValue());</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码主要就是将配置承载对象中的属性设置到属性集合Map中，用于构建Dubbo URL。整个逻辑需要注意，配置承载对象的getter方法上标注的 <code>@Parameter</code> 注解，以及配置承载对象的getParameters方法。</p><h5 id="添加事件通知属性"><a href="#添加事件通知属性" class="headerlink" title="添加事件通知属性"></a>添加事件通知属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendAttributes</span><span class="params">(Map&lt;Object, Object&gt; parameters, Object config)</span> </span>&#123;</span><br><span class="line">           appendAttributes(parameters, config, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> parameters 参数集合</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> config     配置对象</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> prefix     属性前缀。用于配置项添加到参数集合中时的前缀</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendAttributes</span><span class="params">(Map&lt;Object, Object&gt; parameters, Object config, String prefix)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           Method[] methods = config.getClass().getMethods();</span><br><span class="line">           <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   String name = method.getName();</span><br><span class="line">                   <span class="comment">// 选择方法为 返回值为基本类型 + public的getter/is方法 （和解析到配置类的过滤添加呼应）</span></span><br><span class="line">                   <span class="keyword">if</span> ((name.startsWith(<span class="string">"get"</span>) || name.startsWith(<span class="string">"is"</span>))</span><br><span class="line">                           &amp;&amp; !<span class="string">"getClass"</span>.equals(name)</span><br><span class="line">                           &amp;&amp; Modifier.isPublic(method.getModifiers())</span><br><span class="line">                           &amp;&amp; method.getParameterTypes().length == <span class="number">0</span></span><br><span class="line">                           &amp;&amp; isPrimitive(method.getReturnType())) &#123;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 选择带有@Parameter(attribute=true)的方法</span></span><br><span class="line">                       Parameter parameter = method.getAnnotation(Parameter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                       <span class="keyword">if</span> (parameter == <span class="keyword">null</span> || !parameter.attribute()) &#123;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       String key;</span><br><span class="line">                       parameter.key();</span><br><span class="line">                       <span class="keyword">if</span> (parameter.key().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           key = parameter.key();</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">int</span> i = name.startsWith(<span class="string">"get"</span>) ? <span class="number">3</span> : <span class="number">2</span>;</span><br><span class="line">                           key = name.substring(i, i + <span class="number">1</span>).toLowerCase() + name.substring(i + <span class="number">1</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 获得属性值，存在则添加到参数集合中</span></span><br><span class="line">                       Object value = method.invoke(config);</span><br><span class="line">                       <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (prefix != <span class="keyword">null</span> &amp;&amp; prefix.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                               key = prefix + <span class="string">"."</span> + key;</span><br><span class="line">                           &#125;</span><br><span class="line">                           parameters.put(key, value);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码主要用于Dubbo的事件通知的，具体是标注在MethodConfig配置承载对象的 getOnreturn(),getOnreturnMethod(),getOnthrow()…方法上。</p><h4 id="AbstractInterfaceConfig-抽象配置类"><a href="#AbstractInterfaceConfig-抽象配置类" class="headerlink" title="AbstractInterfaceConfig 抽象配置类"></a>AbstractInterfaceConfig 抽象配置类</h4><p>继承关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractConfig</span><br><span class="line">  - AbstractMethodConfig</span><br><span class="line">    - AbstractInterfaceConfig</span><br></pre></td></tr></table></figure><p>AbstractConfig抽象类的核心逻辑已经分析过，AbstractMethodConfig抽象类中没有比较重要的逻辑，基本都是 <code>配置属性的设置/获取方法</code>，就不再分析，接下来我们一起看下AbstractInterfaceConfig抽象类的逻辑。</p><h5 id="校验注册中心配置"><a href="#校验注册中心配置" class="headerlink" title="校验注册中心配置"></a>校验注册中心配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInterfaceConfig</span> <span class="keyword">extends</span> <span class="title">AbstractMethodConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// for backward compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (registries == <span class="keyword">null</span> || registries.isEmpty()) &#123;</span><br><span class="line">            String address = ConfigUtils.getProperty(<span class="string">"dubbo.registry.address"</span>);</span><br><span class="line">            <span class="keyword">if</span> (address != <span class="keyword">null</span> &amp;&amp; address.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                registries = <span class="keyword">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class="line">                String[] as = address.split(<span class="string">"\\s*[|]+\\s*"</span>);</span><br><span class="line">                <span class="keyword">for</span> (String a : as) &#123;</span><br><span class="line">                    RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">                    registryConfig.setAddress(a);</span><br><span class="line">                    registries.add(registryConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((registries == <span class="keyword">null</span> || registries.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException((getClass().getSimpleName().startsWith(<span class="string">"Reference"</span>)</span><br><span class="line">                    ? <span class="string">"No such any registry to refer service in consumer "</span></span><br><span class="line">                    : <span class="string">"No such any registry to export service in provider "</span>)</span><br><span class="line">                    + NetUtils.getLocalHost()</span><br><span class="line">                    + <span class="string">" use dubbo version "</span></span><br><span class="line">                    + Version.getVersion()</span><br><span class="line">                    + <span class="string">", Please add &lt;dubbo:registry address=\"...\" /&gt; to your spring config. If you want unregister, please set &lt;dubbo:service registry=\"N/A\" /&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (RegistryConfig registryConfig : registries) &#123;</span><br><span class="line">            <span class="comment">// 调用AbstractConfig中的方法</span></span><br><span class="line">            appendProperties(registryConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="校验应用配置"><a href="#校验应用配置" class="headerlink" title="校验应用配置"></a>校验应用配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInterfaceConfig</span> <span class="keyword">extends</span> <span class="title">AbstractMethodConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// for backward compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String applicationName = ConfigUtils.getProperty(<span class="string">"dubbo.application.name"</span>);</span><br><span class="line">            <span class="keyword">if</span> (applicationName != <span class="keyword">null</span> &amp;&amp; applicationName.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                application = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"No such application config! Please add &lt;dubbo:application name=\"...\" /&gt; to your spring config."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用AbstractConfig中的方法</span></span><br><span class="line">        appendProperties(application);</span><br><span class="line"></span><br><span class="line">        String wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_KEY);</span><br><span class="line">        <span class="keyword">if</span> (wait != <span class="keyword">null</span> &amp;&amp; wait.trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.setProperty(Constants.SHUTDOWN_WAIT_KEY, wait.trim());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY);</span><br><span class="line">            <span class="keyword">if</span> (wait != <span class="keyword">null</span> &amp;&amp; wait.trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.setProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY, wait.trim());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加载注册中心URL数组"><a href="#加载注册中心URL数组" class="headerlink" title="加载注册中心URL数组"></a>加载注册中心URL数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInterfaceConfig</span> <span class="keyword">extends</span> <span class="title">AbstractMethodConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 加载注册中心URL数组</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> provider 是否是服务提供者</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> URL数组</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> List&lt;URL&gt; <span class="title">loadRegistries</span><span class="params">(<span class="keyword">boolean</span> provider)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 校验RegistryConfig 配置数组，不存在会抛出异常，并且该方法会初始化RegistryConfig的配置属性</span></span><br><span class="line">         checkRegistry();</span><br><span class="line">         <span class="comment">// 创建注册中心URL数组</span></span><br><span class="line">         List&lt;URL&gt; registryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">         <span class="keyword">if</span> (registries != <span class="keyword">null</span> &amp;&amp; !registries.isEmpty()) &#123;</span><br><span class="line">             <span class="comment">// 遍历RegistryConfig 数组</span></span><br><span class="line">             <span class="keyword">for</span> (RegistryConfig config : registries) &#123;</span><br><span class="line">                 <span class="comment">// 获取注册中心的地址</span></span><br><span class="line">                 String address = config.getAddress();</span><br><span class="line">                 <span class="comment">// 地址为空就使用 0.0.0.0 任意地址</span></span><br><span class="line">                 <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                     address = Constants.ANYHOST_VALUE;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">// 如果配置了启动参数的注册中心地址，它的优先级最高，就进行覆盖</span></span><br><span class="line">                 String sysaddress = System.getProperty(<span class="string">"dubbo.registry.address"</span>);</span><br><span class="line">                 <span class="keyword">if</span> (sysaddress != <span class="keyword">null</span> &amp;&amp; sysaddress.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                     address = sysaddress;</span><br><span class="line">                 &#125;</span><br><span class="line"> </span><br><span class="line">                 <span class="comment">// 选择有效的注册中心地址</span></span><br><span class="line">                 <span class="keyword">if</span> (address.length() &gt; <span class="number">0</span> &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123;</span><br><span class="line"> </span><br><span class="line">                     <span class="comment">// 创建参数集合map,用于Dubbo URL的构建</span></span><br><span class="line">                     Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"> </span><br><span class="line">                     <span class="comment">// 将应用配置对象和注册中心配置对象的属性添加到参数集合map中</span></span><br><span class="line">                     appendParameters(map, application);</span><br><span class="line">                     <span class="comment">/**</span></span><br><span class="line"><span class="comment">                      * 需要注意的是：RegistryConfig 的 getAddress方法上使用了 <span class="doctag">@Parameter</span>(excluded = true)注解，因此它的address属性不会加入到参数集合map中</span></span><br><span class="line"><span class="comment">                      *  <span class="doctag">@Parameter</span>(excluded = true)</span></span><br><span class="line"><span class="comment">                      *  public String getAddress() &#123;return address;&#125;</span></span><br><span class="line"><span class="comment">                      */</span></span><br><span class="line">                     appendParameters(map, config);</span><br><span class="line"> </span><br><span class="line">                     <span class="comment">// 添加 path,dubbo,timestamp,pid 到参数集合map中</span></span><br><span class="line">                     map.put(<span class="string">"path"</span>, RegistryService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>; <span class="comment">// 这里的path要和服务暴露逻辑中的path区分，注册中心的URL中的path为RegistryService的全路径名</span></span><br><span class="line">                     map.put(<span class="string">"dubbo"</span>, Version.getProtocolVersion());</span><br><span class="line">                     map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                     <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                         map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">                     &#125;</span><br><span class="line"> </span><br><span class="line">                     <span class="comment">// 参数集合map中不存在 protocol 参数【以上配置对象的属性中没有有效的协议protocol参数】，就默认 使用 dubbo 作为 协议protocol的值</span></span><br><span class="line">                     <span class="keyword">if</span> (!map.containsKey(<span class="string">"protocol"</span>)) &#123;</span><br><span class="line">                         <span class="comment">// 不需考虑remote扩展实现的情况</span></span><br><span class="line">                         if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension("remote")) &#123;</span><br><span class="line">                             map.put(<span class="string">"protocol"</span>, <span class="string">"remote"</span>);</span><br><span class="line">                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                             map.put(<span class="string">"protocol"</span>, <span class="string">"dubbo"</span>);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line"> </span><br><span class="line">                     <span class="comment">// 解析地址，创建Dubbo URL数组，注意address可能包含多个注册中心ip, 【数组大小可以为一】</span></span><br><span class="line">                     List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map);</span><br><span class="line"> </span><br><span class="line">                     <span class="comment">// 循环 dubbo Register url</span></span><br><span class="line">                     <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                         <span class="comment">// 设置 registry=$&#123;protocol&#125;参数,设置到注册中心的 URL的参数部分的位置上，并且是追加式的添加</span></span><br><span class="line">                         url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());</span><br><span class="line">                         <span class="comment">// 重置 URL中的 protocol属性为 'registry',即将URL的协议头设置为'registry'</span></span><br><span class="line">                         url = url.setProtocol(Constants.REGISTRY_PROTOCOL);</span><br><span class="line">                         <span class="comment">/**</span></span><br><span class="line"><span class="comment">                          * 通过判断条件，决定是否添加url到registryList中，条件如下：</span></span><br><span class="line"><span class="comment">                          * 1 如果是服务提供者,是否只订阅不注册，如果是就不添加到注册中心URL数组中</span></span><br><span class="line"><span class="comment">                          * 2 如果是服务消费者，是否是只注册不订阅，如果是就不添加到注册中心URL数组中</span></span><br><span class="line"><span class="comment">                          *</span></span><br><span class="line"><span class="comment">                          */</span></span><br><span class="line">                         <span class="keyword">if</span> ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="keyword">true</span>)) || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, <span class="keyword">true</span>))) &#123;</span><br><span class="line">                             registryList.add(url);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> registryList;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加载监控中心URL"><a href="#加载监控中心URL" class="headerlink" title="加载监控中心URL"></a>加载监控中心URL</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInterfaceConfig</span> <span class="keyword">extends</span> <span class="title">AbstractMethodConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载监控中心URL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registryURL 注册中心URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 监控中心URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> URL <span class="title">loadMonitor</span><span class="params">(URL registryURL)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果监控配置为空，就从属性配置中加载配置到MonitorConfig</span></span><br><span class="line">        <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取监控地址</span></span><br><span class="line">            String monitorAddress = ConfigUtils.getProperty(<span class="string">"dubbo.monitor.address"</span>);</span><br><span class="line">            <span class="comment">// 获取监控协议</span></span><br><span class="line">            String monitorProtocol = ConfigUtils.getProperty(<span class="string">"dubbo.monitor.protocol"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有配置就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> ((monitorAddress == <span class="keyword">null</span> || monitorAddress.length() == <span class="number">0</span>) &amp;&amp; (monitorProtocol == <span class="keyword">null</span> || monitorProtocol.length() == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建MonitorConfig</span></span><br><span class="line">            monitor = <span class="keyword">new</span> MonitorConfig();</span><br><span class="line">            <span class="keyword">if</span> (monitorAddress != <span class="keyword">null</span> &amp;&amp; monitorAddress.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                monitor.setAddress(monitorAddress);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (monitorProtocol != <span class="keyword">null</span> &amp;&amp; monitorProtocol.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                monitor.setProtocol(monitorProtocol);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为MonitorConfig加载配置【启动参数变量和properties配置到配置对象】</span></span><br><span class="line">        appendProperties(monitor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 interface,dubbo,timestamp,pid 到 map 集合中</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(Constants.INTERFACE_KEY, MonitorService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        map.put(<span class="string">"dubbo"</span>, Version.getProtocolVersion());</span><br><span class="line">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//set ip</span></span><br><span class="line">        String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);</span><br><span class="line">        <span class="keyword">if</span> (hostToRegistry == <span class="keyword">null</span> || hostToRegistry.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            hostToRegistry = NetUtils.getLocalHost();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInvalidLocalHost(hostToRegistry)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Specified invalid registry ip from property:"</span> + Constants.DUBBO_IP_TO_REGISTRY + <span class="string">", value:"</span> + hostToRegistry);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(Constants.REGISTER_IP_KEY, hostToRegistry);</span><br><span class="line"></span><br><span class="line">        appendParameters(map, monitor);</span><br><span class="line">        appendParameters(map, application);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得监控地址</span></span><br><span class="line">        String address = monitor.getAddress();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果启动参数配置了监控中心地址，就进行覆盖，启动参数优先级最高</span></span><br><span class="line">        String sysaddress = System.getProperty(<span class="string">"dubbo.monitor.address"</span>);</span><br><span class="line">        <span class="keyword">if</span> (sysaddress != <span class="keyword">null</span> &amp;&amp; sysaddress.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            address = sysaddress;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直连监控中心服务器地址</span></span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isNotEmpty(address)) &#123;</span><br><span class="line">            <span class="comment">// 若监控地址不存在 protocol 参数，默认 dubbo 添加到 map 集合中</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(Constants.PROTOCOL_KEY)) &#123;</span><br><span class="line">                <span class="comment">// logstat这个拓展实现已经不存在了,可以忽略</span></span><br><span class="line">                if (ExtensionLoader.getExtensionLoader(MonitorFactory.class).hasExtension("logstat")) &#123;</span><br><span class="line">                    map.put(Constants.PROTOCOL_KEY, <span class="string">"logstat"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(Constants.PROTOCOL_KEY, <span class="string">"dubbo"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析地址，创建Dubbo URL 对象</span></span><br><span class="line">            <span class="keyword">return</span> UrlUtils.parseURL(address, map);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1  当 protocol=registry时，并且注册中心URL非空时，从注册中心发现监控中心地址，以注册中心URL为基础，创建监控中心URL</span></span><br><span class="line"><span class="comment">             * 2  基于注册中心创建的监控中心URL： protocol = dubbo,parameters.protocol=registry,parameter.refer=map</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(monitor.getProtocol()) &amp;&amp; registryURL != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> registryURL.setProtocol(<span class="string">"dubbo"</span>).addParameter(Constants.PROTOCOL_KEY, <span class="string">"registry"</span>).addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="校验接口和方法列表"><a href="#校验接口和方法列表" class="headerlink" title="校验接口和方法列表"></a>校验接口和方法列表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInterfaceConfig</span> <span class="keyword">extends</span> <span class="title">AbstractMethodConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验接口和方法：</span></span><br><span class="line"><span class="comment">     * 1 接口类必须非空并且必须是接口</span></span><br><span class="line"><span class="comment">     * 2 方法在接口中已经定义</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaceClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methods</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkInterfaceAndMethods</span><span class="params">(Class&lt;?&gt; interfaceClass, List&lt;MethodConfig&gt; methods)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// interface cannot be null</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"interface not allow null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// to verify interfaceClass is an interface</span></span><br><span class="line">        <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The interface class "</span> + interfaceClass + <span class="string">" is not a interface!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check if methods exist in the interface</span></span><br><span class="line">        <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (MethodConfig methodBean : methods) &#123;</span><br><span class="line">                String methodName = methodBean.getName();</span><br><span class="line">                <span class="keyword">if</span> (methodName == <span class="keyword">null</span> || methodName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"&lt;dubbo:method&gt; name attribute is required! Please check: &lt;dubbo:service interface=\""</span> + interfaceClass.getName() + <span class="string">"\" ... &gt;&lt;dubbo:method name=\"\" ... /&gt;&lt;/&lt;dubbo:reference&gt;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> hasMethod = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (java.lang.reflect.Method method : interfaceClass.getMethods()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (method.getName().equals(methodName)) &#123;</span><br><span class="line">                        hasMethod = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!hasMethod) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The interface "</span> + interfaceClass.getName()</span><br><span class="line">                            + <span class="string">" not found method "</span> + methodName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="校验Stub和Mock相关的配置"><a href="#校验Stub和Mock相关的配置" class="headerlink" title="校验Stub和Mock相关的配置"></a>校验Stub和Mock相关的配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInterfaceConfig</span> <span class="keyword">extends</span> <span class="title">AbstractMethodConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验Stub和Mock相关的配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaceClass</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkStubAndMock</span><span class="params">(Class&lt;?&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isNotEmpty(local)) &#123;</span><br><span class="line">            Class&lt;?&gt; localClass = ConfigUtils.isDefault(local) ? ReflectUtils.forName(interfaceClass.getName() + <span class="string">"Local"</span>) : ReflectUtils.forName(local);</span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The local implementation class "</span> + localClass.getName() + <span class="string">" not implement interface "</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ReflectUtils.findConstructor(localClass, interfaceClass);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such constructor \"public "</span> + localClass.getSimpleName() + <span class="string">"("</span> + interfaceClass.getName() + <span class="string">")\" in local implementation class "</span> + localClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isNotEmpty(stub)) &#123;</span><br><span class="line">            Class&lt;?&gt; localClass = ConfigUtils.isDefault(stub) ? ReflectUtils.forName(interfaceClass.getName() + <span class="string">"Stub"</span>) : ReflectUtils.forName(stub);</span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The local implementation class "</span> + localClass.getName() + <span class="string">" not implement interface "</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ReflectUtils.findConstructor(localClass, interfaceClass);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such constructor \"public "</span> + localClass.getSimpleName() + <span class="string">"("</span> + interfaceClass.getName() + <span class="string">")\" in local implementation class "</span> + localClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mock 配置校验</span></span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isNotEmpty(mock)) &#123;</span><br><span class="line">            <span class="comment">// 如果mock以 'return' 开头，则去掉该前缀</span></span><br><span class="line">            <span class="keyword">if</span> (mock.startsWith(Constants.RETURN_PREFIX)) &#123;</span><br><span class="line">                <span class="comment">// 获取return 指定的内容</span></span><br><span class="line">                String value = mock.substring(Constants.RETURN_PREFIX.length());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 解析return指定的内容，并转换成对应的返回类型</span></span><br><span class="line">                    MockInvoker.parseMockValue(value);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Illegal mock json value in &lt;dubbo:service ... mock=\""</span> + mock + <span class="string">"\" /&gt;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不是以 'return' 开头</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获得Mock类</span></span><br><span class="line">                Class&lt;?&gt; mockClass = ConfigUtils.isDefault(mock) ? ReflectUtils.forName(interfaceClass.getName() + <span class="string">"Mock"</span>) : ReflectUtils.forName(mock);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 校验是否实现接口</span></span><br><span class="line">                <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(mockClass)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The mock implementation class "</span> + mockClass.getName() + <span class="string">" not implement interface "</span> + interfaceClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 校验是否有默认的构造方法</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mockClass.getConstructor(<span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such empty constructor \"public "</span> + mockClass.getSimpleName() + <span class="string">"()\" in mock implementation class "</span> + mockClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServiceConfig-配置类"><a href="#ServiceConfig-配置类" class="headerlink" title="ServiceConfig 配置类"></a>ServiceConfig 配置类</h4><p>该类是 <code>服务暴露</code> 的核心类，我们在 <a href="http://localhost:4000/posts/f0ae64a/" target="_blank" rel="noopener">Dubbo示例 - API配置</a> 中已经使用API的方式创建一个Dubbo应用，最后通过调用 <code>ServiceConfig#export()方法</code>进行服务的导出，ServiceConfig 继承关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AbstractConfig</span><br><span class="line"> - AbstractMethodConfig</span><br><span class="line">   - AbstractInterfaceConfig</span><br><span class="line">     - AbstractServiceConfig</span><br><span class="line">       - ServiceConfig</span><br></pre></td></tr></table></figure><p>AbstractServiceConfig 抽象类中也没有核心的逻辑，主要就是配置属性的设置和获取方法，因此也不再分析。</p><p><code>ServiceConfig#export()</code>方法主要做以下几件事：</p><ol><li>进一步初始化Dubbo的配置承载对象，因为有的配置对象我们可能并没有显示创建或配置。</li><li>对配置对象们进行校验是否为空，为空则新建，或者抛出异常。</li><li>ServiceConfig聚集了Dubbo服务的的所有配置属性，使用它的属性构建Dubbo URL对象</li><li>进行服务暴露</li></ol><h5 id="ServiceConfig-属性"><a href="#ServiceConfig-属性" class="headerlink" title="ServiceConfig 属性"></a>ServiceConfig 属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractServiceConfig</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 Protocol实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 ProxyFactory 实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机端口集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; RANDOM_PORT_MAP = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟暴露线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService delayExportExecutor = Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboServiceDelayExporter"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务配置暴露的Exporter 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Exporter&lt;?&gt;&gt; exporters = <span class="keyword">new</span> ArrayList&lt;Exporter&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口全路径名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非配置，通过interfaceName 通过反射获得</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口的实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T ref;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务方法配置对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MethodConfig&gt; methods;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务提供者默认配置的配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ProviderConfig provider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exported;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> unexported;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String generic;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进一步初始化配置承载对象"><a href="#进一步初始化配置承载对象" class="headerlink" title="进一步初始化配置承载对象"></a>进一步初始化配置承载对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 暴露服务入口，加jvm锁</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 当export 或者 delay 未配置时，从ProviderConfig对象读取</span></span><br><span class="line">          <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (export == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  export = provider.getExport();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (delay == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  delay = provider.getDelay();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 不暴露服务(export = false),则不进行暴露服务逻辑</span></span><br><span class="line">          <span class="keyword">if</span> (export != <span class="keyword">null</span> &amp;&amp; !export) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 延迟暴露的话，就是使用任务线程池ScheduledExecutorService处理</span></span><br><span class="line">          <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              delayExportExecutor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                      doExport();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              doExport();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 服务暴露，jvm锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 检查是否可以暴露，若可以，标记已经暴露然后执行服务暴露逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already unexported!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果已经暴露了直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记已经暴露过了</span></span><br><span class="line">            exported = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 校验interfaceName 是否合法，即接口名非空</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceName == <span class="keyword">null</span> || interfaceName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"&lt;dubbo:service interface=\"\" /&gt; interface not allow null!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 校验provider是否为空，为空则新建一个，并拼接属性配置（环境变量 + .properties文件中的 属性）到ProviderConfig对象</span></span><br><span class="line">            checkDefault();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 检测application，module等核心配置类对象是否为空，若为空则尝试从其他配置类对象中获取对应的实例。即： 从ProviderConfig 对象中，读取application,module,registries,monitor,protocols配置对象</span></span><br><span class="line">            <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    application = provider.getApplication();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">module</span> = provider.getModule();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    registries = provider.getRegistries();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    monitor = provider.getMonitor();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (protocols == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    protocols = provider.getProtocols();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从ModuleConfig 对象中，读取registries,monitor配置对象</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    registries = <span class="keyword">module</span>.getRegistries();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    monitor = <span class="keyword">module</span>.getMonitor();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从ApplicationConfig 对象中，读取registries,monitor配置对象</span></span><br><span class="line">            <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    registries = application.getRegistries();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    monitor = application.getMonitor();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 检测ref是否泛化接口的实现</span></span><br><span class="line">            <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> GenericService) &#123;</span><br><span class="line">                <span class="comment">// 设置 interfaceClass 为 GenericService.class</span></span><br><span class="line">                interfaceClass = GenericService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">                    <span class="comment">// 设置 generic = "true"</span></span><br><span class="line">                    generic = Boolean.TRUE.toString();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 普通接口的实现</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 通过反射获取对应的接口的Class</span></span><br><span class="line">                    interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread()</span><br><span class="line">                            .getContextClassLoader());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检验接口和方法 （接口非空，方法都在接口中定义）</span></span><br><span class="line">                checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">                <span class="comment">// 校验引用ref是否实现了当前接口</span></span><br><span class="line">                checkRef();</span><br><span class="line">                <span class="comment">// 标记为非泛化实现</span></span><br><span class="line">                generic = Boolean.FALSE.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/** 处理服务接口客户端本地代理,即本地存根（local 属性 -&gt; AbstractInterfaceConfig#setLocal）。目前已经废弃，此处主要用于兼容，使用stub属性. todo 服务端没有意义 &#123;<span class="doctag">@link</span> StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125; */</span></span><br><span class="line">            <span class="keyword">if</span> (local != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果local属性设置为ture，表示使用缺省代理类名，即：接口名 + Local 后缀</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"true"</span>.equals(local)) &#123;</span><br><span class="line">                    local = interfaceName + <span class="string">"Local"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; localClass;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取本地存根类</span></span><br><span class="line">                    localClass = ClassHelper.forNameWithThreadContextClassLoader(local);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法</span></span><br><span class="line">                <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The local implementation class "</span> + localClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/** 处理服务接口客户端本地代理(stub 属性)相关，即本地存根。目的：想在客户端【服务消费方】执行需要的逻辑，不局限服务提供的逻辑。本地存根类编写方式是固定。todo 服务端没有意义 &#123;<span class="doctag">@link</span> StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125;*/</span></span><br><span class="line">            <span class="keyword">if</span> (stub != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果stub属性设置为ture，表示使用缺省代理类名，即：接口名 + Stub 后缀</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"true"</span>.equals(stub)) &#123;</span><br><span class="line">                    stub = interfaceName + <span class="string">"Stub"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; stubClass;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取本地存根类</span></span><br><span class="line">                    stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断interfaceClass 是否是 stubClass 的接口，即 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法</span></span><br><span class="line">                <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(stubClass)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The stub implementation class "</span> + stubClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/* 检测各种对象是否为空，为空则新建，或者抛出异常*/</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 校验ApplicationConfig配置</span></span><br><span class="line">            checkApplication();</span><br><span class="line">            <span class="comment">// 校验RegistryConfig配置</span></span><br><span class="line">            checkRegistry();</span><br><span class="line">            <span class="comment">// 校验ProtocolConfig配置数组</span></span><br><span class="line">            checkProtocol();</span><br><span class="line">            <span class="comment">// 读取环境变量和properties配置到ServiceConfig对象（自己）</span></span><br><span class="line">            appendProperties(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 校验Stub和Mock相关的配置</span></span><br><span class="line">            checkStubAndMock(interfaceClass);</span><br><span class="line">            <span class="comment">// 服务路径，缺省是接口名</span></span><br><span class="line">            <span class="keyword">if</span> (path == <span class="keyword">null</span> || path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                path = interfaceName;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暴露服务</span></span><br><span class="line">            doExportUrls();</span><br><span class="line">          </span><br><span class="line">            ProviderModel providerModel = <span class="keyword">new</span> ProviderModel(getUniqueServiceName(), <span class="keyword">this</span>, ref);</span><br><span class="line">            ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多协议多注册中心"><a href="#多协议多注册中心" class="headerlink" title="多协议多注册中心"></a>多协议多注册中心</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Dubbo 允许我们使用不同的协议导出服务，也允许我们向多个注册中心注册服务。Dubbo 在 doExportUrls 方法中对多协议，多注册中心进行了支持</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 加载注册中心URL 数组 【协议已经处理过，不再是配置的注册中心协议 如：zookeeper ,而是统一替换成了registry】</span></span><br><span class="line">           List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">           <span class="comment">// 遍历协议集合，支持多协议暴露。</span></span><br><span class="line">           <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">               doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 使用不同的协议，逐个向注册中心分组暴露服务。该方法中包含了本地和远程两种暴露方式</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> protocolConfig 协议配置对象</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> registryURLs   处理过的注册中心分组集合【已经添加了ApplicationConfig和RegistryConfig的参数】</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 协议名</span></span><br><span class="line">           String name = protocolConfig.getName();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 协议名为空时，缺省设置为 dubbo</span></span><br><span class="line">           <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">               name = <span class="string">"dubbo"</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 创建参数集合map，用于Dubbo URL 的构建（服务提供者URL）</span></span><br><span class="line">           Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// 将side,dubbo,timestamp,pid参数，添加到map集合中</span></span><br><span class="line">           map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">           map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());</span><br><span class="line">           map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">           <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 通过反射将各种配置对象中的属性添加到map集合中，map用于URL的构建【注意属性覆盖问题】</span></span><br><span class="line">           appendParameters(map, application);</span><br><span class="line">           appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">           appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">           appendParameters(map, protocolConfig);</span><br><span class="line">           appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">           <span class="comment">// 将MethodConfig 对象数组添加到 map 集合中。就是将每个MethodConfig和其对应的ArgumentConfig对象数组添加到map中【处理方法相关的属性到map】</span></span><br><span class="line">           <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line">               <span class="comment">// methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method&gt; 标签的配置信息</span></span><br><span class="line">               <span class="keyword">for</span> (MethodConfig method : methods) &#123;</span><br><span class="line">                   <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 将MethodConfig对象的属性添加到map集合中，其中属性键 = 方法名.属性名。如：</span></span><br><span class="line"><span class="comment">                    * &lt;dubbo:method name="sleep" retries="2"&gt;&lt;/dubbo:method&gt;对应的MethodConfig，属性到map的格式 map=&#123;"sleep.retries":2,...&#125;</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   appendParameters(map, method, method.getName());</span><br><span class="line">   </span><br><span class="line">                   <span class="comment">// 当配置了 MehodConfig.retry = false 时，强制禁用重试</span></span><br><span class="line">                   String retryKey = method.getName() + <span class="string">".retry"</span>;</span><br><span class="line">                   <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                       String retryValue = map.remove(retryKey);</span><br><span class="line">                       <span class="comment">// 检测 MethodConfig retry 是否为 false，若是，则设置重试次数为0</span></span><br><span class="line">                       <span class="keyword">if</span> (<span class="string">"false"</span>.equals(retryValue)) &#123;</span><br><span class="line">                           map.put(method.getName() + <span class="string">".retries"</span>, <span class="string">"0"</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 将MethodConfig下的ArgumentConfig 对象数组，添加到 map 集合中</span></span><br><span class="line">                   List&lt;ArgumentConfig&gt; arguments = method.getArguments();</span><br><span class="line">                   <span class="keyword">if</span> (arguments != <span class="keyword">null</span> &amp;&amp; !arguments.isEmpty()) &#123;</span><br><span class="line">                       <span class="keyword">for</span> (ArgumentConfig argument : arguments) &#123;</span><br><span class="line">                           <span class="comment">// 检测type 属性是否为空，</span></span><br><span class="line">                           <span class="keyword">if</span> (argument.getType() != <span class="keyword">null</span> &amp;&amp; argument.getType().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="comment">// 通过反射取出接口的方法列表</span></span><br><span class="line">                               Method[] methods = interfaceClass.getMethods();</span><br><span class="line">                               <span class="comment">// 遍历接口中的方法列表</span></span><br><span class="line">                               <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">                                       String methodName = methods[i].getName();</span><br><span class="line">                                       <span class="comment">// 比对方法名，查找目标方法</span></span><br><span class="line">                                       <span class="keyword">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class="line">                                           <span class="comment">// 通过反射取出目标方法的参数类型列表</span></span><br><span class="line">                                           Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();</span><br><span class="line">                                           <span class="comment">// 若果配置index配置项，且值不为-1</span></span><br><span class="line">                                           <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                                               <span class="comment">// 从argtypes数组中获取下标index处的元素argType，并检测ArgumentConfig中的type属性与argType名称是否一致，不一致则抛出异常</span></span><br><span class="line">                                               <span class="keyword">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                   <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中，键前缀=方法名.index，如：map = &#123;"sleep.2":true&#125;</span></span><br><span class="line">                                                   appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                                               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error : the index attribute and type attribute not match :index :"</span> + argument.getIndex() + <span class="string">", type:"</span> + argument.getType());</span><br><span class="line">                                               &#125;</span><br><span class="line">                                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                               <span class="comment">// 遍历参数类型数组argtypes，查找argument.type类型的参数</span></span><br><span class="line">                                               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; argtypes.length; j++) &#123;</span><br><span class="line">                                                   Class&lt;?&gt; argclazz = argtypes[j];</span><br><span class="line">                                                   <span class="comment">// 从参数类型列表中查找类型名称为argument.type的参数</span></span><br><span class="line">                                                   <span class="keyword">if</span> (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                       <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中</span></span><br><span class="line">                                                       appendParameters(map, argument, method.getName() + <span class="string">"."</span> + j);</span><br><span class="line">                                                       <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span> &amp;&amp; argument.getIndex() != j) &#123;</span><br><span class="line">                                                           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error : the index attribute and type attribute not match :index :"</span> + argument.getIndex() + <span class="string">", type:"</span> + argument.getType());</span><br><span class="line">                                                       &#125;</span><br><span class="line">                                                   &#125;</span><br><span class="line">                                               &#125;</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="comment">// 用户未配置 type 属性，但配置了index属性，且index != -1</span></span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123; <span class="comment">// 指定单个参数的位置</span></span><br><span class="line">                               <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中</span></span><br><span class="line">                               appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config must set index or type attribute.eg: &lt;dubbo:argument index='0' .../&gt; or &lt;dubbo:argument type=xxx .../&gt;"</span>);</span><br><span class="line">                           &#125;</span><br><span class="line">   </span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="comment">// end of methods for</span></span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">//------------------- 检测 generic 是否 为 true ,并根据检测结果向map中添加不同的信息 ---/</span></span><br><span class="line">           <span class="comment">// 将 generic,methods,revision 加入到数组</span></span><br><span class="line">           <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">               map.put(Constants.GENERIC_KEY, generic);</span><br><span class="line">               map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 先从MAINFEST.MF 中获取版本号，若获取不到，再从jar包命名中可能带的版本号作为结果，如 2.6.5.RELEASE。若都不存在，返回默认版本号【源码运行可能会没有】</span></span><br><span class="line">               String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">               <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   map.put(<span class="string">"revision"</span>, revision); <span class="comment">// 修订号</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 为接口生成包裹类 Wrapper，Wrapper 中包含了接口的详细信息，比如接口方法名数组，字段信息等【Dubbo 自定义功能类】</span></span><br><span class="line">               String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">   </span><br><span class="line">               <span class="comment">// 添加方法名到 map 中，如果包含多个方法名，则用逗号隔开，比如：method=a,b</span></span><br><span class="line">               <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">                   logger.warn(<span class="string">"NO method found in service interface "</span> + interfaceClass.getName());</span><br><span class="line">                   <span class="comment">// 没有方法名就添加 method=*</span></span><br><span class="line">                   map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 将逗号作为分隔符连接方法名，并将连接后的字符串放入 map 中</span></span><br><span class="line">                   map.put(Constants.METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">","</span>));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// token 【使暴露出去的服务更安全，使用token做安全校验】</span></span><br><span class="line">           <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">                   map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   map.put(Constants.TOKEN_KEY, token);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 协议为injvm时，不注册，不通知</span></span><br><span class="line">           <span class="keyword">if</span> (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123;</span><br><span class="line">               protocolConfig.setRegister(<span class="keyword">false</span>);</span><br><span class="line">               map.put(<span class="string">"notify"</span>, <span class="string">"false"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 获得基础路径</span></span><br><span class="line">           String contextPath = protocolConfig.getContextpath();</span><br><span class="line">           <span class="keyword">if</span> ((contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span>) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">               contextPath = provider.getContextpath();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// --------------------------- 主机绑定----------------------------/</span></span><br><span class="line">           <span class="comment">// 获得注册到注册中心的服务提供者host，并为map设置bind.ip , anyhost 两个key</span></span><br><span class="line">           String host = <span class="keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">           <span class="comment">// 获取端口，并为map设置bing.port key</span></span><br><span class="line">           Integer port = <span class="keyword">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 创建Dubbo URL对象 【注意这里的 path 的值】</span></span><br><span class="line"><span class="comment">            * 1 name: 协议名</span></span><br><span class="line"><span class="comment">            * 2 host: 主机名</span></span><br><span class="line"><span class="comment">            * 3 port: 端口</span></span><br><span class="line"><span class="comment">            * 4 path: 【基础路径】/path</span></span><br><span class="line"><span class="comment">            * 5 parameters: 属性集合map</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           URL url = <span class="keyword">new</span> URL(name, host, port, (contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span> ? <span class="string">""</span> : contextPath + <span class="string">"/"</span>) + path, map);</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// 省略服务暴露代码</span></span><br><span class="line">         </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReferenceConfig-配置类"><a href="#ReferenceConfig-配置类" class="headerlink" title="ReferenceConfig 配置类"></a>ReferenceConfig 配置类</h4><p>该类是 <code>服务引用</code> 的核心类，我们在 <a href="http://localhost:4000/posts/f0ae64a/" target="_blank" rel="noopener">Dubbo示例 - API配置</a> 中已经使用API的方式创建一个Dubbo应用，最后通过调用 <code>ReferenceConfig#get()方法</code>引用服务，ReferenceConfig 继承关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AbstractConfig</span><br><span class="line"> - AbstractMethodConfig</span><br><span class="line">   - AbstractInterfaceConfig</span><br><span class="line">     - AbstractReferenceConfig</span><br><span class="line">       - ReferenceConfig</span><br></pre></td></tr></table></figure><p>AbstractReferenceConfig 抽象类中也没有核心的逻辑，主要就是配置属性的设置和获取方法，因此也不再分析。</p><p><code>ReferenceConfig#get()</code>方法主要做以下几件事：</p><ol><li>进一步初始化Dubbo的配置承载对象，因为有的配置对象我们可能并没有显示创建或配置。</li><li>对配置对象们进行校验是否为空，为空则新建，或者抛出异常。</li><li>ReferenceConfig聚集了Dubbo服务消费者的的所有配置属性，使用它的属性构建Dubbo URL对象</li><li>进行服务引用</li></ol><h5 id="ReferenceConfig-属性"><a href="#ReferenceConfig-属性" class="headerlink" title="ReferenceConfig 属性"></a>ReferenceConfig 属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractReferenceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 Protocol 拓展实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 Cluster 拓展实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 ProxyFactory 拓展实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务引用URL数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String client;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直连服务提供者地址</span></span><br><span class="line"><span class="comment">     * 1 可以是注册中心，也可以是服务提供者</span></span><br><span class="line"><span class="comment">     * 2 可以配置多个，使用 ";" 分割</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法配置对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MethodConfig&gt; methods;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者默认配置的配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConsumerConfig consumer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String protocol;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> T ref;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Invoker&lt;?&gt; invoker;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroyed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进一步初始化配置承载对象-1"><a href="#进一步初始化配置承载对象-1" class="headerlink" title="进一步初始化配置承载对象"></a>进一步初始化配置承载对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractReferenceConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 已销毁，不可获得</span></span><br><span class="line">          <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already destroyed!"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 若未初始化，调用init()方法进行初始化</span></span><br><span class="line">          <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">              init();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 返回引用服务</span></span><br><span class="line">          <span class="keyword">return</span> ref;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 已经初始化过，直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          initialized = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// 校验接口名非空</span></span><br><span class="line">          <span class="keyword">if</span> (interfaceName == <span class="keyword">null</span> || interfaceName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"&lt;dubbo:reference interface=\"\" /&gt; interface not allow null!"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 拼接属性配置（环境变量 + .properties 中的属性）到 ConsumerConfig对象</span></span><br><span class="line">          checkDefault();</span><br><span class="line">          <span class="comment">// 拼接属性配置（环境变量 + .properties 中的属性）到ReferenceConfig（自己）</span></span><br><span class="line">          appendProperties(<span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 若未设置 generic 属性，就使用ConsumerConfig的generic属性</span></span><br><span class="line">          <span class="keyword">if</span> (getGeneric() == <span class="keyword">null</span> &amp;&amp; getConsumer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">              setGeneric(getConsumer().getGeneric());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 是否是泛化接口的实现，如果是泛化接口实现的话，就直接设置当前接口为 GenericService.class</span></span><br><span class="line">          <span class="keyword">if</span> (ProtocolUtils.isGeneric(getGeneric())) &#123;</span><br><span class="line">              interfaceClass = GenericService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  </span><br><span class="line">              <span class="comment">// 普通接口的实现</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 根据接口名，获得对应的接口类</span></span><br><span class="line">                  interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread().getContextClassLoader());</span><br><span class="line">              &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">              &#125;</span><br><span class="line">  </span><br><span class="line">              <span class="comment">// 校验接口和方法</span></span><br><span class="line">              checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 直连提供者，第一优先级，通过 -D 参数（系统变量）指定 ，例如 java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890</span></span><br><span class="line">          String resolve = System.getProperty(interfaceName);</span><br><span class="line">          String resolveFile = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 直连提供者第二优先级，通过文件映射，例如 com.alibaba.xxx.XxxService=dubbo://localhost:20890</span></span><br><span class="line">          <span class="keyword">if</span> (resolve == <span class="keyword">null</span> || resolve.length() == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 从系统属性中获取解析文件路径</span></span><br><span class="line">              resolveFile = System.getProperty(<span class="string">"dubbo.resolve.file"</span>);</span><br><span class="line">              <span class="keyword">if</span> (resolveFile == <span class="keyword">null</span> || resolveFile.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 默认先加载 $&#123;user.home&#125;/dubbo-resolve.properties 文件，无需配置，自动加载</span></span><br><span class="line">                  File userResolveFile = <span class="keyword">new</span> File(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.home"</span>)), <span class="string">"dubbo-resolve.properties"</span>);</span><br><span class="line">                  <span class="keyword">if</span> (userResolveFile.exists()) &#123;</span><br><span class="line">                      <span class="comment">// 获取文件绝对路径</span></span><br><span class="line">                      resolveFile = userResolveFile.getAbsolutePath();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 存在resolveFile,则进行文件读取加载</span></span><br><span class="line">              <span class="keyword">if</span> (resolveFile != <span class="keyword">null</span> &amp;&amp; resolveFile.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">                  FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(resolveFile));</span><br><span class="line">                      <span class="comment">// 从文件中加载配置</span></span><br><span class="line">                      properties.load(fis);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unload "</span> + resolveFile + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                          <span class="keyword">if</span> (<span class="keyword">null</span> != fis) &#123;</span><br><span class="line">                              fis.close();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                          logger.warn(e.getMessage(), e);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 根据服务全路径名获取对应的 直连提供者的url</span></span><br><span class="line">                  resolve = properties.getProperty(interfaceName);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 设置直连提供者的 url</span></span><br><span class="line">          <span class="keyword">if</span> (resolve != <span class="keyword">null</span> &amp;&amp; resolve.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              url = resolve;</span><br><span class="line">              <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (resolveFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      logger.warn(<span class="string">"Using default dubbo resolve file "</span> + resolveFile + <span class="string">" replace "</span> + interfaceName + <span class="string">""</span> + resolve + <span class="string">" to p2p invoke remote service."</span>);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      logger.warn(<span class="string">"Using -D"</span> + interfaceName + <span class="string">"="</span> + resolve + <span class="string">" to p2p invoke remote service."</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 不通过系统属性指定，就使用配置的直连（在配置的前提下），如：&lt;dubbo:reference id="xxxService" interface="com.alibaba.xxx.XxxService" url="dubbo://localhost:20890" /&gt;</span></span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 尝试从ConsumerConfig 对象中，读取 application,module,registries,monitor 配置对象</span></span><br><span class="line">          <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  application = consumer.getApplication();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">module</span> = consumer.getModule();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  registries = consumer.getRegistries();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  monitor = consumer.getMonitor();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 从ModuleConfig 对象中，读取registries,monitor配置对象</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  registries = <span class="keyword">module</span>.getRegistries();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  monitor = <span class="keyword">module</span>.getMonitor();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 从ApplicationConfig对象中，读取registries,monitor配置对象</span></span><br><span class="line">          <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  registries = application.getRegistries();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  monitor = application.getMonitor();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 校验ApplicationConfig配置</span></span><br><span class="line">          checkApplication();</span><br><span class="line">          <span class="comment">// 校验 Stub和 Mock 相关的配置</span></span><br><span class="line">          checkStubAndMock(interfaceClass);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 创建参数集合map，用于下面创建Dubbo URL</span></span><br><span class="line">          Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">          <span class="comment">// 符合条件的方法对象的属性，主要用来Dubbo事件通知</span></span><br><span class="line">          Map&lt;Object, Object&gt; attributes = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 将 side，dubbo,timestamp,pid参数，添加到map集合中</span></span><br><span class="line">          map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);</span><br><span class="line">          map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());</span><br><span class="line">          map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">          <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 非泛化服务，设置revision,methods,interface加入到map集合中</span></span><br><span class="line">          <span class="keyword">if</span> (!isGeneric()) &#123;</span><br><span class="line">              String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">              <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  map.put(<span class="string">"revision"</span>, revision);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 获取接口方法列表，并添加到map中</span></span><br><span class="line">              String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">              <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">                  logger.warn(<span class="string">"NO method found in service interface "</span> + interfaceClass.getName());</span><br><span class="line">                  map.put(<span class="string">"methods"</span>, Constants.ANY_VALUE);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  map.put(<span class="string">"methods"</span>, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">","</span>));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          map.put(Constants.INTERFACE_KEY, interfaceName);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 将各种配置对象中的属性，添加到 map 集合中</span></span><br><span class="line">          appendParameters(map, application);</span><br><span class="line">          appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">          appendParameters(map, consumer, Constants.DEFAULT_KEY);</span><br><span class="line">          appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 获得服务键，作为前缀 格式：group/interface:version</span></span><br><span class="line">          String prefix = StringUtils.getServiceKey(map);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 将MethodConfig 对象数组中每个MethodConfig中的属性添加到map中</span></span><br><span class="line">          <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line">              <span class="comment">// 遍历 MethodConfig 列表</span></span><br><span class="line">              <span class="keyword">for</span> (MethodConfig method : methods) &#123;</span><br><span class="line">                  appendParameters(map, method, method.getName());</span><br><span class="line">                  <span class="comment">// 当配置了 MethodConfig.retry=false 时，强制禁用重试</span></span><br><span class="line">                  String retryKey = method.getName() + <span class="string">".retry"</span>;</span><br><span class="line">                  <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                      String retryValue = map.remove(retryKey);</span><br><span class="line">                      <span class="keyword">if</span> (<span class="string">"false"</span>.equals(retryValue)) &#123;</span><br><span class="line">                          <span class="comment">// 添加重试次数配置 methodName.retries</span></span><br><span class="line">                          map.put(method.getName() + <span class="string">".retries"</span>, <span class="string">"0"</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 将带有@Parameter(attribute=true)配置对象的属性，添加到参数集合中</span></span><br><span class="line">                  appendAttributes(attributes, method, prefix + <span class="string">"."</span> + method.getName());</span><br><span class="line">                  <span class="comment">// 检查属性集合中的事件通知方法是否正确，若正确，进行转换</span></span><br><span class="line">                  checkAndConvertImplicitConfig(method, map, attributes);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 以系统环境变量（DUBBO_IP_TO_REGISTRY）的值作为服务消费者ip地址,没有设置再取主机地址</span></span><br><span class="line">          String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);</span><br><span class="line">          <span class="keyword">if</span> (hostToRegistry == <span class="keyword">null</span> || hostToRegistry.length() == <span class="number">0</span>) &#123;</span><br><span class="line">              hostToRegistry = NetUtils.getLocalHost();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInvalidLocalHost(hostToRegistry)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Specified invalid registry ip from property:"</span> + Constants.DUBBO_IP_TO_REGISTRY + <span class="string">", value:"</span> + hostToRegistry);</span><br><span class="line">          &#125;</span><br><span class="line">          map.put(Constants.REGISTER_IP_KEY, hostToRegistry);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 把attributes集合添加到StaticContext进行缓存，为了以后的事件通知</span></span><br><span class="line">          StaticContext.getSystemContext().putAll(attributes);</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">              System.out.println(<span class="string">" ref = createProxy(map); is begin....."</span>);</span><br><span class="line">              Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">          &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">  </span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">         <span class="comment">// 省略服务引用代码</span></span><br><span class="line"> </span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 省略其它代码 $&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其它配置类"><a href="#其它配置类" class="headerlink" title="其它配置类"></a>其它配置类</h4><p>前面只是针对Dubbo的核心配置类进行了分析，还很多其它的配置类并没有分析到(ServiceBean和ReferenceBean属于整合Spring的配置类，我们在XML配置中分析)，不过没有分析到的配置类中几乎都没有复杂的逻辑，大多是封装了配置属性的设置和获取操作。每个配置类中封装的配置属性都有所不同，那些抽象的配置类封装的都是可供不同子类复用的属性和方法，每个配置类可以设置那些属性我们可以参考<a href="http://dubbo.apache.org/zh-cn/docs/user/references/xml/introduction.html" target="_blank" rel="noopener">官方文档</a>，需要说明的是，官网给出的是XML配置形式，不过按照对应的规则转换就可以相通了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Dubbo的配置相对比较枯燥，刚开始看的时候可能有点蒙圈，笔者也是硬着头皮看了好久，看完后也不是很理解，但是把整个流程看完后再回来看体会就更深了。XML配置和注解配置也是基于API配置和属性配置的，区别是XML配置和注解配置要解决和Spring融合问题，我们在接下来的文章中再详细分析。嘿咻，整篇文章都在贴代码！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;我们通过 &lt;a href=&quot;https://gentryhuang.com/posts/46f95e97/&quot;&gt;Dubbo URL统一模型&lt;/
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="RPC" scheme="https://gentryhuang.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 动态编译</title>
    <link href="https://gentryhuang.com/posts/68ac5094/"/>
    <id>https://gentryhuang.com/posts/68ac5094/</id>
    <published>2020-03-21T16:00:00.000Z</published>
    <updated>2020-09-03T03:12:53.630Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在<a href="https://gentryhuang.com/posts/3e0b5964/">Dubbo自适应扩展</a>中，我们已经得到了自适应扩展类的字符串，需要通过编译才能得到真正的Class，本篇文章就来介绍将类的字符串编译成类的过程。</p><h3 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-compiler.jpg" alt></p><p>dubbo 的动态编译的整体结构如上图所示。dubbo中的Compiler基于dubbo spi机制进行加载，目前支持jdk和javassist两种实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">compiler</span>=<span class="string">"jdk"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">compiler</span>=<span class="string">"javassist"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>整体了解了dubbo的动态编译后，我们接着上一篇文章继续分析，dubbo动态编译入口的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 生成自适应拓展实现的代码字符串</span></span><br><span class="line">    String code = createAdaptiveExtensionClassCode();</span><br><span class="line">    <span class="comment">// 获取类加载器</span></span><br><span class="line">    ClassLoader classLoader = findClassLoader();</span><br><span class="line">    <span class="comment">// 获取Compiler自适应扩展对象</span></span><br><span class="line">    com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    <span class="comment">// 动态编译，生成Class</span></span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法在编译阶段需要先获取自适应编译对象，然后调用该对象的compile方法进行代码的编译。其实这里并不是直接使用自适应对象进行代码编译，而是将具体的编译任务交给子类来完成，即JdkCompiler子类和JavassistCompiler子类，下面我们来看看dubbo 动态编译的成员及它们的用途。</p><h4 id="Compiler-扩展接口"><a href="#Compiler-扩展接口" class="headerlink" title="Compiler 扩展接口"></a>Compiler 扩展接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compiler. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * 使用Dubbo SPI机制，默认拓展名为javassist</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编译Java 代码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code        Java代码字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader 类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Compiled class 编译后的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; compile(String code, ClassLoader classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AdaptiveCompiler-固定自适应扩展类"><a href="#AdaptiveCompiler-固定自适应扩展类" class="headerlink" title="AdaptiveCompiler 固定自适应扩展类"></a>AdaptiveCompiler 固定自适应扩展类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AdaptiveCompiler. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * 实现Compiler接口，带有<span class="doctag">@Adaptive</span>注解，是固定的自适应实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveCompiler</span> <span class="keyword">implements</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认编辑器的拓展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> String DEFAULT_COMPILER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法，设置默认编辑器的拓展名。该方法被 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.config.ApplicationConfig#setCompiler(java.lang.String)&#125;方法调用.</span></span><br><span class="line"><span class="comment">     * 在&lt;dubbo:application compiler=""/&gt; 配置 可触发该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> compiler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultCompiler</span><span class="params">(String compiler)</span> </span>&#123;</span><br><span class="line">        DEFAULT_COMPILER = compiler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123;</span><br><span class="line">        Compiler compiler;</span><br><span class="line">        <span class="comment">// 获得Compiler的ExtensionLoader对象</span></span><br><span class="line">        ExtensionLoader&lt;Compiler&gt; loader = ExtensionLoader.getExtensionLoader(Compiler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 声明 name 变量</span></span><br><span class="line">        String name = DEFAULT_COMPILER;</span><br><span class="line">        <span class="comment">// 使用设置的拓展名，获得Compiler拓展对象</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            compiler = loader.getExtension(name);</span><br><span class="line">            <span class="comment">// 获得默认的Compiler拓展对象</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            compiler = loader.getDefaultExtension();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用真正的Compiler对象，动态编译代码</span></span><br><span class="line">        <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类使用了@Adaptive注解，说明AdaptiveCompiler会固定为默认实现，通过代码的逻辑不难发现，该类主要用来管理其它的Compiler,每次调用compiler方法时会尝试根据扩展名获取Compiler的扩展对象，默认情况下使用JavassistCompiler扩展对象，然后使用编译对象进行动态编译代码串。</p><h4 id="AbstractCompiler-抽象编译类"><a href="#AbstractCompiler-抽象编译类" class="headerlink" title="AbstractCompiler 抽象编译类"></a>AbstractCompiler 抽象编译类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCompiler</span> <span class="keyword">implements</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包名的正则表达式，注意匹配组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PACKAGE_PATTERN = Pattern.compile(<span class="string">"package\\s+([$_a-zA-Z][$_a-zA-Z0-9\\.]*);"</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类名的正则表达式，注意匹配组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern CLASS_PATTERN = Pattern.compile(<span class="string">"class\\s+([$_a-zA-Z][$_a-zA-Z0-9]*)\\s+"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="comment">// 获得包名</span></span><br><span class="line">        code = code.trim();</span><br><span class="line">        Matcher matcher = PACKAGE_PATTERN.matcher(code);</span><br><span class="line">        String pkg;</span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            pkg = matcher.group(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pkg = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得类名</span></span><br><span class="line">        matcher = CLASS_PATTERN.matcher(code);</span><br><span class="line">        String cls;</span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            cls = matcher.group(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No such class name in "</span> + code);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得完整类名： 包名.类名</span></span><br><span class="line">        String className = pkg != <span class="keyword">null</span> &amp;&amp; pkg.length() &gt; <span class="number">0</span> ? pkg + <span class="string">"."</span> + cls : cls;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用类加载器尝试加载类，如果加载成功，说明已经存在（可能编译过了）</span></span><br><span class="line">            <span class="keyword">return</span> Class.forName(className, <span class="keyword">true</span>, ClassHelper.getCallerClassLoader(getClass()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果加载失败，可能类不存在，说明可能未编译过，就进行编译</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 代码格式验证</span></span><br><span class="line">            <span class="keyword">if</span> (!code.endsWith(<span class="string">"&#125;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The java code not endsWith \"&#125;\", code: \n"</span> + code + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用具体的编译器进行代码编译，由子类实现</span></span><br><span class="line">                <span class="keyword">return</span> doCompile(className, code);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                <span class="keyword">throw</span> t;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to compile class, cause: "</span> + t.getMessage() + <span class="string">", class: "</span> + className + <span class="string">", code: \n"</span> + code + <span class="string">"\n, stack: "</span> + ClassUtils.toString(t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编译代码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name   类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 代码串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 编译后的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt; doCompile(String name, String source) <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该抽象类主要做两件事情，先获取要编译的字符串中的类的全路径名，根据类名尝试加载对应的类，如果加载成功说明已经编译过了，就直接返回即可，防止重复编译。如果加载失败，那么就需要进行编译处理。接下来将编译的任务交给具体的子类来完成。</p><h4 id="JavassistCompiler-编译器"><a href="#JavassistCompiler-编译器" class="headerlink" title="JavassistCompiler 编译器"></a>JavassistCompiler 编译器</h4><p>在介绍JavassistCompiler编译器前，我们需要先简单了解下Javassist，这样就能很好理解JavassistCompiler的逻辑了。Javassist是用来处理java字节码的类库，可以进行分析、编辑和创建Java字节码，它提供了丰富的API，可以使开发人员很方便操作字节码。不仅如此，我们知道处理Java字节码的工具很多，如cglib，asm等，为什么选择Javassist呢？因为Javassist简单且快速，可以直接使用Java编码的方式而不需要了解虚拟机指令就能动态改变类的结构，或者动态生成类。下面我们来看下javassist的几个API，dubbo就是使用javassist的API来动态生成类的。</p><ol><li>读取Class</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取默认的ClassPool（搜索类路径只是JVM的同路径下的class），是一个Javassist的类池</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line"><span class="comment">//从classpath中查询类Xxx</span></span><br><span class="line">CtClass cc = pool.get(<span class="string">"Xxx"</span>);</span><br><span class="line"><span class="comment">//设置Xxx的父类Yyy</span></span><br><span class="line">cc.setSuperclass(pool.get(<span class="string">"Yyy"</span>));</span><br><span class="line"><span class="comment">// 转为字节数组，进行CtClass的冻结</span></span><br><span class="line"><span class="keyword">byte</span>[] b=cc.toBytecode();</span><br><span class="line"><span class="comment">// 生成class 类，默认加载到当前线程的ClassLoader中，也可以选择输出的ClassLoader。</span></span><br><span class="line">Class clazz=cc.toClass();</span><br><span class="line"><span class="comment">// 修改读取的Class的name，这样会创建一个新的Class，旧的不会删除</span></span><br><span class="line">cc.setName(<span class="string">"XxxTemp"</span>);</span><br><span class="line"><span class="comment">// 其它api</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="2"><li>创建Class</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line"><span class="comment">// 创建一个Xxx类</span></span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"Xxx"</span>);</span><br><span class="line"><span class="comment">//新增方法</span></span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public void test()&#123;System.out.print(hello world)&#125;"</span>,cc);</span><br><span class="line">cc.addMethod(m);</span><br><span class="line"><span class="comment">//新增Field</span></span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"a"</span>, point);</span><br><span class="line">cc.addField(f);</span><br><span class="line"><span class="comment">//引入包</span></span><br><span class="line">pool.importPackage(<span class="string">"package"</span>);</span><br><span class="line"><span class="comment">// 其它api</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li>搜索路径</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认加载方式如</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(<span class="keyword">this</span>.getClass()));</span><br><span class="line"><span class="comment">//从文件加载classpath</span></span><br><span class="line">pool.insertClassPath(<span class="string">"filepath"</span>)</span><br><span class="line"><span class="comment">//从URL中加载</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> URLClassPath(<span class="string">"xxx"</span>));</span><br><span class="line"><span class="comment">//追加 LoaderClassPath</span></span><br><span class="line">pool.appendClassPath(<span class="keyword">new</span> LoaderClassPath(ClassHelper.getCallerClassLoader(getClass())));</span><br></pre></td></tr></table></figure><ol start="4"><li>具体操作示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistCompilerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建</span></span><br><span class="line">        createStudentClass();</span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        readStudentClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建字节码信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createStudentClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ClassPool</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        <span class="comment">// 创建 com.alibaba.dubbo.test.Student 类</span></span><br><span class="line">        CtClass ctClass = pool.makeClass(<span class="string">"com.alibaba.dubbo.test.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建属性(通用形式)</span></span><br><span class="line">        CtField nameField = CtField.make(<span class="string">"private String name;"</span>, ctClass);</span><br><span class="line">        ctClass.addField(nameField);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// API形式创建属性</span></span><br><span class="line">        CtField ageField = <span class="keyword">new</span> CtField(pool.getCtClass(<span class="string">"int"</span>), <span class="string">"age"</span>, ctClass);</span><br><span class="line">        ageField.setModifiers(Modifier.PRIVATE);</span><br><span class="line">        ctClass.addField(ageField);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建方法 （通用方式）</span></span><br><span class="line">        CtMethod setName = CtMethod.make(<span class="string">"public void setName(String name)&#123;this.name = name;&#125;"</span>, ctClass);</span><br><span class="line">        CtMethod getName = CtMethod.make(<span class="string">"public String getName()&#123;return name;&#125;"</span>, ctClass);</span><br><span class="line">        ctClass.addMethod(setName);</span><br><span class="line">        ctClass.addMethod(getName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// api形式创建方法</span></span><br><span class="line">        ctClass.addMethod(CtNewMethod.getter(<span class="string">"getAge"</span>, ageField));</span><br><span class="line">        ctClass.addMethod(CtNewMethod.setter(<span class="string">"setAge"</span>, ageField));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建无参构造方法</span></span><br><span class="line">        CtConstructor ctConstructor = <span class="keyword">new</span> CtConstructor(<span class="keyword">null</span>, ctClass);</span><br><span class="line">        ctConstructor.setBody(<span class="string">"&#123;&#125;"</span>);</span><br><span class="line">        ctClass.addConstructor(ctConstructor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建有参构造方法</span></span><br><span class="line">        CtConstructor constructor = <span class="keyword">new</span> CtConstructor(<span class="keyword">new</span> CtClass[]&#123;CtClass.intType, pool.get(<span class="string">"java.lang.String"</span>)&#125;, ctClass);</span><br><span class="line">        constructor.setBody(<span class="string">"&#123;this.age=age;this.name=name;&#125;"</span>);</span><br><span class="line">        ctClass.addConstructor(constructor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// api创建普通方法</span></span><br><span class="line">        CtMethod ctMethod = <span class="keyword">new</span> CtMethod(CtClass.voidType, <span class="string">"sayHello"</span>, <span class="keyword">new</span> CtClass[]&#123;&#125;, ctClass);</span><br><span class="line">        ctMethod.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        ctMethod.setBody(<span class="keyword">new</span> StringBuilder(<span class="string">"&#123;\n System.out.println(\"hello world!\"); \n&#125;"</span>).toString());</span><br><span class="line">        ctClass.addMethod(ctMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成class 类</span></span><br><span class="line">        Class&lt;?&gt; clazz = ctClass.toClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射创建对象</span></span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法调用</span></span><br><span class="line">        obj.getClass().getMethod(<span class="string">"sayHello"</span>, <span class="keyword">new</span> Class[]&#123;&#125;).invoke(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ctClass的字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] codeByteArray = ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字节码写入到class文件中</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"/opt/test/Student.class"</span>));</span><br><span class="line">        fos.write(codeByteArray);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问已存在的字节码信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readStudentClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ClassPool</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        CtClass ctClass = pool.get(<span class="string">"com.alibaba.dubbo.test.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">        <span class="comment">//获取类名</span></span><br><span class="line">        System.out.println(ctClass.getName());</span><br><span class="line">        <span class="comment">//获取接口</span></span><br><span class="line">        System.out.println(Arrays.toString(ctClass.getInterfaces()));</span><br><span class="line">        <span class="comment">//获取方法列表</span></span><br><span class="line">        System.out.println(Arrays.toString(ctClass.getMethods()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>运行上面的代码会在本地/opt/test文件目录下生成了一个Student.class文件，我们通过 <code>javap</code> 命令进行反编译的结果如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ javap  Student<span class="class">.<span class="keyword">class</span> </span></span><br><span class="line">Compiled from "Student.java"</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">dubbo</span>.<span class="title">test</span>.<span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> com.alibaba.dubbo.test.Student();</span><br><span class="line">  <span class="keyword">public</span> com.alibaba.dubbo.test.Student(<span class="keyword">int</span>, java.lang.String);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以清楚地看到，通过Javassist把一个完整的class字符串编译成为一个Class，有了这个案例的铺垫我们就很容易理解JavassistCompiler的原理了，让我们一起来看看它的逻辑。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JavassistCompiler. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * 基于 Javassist 实现的 Compiler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistCompiler</span> <span class="keyword">extends</span> <span class="title">AbstractCompiler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配import</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern IMPORT_PATTERN = Pattern.compile(<span class="string">"import\\s+([\\w\\.\\*]+);\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 extents</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern EXTENDS_PATTERN = Pattern.compile(<span class="string">"\\s+extends\\s+([\\w\\.]+)[^\\&#123;]*\\&#123;\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 implements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern IMPLEMENTS_PATTERN = Pattern.compile(<span class="string">"\\s+implements\\s+([\\w\\.]+)\\s*\\&#123;\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正则匹配方法/属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern METHODS_PATTERN = Pattern.compile(<span class="string">"\n(private|public|protected)\\s+"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正则匹配变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern FIELD_PATTERN = Pattern.compile(<span class="string">"[^\n]+=[^\n]+;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; doCompile(String name, String source) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获得类名</span></span><br><span class="line">        <span class="keyword">int</span> i = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        String className = i &lt; <span class="number">0</span> ? name : name.substring(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建ClassPoll对象</span></span><br><span class="line">        ClassPool pool = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 设置类搜索路径</span></span><br><span class="line">        pool.appendClassPath(<span class="keyword">new</span> LoaderClassPath(ClassHelper.getCallerClassLoader(getClass())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配import</span></span><br><span class="line">        Matcher matcher = IMPORT_PATTERN.matcher(source);</span><br><span class="line">        <span class="comment">// 引入包名</span></span><br><span class="line">        List&lt;String&gt; importPackages = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 引入类名</span></span><br><span class="line">        Map&lt;String, String&gt; fullNames = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配import，导入依赖包</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            String pkg = matcher.group(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 导入整个包下的类/接口</span></span><br><span class="line">            <span class="keyword">if</span> (pkg.endsWith(<span class="string">".*"</span>)) &#123;</span><br><span class="line">                String pkgName = pkg.substring(<span class="number">0</span>, pkg.length() - <span class="number">2</span>);</span><br><span class="line">                pool.importPackage(pkgName);</span><br><span class="line">                importPackages.add(pkgName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 导入指定类/接口</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> pi = pkg.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                <span class="keyword">if</span> (pi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    String pkgName = pkg.substring(<span class="number">0</span>, pi);</span><br><span class="line">                    pool.importPackage(pkgName);</span><br><span class="line">                    importPackages.add(pkgName);</span><br><span class="line">                    fullNames.put(pkg.substring(pi + <span class="number">1</span>), pkg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] packages = importPackages.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配extends</span></span><br><span class="line">        matcher = EXTENDS_PATTERN.matcher(source);</span><br><span class="line">        CtClass cls;</span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            String extend = matcher.group(<span class="number">1</span>).trim();</span><br><span class="line">            String extendClass;</span><br><span class="line">            <span class="comment">// 内嵌的类，如： extends A.B</span></span><br><span class="line">            <span class="keyword">if</span> (extend.contains(<span class="string">"."</span>)) &#123;</span><br><span class="line">                extendClass = extend;</span><br><span class="line">                <span class="comment">// 指定引用的类</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fullNames.containsKey(extend)) &#123;</span><br><span class="line">                extendClass = fullNames.get(extend);</span><br><span class="line">                <span class="comment">// 引用整个包下的类</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                extendClass = ClassUtils.forName(packages, extend).getName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建 CtClass 对象</span></span><br><span class="line">            cls = pool.makeClass(name, pool.get(extendClass));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 CtClass 对象</span></span><br><span class="line">            cls = pool.makeClass(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配 implements</span></span><br><span class="line">        matcher = IMPLEMENTS_PATTERN.matcher(source);</span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            String[] ifaces = matcher.group(<span class="number">1</span>).trim().split(<span class="string">"\\,"</span>);</span><br><span class="line">            <span class="keyword">for</span> (String iface : ifaces) &#123;</span><br><span class="line">                iface = iface.trim();</span><br><span class="line">                String ifaceClass;</span><br><span class="line">                <span class="comment">// 内嵌的接口，例如：extends A.B</span></span><br><span class="line">                <span class="keyword">if</span> (iface.contains(<span class="string">"."</span>)) &#123;</span><br><span class="line">                    ifaceClass = iface;</span><br><span class="line">                    <span class="comment">// 指定引用的接口</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fullNames.containsKey(iface)) &#123;</span><br><span class="line">                    ifaceClass = fullNames.get(iface);</span><br><span class="line">                    <span class="comment">// 引用整个包下的接口</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ifaceClass = ClassUtils.forName(packages, iface).getName();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 添加接口</span></span><br><span class="line">                cls.addInterface(pool.get(ifaceClass));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得类中的内容，即 &#123; &#125; 内的内容</span></span><br><span class="line">        String body = source.substring(source.indexOf(<span class="string">"&#123;"</span>) + <span class="number">1</span>, source.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配 方法、属性</span></span><br><span class="line">        String[] methods = METHODS_PATTERN.split(body);</span><br><span class="line">        <span class="keyword">for</span> (String method : methods) &#123;</span><br><span class="line">            method = method.trim();</span><br><span class="line">            <span class="keyword">if</span> (method.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 构造方法</span></span><br><span class="line">                <span class="keyword">if</span> (method.startsWith(className)) &#123;</span><br><span class="line">                    cls.addConstructor(CtNewConstructor.make(<span class="string">"public "</span> + method, cls));</span><br><span class="line">                    <span class="comment">// 变量</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FIELD_PATTERN.matcher(method).matches()) &#123;</span><br><span class="line">                    cls.addField(CtField.make(<span class="string">"private "</span> + method, cls));</span><br><span class="line">                    <span class="comment">// 方法</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cls.addMethod(CtNewMethod.make(<span class="string">"public "</span> + method, cls));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成类</span></span><br><span class="line">        <span class="keyword">return</span> cls.toClass(ClassHelper.getCallerClassLoader(getClass()), JavassistCompiler<span class="class">.<span class="keyword">class</span>.<span class="title">getProtectionDomain</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个逻辑下来就是按照编写一个类的步骤对自适应类的字符串进行正则匹配拆解，不断通过正则表达式匹配不同部分的代码，然后调用Javassist的API生成代表不同部分的对象，最终组装成一个完整的自适应扩展类，还是挺简单的。这里说一句，dubbo中很多地方都是采用拼接字符串方式，然后通过具体的技术手段生成目标对象，如dubbo 的服务暴露源码中Wrapper类的生成逻辑也是先拼接字符串，然后通过dubbo的ClassGenerator处理成Class，但是ClassGenerator内部也是封装了Javassist相关对象，具体生成Class还是Javassist来完成的。</p><h4 id="JdkCompiler-编译器"><a href="#JdkCompiler-编译器" class="headerlink" title="JdkCompiler 编译器"></a>JdkCompiler 编译器</h4><p>JdkCompiler使用的是jdk内置的编译器，主要使用三个不同功能的对象完成对字符串的编译:</p><ul><li>JavaFileObject对象<br>将字符串代码包装成一个文件对象</li><li>JavaFileManager接口<br>负责管理文件的读取和输出位置</li><li>JavaCompiler.CompilationTask 对象<br>把JavaFileObject对象 编译成具体的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; doCompile(String name, String sourceCode) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">int</span> i = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">    String packageName = i &lt; <span class="number">0</span> ? <span class="string">""</span> : name.substring(<span class="number">0</span>, i);</span><br><span class="line">    String className = i &lt; <span class="number">0</span> ? name : name.substring(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 创建JavaFileObject 对象</span></span><br><span class="line">    JavaFileObjectImpl javaFileObject = <span class="keyword">new</span> JavaFileObjectImpl(className, sourceCode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 JavaFileManager 管理类文件的输入和输出位置</span></span><br><span class="line">    javaFileManager.putFileForInput(StandardLocation.SOURCE_PATH, packageName, className + ClassUtils.JAVA_EXTENSION, javaFileObject);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 调用JavaCompiler.CompilationTask 的call方法 把JavaFileObject对象 编译成具体的类</span></span><br><span class="line">    Boolean result = compiler.getTask(<span class="keyword">null</span>, javaFileManager, diagnosticCollector, options,</span><br><span class="line">            <span class="keyword">null</span>, Arrays.asList(javaFileObject))</span><br><span class="line">            .call();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> || !result) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Compilation failed. class: "</span> + name + <span class="string">", diagnostics: "</span> + diagnosticCollector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载生成的类</span></span><br><span class="line">    <span class="keyword">return</span> classLoader.loadClass(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是JdkCompiler编译的逻辑，使用的都是jdk的接口，想要了解更多可以自行查看源代码，其它的就不多做分析。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>自此，dubbo spi分析完了。dubbo框架具有良好的扩展性得益于两个方面，第一个方面就是在不同的场景中，dubbo使用了不同的设计模式，第二个方面就是dubbo spi机制。可以说dubbo中几乎所有的组件都是通过dubbo spi机制串联起来的，串联的总线就是<a href="https://gentryhuang.com/posts/46f95e97/">Dubbo URL</a>，可见dubbo spi在整个框架中的重要性。在接下来的几篇文章中我们将一起了解下dubbo多样的配置，总体上不难，就是内容有点多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;在&lt;a href=&quot;https://gentryhuang.com/posts/3e0b5964/&quot;&gt;Dubbo自适应扩展&lt;/a&gt;中，我们已
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Javassist" scheme="https://gentryhuang.com/tags/Javassist/"/>
    
      <category term="JDK" scheme="https://gentryhuang.com/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 自适应扩展</title>
    <link href="https://gentryhuang.com/posts/3e0b5964/"/>
    <id>https://gentryhuang.com/posts/3e0b5964/</id>
    <published>2020-03-17T16:00:00.000Z</published>
    <updated>2020-09-03T03:12:53.633Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>上一篇文章中我们分析了dubbo spi机制，但是遗留了自适应扩展并没有展开说明，这篇文章就是来填坑的。上篇文章中也介绍了固定的自适应扩展类以及加载的流程，这篇文章主要专注于自动生成的自适应扩展类以及自适应扩展对象的创建，就不再过多介绍固定的自适应扩展。自适应扩展整体上需要讨论三部分内容：<code>自适应扩展原理</code>、<code>自适应扩展类串的生成</code> 和 <code>动态编译</code> 。 该篇文章将讨论前两个部分，动态编译会单独写一篇文章详细说明。</p><h4 id="自适应扩展原理"><a href="#自适应扩展原理" class="headerlink" title="自适应扩展原理"></a>自适应扩展原理</h4><p>扩展点的扩展类一般会在框架启动时被加载，但我们这次的主角并不会在框架启动时被加载，只可能在获取自适应实现的时候被创建、编译和实例化。这里之所以说可能，是当一个扩展接口既有固定的自适应扩展类，又想实现自动生成自适应扩展类的情况下，只会以固定的自适应扩展类为准，不会去创建动态的自适应扩展类，在框架启动时就会加载固定扩展类并放入缓存。当缓存中不存在自适应扩展类时，dubbo没有直接使用代理模式实现自适应扩展，而是为扩展接口生成具有代理功能的代码，然后通过动态编译得到自适应类，整个过程最终的目的是为扩展点生成代理对象，而代理对象主要任务就是从URL中获取扩展名对应的扩展实。接下来我们通过对官网的例子稍加改动来说明自动生成的自适应扩展的原理。<br><br></p><p>车轮制造接口 WheelMaker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WheelMaker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeWheel</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WheelMaker 接口的普通实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonWheelMaker对应的扩展名设置为 commonWheelMaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonWheelMaker</span> <span class="keyword">implements</span> <span class="title">WheelMaker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeWheel</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"打印url，制造全宇宙最好的车轮..."</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WheelMaker 接口的自适应实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveWheelMaker</span> <span class="keyword">implements</span> <span class="title">WheelMaker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeWheel</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 1.从 URL 中获取 WheelMaker 名称</span></span><br><span class="line">        String wheelMakerName = url.getParameter(<span class="string">"wheel.maker"</span>);</span><br><span class="line">        <span class="keyword">if</span> (wheelMakerName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"wheelMakerName == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.通过 SPI 加载 WheelMaker 名称 对应WheelMaker具体实现。这里获取扩展实现还是使用getExtension方法。</span></span><br><span class="line">        WheelMaker wheelMaker = ExtensionLoader.getExtensionLoader(WheelMaker<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">wheelMakerName</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.调用目标方法</span></span><br><span class="line">        wheelMaker.makeWheel(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AdaptiveWheelMaker 是一个代理类[在dubbo框架中该类型的类是自动生成的,并发手动实现],与传统的代理逻辑不同，AdaptiveWheelMaker 所代理的对象是在 makeWheel 方法中通过 SPI 加载得到的。makeWheel 方法主要做了三件事情：</p><ol><li>从 URL 中获取 WheelMaker 扩展名</li><li>通过 SPI 加载具体的 WheelMaker 实现类</li><li>调用目标方法</li></ol><br><p>程序运行时，假设我们获取到了AdaptiveWheelMaker对象，然后调用它的makeWheel方法，然后有这样一个 url 参数传入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo:&#x2F;&#x2F;192.168.0.101:20880&#x2F;XxxService?wheel.maker&#x3D;commonWheelMaker</span><br></pre></td></tr></table></figure><p>AdaptiveWheelMaker 的 makeWheel 方法从 url 中提取 wheel.maker 参数，得到扩展名 commonWheelMaker，之后再通过 SPI 加载扩展名为 commonWheelMaker 的实现类，最终得到具体的 WheelMaker 实例。</p><p><font color="#c7254e"><strong>原理小结</strong></font><br>这个例子展示了自动生成的自适应扩展类的核心实现，即在扩展接口的方法被调用（dubbo中是使用自适应扩展对象调用的）时，通过SPI加载具体的扩展对象，并调用该扩展对象的同名方法。</p><h4 id="自适应扩展类串的生成"><a href="#自适应扩展类串的生成" class="headerlink" title="自适应扩展类串的生成"></a>自适应扩展类串的生成</h4><p>通过上面的例子，我们直观的认识了自适应扩展类的工作原理。通过上一篇文章我们知道@Adaptive 可注解在类或方法上，注解在类上时，Dubbo 不会为该类生成代理类。注解在扩展接口的方法上时，Dubbo 会为为该接口生成代理逻辑。接下来我们从上一篇文章提到的getAdaptiveExtension方法入口继续分析。</p><h5 id="getAdaptiveExtension-方法"><a href="#getAdaptiveExtension-方法" class="headerlink" title="getAdaptiveExtension 方法"></a>getAdaptiveExtension 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中获取扩展点对应的自适应扩展对象</span></span><br><span class="line">    Object instance = cachedAdaptiveInstance.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存未命中，则通过双重检锁获取/创建</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//  若之前创建的时候没有报错，即之前创建了并且没有抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试从缓存中获取</span></span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 创建自适应拓展对象</span></span><br><span class="line">                        instance = createAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 放入缓存中</span></span><br><span class="line">                        cachedAdaptiveInstance.set(instance);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        createAdaptiveInstanceError = t;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"fail to create adaptive instance: "</span> + t.toString(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  若之前创建的时候报错，则抛出异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"fail to create adaptive instance: "</span> + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码用来获取扩展点的自适应对象，该方法先检查缓存，缓存中没有则调用 createAdaptiveExtension 方法尝试创建自适应对象。我们继续跟进 createAdaptiveExtension 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *  1 getAdaptiveExtensionClass方法用来获得自适应扩展类【注意，获得的自适应扩展类可能是配置文件中的类，也可能是通过字节码创建的】</span></span><br><span class="line"><span class="comment">            *  2 通过反射创建自适应扩展对象</span></span><br><span class="line"><span class="comment">            *  3 调用injectExtension方法，向创建的自适应拓展对象注入依赖</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create adaptive extension "</span> + type + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面的方法先获取自适应扩展类，然后利用反射创建自适应对象，接着会向创建的自适应对象注入依赖。现在，我们已经知道了自适应扩展类分为两类，固定的自适应扩展类中可能存在一些依赖，这时需要使用扩展工厂进行setter注入，自动生成的扩展实现一般不会依赖其它属性。接下来我们分析下自适应扩展类怎么获取的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">     <span class="comment">// 刷新扩展点实现类集合</span></span><br><span class="line">     getExtensionClasses();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 缓存中有扩展点的自适应类就直接返回</span></span><br><span class="line">     <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 没有就自动生成自适应拓展类的代码，编译后返回该类</span></span><br><span class="line">     <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的代码先是刷新扩展点实现类集合，注意如果扩展接口的实现类中有标注@Adaptive注解的类，那么cachedAdaptiveClass缓存属性中保存的就是该类，即固定的自适应扩展类。如果没有的话，说明当前扩展接口的实现类中不存在固定的自适应扩展类，那么只能尝试创建该接口的自适应扩展类，代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成自适应拓展实现类的代码字符串</span></span><br><span class="line">        String code = createAdaptiveExtensionClassCode();</span><br><span class="line">        <span class="comment">// 获取类加载器</span></span><br><span class="line">        ClassLoader classLoader = findClassLoader();</span><br><span class="line">        <span class="comment">// 获取Compiler自适应扩展对象</span></span><br><span class="line">        com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">        <span class="comment">// 动态编译，生成Class</span></span><br><span class="line">        <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>createAdaptiveExtensionClass 方法包含三个步骤：</p><ol><li>生成自适应扩展实现类的代码字符串</li><li>获取Compiler自适应扩展对象</li><li>动态编译 自适应拓展实现类的代码字符串 ，生成Class</li></ol><p>后面两个步骤属于 <code>动态编译</code> 部分，不在本文范畴，我们主要关注 自适应扩展实现类的代码字符串 的生成逻辑。</p><h5 id="自适应扩展类代码生成"><a href="#自适应扩展类代码生成" class="headerlink" title="自适应扩展类代码生成"></a>自适应扩展类代码生成</h5><p>createAdaptiveExtensionClassCode方法代码非常多，不过总的逻辑大致可以分为八个逻辑分支，已经进行详细的注释，下面就直接贴上代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">createAdaptiveExtensionClassCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder codeBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----------------- 1 检查扩展接口方法是否包含 Adaptive注解，要求至少有一个方法被 Adaptive 注解修饰 --------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取扩展点所有方法</span></span><br><span class="line">        Method[] methods = type.getMethods();</span><br><span class="line">        <span class="keyword">boolean</span> hasAdaptiveAnnotation = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方法列表，检测是否标注 Adaptive 注解</span></span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.isAnnotationPresent(Adaptive<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                hasAdaptiveAnnotation = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若所有方法上都没有Adaptive注解，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!hasAdaptiveAnnotation) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No adaptive method on extension "</span> + type.getName() + <span class="string">", refuse to create the adaptive class!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//------------------ 2 生成自适应扩展类的代码字符串，代码生成的顺序与 Java 文件内容顺序一致 ---------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成package</span></span><br><span class="line">        codeBuilder.append(<span class="string">"package "</span>).append(type.getPackage().getName()).append(<span class="string">";"</span>);</span><br><span class="line">        <span class="comment">// 生成import，注意自适应类只依赖ExtensionLoader，其它的都不会依赖，因为使用的都是全路径名，不需要再导入包了</span></span><br><span class="line">        codeBuilder.append("\nimport ").append(ExtensionLoader.class.getName()).append(";");</span><br><span class="line">        <span class="comment">// 开始生成 class</span></span><br><span class="line">        codeBuilder.append(<span class="string">"\npublic class "</span>).append(type.getSimpleName()).append(<span class="string">"$Adaptive"</span>).append(<span class="string">" implements "</span>).append(type.getCanonicalName()).append(<span class="string">" &#123;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//------------------ 3 生成自适应扩展类中的方法，接口中方法可以被 Adaptive 注解修饰，也可以不被修饰，但处理方式也不同 -------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方法列表，为类中填充方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方法返回类型</span></span><br><span class="line">            Class&lt;?&gt; rt = method.getReturnType();</span><br><span class="line">            <span class="comment">// 方法参数类型</span></span><br><span class="line">            Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">            <span class="comment">// 方法异常类型</span></span><br><span class="line">            Class&lt;?&gt;[] ets = method.getExceptionTypes();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试获取方法的 Adaptive 注解，有无注解的区别体现在 生成方法字符串的差异上</span></span><br><span class="line">            Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 类中的方法字符串集</span></span><br><span class="line">            StringBuilder code = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.1 生成没有Adaptive注解的方法代码串。Dubbo不会为没有标注Adaptive注解的方法生成代理逻辑，仅仅生成一句抛出异常代码</span></span><br><span class="line">            <span class="keyword">if</span> (adaptiveAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                code.append(<span class="string">"throw new UnsupportedOperationException(\"method "</span>)</span><br><span class="line">                        .append(method.toString()).append(<span class="string">" of interface "</span>)</span><br><span class="line">                        .append(type.getName()).append(<span class="string">" is not adaptive method!\");"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 生成有Adaptive注解的方法代码串。核心逻辑就是从方法的参数列表中直接或间接获取配置总线URL，然后结合Adaptive注解值及默认扩展名策略，从URL中得到扩展名，然后通过ExtensionLoader获取扩展名对应的扩展实现对象。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> urlTypeIndex = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 遍历方法参数类型数组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">                    <span class="comment">// 判断参数类型是不是URL，确定URL参数位置</span></span><br><span class="line">                    <span class="keyword">if</span> (pts[i].equals(URL<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                        urlTypeIndex = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// urlTypeIndex != -1，表示参数列表中存在 URL类型的参数，即直接获取配置总线URL。如：  &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException 方法</span></span><br><span class="line">                <span class="keyword">if</span> (urlTypeIndex != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 为 URL 类型参数生成判空代码，如：if (arg0 == null) throw new IllegalArgumentException("com.alibaba.dubbo.rpc.Invoker argument == null");</span></span><br><span class="line">                    String s = String.format(<span class="string">"\nif (arg%d == null) throw new IllegalArgumentException(\"url == null\");"</span>, urlTypeIndex);</span><br><span class="line">                    code.append(s);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 为 URL 类型参数生成赋值代码，形如 URL url = arg0</span></span><br><span class="line">                    s = String.format(<span class="string">"\n%s url = arg%d;"</span>, URL<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">urlTypeIndex</span>)</span>;</span><br><span class="line">                    code.append(s);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 参数列表中不存在 URL 类型参数，只能间接尝试获取配置总线URL。如：&lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException 方法，配置总线URL是从invoker中获取。</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 目标方法名，这里如果存在就是 getUrl</span></span><br><span class="line">                    String attribMethod = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// find URL getter method</span></span><br><span class="line">                    LBL_PTS:</span><br><span class="line">                    <span class="comment">// 遍历方法的参数类型列表</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 获取当前方法的参数类型 的 全部方法</span></span><br><span class="line">                        Method[] ms = pts[i].getMethods();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 判断方法参数对象中是否有 public URL getUrl() 方法</span></span><br><span class="line">                        <span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">                            String name = m.getName();</span><br><span class="line">                            <span class="keyword">if</span> ((name.startsWith(<span class="string">"get"</span>) || name.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                    &amp;&amp; Modifier.isPublic(m.getModifiers())</span><br><span class="line">                                    &amp;&amp; !Modifier.isStatic(m.getModifiers())</span><br><span class="line">                                    &amp;&amp; m.getParameterTypes().length == <span class="number">0</span></span><br><span class="line">                                    &amp;&amp; m.getReturnType() == URL<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                                urlTypeIndex = i;</span><br><span class="line">                                attribMethod = name;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 找到方法参数列表中间接存在URL的参数，则结束寻找逻辑</span></span><br><span class="line">                                <span class="keyword">break</span> LBL_PTS;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果参数列表中没有一个参数有getUrl方法，则抛出异常</span></span><br><span class="line">                    <span class="keyword">if</span> (attribMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"fail to create adaptive class for interface "</span> + type.getName()</span><br><span class="line">                                + <span class="string">": not found url parameter or url attribute in parameters of method "</span> + method.getName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 为可返回URL的参数生成判空代码，如：if (arg0 == null) throw new IllegalArgumentException("com.alibaba.dubbo.rpc.Invoker argument == null");</span></span><br><span class="line">                    String s = String.format(<span class="string">"\nif (arg%d == null) throw new IllegalArgumentException(\"%s argument == null\");"</span>, urlTypeIndex, pts[urlTypeIndex].getName());</span><br><span class="line">                    code.append(s);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 为可返回URL的参数 的getUrl方法返回 的URL生成判空代码，如：if (arg0.getUrl() == null) throw new IllegalArgumentException("com.alibaba.dubbo.rpc.Invoker argument getUrl() == null");</span></span><br><span class="line">                    s = String.format(<span class="string">"\nif (arg%d.%s() == null) throw new IllegalArgumentException(\"%s argument %s() == null\");"</span>,</span><br><span class="line">                            urlTypeIndex, attribMethod, pts[urlTypeIndex].getName(), attribMethod);</span><br><span class="line">                    code.append(s);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 生成赋值语句，形如：URL url = argN.getUrl();</span></span><br><span class="line">                    s = String.format(<span class="string">"%s url = arg%d.%s();"</span>, URL<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">urlTypeIndex</span>, <span class="title">attribMethod</span>)</span>;</span><br><span class="line">                    code.append(s);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//----------------- 4 获取 Adaptive 注解值 ，Adaptive 注解值 value 类型为 String[]，可填写多个值，默认情况下为空数组 -------------/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *  获取<span class="doctag">@Adaptive</span>注解的值，如果有值，这些值将作为获取扩展名的key，需要注意，Protocol扩展和其它扩展点是不同的，前者获取扩展名是取协议，后者获取扩展名是取参数的值</span></span><br><span class="line"><span class="comment">                 *  1 普通扩展点，如ProxyFactor： String extName = url.getParameter("proxy", "javassist");</span></span><br><span class="line"><span class="comment">                 *  2 Protocol扩展点： String extName = ( url.getProtocol() == null ? "dubbo" : url.getProtocol() );</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                String[] value = adaptiveAnnotation.value();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果@Adaptive注解没有指定值，则根据扩展接口名生成。如：SimpleExt -&gt; simple.ext，即将扩展接口名中的大写转小写，并使用'.'把它们连接起来</span></span><br><span class="line">                <span class="keyword">if</span> (value.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获取扩展接口简单名称的字符数组</span></span><br><span class="line">                    <span class="keyword">char</span>[] charArray = type.getSimpleName().toCharArray();</span><br><span class="line">                    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">                        <span class="comment">// 判断是否大写字母，如果是就使用 '.' 连接，并大写转小写</span></span><br><span class="line">                        <span class="keyword">if</span> (Character.isUpperCase(charArray[i])) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                                sb.append(<span class="string">"."</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            sb.append(Character.toLowerCase(charArray[i]));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            sb.append(charArray[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    value = <span class="keyword">new</span> String[]&#123;sb.toString()&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//--------------------- 5 检测方法参数列表中是否存在 Invocation 类型的参数，有则表示是调用方法 --------------------/</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> hasInvocation = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 参数类型是Invocation</span></span><br><span class="line">                    <span class="keyword">if</span> (pts[i].getName().equals(<span class="string">"com.alibaba.dubbo.rpc.Invocation"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 为 Invocation 类型参数生成判空代码</span></span><br><span class="line">                        String s = String.format(<span class="string">"\nif (arg%d == null) throw new IllegalArgumentException(\"invocation == null\");"</span>, i);</span><br><span class="line">                        code.append(s);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 生成 String methodName = argN.getMethodName()； 代码，Invocation是调用信息，里面包含调用方法</span></span><br><span class="line">                        s = String.format(<span class="string">"\nString methodName = arg%d.getMethodName();"</span>, i);</span><br><span class="line">                        code.append(s);</span><br><span class="line">                        hasInvocation = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//----------------------- 6 扩展名决策逻辑，@SPI、@Adaptive以及方法含有Invocation类型参数都会影响最终的扩展名 -------------------------/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置默认拓展名，SPI注解值，默认情况下 SPI注解值为空串，此时cachedDefaultName = null</span></span><br><span class="line">                String defaultExtName = cachedDefaultName;</span><br><span class="line"></span><br><span class="line">                String getNameCode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 遍历Adaptive 的注解值，用于生成从URL中获取拓展名的代码，最终的扩展名会赋值给 getNameCode 变量。</span></span><br><span class="line"><span class="comment">                 * 注意：</span></span><br><span class="line"><span class="comment">                 * 1 这个循环的遍历顺序是由后向前遍历的，因为Adaptive注解可能配置了多个扩展名，而dubbo获取扩展名的策略是从前往后依次获取，找到即结束，以下代码拼接的时候也是从后往前拼接。</span></span><br><span class="line"><span class="comment">                 * 2 生成的扩展名代码大致有3大类，Adaptive的注解中属性值的数目决定了内嵌层级：</span></span><br><span class="line"><span class="comment">                 *（1） String extName = (url.getProtocol() == null ? defaultExtName : url.getProtocol()); 获取协议扩展点的扩展名</span></span><br><span class="line"><span class="comment">                 *（2） String extName = url.getMethodParameter(methodName, Adaptive的注解值, defaultExtName); 获取方法级别的参数值作为扩展名，因为方法的参数列表中含有Invocation调用信息。</span></span><br><span class="line"><span class="comment">                 *（3） String extName = url.getParameter(Adaptive的注解值, defaultExtName); 获取参数值作为扩展名</span></span><br><span class="line"><span class="comment">                 *（4） 如果Adaptive的注解中属性值有多个，就进行嵌套获取。如配置两个，以(3)为例：String extName = url.getParameter(Adaptive的注解值[0],url.getParameter(Adaptive的注解值[1], defaultExtName));</span></span><br><span class="line"><span class="comment">                 * 3  参数如果是protocol，protocol是url主要部分，可通过getProtocol方法直接获取。如果是其他的需要是从URL参数部分获取。两者获取方法不一样。其中参数获取又可分为方法级别参数和非方法级别参数</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = value.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                    <span class="comment">// 第一次遍历分支</span></span><br><span class="line">                    <span class="keyword">if</span> (i == value.length - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> != defaultExtName) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!<span class="string">"protocol"</span>.equals(value[i])) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 方法参数列表中有调用信息Invocation参数</span></span><br><span class="line">                                <span class="keyword">if</span> (hasInvocation) &#123;</span><br><span class="line">                                    getNameCode = String.format(<span class="string">"url.getMethodParameter(methodName, \"%s\", \"%s\")"</span>, value[i], defaultExtName);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    getNameCode = String.format(<span class="string">"url.getParameter(\"%s\", \"%s\")"</span>, value[i], defaultExtName);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                getNameCode = String.format(<span class="string">"( url.getProtocol() == null ? \"%s\" : url.getProtocol() )"</span>, defaultExtName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!<span class="string">"protocol"</span>.equals(value[i])) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 方法参数列表中有调用信息Invocation参数</span></span><br><span class="line">                                <span class="keyword">if</span> (hasInvocation) &#123;</span><br><span class="line">                                    getNameCode = String.format(<span class="string">"url.getMethodParameter(methodName, \"%s\", \"%s\")"</span>, value[i], defaultExtName);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    getNameCode = String.format(<span class="string">"url.getParameter(\"%s\")"</span>, value[i]);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                getNameCode = <span class="string">"url.getProtocol()"</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 第二次开始都走该分支，用于嵌套获取扩展名</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="string">"protocol"</span>.equals(value[i])) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 方法参数列表中有调用信息Invocation参数</span></span><br><span class="line">                            <span class="keyword">if</span> (hasInvocation) &#123;</span><br><span class="line">                                getNameCode = String.format(<span class="string">"url.getMethodParameter(methodName, \"%s\", \"%s\")"</span>, value[i], defaultExtName);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                getNameCode = String.format(<span class="string">"url.getParameter(\"%s\", %s)"</span>, value[i], getNameCode);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            getNameCode = String.format(<span class="string">"url.getProtocol() == null ? (%s) : url.getProtocol()"</span>, getNameCode);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 生成扩展明 赋值代码</span></span><br><span class="line">                code.append(<span class="string">"\nString extName = "</span>).append(getNameCode).append(<span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 生成 扩展明 判空代码</span></span><br><span class="line">                String s = String.format(<span class="string">"\nif(extName == null) "</span> +</span><br><span class="line">                                <span class="string">"throw new IllegalStateException(\"Fail to get extension(%s) name from url(\" + url.toString() + \") use keys(%s)\");"</span>,</span><br><span class="line">                        type.getName(), Arrays.toString(value));</span><br><span class="line">                code.append(s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//---------------------------------------- 7 生成 获取扩展对象代码 以及 调用扩展对象的目标方法代码 ---------------------------------/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 生成 extension扩展对象 赋值 代码</span></span><br><span class="line">                s = String.format(<span class="string">"\n%s extension = (%&lt;s)%s.getExtensionLoader(%s.class).getExtension(extName);"</span>, type.getName(), ExtensionLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>(), <span class="title">type</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">                code.append(s);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果方法返回值类型非void，则生成return语句</span></span><br><span class="line">                <span class="keyword">if</span> (!rt.equals(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    code.append(<span class="string">"\nreturn "</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 生成 extension扩展对象 调用目标方法逻辑，形如： extension.方法名(arg0, arg2, ..., argN);</span></span><br><span class="line">                s = String.format(<span class="string">"extension.%s("</span>, method.getName());</span><br><span class="line">                code.append(s);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 生成extension调用方法中的参数 拼接，注意和生成方法签名的参数名保持一直</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                        code.append(<span class="string">", "</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    code.append(<span class="string">"arg"</span>).append(i);</span><br><span class="line">                &#125;</span><br><span class="line">                code.append(<span class="string">");"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//------------------------------------------- 8  生成方法签名，包裹方法体内容 ---------------------------------------/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成方法签名，格式：public + 返回值全限定名 + 方法名 +(</span></span><br><span class="line">            codeBuilder.append(<span class="string">"\npublic "</span>).append(rt.getCanonicalName()).append(<span class="string">" "</span>).append(method.getName()).append(<span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成方法签名的参数列表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    codeBuilder.append(<span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                codeBuilder.append(pts[i].getCanonicalName());</span><br><span class="line">                codeBuilder.append(<span class="string">" "</span>);</span><br><span class="line">                codeBuilder.append(<span class="string">"arg"</span>).append(i);</span><br><span class="line">            &#125;</span><br><span class="line">            codeBuilder.append(<span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成异常抛出代码</span></span><br><span class="line">            <span class="keyword">if</span> (ets.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                codeBuilder.append(<span class="string">" throws "</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ets.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        codeBuilder.append(<span class="string">", "</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    codeBuilder.append(ets[i].getCanonicalName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 方法开始符号</span></span><br><span class="line">            codeBuilder.append(<span class="string">" &#123;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 包括方法体内容</span></span><br><span class="line">            codeBuilder.append(code.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 追加方法结束符号</span></span><br><span class="line">            codeBuilder.append(<span class="string">"\n&#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 追加类的结束符号，生成自适应扩展类结束</span></span><br><span class="line">        codeBuilder.append(<span class="string">"\n&#125;"</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(codeBuilder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> codeBuilder.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码逻辑就一个任务，使用字符串拼接一个自适应扩展类串，梳理出来后并没有那么复杂，其实就是按照编写一个类的步骤进行拼接的。如果非要说复杂的话，那么就提体现在拼接扩展名的逻辑代码中，因为情况非常多，胖友们可以多调试多归类。想要观察生成的自适应扩展类有两种办法，日志级别设置成debug是一种简单粗暴的方式，还可以使用反编译工具进行查看。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇文章主要分析了自动生成的自适应扩展类的原理，以及详细分析了生成一个自适应扩展类的过程，总体来说还是很复杂的。至于为什么不直接使用代理的方式生成自适应扩展类，主要的原因是代理方式效率太低，更详细的可以参考梁飞大佬的博客 <a href="https://www.iteye.com/blog/javatar-814426" target="_blank" rel="noopener">动态代理方案性能对比</a>。自适应扩展还没结束，我们虽然有了一个自适应扩展类的字符串，但是还需要对这个字符串进行编译处理成Class，这样才能创建一个对象自适应扩展对象，下一篇文章中我们就来分析dubbo的动态编译原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;上一篇文章中我们分析了dubbo spi机制，但是遗留了自适应扩展并没有展开说明，这篇文章就是来填坑的。上篇文章中也介绍了固定的自适应扩展类
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="SPI" scheme="https://gentryhuang.com/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Dubbo SPI</title>
    <link href="https://gentryhuang.com/posts/5d81f464/"/>
    <id>https://gentryhuang.com/posts/5d81f464/</id>
    <published>2020-03-12T16:00:00.000Z</published>
    <updated>2020-09-05T14:06:44.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>dubbo并未使用jdk标准的SPI机制，而是对其进行了增强，优化了性能问题并且相比jdk spi更加健壮。</p><h3 id="dubbo-spi-对-jdk-spi的改进"><a href="#dubbo-spi-对-jdk-spi的改进" class="headerlink" title="dubbo spi 对 jdk spi的改进"></a>dubbo spi 对 jdk spi的改进</h3><ul><li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源，而dubbo可以选择性实例化。</li><li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时会报不支持ruby，而不是真正失败的原因。</li><li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li><li>原始jdk spi 不支持缓存，dubbo设计了多维度缓存，提高了框架的性能。</li></ul><h3 id="dubbo-spi-配置规范"><a href="#dubbo-spi-配置规范" class="headerlink" title="dubbo spi 配置规范"></a>dubbo spi 配置规范</h3><ul><li><p>spi配置文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">META-INF&#x2F;dubbo&#x2F;internal : 主要用于 Dubbo 内部提供的拓展点实现</span><br><span class="line">META-INF&#x2F;dubbo : 主要用于自定义扩展点实现</span><br><span class="line">META-INF&#x2F;services : 用于兼容jdk的spi</span><br></pre></td></tr></table></figure><p><font color="#c7254e">说明:</font> 上面的spi配置文件路径是种规范，实际上在使用的时候写在哪个文件下都可以被加载到，但是实际开放种最好按照规范配置。</p></li><li><p>spi配置文件名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扩展点全路径名</span><br></pre></td></tr></table></figure></li><li><p>文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key&#x3D;value形式，多个使用换行符分割，这是dubbo配置的方式</span><br><span class="line">value形式，没有指定扩展名，这是jdk配置方式，dubbo进行了兼容，会自动为扩展实现类生成默认的扩展名</span><br></pre></td></tr></table></figure></li></ul><p><font color="#c7254e">说明:</font> dubbo spi 通过键值对的方式进行配置，这样我们可以按需实例化扩展点的实现，而不是一次实例化所有的扩展实现类。</p><ul><li>加载扩展实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo使用ExtensionLoader加载指定实现类，dubbo spi的逻辑几乎都封装在该类中。</span><br></pre></td></tr></table></figure></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>前面简单介绍了dubbo spi机制，下面我们通过一个例子来演示dubbo spi的简单用法。扩展点接口及实现复用 <a href="https://gentryhuang.com/posts/a9c33b8c/">spi机制之jdk示例</a> 中代码，区别是dubbo spi的接口使用@SPI注解进行标注。</p><p>定义扩展接口，使用@SPI注解进行标注</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.spi;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在META-INF/dubbo文件目录下创建一个文件，名称为Command的全路径名 com.alibaba.dubbo.spi.Command。 配置内容为扩展实现类及其扩展名，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start&#x3D;com.alibaba.dubbo.spi.impl.StartCommand</span><br><span class="line">shutdown&#x3D;com.alibaba.dubbo.spi.impl.ShutdownCommand</span><br></pre></td></tr></table></figure><p>准备就绪后，最后写测试代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// ExtensionLoader是dubbo提供的，用来加载拓展实现类</span></span><br><span class="line">       ExtensionLoader&lt;Command&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Command<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 加载指定扩展名对应的扩展实现对象（获取的时候会进行实例化）</span></span><br><span class="line">       Command startCommand = extensionLoader.getExtension(<span class="string">"start"</span>);</span><br><span class="line">       startCommand.execute();</span><br><span class="line"></span><br><span class="line">       Command shutdownCommand = extensionLoader.getExtension(<span class="string">"shutdown"</span>);</span><br><span class="line">       shutdownCommand.execute();</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start command</span><br><span class="line">shut down command</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>简单说明和演示dubbo spi后，我们对dubbo spi有了一定的认识，使用起来还是比较简单的，接下来进入源码分析阶段，让我们一起去看看dubbo底层是怎么加载和选择扩展实现的。</p><h3 id="dubbo-spi-源码分析"><a href="#dubbo-spi-源码分析" class="headerlink" title="dubbo spi 源码分析"></a>dubbo spi 源码分析</h3><p>进行源码分析之前，我们先看下dubbo spi整体的代码结构，然后对核心注解和类进行说明。</p><h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-spi.jpg" alt></p><h4 id="扩展点-SPI-注解"><a href="#扩展点-SPI-注解" class="headerlink" title="扩展点 SPI 注解"></a>扩展点 SPI 注解</h4><p>扩展点接口标识，dubbo的扩展点必须标注该注解，否则在执行spi逻辑时框架会报异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SPI &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缺省扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SPI注解的value属性是用来指定扩展点的默认扩展名，如Protocol扩展接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>&#123;<span class="comment">//...&#125;  // dubbo对应的扩展实现类就是DubboProtocol，即Protocol默认的扩展实现类</span></span><br></pre></td></tr></table></figure><h4 id="扩展点-Adaptive-注解"><a href="#扩展点-Adaptive-注解" class="headerlink" title="扩展点 Adaptive 注解"></a>扩展点 Adaptive 注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据URL的Key获取对应的Value作为自适应拓展名。比如，&lt;code&gt;String[] &#123;"key1", "key2"&#125;&lt;/code&gt;，表示</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;先在URL上找key1的Value作为自适应拓展名；</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;key1没有value，则使用key2的value作为自适应拓展名。</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;key2没有value，就使用缺省的扩展，即： 如果&#123;<span class="doctag">@link</span> URL&#125;这些Key都没有value，使用缺省的扩展（在接口的&#123;<span class="doctag">@link</span> SPI&#125;中设定的值）</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;如果没有设置缺省扩展名或者缺省扩展名也没有value，则方法调用会抛出&#123;<span class="doctag">@link</span> IllegalStateException&#125;。</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * 注意：如果没有使用Adaptive注解指定扩展名，扩展接口也没有指定<span class="doctag">@SPI</span>默认值，则在加载扩展实现的时候dubbo会自动把扩展接口名称根据驼峰大小写分开，并使用 '.' 符号连接起来，</span></span><br><span class="line"><span class="comment">     *      以此名称作为默认扩展名。如：SimpleExt -&gt; simple.ext</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> parameter key names in URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个拓展接口，在框架中同时只能存在一个 Adaptive 拓展实现类，可能是固定的扩展实现类，也可能是自动生成、编译得到的扩展实现类。@Adaptive 注解，可添加类或方法上，分别代表了两种不同的使用方式。第一种，标记在类上（属于装饰类），整个实现类会作为自适应扩展类，dubbo不会为该类生成代理类，它主要用于固定已知类。目前 Dubbo 项目里，只有 ExtensionFactory 拓展的实现类 AdaptiveExtensionFactory 和Compiler 拓展的实现AdaptiveCompiler这么使用。第二种，标记在扩展接口的方法上，代表自动生成、编译一个该接口的动态Adaptive拓展实现类（属于动态代理类，如Protocol$Adaptive），一般该类没有实际的工作，只是根据参数和运行状态加载其他的扩展实现来完成最终的工作。</p><h4 id="扩展点-Activate-注解"><a href="#扩展点-Activate-注解" class="headerlink" title="扩展点 Activate 注解"></a>扩展点 Activate 注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Activate &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * group过滤条件。在调用&#123;<span class="doctag">@link</span> ExtensionLoader#getActivateExtension(URL, String, String)&#125; 方法时，如果传入的group参数符合该注解设置的group属性值，则匹配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] group() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key过滤条件。在调用&#123;<span class="doctag">@link</span> ExtensionLoader#getActivateExtension(URL, String, String)&#125; 方法时，如果url中的参数中存在该注解设置的key值，则匹配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension list which should be put before the current one</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] before() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension list which should be put after the current one</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] after() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> absolute ordering info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解用于设置扩展实现类被自动激活的加载条件，如：过滤器扩展点有多个实现，那么就可以使用该注解设置激活条件，在获取自动激活扩展实现时需要符合条件才能获取到。框架通过ExtensionLoader#getActivateExtension方法获得激活条件的扩展实现集合。</p><h4 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h4><p>dubbo的扩展加载器，dubbo spi 的相关逻辑几乎都被封装在该类中，该类是 <code>dubbo spi 的 核心</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtensionLoader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//========================================= 类属性，所有ExtensionLoader对象共享 ================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dubbo扩展点目录 ，该目录是为了兼容jdk的spi</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICES_DIRECTORY = <span class="string">"META-INF/services/"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dubbo扩展点目录，主要用于自定义扩展点实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_DIRECTORY = <span class="string">"META-INF/dubbo/"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dubbo扩展点目录，用于 Dubbo 内部提供的拓展点实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + <span class="string">"internal/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点实现名的分隔符 正则表达式，多个扩展点名之间使用 ',' 进行分割</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern NAME_SEPARATOR = Pattern.compile(<span class="string">"\\s*[,]+\\s*"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点加载器集合</span></span><br><span class="line"><span class="comment">     * key: 拓展点接口</span></span><br><span class="line"><span class="comment">     * value: 扩展点加载器。 一个扩展点接口对应一个 扩展点加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点实现类集合</span></span><br><span class="line"><span class="comment">     * key: 扩展点实现类</span></span><br><span class="line"><span class="comment">     * value: 扩展点实现对象</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 一个扩展点通过对应的ExtensionLoader去加载它的具体实现，考虑到性能和资源问题，在加载拓展配置后不会立马进行扩展实现的对象的初始化，而是先把扩展配置存起来。</span></span><br><span class="line"><span class="comment">     * 等到真正使用对应的拓展实现时才进行扩展实现的对象的初始化，初始化后也进行缓存。即：</span></span><br><span class="line"><span class="comment">     * 1 缓存加载的拓展配置</span></span><br><span class="line"><span class="comment">     * 2 缓存创建的拓展实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==============================  实例属性 ，每个ExtensionLoader对象独有 ====================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点，如：Protocol</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点实现工厂，用于向扩展对象中注入依赖属性，一般通过调用 &#123;<span class="doctag">@link</span> #injectExtension(Object)&#125; 方法进行实现。</span></span><br><span class="line"><span class="comment">     * 特别说明：</span></span><br><span class="line"><span class="comment">     *  除了ExtensionFactory扩展接口，其余的所有扩展接口的ExtensionLoader对象都会拥有一个自己的扩展工厂，即 objectFactory = AdaptiveExtensionFactory；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExtensionFactory objectFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点实现类 到 扩展名 的映射</span></span><br><span class="line"><span class="comment">     * 如：</span></span><br><span class="line"><span class="comment">     * dubbo=dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol ===&gt; &lt;DubboProtocol,dubbo&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名 到 扩展点实现类 的映射</span></span><br><span class="line"><span class="comment">     * 不包括以下两种类型：</span></span><br><span class="line"><span class="comment">     * 1 自适应扩展实现类，如：AdaptiveExtensionFactory</span></span><br><span class="line"><span class="comment">     * 2 扩展点的Wrapper实现类，如：ProtocolFilterWrapper</span></span><br><span class="line"><span class="comment">     * 如：</span></span><br><span class="line"><span class="comment">     * dubbo=dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol ===&gt; &lt;dubbo,DubboProtocol&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class="keyword">new</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名 到 <span class="doctag">@Activate</span>注解 的映射， 如： ContextFilter -&gt; Activate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Activate&gt; cachedActivates = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Activate&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名 到 扩展点实现对象 的映射</span></span><br><span class="line"><span class="comment">     * 如：</span></span><br><span class="line"><span class="comment">     * dubbo=dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol ===&gt; &lt;dubbo,Holder&lt;DubboProtocol对象&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应扩展对象</span></span><br><span class="line"><span class="comment">     * 注意: 一个扩展点最多只能有一个自适应扩展对象，&gt; 1 框架就会报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Object&gt; cachedAdaptiveInstance = <span class="keyword">new</span> Holder&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应扩展实现类 &#123;<span class="doctag">@link</span> #getAdaptiveExtensionClass()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Class&lt;?&gt; cachedAdaptiveClass = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点的默认扩展名，通过 &#123;<span class="doctag">@link</span> SPI&#125; 注解获得</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String cachedDefaultName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建自适应对象时发生的异常 -&gt; &#123;<span class="doctag">@link</span> #createAdaptiveExtension()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Throwable createAdaptiveInstanceError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点Wrapper实现类集合，如：ProtocolFilterWrapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名 到 加载对应扩展类发生的异常 的映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IllegalStateException&gt; exceptions = <span class="keyword">new</span> ConcurrentHashMap&lt;String, IllegalStateException&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1 任意一个扩展点在获取对应的ExtensionLoader时，都会先尝试获取属于它的ExtensionFactory自适应扩展，即 AdaptiveExtensionFactory，</span></span><br><span class="line"><span class="comment">     * 它管理着SpiExtensionFactory和SpringExtensionFactory这两大扩展点工厂，用于调用 &#123;<span class="doctag">@link</span> #injectExtension(Object)&#125;方法，向扩展实现中注入依赖属性，</span></span><br><span class="line"><span class="comment">     * 需要注意的是，SpiExtensionFactory和SpringExtensionFactory获得对象是不同的，前者获取自适应对象，后者从Spring容器中获取对象。</span></span><br><span class="line"><span class="comment">     * 2 当扩展点是ExtensionFactory时，那么它的对应的ExtensionLoader的objectFactory 属性为null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 扩展点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 省略其它代码...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于性能的考虑，dubbo spi相比较与jdk spi的一个改进就是使用了大量的缓存，dubbo spi 缓存从大的方向可分为 <code>类缓存</code>、<code>实例缓存</code>，这两种缓存又能根据扩展实现类的种类分为 <code>普通扩展缓存</code>、<code>包装扩展缓存</code>、<code>自适应扩展缓存</code>。</p><ul><li>类缓存<blockquote><p>dubbo spi在查询扩展类时，会先从缓存中获取，如果缓存中不存在，再加载配置文件并分类缓存，注意，这个过程不会进行初始化流程。</p></blockquote></li><li>实例缓存<blockquote><p>dubbo spi缓存的Class是按需进行实例化的，在查询实例时会先从缓存中获取，如果缓存不存在则会进行加载/初始化，然后缓存起来。</p></blockquote></li></ul><h4 id="多类型的扩展点"><a href="#多类型的扩展点" class="headerlink" title="多类型的扩展点"></a>多类型的扩展点</h4><p>根据扩展实现类的特点及用途可以分为普通扩展类、自动激活扩展类、包装扩展类以及自适应扩展类，其中自动激活扩展类属于普通扩展类。需要注意的是，除了动态编译得到的自适应扩展类，其它的所有扩展类都需要在配置文件中进行配置，否则框架无法加载到。下面我们简单说明下各个类型的扩展类及其特点。</p><h5 id="普通扩展类"><a href="#普通扩展类" class="headerlink" title="普通扩展类"></a>普通扩展类</h5><p>属于最基础的扩展类，一般通过扩展名获取对应的扩展实现就是该类型。在配置普通扩展类时需要指定扩展名，不指定会按规则自动生成，因为普通扩展实现都是根据扩展名获取的。</p><h5 id="包装扩展类"><a href="#包装扩展类" class="headerlink" title="包装扩展类"></a>包装扩展类</h5><p>包括扩展类又叫 <code>Wrapper类</code>，一般不是扩展点的真正实现，主要用来对扩展实现进行功能增强或通用逻辑处理。Wrapper类有两个特征：<code>实现扩展接口</code>、<code>存在一个参数类型是扩展点的构造方法</code>。Wrapper类是dubbo <code>AOP</code>的实现。在配置Wrapper类时，可以不指定扩展名，即使指定了也不会使用，但一般情况根据dubbo spi的约定还是统一配置。</p><h5 id="自适应类"><a href="#自适应类" class="headerlink" title="自适应类"></a>自适应类</h5><p>自适应类非常灵活，也叫 <code>Adaptive类</code>，有两种实现方式。Adaptive类的两个特征：<code>实现扩展接口</code>、<code>实现类或扩展接口的方法上需要使用 @Adaptive 标注</code>。类上标注@Adaptive是一个Adaptive类可以理解，但是扩展接口的方法上标注@Adaptive怎么会是一个类呢？是因为标注在扩展接口的方法上，dubbo spi机制在获取自适应扩展实现类时，如果当前环境中没有自适应扩展实现类就会对标注的方法所在接口进行javassist操作，生成自适应扩展类的字符串，然后通过动态编译成一个自适应类。@Adaptive标注在扩展接口的方法上的方式，可以动态地通过URL中的参数来确定使用哪个扩展实现。在配置文件中可以不指定扩展名，即使指定了也不会使用，但一般情况根据dubbo spi的约定还是统一配置。</p><h5 id="自动激活类"><a href="#自动激活类" class="headerlink" title="自动激活类"></a>自动激活类</h5><p>自动激活类属于特殊的普通扩展类，该类的两个特征：<code>实现接口</code>、<code>类上使用 @Activate 标注</code>。它支持某个扩展点需要同时激活多个实现的特性，如 dubbo中的过滤器扩展点，需要激活多个扩展实现。</p><h4 id="ExtensionLoader-工作流程"><a href="#ExtensionLoader-工作流程" class="headerlink" title="ExtensionLoader 工作流程"></a>ExtensionLoader 工作流程</h4><p>ExtensionLoader封装了dubbo spi的主要逻辑，配置的加载、扩展类缓存、扩展实现的实例化及缓存、自适应类的生成与编译及缓存、自适应对象的实例化及缓存以及dubbo ioc和aop的实现等。这些逻辑主要体现在三个入口方法中，每个入口方法获取到的扩展实现类型会有所不同，但是方法内部逻辑有相同之处。下面我们分别从三个入口方法开始详细分析dubbo spi的整个流程，需要说明的是，getExtension方法是最核心的方法，其它两个入口方法都会依赖该方法中的部分流程，因此我们会先分析getExtension方法，在分析其它两个方法的时候涉及重复的流程就不再分析。</p><h5 id="getExtension-方法"><a href="#getExtension-方法" class="headerlink" title="getExtension 方法"></a>getExtension 方法</h5><p>ExtensionLoader中最核心的方法，因为它实现了一个完整的查询扩展实现的逻辑。获取过程中的每一步都会先检查缓存是否命中，命中就直接返回或进行赋值，没有命中则加载配置文件，然后缓存配置文件中的扩展实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获得指定扩展名的扩展对象</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> name 扩展名</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果当前扩展名是 'true'，就获取默认的扩展对象</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="string">"true"</span>.equals(name)) &#123;</span><br><span class="line">         <span class="comment">// 方法简化为 getExtension(cachedDefaultName) , cacheDefaultName的值参见 @SPI注解</span></span><br><span class="line">         <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 从缓存中获得对应的扩展对象</span></span><br><span class="line">     Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line">     <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">         cachedInstances.putIfAbsent(name, <span class="keyword">new</span> Holder&lt;Object&gt;());</span><br><span class="line">         holder = cachedInstances.get(name);</span><br><span class="line">     &#125;</span><br><span class="line">     Object instance = holder.get();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 缓存中没有， 双重检锁获取扩展名对应扩展实现对象</span></span><br><span class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">             instance = holder.get();</span><br><span class="line">             <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 缓存中确实没有，就创建扩展名对应的扩展实现对象</span></span><br><span class="line">                 instance = createExtension(name);</span><br><span class="line">                 <span class="comment">// 将扩展实现对象放入缓存中</span></span><br><span class="line">                 holder.set(instance);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> (T) instance;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的代码逻辑比较简单，根据扩展名获取扩展对象，先检查缓存中是否有目标对象，没有则调用 <code>createExtension</code>方法开始创建扩展对象。需要特被说明的是，如果name是true的情况，加载的就是默认扩展类。那么下面我们来分析createExtension方法流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建扩展名对应的扩展点实现对象并缓存到类属性的集合中</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取扩展名对应的扩展点实现类，先尝试从缓存中取对应的扩展实现类，没有的话就加载配置文件然后再次获取</span></span><br><span class="line">       Class&lt;?&gt; clazz =</span><br><span class="line">               getExtensionClasses()</span><br><span class="line">                       .get(name);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 没有找到扩展名对应的扩展点实现类，则报错</span></span><br><span class="line">       <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> findException(name);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 从类属性缓存集合中尝试获取扩展点实现类对应的对象</span></span><br><span class="line">           T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 当缓存中没有，就通过反射创建扩展点实现类对象并放入缓存</span></span><br><span class="line">           <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">               EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">               instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// dubbo ioc实现，进行setter注入</span></span><br><span class="line">           injectExtension(instance);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * dubbo aop实现</span></span><br><span class="line"><span class="comment">            * 注意：</span></span><br><span class="line"><span class="comment">            *  如果当前扩展点存在 Wrapper类，那么从ExtensionLoader 中获得的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类，因此调用方法时调用的是Wrapper类中的方法，并非直接调用扩展点的真正实现。</span></span><br><span class="line"><span class="comment">            *  即 如果在Wrapper的方法中不显示调用扩展点的真正实现的话，那么结果一定不是预期的。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">           <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                   <span class="comment">// 创建 Wrapper 实例，然后进行 setter注入依赖属性</span></span><br><span class="line">                   instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> instance;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension instance(name: "</span> + name + <span class="string">", class: "</span> +</span><br><span class="line">                   type + <span class="string">")  could not be instantiated: "</span> + t.getMessage(), t);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>createExtension(String name)方法的逻辑代码中已经详细注释说明，下面小结关键的步骤：</p><ol><li>调用getExtensionClasses()刷新扩展点实现类集合</li><li>通过反射创建扩展点的扩展对象并放入类缓存中</li><li>使用dubbo的setter注入向扩展对象中注入依赖属性</li><li>使用扩展点的Wrapper对扩展对象实现dubbo的aop处理逻辑<br></li></ol><p>通过扩展名获取扩展对象时可能不能命中缓存，此时就要创建扩展对象，创建扩展对象需要扩展实现类，下面我们看下dubbo获取扩展名到扩展实现类的映射集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取扩展点实现类的集合，先从缓存中获取，没有命中缓存就从配置文件中加载并分类放入缓存。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 先从缓存中获取</span></span><br><span class="line">      Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 双重检锁，获取扩展点的扩展实现类集合</span></span><br><span class="line">      <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">              classes = cachedClasses.get();</span><br><span class="line">              <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 加载扩展类</span></span><br><span class="line">                  classes = loadExtensionClasses();</span><br><span class="line">                  <span class="comment">// 将 扩展名到扩展点实现类的映射 加入到 cachedClasses 集合中，缓存起来</span></span><br><span class="line">                  cachedClasses.set(classes);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> classes;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果缓存不能命中扩展名对应的扩展实现类就只能加载配置文件刷新扩展点实现类集合,下面我们看下dubbo是如何加载配置文件的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">//1、 通过@SPI注解获得扩展点的默认扩展名（前提是当前拓展点需要有@SPI注解，其实程序执行到这里type一定是有@SPI注解的，因为在获取扩展点的扩展加载器的时候已经判断了）</span></span><br><span class="line">    <span class="keyword">final</span> SPI defaultAnnotation = type.getAnnotation(SPI<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.1 如果扩展点的@SPI注解设置了默认值</span></span><br><span class="line">    <span class="keyword">if</span> (defaultAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @SPI注解的值就是扩展点的默认扩展名</span></span><br><span class="line">        String value = defaultAnnotation.value();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对默认扩展名进行分隔处理，以逗号分隔为字符串数组</span></span><br><span class="line">            String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测 SPI 注解内容是否合法，不合法则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"more than 1 default extension name on extension "</span> + type.getName()</span><br><span class="line">                        + <span class="string">": "</span> + Arrays.toString(names));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** 设置默认名称，cachedDefaultName 是用来加载扩展点的默认实现 &#123;<span class="doctag">@link</span> #getDefaultExtension()&#125; */</span></span><br><span class="line">            <span class="keyword">if</span> (names.length == <span class="number">1</span>) &#123;</span><br><span class="line">                cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、 从配置文件中加载拓展实现类集合，这里分别对应三类文件（1. Dubbo内置的 2. Dubbo自定义 3. JDK SPI）</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY);</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到该方法没有太多的逻辑，主要处理扩展点的默认扩展名，如果存在的化就放入缓存中，具体加载配置文件的逻辑由loadDirectory方法实现。 需要注意的是，唯一调用该方法的入口 {@link #getExtensionClasses()} 已经加过了锁，因此此处无需再次加锁。接下来继续分析dubbo如何加载配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接完整的文件名（相对路径）： 目录 + type全类名</span></span><br><span class="line">    String fileName = dir + type.getName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类加载器</span></span><br><span class="line">        ClassLoader classLoader = findClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 获得文件名对应的所有文件数组（可能同一个文件名在不同的目录结构中，这样就会获取多个文件）,每个文件内容封装到一个java.net.URL中*/</span></span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            urls = classLoader.getResources(fileName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历java.net.URL集合</span></span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.URL resourceURL = urls.nextElement();</span><br><span class="line">                <span class="comment">// 加载java.net.URL</span></span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"Exception when load extension class(interface: "</span> +</span><br><span class="line">                type + <span class="string">", description file: "</span> + fileName + <span class="string">")."</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码可以看出,loadDirectory方法主要就做一件事，加载配置文件并将每个配置文件内容封装到java.net.URL集合中，接下来在loadResource方法中就可以从该URL中依次解析扩展名和扩展实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 加载配置文件内容（已经封装成了java.net.URL）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> extensionClasses 扩展类集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> classLoader      类加载器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> resourceURL      文件内容资源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 读取文件内容</span></span><br><span class="line">           BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(resourceURL.openStream(), <span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">               String line;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 一行一行的读取。会跳过当前被注释掉行，例如：#dubbo=xxx</span></span><br><span class="line">               <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 如果有#注释，那么ci为0，没有就为-1</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">'#'</span>);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 在有#注释的情况下，此时line的长度为0</span></span><br><span class="line">                   <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 去除前后端空格，防止自定义扩展点实现时配置不规范</span></span><br><span class="line">                   line = line.trim();</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 没有#注释的情况</span></span><br><span class="line">                   <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">/**</span></span><br><span class="line"><span class="comment">                            * 拆分 key=value ，name为拓展名 line为拓展实现类名。注意：</span></span><br><span class="line"><span class="comment">                            * 1 这里name可能为空,这种情况扩展名会自动生成（因为Dubbo SPI兼容Java SPI，Dubbo SPI配置强调key=value格式，应该尽可能遵守规则）</span></span><br><span class="line"><span class="comment">                            * 2 扩展名只对普通扩展才有意义，对自适应扩展、Wrapper是没用的，之所以要配置，是为了统一dubbo spi配置规则</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line"></span><br><span class="line">                           String name = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// i &gt; 0，有扩展名； i &lt; 0 没有配置扩展名，即兼容Java SPI</span></span><br><span class="line">                           <span class="keyword">int</span> i = line.indexOf(<span class="string">'='</span>);</span><br><span class="line"></span><br><span class="line">                           <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="comment">/** 获取 = 左边的key 即扩展名 */</span></span><br><span class="line">                               name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                               <span class="comment">/** 获取 = 右边的value 即拓展点的实现的全限定性类名 */</span></span><br><span class="line">                               line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// 加载当前行对应的扩展点配置</span></span><br><span class="line">                           <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                * 1 通过反射，根据名称获取扩展点实现类</span></span><br><span class="line"><span class="comment">                                * 2 对扩展实现类进行分类缓存</span></span><br><span class="line"><span class="comment">                                */</span></span><br><span class="line">                               loadClass(extensionClasses, resourceURL, Class.forName(line, <span class="keyword">true</span>, classLoader), name);</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                           IllegalStateException e = <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to load extension class(interface: "</span> + type + <span class="string">", class line: "</span> + line + <span class="string">") in "</span> + resourceURL + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                           exceptions.put(line, e);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               reader.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           logger.error(<span class="string">"Exception when load extension class(interface: "</span> +</span><br><span class="line">                   type + <span class="string">", class file: "</span> + resourceURL + <span class="string">") in "</span> + resourceURL, t);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>loadResource方法用于将配置文件中的每行记录读取出来，经过解析和反射处理就能拿到扩展名和对应的扩展实现类，扩展名和扩展实现类的获取逻辑已经在代码中详细注释。最后调用loadClass方法进行分类缓存，这些缓存很多，我们来看下dubbo是如何处理实例缓存的分类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对扩展点实现类进行分类缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> extensionClasses 扩展实现类集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resourceURL      文件内容资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz            扩展点实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name             扩展名  【只对普通扩展才有意义】</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断拓展点实现类，是否实现了当前type接口，没有实现就会报错</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error when load extension class(interface: "</span> +</span><br><span class="line">                type + <span class="string">", class line: "</span> + clazz.getName() + <span class="string">"), class "</span></span><br><span class="line">                + clazz.getName() + <span class="string">"is not subtype of interface."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------- 根据扩展点实现类的类型可分为三大类 ，在进行分类缓存中有优先级，即同一个实现类只能归属到某个分类中 --------------------------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、自适应扩展类</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * （1）当前扩展点实现类是否标注<span class="doctag">@Adaptive</span>注解，标记的话就是自适应扩展类，直接缓存到 cachedAdaptiveClass 属性中，然后结束逻辑，即不会进行下面的 Wrapper、普通扩展类以及自动激活类逻辑判断。</span></span><br><span class="line"><span class="comment">     * （2）自适应固定扩展实现类其实不需要配置扩展名，即使配置了也用不到，因为自适应扩展类和自适应扩展对象整个转换闭环都用不到扩展名。之所以配置，是为了统一规则。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="comment">// 一个扩展点有且仅允许一个自适应扩展实现类，如果符合条件就加入到缓存中，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedAdaptiveClass = clazz;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"More than 1 adaptive class found: "</span></span><br><span class="line">                    + cachedAdaptiveClass.getClass().getName()</span><br><span class="line">                    + <span class="string">", "</span> + clazz.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  2、Wrapper类型 （该类需要有有一个参数的构造方法，且这个参数类型是当前的扩展点type）</span></span><br><span class="line"><span class="comment">         *  说明：</span></span><br><span class="line"><span class="comment">         *  （1）当前扩展点实现类如果是Wrapper类，直接缓存到 cachedWrapperClasses 属性集合中，然后结束逻辑，即不会进行下面的 普通扩展类以及自动激活类逻辑判断。</span></span><br><span class="line"><span class="comment">         *  （2）Wrapper类其实不需要配置扩展名，即使配置了也用不到。之所以配置，是为了统一规则。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrappers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">            wrappers = cachedWrapperClasses;</span><br><span class="line">        &#125;</span><br><span class="line">        wrappers.add(clazz);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3、普通的扩展实现类，注意Activate自动激活类从大的方面也属于普通的扩展实现类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否有默认的构造方法，没有会抛出异常</span></span><br><span class="line">        clazz.getConstructor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未配置扩展名，则自动生成。适用于Java SPI的配置方式（Dubbo SPI 兼容Java SPI） 例如： xxx.yyy.DemoFilter生成的拓展名为demo</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 自动生成扩展名</span></span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such extension name for the class "</span> + clazz.getName() + <span class="string">" in the config "</span> + resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对扩展名进行分割处理，dubbo支持配置多个扩展名。如果配置多个扩展名需要以','分割</span></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (names != <span class="keyword">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.1、 如果当前类标注了@Activate，就缓存到 cachedActivates集合。需要注意的是，即使扩展点配置多个，cachedActivates 的key 只取第一个。</span></span><br><span class="line">            Activate activate = clazz.getAnnotation(Activate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (activate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 拓展名与 @Activate的映射</span></span><br><span class="line">                cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 3.2、缓存当前扩展点分类到 cachedNames 集合 和 cachedClasses 集合</span></span><br><span class="line"><span class="comment">             * 说明：</span></span><br><span class="line"><span class="comment">             *  （1）cachedNames 缓存集合中的数据特点：同一个扩展点实现类对应的扩展名即使在配置多个扩展名的情况下也只取第一个</span></span><br><span class="line"><span class="comment">             *  （2）cachedClasses 缓存集合的数据特点：同一个扩展点实现类对应的扩展名可能存在多个</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存扩展类到扩展名的映射</span></span><br><span class="line">                <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                    cachedNames.put(clazz, n);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存扩展名到扩展类的映射，注意如果在不同的文件中配置同一个扩展点实现，并且扩展名有相同的情况，这时以解析的第一个为准</span></span><br><span class="line">                Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    extensionClasses.put(n, clazz);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate extension "</span> + type.getName() + <span class="string">" name "</span> + n + <span class="string">" on "</span> + c.getName() + <span class="string">" and "</span> + clazz.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码可知，loadClass方法主要就是分类缓存不同扩展实现类，这个过程不涉及扩展实现类的实例化，这也验证了前面的结论，dubbo spi是按需实例化对象。到这里getExtension方法主要过就分析完了，前面也说到该方法是加载扩展实现的完整逻辑，其它的两个入口中的逻辑也会使用上面过程中的部分逻辑，在下面的代码分析中我们可以看到。</p><h5 id="getActivateExtension-方法"><a href="#getActivateExtension-方法" class="headerlink" title="getActivateExtension 方法"></a>getActivateExtension 方法</h5><p>该方法只是根据不同的条件同时激活多个普通扩展实现类，即会做一些通用的判断来筛选是否是激活扩展扩展对象。前面多次提到该法会依赖getExtension方法中的逻辑，下面我就一起来看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得激活条件的扩展实现对象集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url    url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 激活的扩展名数组，可能为空。如：获取dubbo内置的过滤器时，key=service.filter，url中没有对应的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> group  过滤分组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被激活的扩展实现对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.common.extension.Activate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 激活扩展实现对象结果集</span></span><br><span class="line">        List&lt;T&gt; exts = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 激活的扩展名集合</span></span><br><span class="line">        List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">0</span>) : Arrays.asList(values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  判断扩展名集合中是否有 '-default' , 如： &lt;dubbo:service filter="-default"/&gt; 代表移出所有默认的过滤器。注意，names是个空的List是符合条件的</span></span><br><span class="line">        <span class="keyword">if</span> (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取/刷新 扩展点实现类的集合</span></span><br><span class="line">            getExtensionClasses();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 遍历cachedActivates (拓展名 到 <span class="doctag">@Activate</span> 的映射)</span></span><br><span class="line"><span class="comment">             * 1 匹配分组，匹配成功则继续逻辑，否则不处理 加载配置文件时收集到的激活扩展类</span></span><br><span class="line"><span class="comment">             * 2 对激活扩展类进行实例化[初次才会，以后就从缓存中取]</span></span><br><span class="line"><span class="comment">             * 3 判断当前缓存中的激活扩展类是否和传入的激活扩展类冲突，如果有冲突，就忽略缓存中的激活扩展类，以传入的扩展类为主</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扩展名</span></span><br><span class="line">                String name = entry.getKey();</span><br><span class="line">                <span class="comment">// Activate</span></span><br><span class="line">                Activate activate = entry.getValue();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 匹配分组，判断Activate注解的group属性值是否包含当前传入的group，包含就符合分组条件</span></span><br><span class="line">                <span class="keyword">if</span> (isMatchGroup(group, activate.group())) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取扩展名对应的扩展点实现对象</span></span><br><span class="line">                    T ext = getExtension(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 是否忽略 加载配置文件时收集到的激活扩展类</span></span><br><span class="line">                    <span class="keyword">if</span> (!names.contains(name) <span class="comment">// 匹配扩展名</span></span><br><span class="line">                            &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name) <span class="comment">// 如果包含 '-' 表示不激活该扩展实现</span></span><br><span class="line">                            &amp;&amp; isActive(activate, url)) <span class="comment">// 检测URL中是否出现了指定的key</span></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        exts.add(ext);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对扩展对象进行排序（根据注解的before、after、order属性）</span></span><br><span class="line">            Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;T&gt; usrs = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历传入的激活扩展名集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取激活扩展名</span></span><br><span class="line">            String name = names.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否是 移除激活扩展名，如果是就忽略。 如： &lt;dubbo:service filter="-demo"/&gt;，那么此时demo对应的扩展实现就是属于无效的</span></span><br><span class="line">            <span class="keyword">if</span> (!name.startsWith(Constants.REMOVE_VALUE_PREFIX) &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理 自定义的激活扩展配置在默认的激活扩展前面的情况, 如： &lt;dubbo:service filter="demo,default"/&gt;，那么自定义的demo激活扩展就优先默认的激活扩展。主要是exts中的值变化，前面已经处理了默认的激活扩展(加载配置文件时收集到的激活扩展类)</span></span><br><span class="line">                <span class="keyword">if</span> (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!usrs.isEmpty()) &#123;</span><br><span class="line">                        exts.addAll(<span class="number">0</span>, usrs);</span><br><span class="line">                        usrs.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 获得激活扩展实现对象</span></span><br><span class="line">                    T ext = getExtension(name);</span><br><span class="line">                    usrs.add(ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!usrs.isEmpty()) &#123;</span><br><span class="line">            exts.addAll(usrs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exts;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取激活的扩展对象逻辑在代码中已经详细注释说明，获取扩展实现对象还是调用了getExtension方法。该方法主要步骤：</p><ol><li>如果触发获取扩展实现类动作时，会检查缓存，如果缓存中没有，就加载配置文件来刷新扩展实现类集合。</li><li>遍历缓存中的激活集合（这个缓存内容是加载的带有@Activate注解的扩展类信息），根据传入的URL匹配条件筛选出符合激活条件的扩展类实现，然后进行排序操作。</li><li>遍历传入的激活扩展名集合，根据设置的顺序调整扩展点激活顺序，其中default代表的是所有@Activate标注并且配置在配置文件中的扩展实现类</li><li>通过getExtension(name)获取激活扩展名对应的扩展对象并加入结果集合</li><li>返回符合条件的激活类集合</li></ol><h5 id="getAdaptiveExtension-方法"><a href="#getAdaptiveExtension-方法" class="headerlink" title="getAdaptiveExtension 方法"></a>getAdaptiveExtension 方法</h5><p>获取自适应扩展对象的入口，如果获取的自适应扩展类属于固定的，那么该方法相对独立，几乎不依赖getExtension方法的逻辑。如果属于动态生成则内部也会调用getExtension方法。由于该方法会涉及到javassist、动态编译等技术，内容较多且比较复杂，这里不再进行分析，我会单独写一篇文章进行详细说明。下面先给出固定的自适应扩展类和自动生成的自适应扩展类的示例，让胖友们有个概念。</p><p>固定的自适应扩展类，以编译扩展接口为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AdaptiveCompiler. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * 实现Compiler接口，自适应Compiler实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveCompiler</span> <span class="keyword">implements</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认编辑器的拓展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> String DEFAULT_COMPILER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法，设置默认编辑器的拓展名。该方法被 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.config.ApplicationConfig#setCompiler(java.lang.String)&#125;方法调用.</span></span><br><span class="line"><span class="comment">     * 在&lt;dubbo:application compiler=""/&gt; 配置下可触发该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> compiler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultCompiler</span><span class="params">(String compiler)</span> </span>&#123;</span><br><span class="line">        DEFAULT_COMPILER = compiler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123;</span><br><span class="line">        Compiler compiler;</span><br><span class="line">        <span class="comment">// 获得Compiler的ExtensionLoader对象</span></span><br><span class="line">        ExtensionLoader&lt;Compiler&gt; loader = ExtensionLoader.getExtensionLoader(Compiler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 声明 name 变量，引用 DEFAULT_COMPILER 的值，避免下面的值变了</span></span><br><span class="line">        String name = DEFAULT_COMPILER;</span><br><span class="line">        <span class="comment">// 使用设置的拓展名，获得Compiler拓展对象</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            compiler = loader.getExtension(name);</span><br><span class="line">            <span class="comment">// 获得默认的Compiler拓展对象</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            compiler = loader.getDefaultExtension();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用真正的Compiler对象，动态编译代码</span></span><br><span class="line">        <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态生成的自适应扩展类，以ZookeeperTransporter扩展接口为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperTransporter</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">dubbo</span>.<span class="title">remoting</span>.<span class="title">zookeeper</span>.<span class="title">ZookeeperTransporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> com.alibaba.dubbo.remoting.zookeeper.<span class="function">ZookeeperClient <span class="title">connect</span><span class="params">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(<span class="string">"client"</span>, url.getParameter(<span class="string">"transporter"</span>, <span class="string">"curator"</span>));</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter) name from url("</span> + url.toString() + <span class="string">") use keys([client, transporter])"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter extension = (com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter) ExtensionLoader</span><br><span class="line">                .getExtensionLoader(com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">getExtension</span>(<span class="title">extName</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> extension.connect(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="hasExtension-方法"><a href="#hasExtension-方法" class="headerlink" title="hasExtension 方法"></a>hasExtension 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有对应的扩展实现类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 扩展名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 没有name对应的扩展实现类就抛出异常，即最后返回false</span></span><br><span class="line">            <span class="keyword">this</span>.getExtensionClass(name);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码比较简单，根据扩展名判断是否有对应的扩展实现类，之所以单独拿出来介绍是Dubbo的很多流程会用到该方法，有个印象就可以了。</p><h4 id="dubbo-ioc-实现"><a href="#dubbo-ioc-实现" class="headerlink" title="dubbo ioc 实现"></a>dubbo ioc 实现</h4><p>dubbo的ioc实现目前仅支持setter注入，严谨来说，dubbo的ioc实现方式还可以通过构造注入，即Wrapper类的实现。dubbo的setter注入要求是，如果某个扩展类是另外一个扩展点实现类的成员属性，并且拥有对应的setter方法，那么dubbo就会自动注入对应的扩展点实现对象。这个功能在上面创建扩展实现的时候需要用到，当时没有详细说明，下面我们单独来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 依赖注入</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> instance 扩展实现对象 （注意，可能会是一个Wrapper）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 只有ExtensionFactory扩展点对应的ExtensionLoader对象的该属性为null，其它扩展点的ExtensionLoader对象的该属性必然不为null</span></span><br><span class="line">           <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 反射获得扩展实现对象中的所有方法</span></span><br><span class="line">               <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 过滤规则为 ' set开头 + 仅有一个参数 + public ' 的方法</span></span><br><span class="line">                   <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br><span class="line">                           &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                           &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        * 检查方法是否有 <span class="doctag">@DisableInject</span> 注解，有该注解就忽略依赖注入</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                       <span class="keyword">if</span> (method.getAnnotation(DisableInject<span class="class">.<span class="keyword">class</span>) !</span>= <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 获取setter方法参数类型</span></span><br><span class="line">                       Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// 获得属性名，如：setXxx -&gt; xxx</span></span><br><span class="line">                           String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">/**</span></span><br><span class="line"><span class="comment">                            * 通过扩展工厂获得属性值，即 方法参数类型作为扩展点，属性名作为扩展名。</span></span><br><span class="line"><span class="comment">                            * ExtensionFactory的实现有三个,AdaptiveExtensionFactory是对其它两个工厂的管理，getExtension方法的真正调用的是其它两个工厂的方法:</span></span><br><span class="line"><span class="comment">                            *  1）SpringExtensionFactory</span></span><br><span class="line"><span class="comment">                            *   getExtension方法会返回容器中名称为property并且类型为pt的bean对象</span></span><br><span class="line"><span class="comment">                            *  2）SpiExtensionFactory</span></span><br><span class="line"><span class="comment">                            *   getExtension方法会返回类型为pt的自适应拓展对象，因为该方法会校验pt是接口类型并且有<span class="doctag">@SPI</span>注解，然后pt有拓展类的情况下，就会获取pt的自适应拓展对象，property没用到</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                           Object object = objectFactory.getExtension(pt, property);</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// 通过反射设置属性值</span></span><br><span class="line">                           <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               method.invoke(instance, object);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                           logger.error(<span class="string">"fail to inject via method "</span> + method.getName()</span><br><span class="line">                                   + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           logger.error(e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>dubbo的ioc基于setter方法注入依赖的，注入的依赖来源则需要通过扩展工厂提供，接下来我们来分析dubbo的扩展工厂。</p><h5 id="扩展工厂接口"><a href="#扩展工厂接口" class="headerlink" title="扩展工厂接口"></a>扩展工厂接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get extension. 获得扩展对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type object type. 扩展接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name object name. 扩展名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object instance. 扩展实现实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExtensionFactory 扩展工厂，是dubbo的一个扩展点。主要用于获取扩展实现对象所需的依赖，然后完成依赖注入，该接口的uml关系如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/extension-factory.jpg" alt></p><p>由uml图可知，该接口有三个扩展实现类。AdaptiveExtensionFactory是它的自适应实现类，只是用来管理SpiExtensionFactory和SpringExtensionFactory，具体依赖的查找还是由这两个类完成，下面我们分别来分析。</p><h5 id="AdaptiveExtensionFactory-工厂"><a href="#AdaptiveExtensionFactory-工厂" class="headerlink" title="AdaptiveExtensionFactory 工厂"></a>AdaptiveExtensionFactory 工厂</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ExtensionFactory扩展实现对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AdaptiveExtensionFactory也是ExtensionFactory的扩展实现类，只是比较特殊，是自适应扩展类，不同于普通的扩展类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptiveExtensionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;ExtensionFactory&gt; list = <span class="keyword">new</span> ArrayList&lt;ExtensionFactory&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用ExtensionLoader 加载拓展点实现类，getSupportedExtensions() 返回的是ExtensionFactory扩展点实现类对应的扩展名集合</span></span><br><span class="line">        <span class="keyword">for</span> (String name : loader.getSupportedExtensions()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据扩展名获取 ExtensionFactory 的扩展实现对象 并加入缓存中</span></span><br><span class="line">            list.add(loader.getExtension(name));</span><br><span class="line">        &#125;</span><br><span class="line">        factories = Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取目标对象，主要用于 &#123;<span class="doctag">@link</span> ExtensionLoader#injectExtension(java.lang.Object)&#125; 方法中，用于获取扩展实现对象所需要的依赖属性值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type object type. 扩展接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name object name. 扩展名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历扩展工厂对象，获取指定的扩展对象或Spring中的Bean对象</span></span><br><span class="line">        <span class="keyword">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            T extension = factory.getExtension(type, name);</span><br><span class="line">            <span class="keyword">if</span> (extension != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AdaptiveExtensionFactory 自适应扩展工厂，内部维护了一个 ExtensionFactory 列表，用来管理其它的ExtensionFactory。在用户没有自定义ExtensionFactory的情况下，dubbo目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建 <code>自适应的拓展</code>，后者从Spring容器中获取所需依赖。</p><h5 id="SpiExtensionFactory-工厂"><a href="#SpiExtensionFactory-工厂" class="headerlink" title="SpiExtensionFactory 工厂"></a>SpiExtensionFactory 工厂</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取自适应扩展对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type object type. 扩展接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name object name. 扩展名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 校验是接口类型并且有@SPI注解</span></span><br><span class="line">        <span class="keyword">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            <span class="comment">// 加载拓展接口对应的 ExtensionLoader</span></span><br><span class="line">            ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断当前扩展点是否有普通的扩展实现类，注意：当前扩展点存在普通的扩展实现类才会去获取对应的自适应扩展对象</span></span><br><span class="line">            <span class="keyword">if</span> (!loader.getSupportedExtensions().isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 获取自适应扩展对象</span></span><br><span class="line">                <span class="keyword">return</span> loader.getAdaptiveExtension();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SpringExtensionFactory-工厂"><a href="#SpringExtensionFactory-工厂" class="headerlink" title="SpringExtensionFactory 工厂"></a>SpringExtensionFactory 工厂</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SpringExtensionFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashSet&lt;ApplicationContext&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存Spring上下文</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addApplicationContext</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        contexts.add(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeApplicationContext</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        contexts.remove(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// currently for test purpose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearContexts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        contexts.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历SpringContext上下集合</span></span><br><span class="line">        <span class="keyword">for</span> (ApplicationContext context : contexts) &#123;</span><br><span class="line">            <span class="comment">// 判断容器中是否包含名称为name的bean</span></span><br><span class="line">            <span class="keyword">if</span> (context.containsBean(name)) &#123;</span><br><span class="line">                <span class="comment">// 获得bean对象</span></span><br><span class="line">                Object bean = context.getBean(name);</span><br><span class="line">                <span class="comment">// 判断获得的bean类型是否是type类型</span></span><br><span class="line">                <span class="keyword">if</span> (type.isInstance(bean)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (T) bean;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.warn(<span class="string">"No spring extension (bean) named:"</span> + name + <span class="string">", try to find an extension (bean) of type "</span> + type.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span> </span>== type) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ApplicationContext context : contexts) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> context.getBean(type);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoUniqueBeanDefinitionException multiBeanExe) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Find more than 1 spring extensions (beans) of type "</span> + type.getName() + <span class="string">", will stop auto injection. Please make sure you have specified the concrete parameter type and there's only one extension of that type."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException noBeanExe) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Error when get spring extension(bean) for type:"</span> + type.getName(), noBeanExe);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.warn(<span class="string">"No spring extension (bean) named:"</span> + name + <span class="string">", type:"</span> + type.getName() + <span class="string">" found, stop get bean."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo使用spring容器管理的依赖为扩展对象注入依赖属性。dubbo是如何与spring容器打通的呢？有两处结合点，分别是服务暴露和服务引用的时候，利用ApplicationContextAware的回调方法设置spring上下文。</p><ul><li>服务暴露结合点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;<span class="comment">// 当前加载的上下文</span></span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="comment">// 为Spring拓展工厂注入上下文 ,todo dubbo和Spring容器打通</span></span><br><span class="line">        SpringExtensionFactory.addApplicationContext(applicationContext);</span><br><span class="line">        <span class="keyword">if</span> (applicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SPRING_CONTEXT = applicationContext;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method method = applicationContext.getClass().getMethod(<span class="string">"addApplicationListener"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;ApplicationListener<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">// backward compatibility to spring 2.0.1</span></span><br><span class="line">                method.invoke(applicationContext, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">                supportedApplicationListener = <span class="keyword">true</span>; <span class="comment">// 当前Spring容器是否支持上下文监听</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (applicationContext <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Method method = AbstractApplicationContext.class.getDeclaredMethod("addListener", new Class&lt;?&gt;[]&#123;ApplicationListener.class&#125;); // backward compatibility to spring 2.0.1</span><br><span class="line">                        <span class="keyword">if</span> (!method.isAccessible()) &#123;</span><br><span class="line">                            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(applicationContext, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">                        supportedApplicationListener = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务引用结合点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="comment">// dubbo 和 spring容器打通</span></span><br><span class="line">        SpringExtensionFactory.addApplicationContext(applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="dubbo-aop-实现"><a href="#dubbo-aop-实现" class="headerlink" title="dubbo aop 实现"></a>dubbo aop 实现</h4><p>dubbo aop 实现需要Wrapper类，关于Wrapper类前面已经介绍过了，这里不再说明。关于dubbo aop的功能也在前面的流程中体现出来了，单独把dubbo aop拿出来进行说明是考虑到前面的篇幅没有具体到Wrapper类，只是阐述了其功能和实现。实现一个Wrapper类的基本步骤如下：</p><ol><li>定义一个Wrapper类并实现扩展接口，然后编写AOP逻辑。</li><li>在配置文件配置自定义的Wrapper类</li></ol><h5 id="定义-Wrapper类"><a href="#定义-Wrapper类" class="headerlink" title="定义 Wrapper类"></a>定义 Wrapper类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandWrapper</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Command command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法的参数必须是扩展点类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommandWrapper</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"CommandWrapper is running ..."</span>);</span><br><span class="line">        <span class="comment">// 执行扩展实现对象，注意，如果不显示调用扩展实现，那么就达不到目标结果，只会执行这个并没有真正实现的Wrapper</span></span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义Wrapper类很简单，只要按照Wrapper类的要求进行实现即可。需要说明的是，我们所说的Wrapper类其实不强制类名以Wrapper结尾，只要符合Wrapper类的要求就是一个Wrapper类，并不是用名字进行区分是否Wrapper类，只是这样写是dubbo的一种约定罢了。</p><h5 id="配置-Wrapper类"><a href="#配置-Wrapper类" class="headerlink" title="配置 Wrapper类"></a>配置 Wrapper类</h5><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/spi-wrapper.jpg" alt></p><h5 id="dubbo-内置的Wrapper-举例"><a href="#dubbo-内置的Wrapper-举例" class="headerlink" title="dubbo 内置的Wrapper 举例"></a>dubbo 内置的Wrapper 举例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Cluster接口，MockClusterWrapper实现类，注意它是个Wrapper类，对应的Cluster对象都会被它所包装。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockClusterWrapper</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真正的Cluster 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Cluster cluster;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockClusterWrapper</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cluster = cluster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建MockClusterInvoker对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory Directory 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MockClusterInvoker&lt;T&gt;(directory, <span class="keyword">this</span>.cluster.join(directory));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇文章简单介绍了dubbo spi 用法，并对 dubbo spi 的核心源码进行了分析，总体上不算复杂但很繁琐，细节点很多，比如，扩展名生成的规则，扩展类的种类区别，自动激活扩展生效条件。想要掌握整个流程需要耐心调试源码，笔者差点被spi及接下来要分析的dubbo配置给劝退了。另外，由于dubbo spi自适应机制涉及到的代码量较多，逻辑比较复杂，我将会在下一篇文章中单独进行分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;dubbo并未使用jdk标准的SPI机制，而是对其进行了增强，优化了性能问题并且相比jdk spi更加健壮。&lt;/p&gt;
&lt;h3 id=&quot;dub
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="SPI" scheme="https://gentryhuang.com/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>Java SPI</title>
    <link href="https://gentryhuang.com/posts/a9c33b8c/"/>
    <id>https://gentryhuang.com/posts/a9c33b8c/</id>
    <published>2020-03-10T16:00:00.000Z</published>
    <updated>2020-09-03T01:23:40.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SPI概述"><a href="#SPI概述" class="headerlink" title="SPI概述"></a>SPI概述</h3><p>SPI（Service Provider Interface）是JDK内置的一种服务提供发现机制。一个服务(Service)通常指的是已知的接口或者抽象类，服务提供方就是对这个接口或者抽象类的实现，然后按照SPI标准存放到资源路径META-INF/services目录下，文件的命名为该服务接口的全限定名。Java SPI使用了策略模式，一个接口多种实现，我们只声明接口，具体的实现并不在程序中直接确定，而是由配置决定。</p><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p> 服务的提供者的接口，它的多种实现一般会在jar包的META-INF/services 目录下，在这个目录下创建服务提供者接口同名文件，这个文件中就是接口的具体实现类的全限定性类名。而当外部加载这个服务提供功能时，就能通过该jar包META-INF/services/下的配置文件得到具体的实现类名，并加载实例化，完成功能的装配。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>定义接口</li><li>编写接口实现类</li><li>在META-INF/services 目录下创建一个以接口全路径名的文件</li><li>文件内容是接口实现类的全路径名，可以有多个，如果多个需要使用分行符分割</li><li>在代码中使用jdk的ServiceLoader来加载接口的具体实现类</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="服务提供者接口"><a href="#服务提供者接口" class="headerlink" title="服务提供者接口"></a>服务提供者接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.spi;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务提供者实现类"><a href="#服务提供者实现类" class="headerlink" title="服务提供者实现类"></a>服务提供者实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.spi.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start...."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.spi.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"shutdown...."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在META-INF-services下创建-com-alibaba-dubbo-spi-Command文件"><a href="#在META-INF-services下创建-com-alibaba-dubbo-spi-Command文件" class="headerlink" title="在META-INF/services下创建 com.alibaba.dubbo.spi.Command文件"></a>在META-INF/services下创建 com.alibaba.dubbo.spi.Command文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 内容</span><br><span class="line">com.alibaba.dubbo.spi.impl.StartCommand</span><br><span class="line">com.alibaba.dubbo.spi.impl.ShutdownCommand</span><br></pre></td></tr></table></figure><h4 id="加载扩展实现"><a href="#加载扩展实现" class="headerlink" title="加载扩展实现"></a>加载扩展实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ServiceLoader是JDK的，用来加载接口的实现类（通过配置文件加载）</span></span><br><span class="line">        ServiceLoader&lt;Command&gt; serviceLoader = ServiceLoader.load(Command<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (Command command : serviceLoader) &#123;</span><br><span class="line">            <span class="keyword">if</span> (command <span class="keyword">instanceof</span> StartCommand) &#123;</span><br><span class="line">                System.out.println(<span class="string">"判断出是Start："</span> + command.getClass().getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (command <span class="keyword">instanceof</span> ShutdownCommand) &#123;</span><br><span class="line">                System.out.println(<span class="string">"判断出是Shutdown："</span> + command.getClass().getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line">            command.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用jdk的spi的依赖"><a href="#使用jdk的spi的依赖" class="headerlink" title="使用jdk的spi的依赖"></a>使用jdk的spi的依赖</h3><h4 id="mysql驱动"><a href="#mysql驱动" class="headerlink" title="mysql驱动"></a>mysql驱动</h4><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/mysql-spi.jpg" alt></p><h4 id="SpringServletContainer初始化器"><a href="#SpringServletContainer初始化器" class="headerlink" title="SpringServletContainer初始化器"></a>SpringServletContainer初始化器</h4><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/springweb-spi.jpg" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>jdk的spi机制虽然实现了服务发现机制，即在模块装配的时候不在模块中写死代码就能够发现服务，但是存在性能和健壮性问题，具体的问题及解决方案在dubbo spi中说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SPI概述&quot;&gt;&lt;a href=&quot;#SPI概述&quot; class=&quot;headerlink&quot; title=&quot;SPI概述&quot;&gt;&lt;/a&gt;SPI概述&lt;/h3&gt;&lt;p&gt;SPI（Service Provider Interface）是JDK内置的一种服务提供发现机制。一个服务(Serv
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/tags/JDK/"/>
    
      <category term="SPI" scheme="https://gentryhuang.com/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo项目结构总览</title>
    <link href="https://gentryhuang.com/posts/e2577ca1/"/>
    <id>https://gentryhuang.com/posts/e2577ca1/</id>
    <published>2020-03-08T16:00:00.000Z</published>
    <updated>2020-08-15T13:48:14.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>dubbo源码分析相关文章使用的dubbo版本为2.6.5，如使用其它版本会显示说明。参考文档以<a href="http://dubbo.apache.org/zh-cn/index.html" target="_blank" rel="noopener">官方文档</a> 为主【官网文档写的太好了】，参考书籍《深入理解Apache Dubbo与实战》。</p><h3 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h3><p>由于dubbo官方文档写的非常好，这里会大量引用相关的图片及说明，<a href="http://dubbo.apache.org/zh-cn/docs/dev/design.html" target="_blank" rel="noopener">点我</a> 进入官方文档。</p><h4 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h4><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-frame.jpg" alt></p><p><strong>图例说明：</strong></p><ul><li>图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</li><li>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。</li><li>图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。</li><li>图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。</li></ul><h4 id="总体分层"><a href="#总体分层" class="headerlink" title="总体分层"></a>总体分层</h4><p>从整体设计设计图可知悉，dubbo的总体分为业务层(Business)、RPC层、Remote三层，每一层细分共可分成十层。Service和Config两层可以认为是API层，主要提供给API使用者，使用者无须关心底层的实现，只需要配置和完成业务代码即可。其它八层合在一起可以认为是SPI层，用于扩展，即开放者可以基于SPI层自定义一些组件来完成具体业务，也可以基于dubbo框架做定制性的二次开发。</p><h4 id="dubbo核心组件"><a href="#dubbo核心组件" class="headerlink" title="dubbo核心组件"></a>dubbo核心组件</h4><p>dubbo中每层都代表了不同的逻辑实现，它们是一个个组件，这些组件构成了整个dubbo体系。对于使用方来说更多接触到的是配置，按照dubbo配置规则选择适合当前业务的配置项即可轻松实现rpc调用。正是由于dubbo的各个组件职责分明的设计，才使得dubbo框架能够做到高扩展性。dubbo核心组件如下表：</p><table><thead><tr><th align="left">分层名</th><th>作用</th></tr></thead><tbody><tr><td align="left">service</td><td>业务层：包括业务代码的接口与实现，即开放者实现的业务代码。</td></tr><tr><td align="left">config</td><td>配置层：主要围绕ServiceConfig（服务提供方配置）和ReferenceConfig（服务消费方）展开，初始化配置信息。可以理解为该层管理了整个dubbo的配置</td></tr><tr><td align="left">proxy</td><td>服务代理层：在dubbo中，无论提供者还是消费者，框架都会生成一个代理类，整个过程对上层是透明的。当调用一个远程接口时，看起来就像是调用了一个本地接口一样，代理层会自动做远程调用并返回结果，即让业务层对远程调用完全无感知</td></tr><tr><td align="left">registry</td><td>注册中心层：负责dubbo框架的服务注册与发现。当有新的服务加入或旧服务下线时，注册中心都会感知并通知给所有订阅方</td></tr><tr><td align="left">cluster</td><td>集群容错层：提供多种容错策略、封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code> 为中心，扩展接口为 <code>Cluster</code>, <code>Directory</code>, <code>Router</code>, <code>LoadBalance</code>以及<code>Mock</code></td></tr><tr><td align="left">monitor</td><td>监控层：RPC 调用次数和调用时间监控等</td></tr><tr><td align="left">protocol</td><td>远程调用层：封装RPC调用具体过程，以 <code>Invocation</code>, <code>Result</code> 为中心，是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。</td></tr><tr><td align="left">exchange</td><td>信息交换层：建立Request-Response模型，封装请求响应模式，以 <code>Request</code>, <code>Response</code> 为中心</td></tr><tr><td align="left">transport</td><td>网络传输层：把网络传输抽象为统一接口，以 <code>Message</code> 为中心，如Mina和Netty虽然接口不一样，但是Dubbo在它们上面封装了统一的接口。用户可以根据其扩展接口添加更多的网络传输方式。</td></tr><tr><td align="left">serialize</td><td>序列化层：如果数据要通过网络进行传输，则需要先做序列化，转成二进制流。序列化层负责管理整个框架网络传输时的序列化和反序列化工作</td></tr></tbody></table><h4 id="关系说明"><a href="#关系说明" class="headerlink" title="关系说明"></a>关系说明</h4><ul><li><p>在 RPC 中，Protocol 是核心层，也就是<strong>只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用</strong>，然后在 Invoker 的主过程上 Filter 拦截点。</p></li><li><p>图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。</p></li><li><p>而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</p></li><li><p>Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有<strong>到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务</strong>。</p></li><li><p>而<strong>Remoting 实现是 Dubbo 协议的实现</strong>，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</p></li><li><p>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</p></li></ul><h4 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h4><blockquote><p>Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。</p><p>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p><p>Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。</p></blockquote><p><font color="#c7254e">特别说明:</font> protocol是对数据格式的一种约定，它可以把我们对接口的配置，根据具体的协议转换成不同的Invoker对象。</p><h4 id="基本设计原则"><a href="#基本设计原则" class="headerlink" title="基本设计原则"></a>基本设计原则</h4><ul><li>Dubbo 自身的功能也是通过扩展点实现的，也就是 Dubbo 的所有功能点都可被用户自定义扩展所替换</li><li>采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息</li></ul><h4 id="源码分析范围"><a href="#源码分析范围" class="headerlink" title="源码分析范围"></a>源码分析范围</h4><p>除了架构图中的Monitor模块不会详细分析，其它都会详细分析。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>本文主要简单介绍了dubbo的总体架构图和核心组件，这样在阅读源码之前有整体的概念。更详细的介绍可以参考官网文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;dubbo源码分析相关文章使用的dubbo版本为2.6.5，如使用其它版本会显示说明。参考文档以&lt;a href=&quot;http://dubbo.
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="RPC" scheme="https://gentryhuang.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>URL统一模型</title>
    <link href="https://gentryhuang.com/posts/46f95e97/"/>
    <id>https://gentryhuang.com/posts/46f95e97/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-09-04T09:14:17.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="URL-定义"><a href="#URL-定义" class="headerlink" title="URL 定义"></a>URL 定义</h3><p>URL 的全名即统一资源定位符，因特网上的可用资源是使用字符串来表示的，而这些具有特定格式和语义的字符串就是URL</p><p><strong>标准的URL格式:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">组成：协议、账号&#x2F;密码、主机、端口、路径 [大多数url不需要账号&#x2F;密码,需要安全认证的才会需要]</span><br><span class="line">格式：protocol:&#x2F;&#x2F;[username:password@]host:port&#x2F;path?key&#x3D;value&amp;key&#x3D;value</span><br></pre></td></tr></table></figure><h3 id="Dubbo中的-URL"><a href="#Dubbo中的-URL" class="headerlink" title="Dubbo中的 URL"></a>Dubbo中的 URL</h3><p>Dubbo中也使用了类似的 URL，URL 中的每个参数几乎都有各自的用途，它们往往对应着特定的功能或实现。Dubbo中对这个 URL 做了封装，大体上分为主要参数和键值对参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * url 例子:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;http://www.facebook.com/friends?param1=value1&amp;amp;param2=value2</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;http://username:password@10.20.130.230:8080/list?version=1.0.0</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ftp://username:password@192.168.1.7:21/1/read.txt</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;registry://192.168.1.7:9090/com.alibaba.service1?param1=value1&amp;amp;param2=value2</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * 一些特别的url:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;192.168.1.3:20880&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * for this case, url protocol = null, url host = 192.168.1.3, port = 20880, url path = null</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;file:///home/user1/router.js?type=script&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * for this case, url protocol = file, url host = null, url path = home/user1/router.js</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;file://home/user1/router.js?type=script&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * for this case, url protocol = file, url host = home, url path = user1/router.js</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;file:///D:/1/router.js?type=script&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * for this case, url protocol = file, url host = null, url path = D:/1/router.js</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;file:/D:/1/router.js?type=script&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 同上： file:///D:/1/router.js?type=script</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;/home/user1/router.js?type=script &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 对于这些例子： url protocol = null, url host = null, url path = home/user1/router.js</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;home/user1/router.js?type=script &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 对于这些例子： url protocol = null, url host = home, url path = user1/router.js</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.net.URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.net.URI</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">URL</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1985165475234910535L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String protocol;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** by default, host to registry</span></span><br><span class="line"><span class="comment">     * 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** by default, port to registry</span></span><br><span class="line"><span class="comment">     * 端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路径（服务名）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数集合，键值对形式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; parameters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它属性及构造函数</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(String protocol, String username, String password, String host, <span class="keyword">int</span> port, String path, Map&lt;String, String&gt; parameters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((username == <span class="keyword">null</span> || username.length() == <span class="number">0</span>)</span><br><span class="line">                &amp;&amp; password != <span class="keyword">null</span> &amp;&amp; password.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid url, password without username!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = (port &lt; <span class="number">0</span> ? <span class="number">0</span> : port);</span><br><span class="line">        <span class="comment">// trim the beginning "/"</span></span><br><span class="line">        <span class="keyword">while</span> (path != <span class="keyword">null</span> &amp;&amp; path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            path = path.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">if</span> (parameters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(parameters);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.parameters = Collections.unmodifiableMap(parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略其它方法</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dubbo中常见的-URL"><a href="#Dubbo中常见的-URL" class="headerlink" title="Dubbo中常见的 URL"></a>Dubbo中常见的 URL</h4><ul><li><p>Dubbo协议的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo:&#x2F;&#x2F;10.1.22.50:20880&#x2F;com.alibaba.dubbo.demo.DemoService?anyhost&#x3D;true&amp;application&#x3D;demo-provider&amp;bean.name&#x3D;com.alibaba.dubbo.demo.DemoService&amp;bind.ip&#x3D;10.1.14.50&amp;bind.port&#x3D;20880&amp;dubbo&#x3D;2.0.2&amp;generic&#x3D;false&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;qos.port&#x3D;22222&amp;side&#x3D;provider&amp;timestamp&#x3D;1596611769521</span><br></pre></td></tr></table></figure></li><li><p>服务提供者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">provider:&#x2F;&#x2F;10.1.22.50:20880&#x2F;com.alibaba.dubbo.demo.DemoService?anyhost&#x3D;true&amp;application&#x3D;demo-provider&amp;bean.name&#x3D;com.alibaba.dubbo.demo.DemoService&amp;category&#x3D;configurators&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.2&amp;generic&#x3D;false&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;side&#x3D;provider&amp;timestamp&#x3D;1596611769521</span><br></pre></td></tr></table></figure></li><li><p>服务消费者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer:&#x2F;&#x2F;10.1.22.50&#x2F;com.alibaba.dubbo.demo.DemoService?application&#x3D;demo-consumer&amp;category&#x3D;consumers&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.2&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;3363&amp;qos.port&#x3D;33333&amp;side&#x3D;consumer&amp;timestamp&#x3D;1596612621336</span><br></pre></td></tr></table></figure></li><li><p>服务暴露过程临时协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.2&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;qos.port&#x3D;22222&amp;registry&#x3D;zookeeper&amp;timestamp&#x3D;1596611658802</span><br></pre></td></tr></table></figure></li><li><p>zk注册中心</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.2&amp;interface&#x3D;com.alibaba.dubbo.registry.RegistryService&amp;owner&#x3D;gentryhuang&amp;pid&#x3D;3272&amp;qos.port&#x3D;22222&amp;timestamp&#x3D;1596611658802</span><br></pre></td></tr></table></figure><p><font color="#c7254e">说明:</font> 除此之外还有很多类型的 URL ，不同的协议[如：dubbo协议、http协议等]对应不同的URL、不同的角色[如：提供者、消费者、注册中心、路由器等]对应不同的URL、不同的功能流程[如：服务暴露、服务引用、服务路由等]对应不同的URL…这些在后面的源码解析中都有对应。</p></li></ul><h4 id="Dubbo的-URL-统一模型的意义"><a href="#Dubbo的-URL-统一模型的意义" class="headerlink" title="Dubbo的 URL 统一模型的意义"></a>Dubbo的 URL 统一模型的意义</h4><p>Dubbo中的 URL 可以说是Dubbo的配置总线，它贯穿整个Dubbo的生命周期。上下文的信息传递需要 URL 来提供，特定功能的实现需要 URL 的支持[如：所有扩展点参数都包含url参数，url作为上下文信息贯穿整个拓展点体系]。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;URL-定义&quot;&gt;&lt;a href=&quot;#URL-定义&quot; class=&quot;headerlink&quot; title=&quot;URL 定义&quot;&gt;&lt;/a&gt;URL 定义&lt;/h3&gt;&lt;p&gt;URL 的全名即统一资源定位符，因特网上的可用资源是使用字符串来表示的，而这些具有特定格式和语义的字符串就是
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="RPC" scheme="https://gentryhuang.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo示例 - 注解配置</title>
    <link href="https://gentryhuang.com/posts/7202a9c0/"/>
    <id>https://gentryhuang.com/posts/7202a9c0/</id>
    <published>2020-03-05T16:00:00.000Z</published>
    <updated>2020-09-01T12:12:42.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h3><p>使用注解的方式进行配置</p><h4 id="定义服务接口"><a href="#定义服务接口" class="headerlink" title="定义服务接口"></a>定义服务接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.examples.annotation.api;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务提供方"><a href="#服务提供方" class="headerlink" title="服务提供方"></a>服务提供方</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.examples.annotation.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.examples.annotation.api.AnnotationService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationServiceImpl，注意，这里 <span class="doctag">@Service</span> 注解是Dubbo的注解，用来进行服务暴露的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationServiceImpl</span> <span class="keyword">implements</span> <span class="title">AnnotationService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"async provider received: "</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"annotation: hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务提供方属性配置"><a href="#服务提供方属性配置" class="headerlink" title="服务提供方属性配置"></a>服务提供方属性配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># dubbo-provider.properties</span><br><span class="line">dubbo.application.name&#x3D;annotation-provider</span><br><span class="line">dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181</span><br><span class="line">dubbo.protocol.name&#x3D;dubbo</span><br><span class="line">dubbo.protocol.port&#x3D;20880</span><br></pre></td></tr></table></figure><p><font color="#c7254e">说明:</font> 使用dubbo注解形式一般结合属性配置，用来配置应用共享的配置项。</p><h4 id="指定扫描路径，启动容器并暴露服务"><a href="#指定扫描路径，启动容器并暴露服务" class="headerlink" title="指定扫描路径，启动容器并暴露服务"></a>指定扫描路径，启动容器并暴露服务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.examples.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProviderConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationProvider</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Java Config + 注解的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"com.alibaba.dubbo.examples.annotation.impl"</span>)</span><br><span class="line">    <span class="meta">@PropertySource</span>(<span class="string">"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-provider.properties"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里通过Java Config显示组装出Bean，会注入给Dubbo服务，即标注有<span class="doctag">@Service</span>的类。如果不显示装配，Dubbo会默认创建内置的配置类定义，创建内置的配置类定义的前提是配置了相关的属性，否则不会创建。其他配置类似。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ProviderConfig <span class="title">providerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ProviderConfig providerConfig = <span class="keyword">new</span> ProviderConfig();</span><br><span class="line">            providerConfig.setTimeout(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> providerConfig;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.examples.annotation.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.examples.annotation.api.AnnotationService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationAction，注意，<span class="doctag">@Reference</span>注解用来引用服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"annotationAction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务消费方属性配置"><a href="#服务消费方属性配置" class="headerlink" title="服务消费方属性配置"></a>服务消费方属性配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># dubbo-consumer.properties</span><br><span class="line">dubbo.application.name&#x3D;annotation-consumer</span><br><span class="line">dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181</span><br><span class="line">dubbo.consumer.timeout&#x3D;3000</span><br></pre></td></tr></table></figure><p><font color="#c7254e">说明:</font> 使用dubbo注解形式一般结合属性配置，用来配置应用共享的配置项。</p><h4 id="扫描路径，启动容器并调用服务"><a href="#扫描路径，启动容器并调用服务" class="headerlink" title="扫描路径，启动容器并调用服务"></a>扫描路径，启动容器并调用服务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.examples.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.examples.annotation.action.AnnotationAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationConsumer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConsumerConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        context.start();</span><br><span class="line">        <span class="keyword">final</span> AnnotationAction annotationAction = (AnnotationAction) context.getBean(<span class="string">"annotationAction"</span>);</span><br><span class="line">        String hello = annotationAction.doSayHello(<span class="string">"world"</span>);</span><br><span class="line">        System.out.println(<span class="string">"result :"</span> + hello);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"com.alibaba.dubbo.examples.annotation.action"</span>)</span><br><span class="line">    <span class="meta">@PropertySource</span>(<span class="string">"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-consumer.properties"</span>)</span><br><span class="line">    <span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"com.alibaba.dubbo.examples.annotation.action"</span>&#125;)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里通过Java Config显示组装出Bean，会注入给Dubbo服务，即标注有<span class="doctag">@Reference</span>的类。如果不显示装配，Dubbo会默认创建内置的配置类定义，创建内置的配置类定义的前提是配置了相关的属性，否则不会创建。其他配置类似。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumerConfig <span class="title">consumerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ConsumerConfig consumerConfig = <span class="keyword">new</span> ConsumerConfig();</span><br><span class="line">            consumerConfig.setTimeout(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> consumerConfig;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>注解实现使代码更整洁，开发效率更高，随着注解和配置化的盛行，xml的方式会渐渐地淡出舞台。但使用注解对开放者的要求更高，具体的dubbo注解如何与Spring融合，在后面的章节中会进行说明。使用注解的方式，配置对象的创建及配置对象属性设置也都是Spring完成的，注意这里Spring完成配置属性地设置是指启动加载的配置属性，如上面例子中的@PropertySource注解引入的配置文件内容，此外@Service、@Reference注解中的属性Spring会自动绑定到配置对象中，至于系统参数、dubbo.properties中的配置参数等是dubbo框架自动加载并配置的，我们可在服务暴露和服务引用中看到具体的过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;快速启动&quot;&gt;&lt;a href=&quot;#快速启动&quot; class=&quot;headerlink&quot; title=&quot;快速启动&quot;&gt;&lt;/a&gt;快速启动&lt;/h3&gt;&lt;p&gt;使用注解的方式进行配置&lt;/p&gt;
&lt;h4 id=&quot;定义服务接口&quot;&gt;&lt;a href=&quot;#定义服务接口&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="RPC" scheme="https://gentryhuang.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo示例 - XML配置</title>
    <link href="https://gentryhuang.com/posts/3f1c0a92/"/>
    <id>https://gentryhuang.com/posts/3f1c0a92/</id>
    <published>2020-03-03T16:00:00.000Z</published>
    <updated>2020-08-15T15:30:22.534Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h3><p>使用xml的方式进行配置，详细配置项：<a href="http://dubbo.apache.org/zh-cn/docs/user/references/xml/introduction.html" target="_blank" rel="noopener">配置参考手册</a></p><h4 id="定义服务接口"><a href="#定义服务接口" class="headerlink" title="定义服务接口"></a>定义服务接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务提供方实现接口"><a href="#服务提供方实现接口" class="headerlink" title="服务提供方实现接口"></a>服务提供方实现接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.rpc.RpcContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"["</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()) + <span class="string">"] Hello "</span> + name + <span class="string">", request from consumer: "</span> + RpcContext.getContext().getRemoteAddress());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">", response from provider: "</span> + RpcContext.getContext().getLocalAddress();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务提供方服务暴露配置"><a href="#服务提供方服务暴露配置" class="headerlink" title="服务提供方服务暴露配置"></a>服务提供方服务暴露配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span> <span class="attr">owner</span>=<span class="string">"gentryhuang"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.dubbo.demo.provider.DemoServiceImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="启动Spring容器，进行服务暴露"><a href="#启动Spring容器，进行服务暴露" class="headerlink" title="启动Spring容器，进行服务暴露"></a>启动Spring容器，进行服务暴露</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"META-INF/spring/dubbo-demo-provider.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line"></span><br><span class="line">        System.in.read(); <span class="comment">// press any key to exit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务消费者引用服务配置"><a href="#服务消费者引用服务配置" class="headerlink" title="服务消费者引用服务配置"></a>服务消费者引用服务配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用zookeeper注册中心暴露发现服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="加载Spring配置，并调用远程服务"><a href="#加载Spring配置，并调用远程服务" class="headerlink" title="加载Spring配置，并调用远程服务"></a>加载Spring配置，并调用远程服务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"META-INF/spring/dubbo-demo-consumer.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        DemoService demoService = (DemoService) context.getBean(<span class="string">"demoService"</span>); <span class="comment">// get remote service proxy</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                String hello = demoService.sayHello(<span class="string">"world"</span>); <span class="comment">// call remote method</span></span><br><span class="line">                System.out.println(hello); <span class="comment">// get result</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>dubbo自定义了很多的xml标签，这些标签就对应了API配置中的配置对象，标签的属性就对应配置对象的属性，API的方式是手动创建配置对象并设置属性值，xml的方式是创建配置对象和设置属性值都交给Spring来完成，注意DubboBeanDefinitionParser设置的属性值不包括系统参数、dubbo.properties等，而是xml中配置对象的属性。这些标签是怎么和pring融合的在<a href="https://gentryhuang.com/posts/eee3e639/">spring自定义标签</a>中已经介绍了实现原理，在后面的dubbo配置解析中会继续说明。更多的配置请参考：<a href="http://dubbo.apache.org/zh-cn/docs/user/references/xml/introduction.html" target="_blank" rel="noopener">配置参考手册</a>。下一篇文章中我们介绍使用注解的方式进行配置,这种方式更简洁，效率更高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;快速启动&quot;&gt;&lt;a href=&quot;#快速启动&quot; class=&quot;headerlink&quot; title=&quot;快速启动&quot;&gt;&lt;/a&gt;快速启动&lt;/h3&gt;&lt;p&gt;使用xml的方式进行配置，详细配置项：&lt;a href=&quot;http://dubbo.apache.org/zh-cn/docs
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="RPC" scheme="https://gentryhuang.com/tags/RPC/"/>
    
  </entry>
  
</feed>
