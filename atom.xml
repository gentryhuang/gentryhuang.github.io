<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gentryhuang‘s blog</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gentryhuang.com/"/>
  <updated>2022-03-01T14:31:31.295Z</updated>
  <id>https://gentryhuang.com/</id>
  
  <author>
    <name>gentryhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis原理 - SCAN 原理</title>
    <link href="https://gentryhuang.com/posts/c1861d8c/"/>
    <id>https://gentryhuang.com/posts/c1861d8c/</id>
    <published>2022-03-01T14:14:47.000Z</published>
    <updated>2022-03-01T14:31:31.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SCAN 命令在 Redis 早期版本中就支持，主要是为了解决 Redis 去批量获取 key 时造成的阻塞情况。如 KEYS 命令是获取所有命令，这是一种阻塞操作，这里就可以使用 SCAN 命令来尽可能避免 Redis 的阻塞。</p><p>SCAN 命令的复杂度虽然是 O(N)，但它是分次进行的，不会阻塞线程。</p><h2 id="SCAN-命令集"><a href="#SCAN-命令集" class="headerlink" title="SCAN 命令集"></a>SCAN 命令集</h2><p>SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令<strong>都用于增量地迭代集合类元素</strong>。</p><ul><li>SCAN 命令用于迭代当前数据库中的数据库键；</li><li>SSCAN 命令用于迭代集合键中的元素；</li><li>HSCAN 命令用于迭代哈希键中的键值对；</li><li>ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）;</li></ul><p>以上列出的四个命令都支持<strong>增量式迭代</strong>， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题。当 KEYS 命令被用于处理一个大的数据库时，又或者 SMEMBERS 命令被用于处理一个大的集合键时，它们可能会阻塞服务器达数秒之久。</p><p>不过，增量式迭代命令也有很大的缺点，比如在对键进行增量式迭代的过程中，键可能会被修改；字典在进行 rehash 时，缩容的情况会造成重复读取数据；在增量迭代过程，如果增加或删除元素在一定程度上也会导致问题（如果把增量迭代看作完整的过程）。所以增量式迭代命令只能对被返回的元素提供有限的保证。</p><h2 id="SCAN-命令的基本用法"><a href="#SCAN-命令的基本用法" class="headerlink" title="SCAN 命令的基本用法"></a>SCAN 命令的基本用法</h2><p> SCAN 、 SSCAN 、 HSCAN 和 ZSCAN 四个命令的工作方式都非常相似，它们的区别如下：</p><ul><li>SSCAN 命令、 HSCAN 命令和 ZSCAN 命令的第一个参数总是一个数据库键；</li><li>SCAN 命令则不需要在第一个参数提供任何数据库键 —— 因为它迭代的是当前数据库中的所有数据库键。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> SCAN 命令</span></span><br><span class="line">127.0.0.1:6379&gt; SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]</span><br><span class="line"><span class="meta">#</span><span class="bash"> SSCAN 命令</span></span><br><span class="line">127.0.0.1:6379&gt; SSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><p>SCAN 命令是一个基于游标的迭代器，也就是 SCAN 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。</p><p>当 SCAN 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>以下是一个 SCAN 命令的迭代过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) "17"</span><br><span class="line">2)  1) "key:12"</span><br><span class="line">    2) "key:8"</span><br><span class="line">    3) "key:4"</span><br><span class="line">    4) "key:14"</span><br><span class="line">    5) "key:16"</span><br><span class="line">    6) "key:17"</span><br><span class="line">    7) "key:15"</span><br><span class="line">    8) "key:10"</span><br><span class="line">    9) "key:3"</span><br><span class="line">    10) "key:7"</span><br><span class="line">    11) "key:1"</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 17</span><br><span class="line">1) "0"</span><br><span class="line">2) 1) "key:5"</span><br><span class="line">   2) "key:18"</span><br><span class="line">   3) "key:0"</span><br><span class="line">   4) "key:2"</span><br><span class="line">   5) "key:19"</span><br><span class="line">   6) "key:13"</span><br><span class="line">   7) "key:6"</span><br><span class="line">   8) "key:9"</span><br><span class="line">   9) "key:11"</span><br></pre></td></tr></table></figure><p>从上面的示例可以看到， SCAN 命令的回复是一个包含两个元素的数组， 第一个数组元素是用于进行下一次迭代的新游标， 而第二个数组元素则是一个数组， 这个数组中包含了所有被迭代的元素。</p><p>在第二次调用 SCAN 命令时， 命令返回了游标 0 ， 这表示迭代已经结束， 整个数据集已经被完整遍历过了。以 0 作为游标开始一次新的迭代， 一直调用 SCAN 命令， 直到命令返回游标 0 ， 我们称这个过程为一次完整遍历。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>SCAN 命令、 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都返回一个包含两个元素的 multi-bulk 回复： </p><ul><li>回复的第一个元素是字符串表示的无符号 64 位整数（游标）</li><li>回复的第二个元素是另一个 multi-bulk 回复， 这个 multi-bulk 回复包含了本次被迭代的元素。</li></ul><p>SCAN 命令返回的每个元素都是一个数据库键。</p><p>SSCAN 命令返回的每个元素都是一个集合成员。</p><p>HSCAN 命令返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。</p><p>ZSCAN 命令返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。</p><h3 id="SCAN-选项"><a href="#SCAN-选项" class="headerlink" title="SCAN 选项"></a>SCAN 选项</h3><h4 id="COUNT-选项"><a href="#COUNT-选项" class="headerlink" title="COUNT 选项"></a>COUNT 选项</h4><p>虽然增量式迭代命令不保证每次迭代所返回的元素数量， 但我们可以使用 <code>COUNT</code> 选项， 对命令的行为进行一定程度上的调整。 <code>COUNT</code> 选项的作用就是让用户告知迭代命令， 在每次迭代中应该从数据集里返回多少元素。注意， <code>COUNT</code> 选项只是对增量式迭代命令的一种提示，它只是一个参考值，因为 Redis 扫描数据是以哈希桶为单位的。</p><ul><li><code>COUNT</code> 参数的默认值为 <code>10</code> ；</li><li>在迭代一个足够大的、由哈希表实现的数据库、集合键、哈希键或者有序集合键时， 如果用户没有使用 <code>MATCH</code> 选项， 那么命令返回的元素数量通常和 <code>COUNT</code> 选项指定的一样， 或者比 <code>COUNT</code> 选项指定的数量稍多一些。</li><li>在迭代一个编码为整数集合（intset，一个只由整数值构成的小集合）、 或者编码为压缩列表（ziplist，由不同值构成的一个小哈希或者一个小有序集合）时， 增量式迭代命令通常会无视 <code>COUNT</code> 选项指定的值， 在第一次迭代就将数据集包含的<strong>所有元素</strong>都返回给用户。</li></ul><h4 id="MATCH-选项"><a href="#MATCH-选项" class="headerlink" title="MATCH 选项"></a>MATCH 选项</h4><p>和<code>keys</code>命令一样， 增量式迭代命令也可以通过提供一个 glob 风格的模式参数， 让命令只返回和给定模式相匹配的元素， 这一点可以通过在执行增量式迭代命令时， 通过给定 <code>MATCH &lt;pattern&gt;</code> 参数来实现。</p><p>需要注意的是， 对元素的模式匹配工作是在命令从数据集中取出元素之后， 向客户端返回元素之前的这段时间内进行的， 所以如果被迭代的数据集中只有少量元素和模式相匹配， 那么迭代命令或许会在多次执行中都不返回任何元素。</p><h3 id="SCAN-命令的保证"><a href="#SCAN-命令的保证" class="headerlink" title="SCAN 命令的保证"></a>SCAN 命令的保证</h3><p>SCAN 命令， 以及其他增量式迭代命令， 在进行完整遍历的情况下可以为用户带来以下保证： 从完整遍历开始直到完整遍历结束期间， 一直存在于数据集内的所有元素都会被完整遍历返回； 这意味着， 如果有一个元素， 它从遍历开始直到遍历结束期间都存在于被遍历的数据集当中， 那么 SCAN 命令总会在某次迭代中将这个元素返回给用户。</p><p>然而因为增量式命令<strong>仅仅使用游标来记录迭代状态</strong>， 所以这些命令带有以下缺点：</p><ul><li>同一个元素可能会被返回多次。 处理重复元素的工作交由应用程序负责， 比如说， 可以考虑将迭代返回的元素仅仅用于可以安全地重复执行多次的操作上。</li><li>如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回， 也可能不会。</li></ul><p>因为迭代的所有状态都保存在游标里面， 而服务器无须为迭代保存任何状态， 所以客户端可以在中途停止一个迭代， 而无须对服务器进行任何通知。</p><p>使用间断的（broken）、负数、超出范围或者其他非正常的游标来执行增量式迭代并不会造成服务器崩溃， 但可能会让命令产生未定义的行为。未定义行为指的是， 增量式命令对返回值所做的保证可能会不再为真。只有两种游标是合法的：</p><ol><li>在开始一个新的迭代时， 游标必须为 <code>0</code> 。</li><li>增量式迭代命令在执行之后返回的， 用于延续（continue）迭代过程的游标。</li></ol><h3 id="SCAN-原理"><a href="#SCAN-原理" class="headerlink" title="SCAN 原理"></a>SCAN 原理</h3><p>Redis 使用了 Hash 表作为底层实现：</p><p><img src="/posts/c1861d8c/redis-practice-53.png" alt></p><p>SCAN 命令就是对这个一维数组进行遍历，每次返回的游标值也都是这个数组的索引。如果不考虑字典的扩容缩容，直接按数组下标挨个遍历就行了。COUNT 参数表示遍历数据的数量，该值只是起到一个大致约束的作用，所以返回的结果取决于索引下挂接链表的长度，有些槽位可能是空的，还有些槽位上挂接的链表上的元素可能会有多个。</p><p>如果不考虑扩容与缩容，那么无论是从前遍历还是从后遍历都可以获取所有的key值。但是有扩容、缩容后就需要考虑遍历的<strong>准确性</strong>，是否存在重复遍历，是否存在遗漏的遍历。如果我们<strong>按照低位加法，即从前向后遍历</strong>，当扩容或者缩容时进行的rehash操作使得<strong>数据分散到不同的槽位，这就有可能发生重复遍历与遗漏遍历的情况</strong>。</p><p>因此，Redis 采用了<strong>高位加法进位</strong>计算游标的方式遍历集合，Redis 的 SCAN 命令遍历流程如下图：</p><p><img src="/posts/c1861d8c/redis-practice-54.png" alt></p><p>观察这张图，我们发现<strong>采用高位加法进位计算游标的遍历顺序，rehash 时游标指向的槽位在遍历顺序上是相邻的</strong>。这得益于 Redis rehash 机制:</p><ul><li>扩容时：原来属于 <code>1xx</code>槽位的所有元素分散到 <code>01xx</code>和 <code>11xx</code>槽位中，其中前者是原数组的槽位，后者是扩容的新数组的槽位；</li><li>缩容时：<code>1xx</code>槽位的所有元素由 <code>01xx</code>和11<code>xx</code>槽位中元素融合；</li></ul><p>假设当前即将要遍历 110 这个槽位 (橙色)，那么扩容发生时，当前槽位上所有的元素分散在槽位 0110 和 1110(深绿色)中，也就是在槽位的二进制数增加一个高位 0 或 1，其中 1110 就是通过<strong>高位加法进位</strong>算出的下个要扫描的槽位，该槽位对应了扩容的新数组的位置。这时我们可以直接从 0110 这个槽位开始往后继续遍历，0110 槽位之前的所有槽位都是已经遍历过的，这样就可以避免扩容后对已经遍历过的槽位进行重复遍历。注意，主线程在 <code>SCAN</code> 和 rehash 时只能进行一个。</p><p>再考虑缩容，假设当前即将要遍历 110 这个槽位 (橙色)，那么缩容时，当前槽位所有的元素分散在槽位 10(深绿色)和 110(橙色)中，其中槽位 10 也就是去掉槽位二进制最高位，这是通过<strong>高位加法进位</strong>算出的，该槽位对应了缩容的新数组的位置。这时我们可以直接从 10 这个槽位继续往后遍历，10 槽位之前的所有槽位都是已经遍历过的，但图中 010 这个槽位上的元素已经被遍历过了。可以理解为，对于遍历来说，缩容后 10 槽位的元素是 010 和 110 上挂接的元素的融合。</p><p>在使用SCAN命令时，<strong>不会漏key，但可能会得到重复的key，这主要和Redis的rehash机制有关</strong>。Redis的所有key存在一个全局的哈希表中，如果存入的key慢慢变多，在达到一定阈值后，为了避免哈希冲突导致查询效率降低，这个哈希表会进行扩容。与之对应的，key数量逐渐变少时，这个哈希表会缩容以节省空间。</p><ul><li>为什么不会漏 key：Redis在SCAN遍历全局哈希表时，采用<strong>高位加法进位</strong>的方式遍历哈希桶，当哈希表扩容后，通过这种算法遍历，旧哈希表中的数据映射到新哈希表，<strong>依旧会保留原来的先后顺序</strong>，这样就可以保证遍历时不会遗漏也不会重复。</li><li>为什么会得到重复的key：这个情况主要发生在哈希表缩容。已经遍历过的哈希桶在缩容时，可能会映射到新哈希表没有遍历到的位置，所以继续遍历就会对同一个key返回多次。</li></ul><p>SCAN是遍历整个实例的所有key，另外Redis针对Hash/Set/Sorted Set也提供了HSCAN/SSCAN/ZSCAN命令，用于遍历一个key中的所有元素，建议在获取一个bigkey的所有数据时使用，避免发生阻塞风险。</p><p>Hash/Set/Sorted Set元素数量比较少时，底层会采用intset/ziplist方式存储，如果以这种方式存储，在执行HSCAN/SSCAN/ZSCAN命令时，会无视count参数，直接把所有元素一次性返回。</p><p>在分片集群场景下 SCAN 命令是无法跨节点扫描的，只能是一个节点一个节点的进行扫描。</p><h3 id="SCAN-源码分析"><a href="#SCAN-源码分析" class="headerlink" title="SCAN 源码分析"></a>SCAN 源码分析</h3><p>Redis 对 SCAN 命令集处理的底层函数是 <code>scanGenericCommand</code> 。下面我们对该函数处理的主要过程进行说明。</p><h4 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// 默认是 10</span></span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">10</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 输入类型检查，必须针对 集合类型或者数据库</span></span><br><span class="line">    serverAssert(o == <span class="literal">NULL</span> || o-&gt;type == OBJ_SET || o-&gt;type == OBJ_HASH ||</span><br><span class="line">                 o-&gt;type == OBJ_ZSET);</span><br><span class="line">    <span class="comment">// 设置第一个选项参数的索引位置</span></span><br><span class="line">    <span class="comment">// 0    1      2      3</span></span><br><span class="line">    <span class="comment">// SCAN OPTION &lt;op_arg&gt;         SCAN 命令的选项值从索引 2 开始</span></span><br><span class="line">    <span class="comment">// HSCAN &lt;key&gt; OPTION &lt;op_arg&gt;  而其他 *SCAN 命令的选项值从索引 3 开</span></span><br><span class="line">    i = (o == <span class="literal">NULL</span>) ? <span class="number">2</span> : <span class="number">3</span>; <span class="comment">/* Skip the key argument if needed. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 解析参数</span></span><br><span class="line">    <span class="comment">// 如 zscan key cursor [MATCH pattern] [COUNT count]</span></span><br><span class="line">    <span class="comment">// 如 scan cursor [MATCH pattern] [COUNT count] [TYPE type]</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; c-&gt;argc) &#123;</span><br><span class="line">        j = c-&gt;argc - i;</span><br><span class="line">        <span class="comment">// 1.1 todo COUNT count 参数，指定了扫描哈希桶的个数</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">"count"</span>) &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 1.2 MATCH pattern 参数，指定 key 的匹配模式</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">"match"</span>) &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 1.3 特定类型参数 type ，只能用于 scan DB，也就是 scan 命令，不像 zscan 这种</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">"type"</span>) &amp;&amp; o == <span class="literal">NULL</span> &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 1.4 error 参数项无法识别</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyErrorObject(c, shared.syntaxerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给定了对象 o ，那么它必须是一个哈希对象或者集合对象，如果 o 为 NULL 的话，函数将使用当前数据库作为迭代对象。</p><h4 id="判断要扫描的是否是哈希表"><a href="#判断要扫描的是否是哈希表" class="headerlink" title="判断要扫描的是否是哈希表"></a>判断要扫描的是否是哈希表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/* Handle the case of a hash table. */</span></span><br><span class="line">    <span class="comment">// 处理哈希表的情况</span></span><br><span class="line">    ht = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 扫描数据库</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ht = c-&gt;db-&gt;dict;</span><br><span class="line">        <span class="comment">// set 数据类型，使用哈希表编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET &amp;&amp; o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        ht = o-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash 数据类型，使用哈希表编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH &amp;&amp; o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        ht = o-&gt;ptr;</span><br><span class="line">        count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// zset 数据类型，非压缩编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_ZSET &amp;&amp; o-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = o-&gt;ptr;</span><br><span class="line">        ht = zs-&gt;dict;</span><br><span class="line">        count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line">    &#125;  </span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断要扫描的集合，是否使用内存紧凑型结构。如果对象的底层实现为 ziplist 、intset 而不是哈希表，那么这些对象通常都只包含了少量元素， 因此，为了避免服务器记录迭代状态，我们将 ziplist 或者 intset 里面的所有元素都一次返回给调用者，无视 count 参数，并向调用者返回游标 cursor 0 。</p><h4 id="扫描哈希表"><a href="#扫描哈希表" class="headerlink" title="扫描哈希表"></a>扫描哈希表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"> <span class="comment">// 3.1 哈希表编码情况</span></span><br><span class="line">    <span class="keyword">if</span> (ht) &#123;</span><br><span class="line">        <span class="keyword">void</span> *privdata[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 我们将最大迭代次数设置为指定 COUNT 的 10 倍，因此如果哈希表处于病态状态（非常稀疏），我们可以避免以不返回或返回很少元素为代价而阻塞太多时间。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> maxiterations = count * <span class="number">10</span>;</span><br><span class="line">        privdata[<span class="number">0</span>] = keys;</span><br><span class="line">        privdata[<span class="number">1</span>] = o;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描约 count 数量的数据</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 返回下次扫描的游标</span></span><br><span class="line">            <span class="built_in">cursor</span> = dictScan(ht, <span class="built_in">cursor</span>, scanCallback, <span class="literal">NULL</span>, privdata);</span><br><span class="line">                <span class="comment">// 游标不为 0</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">cursor</span> &amp;&amp; </span><br><span class="line">                 <span class="comment">// 递减迭代次数</span></span><br><span class="line">                 maxiterations-- &amp;&amp; </span><br><span class="line">      <span class="comment">// 扫描数据量达到指定的 count (一般都会大于 count ，因此扫描是以一个桶为单位）。一个桶不够，会扫描多个桶来凑count 大小</span></span><br><span class="line">                 listLength(keys) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) count); </span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果 SCAN 操作的数据结构是哈希表，那么就会采用<strong>高位加法进位的方式遍历哈希表</strong>，具体实现在 <code>dictScan</code>函数中。从以上代码可以看出：</p><ul><li>COUNT 参数项起到大致约束作用，告知 Redis 大约扫描 count 个数据；</li><li>这里设置了最大扫描哈希桶（槽位）的数量为 10*count ，目的是防止遇到过多空的哈希桶，一直达不到 count 的条件阻塞主线程；</li></ul><h5 id="高位加法进位遍历"><a href="#高位加法进位遍历" class="headerlink" title="高位加法进位遍历"></a>高位加法进位遍历</h5><p>由于 Redis 使用的是渐进式 rehash 机制，因此当 SCAN 命令执行时处于 rehash 阶段，就需要同时扫描新表和旧表，然后将结果返回客户端。</p><h6 id="未处于-rehash-过程"><a href="#未处于-rehash-过程" class="headerlink" title="未处于 rehash 过程"></a>未处于 rehash 过程</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v, <span class="comment">// 游标</span></span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanBucketFunction *bucketfn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span> </span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de, *next;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 跳过空字典</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 没有处于迁移过程，迭代只有一个哈希表的字典</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="comment">// 指向哈希表</span></span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 记录哈希表的 mask</span></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向游标 v 对应的哈希桶</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果游标 v 对应的哈希桶非空，则遍历游标 v 对应桶中的所有节点</span></span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        v |= ~m0;</span><br><span class="line">        <span class="comment">// 1）倒置游标 v</span></span><br><span class="line">        v = rev(v);</span><br><span class="line">        <span class="comment">// 2）加 1</span></span><br><span class="line">        v++;</span><br><span class="line">        <span class="comment">// 3）倒置加1后的游标 v</span></span><br><span class="line">        v = rev(v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 正在迁移中，需要迭代两个哈希表</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 返回的游标是使用高位进位加法实现的</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据游标定位到哈希桶后，处理完后会紧接着计算下次使用的游标，而计算方法就是 <strong>高位加法进位</strong>。</p><p>下面举例进行说明：</p><p>假设当前哈希表有 4 个桶，也就是默认桶数量，使用 SCAN 命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCAN 0 MATCH * COUNT 1</span><br></pre></td></tr></table></figure><p>按照正规的操作步骤，假设得到一个完整的桶迭代顺序如下：</p><blockquote><p>0-&gt;2-&gt;1-&gt;3 ，转换成二进制为：00-&gt;10-&gt;01-&gt;11</p></blockquote><p>我们发现每次这个序列变化是，<strong>将游标倒置 -&gt; 加 1 -&gt; 再倒置</strong>。</p><p>要知道，普通二进制的加法，是从右往左相加、进位。而这个序列是从左往右相加、进位的。代码体现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1）倒置游标 v</span></span><br><span class="line">v = rev(v);</span><br><span class="line"><span class="comment">// 2）加 1</span></span><br><span class="line">v++;</span><br><span class="line"><span class="comment">// 3）倒置加1后的游标 v</span></span><br><span class="line">v = rev(v);</span><br></pre></td></tr></table></figure><h6 id="处于-rehash-过程"><a href="#处于-rehash-过程" class="headerlink" title="处于 rehash 过程"></a>处于 rehash 过程</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v, <span class="comment">// 游标</span></span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanBucketFunction *bucketfn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span> </span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de, *next;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 跳过空字典</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">        <span class="comment">// 3 正在迁移中，需要迭代两个哈希表</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 3.1 指向两个哈希表，即 0 号和 1 号哈希表</span></span><br><span class="line">        t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 确保 t0 比 t1 要小，即把字典中的两个哈希表较小的赋值给 t0</span></span><br><span class="line">        <span class="comment">// todo 这个是必须的，因为可能是扩容，也可能缩容。遍历顺序是先小表，再到表。</span></span><br><span class="line">        <span class="comment">// 扩容：小的是原哈希表</span></span><br><span class="line">        <span class="comment">// 缩容：小的是新哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (t0-&gt;<span class="built_in">size</span> &gt; t1-&gt;<span class="built_in">size</span>) &#123;</span><br><span class="line">            t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.3 记录两个哈希表的掩码</span></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line">        m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 注意，rehash 的单位是哈希桶，因此数据要么在 3.3 中取到，要在 3.4 中取到 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.3 迭代 t0哈希表</span></span><br><span class="line">        <span class="comment">// 根据游标 v 定位到桶，并迭代桶中的所有节点</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.4 迭代 t1 哈希表</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">            <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t1-&gt;table[v &amp; m1]);</span><br><span class="line">            <span class="comment">// 根据游标 v 定位到桶，并迭代桶中的所有节点</span></span><br><span class="line">            de = t1-&gt;table[v &amp; m1];</span><br><span class="line">            <span class="keyword">while</span> (de) &#123;</span><br><span class="line">                next = de-&gt;next;</span><br><span class="line">                fn(privdata, de);</span><br><span class="line">                de = next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment the reverse cursor not covered by the smaller mask.*/</span></span><br><span class="line">            v |= ~m1;</span><br><span class="line">            v = rev(v);</span><br><span class="line">            v++;</span><br><span class="line">            v = rev(v);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 当掩码差异覆盖的位不为零时继续</span></span><br><span class="line">            <span class="comment">// ^ 按位异或</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回的游标是使用高位进位加法实现的</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SCAN 命令处于 rehash 过程需要同时扫描新表和旧表，虽然扩容和缩容的情况使用的是同一套流程，但是意义上是不同的。下面对关键流程进行总结：</p><ol><li><p>根据字典中的两个哈希表的大小排序，将小的哈希表赋值给 t0，将大的哈希表赋值给 t1；</p></li><li><p>分别记录 t0、t1 的掩码值，用于后续根据游标计算桶的索引；</p></li><li><p>根据索引先后迭代 t0表、t1表；</p></li></ol><p>把 SCAN 扫描图再拿过来：</p><p><img src="/posts/c1861d8c/redis-practice-54.png" alt></p><p><strong>对于扩容来说，t0 是原数组，t1 是新数组：</strong></p><p>在读取游标 v 110 对应的槽位前，哈希表扩容了，此时原数组 t0 数组的 110 槽位的数据可能还在，也可能已经迁移到了新数组 t1 1110 槽位中。此时，SCAN 顺序是先 t0 的 110 槽位，再 t1 的 1110 槽位。可以看到，通过<strong>高位加法进位</strong>遍历，依旧会保留原来的先后顺序，这种情况可以保证遍历时不会遗漏也不会重复。</p><p><strong>对于缩容来说，t0 是新数组，t1 是原数组：</strong></p><p>在读取游标 v 110 对应的槽位前，哈希表缩容了，此时原数组 t1 数组的 110 槽位的数据可能还在，也可能已经迁移到了新数组 t0 10 槽位中。此时，SCAN 顺序是先 t0 的 10 槽位，再 t1 的 110 槽位。可以看到，通过<strong>高位加法进位</strong>遍历，虽然依旧会保留原来的先后顺序，但是出现了<strong>“往回读一个哈希桶”</strong>，要知道已经遍历过的哈希桶在缩容时，可能会映射到新哈希表没有遍历到的位置，所以继续遍历就会对同一个key返回多次。按照图中的就是，010 槽位的元素会被重复遍历，但 010 之前的都不会。</p><h4 id="扫描内存紧凑型结构"><a href="#扫描内存紧凑型结构" class="headerlink" title="扫描内存紧凑型结构"></a>扫描内存紧凑型结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"> <span class="comment">// 3.2 压缩模式，一次性返回所有数据，忽略 count</span></span><br><span class="line">    <span class="comment">// 3.2.1 整数编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int64_t</span> ll;</span><br><span class="line">        <span class="keyword">while</span> (intsetGet(o-&gt;ptr, pos++, &amp;ll))</span><br><span class="line">            listAddNodeTail(keys, createStringObjectFromLongLong(ll));</span><br><span class="line">        <span class="comment">// 游标返回 0</span></span><br><span class="line">        <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2.2 ziplist b编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH || o-&gt;type == OBJ_ZSET) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ziplistIndex(o-&gt;ptr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vll;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            ziplistGet(p, &amp;vstr, &amp;vlen, &amp;vll);</span><br><span class="line">            listAddNodeTail(keys,</span><br><span class="line">                            (vstr != <span class="literal">NULL</span>) ? createStringObject((<span class="keyword">char</span> *) vstr, vlen) :</span><br><span class="line">                            createStringObjectFromLongLong(vll));</span><br><span class="line">            p = ziplistNext(o-&gt;ptr, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 游标返回 0</span></span><br><span class="line">        <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Not handled encoding in SCAN."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果对象的底层实现为 ziplist 、intset 而不是哈希表，那么这些对象通常都只包含了少量元素， 因此会将 ziplist 或者 intset 里面的所有元素都一次返回给调用者，无视 count 参数。</p><h4 id="匹配过滤"><a href="#匹配过滤" class="headerlink" title="匹配过滤"></a>匹配过滤</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// 4 如果指定了 key 的匹配模式，那么对扫描的结果进行过滤</span></span><br><span class="line">    node = listFirst(keys);</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        robj *kobj = listNodeValue(node);</span><br><span class="line">        nextnode = listNextNode(node);</span><br><span class="line">        <span class="keyword">int</span> filter = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Filter element if it does not match the pattern. */</span></span><br><span class="line">        <span class="keyword">if</span> (use_pattern) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Filter an element if it isn't the type we want. */</span></span><br><span class="line">        <span class="keyword">if</span> (!filter &amp;&amp; o == <span class="literal">NULL</span> &amp;&amp; <span class="keyword">typename</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Filter element if it is an expired key. */</span></span><br><span class="line">        <span class="keyword">if</span> (!filter &amp;&amp; o == <span class="literal">NULL</span> &amp;&amp; expireIfNeeded(c-&gt;db, kobj)) filter = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* Remove the element and its associated value if needed. */</span></span><br><span class="line">        <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">            decrRefCount(kobj);</span><br><span class="line">            listDelNode(keys, node);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        node = nextnode;</span><br><span class="line">    &#125;</span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，对元素的模式匹配工作是在命令从数据集中取出元素之后， 向客户端返回元素之前的这段时间内进行的。</p><h4 id="返回扫描结果"><a href="#返回扫描结果" class="headerlink" title="返回扫描结果"></a>返回扫描结果</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 5 返回给客户端</span></span><br><span class="line">    <span class="comment">// 返回数据项是 2</span></span><br><span class="line">    addReplyArrayLen(c, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 第一项是 cursor</span></span><br><span class="line">    addReplyBulkLongLong(c, <span class="built_in">cursor</span>);</span><br><span class="line">    <span class="comment">// 第二项是值或是键值值，值：set和zset ，键值对：hash</span></span><br><span class="line">    addReplyArrayLen(c, listLength(keys));</span><br><span class="line">    <span class="keyword">while</span> ((node = listFirst(keys)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        robj *kobj = listNodeValue(node);</span><br><span class="line">        addReplyBulk(c, kobj);</span><br><span class="line">        decrRefCount(kobj);</span><br><span class="line">        listDelNode(keys, node);</span><br><span class="line">    &#125;</span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;SCAN 命令在 Redis 早期版本中就支持，主要是为了解决 Redis 去批量获取 key 时造成的阻塞情况。如 KEYS 命令是获取所
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="SCAN" scheme="https://gentryhuang.com/tags/SCAN/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="https://gentryhuang.com/posts/4eb3381c/"/>
    <id>https://gentryhuang.com/posts/4eb3381c/</id>
    <published>2022-01-08T02:10:15.000Z</published>
    <updated>2022-01-10T06:04:49.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h1><p>分布式系统中，同一系统的不同主机共享同一资源，在访问的时候需要添加互斥语义以保护资源。这种情况下就需要使用分布式锁，<strong>锁是保存在一个共享存储系统中的，所有进程都可以去该系统上申请加锁和释放锁</strong>。</p><h1 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h1><p>用于存储“锁”的共享存储系统，可以是 <code>MySQL</code>、<code>Redis</code>、<code>Zookeeper</code> 以及 <code>Etcd</code> 等。对应的，每种共享存储系统都可以实现分布式锁。</p><h2 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h2><p>用于实现分布锁的数据表结构定义如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TDistributedLock (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">' 主键 '</span>,</span><br><span class="line">  <span class="string">`lock_key`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">' 锁的键值 '</span>,</span><br><span class="line">  <span class="string">`lock_timeout`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NOW</span>() <span class="keyword">COMMENT</span> <span class="string">' 锁的超时时间 '</span></span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_lock_key`</span> (<span class="string">`lock_key`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">' 分布式锁表 '</span>;</span><br></pre></td></tr></table></figure><p>当进程申请加锁时，只需要插入一条数据即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TDistributedLock(lock_key, lock_timeout) <span class="keyword">values</span>(<span class="string">'order_lock_key'</span>, <span class="string">'2022-01-07 20:30:00'</span>);</span><br></pre></td></tr></table></figure><p>当对共享资源的操作完毕后，可以释放锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> TDistributedLock <span class="keyword">where</span> lock_key=<span class="string">'order_lock_key'</span>;</span><br></pre></td></tr></table></figure><p>基于数据库实现的方案简单、方便，核心点是利用数据库表的<strong>唯一索引</strong>约束，保证多个进程同时申请加锁时，只有一个能获得锁。</p><p>虽然基于数据库实现的方案简单，但是存在一些问题。下面我们对问题进行说明，并给出解决方式。</p><ul><li>获得锁的进程意外 crash ，来不及释放锁。<blockquote><p>在插入锁记录时，同时设置了锁的过期时间 lock_timeout ，可以启动一个扫描清理线程 lock_cleaner，将超时的锁记录删除。</p></blockquote></li><li>如何支持可重入锁<blockquote><p>可以在锁记录表中增加一个字段，记录当前获取锁的主机信息和进程信息，在获取锁时先判断是否是重入锁。如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给它就可以了。此时需要考虑业务的复杂程度，判断是否要延长锁的更新时间。</p></blockquote></li><li>锁的可靠性怎么保证<blockquote><p>数据库支持主从、一主多从、多主多从等复制方案，可保证一个数据库实例宕机，其它实例可以接管过来继续提供服务。但是，有些复制方案是异步的，可能会导致锁丢失，进而导致分布锁失效。</p></blockquote></li></ul><h2 id="基于-Zookeeper-实现"><a href="#基于-Zookeeper-实现" class="headerlink" title="基于 Zookeeper 实现"></a>基于 Zookeeper 实现</h2><p>Zookeeper 是一个分布式协调框架，以目录结构的形式存储数据。基于 Zookeeper 的一些特性，实现分布式锁的逻辑如下：</p><ol><li>使用 Zookeeper 的临时有序节点，每个进程获取锁需要在 Zookeeper 上创建一个临时有序节点，如在 /lock/ 目录下；</li><li>创建节点成功后，获取 /lock 目录下的所有临时节点，再判断当前进程创建的节点是否是所有的节点中序号最小的节点；</li><li>如果当前进程创建的节点是所有节点序号最小的节点，则获取锁成功。</li><li>如果当前进程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。 比如当前进程获取到的节点序号为/lock/003,然后所有的节点列表为 [/lock/001,/lock/002,/lock/003],则对 /lock/002 这个节点添加一个事件监听器。</li></ol><p>当进程处理完共享资源后，就可以释放锁了，也就是删除它创建的临时节点。Zookeeper 添加其上的监听器会捕捉到移除事件，然后唤醒下一个序号的节点，然后执行第 3 步，继续抢锁。比如/lock/001 被删除了，/lock/002 监听到事件，此时节点集合为[/lock/002,/lock/003],则 /lock/002 为最小序号节点，获取到锁。</p><p><strong>注意：</strong>不使用 Zookeeper 的持久节点，是避免加锁成功后出现异常，节点来不及删除，导致后面的节点会一直等待节点删除，从而出现死锁，临时节点因为会随着客户端的下线被删除，可以避免死锁的问题。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Zookeeper <strong>无需考虑锁的过期时间问题</strong>，它采用的是临时节点和主动删除策略。客户端获取到锁后，只要连接不断开，除非主动删除临时节点，否则一直持有锁。即使客户端异常宕机，因为是临时节点，因此会自动删除，避免了死锁。</p><p>没有锁过期的问题，而且还能在异常时自动释放锁。一切看起来很安全，但是我们考虑下客户端获取到锁后，连接断开的情况。</p><p>我们知道，客户端和 Zookeeper 之间的连接是通过客户端<strong>定时心跳</strong>来维持的，如果 Zookeeper 长时间收不到客户端的心跳，就认为这个连接过期了，会把这个临时节点删除。对于长时间的 GC ，客户端应用程序就无法给 Zookeeper 发送心跳，一旦超时 Zookeeper 就会把锁节点删除，GC 结束后其它客户端也来获取锁，也获取到了。此时，同时有两个客户端持有锁，这是有问题的。</p><p>可以知道，<strong>Zookeeper 在进程 GC、网络延迟异常场景下的安全性得不到保证</strong>。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>优点</strong></p><ul><li>数据一致性得到保证</li><li>不需要考虑锁的过期时间</li><li>使用 watch 机制，避免了等候锁的客户端不停地轮循锁是否可用，当锁的状态发生变化时可以自动得到通知。</li></ul><p><strong>劣势</strong></p><ul><li>性能问题，体现在读写和数据同步上</li><li>客户端与 Zookeeper 长时间失联，锁被释放问题</li><li>羊群效应，要尽量避免大量节点监控一个节点的行为，做到按需监听</li></ul><h2 id="基于单个-Redis-节点实现"><a href="#基于单个-Redis-节点实现" class="headerlink" title="基于单个 Redis 节点实现"></a>基于单个 Redis 节点实现</h2><p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁。而且 Redis 的读写性能高，可以应对高并发的锁操作场景。</p><h3 id="SETNX-实现"><a href="#SETNX-实现" class="headerlink" title="SETNX 实现"></a>SETNX 实现</h3><p>SETNX 命令在执行时会判断键是否存在，如果不存在，就设置键值对，如果存在，就不做任何设置。</p><p>我们可以用 SETNX 和 DEL 命令组合来实现加锁和释放锁操作。下面的伪代码示例显示了锁操作的过程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">SETNX lock_key <span class="number">1</span></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">DO THINGS</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure><p>不难看出，上述方案存在很多问题，如下：</p><ul><li>没有过期时间，进程异常退出会导致死锁</li><li>不能区分来自不同客户端的锁操作，容易导致误删锁</li></ul><p>避免死锁的一个最直接的方法就是设置一个过期时间，也就是租期。假设业务逻辑不会超过 3s，那么在加锁时，可以设置 3s 过期时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">SETNX lock_key <span class="number">1</span></span><br><span class="line"><span class="comment">// 设置 3s 租期</span></span><br><span class="line">EXPIRE lock_key <span class="number">3</span></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">DO THINGS</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure><p>设置了租期后，也不能保证不会死锁。因为加锁、设置过期是 2 个操作，可能只执行了第一个操作，第二个操作没有执行，这种情况就有潜在的风险，死锁仍然可能发生。</p><p>好在 Redis 扩展了 SET 命令，可以使用一条命令替换上述存在问题的两条命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁并设置 3s 租期</span></span><br><span class="line">SET lock_key <span class="number">1</span> EX <span class="number">3</span> NX</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">DO THINGS</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure><p>这样就解决了死锁问题。</p><h3 id="SET-实现"><a href="#SET-实现" class="headerlink" title="SET 实现"></a>SET 实现</h3><p>为了能达到和 SETNX 命令一样的效果，Redis 扩展了 SET 命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [EX seconds | PX milliseconds]  [NX]</span><br></pre></td></tr></table></figure><p>虽然 SET 命令可以解决 SETNX 命令中存在的<strong>死锁问题</strong>，但是没有解决误删锁问题。这个问题的主要原因是，每个客户端在释放锁时，都是直接操作，<strong>没有检查锁是否还是自己持有</strong>。如以下场景：</p><ol><li>客户端 A 加锁成功，开始操作共享资源；</li><li>客户端 A 操作共享资源的时间超过了锁的过期时间，执行还没有完成，锁就自动释放了；</li><li>客户端 B 加锁成功，开始操作共享资源；</li><li>客户端 A 执行完成，释放锁，此时释放的事客户端 B 的锁。</li></ol><p>导致以上问题的关键有两个：</p><ul><li><strong>锁过期</strong>：客户端 A 执行时间过长，导致锁提前释放了，之后被客户端 B 持有。</li><li><strong>误释放锁</strong>：客户端 A 执行完成后，以为还是自己的锁，结果释放了客户端 B 的锁。</li></ul><p>下面我们对以上两个潜在问题进行分析并解决。</p><h4 id="解决锁被被人释放问题"><a href="#解决锁被被人释放问题" class="headerlink" title="解决锁被被人释放问题"></a>解决锁被被人释放问题</h4><p>在加锁操作中，每个客户端都使用一个唯一标识，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// $uuid 是当前客户端的唯一标识</span><br><span class="line">127.0.0.1:6379&gt; SET lock_key $uuid EX 3 NX</span><br></pre></td></tr></table></figure><p>在释放锁操作时，我们需要判断锁变量的值，是否等于执行释放锁操作的客户端的唯一标识，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放锁 比较unique_value是否相等，避免误释放</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">end</span></span><br></pre></td></tr></table></figure><p>上面是使用 Lua 脚本（unlock.script）实现的释放锁操作的伪代码，其中，KEYS[1]表示 lock_key，ARGV[1]是当前客户端的唯一标识，这两个值都是我们在执行 Lua 脚本时作为参数传入的。</p><p><strong>在释放锁操作中，我们使用了 Lua 脚本，这是因为，释放锁操作的逻辑也包含了读取锁变量、判断值、删除锁变量的多个操作，而 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</strong></p><h4 id="锁提前过期问题"><a href="#锁提前过期问题" class="headerlink" title="锁提前过期问题"></a>锁提前过期问题</h4><p>锁的过期时间如果评估不好，那么就会有提前释放的风险。但是，面对不同的业务场景过期时间很难精确预估。这个时候，我们可以使用<strong>续租</strong>的方式，延续锁的过期时间。</p><p>在加锁时，先设置一个过期时间，然后启动一个后台线程，定时检测锁的实效时间，如果锁快要过期了，但操作共享资源还没有处理完成，那么就对锁进行续期，重新设置过期时间。Java 中的 Redission 在使用分布式锁时，就采用了自动续期的方式来避免锁提前过期，这个后台线程一般称做<strong>看门狗线程</strong>。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><p>下面对基于 Redis 实现的分布式锁出现的问题以及解决方案进行梳理：</p><ul><li>针对死锁问题，可以通过设置过期时间来解决；</li><li>针对锁提前释放，可以使用自动续期来解决；</li><li>针对锁被误删除，可以通过检查锁的唯一标识来决定是否可以释放。</li></ul><h2 id="基于多个-Redis-节点实现"><a href="#基于多个-Redis-节点实现" class="headerlink" title="基于多个 Redis 节点实现"></a>基于多个 Redis 节点实现</h2><p>在使用 Redis 时，为了可靠性，一般会采用哨兵或集群的方式部署。那这种可靠性对于分布式锁有什么影响呢？我们以哨兵模式为例，分析主从切换对分布式锁的影响。</p><ol><li>客户端 A 在主库上执行 SET 命令申请加锁成功；</li><li>主库异常宕机，申请加锁的 SET 命令还未同步到从库上；</li><li>从库被提升为新主库，此时锁的数据在新的主库上丢失了；</li><li>其它客户端向主库申请加锁也会成功，此时分布式锁失效了。</li></ol><p>可以看到，因为 Redis 的主从复制是异步的，高可用机制不能保证锁的可靠性。因此，Redis 的作者提出了 Redlock 方案。</p><h3 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h3><p>Redlock 算法的基本思路，是让客户端和多个独立的 Redis 实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，并且总耗时不超过锁的有效时间，那么就认为客户端成功地获得分布式锁了，否则加锁失败。这样一来，即使有单个 Redis 实例发生故障，还有其它实例，锁的可靠性得到了保障。</p><p>可以看出，Redlock 的特点如下：</p><ul><li>不是部署主从库，而是只部署主库；</li><li>主库要部署多个，官方推荐至少 5 个实例；</li></ul><p>也就是说，Redlock 要求至少部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>Redlock 算法的步骤一共分为 5 步：</p><ol><li>客户端获取当前时间戳。</li><li>客户端按顺序依次向 N 个 Redis 实例执行加锁操作。这里的加锁操作和在单实例上执行的加锁操作一样，使用 SET 命令，带上 NX，EX/PX 选项，以及带上客户端的唯一标识。为了保证某个实例加锁失败（实例宕机、网络超时、锁被其它客户端持有） Redlock 算法能够继续运行，需要给加锁操作设置一个超时时间。如果客户端在和一个 Redis 实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个 Redis 实例继续请求加锁。加锁操作的超时时间需要远远地小于锁的有效时间，一般也就是设置为几十毫秒。</li><li>客户端只有在满足下面的这两个条件时，才能认为是加锁成功。<ul><li>客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁；</li><li>计算客户端获取锁的总耗时，必须没有超过锁的有效时间。</li></ul></li><li>加锁成功，操作共享资源。</li><li>加锁失败，向全部节点发起释放锁的请求。和在单实例上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。</li></ol><h4 id="关键步骤分析"><a href="#关键步骤分析" class="headerlink" title="关键步骤分析"></a>关键步骤分析</h4><p>Redlock 算法的关键如下：</p><ul><li>必须是大多数节点加锁成功；<blockquote><p>为了实现容错功能。</p></blockquote></li><li>大多数节点加锁的总耗时要小于锁设置的过期时间；<blockquote><p>即使大多数节点加锁成功，但如果加锁的累计耗时已经超过了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁也就没有意义了。</p></blockquote></li><li>释放锁要向全部节点发起释放锁请求。<blockquote><p>可能存在实例上加锁成功了，但是获取响应结果时是失败的，如网络问题导致超时。</p></blockquote></li></ul><h4 id="Redlock-存在问题"><a href="#Redlock-存在问题" class="headerlink" title="Redlock 存在问题"></a>Redlock 存在问题</h4><h5 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h5><p>为了效率可以使用单节点 Redis ，即使偶尔发生锁失效（宕机、主从切换），有些业务不会产生严重后果，最差可以做幂等。毕竟，使用 Redlock 太重了。</p><h5 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h5><p>在进程暂停、时钟跳跃、节点奔溃恢复等情况下，Redlock 是不安全的。</p><h6 id="进程暂停"><a href="#进程暂停" class="headerlink" title="进程暂停"></a>进程暂停</h6><p>在 Java 中进行 GC 时，会使进程暂停，时间序列如下：</p><ol><li>客户端 1 依次向节点 A、B、C、D、E 请求加锁；</li><li>客户端 1 获得锁后，进入 GC ，这个时间假设很长；</li><li>大多数或全部 Redis 节点上的锁都过期了；</li><li>客户端 2 依次向节点 A、B、C、D、E 请求加锁，获取锁成功；</li><li>客户端 1 和客户端 2 都获取到了锁，发生了冲突。</li></ol><h6 id="时钟跳跃"><a href="#时钟跳跃" class="headerlink" title="时钟跳跃"></a>时钟跳跃</h6><p>当多个 Redis 节点时钟发生问题时，也会导致 Redlock 锁失效。</p><ol><li>客户端 1 依次向节点 A、B、C、D、E 请求加锁，获取到了节点 A、B、C 上的锁，但由于网络问题，无法访问 D 和 E；</li><li>节点 C 上的时钟向前跳跃，导致锁过期了。</li><li>客户端 2 依次向节点 A、B、C、D、E 请求加锁，获取节点 C、D、E 上的锁，由于网络问题，无法访问 A 和 B；</li><li>客户端 1 和客户端 2 都获取到了锁，发生了冲突。</li></ol><p>机器的时钟发生错误，是很有可能发生的，比如：</p><ul><li>系统管理员手动修改了机器时钟</li><li>机器时钟在同步 NTP 时间时，发生了大的跳跃</li></ul><p>Redis 节点奔溃重启，如果锁信息没有持久化，那么也会造成和时钟跳跃一样的问题。</p><h4 id="解决-Redlock-问题"><a href="#解决-Redlock-问题" class="headerlink" title="解决 Redlock 问题"></a>解决 Redlock 问题</h4><h5 id="时钟跳跃问题"><a href="#时钟跳跃问题" class="headerlink" title="时钟跳跃问题"></a>时钟跳跃问题</h5><p>针对时钟问题，Redlock 并不需要完全一致的时钟，只需要大体一致就可以了。避免手动修改机器时钟，并通过正确的运维保证机器时钟不会大幅度跳跃。</p><h5 id="进程暂停问题"><a href="#进程暂停问题" class="headerlink" title="进程暂停问题"></a>进程暂停问题</h5><p>对于 Redlock 来说，如果进程暂停、网络延迟发生在获得锁之前，那么 Redlock 是可以检测出来的，如果超出了锁设置的过期时间，就认为加锁失败，之后释放所有节点的锁；如果发生在获得锁之后，也就是在客户端操作共享资源的过程发生问题导致锁失效，那 Redlock 确实没有办法了，但是这不仅仅是 Redlock 的问题，其它分布式锁实现也有类似问题，比如 Zookeeper 实现的分布式锁也会因一定时间没有保持心跳而断开连接，导致分布式锁失效。</p><p>总的来说，Redlock 在保证时钟正确的基础上，是可以保证正确性的。</p><h4 id="Redlock-实践"><a href="#Redlock-实践" class="headerlink" title="Redlock 实践"></a>Redlock 实践</h4><p>追求性能，并能容忍一定的可靠性和安全，可以直接使用单节点的 Redis；对可靠性有追求，可以考虑使用 Redis 的可靠性机制。毕竟，Redlock 较重，而且部署成本高，时钟跳跃问题也不是那么容易解决或避免。</p><h2 id="基于-Etcd-实现"><a href="#基于-Etcd-实现" class="headerlink" title="基于 Etcd 实现"></a>基于 Etcd 实现</h2><p>Etcd 是 CoreOS 团队于 2013 年 6 月发起的开源项目，它的目标是构建一个高可用的分布式键值 (key-value) 数据库。Etcd 内部基于 raft 一致性算法，使用 Go 语言实现。</p><p>Etcd 分布式锁的逻辑如下：</p><ul><li>Lease 机制:即租约机制(TTL，Time To Live)，etcd 可以为存储的 KV 对设置租约，当租约到期，KV 将失效删除;同时也支持续约， 即 KeepAlive。</li><li>Revision 机制:每个 key 带有一个 Revision 属性值，etcd 每进行一次事务对应的全局 Revision 值都会加一，因此每个 key 对应的 Revision 属性值都是全局唯一的。通过比较 Revision 的大小就可以知道进行写操作的顺序。 </li><li>在实现分布式锁时，多个程序同时抢锁，根据 Revision 值大小依次获得锁，可以避免 “羊群效应” (也称 “惊群效应”)，实现公平 锁。</li><li>Prefix 机制:即前缀机制，也称目录机制。可以根据前缀(目录)获取该目录下所有的 key 及对应的属性(包括 key, value 以及 revision 等)。</li><li>Watch 机制:即监听机制，Watch 机制支持 Watch 某个固定的 key，也支持 Watch 一个目录(前缀机制)，当被 Watch 的 key 或目录 发生变化，客户端将收到通知。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章对分布式锁的几种实现方式进行了介绍，重点分析了 Redis 分布式锁的实现方式，通过不断演进，最终出现了 Redlock ，并对 Redlock 存在的问题进行了说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么需要分布式锁？&quot;&gt;&lt;a href=&quot;#为什么需要分布式锁？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要分布式锁？&quot;&gt;&lt;/a&gt;为什么需要分布式锁？&lt;/h1&gt;&lt;p&gt;分布式系统中，同一系统的不同主机共享同一资源，在访问的时候需要添加互斥语义以
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式锁" scheme="https://gentryhuang.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构 - SDS续</title>
    <link href="https://gentryhuang.com/posts/1a7fe47d/"/>
    <id>https://gentryhuang.com/posts/1a7fe47d/</id>
    <published>2021-12-12T03:10:07.000Z</published>
    <updated>2022-01-19T11:02:30.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://gentryhuang.com/posts/f7ccc3b4/">SDS</a> 中，我们对 Redis 中的简单动态字符串进行了说明。本篇文章将对 SDS 的使用进行简单介绍，主要对 String 类型的 Set 命令、字符串对象的编码、字符串对象的缩容这三个方面进行分析。</p><h2 id="Set命令的实现"><a href="#Set命令的实现" class="headerlink" title="Set命令的实现"></a>Set命令的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-- t_string.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *expire = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> unit = UNIT_SECONDS;</span><br><span class="line">    <span class="keyword">int</span> flags = OBJ_NO_FLAGS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 解析并设置选项参数</span></span><br><span class="line">    <span class="keyword">if</span> (parseExtendedStringArgumentsOrReply(c, &amp;flags, &amp;unit, &amp;expire, COMMAND_SET) != C_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 尝试对值对象进行编码优化，以节省内存</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 执行 set 通用命令方法</span></span><br><span class="line">    setGenericCommand(c, flags, c-&gt;argv[<span class="number">1</span>], c-&gt;argv[<span class="number">2</span>], expire, unit, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数是 SET 命令的处理函数，主要的步骤已经标注，其中 2、3 两步涉及的内容有点多，我们先对涉及的字符串对象编码情况以及缩容进行说明。</p><h2 id="字符串对象的编码"><a href="#字符串对象的编码" class="headerlink" title="字符串对象的编码"></a>字符串对象的编码</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/f7ccc3b4/&quot;&gt;SDS&lt;/a&gt; 中，我们对 Redi
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构 - SDS</title>
    <link href="https://gentryhuang.com/posts/f7ccc3b4/"/>
    <id>https://gentryhuang.com/posts/f7ccc3b4/</id>
    <published>2021-12-04T08:34:15.000Z</published>
    <updated>2021-12-08T11:31:09.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>字符串作为我们日常开发常见的数据类型，几乎任何地方都可能用到，这就要求字符串的实现需要满足以下要求：</p><ul><li>能支持丰富且高效的字符串操作，如字符串追加、获取长度等。</li><li>能保存任意二进制数据，比如图片等</li><li>能尽可能地节省内存开销</li></ul><h1 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C 字符串"></a>C 字符串</h1><p>在 C 语言中可以使用 <strong>char* 字符数组</strong> 来实现字符串，本质就是<strong>一块连续的内存空间，依次存放了字符串中的每个字符</strong>。比如，下图显示的就是字符串“redis”的char*数组结构：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/data_structure/redis-sds-c-array.jpg" alt></p><p>从图中可以看到，字符数组的最后一个字符是“\0”，这个字符的作用是什么呢？其实，C 语言在对字符串进行操作时，<strong>char* 指针只是指向字符数组的起始位置，而字符数组的结尾位置就用“\0”表示，意思是指字符串的结束</strong>。</p><p>C 语言标准库 <code>string.h</code>中也定义了多种字符串的操作函数，比如字符串比较函数 strcmp、字符串长度计算函数 strlen、字符串追加函数 strcat 等，这样就便于开发者直接调用这些函数来完成字符串操作。从以上角度来看，Redis 好像完全可以复用 C 语言中对字符串的实现。但 C 字符串没有很好地解决系列问题。</p><h2 id="字符串高效操作"><a href="#字符串高效操作" class="headerlink" title="字符串高效操作"></a>字符串高效操作</h2><p>C 语言标准库中字符串的操作函数，是通过检查字符数组中是否有<code>\0</code>来判断字符串是否结束，基于此 C 语言操作函数复杂度是不可观的。比如：</p><ul><li>strlen 函数：该函数需要遍历字符数组中的每一个字符，才能得到字符串长度，所以这个操作函数的复杂度是 O(N)。</li><li>strcat 函数：将一个源字符串 src 追加到一个目标字符串的末尾，一方面要先遍历目标字符串找到末尾，然后再遍历源字符串才能完成追加。另一方面，还需要确认目标字符串具有足够的可用空间，否则就无法追加。</li></ul><p>操作函数的复杂度一旦增加，就会影响字符串的操作效率，这就<strong>不符合 Redis 对字符串高效操作的需求了</strong>。</p><h2 id="二进制数安全"><a href="#二进制数安全" class="headerlink" title="二进制数安全"></a>二进制数安全</h2><p>C 语言中 char* 字符串以<code>\0</code>表示字符串的结束，这样决定了它存储数据的局限性。如果我们要保存的数据中本身就有<code>\0</code>，那么数据在<code>\0</code>处就会被截断，这<strong>不符合 Redis 希望保存任意二进制数据的需求</strong>。</p><h2 id="内存分配与释放"><a href="#内存分配与释放" class="headerlink" title="内存分配与释放"></a>内存分配与释放</h2><p>C 语言中 char* 字符串的长度和底层数组的长度之间存在<strong>关联性</strong>，每次增加或者缩短一个 C 字符串，程序都需对保存这个 C 字符串的数组进行一次分配操作，该过程涉及到内存分配和释放。内存操作通常是个比较耗时的操作，这<strong>不符合 Redis 对字符串高效操作的需求了</strong>。</p><h1 id="Redis-中字符串"><a href="#Redis-中字符串" class="headerlink" title="Redis 中字符串"></a>Redis 中字符串</h1><p>综合 C 语言中字符串的不足，Redis 对字符串的实现进行了设计和考虑：</p><ul><li><strong>操作效率高：</strong>Redis 专门设计了 SDS 数据结构，在字符数组的基础上，增加了字符数组存储数据长度和分配空间大小等元数据。这样一来，需要<strong>基于字符串长度</strong>进行的追加、复制、比较等操作，就可以直接读取元数据，效率也就提升了。</li><li><strong>二进制安全：</strong>SDS 数据结构定义了字符数组存储数据长度和分配空间大小等元数据，不需要通过字符数组中的<code>\0</code>字符判断字符串结束，所以可存储包含 \0 的数据，这样就可以存储图片等二进制数据。</li><li><strong>优化内存操作：</strong>SDS 为了避免频繁操作字符串时带来的内存开销，使用了内存预分配和惰性空间释放（多余内存不释放）。</li><li><strong>节省内存空间：</strong>SDS通过设计不同的 SDS 类型来表示不同大小的字符串，并使用<code>__attribute__ ((__packed__))</code>编译优化来实现紧凑型内存布局，达到节省内存的目的。</li><li><strong>兼容C字符串：</strong>可以直接使用 C 语言标准库函数。</li></ul><h2 id="SDS-结构设计"><a href="#SDS-结构设计" class="headerlink" title="SDS 结构设计"></a>SDS 结构设计</h2><p>由于 Redis 是使用 C 语言开发的，所以<strong>为了保证能尽量复用 C 标准库中的字符串操作函数，Redis 保留了使用字符数组来保存实际的数据。但是和 C 语言仅用字符数组不同，Redis 还专门设计了 SDS（即简单动态字符串）的数据结构，内部存储数据使用的还是 C 语言中的字符数组，但定义了几个描述字符数组的元数据</strong>。SDS 结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/data_structure/redis-sds-struct.jpg" alt></p><p>首先，SDS 结构里包含了一个<strong>字符数组 buf[]，用来保存实际数据</strong>。同时，SDS 结构里还包含了三个元数据，分别是<strong>字符数组现有长度 len</strong>、<strong>分配给字符数组的空间长度 alloc</strong>，以及 <strong>SDS 类型 flags</strong>。其中，<strong>Redis 给 len 和 alloc 这两个元数据定义了多种数据类型，进而可以用来表示不同类型的 SDS</strong>。<strong>注意：</strong>sds 可用的（空闲的）长度:  avail = alloc - len 。</p><p>此外，Redis 使用 typedef 给 char* 类型定义了一个别名，这个别名就是 sds ，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型别名，是 SDS 中用于存储字符数据的属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>SDS 本质上还是一个字符数组，因为<strong>核心的存储数据还是使用 C 语言中的字符数组，只是在字符数组的基础上增加了额外的元数据。</strong>在 Redis 中需要用到字符数组时，就直接使用 sds 这个别名，它是 SDS 结构体中用于存储字符的属性。<strong>注意 sds 和 SDS 结构体的区别与联系。</strong></p><h2 id="创建-SDS"><a href="#创建-SDS" class="headerlink" title="创建 SDS"></a>创建 SDS</h2><p>了解了 SDS 结构设计后，我们简单看下 Redis 是如何创建字符串的。Redis 会调用 SDS 中的创建函数 sdsnewlen 新建 SDS 结构体，并把 SDS 结构体中的数组 buf[] 赋给 sds 类型变量，然后把要创建的字符串拷贝给 sds 变量。下面的代码显示了创建 SDS 的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的 SDS 字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param init 初始化字符串指针</span></span><br><span class="line"><span class="comment"> * @param initlen 初始化字符串长度</span></span><br><span class="line"><span class="comment"> * @param trymalloc</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sds _sdsnewlen(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen, <span class="keyword">int</span> trymalloc) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向 SDS 结构体的指针</span></span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sds 类型变量，即 char* 字符数组</span></span><br><span class="line">    sds s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据初始化字符串长度选择对应类型的 sds</span></span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8 since type 5 is not good at this. */</span></span><br><span class="line">    <span class="comment">// 创建空字符串通常是为了追加。利用 类型8 因为 类型5 不擅长这个。</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  type 对应的 SDS 结构体中元数据的长度</span></span><br><span class="line">    <span class="comment">// todo hdrlen 是SDS结构体中元数据的长度</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line">    <span class="keyword">size_t</span> usable;</span><br><span class="line"></span><br><span class="line">    assert(initlen + hdrlen + <span class="number">1</span> &gt; initlen); <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据是否尝试 malloc，新建SDS结构，并分配内存空间</span></span><br><span class="line">    <span class="comment">// todo sh 指向当前新建的 SDS 结构，即 sh指向SDS结构体起始位置</span></span><br><span class="line">    sh = trymalloc ?</span><br><span class="line">         s_trymalloc_usable(hdrlen + initlen + <span class="number">1</span>, &amp;usable) :</span><br><span class="line">         s_malloc_usable(hdrlen + initlen + <span class="number">1</span>, &amp;usable);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区相关</span></span><br><span class="line">    <span class="keyword">if</span> (init == SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有初始化内容</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen + initlen + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sh + hdrlen 表示将指向 SDS 结构的指针移动到 SDS 结构体中的 buf</span></span><br><span class="line">    <span class="comment">// todo 把 SDS 结构体中的数组 buf[] 赋给 sds 类型变量</span></span><br><span class="line">    s = (<span class="keyword">char</span> *) sh + hdrlen;</span><br><span class="line"></span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *) s) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防御性编程，防止超过当前 SDS 能表示的字符数组长度</span></span><br><span class="line">    usable = usable - hdrlen - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (usable &gt; sdsTypeMaxSize(type))</span><br><span class="line">        usable = sdsTypeMaxSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型，为 SDS 结构体属性赋值</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="comment">// 已废弃</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// 根据不同的 SDS 类型，初始化 SDS 结构体属性</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们拷贝给 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以 \0 结尾，表示字符串结束，用于兼容 C 字符串</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 SDS 结构</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SDS-操作效率"><a href="#SDS-操作效率" class="headerlink" title="SDS 操作效率"></a>SDS 操作效率</h2><p>因为 SDS 结构中<strong>记录了字符数组已占用的空间和被分配的空间</strong>，这就比传统 C 语言实现的字符串基础长度操作会带来更高的操作效率。</p><p>以字符串追加操作为例进行介绍。Redis 中实现字符串追加的函数是 sds.c 文件中的 sdscatlen 函数。这个函数的参数一共有三个，分别是目标字符串 s、源字符串 t 和要追加的长度 len，源码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将长度为 len 的字符串 t 追加到 sds 的字符串末尾</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 目标字符串</span></span><br><span class="line"><span class="comment"> * @param t 源字符串</span></span><br><span class="line"><span class="comment"> * @param len 要追加的字符串长度</span></span><br><span class="line"><span class="comment"> * @return 追加成功返回新 sds ，失败返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取目标字符串s的当前长度</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    <span class="comment">//根据要追加的长度len和目标字符串s的现有长度，判断是否要扩容</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将源字符串t中len长度的数据拷贝到目标字符串结尾</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    <span class="comment">//设置目标字符串的最新长度：拷贝前长度curlen加上拷贝长度</span></span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    <span class="comment">//拷贝后，在目标字符串结尾加上\0</span></span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，和 C 语言中的字符串操作相比，SDS 通过记录字符数组的使用长度和分配空间大小，避免了对字符串的遍历操作，降低了操作开销，进一步就可以帮助诸多字符串操作更加高效地完成，比如创建、追加、复制、比较等。</p><h2 id="内存预分配"><a href="#内存预分配" class="headerlink" title="内存预分配"></a>内存预分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对 SDS 中 buf 的长度进行扩展，确保在函数执行之后，buf 至少会有 addlen + 1 长度的空余空间。</span></span><br><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s buf</span></span><br><span class="line"><span class="comment"> * @param addlen 预计新增的字符串长度</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 获取 sds 目前可用的空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 s 对应的 SDS 类型（在创建 SDS 时，内部属性 buf[-1] 保存的就是 SDS 类型）</span></span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line">    <span class="keyword">size_t</span> usable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 sds 目前的剩余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-- 执行到这里，说明 sds 剩余空间不足，需要进行扩容 ----*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 获取 sds 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 获取 sds 所在的 SDS 结构体</span></span><br><span class="line">    sh = (<span class="keyword">char</span> *) s - sdsHdrSize(oldtype);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 获取新的长度，sds 当前长度 + addlen</span></span><br><span class="line">    newlen = (len + addlen);</span><br><span class="line">    assert(newlen &gt; len);   <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 判断是否需要扩容，以实现预分配</span></span><br><span class="line">    <span class="comment">// todo 小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7 根据预扩容的大小，获取对应类型的 SDS</span></span><br><span class="line">    <span class="comment">// todo 为了有效节省内存空间，使用不同的 SDS 类型保存相应大小的数据</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SDS_TYPE_5 已经废弃，如果是 SDS_TYPE_5 ，则默认使用 SDS_TYPE_8</span></span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*---- 确定了 SDS 类型，就可以进行空间分配了 --------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8 获取结构头的大小，即 SDS 结构体的元数据大小</span></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    assert(hdrlen + newlen + <span class="number">1</span> &gt; len);  <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.1 如果 SDS 类型还是之前的类型</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype == type) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结构头大小不变，无需要将字符串向前移动，即无需数据拷贝</span></span><br><span class="line">        <span class="comment">// 新的指向 SDS 指针</span></span><br><span class="line">        newsh = s_realloc_usable(sh, hdrlen + newlen + <span class="number">1</span>, &amp;usable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内容不足，分配失败</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 SDS 中的 char buf[]</span></span><br><span class="line">        s = (<span class="keyword">char</span> *) newsh + hdrlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.2 如果 SDS 类型是新的类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于结构头大小改变，需要将字符串向前移动，不能使用 realloc</span></span><br><span class="line">        <span class="comment">// 新的指向 SDS 指针</span></span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,and can't use realloc */</span></span><br><span class="line">        newsh = s_malloc_usable(hdrlen + newlen + <span class="number">1</span>, &amp;usable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内容不足，分配失败</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原来的字符串数据拷贝到新的 SDS 中的 buf 中</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span> *) newsh + hdrlen, s, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的 SDS 结构体</span></span><br><span class="line">        s_free(sh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 SDS 中的 char buf[]</span></span><br><span class="line">        s = (<span class="keyword">char</span> *) newsh + hdrlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// todo 标记 buf 属于哪种 SDS 类型</span></span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 sds 实际长度</span></span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9 获取 SDS 结构体最大可存储字符串的长度，这里 -1 是包括数组最后一位 \0</span></span><br><span class="line">    usable = usable - hdrlen - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防御性编程</span></span><br><span class="line">    <span class="keyword">if</span> (usable &gt; sdsTypeMaxSize(type))</span><br><span class="line">        usable = sdsTypeMaxSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 sds 分配的长度，注意，这里并不是直接使用扩容后的 newlen ,而是使用计算得来。</span></span><br><span class="line">    <span class="comment">// 注意，分配的长度不包括 \0 占用的字符</span></span><br><span class="line">    sdssetalloc(s, usable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用内存预分配，可以减少连续执行字符串增长操作所需的内存重新分配次数，也可以避免缓冲区溢出。</p><h2 id="紧凑型字符串结构"><a href="#紧凑型字符串结构" class="headerlink" title="紧凑型字符串结构"></a>紧凑型字符串结构</h2><p>SDS 结构中有一个元数据 flags，表示的是 SDS 类型。事实上，SDS 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。这 5 种类型的<strong>主要区别就在于：</strong>它们数据结构中的<strong>字符数组现有长度 len 和分配空间长度 alloc，这两个元数据的数据类型不同</strong>。下面以 sdshdr8 为例，它的定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="comment">// 字符数组现有长度。 8 位无符号整型，占用 1 字节的内存空间</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="comment">// 字符数组已经分配的长度, 不包括结构体和\0结束符</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="comment">// SDS 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="comment">// 字符数组，用来保存实际数据</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到，现有长度 len 和已分配空间 alloc 的数据类型都是 uint8_t，它是 8 位无符号整型，会占用 1 字节的内存空间。当字符串类型是 sdshdr8 时，<strong>它能表示的字符数组长度（包括数组最后一位\0）不会超过 256 字节（2 的 8 次方等于 256）</strong>。</p><p>实际上，<strong>SDS 之所以设计不同的结构头（即不同类型），是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。因为在保存不同大小的字符串时，结构头占用的内存空间也不一样，这样一来，在保存小字符串时，结构头占用空间也比较少。</p><h2 id="使用编译优化来节省内存空间"><a href="#使用编译优化来节省内存空间" class="headerlink" title="使用编译优化来节省内存空间"></a>使用编译优化来节省内存空间</h2><p>除了设计不同类型的结构头，Redis 在编程上还 <strong>使用了专门的编译优化来节省内存空间</strong>。</p><p>在定义不同类型的结构头时，使用了 <code>__attribute__ ((__packed__))</code> ，目的是告诉编译器，在编译结构时，不要使用字节对齐的方式，而是<strong>采用紧凑的方式分配内存</strong>。下面以 sdshdr8 结构定义为例进行分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span></span></span><br></pre></td></tr></table></figure><p>在默认情况下，编译器会按照 8 字节对齐的方式，给变量分配内存。也就是说，即使一个变量的大小不到 8 个字节，编译器也会给它分配 8 个字节。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>针对 C 语言中 char* 实现字符串的缺陷，Redis 基于 char* 基础之上设计了 SDS 结构。这一设计是从 <code>操作效率</code>、<code>二进制安全</code>、<code>内存开销</code> 以及<code>兼容 C 字符串</code> 方面思考的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;字符串作为我们日常开发常见的数据类型，几乎任何地方都可能用到，这就要求字符串的实现需要满足以下要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能支持丰富且
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - Redis主流程</title>
    <link href="https://gentryhuang.com/posts/19fe4bc5/"/>
    <id>https://gentryhuang.com/posts/19fe4bc5/</id>
    <published>2021-11-27T16:00:00.000Z</published>
    <updated>2021-12-07T03:19:06.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇文章将从源码层面对 Redis 主干轮廓进行说明。以主线程执行流程为主干，对途径的枝枝蔓蔓简单介绍，不会过度展开，后续将针对每一个模块进行详细分析。由于 Redis 是用 C 语言实现的，当然应该从 main 函数开启阅读源码旅程。</p><h1 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h1><p>Redis 服务器启动的入口是 main 函数，其它的无需多说，下面直接上代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis Server 启动入口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *  Redis是用C语言实现的，从 main 函数启动。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">char</span> config_from_stdin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    <span class="comment">// 1 初始化库</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 检查服务器是否以 Sentinel 模式启动</span></span><br><span class="line">    <span class="comment">// 这一点非常重要，因为 Sentinel 和普通的实例不同</span></span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3  初始化服务器配置</span></span><br><span class="line">    initServerConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 ACL 初始化（6.0 对 ACL 进行了功能丰富）</span></span><br><span class="line">    ACLInit(); <span class="comment">/* The ACL subsystem must be initialized ASAP because the</span></span><br><span class="line"><span class="comment">                  basic networking code and client creation depends on it. */</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 5 如果服务器以 Sentinel 模式启动，那么需要进行 Sentinel 功能相关的初始化，并为要监视的主服务器创建一些相应的数据结构</span></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        <span class="comment">// Sentinel 所属的属性覆盖服务器默认的属性</span></span><br><span class="line">        initSentinelConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哨兵模式初始化</span></span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 6 是否需要在 redis-check-rdb/aof模式下启动，这样可以校验持久化文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>], <span class="string">"redis-check-rdb"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_rdb_main(argc, argv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>], <span class="string">"redis-check-aof"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_aof_main(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7 检查用户是否指定了配置文件，或者配置选项</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">background</span> = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8 将服务器设置为守护进程运行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">background</span>) daemonize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9 创建并初始化服务器</span></span><br><span class="line">    initServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🌟 服务器不是运行在 SENTINEL 模式，那么执行以下代码</span></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 10  bio 和 io 线程的初始化</span></span><br><span class="line">        InitServerLast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11 从 AOF 文件或者 RDB 文件中载入数据</span></span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                          <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                          <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 以 SENTINEL 模式运行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        <span class="comment">// bio 和 io 线程的初始化</span></span><br><span class="line">        InitServerLast();</span><br><span class="line">        <span class="comment">// Sentinel 准备就绪后执行</span></span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12 🌟 启动事件处理循环</span></span><br><span class="line">    <span class="comment">// 主要围绕 IO多路复用 展开的，驱动注册的时间事件回调和 IO 事件回调</span></span><br><span class="line">    aeMain(server.el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12 退出事件循环，回收内存</span></span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retun 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 服务启动后，主线程 main 会依次执行以上流程，直到进入 <strong>aeMain</strong> 事件处理循环方法中。需要说明的是，上述代码片段删除掉了不关心的逻辑，本篇文章我们只关注以下两个逻辑：</p><ul><li>执行各种初始化</li><li>执行事件循环</li></ul><p>Redis 服务器初始化逻辑较为复杂，从底层的数据结构到服务器不同的角色，初始化的逻辑和属性都不一样，这里就不展开了。下面对流程进行概括：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/themory/redis-outline-main-process.jpg" alt></p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>事件循环逻辑是 Redis 核心的直接体现，它就是在这个循环中不断处理网络请求和内部自身逻辑的。下面我们直接上代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;<span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程进入主循环，一直处理事件，直到服务器关闭</span></span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;<span class="built_in">stop</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始处理事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS |</span><br><span class="line">                                   AE_CALL_BEFORE_SLEEP |</span><br><span class="line">                                   AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只要事件循环 <code>aeEventLoop</code> 没有被停止，主线程 main 就会一直自旋，不断执行 <code>aeProcessEvents</code> 方法。不难看出 <code>aeProcessEvents</code> 方法封装了 Redis 的所有功能逻辑，这里提前说下，Redis 的功能逻辑总共两大类：一个是网络事件，也称为文件事件；另一个是时间事件；前者用于处理网络中的交互，后者用于处理 Redis 自身的一些逻辑。</p><p>下面继续贴出 <code>aeProcessEvents</code> 方法的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line">        <span class="keyword">int64_t</span> usUntilTimer = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取最近的时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            usUntilTimer = usUntilEarliestTimer(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1 使用 usUntilTimer 来决定文件事件的阻塞时间</span></span><br><span class="line">        <span class="keyword">if</span> (usUntilTimer &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            tv.tv_sec = usUntilTimer / <span class="number">1000000</span>;</span><br><span class="line">            tv.tv_usec = usUntilTimer % <span class="number">1000000</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2 执行到这里，说明没有时间事件。那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                <span class="comment">// 设置文件事件不阻塞</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                <span class="comment">// 文件事件阻塞直到有事件到达为止</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">            tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2 前置回调函数 - beforeSleep */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">        <span class="number">3</span> 调用多路复用 API，只会在超时或某些事件触发时返回。即等待事件产生</span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* 4 后置回调函数 - beforeSleep */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.1 从已就绪数组中获取文件描述符信息</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.2 如果是套接字上发生读事件，调用读事件处理器处理读事件</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                fired++;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Fire the writable event. */</span></span><br><span class="line">            <span class="comment">// 5.3 如果是套接字上发生写事件，调用写事件处理器处理写事件</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">             * after the writable one.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 如果需要反转调用，在可写事件之后触发可读事件</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (invert) &#123;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">                <span class="keyword">if</span> ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp;</span><br><span class="line">                    (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc)) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 6 如果是时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        <span class="comment">// 执行时间事件</span></span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码片段中也可以看到，主线程在不断轮询时间事件和文件事件，找到就尝试执行。上述代码虽然简短，但是却几乎包含了 Redis 的所有功能，秘密就在以下几个组件中：</p><ul><li>前置处理器 beforeSleep </li><li>IO多路复用库（及多种回调函数）</li><li>后置处理器 afterSleep</li></ul><p>关于以上代码片段背后的信息，会在后面的文章中介绍 Redis 事件一文中详细说明，这里先不展开。下面对以上方法进行概括：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/themory/redis-outline-multi-process.jpg" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章简单介绍了 Redis 启动的入口以及执行的主干流程，这里有个印象即可，后续会对每个模块展开说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本篇文章将从源码层面对 Redis 主干轮廓进行说明。以主线程执行流程为主干，对途径的枝枝蔓蔓简单介绍，不会过度展开，后续将针对每一个模块进
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 源码结构总览</title>
    <link href="https://gentryhuang.com/posts/adccc332/"/>
    <id>https://gentryhuang.com/posts/adccc332/</id>
    <published>2021-11-27T06:59:01.000Z</published>
    <updated>2021-12-07T03:20:43.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从本篇文章开始，将对 Redis 核心原理以及相关源码进行分析，需要说明的是，笔者阅读的 Redis 版本是 <code>#define REDIS_VERSION &quot;6.2.4&quot;</code>，之所以选择较新的版本，因为笔者对 Redis 一些新特性比较感兴趣，特别是 Redis 在 6.0 版本中提出的 IO 多线程。</p><h1 id="Redis-源码结构"><a href="#Redis-源码结构" class="headerlink" title="Redis 源码结构"></a>Redis 源码结构</h1><p>了解源码的整体目录结构是快速对代码进行认知的一个行之有效的方法。下面我们对 Redis 的源码目录进行简单介绍。</p><h2 id="Redis-源码整体结构"><a href="#Redis-源码整体结构" class="headerlink" title="Redis 源码整体结构"></a>Redis 源码整体结构</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-summary-struct.jpg" alt></p><p>对于 Redis 来说，在它的源码总目录下，一共包含了 <strong>deps</strong>、<strong>src</strong>、<strong>tests</strong>、<strong>utils</strong> 四个子目录，这四个子目录分别对应了 Redis 中发挥不同作用的代码，下面我们具体来看看。</p><h3 id="deps-目录"><a href="#deps-目录" class="headerlink" title="deps 目录"></a>deps 目录</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-deps-struct.jpg" alt></p><p>这个目录<strong>主要包含了 Redis 依赖的第三方代码库</strong>，包括 Redis 的 C 语言版本客户端代码 hiredis、jemalloc 内存分配器代码、readline 功能的替代代码 linenoise，以及 lua 脚本代码。</p><p>这部分代码的一个显著特点，就是<strong>它们可以独立于 Redis src 目录下的功能源码进行编译</strong>，也就是说，它们可以独立于 Redis 存在和发展。</p><h3 id="src-目录"><a href="#src-目录" class="headerlink" title="src 目录"></a>src 目录</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-src-struct.jpg" alt></p><p>目录里面包含了 Redis 所有功能模块的代码文件，也是 Redis 源码的重要组成部分。src 目录下只有一个 modules 子目录，剩余的源码文件都是在 src 目录下，没有再分下一级子目录。因为 Redis 的功能模块实现是典型的 C 语言风格，不同功能模块之间不再设置目录分隔，而是通过头文件包含来相互调用。</p><h3 id="tests-目录"><a href="#tests-目录" class="headerlink" title="tests 目录"></a>tests 目录</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-tests-struct.jpg" alt></p><p>在 Redis 的代码目录中，将功能测试和单元测试分代码用一个 tests 目录统一管理了起来。Redis 实现的测试代码可以分成四部分，分别是单元测试（对应 unit 子目录），Redis Cluster 功能测试（对应 cluster 子目录）、哨兵功能测试（对应 sentinel 子目录）、主从复制功能测试（对应 integration 子目录）。这些子目录中的测试代码使用了 Tcl 语言（通用的脚本语言）进行编写，主要目的就是方便进行测试。</p><p>在 tests 目录中，除了有针对特定功能模块的测试代码外，还有一些代码是用来支撑测试功能的，这些代码在 assets、helpers、modules、support 四个目录中。</p><h3 id="utils-目录"><a href="#utils-目录" class="headerlink" title="utils 目录"></a>utils 目录</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-utils-struct.jpg" alt></p><p>在 Redis 开发过程中，还有一些功能属于辅助性功能，包括用于创建 Redis Cluster 的脚本、用于测试 LRU 算法效果的程序，以及可视化 rehash 过程的程序。在 Redis 代码结构中，这些功能代码都被归类到了 utils 目录中统一管理。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Redis 源码的整体结构相对还是比较简单的，但定义的这些包结构涵盖了一个应用软件所具备的所有功能。通过本篇文章先从代码结构层面对 Redis 有个了解，后续将针对核心模块进行原理介绍，以及源码的阅读。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>笔者刚入门编程时学习的就是 C 语言，虽然掌握了 Redis 的核心模块的工作原理，但也只是停留在记忆和理解层面，也曾尝试过阅读 Redis 的源码，但并不系统。偶然的机会，看见极客时间推出的 Redis 源码课程，就决定重新对 Redis 源码进行梳理和补充，最终的目标就是 <strong>知其原理，懂其源码！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从本篇文章开始，将对 Redis 核心原理以及相关源码进行分析，需要说明的是，笔者阅读的 Redis 版本是 &lt;code&gt;#define R
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>限流算法</title>
    <link href="https://gentryhuang.com/posts/32609cb8/"/>
    <id>https://gentryhuang.com/posts/32609cb8/</id>
    <published>2021-11-23T16:00:00.000Z</published>
    <updated>2021-11-30T09:26:37.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>限流顾名思义是限制流量，目的是为了保障服务稳定运行，避免服务被流量冲垮。</p><p>为什么要限流？因为再厉害的系统总有所能承载的能力上限，一旦流量突破这个上限，就会引起实例宕机，进而发生系统雪崩，带来灾难性后果。限流是系统自我保护的最直接手段，当流量超出服务处理能力时，部分请求将会被限流组件拦截，根据具体业务场景选择丢失。</p><h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>计算器算法的思想很简单，每当一个请求到来时，就将计数器加一，当计数器数值超过阈值后，就拒绝接收到的请求。在指定周期内，计数器会重置，开始新一轮的计数。计数器算法简单粗暴，易于实现。但是缺点也是很大的，容易造成前一个时间段非常忙碌，下一时间段又非常空闲。</p><h2 id="漏通算法"><a href="#漏通算法" class="headerlink" title="漏通算法"></a>漏通算法</h2><p>漏桶算法由流量容器、流量入口和流量出口组成。流量入口一般就是业务请求，流量容器用于暂存一定大小的业务流量，流量出口则是我们设定的限速值，比如 1000 QPS。漏桶算法如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/current_limiting/current-limiting-bucket.png" alt></p><p>如上图，流入漏桶流量的流速是不可控的，但流出流量的速度是恒定的，而漏桶的容量是有限的，这就会导致一旦流入流量超出漏桶容量，这部分流量只能被丢弃了。</p><p>漏桶算法可以通过暂存一定的流量达到流量整形的目的，但是漏桶不能处理突发流量。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶和漏桶算法既有相似之处，又有很大的不同，不同之处也是令牌桶算法能够支持突发流量的原因。</p><p>令牌桶算法需要一个令牌工厂以一定周期向令牌桶中放入令牌，当令牌桶满了之后，多出的令牌会被丢弃。每当一个请求到来时都会先从令牌桶中取令牌，由于令牌桶中可能存放了很多令牌，因此允许多个请求同时取令牌，如果令牌够多就可以在一定程度上支持突发流量。当令牌桶中没有令牌后，无法获取到令牌的请求可以丢弃，或者重试。令牌桶算法如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/current_limiting/current-limiting-token.png" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章简单介绍了常见的三种限流算法，它们被落地到不同的实现中，如 Dubbo 中的 <code>TpsLimitFilter</code> 使用的就是计算器限流算法，Google 提供的 <code>RateLimiter</code> 开源包使用的是基于令牌桶算法。</p><p><strong>总体来说，限流既可以是在客户端限流，也可以是在服务端限流。此外，限流的实现方式既可支持 URL 以及方法级别的限流，也可支持基于 QPS 和线程的限流。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;限流顾名思义是限制流量，目的是为了保障服务稳定运行，避免服务被流量冲垮。&lt;/p&gt;
&lt;p&gt;为什么要限流？因为再厉害的系统总有所能承载的能力上限
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="限流" scheme="https://gentryhuang.com/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>并发 - JMM</title>
    <link href="https://gentryhuang.com/posts/11b0627b/"/>
    <id>https://gentryhuang.com/posts/11b0627b/</id>
    <published>2021-09-20T01:14:12.000Z</published>
    <updated>2022-01-07T07:54:44.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章将对 Java 的内存模型（JMM）进行介绍，本质上它是一种编程语言规范，用于尝试统一一个能够在各种处理器架构中为并发提供一致语义的内存模型（不同处理器架构一般具有不同强度的模型）。驱动 Java 内存模型产生的原因有很多，如编译器优化、处理器乱序执行和缓存等，这些因素导致并发程序中有些行为是非法的。因此，在介绍 Java 内存模型之前，我们先对并发编程相关概念进行说明，然后再引出 Java 内存模型。</p><h1 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h1><p>了解现代计算机硬件架构对理解 Java 内存模型非常重要，常见的硬件内存架构图如下：</p><p><img src="/posts/11b0627b/computer-hardware-memory-architecture.jpg" alt></p><p>下面我们重点对硬件内存架构的组成，缓存一致性问题进行介绍。</p><h2 id="硬件内存组成"><a href="#硬件内存组成" class="headerlink" title="硬件内存组成"></a>硬件内存组成</h2><p>现代计算机内存架构包括：多CPU、CPU寄存器、CPU缓存以及共享的内存。</p><p><strong>多CPU</strong></p><blockquote><p>现代计算机通常有 2 个或更多 CPU ，其中一些 CPU 可能具有多个核。当只有一个 CPU 时，要运行多个程序（进程）的话，就意味着要经常进行进程上下文切换。尽管单 CPU 是多核，也只是多个处理器核心，其他设备都是共用的，所以多个进程就必然要经常进行进程上下文切换，这个代价是很高的。</p></blockquote><p><strong>CPU多核</strong></p><blockquote><p>一个多核的 CPU 也就是一个 CPU 上有多个处理器核心。</p></blockquote><p><strong>CPU寄存器</strong></p><blockquote><p>每个 CPU 都包含一组寄存器，它们是 CPU 内存的基础。CPU 在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为 CPU 访问寄存器的速度远大于主存。</p></blockquote><p><strong>CPU缓存</strong></p><blockquote><p>每个 CPU 还可能有一个 CPU 缓存存储器层。事实上，大多数现代 CPU 都有一定大小的缓存层，位于 CPU 与主内存间的一种容量较小但速度很高的存储器，但通常不如访问其内部寄存器的速度快。由于 CPU 的速度远高于主内存，CPU 直接从主内存中存取数据要等待一定时间周期。CPU 缓存中保存着 CPU 刚用过或循环使用的一部分数据，当 CPU 再次使用该部分数据时可从缓存中直接获取, 减少了 CPU 的等待时间，提高了系统的效率。</p></blockquote><p>一些 CPU 可能有多个缓存层，具体如下：</p><blockquote><ul><li><strong>一级缓存(L1 Cache)</strong>: 容量最小，速度最快，每个核独有。针对指令和数据分为数据缓存和指令缓存</li><li><strong>二级缓存(L2 Cache)</strong>: 容量比 L1 大，速度比 L1 慢，每个核独有</li><li><strong>三级缓存(L3 Cache)</strong>: 容量最大，速度最慢，<strong>多个核共享</strong></li></ul></blockquote><p>由于Cache的容量很小，一般都是充分的利用局部性原理，按<strong>行/块</strong>来和主存进行批量数据交换，以提升数据的访问效率。</p><p><strong>内存</strong></p><blockquote><p>计算机还包含一个主存储区 (RAM)，所有 CPU 都可以访问它。主内存区域通常比 CPU 的高速缓存大得多。</p></blockquote><p><strong>读取数据</strong></p><blockquote><ul><li><strong>取寄存器中的值</strong>: 只需要一步，直接读取即可。</li><li><strong>取L1中的值</strong>: 先锁住<strong>缓存行</strong>，然后取出数据，最后解锁。如果没有锁住说明慢了。</li><li><strong>取L2中的值</strong>: 先到 L1 中取，L1 中不存在再到 L2 中取。L2 开始加锁，将 L2 中的数据复制到 L1 ，再执行从 L1 中读取数据的步骤，解锁 L2。</li><li><strong>取L3中的值</strong>: 同样地，先将数据由 L3 复制到 L2，然后从 L2 复制到 L1 ，从 L1 读取数据。</li></ul></blockquote><p>CPU 在读取数据时，先在 L1 中寻找，再从 L2 中寻找，再从 L3 中寻找，然后是内存，最后是外存储器。</p><h2 id="CPU优化手段"><a href="#CPU优化手段" class="headerlink" title="CPU优化手段"></a>CPU优化手段</h2><p>为了提高程序运行的性能，现代 CPU 在很多方面对程序进行了优化。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>CPU 高速缓存，尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存提高性能。</p><p><img src="/posts/11b0627b/cpu-cache-level.jpg" alt></p><h3 id="运行时指令重排"><a href="#运行时指令重排" class="headerlink" title="运行时指令重排"></a>运行时指令重排</h3><p>为了提高 CPU 处理性能，CPU 可能会乱序执行。如，当 CPU 写缓存时发现缓存曲块正被其它 CPU 占用，为了提高 CPU 处理性能，可能将后面的读缓存命令优先执行。</p><p><img src="/posts/11b0627b/cpu-command-process.jpg" alt></p><p>注意，CPU 指令重排并非随意重排，需要遵守 <strong>as-if-serial语义</strong> ，该语义表示：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，运行时和处理器都必须遵守 <strong>as-if-serial 语义</strong>。也就是说，编译器和处理器<strong>不会对存在数据依赖关系的操作做重排序</strong>。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>基于高速缓存很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题-<strong>缓存一致性(CacheCoherence)</strong>。缓存中的数据与主内存的数据并不是实时同步的，各 CPU（或 CPU 核）间缓存的数据也不是实时同步。也就是说，在同一个时间点，各 CPU 所看到同一内存地址的数据的值可能不一致。如，当多个处理器执行的任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，这样不一致的情况如果同步回主内存时以哪个处理为准呢？</p><p><img src="/posts/11b0627b/computer-hardware-memory-architecture-issue.jpg" alt></p><p>运行在左侧 CPU 上的一个线程将共享对象复制到其 CPU 缓存中，并将其count变量更改为 2。此更改对运行在右侧 CPU 上的其他线程不可见，因为更新的count尚未刷新回主内存.</p><h3 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h3><p>所有内存的传输都发生在一条共享的总线上，所有的处理器都会使用该总线。虽然 CPU 缓存各自是独立的，但是主存是共享的，所有的内存访问都要经过总线加锁机制来决定是否可以进行内存的读写，也就是说在同一个指令周期中，只可能有一个 CPU 可以读写内存。</p><p>所谓总线锁就是使用处理器提供的一个 <code>LOCK#信号</code> ，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，只有该处理器可以独占共享内存。</p><h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>总线锁虽然可以保证缓存数据的一致性，但是它比较粗暴，当某个 CPU 对总线进行加锁后，所有后续其它 CPU 对主存的操作都是阻塞的，这样机制就必定会降低性能。因此，缓存一致性协议出现了，它是硬件程序的产物，用来保证缓存之间可见。</p><p>缓存一致性协议有多种，如 <strong>MSI</strong>、<strong>MESI</strong> 等，多数 CPU 厂商对缓存一致性协议进行了实现。下面我们以 <strong>MESI</strong> 协议为例，对其进行介绍。</p><p><strong>MESI协议</strong>规定每个缓存行有个状态位，同时定义了下面四个状态：</p><h4 id="专有态-Exclusive"><a href="#专有态-Exclusive" class="headerlink" title="专有态(Exclusive)"></a>专有态(Exclusive)</h4><p>锁住的缓存行内容只存在当前 CPU 缓存中且同于主存，不出现于其它缓存中，所以当 CPU 发现自己缓存中的共享数据是<strong>专有态(Exclusive)</strong>时，说明该数据是最新的，可以直接读取。</p><p>当缓存行处于<strong>专有态(Exclusive)</strong>时，在任何时刻当有其它 CPU 缓存了该数据时，那么缓存行会由<strong>专有态(Exclusive)</strong>变成<strong>共享态(Shared)</strong>。</p><h4 id="共享态-Shared"><a href="#共享态-Shared" class="headerlink" title="共享态(Shared)"></a>共享态(Shared)</h4><p>锁住的缓存行同于主存，且该缓存行可能被多个 CPU 缓存，各个缓存与主内存数据一致，所以当 CPU 发现自己缓存中的共享数据是<strong>共享态(Shared)</strong>时，说明该数据是最新值，可以直接读取。</p><p>当缓存行处于<strong>共享态(Shared)</strong>时，当任一个 CPU 修改缓存行时，其它 CPU 中该缓存行变成<strong>无效态(Invalid)</strong>。</p><h4 id="修改态-Modified"><a href="#修改态-Modified" class="headerlink" title="修改态(Modified)"></a>修改态(Modified)</h4><p>锁住的缓存行已被修改（脏行），内容已不同于主存。该状态是一个中间状态，缓存行的数据需要在未来某个时间点写回主内存，当被写回主内存之后，该缓存行就会变成专有状态。</p><p>当 CPU 对缓存行进行修改时，变为<strong>修改态(Modified)</strong>，并且同时会向其他缓存了该数据的 CPU 缓存发送一条 Invalid 指令，告诉其他缓存自己对数据进行了修改，让它们把数据对应的缓存行置为<strong>无效态(Invalid)</strong>； 当收到其它 CPU 缓存 Invalid 指令的成功响应时，当前 CPU 缓存会就会把数据同步到主存里面去，然后自己的缓存行由<strong>修改态(Modified)</strong>变为<strong>专有态(Exclusive)</strong>，当有其他 CPU 缓存从主存中读取到了最新的数据时，数据状态会变为<strong>共享态(Shared)</strong>。</p><h4 id="无效态-Invalid"><a href="#无效态-Invalid" class="headerlink" title="无效态(Invalid)"></a>无效态(Invalid)</h4><p>当缓存行处于<strong>无效态(Invalid)</strong>时，说明对应的数据已经被其它 CPU 修改过了，当前锁住的缓存行无效，必须从主存中重新读取。</p><p>无效态(Invalid)是由于收到其它 CPU 发来的 Invalid 指令，收到该指令的 CPU 缓存会把对应的缓存行状态标记为<strong>无效态(Invalid)</strong>，所以当数据处于<strong>无效态(Invalid)</strong>时表示数据已经被别人修改了，当前数据是无效的。</p><p>多处理器时，单个 CPU 对缓存中数据进行改动需要通知给其他 CPU 。也就意味着在缓存一致性协议下，CPU 处理要控制自己的读写操作，还要监听（嗅探）其它 CPU 发出的通知，从而保证<strong>最终一致</strong>。</p><p>这里需要说明下，MESI协议可以在 CPU 修改数据时向其他 CPU 发送消息，但不会出现两个CPU同时修改数据，进而向其他CPU进行消息通知。这样的并发修改通过缓存锁定机制解决的，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性。只有在数据修改的时候才会需要加缓存锁，修改数据的时候先锁定缓存行，不让其他CPU同时修改，其他CPU读取数据是允许的。缓存是否失效是由缓存一致性协议来处理的，它解决一个 CPU 修改其它 CPU 看不到的问题。缓存锁解决几个 CPU 并发修改的问题。</p><p><strong>以下两种情况下处理器会使用总线锁：</strong></p><ul><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时</li><li>处理器不支持缓存锁定</li></ul><h4 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h4><p>前文在描述 MESI 协议时，如果对缓存行进行修改需要经历以下过程：</p><ol><li>某个CPU修改自己缓存的值</li><li>修改缓存后通知其它CPU，等待其它CPU响应</li><li>收到所有CPU的响应</li><li>将缓存中的数据同步到主存</li></ol><p>可以看到，以上整个过程都是同步的，CPU 发送完通知后必须同步等待所有其它 CPU 的响应，而这个过程中当前 CPU 又无法释放出来，所以为了避免这种 CPU 运算资源的浪费，就需要一种方式来进行优化了，此时 <strong>Store Buffer</strong> 就出来了。</p><p><img src="/posts/11b0627b/cpu-store-buffer.png" alt></p><p>当 CPU 对某个共享变量修改时，向其他 CPU 发出 Invalid 指令后不同步等待其他 CPU 指令的响应了，而是直接把最新值写入 Store Bufferes 缓冲区里，然后直接可以去干别的事情了，直到所有的 CPU 都对 Invalid 指令响应后，再把共享变量的值从 Store Buffere 里拿出来，然后写入到自己的缓存里同时同步到主存中。</p><h4 id="Store-Forward"><a href="#Store-Forward" class="headerlink" title="Store Forward"></a>Store Forward</h4><p>Store Forward 称为存储转发。具体是：当 CPU 读取数据时需要先检查它的 Store Buffer 缓冲区中有没有，如果有则直接读取该缓冲区中的值，没有才会读取自己缓存中的值。解决了 Store Buffer 优化过程中由于只读取缓存导致的缓存脏数据问题。</p><p><img src="/posts/11b0627b/cpu-store-buffer-forward.png" alt></p><p>至此，Store Buffer 优化提升了 CPU 效率。但由于修改共享变量先是放到了 Store Buffer 中，只有等到其它 CPU 返回 Invalid OK 后才会同步到缓冲和主存。可以看出执行写操作不是立即生效的，对于有相互依赖的共享数据相关指令，可能会出现CPU乱序执行的现象。解决手段是利用<strong>内存屏障</strong>禁用CPU缓存优化，也就是更新数据时必须立即更新到主存（也就是把store buffer里的指令全部执行完）。</p><h4 id="Invalid-Queue"><a href="#Invalid-Queue" class="headerlink" title="Invalid Queue"></a>Invalid Queue</h4><p>因为 Store Buffer 空间很小，如果有大量的变量修改，它会存储不下，那么这个时候又回到同步通知的状态。此外，有时候其它 CPU 很繁忙并不能马上进行响应，因此为了避免同步等待响应的时间太长，就为每个 CPU 加一个失效队列，当 Store Buffer 存不下的时候，就把失效通知发送到其它 CPU 的失效队列里，只要队列成功接收到了发送的消息就进行响应（发送 Invalid 指令的 CPU 就可以将修改同步到主存了），等到其他CPU闲下来了就从各自的失效队列里读取消息然后失效掉CPU的缓存数据。</p><p>MESI 优化到了 Invalid Queue 阶段，一般来说性能已经很高了，但是在极端的情况下会出现缓存可见性问题。具体来说就是，接收到 Invalid 指令的 CPU 没有来得及处理它的实效队列中的消息，没有及时失效掉对应的缓存行，导致继续使用了本应该失效的缓存数据。这种因为CPU缓存优化而导致后面的指令查看不到前面指令的执行结果，就好像指令之间的执行顺序错乱了一样，这类现象也就是我们俗称的<strong>CPU乱序执行</strong>。解决方法很简单，直接禁用 CPU 缓存优化即可，也就是修改共享数据的指令都同步完成就能保证数据的可见性了，但是这样又会降低整体的性能，这样有点得不偿失，因为毕竟大部分情况下数据都不存在这种共享的问题。不过我们必须要为这种场景提供一种手段来禁用CPU缓存优化，而这种手段同样也是<strong>内存屏障</strong>机制，读取数据时必须读取最新的数据（也就是必须先把失效队列的数据先读取应用完）。</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>前文我们说的内存屏障可以同时作用于 Store Buffer 和 Invalidate Queue 。而实际上，对于写操作只需关心 Store Buffer ，读操作只需关心 Invalidate Queue 。因此，大多数 CPU 架构将内存屏障分为了读屏障和写屏障。内存屏障本质上是 CPU 提供的一组指令，不同的操作系统有不同的实现。</p><p><strong>读屏障:</strong> 任何读屏障前的读操作都会先于读屏障后的读操作完成，即读屏障指令执行后就能保证后面的读取数据指令一定能读取到最新的数据。<br><strong>写屏障:</strong> 任何写屏障前的写操作都会先于写屏障后的写操作完成，即遇到写屏障指令就必须把该指令之前的所有写入指令执行完毕才可以往下执行，这样就可以让CPU修改的数据及时暴露给其它CPU。<br><strong>全屏障:</strong> 同时包含读屏障和写屏障的作用</p><p>实际的 CPU 架构中，可能提供多种内存屏障，常见的如下：</p><ul><li>LoadLoad: 相当于前面说的读屏障</li><li>LoadStore: 任何该屏障前的读操作都会先于该屏障后的写操作完成</li><li>StoreLoad: 任何该屏障前的写操作都会先于该屏障后的读操作完成</li><li>StoreStore: 相当于前面说的写屏障</li></ul><p>实现原理都是类似的，如作用于Store Buffer和Invalidate Queue 。</p><h3 id="指令重排问题"><a href="#指令重排问题" class="headerlink" title="指令重排问题"></a>指令重排问题</h3><p>CPU 指令重排虽然遵守了 <strong>as-if-serial</strong> 语义，但仅在单 CPU 执行的情况下能保证结果正确。在多核多线程中，指令逻辑无法分辨因果关联，为了更好地利用流水线可能出现<strong>乱序执行</strong>，导致程序运行结果错误。</p><p>前文中谈的是内存屏障的可见性功能，它能够让屏障前的操作（读/写）及时执行、刷新，被其它 CPU 看到。而内存屏障还有个功能就是限制指令重排（读/写指令），否则即使内存屏障可以保证可见性，但由于不能保证指令重排，保证可见性意义也不大。</p><p>也就是说，内存屏障提供了一套解决CPU缓存优化而导致的顺序性和可见性问题的方案，但是由于不同的硬件系统提供的内存屏障指令可能都不一样，因此像 JAVA 这种高级编程语言就把不同的内存屏障指令统一进行了封装，让开发者不需要关心到系统的底层，而封装这套解决方案的模型就是Java内存模型(Java Memory Model)。</p><p>注意，除了运行期间 CPU 的指令重排，编译器在编译期间，可能也对指令进行重排，以使其对CPU更友好。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>了解了硬件内存架构后，从本小节开始，我们简单聊聊并发。</p><h2 id="并发编程关键问题"><a href="#并发编程关键问题" class="headerlink" title="并发编程关键问题"></a>并发编程关键问题</h2><p>在并发编程中需要处理两个关键问题：线程之间如何通信及线程之间如何同步。</p><p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种，共享内存和消息传递。共享内存通信机制中，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行<strong>隐式通信</strong>。消息传递通信机制中，线程之间没有公共状态，线程之间必须通过发送消息来<strong>显式通信</strong>。</p><p>同步是指程序中用于控制不同线程间操作发生的相对顺序的机制。在共享内存并发模型中，同步是显式进行的，也就是说程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型中，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p>Java 的并发采用的是<strong>共享内存模型</strong>，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><h2 id="并发特性"><a href="#并发特性" class="headerlink" title="并发特性"></a>并发特性</h2><p>随着 CPU、内存、I/O设备都在不断迭代，不断朝着更快的方向努力的同时，有一个核心矛盾一直存在，那就是这三者的速度差异。为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统和编译程序都做出了贡献，具体体现为：</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异。</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O设备的速度差异。</li><li>编译程序优化指令执行次序</li></ul><p><strong>总结起来就是：</strong>硬件增加缓存、软件增加线程、编译程序优化指令顺序。</p><p>以上优化带来好处的同时，也给并发程序埋下了祸根。带来的问题可以总结为：</p><ul><li>缓存导致可见性问题 </li><li>线程切换导致原子性问题 </li><li>指令优化导致有序性问题</li></ul><p>下面我们对以上问题详细说明。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>。</p><p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。</p><p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存，它们是无法直接通信的。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一个或者多个操作在 CPU 执行的过程中不被中断的特性称为<strong>原子性</strong>。</p><p>Java 并发程序都是基于多线程的，自然会涉及到线程切换，切换的时机大多数是在时间片结束的时候。操作系统做任务切换，可以发生在任何一条<strong>CPU 指令</strong>执行完，注意是 CPU 指令而非高级语言中的一条语句，因为高级语言中的一条语句可能包含多条 CPU 指令。<strong>也就是说，CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言级别。因此，很多时候需要我们自己在高级语言层面保证操作的原子性</strong>。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性指的是程序按照代码的先后顺序执行。但编译器、处理器为了优化性能有时会改变程序执行的次序，而这也是导致问题的原因。</p><p>缓存、线程、编译优化的目的都是提高程序性能的，但是技术在解决一个问题的同时，可能会带来另外一个问题，所以在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避。</p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>Java 的内存模型（JMM）本质上是一种编程语言规范，屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 Java 程序员呈现了一个一致的内存模型。不同点在于，JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型。JMM 通过定义多项规则对编译器和处理器进行限制，主要围绕原子性、有序性、可见性展开，具体来说包括 <strong>volatitle、synchronized 和 fianl 这三个关键字，以及系列 happens-before 原则</strong>。</p><p><strong>注意：</strong>JVM 内存模型和 Java 内存模型是完全不同的两个东西。JVM内存模型是一种内存逻辑划分，便于JVM 管理内存；JMM内存模型是对计算机硬件（处理器模型）的统一抽象，用来屏蔽差异。</p><h2 id="细化规范"><a href="#细化规范" class="headerlink" title="细化规范"></a>细化规范</h2><p>JMM 描述了程序的可能行为，程序执行产生的结果都可以由内存模型预测，它决定了在程序的每个点上可以读取什么值（读写是相互的，也就是写了后，读必须要读取到，这就要求写必须刷新到主内存）。既然 JMM 是一种规范，就需要给 JVM 开发者和厂商实现，需要细化规范。</p><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>可以在线程之间共享的内存称为共享内存或堆内存。所有实例字段，静态字段和数组元素都存储在堆内存中。Java 内存模型的抽象示意图如下：</p><p><img src="/posts/11b0627b/jmm-model.jpg" alt></p><p>JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本，线程对变量的所有操作都必须在本地内存中进行，而不能直接操作主内存中的变量。注意，本地内存是 JMM 的一个抽象概念，并不真实存在。</p><p>如果线程 A 与线程 B 之间要通信的话，必须经历以下2个步骤：</p><ul><li>线程 A 把本地内存中更新过的共享变量刷新到主内存中去。</li><li>线程 B 到主内存中去读取线程 A 之前已更新过的共享变量</li></ul><p>关于主内存与本地内存之间的具体交互，即一个变量如何从主内存拷贝到本地内存、如何从本地内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成。  </p><blockquote><ol><li><strong>lock</strong>：作用于主内存，把变量标识为线程独占状态</li><li><strong>unlock</strong>：作用于主内存，解除独占状态</li><li><strong>read</strong>：作用主内存，把一个变量的值从主内存传输到线程的本地内存</li><li><strong>load</strong>：作用于本地内存，把 read 操作传过来的变量值放入本地内存的变量副本中</li><li><strong>use</strong>：作用本地内存，把本地内存当中的一个变量值传给执行引擎</li><li><strong>assign</strong>：作用本地内存，把一个从执行引擎接收到的值赋值给本地内存的变量</li><li><strong>store</strong>：作用于本地内存的变量，把本地内存的一个变量的值传送到主内存中</li><li><strong>write</strong>：作用于主内存的变量，把 store 操作传来的变量的值放入主内存的变量中</li></ol></blockquote><p>如果要把一个变量从主内存中复制到本地内存中，就需要按顺序地执行read和load操作， 如果把变量从本地内存中同步到主内存中，就需要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</p><p>如前所述，Java 内存模型和硬件内存架构是不同的。不管是本地内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一 个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。具体如下图所示：</p><p><img src="/posts/11b0627b/jmm-cpu-memory-relation.jpg" alt></p><p>当对象和变量可以存储在计算机中各种不同的内存区域时，可能会出现某些问题，两个主要问题是：</p><ul><li>线程更新（写入）共享变量的可见性</li><li>读取、检查和写入共享变量时的竞争条件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章将对 Java 的内存模型（JMM）进行介绍，本质上它是一种编程语言规范，用于尝试统一一个能够在各种处理器架构中为并发提供一致语义的
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JMM" scheme="https://gentryhuang.com/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>网络通信 - Reactor模型</title>
    <link href="https://gentryhuang.com/posts/ae5dbc38/"/>
    <id>https://gentryhuang.com/posts/ae5dbc38/</id>
    <published>2021-09-12T13:10:23.000Z</published>
    <updated>2021-09-12T05:53:02.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Reactor 模型是高性能网络系统实现高并发请求处理的一个解决方案，具体来说就是网络服务端处理高并发网络 IO 请求的一种编程模型。Reactor 编程模型具有以下特征：</p><ul><li><strong>三种事件类型：</strong>连接事件、读事件、写事件</li><li><strong>三种关键角色：</strong> Reactor、Acceptor、Handler </li></ul><p>Reactor 模型就是基于以上三种事件和三种角色来处理网络IO请求的，这就它工作的机制。</p><h1 id="演化"><a href="#演化" class="headerlink" title="演化"></a>演化</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-classic-service-design-.jpg" alt></p><p>上图是传统阻塞IO模型，每个处理程序在自己的线程中运行。</p><p><strong>缺点如下：</strong></p><p>每个连接都需要独立线程处理，当并发数大时会创建多个线程，过度消耗资源。由于每个连接都对应一个线程，当连接没有就绪时线程就会阻塞等待。</p><p><strong>优化方案：</strong></p><ul><li>基于 IO 多路复用模型，多个连接可以共用一个线程。</li><li>使用线程池，将业务逻辑交给线程池处理。</li></ul><p>基于以上问题，为了高效处理网络 IO 的事件，演化出了 Reactor 模型，该模型的思想就是基于IO多路复用和线程池的结合。</p><h1 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h1><p>Reactor 模型处理的是客户端和服务器端的交互过程，而<strong>连接事件</strong>、<strong>读事件</strong>、<strong>写事件</strong>对应了客户端和服务器端交互过程中不同类型的请求在服务器端引发的待处理事件。</p><p>具体引发的待处理事件如下：</p><ul><li>客户端向服务器端发送连接请求以建立连接，这对应了服务器端的一个<strong>连接事件</strong>。</li><li>连接建立后，客户端会给服务器端发送读或写请求，服务器端需要从客户端读取请求内容，这对应了服务器端的<strong>读事件</strong>。</li><li>服务器端在处理完请求后，需要向客户端写回数据，这对应了服务器端的<strong>写事件</strong>。</li></ul><h1 id="关键角色"><a href="#关键角色" class="headerlink" title="关键角色"></a>关键角色</h1><p>Reactor 模型中的不同类型事件的处理是由对应的角色完成的，三种关键角色的任务如下：</p><ul><li>Acceptor 用于处理客户端连接事件，负责接收连接。</li><li>Handler 用于处理读写事件。</li><li>Reactor 负责监听和分派事件。当有连接请求时，Reactor 将产生的连接事件交给 Acceptor 处理；当有读写请求时，Reactor 将读写事件交给 Handler 处理。</li></ul><p>需要注意的是，以上三种角色是 Reactor 模型中实现功能的<strong>抽象</strong>。遵循 Reactor 模型进行服务器端网络框架开发时，需要对 Reactor、Acceptor 以及 Handler 进行逻辑实现。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>根据 Reactor 的数量和处理资源的线程数量的不同，可以分为三类：</p><ul><li>单 Reactor 单线程模型</li><li>单 Reactor 多线程模型</li><li>多 Reactor 多线程模型</li></ul><p>下面依次介绍以上三种 Reactor 线程模型。</p><h2 id="单Reactor单线程模型"><a href="#单Reactor单线程模型" class="headerlink" title="单Reactor单线程模型"></a>单Reactor单线程模型</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-basic-design.jpg" alt></p><p>在单 Reactor 单线程模型下，监听、分派事件由 Reactor 完成，处理连接事件由 Acceptor 完成，处理读写事件和业务逻辑由 Handler 完成，但<strong>始终只有一个线程去完成所有的工作</strong>。</p><p><strong>缺点如下：</strong></p><ul><li>仅使用一个线程完成所有工作，不能充分利用多核机器资源</li><li>当处理任务导致线程负载过高，处理速度会下降，任务会堆积。请求并发量比较低的时候还是可以抗住的，一旦高并发可能将不堪重负</li><li>单线程不能保证可靠性</li></ul><h2 id="单Reactor多线程模型"><a href="#单Reactor多线程模型" class="headerlink" title="单Reactor多线程模型"></a>单Reactor多线程模型</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-worker-thread-pool.jpg" alt></p><p>单 Reactor 多线程模型下，不再采用所有工作都由 Reactor 线程独自完成。监听、分派事件由 Reactor 完成，处理连接事件由 Acceptor 完成，处理读写事件由 Handler 完成，这些操作由 Reactor 线程执行。<strong>对于业务逻辑的处理交给线程池（多线程），不再是 Reactor 线程</strong>。相比 单 Reactor 单线程模型，充分利用多核机器的资源、提高性能并且增加可靠性。</p><p><strong>缺点如下：</strong><br>Reactor 线程承担了所有事件的处理，没有解决高并发场景下单线程存在的性能问题。如并发太高，Reactor 线程来不及处理连接请求和读写数据。</p><h2 id="多Reactor多线程模型"><a href="#多Reactor多线程模型" class="headerlink" title="多Reactor多线程模型"></a>多Reactor多线程模型</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-multiple-reactor.jpg" alt></p><p>多 Reactor 多线程模型是将 Reactor 拆分成了 mainReactor 和 subReactor 两个部分。主要有一个 mainReactor，多个 subReactor 以及每个 subReactor 附带一个线程池。mainReactor 主要负责监听客户端的连接请求，当有连接请求到达会分派给 Acceptor（位于 mainReactor 中）处理，并将产生的连接信息交给 subReactor ，后续 subReactor 监听到读写事件后，分派给 Handler 处理，业务逻辑交给线程池处理。</p><h1 id="事件驱动框架"><a href="#事件驱动框架" class="headerlink" title="事件驱动框架"></a>事件驱动框架</h1><p>至此，我们已经了解了 Reactor 模型的组件和工作机制，但是 Reactor 中的角色和事件是怎么联动起来的呢？这就需要事件驱动框架了。</p><p>在实现 Reactor 模型时，利用事件驱动框架对整体流程进行控制。事件驱动框架在设计时包括但不限于以下内容：</p><ul><li>事件定义及初始化</li><li>事件监听、分派(分派给对应的程序处理)、处理</li><li>轮询（一般是循环逻辑）</li></ul><h2 id="事件初始化"><a href="#事件初始化" class="headerlink" title="事件初始化"></a>事件初始化</h2><p>Reactor 模型是基于事件和角色工作的，事件驱动框架的实现自然也离不开事件的定义以及初始化。事件初始化的作用主要是创建需要监听的事件类型，并为该类型事件关联对应的处理程序，也就是处理连接事件的 Acceptor、处理读写事件的 Handler以及处理业务逻辑的其它处理程序。</p><h2 id="事件分派、处理"><a href="#事件分派、处理" class="headerlink" title="事件分派、处理"></a>事件分派、处理</h2><p>监听、分派事件是由 Reactor 来完成的，在事件驱动框架中通常会用一个<strong>主循环程序</strong>实现。在这个主循环中，监听发生的事件，并根据事件类型将待处理的事件分派给与之关联的 Acceptor 和 Handler 处理。</p><h2 id="串联部件"><a href="#串联部件" class="headerlink" title="串联部件"></a>串联部件</h2><p>Reactor 模型的工作机制：客户端不同类型请求和服务器端结果处理会在服务器端触发连接、读、写事件，这三类事件的监听、分派和处理又是由 Reactor、Acceptor、Handler 三类角色来完成的，这三类角色会通过事件驱动框架来实现交互和事件处理。不难发现，实现一个 Reactor 模型的关键就是要实现一个事件驱动框架串联起 Reactor 所有部件。</p><p><strong>Reactor 模型的工作机制整体流程图如下：</strong></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-event-process.jpg" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Reactor 模型进行了介绍。先是对 Reactor 中涉及的部件及功能进行说明，接着对 Reactor 的演化进行了简单介绍，然后分别对不同种类的 Reactor 进行了逐一说明，最后介绍了事件驱动框架，它是串联 Reactor 模型下所有部件的关键程序。</p><p><strong>参考：</strong><br><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Reactor 模型是高性能网络系统实现高并发请求处理的一个解决方案，具体来说就是网络服务端处理高并发网络 IO 请求的一种编程模型。Rea
      
    
    </summary>
    
    
      <category term="网络通信" scheme="https://gentryhuang.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>并发 - ThreadLocal</title>
    <link href="https://gentryhuang.com/posts/151f44ae/"/>
    <id>https://gentryhuang.com/posts/151f44ae/</id>
    <published>2021-09-03T04:30:12.000Z</published>
    <updated>2021-09-13T15:06:41.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ThreadLocal 提供了线程局部变量，它是将线程需要访问的数据存储在线程对象自身中，从而避免多线程的数据竞争问题。ThreadLocal 实现原理如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-struct.png" alt></p><p>理解 ThreadLocal 原理，其实就是理解 <strong>Thread</strong>、<strong>ThreadLocal</strong> 以及 <strong>ThreadLocalMap</strong> 三者之间的关系。线程类 Thread 内部持有 ThreadLocalMap 的成员变量，而 ThreadLocalMap 是 ThreadLocal 的内部类，ThreadLocal 对外暴露操作数据的 API 都是操作 ThreadLocalMap 中的数据。<strong>总得来说，线程 Thread 在向 ThreadLocal 中设置值时，其实都是向自己所持有的 ThreadLocalMap 中设置数据；读的时候同理，先是从线程自身中取出持有的 ThreadLocalMap ，然后再根据 ThreadLocal 引用作为 key 取出对应的元素 Entry 进而取出 value</strong>。因此 ThreadLocal 可以轻松实现变量的线程隔离，毕竟变量都是维护在各个线程中的，自然没有竞争。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>根据前文中的 ThreadLocal 实现原理图可以发现 ThreadLocal 是 Thread 使用的一个工具，下面我们剥离出 Thread 中相关 ThreadLocal 信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 与此线程相关的 ThreadLocal 值，这个映射由 ThreadLocal 类维护 */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 与此线程相关的 InheritableThreadLocal 值。这个映射由 InheritableThreadLocal 类维护。*/</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread 中维护了两个 ThreadLocalMap 类型的变量，<strong><code>threadLocals</code> 用于存储当前线程使用的 ThreadLocal 相关信息；<code>inheritableThreadLocals</code> 用于存储当前线程使用的 InheritableThreadLocal 相关信息。使用 InheritableThreadLocal 可以实现多个线程访问 ThreadLocal 的值，即父线程中创建一个 InheritableThreadLocal 的实例，然后在子线程中就可以得到这个 InheritableThreadLocal 中设置的值</strong>。关于共享线程的 ThreadLocal 数据将在下面的内容中分析。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><strong>ThreadLocal 相关的 UML 类图如下所示：</strong></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-uml.jpg" alt></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1 作为 ThreadLocal 实例的变量，私有、不可变。每当创建 ThreadLocal 时这个值都会累加 HASH_INCREMENT</span></span><br><span class="line"><span class="comment">    * 2 主要为了多个 ThreadLocal 实例的情况下，让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二进制：-10011110001101110111100110111001</span></span><br><span class="line"><span class="comment">    * 十进制：-2654435769</span></span><br><span class="line"><span class="comment">    * 说明：</span></span><br><span class="line"><span class="comment">    * 1 Entry[] table 的大小必须是 2^N，那 2^N-1 的二进制表示就是低位连续的N个1，</span></span><br><span class="line"><span class="comment">    * 2 key.threadLocalHashCode &amp; (len-1) 的值就是 threadLocalHashCode 的低 N 位，这里使用位运算实现取模，和 HashMap 计算下标类似</span></span><br><span class="line"><span class="comment">    * 3 要求 threadLocalHashCode 的值要均匀，这里给出 0x61c88647 就能达到。</span></span><br><span class="line"><span class="comment">    * 原因：</span></span><br><span class="line"><span class="comment">    * 取该值与fibonacci hashing(斐波那契散列法)以及黄金分割有关，目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是Entry[] table中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 作为 ThreadLocal 类变量</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 基于当前 ThreadLocal ，下一个要给出的哈希码，自动更新，从 0 开始计数。</span></span><br><span class="line"><span class="comment">    * 每次获取当前值并加上固定的 HASH_INCREMENT</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回下一个 ThreadLocal 的 hash</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 关键属性分为两类。一类是 ThreadLocal 实例变量，另一类是 ThreadLocal 类变量。其中类变量在 ThreadLocal 类加载过程就进行初始化，也就是 <code>nextHashCode</code> 的初始化，后续实例变量 <code>threadLocalHashCode</code> 随着对象的创建而调用 <code>nextHashCode</code> 方法进行赋值，可以看出每次递增为 <strong>HASH_INCREMENT</strong> ，至于为什么选择这个值，是和斐波那契散列法以及黄金分割有关，目的就是为了让哈希码能均匀的分布在 2^n 次方的数组里，这个和 HashMap 中 hash 实现目的是一致的。</p><p>了解了核心属性后，下面以几个方法做为入口分析 ThreadLocal 源码。</p><h3 id="Set-方法"><a href="#Set-方法" class="headerlink" title="Set 方法"></a>Set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置当前线程变量的值 value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据当前线程获取其成员变量 threadLocals 所指向的 ThreadLocalMap 对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 判断当前线程的 ThreadLocalMap 是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 3.1 如果不为空，说明当前线程内部已经有ThreadLocalMap对象了</span></span><br><span class="line">            <span class="comment">// 那么直接将当前对应的 ThreadLocal 对象的引用作为键，存入的 value 作为值存储到 ThreadLocalMap 中</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 3.2 创建一个 ThreadLocalMap 对象并将值存入到该对象中，并赋值给当前线程的threadLocals成员变量</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>ThreadLocal 中的增、删、查方法基本都会有三个步骤。下面对 Set 方法进行小结:</strong></p><blockquote><ol><li>获取当前线程</li><li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li><li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 set 方法放入数据，映射表不存在则先创建映射表再放入数据</li></ol></blockquote><h3 id="Get-方法"><a href="#Get-方法" class="headerlink" title="Get 方法"></a>Get 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程的线程副本变量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据当前线程获取其 ThreadLocalMap 实例</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果当前线程的 ThreadLocalMap 不为空</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T) e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果当前线程的 ThreadLocalMap 为空或 ThreadLocalMap 中没有当前 ThreadLocal 对应的元素，则调用 initialValue() 方法初始化值</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对 Get 方法进行小结:</strong></p><blockquote><ol><li>获取当前线程</li><li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li><li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 getEntry 方法查询数据；映射表不存在或从映射表中没有找到当前 ThreadLocal 对应的元素，则调用 setInitialValue 方法完成映射表的创建或初始值的获取</li></ol></blockquote><p>Get 方法相比 Set 方法会涉及查询不到元素的情况，如果当前线程持有的映射表还没有或者找不到元素，那么 ThreadLocal 会尝试以初始化值的方式进行兜底处理，初始值的情况通过方法 <code>initialValue()</code> 交给具体实现。</p><h4 id="setInitialValue-方法"><a href="#setInitialValue-方法" class="headerlink" title="setInitialValue 方法"></a>setInitialValue 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置初始化值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 调用 initialValue() 方法获取指定的初始化值，默认为 null</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取当前线程的 ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果 ThreadLocalMap 不为空，则直接将初始值设置到 ThreadLocalMap 中</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 如果 ThreadLocalMap 为空，则创建 ThreadLocalMap 对象，并设置初始值</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化值，子类覆盖</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Remove-方法"><a href="#Remove-方法" class="headerlink" title="Remove 方法"></a>Remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程持有的 ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 删除 ThreadLocalMap 中当前 ThreadLocal 相关的信息</span></span><br><span class="line">        <span class="comment">// 包括清理对应的引用和值</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对 Remove 方法进行小结:</strong></p><blockquote><ol><li>获取当前线程</li><li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li><li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 remove 方法根据当前 ThreadLocal 清理对应数据，可以防止内存泄漏</li></ol></blockquote><h3 id="createMap-方法"><a href="#createMap-方法" class="headerlink" title="createMap 方法"></a>createMap 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为线程 t 初始化 ThreadLocalMap 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t          当前线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>线程中的 ThreadLocalMap 使用的是延迟初始化，即第一次调用 get() 或者 set() 方法的时候才会进行初始化。</p><h3 id="getMap-方法"><a href="#getMap-方法" class="headerlink" title="getMap 方法"></a>getMap 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">// 返回线程 t 的 threadLocals</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于获取每个线程持有自身的 ThreadLocalMap 实例，因此它们是不存在并发竞争的，这就是我们说的每个线程都有自己的变量副本。</p><p>至此，ThreadLocal 相关属性以及暴露的方法已经分析完毕。可以看出，ThreadLocal 中并没有持有 ThreadLocalMap 的引用，该引用是在 Thread 类中。此外，ThreadLocal 暴露的 API 操作都是基于 ThreadLocalMap 的。因此，我们理解了 ThreadLocalMap 才算是掌握了 ThreadLocal 。下面我们重点对 ThreadLocalMap 进行分析。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，本质上是一个 Map ，和 HashMap 类似，依然是 key-value 的形式，具体由 Entry 结构封装。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-map-struct.jpg" alt></p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储数据的 Entry 数组，长度是 2 的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中元素的个数，初始值为 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组扩容阈值，默认为0，创建了 ThreadLocalMap 对象后会被重新设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置调整大小阈值，以保持在最坏 2/3 的负载因子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ThreadLocalMap使用 开放地址法-线性探测法 来解决哈希冲突 */</span></span><br><span class="line"><span class="comment">// 向后一个位置找，注意从头开始的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向前一个位置找，注意跳到尾部的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体属性类似 HashMap ，各个值的含义已经详细注释就不再说明。需要注意的是，由于 ThreadLocalMap 使用的是线性探测法解决 hash 冲突，因此定义向前和向后探测的方法以便于寻找合适的位置及定位元素。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 与传入 ThreadLocal 关联的值，也就是线程局部变量值</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Entry的 key 是对 ThreadLocal 的弱引用，当抛弃掉 ThreadLocal 对象时，垃圾收集器会忽略这个 key 的引用而清理掉 ThreadLocal 对象。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一个线程可以使用多个 ThreadLocal 将不同的值存储到当前线程的 ThreadLocalMap 中。熟悉 HashMap 存储结构的可以发现，ThreadLocalMap 中的存储结构有两大不同点：</p><ul><li>没有链表相关的指针，更没有树节点的左右链接</li><li>元素节点结构 Entry 继承了 <code>WeakReference</code> 类，以实现弱引用功能</li></ul><p>作为一个映射表，必然会有元素冲突的可能，虽然和 HashMap 结构类似，但是没有 HashMap 中链表和树形结构，那么 ThreadLocalMap 是怎么解决 hash 冲突的呢？答案是<strong>线性探测法</strong>。关于 Entry 继承 <code>WeakReference</code> 的原因我们在后面的文章中进行分析。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstKey   ThreadLocal 引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue 设置的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">// 1 初始化 Entry 数组，大小为 16</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取 ThreadLocal 的 hash 值(该值是累加的)</span></span><br><span class="line">        <span class="comment">// 计算当前 key 对应的数组下标位置， 和 HashMap 的位运算代替取模原理一样</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 将 Entry 对象存入到数组指定的位置</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 记录数组元素个数</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 初始化扩容阈值</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当线程 Thread 持有的 ThreadLocalMap 还没有初始化时，在使用 ThreadLocal 存储或获取数据时都会先创建一个 ThreadLocalMap 对象然后挂载到当前线程 Thread 上，后续不管该线程使用了多少个 ThreadLocal ，都会使用创建的 ThreadLocalMap 进行储存相应值，有冲突就使用<strong>线性探测法</strong>解决。</p><p>了解了 ThreadLocalMap 的底层数据结构后，下面我们依然从它的核心操作方法出发分析底层实现。</p><h3 id="getEntry-方法"><a href="#getEntry-方法" class="headerlink" title="getEntry 方法"></a>getEntry 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取与 key 关联的 Entry</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 根据 key 计算下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 根据下标获取 Entry</span></span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 通过下标直接得到的 Entry 不是要找的，那么就线性探测找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>获取线程局部变量值的 getEntry 方法是 ThreadLocal 暴露的 get() 方法的底层实现，它的主要流程如下：</p><ul><li>根据 ThreadLocal 引用计算对应的数组下标，这个和 HashMap 类似</li><li>根据计算得到的下标尝试直接获取对应的 Entry，如果当前 Entry 为空或对应的 key 不是当前传入的 key ，那么进行线性探测获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * getEntry方法的版本，用于在键未在其直接散列槽中找到时使用。</span></span><br><span class="line"><span class="comment">         * 注意，该方法会清理无效 Entry</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i   the table index for key's hash code</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e   the entry at table[i]</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 线性探测</span></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取 Entry 的 key</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.1 命中，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="comment">// 2.2 无效 Entry，执行连续段删除</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3 获取下个位置</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3 遍历完也没查到，返回 null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>之所以要进行线性探测获取其实是和链表查询一样，可能目标元素由于 hash 冲突放到了后续位置。<strong>注意：查询流程也就是 get() 方法可能也会清理无效的元素，以防止内存泄漏，但不能保证</strong>。关于连续段清理无效元素逻辑暂略过。</p><h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置与 key 关联的值</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * ThreadLocal 的 set 方法，就是为了将指定的值存入到指定线程的 ThreadLocalMap 对象中，具体还是通过 ThreadLocalMap 的 set 方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key   the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 获取数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 计算当前 ThreadLocal 对象引用作为键在数组中的下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 根据获取到的下标进行线性探测，寻找空的位置。</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 中的 key ，即 ThreadLocal 的引用，注意是弱引用。</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 判断和当前的 ThreadLocal 对象是否是同一个对象，如果是，那么直接进行值替换，并结束方法，</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.3 判断当前 Entry 是否失效，即是否被回收（弱引用），如果失效，说明当前位置可以重新使用，就使用新的 key-value 将其替换</span></span><br><span class="line">                <span class="comment">// 该过程还会进行连续段删除其它无效的 entry</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 找到某个空位置，直接将键值对设置到该位置上。</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 尝试随机清理无效 entry ，如果没有可清理的 entry 且数组元素大小 &gt;= 扩容阈值，则进行 rehash</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>设置线程局部变量值的 set 方法稍微复杂点，下面对其主要流程进行说明：</strong></p><blockquote><ol><li>根据传入的 key 计算数组下标位置</li><li>根据计算得到的下标进行线性探测，寻找空的位置以存放元素<ul><li>检测到存在相同 key 的元素，进行值覆盖，然后结束流程即可</li><li>检测到无效的元素，则重用无效元素位置，并尝试清理无效的元素</li><li>在某个空位置存放数据</li></ul></li><li>如果不是值覆盖或重用无效元素位置的情况，那么需要判断是否需要 rehash  </li></ol></blockquote><p>下面我们对上述关联的核心方法进行拆解分析。</p><h4 id="replaceStaleEntry-方法"><a href="#replaceStaleEntry-方法" class="headerlink" title="replaceStaleEntry 方法"></a>replaceStaleEntry 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 替换无效 Entry ，并尝试删除其它无效的 Entry。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> staleSlot 无效 entry 的位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标志 Table 中是否存在无效 Entry。slotToExpunge != staleSlot 说明 table 中存在无效 Entry 需要进行清理，否则说明没有。</span></span><br><span class="line">            <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 根据传入的无效 Entry 的位置 staleSlot 向前扫描一段连续非空的 Entry ，并记录最后一个无效的 Entry 的位置。或者扫描完也没有找到。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = prevIndex(i, len))</span><br><span class="line">                <span class="comment">// 2.1 如果是无效 Entry ，则更新删除标记 slotToExpunge</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 根据传入的无效 Entry 向后扫描一段连续的 Entry（根据线性探测，具有相同的 key 的元素一定是从后找的） ,以寻找是否有相同 key 的 Entry，以及在需要时更新删除标记位 slotToExpunge</span></span><br><span class="line">            <span class="comment">// 找到相同 key 的元素或末尾的空槽，以最先出现的为准</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 的 key</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 如果找到了具有相同的 key ，则更新其值。也就是更新其值并将其与传入的无效 Entry 替换，即与 table[staleSlot] 进行替换</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    <span class="comment">// 3.2.1 更新为传入的 value</span></span><br><span class="line">                    e.value = value;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.2.2 使用相同 key 的 Entry 重用失效位置以避免新创建一个 Entry，以维持散列表的顺序。</span></span><br><span class="line">                    tab[i] = tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.2.3 如果向前查找没有找到无效的 Entry，则更新删除标记位 slotToExpunge 为当前位置 i，此时 i 位置对应的是无效 Entry</span></span><br><span class="line">                    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                        slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.3.4 将新过时的槽或在其上面遇到的任何其他过时槽发送到expungeStaleEntry，以删除或重新散列运行中的所有其他条目。</span></span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果向前查找没有找到无效 entry，并且当前向后扫描的entry无效，则更新 slotToExpunge 为当前值 i</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 执行到这里，说明 table 中不存在相同 key 的 Entry，此时只需直接重用无效位置即可</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 slotToExpunge != staleSlot 说明 table 中存在无效 Entry 需要进行清理</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>重用无效 Entry 位置有两种可能：</strong></p><ul><li>如果扫描到的 Table 中存在和要插入的 key 相同的 Entry，那么就使用更新 value 后的该 Entry 替换无效 Entry 以避免新创建 Entry，同时该 Entry 成为了无效 Entry，只需等待后续删除即可。</li><li>如果扫描到的 Table 中不存在和要插入的 key 相同的 Entry ，那么直接创建 Entry 替换无效 Entry 即可。</li></ul><p>此外，上述方法还会对无效 Entry 进行清理，触发条件就是检测到其它无效 Entry 的存在。</p><h4 id="rehash-操作"><a href="#rehash-操作" class="headerlink" title="rehash 操作"></a>rehash 操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * rehash 操作</span></span><br><span class="line"><span class="comment">         * 1 扫描整个 Table ，删除无效的 Entry</span></span><br><span class="line"><span class="comment">         * 2 执行清理后，如果还需要扩容，则将表扩大一倍</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 清理所有无效 Entry</span></span><br><span class="line">            expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  2 threshold - threshold / 4 = 1en / 2，降低扩容阈值是因为上面做了一次全清理 size 可能会减小</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Table 容量扩大为原来 2 倍</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] oldTab = table;</span><br><span class="line">            <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 容量扩大为原来 2 倍</span></span><br><span class="line">            <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">            Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 重新映射旧数组中的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">                Entry e = oldTab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 清理无效 Entry</span></span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 线性探测重新设置值</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, newLen);</span><br><span class="line">                        newTab[h] = e;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 设置新的阈值</span></span><br><span class="line">            setThreshold(newLen);</span><br><span class="line">            size = count;</span><br><span class="line">            table = newTab;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>新增数据后，如果达到阈值就会触发 rehash 流程，进行<strong>数组扩容和数据重新映射</strong>，这个没什么可说的。</p><h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 计算 key 对应的下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 进行线性探测，查找正确的 Entry</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到对应的 Entry</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    <span class="comment">// 调用 WeakReference.clear() 方法清除对应的引用</span></span><br><span class="line">                    e.clear();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 连续段删除 Entry</span></span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上述方法是 ThreadLocal 暴露的 remove() 方法的底层实现，用来清理当前 ThreadLocal 关联的信息。具体清理信息如下：</p><ul><li>清除对当前 ThreadLocal 的弱引用</li><li>清除当前 ThreadLcoal 对应的 Entry 中的 value </li><li>清除当前 ThreadLocal 对应的 Entry </li></ul><h3 id="expungeStaleEntry-方法"><a href="#expungeStaleEntry-方法" class="headerlink" title="expungeStaleEntry 方法"></a>expungeStaleEntry 方法</h3><p>expungeStaleEntry 方法用于彻底删除指定位置的 Entry 所以信息，接着向后连续段扫描删除无效 Entry ，并对可能存在 hash 冲突的 Entry 进行 rehash 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除过期的元素，是连续段方式的删除</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 清理 staleSlot 位置的无效 Entry ，并递减元素个数</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 从 stateSlot 开始向后扫描一段连续的非空的 Entry</span></span><br><span class="line">            <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 的 k</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 如果遇到key为null,表示无效entry，进行清理.</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// value 置空</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 元素置空</span></span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 元素个数递减</span></span><br><span class="line">                    size--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.3 如果 key 不为 null ，则对可能存在 hash 冲突的 Entry 进行 rehash</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 计算 key 对应的下标，如果与现在所在位置不一致，认为存在 hash 冲突，置空当前 table[i] ，</span></span><br><span class="line">                    <span class="comment">// 并从 h 开始向后线性探测到第一个空的 slot，把当前的 entry 移动过去。</span></span><br><span class="line">                    <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                        tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                        <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                        <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        tab[h] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下一个为空的下标</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于删除过期的元素，具体删除策略如下：</p><ul><li>根据传入的 stateSlot 清理对应的无效 Entry，这个是绝对删除。</li><li>根据传入的 stateSlot 向后扫描一段连续非空的 Entry ，对可能存在 hash 冲突的 Entry 进行 rehash ，并且清理遇到的无效 Entry 。</li></ul><h3 id="expungeStaleEntries-方法"><a href="#expungeStaleEntries-方法" class="headerlink" title="expungeStaleEntries 方法"></a>expungeStaleEntries 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描整个 Table ，删除无效的 Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="comment">// 无效 Entry ，则调用 expungeStaleEntry 方法删除对应位置及连坐删除 Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是在 expungeStaleEntry 方法的基础上，对整个 Table 中无效元素进行清理，一定会清理截止到当前 Table 中所有的无效 Entry 。需要说明的是，ThreadLocal 的所有一些列操作都是单线程的，也就是当前线程。</p><h3 id="cleanSomeSlots-方法"><a href="#cleanSomeSlots-方法" class="headerlink" title="cleanSomeSlots 方法"></a>cleanSomeSlots 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 启发式的扫描清除，扫描次数由传入的参数n决定</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i 从i向后开始扫描（不包括i，因为索引为i的Slot肯定为null）</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> n  控制扫描次数，正常情况下为 log2(n) ，如果找到了无效 Entry ，会将 n 重置为 table 的长度 len 进行阶段删除</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> true if any stale entries have been removed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 删除标志</span></span><br><span class="line">            <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 i 位置向后遍历，删除无效的 Entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">                Entry e = tab[i];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前 Entry 无效，则进行清理并进行连坐</span></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    n = len;</span><br><span class="line">                    removed = <span class="keyword">true</span>;</span><br><span class="line">                    i = expungeStaleEntry(i);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 无符号的右移动，可以用于控制扫描次数在log2(n)</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> removed;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>启发式扫描删除具有随机性，启发式思想也用在其他代码中，如 Redis 中的定期删除逻辑。</p><p>自此，ThreadLocalMap 的源码实现分析完毕。</p><h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><p>一般来说 ThreadLocal 数据都是线程独享的，但是 ThreadLocal 继承体系支持子线程共享父线程的变量副本数据。共享线程的 ThreadLocal 数据可以使用 <strong>InheritableThreadLocal</strong> 来实现。通过在父线程中创建一个 <strong>InheritableThreadLocal</strong> 的实例，然后在子线程中就可以获取该实例中设置的值。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 创建 InheritableThreadLocal 对象</span></span><br><span class="line">    ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 创建的 ThreadLocalMap 挂载到当前 Thread 的 inheritableThreadLocals 属性</span></span><br><span class="line">    threadLocal.set(<span class="string">"小芒果!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 创建并启动子线程</span></span><br><span class="line">    Runnable runnable = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 打印子线程 ThreadLocal 的线程变量值</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt; "</span> + threadLocal.get());</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印父线程（这里是主线程） ThreadLocal 的线程变量值</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt; "</span> + threadLocal.get());</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main-&gt; 小芒果!</span><br><span class="line">Thread-0-&gt; 小芒果!</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>线程变量传递逻辑很简单，它隐藏在 Thread 的 init 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- Thread</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 获取初始化当前线程的线程</span></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果 parent 线程使用了 InheritableThreadLocal ，那么就把 parent 的 inheritableThreadLocals 给当前线程的 inheritableThreadLocals 。</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 设置到当前线程的 inheritableThreadLocals 属性中</span></span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从线程初始化逻辑中可以看出，如果父线程 ThreadLocalMap 类型的变量 <code>inheritableThreadLocals</code> 不为空，那么就把父线程的该属性设置给当前线程的 <code>inheritableThreadLocals</code> 属性。具体设置逻辑在 ThreadLocal 的 createInheritedMap 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">// 继承式创建 ThreadLocal</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅由 createInheritedMap 方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocal.ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取 parentMap 的 Table 信息</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建新的 Table</span></span><br><span class="line">        table = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 将 parentMap 中的数据依次映射到新创建的 Table 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 3.1 获取当前 Entry</span></span><br><span class="line">            ThreadLocal.ThreadLocalMap.Entry e = parentTable[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 获取 Entry 中的 key</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.3 Entry 有效的话就进行映射</span></span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 用于获取父线程变量值的转换，默认就是父线程 Entry.value 值</span></span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 线性探测存储元素</span></span><br><span class="line">                    ThreadLocal.ThreadLocalMap.Entry c = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line">                    <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line"></span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过以上逻辑可以发现，如果要使用线程变量共享需要使用到 <strong>InheritableThreadLocal</strong> 类，线程 Thread 的映射属性使用 <code>inheritableThreadLocals</code> 而非 <code>threadLocals</code> 。</p><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认是 Entry 的 value 值，使用方可继承 InheritableThreadLocal 覆盖该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentValue the parent thread's value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the child thread's initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程 t 的 ThreadLocalMap ，注意取的是 inheritableThreadLocals 属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建当前线程 t 的 ThreadLocalMap ，注意设置的是 inheritableThreadLocals 属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InheritableThreadLocal 继承了 ThreadLocal ，重写了以上三个方法，主要是将映射表挂在到 Thread 的 <code>inheritableThreadLocals</code> 属性上，用以实现线程变量的共享。注意，线程变量独享使用的是 Thread 中的 <code>threadLocals</code> 属性。InheritableThreadLocal 对比 ThreadLocal 唯一不同是子线程会继承父线程变量，并支持自定义赋值函数。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>ThreadLocalMap 使用 ThreadLocal 的弱引用做为元素 Entry 的 key ,如果一个 ThreadLocal 没有外部强引用来引用它，那么系统 GC 时这个 ThreadLocal 会被回收。此时，ThreadLocalMap 中就会出现 key 为 null 的 Entry ，这样就没有办法访问这些 Entry，这些 Entry 理论上属于无效的，应该被 GC 回收。但是，如果存在持有这些 Entry 的线程迟迟不结束（如使用线程池），那么这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链 <strong>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</strong>，导致无法回收，造成内存泄漏。</p><p>ThreadLocal 为了尽可能避免内存泄漏问题，在 <code>get()</code>、<code>set()</code> 以及 <code>remove()</code> 方法中都有清除线程的 ThreadLocalMap 中 key 为 null 的 value 逻辑。<strong>注意，其中 get()、set() 两个方法都不能完全防止内存泄漏，存在无效 Entry 无法扫描到的情况，因为只有在线性探测流程中才会尝试连续段清理无效 Entry 。最好的方式是每次使用完 ThreadLocal 都手动 remove 一下</strong>。</p><p>此外，以下措施会增加内存泄漏的风险：</p><ul><li>使用 static 的 ThreadLocal ，这种方式延长了 ThreadLocal 的生命周期</li><li>分配使用了 ThreadLocal ，而不再调用其 <code>get()</code>、<code>set()</code> 以及 <code>remove()</code> 方法</li></ul><h2 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h2><ul><li><strong>key 使用强引用：</strong>ThreadLocal 对象没有外部引用，但是 ThreadLocalMap 持有 ThreadLocal 的强引用，如果没有手动删除，ThreadLocal 不会被回收，这会导致 Entry 内存泄漏。</li><li><strong>key 使用弱引用：</strong>ThreadLocal 对象没有外部引用，由于 ThreadLocalMap 持有 ThreadLocal 的弱引用，即使没有手动删除，ThreadLcoal 也可以被回收。value 在下一次执行方法时被清除。 </li></ul><p>Entry 继承 WeakReference，并且使用 ThreadLocal 的弱引用作为 key，这样可以将 ThreadLocal 对象的生命周期和线程生命周期解绑。持有弱引用可以使得 ThreadLocal 在没有其他强引用的时候被回收掉，这样可以避免因为线程得不到销毁导致 ThreadLocal 对象无法被回收。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>每次使用完 ThreadLocal 都应该调用它的 remove() 方法，进行数据清理，防止内存泄漏。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>多线程之间需要拥有同一个信息，那么通常可以采用 <code>initialValue()</code> 方法进行初始化，直接将需要拥有的变量副本存储到 ThreadLocal 中。</li><li>多个线程中存储不同的信息，那么需要使用 set() 方法设置变量副本到 ThreadLocal 中。</li></ul><p>上述描述<strong>存储到 ThreadLocal 中</strong>是不对的，需要注意，数据其实是存储到线程持有的 ThreadLocalMap 对象中，该对象是一个散列表。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 ThreadLocal 进行了深入的分析，它能保证数据安全是因为每个线程都有自己的线程变量，不会发生多个线程共享变量的情况。首先对 ThreadLocal 的关系进行了介绍，从总体上认识 ThreadLocal 。接着对 ThreadLocal 进行了分析，从其属性到暴露的 API 。然后对 ThreadLocal 底层的支持类 ThreadLocalMap 进行了分析，同样从属性到支撑上层的方法的分析。最后对父子线程就 ThreadLocal 如何共享线程变量进行了分析。在文章的最后，对内存泄漏问题进行了介绍。</p><p><strong>参考资料</strong><br><a href="https://www.cnblogs.com/lqlqlq/p/13302901.html" target="_blank" rel="noopener">https://www.cnblogs.com/lqlqlq/p/13302901.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;ThreadLocal 提供了线程局部变量，它是将线程需要访问的数据存储在线程对象自身中，从而避免多线程的数据竞争问题。ThreadLoca
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="Thread" scheme="https://gentryhuang.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Java基础 - Reference</title>
    <link href="https://gentryhuang.com/posts/55ae5a2b/"/>
    <id>https://gentryhuang.com/posts/55ae5a2b/</id>
    <published>2021-08-21T02:30:12.000Z</published>
    <updated>2021-09-13T15:06:20.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 Java 中有 4 种引用类型，主要是在垃圾回收时 JVM 会根据不同的引用类型采取不同的措施。下面分别对这四种类型进行说明，特别是弱引用，将会结合示例进行分析。</p><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>Java 中的四种引用类型如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/reference/java-reference-uml.jpg" alt></p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用是 Java 默认的引用类型。如果一个对象具有强引用，当内存空间不足时，JVM 宁可抛出 <strong>OutOfMemoryError</strong> 错误使程序异常终止，也不会回收具有强引用的对象来解决内存不足问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，在一个方法中有一个强引用 <code>object</code> ，该引用保存在栈中，而真正的引用内容 <code>Object</code> 对象保存在堆中。当上述方法运行完成后退出方法栈，强引用 <code>object</code> 就不存在了，引用的 <code>Object</code> 对象就会被回收。 注意，如果 <code>Object object = new Object();</code> 是全局的，那么在不使用该对象时需要设置 <code>object = null</code> 以帮助垃圾收集器回收该对象。</p><p>也就是说，一个对象从根路径能找到强引用指向它，JVM 就不会回收。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>如果一个对象只具有软引用，在内存空间足够的情况下 JVM 就不会回收它；如果内存空间不足就会回收这些对象。更准确地来说，进行 Young GC 不会触发软引用所指向对象的回收；但如果触发Full GC，则软引用所指向的对象将被回收。前提是除了软引用之外没有其他强引用引用的情况下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">String str = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="comment">// 软引用</span></span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(str);       </span><br><span class="line"><span class="comment">// 内存不足</span></span><br><span class="line"><span class="keyword">if</span>(isNotFullMemeory())&#123;</span><br><span class="line">     str = <span class="keyword">null</span>;</span><br><span class="line">     System.gc();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如上所示，在内存不足时会回收软引用。软引用可用来实现高速缓存。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>如果一个对象只有弱引用指向它，当进行年轻代垃圾回收时，一旦发现该引用指向的对象就会立刻回收，不管当前内存空间是否足够。注意，由于垃圾回收器是一个优先级很低的线程，因此不一定及时发现那些具有弱引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">String str = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(str);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 垃圾回收</span></span><br><span class="line">str = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><p>如上所示，在进行垃圾回收时发现弱引用立即回收。如果想使用一个对象且不想介入这个对象的生命周期，这时就可以使用弱引用。注意，下面的代码可以转为强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String  str = weakReference.get();</span><br></pre></td></tr></table></figure><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">String str = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="comment">// 虚引用</span></span><br><span class="line">PhantomReference phantomReference = <span class="keyword">new</span> PhantomReference(str,<span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">str = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 随时可能会输</span></span><br></pre></td></tr></table></figure><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中，该队列就是前文类图中的 <code>ReferenceQueue</code> 。</p><h1 id="再谈弱引用"><a href="#再谈弱引用" class="headerlink" title="再谈弱引用"></a>再谈弱引用</h1><p>由于在看 <strong>ThreadLocal</strong> 源码时考虑到涉及 <strong>弱引用</strong> ，因此单独拿出来说明下。下面对 <strong>WeakReference</strong> 类进行分析。</p><h2 id="WeakReference"><a href="#WeakReference" class="headerlink" title="WeakReference"></a>WeakReference</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个指向给定对象的弱引用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent 给定对象的引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent 给定对象的引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q 对象被回收后会把弱引用对象，也就是WeakReference对象或者其子类的对象，放入队列ReferenceQueue中，注意不是被弱引用的对象，被弱引用的对象已经被回收了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过上述代码强调两个概念：</strong></p><blockquote><p>1 弱引用对象是指 WeakReference 实例或其子类实例。<br>2 被弱引用的对象是指需要通过 WeakReference 封装的对象，<strong>形如：</strong><code>WeakReference&lt;Xxx&gt; appleWeakReference = new WeakReference&lt;&gt;(xxx)</code>。这个时候我们说，持有了 <code>xxx</code> 指向对象的弱引用，也就是说当 <code>xxx</code> 也不再引用（可能不止 xxx 引用）时，就剩下弱引用，此时垃圾回收时是可以把对应的对象回收掉。</p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><strong>Fruit 类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        log.info(name + <span class="string">"finalize !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Fruit&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强引用</span></span><br><span class="line">        Fruit fruit = <span class="keyword">new</span> Fruit(<span class="string">"小芒果"</span>);</span><br><span class="line">        <span class="comment">// 创建弱引用对象</span></span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal(fruit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 WeakReference.get() 方法获取对应的对象</span></span><br><span class="line">        log.info(<span class="string">"Fruit: "</span> + animal.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消除强引用，确保只有弱引用（不消除强引用，不会回收）</span></span><br><span class="line">        fruit = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证 GC 的发生</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小芒果被回收 - 因此只有弱引用</span></span><br><span class="line">        log.info(animal.get() == <span class="keyword">null</span> ? <span class="string">" Fruit is Cleared"</span> : animal.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 WeakReference ，持有 Fruit 的弱引用。</span></span><br><span class="line"><span class="comment">     * 当垃圾回收时，回收的是弱引用 referent 指向的对象，而非 Animal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(Fruit referent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(referent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO com.code.concurrent.Client - Fruit: Fruit&#123;name&#x3D;&#39;小芒果&#39;&#125;</span><br><span class="line">[Finalizer] INFO com.code.concurrent.Fruit - 小芒果finalize !</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 5242K-&gt;752K(76288K)] 5242K-&gt;760K(251392K), 0.0008122 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 752K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;534K(175104K)] 760K-&gt;534K(251392K), [Metaspace: 3371K-&gt;3371K(1056768K)], 0.0042356 secs] [Times: user&#x3D;0.03 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[main] INFO com.code.concurrent.Client -  Fruit is Cleared</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 7209K [0x000000076ab00000, 0x0000000770000000, 0x00000007c0000000)</span><br><span class="line">  eden space 65536K, 11% used [0x000000076ab00000,0x000000076b20a738,0x000000076eb00000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076eb00000,0x000000076eb00000,0x000000076f580000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)</span><br><span class="line"> ParOldGen       total 175104K, used 534K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)</span><br><span class="line">  object space 175104K, 0% used [0x00000006c0000000,0x00000006c0085bf8,0x00000006cab00000)</span><br><span class="line"> Metaspace       used 3857K, capacity 4704K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 428K, capacity 464K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强引用</span></span><br><span class="line">        Fruit fruit = <span class="keyword">new</span> Fruit(<span class="string">"小芒果"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建弱引用对象及引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Fruit&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal(fruit, referenceQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 WeakReference.get() 方法获取对应的对象</span></span><br><span class="line">        log.info(<span class="string">"Fruit 对象信息: "</span> + animal.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC 前</span></span><br><span class="line">        log.info(<span class="string">"GC 前"</span>);</span><br><span class="line">        <span class="keyword">if</span> (referenceQueue.poll() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"没有回收被弱引用的对象，不会加入队列中"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录弱引用对象地址，用于回收前后对比</span></span><br><span class="line">        log.info(<span class="string">"弱引用对象地址："</span>+ animal.toString());</span><br><span class="line">        <span class="comment">// 消除强引用，确保只有弱引用（不消除强引用，不会回收）</span></span><br><span class="line">        fruit = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发垃圾回收</span></span><br><span class="line">        log.info(<span class="string">"GC 中"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 保证 GC 的发生</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC 后</span></span><br><span class="line">        log.info(<span class="string">"GC 后"</span>);</span><br><span class="line">        <span class="comment">// 小芒果被回收 - 因此只有弱引用</span></span><br><span class="line">        log.info(animal.get() == <span class="keyword">null</span> ? <span class="string">" Fruit is Cleared"</span> : animal.get().toString());</span><br><span class="line"></span><br><span class="line">        Reference reference = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((reference = referenceQueue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"回收被弱引用的对象，弱引用对象加入队列中，地址为："</span> + reference.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 WeakReference ，持有 Fruit 的弱引用。</span></span><br><span class="line"><span class="comment">     * 当垃圾回收时，回收的是弱引用 referent 指向的对象，而非 Animal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(Fruit referent, ReferenceQueue referenceQueue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(referent, referenceQueue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO com.code.concurrent.Client - Fruit 对象信息: Fruit&#123;name&#x3D;&#39;小芒果&#39;&#125;</span><br><span class="line">[main] INFO com.code.concurrent.Client - GC 前</span><br><span class="line">[main] INFO com.code.concurrent.Client - 没有回收被弱引用的对象，不会加入队列中</span><br><span class="line">[main] INFO com.code.concurrent.Client - 弱引用对象地址：com.code.concurrent.Client$Animal@a09ee92</span><br><span class="line">[main] INFO com.code.concurrent.Client - GC 中</span><br><span class="line">[Finalizer] INFO com.code.concurrent.Fruit - 小芒果finalize !</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 5242K-&gt;736K(76288K)] 5242K-&gt;744K(251392K), 0.0006983 secs] [Times: user&#x3D;0.00 sys&#x3D;0.01, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 736K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;535K(175104K)] 744K-&gt;535K(251392K), [Metaspace: 3380K-&gt;3380K(1056768K)], 0.0035821 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[main] INFO com.code.concurrent.Client - GC 后</span><br><span class="line">[main] INFO com.code.concurrent.Client -  Fruit is Cleared</span><br><span class="line">[main] INFO com.code.concurrent.Client - 回收被弱引用的对象，弱引用对象加入队列中，地址为：com.code.concurrent.Client$Animal@a09ee92</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 7209K [0x000000076ab00000, 0x0000000770000000, 0x00000007c0000000)</span><br><span class="line">  eden space 65536K, 11% used [0x000000076ab00000,0x000000076b20a738,0x000000076eb00000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076eb00000,0x000000076eb00000,0x000000076f580000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)</span><br><span class="line"> ParOldGen       total 175104K, used 535K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)</span><br><span class="line">  object space 175104K, 0% used [0x00000006c0000000,0x00000006c0085e60,0x00000006cab00000)</span><br><span class="line"> Metaspace       used 3856K, capacity 4704K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 428K, capacity 464K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Java 中的 4 种引用进行了介绍，重点对弱引用进行了详细分析，理解了弱引用再去看 <code>ThreadLocal</code> 就能更好地理解其内存泄漏问题。下一篇文章将对 <code>ThreadLocal</code> 进行分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在 Java 中有 4 种引用类型，主要是在垃圾回收时 JVM 会根据不同的引用类型采取不同的措施。下面分别对这四种类型进行说明，特别是弱引
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
  </entry>
  
  <entry>
    <title>并发 - Thread</title>
    <link href="https://gentryhuang.com/posts/dbdf391f/"/>
    <id>https://gentryhuang.com/posts/dbdf391f/</id>
    <published>2021-08-14T13:50:21.000Z</published>
    <updated>2021-09-15T03:11:19.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>现代操作系统在运行一个程序时，会为其创建一个进程，进程是分配系统资源的最小单位。例如，启动一个 Java 程序时，操作系统就会创建一个 Java 进程。现代操作系统调度 CPU 的最小单位是线程，一个进程可能包含一个或多个线程，这些线程都拥有各自的栈空间和局部变量等属性，并且能够访问共享的内存变量。</p><h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><p><strong>Java 中的线程本质上就是一块内存（对象），不等于操作系统的线程。</strong></p><p>下面是一段 Java 中的线程相关的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 创建线程 Thread</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        log.info(Thread.currentThread().getName() + <span class="string">"is running!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 启动线程</span></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Java 语言来说，上述程序有两个动作，分别是<strong>创建线程</strong>和<strong>启动线程</strong>。但对于底层系统来说，Java 中的线程对象 Thread 执行 <strong>start()</strong> 方法后会间接调用操作系统函数库创建一个操作系统层面的线程并等待 CPU 调度。关于 Java 线程映射操作系统线程在下文会详细分析，我们先对 Java 线程的创建过程进行说明。</p><h2 id="创建Java线程"><a href="#创建Java线程" class="headerlink" title="创建Java线程"></a>创建Java线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化一个 Java 线程</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> g 线程所属的线程组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target 任务体</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 线程名</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> stackSize 线程堆栈大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> acc the AccessControlContext to inherit, or</span></span><br><span class="line"><span class="comment">   *            AccessController.getContext() if null</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> inheritThreadLocals if &#123;<span class="doctag">@code</span> true&#125;, inherit initial values for</span></span><br><span class="line"><span class="comment">   *            inheritable thread-locals from the constructing thread</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="comment">// 当前线程是该线程（要创建的线程）的父线程</span></span><br><span class="line">      Thread parent = currentThread();</span><br><span class="line">      SecurityManager security = System.getSecurityManager();</span><br><span class="line">      <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">              g = security.getThreadGroup();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 使用父线程组</span></span><br><span class="line">          <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">              g = parent.getThreadGroup();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      g.checkAccess();</span><br><span class="line">      <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">              security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      g.addUnstarted();</span><br><span class="line">      <span class="keyword">this</span>.group = g;</span><br><span class="line">      <span class="comment">// 将 daemon、priority 属性设置为父线程的对应属性</span></span><br><span class="line">      <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">      <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 类加载器</span></span><br><span class="line">      <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">          <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">      <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">              acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">      <span class="keyword">this</span>.target = target;</span><br><span class="line">      setPriority(priority);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将父线程的 InheritableThreadLocal 复制过来，ThreadLocal 的使用</span></span><br><span class="line">      <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                  ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">      <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">      <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 分配一个线程 ID</span></span><br><span class="line">      tid = nextThreadID();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在创建 Thread 对象时会调用上面的 init 方法进行 Java 线程初始化。</p><h2 id="启动Java线程"><a href="#启动Java线程" class="headerlink" title="启动Java线程"></a>启动Java线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动线程方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用该方法启动 Java 线程；Java 虚拟机会调用该线程的 run 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 多次启动一个线程是不合法的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 特别是，线程一旦完成执行，就不能重新启动。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  IllegalThreadStateException  if the thread was already</span></span><br><span class="line"><span class="comment"> *               started.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        #run()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        #stop()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 native 方法</span></span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// native 方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们知道的是，Java 线程调用 <code>start</code> 方法后就启动了，获取到 CPU 资源就可以执行任务。那么这和底层系统线程是怎么对应的呢？下面我们就来详细分析 Java 线程是怎么映射操作系统线程的。在分析 Java 线程是怎么映射到操作系统线程之前，我们需要先说明 JDK 的组成。JDK 的代码有两部分，一部分是 Java 语言库，另一部分是实现更底层功能的本地方法，他们由 C++ 实现，位于 openJdk 代码中。</p><h2 id="映射系统线程"><a href="#映射系统线程" class="headerlink" title="映射系统线程"></a>映射系统线程</h2><p>下面我们从调用本地方法 <code>start0</code> 出发，对执行链路进行跟踪，跟踪代码是 openJdk 中的源码。</p><ol><li>Thread.c<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"start0"</span>,           <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">"stop0"</span>,            <span class="string">"("</span> OBJ <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">"isAlive"</span>,          <span class="string">"()Z"</span>,        (<span class="keyword">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">"suspend0"</span>,         <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">"resume0"</span>,          <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">"setPriority0"</span>,     <span class="string">"(I)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">"yield"</span>,            <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;<span class="string">"sleep"</span>,            <span class="string">"(J)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;<span class="string">"currentThread"</span>,    <span class="string">"()"</span> THD,     (<span class="keyword">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">"interrupt0"</span>,       <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">"holdsLock"</span>,        <span class="string">"("</span> OBJ <span class="string">")Z"</span>, (<span class="keyword">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">"getThreads"</span>,        <span class="string">"()["</span> THD,   (<span class="keyword">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"dumpThreads"</span>,      <span class="string">"(["</span> THD <span class="string">")[["</span> STE, (<span class="keyword">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"setNativeName"</span>,    <span class="string">"("</span> STR <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>可以看到，Thread 中的本地方法 <code>start0</code> 维护在一个方法表中，对应的处理函数是 <strong>JVM_StartThread</strong>，下面我们看这个函数的作用。</li><li>jvm.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Thread::start 方法调用执行，必须先释放 Threads_lock</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 确保 C++ Thread 和 OSThread结构 在我们操作之前没有被释放。</span></span><br><span class="line">  <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 忽略</span></span><br><span class="line">  <span class="keyword">if</span> (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    jlong <span class="built_in">size</span> =</span><br><span class="line">           java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">    NOT_LP64(<span class="keyword">if</span> (<span class="built_in">size</span> &gt; SIZE_MAX) <span class="built_in">size</span> = SIZE_MAX;)</span><br><span class="line">    <span class="keyword">size_t</span> sz = <span class="built_in">size</span> &gt; <span class="number">0</span> ? (<span class="keyword">size_t</span>) <span class="built_in">size</span> : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 JavaThread 对象</span></span><br><span class="line">    native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建完 JavaThread 后，启动 JavaThread </span></span><br><span class="line">Thread::start(native_thread);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>可以看到，在执行本地方法 <code>start0</code> 后会创建一个 C++ JavaThread 对象，创建后才会启动 JavaThread 并执行 thread_entry 函数。</li><li>jvm.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line"><span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line"><span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, thread-&gt;threadObj())</span></span>;</span><br><span class="line"><span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line"><span class="comment">//   thread_entry 中 JavaCalls::call_virtual 就是通过 JVM 调用 run 方法的</span></span><br><span class="line">JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                       obj,</span><br><span class="line">                       vmClasses::Thread_klass(),</span><br><span class="line">                       <span class="comment">//  vmSymbols::run_method_name() 映射的就是 run 方法</span></span><br><span class="line">                       vmSymbols::run_method_name(),</span><br><span class="line">                       vmSymbols::void_method_signature(),</span><br><span class="line">                       THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到，JavaThread 执行的回调函数 thread_entry 是关联 Java 线程的直接入口，是通过 Java 虚拟机调用 Thread 对象的 run 方法的。至此，从 Java 线程到 C++ 线程就结束了，不过这两个都不是真正意义上的线程。下面我们继续跟，寻找创建操作系统线程的信息，其实操作系统线程的创建与启动的线索都在创建 C++ JavaThread 对象的逻辑中。</li><li>thread.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JavaThread::JavaThread(ThreadFunction entry_point, <span class="keyword">size_t</span> stack_sz) : JavaThread() &#123;</span><br><span class="line">_jni_attach_state = _not_attaching_via_jni;</span><br><span class="line"><span class="comment">// 1 为 JavaThread 设置运行函数 entry_point</span></span><br><span class="line">set_entry_point(entry_point);</span><br><span class="line"><span class="comment">// Create the native thread itself.</span></span><br><span class="line"><span class="comment">// %note runtime_23</span></span><br><span class="line">os::ThreadType thr_type = os::java_thread;</span><br><span class="line">thr_type = entry_point == &amp;CompilerThread::thread_entry ? os::compiler_thread :</span><br><span class="line">                                                         os::java_thread;</span><br><span class="line"><span class="comment">// 2 根据不同的操作系统，调用对应底层函数创建线程</span></span><br><span class="line">os::create_thread(<span class="keyword">this</span>, thr_type, stack_sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>哇，终于要见到了操作系统创建线程的流程了。在创建 C++ 的线程对象 JavaThread 时会根据不同的操作系统调用不同的函数创建线程。</li><li>os_linux.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread-&gt;JavaThread</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">os::create_thread</span><span class="params">(Thread* thread, ThreadType thr_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">size_t</span> req_stack_size)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建 OSThread </span></span><br><span class="line">OSThread* osthread = <span class="keyword">new</span> OSThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (osthread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// set the correct thread state</span></span><br><span class="line">osthread-&gt;set_thread_type(thr_type);</span><br><span class="line"><span class="comment">// Initial state is ALLOCATED but not INITIALIZED</span></span><br><span class="line">osthread-&gt;set_state(ALLOCATED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 JavaThread 设置 OSThread</span></span><br><span class="line">thread-&gt;set_osthread(osthread);</span><br><span class="line">ThreadState state;</span><br><span class="line">&#123;</span><br><span class="line"> ResourceMark rm;</span><br><span class="line"> <span class="keyword">pthread_t</span> tid;</span><br><span class="line"> <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> limit = <span class="number">3</span>;</span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">   <span class="comment">// 我们的线程来了</span></span><br><span class="line">   <span class="comment">// 调用 Linux 操作系统函数创建真正意义上的线程并运行函数 thread_native_entry，该函数参数是 JavaThread</span></span><br><span class="line">   ret = pthread_create(&amp;tid, &amp;attr, (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*)) thread_native_entry, thread);</span><br><span class="line"> &#125; <span class="keyword">while</span> (ret == EAGAIN &amp;&amp; limit-- &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>这里以 Linux 操作系统为例，我们看到调用 Linux 的 <strong>pthread_create 库函数</strong> 创建线程并执行回调函数 thread_native_entry 。该回调用函数涉及到操作系统线程的状态。</li><li>os_linux.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 所有在 Linux 操作系统下新创建的线程运行的函数。</span></span><br><span class="line"> <span class="comment">// 也就是当在 Java 中创建一个线程并执行 start 方法，后续会创建对应的操作系统线程并执行该方法</span></span><br><span class="line"> <span class="comment">// thread-&gt;JavaThread</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_native_entry</span><span class="params">(Thread *thread)</span> </span>&#123;</span><br><span class="line"> thread-&gt;record_stack_base_and_size();</span><br><span class="line"> thread-&gt;initialize_thread_current();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取 JavaThread 中的 OSThread</span></span><br><span class="line"> OSThread* osthread = thread-&gt;osthread();</span><br><span class="line"> Monitor* sync = osthread-&gt;startThread_lock();</span><br><span class="line"> osthread-&gt;set_thread_id(os::current_thread_id());</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (UseNUMA) &#123;</span><br><span class="line">     <span class="keyword">int</span> lgrp_id = os::numa_get_group_id();</span><br><span class="line">     <span class="keyword">if</span> (lgrp_id != <span class="number">-1</span>) &#123;</span><br><span class="line">     thread-&gt;set_lgrp_id(lgrp_id);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// initialize signal mask for this thread</span></span><br><span class="line"> PosixSignals::hotspot_sigmask(thread);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// initialize floating point control register</span></span><br><span class="line"> os::Linux::init_thread_fpu_state();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// handshaking with parent thread</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="function">MutexLocker <span class="title">ml</span><span class="params">(sync, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">   <span class="comment">// notify parent thread</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置OSThread 为初始状态</span></span><br><span class="line">   osthread-&gt;set_state(INITIALIZED);</span><br><span class="line">   sync-&gt;notify_all();</span><br><span class="line">   <span class="comment">// wait until os::start_thread()</span></span><br><span class="line">   <span class="comment">// 如果 OSThread 是初始化状态，则让它阻塞。</span></span><br><span class="line">    <span class="keyword">while</span> (osthread-&gt;get_state() == INITIALIZED) &#123;</span><br><span class="line">     sync-&gt;wait_without_safepoint_check();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// OSThread 从阻塞中醒来，调用 JavaThread.call_run 方法</span></span><br><span class="line"> thread-&gt;call_run();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到，Linux 在创建线程后先是将状态设置为了 <strong>INITIALIZED</strong>，然后阻塞自己，等待执行 <strong>os::start_thread()</strong> 唤醒自己。醒来后会间接调用 C++ 的 JavaThread 对象的回调函数，进而通过 JVM 调用 Java 的 Thread 对象的 run 方法。至此，C++ 的 JavaThread 对象创建完毕，接着执行它的 start 方法去唤醒阻塞的 OSThread。</li><li>thread.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// thread -&gt; JavaThread</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Thread::start</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// Start is different from resume in that its safety is guaranteed by context or</span></span><br><span class="line"> <span class="comment">// being called from a Java method synchronized on the Thread object.</span></span><br><span class="line"> <span class="keyword">if</span> (thread-&gt;is_Java_thread()) &#123;</span><br><span class="line">   <span class="comment">// Initialize the thread state to RUNNABLE before starting this thread.</span></span><br><span class="line">  <span class="comment">// Can not set it after the thread started because we do not know the</span></span><br><span class="line">      <span class="comment">// exact thread state at that time. It could be in MONITOR_WAIT or</span></span><br><span class="line">     <span class="comment">// in SLEEPING or some other state.</span></span><br><span class="line">     java_lang_Thread::set_thread_status(JavaThread::cast(thread)-&gt;threadObj(),</span><br><span class="line">                                     JavaThreadStatus::RUNNABLE);</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 根据不同的操作系统，调用 start_thread 函数</span></span><br><span class="line"> <span class="comment">// 注意 OS线程还在等待该函数执行</span></span><br><span class="line"> os::start_thread(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到，C++ 的 JavaThread 对象的启动方法 start 会调用 os::start_thread 方法通过设置 OSThread 的状态为 <strong>RUNNABLE</strong> 进而唤醒阻塞的 OSThread ，下面我们依次看更新状态和唤醒方法。</li><li>os.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thead-&gt;JavaThread</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">os::start_thread</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 从 JavaThread 中取出 OSThread</span></span><br><span class="line"> OSThread* osthread = thread-&gt;osthread();</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 设置 OSThread 状态为 RUNNABLE</span></span><br><span class="line"> osthread-&gt;set_state(RUNNABLE);</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 启动线程</span></span><br><span class="line"> pd_start_thread(thread);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">os::pd_start_thread</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line"> OSThread * osthread = thread-&gt;osthread();</span><br><span class="line"> <span class="comment">// 检查 OSThread 状态</span></span><br><span class="line"> Monitor* sync_with_child = osthread-&gt;startThread_lock();</span><br><span class="line"> <span class="function">MutexLocker <span class="title">ml</span><span class="params">(sync_with_child, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 唤醒阻塞的OSThread （阻塞在 thread_native_entry 函数中）</span></span><br><span class="line"> sync_with_child-&gt;notify();</span><br><span class="line"> <span class="comment">// OSThread 被唤醒后会执行 JavaThread.call_run 方法</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>thread.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::call_run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">register_thread_stack_with_NMT();</span><br><span class="line">MACOS_AARCH64_ONLY(<span class="keyword">this</span>-&gt;init_wx());</span><br><span class="line">JFR_ONLY(Jfr::on_thread_start(<span class="keyword">this</span>);)</span><br><span class="line"><span class="keyword">this</span>-&gt;pre_run();</span><br><span class="line"><span class="comment">// JavaThread.run</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">this</span>-&gt;post_run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JavaThread::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// initialize thread-local alloc buffer related fields</span></span><br><span class="line">initialize_tlab();</span><br><span class="line">_stack_overflow_state.create_stack_guard_pages();</span><br><span class="line">cache_global_variables();</span><br><span class="line">set_thread_state(_thread_in_vm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaThread.thread_main_inner</span></span><br><span class="line"><span class="comment">// 运行可以执行 Java 线程的函数</span></span><br><span class="line">thread_main_inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>thread.cpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">JavaThread::thread_main_inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;has_pending_exception() &amp;&amp;</span><br><span class="line">   !java_lang_Thread::is_stillborn(<span class="keyword">this</span>-&gt;threadObj())) &#123;</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="function">ResourceMark <span class="title">rm</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="keyword">this</span>-&gt;set_native_thread_name(<span class="keyword">this</span>-&gt;name());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function">HandleMark <span class="title">hm</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 调用 JavaThread 的运行函数 thread_entry</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;entry_point()(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以上方法用于执行创建 C++ 的 JavaThread 对象时指定的回调函数。目的只有一个，那就是利用 JVM 调用 Java 中我们创建的 Thread 对象的 run 方法。</li></ol><p><strong>至此，Java 线程映射 OS 线程就介绍完毕了。下面我们进行简单小结：</strong></p><blockquote><ol><li>Java 中的 Thread 对象初始化完毕后调用 start 方法开始映射内核线程。注意，Thread 对象创建完毕后调用 start 方法之前和底层线程一毛钱的关系都没有。</li><li>通过调用本地方法 start0 创建 C++ 的 JavaThread 对象，并设置内核线程启动后触发的用于使用 JVM 执行的 Thread 对象的 run 方法的函数。</li><li>JavaThread 会创建底层操作系统的 native thread</li><li>底层的 native thread 开始运行，通过 JVM 调用 Thread 的 run() 方法</li><li>当 Thread 的run()方法执行完毕返回后,或者抛出异常终止后，终止 native thread</li></ol></blockquote><p>可以看出，<strong>Java 中的线程是和内核线程一一对应的，几乎对线程的所有操作都需要借助系统调用完成</strong>。Java 线程映射内核线程的关系图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/java-thread-relatio-os-thread.png" alt></p><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程也有自己的生命周期，Java 中的线程有六种状态，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+--- Thread</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 新建状态，线程尚未启动</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可运行状态。</span></span><br><span class="line"><span class="comment">         * 处于可运行状态的线程正在Java虚拟机中执行，但它可能正在等待操作系统的其他资源，如处理器。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 阻塞状态，等待对象监视器锁</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计时等待</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 终止状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线程的状态。</span></span><br><span class="line"><span class="comment">     * 注意：线程在任何时刻只可能处于 1 种状态。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this thread's state.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// get current thread state</span></span><br><span class="line">        <span class="keyword">return</span> sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>Java 线程中的 <strong>BLOCKED</strong>、<strong>WAITING</strong>、<strong>TIMED_WAITING</strong> 统称为阻塞状态（非 BLOCKED），这三种状态永远没有 CPU 的使用权。了解了线程的六个状态后，下面我们对状态之间的转换进行说明。</p><h3 id="NEW-新建"><a href="#NEW-新建" class="headerlink" title="NEW 新建"></a>NEW 新建</h3><p>NEW 新建表示线程被创建但尚未启动的状态，当我们 new Thread() 新建一个线程时，在线程运行 start() 方法之前，那么它的状态就是 <code>NEW</code>。而一旦线程调用了 start() 方法，它的状态就会从 <code>NEW</code> 变成 <code>RUNNABLE</code>。新建状态的展示如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-new-state.png" alt></p><h3 id="从-NEW-到-RUNNABLE-状态"><a href="#从-NEW-到-RUNNABLE-状态" class="headerlink" title="从 NEW 到 RUNNABLE 状态"></a>从 NEW 到 RUNNABLE 状态</h3><p><strong>NEW 状态的线程，不会被操作系统调度，因此不会执行。Java 线程要执行，就必须转换到 RUNNABLE 状态</strong>。从 NEW 状态转换到 RUNNABLE 状态很简单，只要调用线程对象的 start() 方法就可以了。Java 中的 <code>RUNNABLE</code> 状态对应操作系统线程状态中的两种状态，分别是 <strong>Running</strong> 和 <strong>Ready</strong> 。也就是说，Java 中处于 <code>RUNNABLE</code> 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。因此，对于处于 <code>RUNNABLE</code> 状态的 Java 线程来说，即使当它的 CPU 时间片使用完了导致该线程不能使用，它的状态依然不会改变，还是 <code>RUNNABLE</code> 状态。转换图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-runnable-state.png" alt></p><h3 id="RUNNABLE-与-BLOCKED-的状态转换"><a href="#RUNNABLE-与-BLOCKED-的状态转换" class="headerlink" title="RUNNABLE 与 BLOCKED 的状态转换"></a>RUNNABLE 与 BLOCKED 的状态转换</h3><p><strong>从 RUNNABLE 状态进入到 BLOCKED 状态只有一种可能，就是线程等待 synchronized 的隐式锁</strong>。synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态。转换图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-block-state.png" alt></p><p>想要从 BLOCKED 状态进入 RUNNABLE 状态，需要等待的线程获得 synchronized 隐式锁，获得锁后就又会从 BLOCKED 转换到 RUNNABLE 状态。转换图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-block-to-runnable.png" alt></p><h3 id="RUNNABLE-与-WAITING-的状态转换"><a href="#RUNNABLE-与-WAITING-的状态转换" class="headerlink" title="RUNNABLE 与 WAITING 的状态转换"></a>RUNNABLE 与 WAITING 的状态转换</h3><p>线程进入 Waiting 状态有三种可能性，具体如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-waiting-state.png" alt></p><p><strong>下面对三种可能进行描述：</strong></p><blockquote><ul><li><strong>Object.wait()：</strong>获得 synchronized 隐式锁的线程，调用无参的 Object.wait() 方法，会进入到当前锁对象的 ObjectMonitor 中的 <strong>WaitSet</strong> 等待队列中，当前线程状态由 RUNNABLE 转换为 WAITING 状态。</li><li><strong>Thread.join()：</strong>其中的 join() 是一种线程同步方法，如有一个线程对象 A，当调用 A.join() 的时候，执行这条语句的线程会等待 A 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 A 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE 。</li><li><strong>LockSupport.park()：</strong>调用 LockSupport.park() 方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用 LockSupport.unpark(Thread thread) 可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE 。</li></ul></blockquote><p><strong>注意：</strong>从 WAITING 状态流转到其他状态则比较特殊，因为 WAITING 是不限时的，也就是说无论过了多长时间它都不会主动恢复。</p><p><strong>这里分情况进行讨论：</strong></p><blockquote><ul><li>执行了 LockSupport.unpark() 进入 RUNNABLE 状态</li><li>join 的线程运行结束进入 RUNNABLE 状态。</li><li>被中断进入 RUNNABLE 状态。</li><li>其他线程调用 notify() 或 notifyAll()来唤醒它，它会直接进入 BLOCKED 状态。因为唤醒 WAITING 线程的线程如果调用 notify() 或 notifyAll()，要求必须首先持有 synchronized 的隐式锁，所以处于 WAITING 状态的线程被唤醒时拿不到该锁，就会进入 BLOCKED 状态，直到执行了 notify()/notifyAll() 的唤醒它的线程执行完毕并释放 synchronized 的隐式锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 BLOCKED 状态回到 RUNNABLE 状态。</li></ul></blockquote><p><strong>具体流转图如下：</strong></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-waiting-to-some.png" alt></p><h3 id="RUNNABLE-与-TIMED-WAITING-的状态转换"><a href="#RUNNABLE-与-TIMED-WAITING-的状态转换" class="headerlink" title="RUNNABLE 与 TIMED_WAITING 的状态转换"></a>RUNNABLE 与 TIMED_WAITING 的状态转换</h3><p>线程进入 TIMED_WAITING 有五种可能，具体如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-timed-waiting-state.png" alt></p><p><strong>下面对五种可能进行描述：</strong></p><blockquote><ul><li>调用带超时参数的 Thread.sleep(long millis) 方法</li><li>获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法</li><li>调用带超时参数的 Thread.join(long millis) 方法</li><li>调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法</li><li>调用带超时参数的 LockSupport.parkUntil(long deadline) 方法</li></ul></blockquote><p>这里可以发现 TIMED_WAITING 和 WAITING 状态的区别，仅仅是触发条件多了超时参数。</p><p>同样地，TIMED_WAITING 进入其它状态和 WAITING 类似，只是在其基础上增加了超时限制，也就是超时时间到达时将会返回到 RUNNABLE 状态，注意调用带超时参数的 Object.wait(long timeout) 方法，即使超时时间到了也是先进入阻塞状态（自行进入阻塞队列），获取到锁后才会返回到 RUNNABLE 状态。</p><p><strong>具体流转图如下：</strong></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-timed-waiting-to-some.png" alt></p><h3 id="从-RUNNABLE-到-TERMINATED-状态"><a href="#从-RUNNABLE-到-TERMINATED-状态" class="headerlink" title="从 RUNNABLE 到 TERMINATED 状态"></a>从 RUNNABLE 到 TERMINATED 状态</h3><p>线程进入 TERMINATED 状态有两种情况，具体如下：</p><ul><li>线程执行完 run() 方法后，会自动转换到 TERMINATED 状态</li><li>执行 run() 方法的时候异常抛出，也会导致线程终止</li></ul><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-terminated-state.png" alt></p><p>此外，有时候我们需要强制终止 run() 方法的执行，Java 的 Thread 类中提供了 stop() 方法，不过已经标记为 @Deprecated，所以不建议使用了。正确的姿势是利用线程中断进行交互。</p><h3 id="状态小结"><a href="#状态小结" class="headerlink" title="状态小结"></a>状态小结</h3><ul><li>线程生命周期不可逆，一旦进入 RUNNABLE 状态就不能回到 NEW 状态</li><li>一旦被终止就不可能再有任何状态的变化</li><li>一个线程只能有一次 NEW 和 TERMINATED 状态，只有处于中间状态才可以相互转换，注意相互转换的方向和时机</li></ul><h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><p><strong>并发</strong></p><blockquote><p>如果某个系统支持两个或多个动作<strong>同时存在</strong>，那么这个系统就是一个并发系统。处理器在不同线程之间高速切换，让使用者感觉到这些线程在同时执行。</p></blockquote><p><strong>并行</strong></p><blockquote><p>如果某个系统支持两个或多个动作<strong>同时执行</strong>，那么这个系统就是一个并行系统。</p></blockquote><p>并发系统与并行系统这两个定义之间的差异在于是<strong>同时存在</strong>还是<strong>同时执行</strong>。对于单核 CPU 并发执行任务，这些任务是同时存在的，CPU 会在不同任务之间进行切换，直到所有任务执行完成。并行意味着一定在多核 CPU 上，多个任务（线程）会被分配到独立的处理器上，因此可以同时运行。并行其实是并发的一个子集</p><h1 id="理解中断"><a href="#理解中断" class="headerlink" title="理解中断"></a>理解中断</h1><p>Java 中的中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。注意，中断某个线程，并不是说该线程就立即停止运行了，仅仅对该线程打了个标记。每个线程都关联了一个中断标识位，是一个 boolean 类型的变量，初始值为 false 。</p><p>关于线程中断，在 Thread 类中定义了以下几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 中断线程，即设置线程的中断状态为 true</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@spec</span> JSR-51</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">         checkAccess();</span><br><span class="line">     <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">         Interruptible b = blocker;</span><br><span class="line">         <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">             interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">             b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     interrupt0();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Thread 类中的静态方法，用于检测调用该方法的线程的中断状态，并重置中断标识位</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>  如果当前线程已经被中断过了，那么返回 true ，否则返回 false</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Thread 类中的实例方法，检测线程的中断状态。注意，不会重置中断标识位。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>   如果当前线程已经被中断过了，那么返回 true ，否则返回 false</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 检测线程是否已被中断。检测后是否重置中断状态基于传入的 参数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p>我们说中断线程，其实就是将线程的中断标识位置为 true ，至于被中断的线程怎么处理那就是线程自己的事了。线程通过检查自身是否被中断来进行响应，通过方法 <code>isInterrupted()</code> 判断是否被中断，通过调用静态方法 <code>Thread.interupted()</code> 对当前线程的中断标识位进行重置。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有被中断就执行任务，被中断则结束执行任务</span></span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted())&#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在 Java 提供的抛出 <code>InterruptedException</code> 方法在被调用抛出这个中断异常之前，Java 虚拟机会先把该线程的中断标识位清除然后抛出中断异常。</p><blockquote><p>Object: wait() 系列方法<br>Thread: join() 系列方法、sleep() 系列方法</p></blockquote><p>如上 JDK 提供的几个可中断方法，它们会让线程阻塞。如果线程阻塞在这些方法上，这个时候如果其他线程对这个线程进行了中断，那么这个线程会从这些方法中立即返回，抛出中断异常，同时重置中断状态为 false。日常开发中我们也可以根据需要，自定义可中断方法，在必要的时候通过线程中断实现特定功能。</p><p>此外，如果线程阻塞在 <code>LockSupport.park(Object obj)</code> 方法上，此时如果其他线程对该线程进行中断也会唤醒该阻塞线程，但是唤醒后不会重置中断状态。</p><p><strong>安全地终止线程：</strong>线程中断是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Java 中的线程进行了介绍。先是从线程的创建与启动出发，分析了 Java 线程与内核线程的关系；然后对 Java 中的线程状态及流转进行了详细说明；最后对线程的中断进行了介绍，它是停止线程的正确姿势，也是线程通信的一种方式。</p><p><strong>参考：</strong></p><p>Java编发编程的艺术书籍<br>Java并发编程78讲专栏</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;现代操作系统在运行一个程序时，会为其创建一个进程，进程是分配系统资源的最小单位。例如，启动一个 Java 程序时，操作系统就会创建一个 Ja
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="Thread" scheme="https://gentryhuang.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>时间轮算法 - HashedWheelTimer</title>
    <link href="https://gentryhuang.com/posts/1d01ceec/"/>
    <id>https://gentryhuang.com/posts/1d01ceec/</id>
    <published>2021-07-24T02:06:24.000Z</published>
    <updated>2021-10-12T15:49:10.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>时间轮是一种高效利用线程资源来进行批量化调度的一种调度模型。将大批量的调度任务全部都绑定到同一个调度器上，使用这一调度器来进行所有任务的管理、触发以及执行。本篇文章将对 HashedWheelTimer 进行分析。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>编码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.util.HashedWheelTimer;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.Timeout;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.Timer;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimerClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 创建一个 HashedWheelTimer，内部参数全部使用默认值</span></span><br><span class="line">        Timer timer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 编写 TimeTask 任务</span></span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"is working !"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 提交任务</span></span><br><span class="line">        <span class="comment">// 创建 HashedWheelTimeout 对象，并将该对象放入任务队列中，等待被加入到 Hash 轮中被调用。</span></span><br><span class="line">        Timeout timeout = timer.newTimeout(timerTask, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调度结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1is working !</span><br></pre></td></tr></table></figure><h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>时间轮调度模型如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/hashedwheeltimer/hash-wheel-timer-model.jpeg" alt></p><p><strong>HashedWheelTimer</strong> 时间轮算法可以通过上图来描述。假设时间轮大小为 8 即 8 个格子，1s 转一格，每格都对应一个链表，链表每个节点都保存着待执行的任务。某一时刻，时间轮走到编号为 2 的格子，此时添加了一个 3s 后执行的任务，对应 3 个格子，则 2 + 3 = 5，在编号为 5 的格子对应链表中添加一个任务节点即可，轮次 round 为 0 ；如果添加一个 10s 后执行的任务，同理得 (2 + 10) % 8 = 4，在编号为 4 的格子对应的链表中添加一个任务节点，并标识轮次 round 为 1，当时间轮第二次经过编号为 4 的格子时就会执行该任务。注意，时间轮只会执行 round = 0 的任务，并会把该格子上的其他任务的 round 减 1 。</p><p>时间轮算法的原理还是非常容易理解的，下面我们从源码层面进行分析。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>HashedWheelTimer 相关的核心类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/hashedwheeltimer/hash-wheel-timer-uml.jpg" alt></p><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>HashedWheelTimer 是接口 io.netty.util.Timer 的实现，Timer 是任务调度器，负责对延时任务进行管理、触发和调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调度指定的 TimerTask ，在指定的延迟后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 与指定任务相关联的句柄</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException      if this timer has been &#123;<span class="doctag">@linkplain</span> #stop() stopped&#125; already</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the pending timeouts are too many and creating new timeout</span></span><br><span class="line"><span class="comment">     *                                    can cause instability in the system.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止所有的还没被执行的定时任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 与被此方法取消的任务相关联的句柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h2><p>延时任务，由业务方自行实现。Timer 会在触发时间对延时任务进行调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Timer 调度的任务，由业务方实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executed after the delay specified with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Timer#newTimeout(TimerTask, long, TimeUnit)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 任务执行的时候会将该任务对应的 Timeout 传进来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h2><p>Timeout 是一个非常重要的接口，它的唯一实现类是 HashedWheelTimer 内部类 HashedWheelTimeout ，该内部类聚合了时间轮主要的核心对象，关于该内部类下文会详细分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与&#123;<span class="doctag">@link</span> TimerTask&#125;关联的句柄，由&#123;<span class="doctag">@link</span> Timer&#125;返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回创建此句柄的&#123;<span class="doctag">@link</span> Timer&#125;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Timer <span class="title">timer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TimerTask <span class="title">task</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当且仅当与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;已过期时返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当且仅当与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;已被取消时返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试取消与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;。如果任务已经被执行或取消，它将返回而没有副作用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果取消成功，则为 true，否则为 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashedWheelTimer"><a href="#HashedWheelTimer" class="headerlink" title="HashedWheelTimer"></a>HashedWheelTimer</h2><p>HashedWheelTimer 是对 Timer 的实现，也就是我们说的时间轮。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimer</span> <span class="keyword">implements</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimer 实例统计原子变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger INSTANCE_COUNTER = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过多 HashedWheelTimer 阈值开关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicBoolean WARNED_TOO_MANY_INSTANCES = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimer 数量的阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTANCE_COUNT_LIMIT = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小延时时间，默认是 1 毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MILLISECOND_NANOS = TimeUnit.MILLISECONDS.toNanos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ResourceLeakDetector&lt;HashedWheelTimer&gt; leakDetector = ResourceLeakDetectorFactory.instance()</span><br><span class="line">            .newResourceLeakDetector(HashedWheelTimer<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间轮状态，可以控制工作线程执行任务的状态。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimer&gt; WORKER_STATE_UPDATER =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class, "workerState");</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceLeakTracker&lt;HashedWheelTimer&gt; leak;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread workerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态  0 - init, 1 - started, 2 - shut down</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_INIT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_STARTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_SHUTDOWN = <span class="number">2</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unused"</span>, <span class="string">"FieldMayBeFinal"</span>&#125;)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> workerState; <span class="comment">// 0 - init, 1 - started, 2 - shut down</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走一个 bucket 需要花费的纳秒时长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> tickDuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bucket 数组，用于存储任务，即 HashedWheelTimeout 实例们</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelBucket[] wheel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 掩码，用于 与运算 ，计算属于 wheel 哪个下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 newTimeout 方法线程等待工作线程 workerThread 开启执行任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startTimeInitialized = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimeout 任务队列。MPSC 队列，适用于这里的多生产线程，单消费线程的场景</span></span><br><span class="line">    <span class="comment">// 提交的任务会先进入到该队列中，每次 tick 才会将队列中的任务（一次最多 10 万个）加入到 bucket 中的链表里</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; timeouts = PlatformDependent.newMpscQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimeout 任务取消队列</span></span><br><span class="line">    <span class="comment">// 取消的任务会加入到该队列中，此次 tick 会将该队列中的任务从 bucket 中移除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; cancelledTimeouts = PlatformDependent.newMpscQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间轮中处于等待执行的任务数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong pendingTimeouts = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许最大的等待任务数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxPendingTimeouts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程启动时间，作为时间轮的基准时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> startTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*----------------- 系列构造方法 -------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Executors.defaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(<span class="keyword">long</span> tickDuration, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Executors.defaultThreadFactory(), tickDuration, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(<span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Executors.defaultThreadFactory(), tickDuration, unit, ticksPerWheel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory, <span class="keyword">long</span> tickDuration, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, <span class="number">512</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, ticksPerWheel, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel, <span class="keyword">boolean</span> leakDetection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, ticksPerWheel, leakDetection, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 HashedWheelTimer 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory      线程工厂，用于创建执行 TimerTask 任务的工作线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tickDuration       tick 之间的持续时间，即一次 tick 的时间长度。默认是 100</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit               tickDuration 的时间单位。默认是 毫秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticksPerWheel      定义一圈有多少个 bucket 。 默认是 512</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leakDetection      用于追踪内存泄漏</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxPendingTimeouts 最大允许等待的任务数，也就是 Timeout 实例数（调用 newTimeout 方法产生），可以根据该参数控制不允许太多的任务等待。</span></span><br><span class="line"><span class="comment">     *                           如果未执行任务数达到阈值，那么再次提交任务会抛出 RejectedExecutionException 异常。如果该值为 0 或 负数，则不限制。</span></span><br><span class="line"><span class="comment">     *                           默认不限制。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel, <span class="keyword">boolean</span> leakDetection,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> maxPendingTimeouts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 参数校验</span></span><br><span class="line">        ObjectUtil.checkNotNull(threadFactory, <span class="string">"threadFactory"</span>);</span><br><span class="line">        ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line">        ObjectUtil.checkPositive(tickDuration, <span class="string">"tickDuration"</span>);</span><br><span class="line">        ObjectUtil.checkPositive(ticksPerWheel, <span class="string">"ticksPerWheel"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建时间轮 bucket 结构，这里做向上取整，保证 bucket 数组长度是 2 的 n 次方</span></span><br><span class="line">        <span class="comment">// wheel 就是一个个 bucket。时间轮会以循环的方式走这个 wheel 数组</span></span><br><span class="line">        wheel = createWheel(ticksPerWheel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 掩码，bucket - 1，用来做取模，计算任务应该放到哪个 bucket 中</span></span><br><span class="line">        <span class="comment">// HashMap 在进行 hash 之后，进行index的hash寻址寻址的算法也是和这个一样的</span></span><br><span class="line">        mask = wheel.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 将延迟时间统一转为纳秒</span></span><br><span class="line">        <span class="keyword">long</span> duration = unit.toNanos(tickDuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 防止延迟时间溢出</span></span><br><span class="line">        <span class="keyword">if</span> (duration &gt;= Long.MAX_VALUE / wheel.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">"tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d"</span>,</span><br><span class="line">                    tickDuration, Long.MAX_VALUE / wheel.length));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 延迟时间不能小于 1 毫秒</span></span><br><span class="line">        <span class="keyword">if</span> (duration &lt; MILLISECOND_NANOS) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Configured tickDuration &#123;&#125; smaller then &#123;&#125;, using 1ms."</span>,</span><br><span class="line">                    tickDuration, MILLISECOND_NANOS);</span><br><span class="line">            <span class="keyword">this</span>.tickDuration = MILLISECOND_NANOS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.tickDuration = duration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 根据线程工厂创建线程。注意，这里并没有立即启动线程，启动线程是在第一次提交延迟任务的时候。</span></span><br><span class="line">        workerThread = threadFactory.newThread(worker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追踪内存泄露的，略</span></span><br><span class="line">        leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8 最大允许等待的 Timeout 实例数</span></span><br><span class="line">        <span class="keyword">this</span>.maxPendingTimeouts = maxPendingTimeouts;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9  如果超过 64 个 HashedWheelTimer 实例，它会打印错误日志提醒你</span></span><br><span class="line">        <span class="comment">// 因为时间轮是一个非常耗费资源的结构，所以一个 jvm 中的实例数目不能太高</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</span><br><span class="line">                WARNED_TOO_MANY_INSTANCES.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// 打印错误日志</span></span><br><span class="line">            reportTooManyInstances();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过以上构造方法可以初始化一个时间轮对象，默认情况下，时间轮大小是 512，也就是一圈有 512 个 bucket，走一个 bucket 需要时间为 100ms 。</p><h3 id="初始化-bucket"><a href="#初始化-bucket" class="headerlink" title="初始化 bucket"></a>初始化 bucket</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时间轮 bucket 数组，用来存储任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticksPerWheel 一圈有多少个 bucket ，默认是 512</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashedWheelBucket[] createWheel(<span class="keyword">int</span> ticksPerWheel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"ticksPerWheel must be greater than 0: "</span> + ticksPerWheel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间轮 tick 不能多大</span></span><br><span class="line">        <span class="keyword">if</span> (ticksPerWheel &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"ticksPerWheel may not be greater than 2^30: "</span> + ticksPerWheel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  标准化时间轮大小</span></span><br><span class="line">        ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 HashedWheelBucket 数组</span></span><br><span class="line">        HashedWheelBucket[] wheel = <span class="keyword">new</span> HashedWheelBucket[ticksPerWheel];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wheel.length; i++) &#123;</span><br><span class="line">            wheel[i] = <span class="keyword">new</span> HashedWheelBucket();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wheel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标准化时间轮大小，原则：向上取整，达到 2 的 n 次方</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticksPerWheel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">normalizeTicksPerWheel</span><span class="params">(<span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> normalizedTicksPerWheel = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取第一个大于 ticksPerWheel 的 2 的 n 次方的值</span></span><br><span class="line">        <span class="keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;</span><br><span class="line">            <span class="comment">// 左移一位，即 扩大 2 倍</span></span><br><span class="line">            normalizedTicksPerWheel &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> normalizedTicksPerWheel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>初始化 bucket 的过程就是初始化时间轮的格子，每个格子用于管理落在当前位置的延时任务们，这些任务由链表组织起来，且任务具有轮次的语义，只有任务的轮次为 0 时才能被时间轮执行。注意，<strong>时间轮中的每个 bucket 和延时时间是通过 tick 来间接关联的</strong>，通过延时任务的时间可以计算出它对应 N 个 tick ，而 tick 数对 bucket 数组长度取模运算就能确定具体的 bucket。延时任务完成 Bucket 分配后，时间轮不断进行 tick 的过程就可以通过计算找到 tick 对应的 Bucket ，进而处理延时任务。</p><h2 id="HashedWheelTimeout"><a href="#HashedWheelTimeout" class="headerlink" title="HashedWheelTimeout"></a>HashedWheelTimeout</h2><p>延时任务的包装类，该类聚合了时间轮所有的核心对象及属性，也就是说通过该对象可以拿到所有核心的对象和属性，并且该类包含了延时任务执行的方法<strong>expire()</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimeout</span> <span class="keyword">implements</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_INIT = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 取消</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_CANCELLED = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 到期</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_EXPIRED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用CAS方式更新任务状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; STATE_UPDATER =</span><br><span class="line">                AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.class, "state");</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Timer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelTimer timer;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * TimerTask</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TimerTask task;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 任务触发时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> deadline;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unused"</span>, <span class="string">"FieldMayBeFinal"</span>, <span class="string">"RedundantFieldInitialization"</span>&#125;)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = ST_INIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 离任务执行的轮数，0 表示当前轮次执行。当任务从队列加入 bucket 时会计算这个值。</span></span><br><span class="line">        <span class="comment">// 对与轮次非 0 的任务，那么时间轮执行到对应的 bucket 时会将该任务的该属性值 -1 </span></span><br><span class="line">        <span class="keyword">long</span> remainingRounds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这将用于通过双向链表在 hashhedwheeltimerbucket 中链接超时 的前后指针</span></span><br><span class="line">        HashedWheelTimeout next;</span><br><span class="line">        HashedWheelTimeout prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前 HashedWheelTimeout 所在的 bucket</span></span><br><span class="line">        HashedWheelBucket bucket;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashedWheelTimeout 用于封装 HashedWheelTimer、TimerTask 以及 deadLine 触发时间</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> timer</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> deadline</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HashedWheelTimeout(HashedWheelTimer timer, TimerTask task, <span class="keyword">long</span> deadline) &#123;</span><br><span class="line">            <span class="keyword">this</span>.timer = timer;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.deadline = deadline;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+---HashedWheelTimeout</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 到期并执行任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_EXPIRED)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行 TimerTask.run 方法</span></span><br><span class="line">                task.run(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"An exception was thrown by "</span> + TimerTask<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>() + '.', <span class="title">t</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行任务本质上是调用 HashedWheelTimeout 对象中封装的 TimerTask 对象的 run 方法。需要注意的是，即使任务执行过程抛出异常工作线程也不会退出；为了提高时间轮的精准度，任务执行最好使用异步方式。</p><h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---HashedWheelTimeout</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 取消任务</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里只是修改状态为取消，实际会在下次tick的时候移除</span></span><br><span class="line">     <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_CANCELLED)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">           </span><br><span class="line">     <span class="comment">// 加入到时间轮的全局待取消队列，并在每次tick的时候，从相应 bucket 中移除。 </span></span><br><span class="line">      timer.cancelledTimeouts.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>取消任务只是将待执行的 HashedWheelTimeout 对象加入到全局取消队列中，在后续的 tick 过程才会从对应的 bucket 中删除。</p><h3 id="移除任务"><a href="#移除任务" class="headerlink" title="移除任务"></a>移除任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimeout</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前 Timeout 从对应的 bucket 链表中移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   HashedWheelBucket bucket = <span class="keyword">this</span>.bucket;</span><br><span class="line">     <span class="keyword">if</span> (bucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">          bucket.remove(<span class="keyword">this</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          timer.pendingTimeouts.decrementAndGet();</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>将 HashedWheelTimeout 对象从对应的 bucket 中删除。</p><h2 id="HashedWheelBucket"><a href="#HashedWheelBucket" class="headerlink" title="HashedWheelBucket"></a>HashedWheelBucket</h2><p>用来存放包装任务的 HashedWheelTimeout ，以链表结构的形式进行管理，链表中的每一个节点都是 HashedWheelTimeout。</p><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelBucket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 头指针</span></span><br><span class="line">       <span class="keyword">private</span> HashedWheelTimeout head;</span><br><span class="line">       <span class="comment">// 尾指针</span></span><br><span class="line">       <span class="keyword">private</span> HashedWheelTimeout tail;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Add &#123;<span class="doctag">@link</span> HashedWheelTimeout&#125; to this bucket.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 添加 HashedWheelTimeout 到 当前 bucket 中，即加入到链中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTimeout</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">assert</span> timeout.bucket == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 设置 timeout 的桶，即聚合桶对象</span></span><br><span class="line">           timeout.bucket = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 维护桶中的 HashedWheelTimeout</span></span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">               head = tail = timeout;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               tail.next = timeout;</span><br><span class="line">               timeout.prev = tail;</span><br><span class="line">               tail = timeout;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将 timeout 从链表中移除</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> HashedWheelTimeout <span class="title">remove</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</span><br><span class="line">           HashedWheelTimeout next = timeout.next;</span><br><span class="line">           <span class="comment">// remove timeout that was either processed or cancelled by updating the linked-list</span></span><br><span class="line">           <span class="keyword">if</span> (timeout.prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">               timeout.prev.next = next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (timeout.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">               timeout.next.prev = timeout.prev;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (timeout == head) &#123;</span><br><span class="line">               <span class="comment">// if timeout is also the tail we need to adjust the entry too</span></span><br><span class="line">               <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">                   tail = <span class="keyword">null</span>;</span><br><span class="line">                   head = <span class="keyword">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   head = next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">               <span class="comment">// if the timeout is the tail modify the tail to be the prev node.</span></span><br><span class="line">               tail = timeout.prev;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// null out prev, next and bucket to allow for GC.</span></span><br><span class="line">           timeout.prev = <span class="keyword">null</span>;</span><br><span class="line">           timeout.next = <span class="keyword">null</span>;</span><br><span class="line">           timeout.bucket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// timeout 对应的 timer 的等待任务数减 1</span></span><br><span class="line">           timeout.timer.pendingTimeouts.decrementAndGet();</span><br><span class="line">           <span class="keyword">return</span> next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行任务-1"><a href="#执行任务-1" class="headerlink" title="执行任务"></a>执行任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelBucket</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Expire all &#123;<span class="doctag">@link</span> HashedWheelTimeout&#125;s for the given &#123;<span class="doctag">@code</span> deadline&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 执行 bucket 中的到期任务。注意，只执行 bucket 中轮次为 0 且到期的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireTimeouts</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取时间任务链表的头</span></span><br><span class="line">        HashedWheelTimeout timeout = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理链表上的所有 timeout 实例</span></span><br><span class="line">        <span class="keyword">while</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            HashedWheelTimeout next = timeout.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调整当前 bucket 的任务链表</span></span><br><span class="line">                next = remove(timeout);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 到达触发时间</span></span><br><span class="line">                <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 执行具体的任务，即执行 timeout 中的 TimerTask.run 方法</span></span><br><span class="line">                    timeout.expire();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不可能进入到这个分支</span></span><br><span class="line">                    <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line">                            <span class="string">"timeout.deadline (%d) &gt; deadline (%d)"</span>, timeout.deadline, deadline));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务被取消了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</span><br><span class="line">                next = remove(timeout);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 轮次减 1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout.remainingRounds--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理下个任务</span></span><br><span class="line">            timeout = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>工作线程 tick 时会找到当前 tick 对应的 bucket ，然后执行上述方法进而调度延时任务。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>Worker 是工作线程的任务体，里面封装了时间轮任务触发和执行的逻辑。一旦工作线程启动后，就会不停地 “滴答” bucket ，直到时间轮关闭。</p><h3 id="任务体"><a href="#任务体" class="headerlink" title="任务体"></a>任务体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录没有处理的时间任务</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="keyword">new</span> HashSet&lt;Timeout&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录走了几个 bucket ，不拥堵的情况下每隔 tickDuration 时间走一个 bucket</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> tick;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化启动时间。</span></span><br><span class="line">            <span class="comment">// 注意，在 HashedWheelTimer 中用的都是相对时间，因此需要以启动时间为基准。这里使用 volatile 修饰</span></span><br><span class="line">            startTime = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 因为 startTime = 0 作为工作线程未开始执行任务的标志。这里开始执行了，需要设置非 0</span></span><br><span class="line">                startTime = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个提交任务的线程在 start() 处等待，需要唤醒它</span></span><br><span class="line">            startTimeInitialized.countDown();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * do-while 执行任务逻辑：</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 工作线程是逐个 bucket 顺序处理的，所以即使有些任务执行时间超过了一次 tick 时间，也没关系，这些任务并不会被漏掉。</span></span><br><span class="line"><span class="comment">             * 但是可能被延迟执行，毕竟工作线程是单线程。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待下次 tick 到来，理论上每次等待 tickDuration 就会返回，然后继续往下走</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> deadline = waitForNextTick();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前 tick 下 bucket 数组对应 index，即哪个 bucket</span></span><br><span class="line">                    <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (tick &amp; mask);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理已经取消的任务</span></span><br><span class="line">                    processCancelledTasks();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取当前 tick 对应的桶</span></span><br><span class="line">                    HashedWheelBucket bucket = wheel[idx];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将 timeouts 队列中的 HashedWheelTimeout 转移到相应的桶中</span></span><br><span class="line">                    transferTimeoutsToBuckets();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 执行进入到 bucket 中的任务</span></span><br><span class="line">                    bucket.expireTimeouts(deadline);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 记录走了多少个 tick</span></span><br><span class="line">                    tick++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 执行到这里，说明当前 Timer 要关闭了，做一些清理工作 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将所有 bucket 中没有执行的任务，添加到 unprocessedTimeouts 这个 HashSet 中，用于 stop() 方法返回。</span></span><br><span class="line">            <span class="keyword">for</span> (HashedWheelBucket bucket : wheel) &#123;</span><br><span class="line">                <span class="comment">// 将当前 bucket 上链表节点任务都加入到 unprocessedTimeouts</span></span><br><span class="line">                bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务队列中的任务也添加到 unprocessedTimeouts 中</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!timeout.isCancelled()) &#123;</span><br><span class="line">                    unprocessedTimeouts.add(timeout);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理已经取消的任务</span></span><br><span class="line">            processCancelledTasks();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程启动的第一步是初始化全局的 <code>startTime</code>，它将作为时间轮的基准时间，用来计算延时任务的触发时间。并调用 <code>countDown</code> 方法来通知阻塞在 <code>start</code> 方法上的线程。接着进入主循环中，循环中的行为是每隔一段时间（tickDuration）走一个 bucket ，下面我们拆解执行部分。</p><h3 id="waitForNextTick"><a href="#waitForNextTick" class="headerlink" title="waitForNextTick"></a>waitForNextTick</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- Worker</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitForNextTick</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 计算当前 tick 下的 deadline，这值是确定的。即一次 tick 期限是一个固定值</span></span><br><span class="line">            <span class="comment">// 注意，这里就体现了时间轮的核心，理论上每隔 tickDuration 就会 "滴答" 一次</span></span><br><span class="line">            <span class="keyword">long</span> deadline = tickDuration * (tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 等待当前 tick 时间到达</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.1 基于 startTime 计算距离当前时间的时间戳，该值的理论值认为等于 dealine ，但由于任务执行时间没法控制，实际值一般大于 deadline </span></span><br><span class="line">                <span class="comment">// 注意，startTime 值是固定的，在工作线程启动就定了</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime() - startTime;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.2 判断是否可以进行 tick</span></span><br><span class="line">                <span class="comment">// 标准是：tick 触发的时间值 - currentTime &lt;= 0，没有到触发时间则休眠 sleepTimeMs 毫秒</span></span><br><span class="line">                <span class="comment">// 这里加 999999 是补偿精度，不足 1ms 的补足 1ms</span></span><br><span class="line">                <span class="keyword">long</span> sleepTimeMs = (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3 因为每次执行任务消耗的时间是不受控制的，因此计算出来的 sleepTimeMs 可能为负数</span></span><br><span class="line">                <span class="comment">// 当为负数时，说明前面的任务执行时间过长，导致本该 tick 的时候错过了。这个时候不需要休眠等待，需要立刻处理</span></span><br><span class="line">                <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -Long.MAX_VALUE;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 返回值是基于 startTime 计算的距离当前时间的时间戳</span></span><br><span class="line">                        <span class="keyword">return</span> currentTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// windows 平台特别处理。先除以10再乘以10，是因为windows平台下最小调度单位是10ms，如果不处理成10ms的倍数，可能导致sleep更不准了</span></span><br><span class="line">                <span class="keyword">if</span> (PlatformDependent.isWindows()) &#123;</span><br><span class="line">                    sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">if</span> (sleepTimeMs == <span class="number">0</span>) &#123;</span><br><span class="line">                        sleepTimeMs = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2.4 没有到 tick 时间，则休眠</span></span><br><span class="line">                    Thread.sleep(sleepTimeMs);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    <span class="comment">// 如果工作线程已经关闭，那么返回 Long.MIN_VALUE</span></span><br><span class="line">                    <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Long.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>waitForNextTick 方法的逻辑已经详细注释，该方法就是用来控制每隔一定的时间 “滴答” 一次即跳一个 bucket，此外还处理了因上一个 tick 处理任务时间过长问题，采用的是立即触发执行的方式。不难看出，当遇到较长时间执行的任务时，会打乱原本正常 tick 的节奏，导致其他任务延期执行。 <code>tickDuration</code> 控制着时间的精准度，值越小精准度越高，工作线程则越繁忙。</p><h3 id="processCancelledTasks"><a href="#processCancelledTasks" class="headerlink" title="processCancelledTasks"></a>processCancelledTasks</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- Worker</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理已经取消的任务。将已经取消的任务从对应的 bucket 中移除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCancelledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 遍历任务取消队列</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = cancelledTimeouts.poll();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// all processed</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 将 timeout 从对应的 bucket 中移除</span></span><br><span class="line">                    <span class="comment">// 通过 timeout 持有的 bukcet 进行的操作，即从bucket 链表中删除该 timeout </span></span><br><span class="line">                    timeout.remove();</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"An exception was thrown while process a cancellation task"</span>, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>该方法是为了处理那些被取消的任务，将被取消的任务从队列和 bucket 中分别移除。</p><h3 id="transferTimeoutsToBuckets"><a href="#transferTimeoutsToBuckets" class="headerlink" title="transferTimeoutsToBuckets"></a>transferTimeoutsToBuckets</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+--- Worker</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将 HashedWheelTimeout 队列中的任务加入到相应的 bucket 中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferTimeoutsToBuckets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 限制每 tick 最大转移 10 万个 HashedWheelTimeout 到 bucket，以免阻塞工作线程</span></span><br><span class="line">            <span class="comment">// todo 如果有 100万 个，并且 tickDuration 时间为几分钟级别，那这种情况下就会有一批任务延迟。从侧面说明一个时间轮不能一下子添加特别多的任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">                <span class="comment">// 队列为空</span></span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// all processed</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 被取消了</span></span><br><span class="line">                <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;</span><br><span class="line">                    <span class="comment">// Was cancelled in the meantime.</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">/*---   将任务放到相应的 bucket 中 ----*/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算任务触发时间需要经过多少个 tick</span></span><br><span class="line">                <span class="keyword">long</span> calculated = timeout.deadline / tickDuration;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算任务所属的轮次</span></span><br><span class="line">                timeout.remainingRounds = (calculated - tick) / wheel.length;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果任务在 timeouts 队列里面放久了, 以至于已经过了执行时间(calculated &lt; tick), 这个时候就使用当前 tick 对应的 bucket，从而让那些本应该在过去执行的任务在当前 tick 快速执行掉。</span></span><br><span class="line">                <span class="comment">// 此方法调用完后就会立即执行当前 tick 对应的 bucket 中的任务</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ticks = Math.max(calculated, tick); <span class="comment">// Ensure we don't schedule for past.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算 ticks 对应 bucket</span></span><br><span class="line">                <span class="keyword">int</span> stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask);</span><br><span class="line">                HashedWheelBucket bucket = wheel[stopIndex];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 单个 bucket 是由 HashedWheelTimeout 实例组成的一个链表，单个线程不存在并发</span></span><br><span class="line">                <span class="comment">// 这里将 timeout 加入到 bucket 的链表中</span></span><br><span class="line">                bucket.addTimeout(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在每次执行 tick 对应的 bucket 中的延时任务时，会先将全局任务队列中待执行的任务加入到对应的 bucket 中。</p><h3 id="expireTimeouts"><a href="#expireTimeouts" class="headerlink" title="expireTimeouts"></a>expireTimeouts</h3><p>一次 tick 到来后找到对应的 Bucket，然后就可以处理当前 Bucket 中的延时任务了，具体实现见前文。expireTimeouts 方法中会间接执行 <code>TimeTask.run</code> 方法，如果延时任务执行时间过久则会阻塞工作线程，进一步拖慢超时检测流程。</p><p>以上对 HashedWheelTimer 主要源码进行了分析，但没有串起来。下面我们以执行过程的形式进一步说明。</p><h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task  任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delay 延时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit  延迟时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 校验参数</span></span><br><span class="line">        ObjectUtil.checkNotNull(task, <span class="string">"task"</span>);</span><br><span class="line">        ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 校验等待任务数是否达到阈值</span></span><br><span class="line">        <span class="keyword">long</span> pendingTimeoutsCount = pendingTimeouts.incrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> (maxPendingTimeouts &gt; <span class="number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;</span><br><span class="line">            pendingTimeouts.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Number of pending timeouts ("</span></span><br><span class="line">                    + pendingTimeoutsCount + <span class="string">") is greater than or equal to maximum allowed pending "</span></span><br><span class="line">                    + <span class="string">"timeouts ("</span> + maxPendingTimeouts + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果工作线程没有启动，则启动工作线程。一般由第一个提交任务的线程负责工作线程的启动</span></span><br><span class="line">        start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将任务添加到队列中，该队列将在下一个 tick 时进行处理，在处理过程中，所有排队的 HashedWheelTimeout 将被添加到正确的 HashedWheelBucket 中 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 deadline 是一个相对时间，相对于工作线程启动时间。</span></span><br><span class="line">        <span class="comment">// 注意，该值作为延时任务触发的时间，后续流程虽然会判断，但是貌似用处不大。主要还是用在根据该值计算 tick 进而确定将任务分配到哪个 Bucket，因为任务触发是跟着 tick 走的。</span></span><br><span class="line">        <span class="keyword">long</span> deadline = System.nanoTime() + unit.toNanos(delay) - startTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Guard against overflow.</span></span><br><span class="line">        <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; deadline &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            deadline = Long.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 创建 HashedWheelTimeout 对象，进一步封装任务对象</span></span><br><span class="line">        HashedWheelTimeout timeout = <span class="keyword">new</span> HashedWheelTimeout(<span class="keyword">this</span>, task, deadline);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 加入到 timeouts 队列中，等待被加入到 Bucket 中</span></span><br><span class="line">        <span class="comment">// 注意，还没有加入到时间轮中</span></span><br><span class="line">        timeouts.add(timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> timeout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间轮在初始化后就可以接收业务方提交的延时任务请求了，任务的处理都是交给工作线程这个后台线程。提交任务的流程主要包含 3 个关键步骤：</p><blockquote><p>1 尝试启动工作线程 workerThread<br>2 计算延时任务的触发时间，创建 HashedWheelTimeout 对象进一步封装任务对象<br>3 将创建的 HashedWheelTimeout 对象加入到任务队列</p></blockquote><p>值得一提的是启动工作线程的逻辑，源码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动工作线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if this timer has been</span></span><br><span class="line"><span class="comment">     *                               &#123;<span class="doctag">@linkplain</span> #stop() stopped&#125; already</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果是初始化状态</span></span><br><span class="line">            <span class="keyword">case</span> WORKER_STATE_INIT:</span><br><span class="line">                <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;</span><br><span class="line">                    <span class="comment">// 启动工作线程</span></span><br><span class="line">                    workerThread.start();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WORKER_STATE_STARTED:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WORKER_STATE_SHUTDOWN:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cannot be started once stopped"</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Invalid WorkerState"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，直到 startTime 被工作线程初始化</span></span><br><span class="line">        <span class="keyword">while</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                startTimeInitialized.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                <span class="comment">// Ignore - it will be ready very soon.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到上述方法是 public 修饰的，也就是说用户可以显示的调用，而无需等待第一次提交任务时再启动。但一般没必要显示调用，没有任务提交没必要启动。</p><h2 id="执行任务-2"><a href="#执行任务-2" class="headerlink" title="执行任务"></a>执行任务</h2><p>前文也说了，时间轮中的任务都是由工作线程触发执行的。具体是<strong>一次 tick 到来</strong>后找到对应的 Bucket，然后就可以处理当前 Bucket 中的延时任务了。源码见前文。</p><h2 id="取消任务-1"><a href="#取消任务-1" class="headerlink" title="取消任务"></a>取消任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimeout</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// only update the state it will be removed from HashedWheelBucket on next tick.</span></span><br><span class="line">     <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_CANCELLED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 加入到取消任务队列中</span></span><br><span class="line">         timer.cancelledTimeouts.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>未到期但被取消的任务会放到 <code>cancelledTimeouts</code> 队列中，工作线程周期性调用 <code>processCancelledTasks()</code> 会从 bucket 中删除对应的 HashedWheelTimeout。</p><h2 id="终止时间轮"><a href="#终止时间轮" class="headerlink" title="终止时间轮"></a>终止时间轮</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 工作线程不能停止时间轮</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == workerThread) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    HashedWheelTimer<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>() +</span></span><br><span class="line">                            ".stop() cannot be called from " +</span><br><span class="line">                            TimerTask<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试 CAS 替换当前状态为 “停止：</span></span><br><span class="line">        <span class="keyword">if</span> (!WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) &#123;</span><br><span class="line">            <span class="comment">// workerState can be 0 or 2 at this moment - let it always be 2.</span></span><br><span class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.getAndSet(<span class="keyword">this</span>, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">                <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">assert</span> closed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 中断 worker线程，尝试把正在进行任务的线程中断掉,如果某些任务正在执行则会抛出interrupt异常，并且任务会尝试立即中断</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (workerThread.isAlive()) &#123;</span><br><span class="line">                workerThread.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    workerThread.join(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前前程会等待stop的结果</span></span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">assert</span> closed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回未处理的任务</span></span><br><span class="line">        <span class="keyword">return</span> worker.unprocessedTimeouts();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/hashedwheeltimer/hash-wheel-timer-process.jpg" alt></p><p>HashWheelTimer 是基于时间轮算法，提交的任务会被封装成 <code>HashedWheelTimeout</code> 对象并存放到全局任务队列中。时间轮的格子是用 bucket 数组表示，bucket 内部维护一个 <code>HashedWheelTimeout</code> 类型的双向链表，每一个节点都是一个 HashedWheelTimeout 对象。其内部使用一个工作线程自旋地进行 tick ，tick 到来后会先将全局任务队列中的任务添加到对应的 bucket 中，接着轮训当前 tick 对应 bucket 中的任务链表，执行轮次为 0 的任务，轮次非 0 的任务将其轮次减 1 。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p><strong>优点</strong></p><blockquote><p>1 本地机器直接执行，效率非常高。<br>2 无需扫描所有任务。通过将环切成 N 份，将查询到期延时任务的耗时降到 1/N，N 视任务量的大小可以灵活设置(1024,2048 等)</p></blockquote><p><strong>缺点</strong></p><blockquote><p>1 可靠性：<br>    -  机器重启，数据即丢失，可以使用 MySQL 等持久化存储，机器重启时从数据库 load 进内存。<br>    -  机器宕机，数据丢失，需要使用方自行处理，如由其它机器接管宕机机器的任务<br>2 时间轮调度器的时间精度可能不是很高，对于精度要求特别高的调度任务可能不太合适。因为时间轮算法的精度取决于一次 tick 的时间。<br>3 时间轮是通过单线程实现的，如果在执行任务的过程中出现阻塞，会影响后面任务执行。这个缺点也就是缺点 2 的直接体现。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>时间轮算法不难理解，但 HashedWheelTimer 源码中有很多细节需要注意。任务的管理，体现在任务队列和 bucket 数组的使用；任务的触发，体现在工作线程自旋进行 tick ；任务的执行，体现在工作线程轮询 bucket 的任务链表，对 TimerTask.run 的执行；需要注意的是，整个时间轮的调度都是在一个线程中完成的，因此对于那些耗时较大的定时任务会影响其他任务的正常触发和执行，但任务执行异常并不会导致工作线程退出，这是不同于 JDK 中的 Timer 。</p><p><strong>参考：</strong><br><a href="https://www.javadoop.com/post/HashedWheelTimer" target="_blank" rel="noopener">https://www.javadoop.com/post/HashedWheelTimer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;时间轮是一种高效利用线程资源来进行批量化调度的一种调度模型。将大批量的调度任务全部都绑定到同一个调度器上，使用这一调度器来进行所有任务的管理
      
    
    </summary>
    
    
      <category term="任务调度" scheme="https://gentryhuang.com/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
    
      <category term="HashedWheelTimer" scheme="https://gentryhuang.com/tags/HashedWheelTimer/"/>
    
  </entry>
  
  <entry>
    <title>并发 - ReentrantReadWriteLock</title>
    <link href="https://gentryhuang.com/posts/f3292e6c/"/>
    <id>https://gentryhuang.com/posts/f3292e6c/</id>
    <published>2021-07-10T12:46:36.000Z</published>
    <updated>2021-08-21T09:39:31.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>独占锁（排它锁）在同一时刻只允许一个线程进行访问，如 <a href="https://gentryhuang.com/posts/dd0ffc6a/">并发 - ReentrantLock</a> 一文中介绍的 <code>ReentrantLock</code> 就是一个独占锁。而读写锁在同一时刻可以允许多个<strong>读线程</strong>访问，但是在写线程访问时，所有的读线程和其它写线程都会被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，<strong>通过分离读锁和写锁，不仅保证了写操作对读操作的可见性，还使得并发性相比一般的排它锁有更大提升</strong>。在读多写少的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>读写锁除了保证写操作对读操作的可见性以及并发性的提升之外，<strong>读写锁还能够简化读写交互场景的编码实现</strong>。对于一个共享的缓存数据，一般都是读多写少，但是写操作完成之后的更新需要对后续的读操作可见，这样做的目的是使读操作能读取到正确的数据。使用读写锁实现这样的功能，只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取时，后续其它线程的读写操作都会被阻塞，写锁释放之后，所有操作才会继续执行。相比于使用<strong>等待-通知机制</strong>，更加简单化。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java 并发包提供读写锁的实现是 <strong>ReentrantReadWriteLock</strong> ，它支持以下特性：</p><ul><li><strong>公平性选择：</strong>支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平</li><li><strong>重入性：</strong>支持锁重入，包括读锁和写锁</li><li><strong>锁降级：</strong>同一个线程获取的写锁能够降级为读锁，反之不行。遵循获取写锁、获取读锁、释放写锁、释放读锁</li></ul><h1 id="读写状态"><a href="#读写状态" class="headerlink" title="读写状态"></a>读写状态</h1><p>读写锁 <code>ReentrantReadWriteLock</code> 同样是基于 AQS 实现的锁功能，而读写状态就是 AQS 的同步状态。在 <code>ReentrantLock</code> 中同步状态表示锁被一个线程持有的次数，而读写锁需要在同步状态上维护多个读线程和一个写线程的信息，这就使得<strong>同步状态的设计成为读写锁实现的关键</strong>。由于同步状态 <code>state</code> 是一个整型变量，4 个字节 32 位，因此读写锁将该变量切分成了两部分，高 16 位表示读，低 16 位表示写，划分方式如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/read-write-lock-state.png" alt></p><p>上图中的同步状态表示一个线程已经获取了写锁且重入了 2 次，同时也连续获取了两次读锁。<strong>读写锁是通过位运算来确定读和写各自的状态的</strong>。下面对状态的变化过程进行说明。</p><p><strong>假设当前同步状态 state 的值为 S</strong></p><ul><li>获取写状态<blockquote><p>S &amp; (1 &lt;&lt; 16 -1) -&gt; 将高16位全部抹去</p></blockquote></li><li>获取读状态<blockquote><p>S&gt;&gt;&gt;16 -&gt; 无符号补0，右移16位</p></blockquote></li><li>更新操作<blockquote><p>写状态增加 1 时 -&gt; S + 1<br>读状态增加 1 时 -&gt; S + (1&lt;&lt;16)，也就是 S + 0x00010000</p></blockquote></li></ul><p><strong>注意：</strong>读写锁 <code>ReentrantReadWriteLock</code> 虽然使用同步状态 <code>state</code> 的高低位来表示读写状态，但是同步队列依然是共用一个。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><strong>ReentrantReadWriteLock 的类继承关系类图如下:</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/read-write-lock-uml.jpg" alt></p><p>由继承关系图可知，读写锁 ReentrantReadWriteLock 是通过内部类 Sync 继承 AQS 来行使同步器的职能。由于该读写锁支持公平和非公平模式，因此通过继承内部类 Sync 的方式定义了非公平模式的 NonfairSync 和公平模式的 FairSync 。读写锁的实现依赖组合的 Sync ，也就是说 ReadLock 和 WriteLock 获取和释放锁的功能是交给 Sync 去实现的，公平模式下使用 FairSync ，非公平模式下使用 NonfairSync 。</p><p><strong>读写锁 ReentrantReadWriteLock 组合关系如下图所示：</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/read-write-lock-combination.jpg" alt></p><p><strong>ReentrantReadWriteLock 分为读锁 ReadLock 和写锁 WriteLock 。读锁是共享锁，可被多个线程同时占有；写锁是独占锁，同时只能有一个线程占有，且写锁被线程占有后其它线程既不能获取读锁也不能获取写锁，但占有写锁的线程可以在不释放写锁的情况下继续获取读锁，这是锁降级的特点。</strong></p><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6992448646407690164L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取写锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> writerLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取读锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readerLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync 继承自 AQS ,执行所有同步机制</span></span><br><span class="line"><span class="comment">     * 根据 ReentrantReadWriteLock 构造函数传入的布尔值决定要构造哪一种 Sync 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认创建非公平的 ReentrantReadWriteLock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的公平策略创建 ReentrantReadWriteLock</span></span><br><span class="line"><span class="comment">     * 说明：创建 ReentrantReadWriteLock 对象同时，会依次创建对应模式的 AQS 对象、读锁对象、写锁对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair 公平策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类 Sync ，继承 AQS</span></span><br><span class="line"><span class="comment">     * 1 具体子类包括：非公平模式 NonfairSync 和 公平模式 FairSync</span></span><br><span class="line"><span class="comment">     * 2 实现 AQS 中的独占和共享模式的两对方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平版本的 Sync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平版本的 Sync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span>  </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用外层的 ReentrantReadWriteLock 的 AQS 管理同步状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用外层的 ReentrantReadWriteLock 的 AQS 管理同步状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过前文分析的 <code>ReentrantReadWriteLock</code> UML 类图和相关的组合关系图，不难发现与上述代码结构是一一对应的。下面我们依次对读锁和写锁依赖的 AQS 相关实现进行介绍，理解了相关的实现后也就基本理解了读写锁的实现。</p><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 静态内部类 Sync ，继承 AQS</span></span><br><span class="line"><span class="comment">    * 具体子类包括：非公平模式 NonfairSync 和 公平模式 FairSync</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将同步状态 state 分为两段：高 16 位用于共享模式；低 16 位用于独占模式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 读锁的值操作单位</span></span><br><span class="line">       <span class="comment">// 由于高 16 位用于读锁，因此每次操作基于 1 左移 16 位的值，也就是从高 16 位的末尾进行计算</span></span><br><span class="line">       <span class="comment">// 即，同步状态 state 加减 1 &lt;&lt; 16 =&gt; 1 00000000 00000000</span></span><br><span class="line">       <span class="comment">// 写锁是低 16 位，直接对同步状态 state 加减</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 锁持有次数溢出的阈值，即 2^16 -1</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 独占模式掩码，即 1 &lt;&lt; 16 -1 =&gt; 11111111 11111111</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取 c 的高 16 位的值，代表读锁的获取次数，包括重入</span></span><br><span class="line"><span class="comment">        * 注意：该值是所有线程获取次数总和，包括每个线程重入情况</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取 c 的低 16 位的值，代表写锁的重入次数（写锁是独占模式）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//----------------------- 🌟线程读锁计数器 --------------------/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 用于记录每个线程持有的读锁次数(包括读锁重入)</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 线程持有读锁次数</span></span><br><span class="line">           <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ThreadLocal 的子类，保存线程变量副本 HoldCounter</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 初始化 HoldCounter</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 当前线程读锁计数器</span></span><br><span class="line">       <span class="comment">// 说明：使用 ThreadLocal 来记录当前线程持有的读锁次数</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 最后获取读锁的线程读锁计数器</span></span><br><span class="line">       <span class="comment">// 说明：缓存最后一个获取读锁的线程持有读锁的次数，这里不是全局的概念，所以不管哪个线程获取到读锁后，就把这个值占为已用</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 首个获取读锁的线程(并且其未释放读锁)读锁计数器</span></span><br><span class="line">       <span class="comment">// 说明：</span></span><br><span class="line">       <span class="comment">// 1 这里不是全局的概念，该值被设置的条件是，当获取读锁时此时读锁没有线程持有。等这个 firstReader 代表的线程释放掉读锁以后，会有新的线程占用这个属性，也就是这个"第一个"是动态的。</span></span><br><span class="line">       <span class="comment">// 2 在读锁不产生竞争的情况下，记录读锁重入次数是非常方便的</span></span><br><span class="line">       <span class="comment">// 3 如果一个线程使用了 firstReader，那么它就不需要占用 cachedHoldCounter 变量了</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//-------------------- 线程读锁计数器🌟 --------------------/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 构造方法中初始化</span></span><br><span class="line">       Sync() &#123;</span><br><span class="line">           <span class="comment">// 初始化 readHolds 这个 ThreadLocal 属性</span></span><br><span class="line">           readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">           <span class="comment">// 为了保证 readHolds 的内存可见性</span></span><br><span class="line">           setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取读锁是否需要阻塞，交给子类实现</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取写锁是否需要阻塞，交给子类实现</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略获取和释放同步状态方法对，即获取和释放读锁/写锁方法。</span></span><br><span class="line">       <span class="comment">// 在分析读锁和写锁时结合分析，这里先不展示源码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承 AQS 的静态内部类 Sync 负责读锁 ReadLock 和写锁 WriteLock 的获取与释放工作，对读写锁 ReentrantReadWriteLock 的公平和非公平支持交给了两个子类实现。下面对 Sync 中的属性和抽象方法进行介绍，这些属作为最基础的数据支持读写锁的运行与统计。</p><p><strong>同步状态</strong></p><blockquote><ul><li>读写锁将 int 类型的同步状态 state 同时赋予两种语义，高 16 位表示读锁的持有次数，包括线程重入锁的情况。获取到读锁一次：<code>state + (1&lt;&lt;16)</code>，释放掉读锁一次：<code>state - (1&lt;&lt;16)</code>；</li><li>低 16 位表示写锁的获取次数，因为写锁是独占锁，同时只能被一个线程获取，因此它代表的重入次数。获取写锁一次：<code>state + 1</code>，释放写锁一次：<code>state -1</code> 。</li></ul></blockquote><p><strong>线程读锁计数器</strong></p><blockquote><ol><li>每个线程都需要记录获取的读锁次数，这样才能知道到底是不是读锁重入。注意，判断读锁重入和写锁重入完全不一样。写锁属于独占锁，同一时刻写锁只能一个线程持有，因此同步状态的低 16 位的值就是该线程持有写锁的次数（包括重入）；读锁属于共享锁，同一时刻允许多个线程持有，而同步状态的高 16 位的值是所有线程持有的总次数（包括各个线程重入），因此不能借助同步状态得出各个读线程持有读锁的次数，也就不能判断是否读锁重入，因此需要线程读锁计数器来辅助完成该诉求。</li><li>读写锁使用 ThreadLocal<HoldCounter> 维护每个线程读锁计数器，这样就能识别出哪个线程持有多少次读锁，进而可以判断线程是否是读锁重入以及线程持有读锁的次数。此外，读写锁基于性能考虑，又引入 <strong>“首个线程读锁计数器”</strong> 和 <strong>“最后线程读锁计数器”</strong>。其实 <code>ThreadLocal&lt;HoldCounter&gt; readHolds</code> 完全可以完成计数，只是 ThreadLocal 内部基于 Map 来查询的，相比直接使用变量记录线程读锁计数信息性能要差了那么一丢丢，不过这两个计数器只能记录一个线程持读锁信息，并且是动态变化的，提升性能的依据是尽可能先用这两个计数器，然后才使用通用的 <code>ThreadLocal&lt;HoldCounter&gt; readHolds</code> 记录线程读锁信息。</HoldCounter></li><li><strong>“首个线程读锁计数器”</strong> 是使用 <strong>firstReader</strong> 和 <strong>firstReaderHoldCount</strong> 两个属性组合而成的。<strong>“最后线程读锁计数器”</strong> 是使用 <code>HoldCounter</code> 类型的 <strong>cachedHoldCounter</strong> 属性表示。</li></ol></blockquote><p><strong>读写公平策略</strong></p><blockquote><p>读写锁 ReentrantReadWriteLock 具体分为读锁 ReadLock 和写锁 WriteLock ，在公平和非公平模式下读锁和写锁的表现不同，因此将具体的实现交给公平和非公平子类实现。</p></blockquote><h3 id="非公平-Sync"><a href="#非公平-Sync" class="headerlink" title="非公平 Sync"></a>非公平 Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+--- ReentrantReadWriteLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平版本的 Sync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取写锁是否需要阻塞</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果是非公平模式，那么 lock 的时候就可以直接用去抢锁，抢不到再排队</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取读锁是否需要阻塞</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 判断同步队列中 head 的第一个后继节点是否是来获取写锁的，如果是，就算是非公平模式，也先让该节点获取写锁，避免线程饥饿</span></span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">            <span class="comment">//     final boolean apparentlyFirstQueuedIsExclusive() &#123;</span></span><br><span class="line">            <span class="comment">//        Node h, s;</span></span><br><span class="line">            <span class="comment">//        return (h = head) != null &amp;&amp;</span></span><br><span class="line">            <span class="comment">//            (s = h.next)  != null &amp;&amp;</span></span><br><span class="line">            <span class="comment">//            !s.isShared()         &amp;&amp;</span></span><br><span class="line">            <span class="comment">//            s.thread != null;</span></span><br><span class="line">            <span class="comment">//    &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在非公平模式下，写锁优先尝试抢占锁，抢占失败才会去排队；一般来说，非公平模式下读锁也应该直接尝试抢占锁，但是<strong>写锁被定义了更高的优先级</strong>，读锁会先判断队列中等待的第一个线程节点是否是获取写锁的，如果是就算是非公平模式也先让该节点获取写锁，避免线程饥饿。</p><h3 id="公平-Sync"><a href="#公平-Sync" class="headerlink" title="公平 Sync"></a>公平 Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+--- ReentrantReadWriteLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平版本的 Sync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取写锁是否需要阻塞</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 那么如果阻塞队列有线程等待的话，就乖乖去排队</span></span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断读是否要阻塞</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 同步队列中有线程节点在等待</span></span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在公平模式下，无论是写锁还是读锁，都遵循先来后到原则。<strong>需要说明的是，对于读锁的获取，无论是公平还是非公平模式，它都没有抢占的概念，即使是在非公平模式下，还是需要判断同步队列中的第一个线程节点是否是写线程</strong>。</p><p>至此，读锁和写锁的前置准备已经完成，下面我们进入到读锁和写锁的源码。</p><h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h2><p>读锁内部持有 <code>ReentrantReadWriteLock</code> 中的 Sync 类型的对象，可能是 <code>FairSync</code> 对象，也可能是 <code>NonfairSync</code> 对象，具体由 <code>ReentrantReadWriteLock</code> 构造函数决定。ReadLock 锁获取与释放功能全部委托给 <strong>sync</strong> 对象完成。 </p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--- ReentrantReadWriteLock</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用 AQS 管理同步状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> lock</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="获取读锁"><a href="#获取读锁" class="headerlink" title="获取读锁"></a>获取读锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">+--- ReadLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 模版方法，获取共享同步状态</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+--- AQS</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试获取读锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+--- Sync</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 模版方法，获取共享同步状态 - 获取读锁</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1 读锁是一个支持重入的共享锁，它能被多个线程同时获取，在没有其它写线程访问时（注意非公平模式下同步队列中首个获取写锁的线程节点的情况），读锁总会被成功地获取，而所做的也只是增加读状态。</span></span><br><span class="line"><span class="comment">     * 2 如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其它线程获取，则进入等待状态。</span></span><br><span class="line"><span class="comment">     * 3 读锁的实现有两部分逻辑，一个是获取读锁，另一个是设置线程的读锁计数器。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取同步状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 exclusiveCount(c) != 0 ，说明有线程持有写锁。如果不是当前线程持有的写锁，那么当前线程获取读锁失败。</span></span><br><span class="line">        <span class="comment">// 由于读写锁的降级，如果当前线程持有写锁，是可以继续获取读锁的</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 读锁的获取次数</span></span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 获取读锁是否需要被阻塞（需要考虑公平与非公平的情况）</span></span><br><span class="line">        <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                <span class="comment">// 判断持有读锁次数是否会溢出 (2^16-1)</span></span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                <span class="comment">// 使用  CAS 是将 state 属性的高 16 位加 1，低 16 位不变，如果成功就代表获取到了读锁</span></span><br><span class="line">                <span class="comment">// c + 1 00000000 00000000</span></span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 进入当前代码区域，表示获取到了读锁。下面的逻辑是记录线程读锁计数器，用于标记当前线程持读锁次数，为判断是否读锁重入以及线程获取读锁次数做基础数据准备 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.1 r == 0 说明当前线程是第一个获取读锁的线程，或者是在它之前的读锁都已经释放了</span></span><br><span class="line">            <span class="comment">// 记录 firstReader 为当前线程，及其持有的读锁数量：1</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5.2 当前线程重入锁，加 1 即可</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5.3 当前线程不是第一个获取读锁，并且已经有其它线程获取了读锁</span></span><br><span class="line">                <span class="comment">// - 使用 readHolds 保存当前线程持有的读锁次数</span></span><br><span class="line">                <span class="comment">// - 将当前线程持有读锁信息更新为 cachedHoldCounter 的值，该变量用于记录最后一个获取读锁的线程持锁信息</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取最后一个获取读锁的线程信息。</span></span><br><span class="line">                Sync.HoldCounter rh = cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 cachedHoldCounter 缓存的不是当前线程，则将当前线程持有读锁信息缓存到 HoldCounter</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// cachedHoldCounter 缓存的是当前线程，但 count 为 0</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将当前线程持有读锁次数 count 加 1</span></span><br><span class="line">                rh.count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// return 大于 0 代表获取到了共享锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进入下面方法，可能是以下三种情况：</span></span><br><span class="line">        <span class="comment">// - compareAndSetState(c, c + SHARED_UNIT) 存在竞争，CAS 失败</span></span><br><span class="line">        <span class="comment">// - 公平模式 FairSync 下同步队列中有其它线程节点在等待锁</span></span><br><span class="line">        <span class="comment">// - 非公平模式 NonFairSync 下，同步队列中第一个线程节点（head.next）是获取写锁的，为了避免写锁饥饿，获取读锁的线程不应该和它竞争</span></span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>读锁获取使用 AQS 的共享模式获取同步状态，整个流程如下：</p><ol><li>判断写锁是否被其它线程占有（支持锁降级获取读锁），如果被其它线程占有直接获取读锁失败。</li><li>根据具体的公平或非公平模式判断获取读锁是否需要阻塞，阻塞的话会进入后续二次确认方法，即判断是否是重入获取读锁，重入获取读锁不需要阻塞。</li><li>获取读锁成功后，记录线程读锁计数器。</li></ol><p><strong>获取读锁的注意事项如下：</strong></p><ul><li>获取读锁前提条件是写锁没有被其它线程持有，当前线程持有写锁是可以继续获取读锁的，这是读写锁的锁降级特性。</li><li>在公平模式下，获取读锁时同步队列中有等待的线程节点，如果此时不是重入获取读锁，那么获取锁失败。</li><li>在非公平模式下，获取读锁时同步队列中第一个线程节点是获取写锁的情况，此时如果不是重入获取读锁，那么获取锁失败。写锁被定义更高的优先级。</li><li>获取锁成功后，需要记录当前线程读锁计数器。<strong>线程读锁计数器有两个作用，一个是用于判断线程是否是重入读锁，另一个是提供当前线程获取读锁的次数</strong>。</li></ul><h4 id="fullTryAcquireShared"><a href="#fullTryAcquireShared" class="headerlink" title="fullTryAcquireShared"></a>fullTryAcquireShared</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">+--- Sync</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这段代码与 tryAcquireShared 中的代码在一定程度上是冗余的，但由于没有使用重试和惰性读取保持计数之间的交互使 tryAcquireShared 复杂化，所以总体上更简单。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current 当前线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录线程获取读锁的次数</span></span><br><span class="line">        Sync.HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for 循环</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">// 1 获取同步状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 如果其它线程获取了写锁，那么当前线程是不能获取到读锁的，只能去同步队列中排队</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                <span class="comment">// would cause deadlock.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3 获取读锁应该阻塞，说明同步队列中有其它线程在等待。</span></span><br><span class="line">                <span class="comment">// 注意： 既然是获取读锁应该阻塞，那么进入有什么用呢？ 是用来处理读锁重入的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// firstReader 线程重入锁，暂不做操作，直接执行后面的 CAS</span></span><br><span class="line">                <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 非 firstReader 线程重入锁，则继续判断其它情况重入锁</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 判断是否是 cachedHoldCounter 重入锁，如果也不是，那就是既不是 firstReader 可重入也不是 lastReader 可重入，</span></span><br><span class="line">                        <span class="comment">// 这是只需从 ThreadLocal 取出当前线程持有读锁信息，如果没有占有，则进行兜底操作，让线程去排队</span></span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 那么到 ThreadLocal 中获取当前线程的 HoldCounter</span></span><br><span class="line">                            <span class="comment">// 注意，如果当前线程从来没有初始化过 ThreadLocal 中的值，get() 会执行初始化</span></span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 如果发现 count == 0，也就是说是上一行代码初始化的，之前该线程并没有持有读锁，那么执行 remove 操作清空信息，因为接下来该线程要入队等待了</span></span><br><span class="line">                            <span class="comment">// 然后往下两三行，乖乖排队去</span></span><br><span class="line">                            <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                readHolds.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 非重入，去同步队列中排队</span></span><br><span class="line">                    <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里 CAS 成功，那么就意味着成功获取读锁了</span></span><br><span class="line">            <span class="comment">// 下面需要做的是设置 firstReader 或 cachedHoldCounter，以及 readHolds，记录线程读锁信息</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注意这里 c 是上面的快照，上面修改的不是 c 而是 state</span></span><br><span class="line">                <span class="comment">// 如果发现 sharedCount(c) 等于 0，也就是当前没有线程持有读锁，就将当前线程设置为 firstReader</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果是重 firstReader 重入，直接累加持有读锁的次数即可</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将 cachedHoldCounter 设置为当前线程持有读锁信息，并且使用 ThreadLocal 记录当前线程持有读锁信息</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 累加当前线程持读锁次数</span></span><br><span class="line">                    rh.count++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 更新 cachedHoldCounter 为当前线程持有读锁信息</span></span><br><span class="line">                    cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回大于 0 的数，代表获取到了读锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>上述方法在一定程度上是对 <code>tryAcquireShared</code> 方法的冗余，主要是对并发获取读锁失败以及重入获取锁的处理。具体作用如下：</strong></p><blockquote><ol><li>tryAcquireShared 方法中 CAS 获取同步状态失败后增加获取读锁成功的机会，尽可能不进入同步队列。</li><li>处理 tryAcquireShared 中因获取读锁需要阻塞的情况（上述方法只会处理重入读锁的情况，因为重入读锁不需要阻塞，非重入就需要阻塞，也就是获取读锁再次失败）<ul><li>在非公平模式 NonFairSync 情况下，如果同步队列中 head.next 是获取写锁的节点，那么如果该线程不是重入读锁则获取失败，如果是重入读锁则获取成功，因为重入优先级更高。</li><li>在公平模式 FairSync 情况下，如果同步队列中有线程节点等待，那么如果不是重入读锁则获取失败，如果是重入读锁则获取成功，同样地，因为重入优先级更高。</li></ul></li></ol></blockquote><h3 id="释放读锁"><a href="#释放读锁" class="headerlink" title="释放读锁"></a>释放读锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">+--- ReadLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">+--- AQS</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">+--- Sync</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS模版方法，释放共享同步状态 - 释放读锁</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 读锁的每次释放均减少读状态，减少的值是 1&lt;&lt;16</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 如果当前线程是 firstReader ，说明当前线程是第一个读线程</span></span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 firstReaderHoldCount 等于 1 ，那么本次解锁后就不再持有锁了，需要把 firstReader 置为 null</span></span><br><span class="line">            <span class="comment">// 没有设置 firstReaderHoldCount = 0 ，是因为没必要，其他线程使用的时候自己会重新设置该值</span></span><br><span class="line">            <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                firstReader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                firstReaderHoldCount--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 当前线程不是首个获取读锁的线程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断当前线程是不是最后获取读锁的线程，不是的话要到 ThreadLocal 中取</span></span><br><span class="line">            Sync.HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                rh = readHolds.get();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取计数</span></span><br><span class="line">            <span class="keyword">int</span> count = rh.count;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 将 ThreadLocal remove 掉，防止内存泄漏。因为已经不再持有读锁了</span></span><br><span class="line">                readHolds.remove();</span><br><span class="line">                <span class="comment">// 防止释放锁和获取锁次数不匹配</span></span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// count 减 1</span></span><br><span class="line">            --rh.count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 将同步状态 state 的高 16 位减 1，如果发现读锁和写锁都释放完了，那么唤醒后继的等待线程节点</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取同步状态 state</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// nextc 是 state 高 16 位减 1 后的值</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 nextc == 0，那就是 state 全部 32 位都为 0，也就是读锁和写锁都没有被占有</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="comment">// 释放读锁对读操作没有影响，但是如果现在读锁和写锁都是空闲的，那么释放读锁可能允许等待的写操作继续进行。</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>读锁释放过程比较简单，主要还是对应的两个操作，具体如下：</p><ul><li>更新当前释放读锁的线程对应的读锁计数器，如果是完全释放锁，则需要销毁对应的读锁计数器。</li><li>更新同步状态的高 16 位的值，表示释放读锁。如果是完全释放锁，则当前线程去唤醒同步队列中的线程节点。</li></ul><h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h2><p>写锁是一个支持重入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p><p>写锁内部持有 <code>ReentrantReadWriteLock</code> 中的 Sync 类型的对象，可能是 <code>FairSync</code> 对象，也可能是 <code>NonfairSync</code> 对象，具体由 <code>ReentrantReadWriteLock</code> 构造函数决定。ReadLock 锁获取与释放功能全部委托给 <strong>sync</strong> 对象完成。 </p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--- ReentrantReadWriteLock</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁</span></span><br><span class="line"><span class="comment">     * 1 写锁是独占锁</span></span><br><span class="line"><span class="comment">     * 2 如果有读锁被占用，写锁获取要进入同步队列中等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取写锁"><a href="#获取写锁" class="headerlink" title="获取写锁"></a>获取写锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">+--- WriteLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+--- AQS</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+--- Sync</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 模版方法，获取独占同步状态 - 获取写锁</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1 该方法除了重入条件（当前线程是获取了写锁的线程）之外，增加了一个读锁是否存在的判断。</span></span><br><span class="line"><span class="comment">     * 2 如果存在读锁，则写锁不能被获取，原因在于，读写锁要确保写锁的操作对读锁可见，如果允许读锁在已经被获取的情况下对写锁的获取，</span></span><br><span class="line"><span class="comment">     * 那么正在运行的其它读线程就无法感知到当前写线程的操作。因此，只有等待其它读线程都释放了读锁，写锁才能被当前线程获取。</span></span><br><span class="line"><span class="comment">     * 3 写锁一旦被获取，则其它读写线程的后续访问都被阻塞。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取同步状态 state</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 根据 state 获取写锁的持有次数</span></span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4  c != 0 表示要么有线程持有读锁，要么有线程持有写锁</span></span><br><span class="line">        <span class="comment">// 由于该方法是获取写锁，因此下面只能是写锁重入分支（存在持有读锁的情况直接失败）</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c != 0 &amp;&amp; w == 0: 写锁可用，但是有线程持有读锁(也可能是自己持有，但由于不支持锁升级，因此不能获取写锁)</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> ||</span><br><span class="line">                    <span class="comment">// c != 0 &amp;&amp; w !=0 &amp;&amp; current != getExclusiveOwnerThread(): 非重入，其他线程持有写锁</span></span><br><span class="line">                    current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断写锁持有次数是否超过阈值（65535）</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 能到这里的，只可能是写锁重入，更新同步状态即可</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里，此时 state == 0 ，读锁和写锁都没有被获取</span></span><br><span class="line">        <span class="comment">// 5 获取写锁，这里判断是否需要阻塞（这里考虑到公平还是非公平）</span></span><br><span class="line">        <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                <span class="comment">// 不需要阻塞，则更新 state</span></span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 当前线程独占锁</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写锁获取使用 AQS 的独占模式获取同步状态的流程，整个流程如下：</p><ol><li>判断读锁是否被线程持有（包括当前线程自身），如果被持有则获取写锁直接失败。</li><li>判断是否是重入获取写锁，如果不是直接获取写锁失败。</li><li>根据具体的公平或非公平模式判断获取写锁是否需要阻塞，如果不需要阻塞则尝试获取写锁，成功后当前线程独占锁。</li></ol><h3 id="释放写锁"><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+--- WriteLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+-- AQS</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">+--- Sync</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 模版方法，释放独占同步状态 - 释放写锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> releases</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  当前线程是否占有锁，否则没有资格尝试释放写锁</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算同步状态剩余值</span></span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写锁重入次数是否为 0 ，为 0 表示可以释放</span></span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完全释放</span></span><br><span class="line">        <span class="keyword">if</span> (free)</span><br><span class="line">            <span class="comment">// 清空独占线程</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 state</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写锁的释放与 <code>ReentrantLock</code> 的释放过程基本类似，每次释放均减少写状态，当写状态为 0 时表示写锁可以被释放。</p><h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>ReentrantReadWriteLock 锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。<strong>锁降级是指持有写锁的线程在不释放写锁的同时，再获取到读锁，随后释放写锁，最后释放读锁</strong>。</p><p><strong>锁降级示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line"> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">volatile</span> Boolean updateFlag = Boolean.FALSE;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取缓存，一旦缓存被修改破坏，需要更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取读锁，该方法主要是读取缓存数据</span></span><br><span class="line">        readLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共享数据发生改变，需要重新计算缓存数据</span></span><br><span class="line">        <span class="keyword">if</span> (updateFlag) &#123;</span><br><span class="line">            <span class="comment">// 必须先释放掉读锁，后续加写锁更新缓存</span></span><br><span class="line">            readLock.unlock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 获取写锁，用于只有一个线程更新缓存</span></span><br><span class="line">            writeLock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (updateFlag) &#123;</span><br><span class="line">                    <span class="comment">// 更新缓存值</span></span><br><span class="line">                    cacheData = caculateCacheData();</span><br><span class="line">                    updateFlag = Boolean.FALSE;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 获取读锁</span></span><br><span class="line">                readLock.lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 3 释放写锁</span></span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以上 1、2、3 步完成锁降级，即写锁降级为读锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用缓存</span></span><br><span class="line">            System.out.println(<span class="string">"print cache: "</span> + cacheData);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述示例中，缓存数据可用时，每个线程只需获取读锁然后访问，数据访问完成后释放读锁。但当共享的缓存数据被破坏，此时所有访问 processData 方法的线程都能感知到，但只有一个线程能够获取写锁然后更新缓存，其它线程都会被阻塞。当线程更新完缓存数据后，会接着获取读锁，随后才会释放写锁，完成锁的降级。</p><p>锁降级中的读锁获取是否有必要？答案是必要的，主要是为了保证数据的可见性。如果线程计算完缓存后没有获取读锁而是直接释放掉了写锁，那么此时如果存在另一个线程 t 获取了写锁并修改了缓存，那么当前线程就无法感知线程 t 的数据更新。如果当前线程在释放掉写锁前获取读取，也就是遵循锁降级的步骤，则线程 t 就无法获取写锁，直到当前线程访问数据并释放掉读锁后，线程 t 才能有机会获取写锁更新缓存数据。</p><p><strong>注意:</strong> ReentrantReadWriteLock 不支持锁升级，即持有读锁时再获取写锁，随后释放读锁。不支持的目的是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新数据，则其更新对其它获取到读锁的线程是不可见的。此外，是为了避免发生死锁，试想一个线程先获取读锁，然后再获取写锁，那么该线程会由于获取写锁失败进入同步队列中等待，可能之后就不会被唤醒了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>ReentrantReadWriteLock 读写锁正如其名，具体分为读锁和写锁。无论是读锁还是写锁，整个获取与释放锁的流程都是交给实现 AQS 的 Sync 类型的对象完成，准确来说是公平 Sync 或者非公平 Sync 对象。对于读锁和写锁的语义，是将同步状态 <code>state</code> 划分为高低位，高 16 位表示读锁状态，低 16 位表示写锁状态。写锁的获取和释放锁类似重入锁 <code>ReentrantLock</code> 过程，唯一不同的是写锁需要考虑读锁的占有情况。读锁的获取和释放比较复杂，复杂的主要原因是读锁允许多个线程同时获取且支持可重入，此时同步状态的高 16 位的值没办法表示各个线程持有读锁的情况，因此读写锁新增了<strong>线程读锁计数器</strong>的概念，有了这个概念就可以很轻松判断读线程重入锁的情况以及实时获取当前线程持有读锁的次数。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/reentrant-read-write-lock-summary.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;独占锁（排它锁）在同一时刻只允许一个线程进行访问，如 &lt;a href=&quot;https://gentryhuang.com/posts/dd0f
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
      <category term="AQS" scheme="https://gentryhuang.com/tags/AQS/"/>
    
      <category term="Lock" scheme="https://gentryhuang.com/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>网络通信 - IO多路复用</title>
    <link href="https://gentryhuang.com/posts/b25f5b99/"/>
    <id>https://gentryhuang.com/posts/b25f5b99/</id>
    <published>2021-06-12T02:43:23.000Z</published>
    <updated>2022-01-21T07:10:05.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>IO多路复用简单来说就是，单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力，IO多路复用解决的本质问题是用更少的资源完成更多的事。需要说明的是，处理IO多路复用的问题需要操作系统提供内核级别的支持，操作系统充当观察者的角色。本篇文章我们就来分析IO多路复用底层实现原理，我们以 Linux 操作系统提供的IO复用API <code>select</code>、<code>poll</code> 以及<code>epoll</code> 为例，逐一进行分析。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>实现IO多路复用直接使用用户线程轮询查看若干个文件描述符的状态难道不行吗？为什么要操作系统内核支持？在请求量比较小的时候确实可以使用该方案，但是在大量请求的情况下，这对于 CPU 的使用率来说无疑是种灾难。而使用操作系统内核帮我们观察文件描述符就可以优雅、高效地实现IO多路复用。</p><p>操作系统内核虽然清楚知道每个文件描述符对应的 Socket 的状态变化，但是内核如何知道该把哪个文件描述符信息给哪个进程呢？一个 Socket 文件可以由多个进程使用，而一个进程也可以使用多个 Socket 文件，进程和 Socket 之间是多对多的关系。此外，一个 Socket 也会对应多个事件类型。操作系统表示太难了，它很难判断将哪种事件触发的 Socket 给哪个进程。因此，<strong>在进程内部就需要维护自己关注哪些 Socket 文件的哪些事件，如读事件、写事件以及异常事件等。也就是说，内核帮应用程序盯着感兴趣的 Socket ，应用程序可以根据内核反馈的信息进一步处理网络请求</strong>。</p><p><strong>综上，我们需要关注以下三个问题：</strong></p><ul><li>多路复用机制可以监听哪些套接字</li><li>多路复用机制会监听套接字上的哪些事件</li><li>套接字就绪时，多路复用机制要如何找到就绪的套接字</li></ul><p>下面我们带着这些问题，结合 Linux 下的IO复用API进行分析。</p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>select 实现IO多路复用的思想是：操作系统内核会扫描用户进程传入的 3 类 fd_set 文件描述数组(本质是 bitmap)，当对应的 Socket 准备就绪时会置位（标志对应的 Socket 有数据来了） fd_set 数组中对应的元素，最后将内核置位后的 fd_set 数组们拷贝回用户空间。由于 select 并不会明确指出是哪些文件描述符就绪（一股脑返回全部 fd），因此用户进程需要根据内核返回的 fd_set 数组们自行判断哪个文件描述符对应的 Socket 发生了哪种事件，然后再进一步处理。</p><h2 id="API定义"><a href="#API定义" class="headerlink" title="API定义"></a>API定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 监听感兴趣的文件描述符上的事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, </span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *readfds, fd_set *writefds,fd_set *exceptfds, </span></span></span><br><span class="line"><span class="function"><span class="params">           struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd_set 可以理解为一个集合，这个集合中存放的是文件描述符，可通过以下四个宏进行设置：</span></span><br><span class="line"><span class="comment">// 1 将一个文件描述符移除集合中 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2  检查一个文件描述符是否在集合中，可以用这个来检测一次select调用之后有哪些文件描述符可以进行IO操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 添加一个文件描述符到集合中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 清空给定集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>select 将监听的文件描述符分为了 3 类，每一类都对应一个 fd_set 数组，本质上是一个 bitmap，也就是字节数组。分别是 <strong>writefds（写文件描述符）</strong>、<strong>readfds（读文件描述符）</strong>以及 <strong>exceptfds（异常事件文件描述符）</strong>。每一类都代表 Socket 对应的事件，每一类存储的都是 Socket 对应的文件描述符。用户进程可以根据需要，准备相关 fd_set 数组，在调用 select 函数时，这三个事件参数可以用 NULL 来表示对应的事件不需要监听。其实也不难看出，select 模型下操作系统内核并没有维护存储文件描述符相关的数据结构，只是定义了 fd_set ，将维护工作交给了用户进程。</p><p>下面我们对 select 相关的每个函数进行说明。</p><p><strong>void FD_SET</strong></p><blockquote><p>用户进程可以调用 FD_SET 函数将指定的文件描述符 fd 设置到准备的 fd_set 数组中。</p></blockquote><p><strong>void FD_CLR</strong></p><blockquote><p>用户进程可以调用 FD_CLR 函数将指定的文件描述符 fd 从准备的 fd_set 数组移除。</p></blockquote><p><strong>void FD_ZERO</strong></p><blockquote><p>用户进程可以调用 FD_ZERO 函数将 fd_set 数组清空。该函数主要用来每次调用 select 函数之前，清空 fd_set 数组，因为每次调用 select 函数监听就绪的 Socket 时，内核会根据就绪的 Socket 情况修改用户进程传入的数组，将就绪的 Socket 对应在 fd_set 数组中元素置位，也就是说 fd_set 不可重用。</p></blockquote><p><strong>int select</strong></p><blockquote><p>用户进程可以在超时时间内，监听感兴趣的文件描述符上的事件（读/写/异常事件）发生。下面我们对相关参数和返回值进行说明。</p></blockquote><p>参数：</p><blockquote><ul><li><strong>int nfds:</strong> fd_set 数组当中最大描述符加 1，用来告知内核扫描的bitmap的范围。</li><li><strong>fd_set *readfds:</strong> 要监听的读事件就绪的 Socket 的文件描述符数组，传 NULL 表示对应的事件不需要监听。</li><li><strong>fd_set *writefds:</strong> 要监听的写事件就绪的 Socket 的文件描述符数组，传 NULL 表示对应的事件不需要监听。</li><li><strong>fd_set *exceptfds:</strong> 要监听的异常事件对应的 Socket 的文件描述符数组，传 NULL 表示对应的事件不需要监听。</li><li><strong>struct timeval *timeout:</strong> 超时时间</li></ul></blockquote><p>返回值：</p><blockquote><p>监听的就绪 Socket 的描述符其数目，若超时则为0，若出错则为-1</p></blockquote><p><strong>int  FD_ISSET</strong></p><blockquote><p>用户进程可以调用 FD_ISSET 函数判断文件描述符是否置位了，如果置位就说明对应的 Socket 已就绪。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>准备监听的文件描述符上的事件</strong></p><p>应用程序可以根据具体需要，将 Socket 对应的文件描述符放入到 fd_set 数组中，在调用 select 函数时根据要监听的事件类型传入对应的 fd_set 数组。注意，Socket 不限于客户端的 Socket，服务端的 Socket 也可以，比如监听服务端 Socket 的连接事件发生。其中的用户进程通过调用 FD_SET 函数，将文件描述符写入到 fd_set 数组中，也就是将对应的位设置为 1，具体如下：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/io-multi-select-1.jpg" alt></p><p>对于 select 模型，操作系统内核只是定义了文件描述符事件相关数据结构 fd_set，并没有在内核中提供维护文件描述符事件的数据结构。也就是说，应用程序需要根据系统内核提供的 fd_set 自行处理文件描述符相关数据。</p><p><strong>等待文件描述符就绪</strong></p><p>应用进程调用 select 函数，操作系统内核会依次遍历传入的每类 fd_set 数组，判断 fd_set 中元素对应的 Socket 有没有数据，这个过程的事件复杂度为 O(n)。如果有数据就对 fd_set 数组中的该 Socket 对应的元素进行置位，最后内核将 fd_set 拷贝回用户空间，不会阻塞当前调用进程。如果要监听的 fd_set 中的所有 Socket 都没有数据，那么进程将会阻塞在 select 函数上，直到超时或有 Socket 就绪，才会唤醒进程。</p><p>在内核遍历 fd_set 数组时，如果对应的 Socket 没有数据，那么内核会将用户进程加入到该 Socket 的等待队列中，这一点非常重要。</p><p><strong>文件描述符就绪</strong></p><p>当监听的任何一个 Socket 就绪时，中断程序将唤醒 Socket 等待队列中的进程，即每次唤醒都需要从每个 Socket 等待队列中移除进程。当用户进程被唤醒时，它知道至少有一个监视的 Socket 发生了感兴趣的事件。同时，内核会对该 Socket 对应在 fd_set 数组中的元素进行置位，然后将修改后的 fd_set 数组们拷贝回用户空间。</p><p>注意，select 虽然可以拿到内核修改后的 fd_set 数组，但是它并不知道是哪个 Socket 发生了哪个事件，需要用户进程自己去判断。</p><p><strong>处理网络请求</strong></p><p>用户进程拿到内核返回的 fd_set 数组包含整个文件描述符，程序不知道哪些 Socket 就绪，因此需要自行判断是哪个或哪些 Socket 发生了哪个事件，找到对应的 Socket 后，处理网络请求。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个服务端 Socket 套接字，</span></span><br><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span> (addr));</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">2000</span>);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">bind(sockfd,(struct sockaddr*)&amp;addr ,<span class="keyword">sizeof</span>(addr));</span><br><span class="line"><span class="built_in">listen</span> (sockfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备客户端连接对应的文件描述符</span></span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">  addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">  <span class="comment">// 创建客户端 Socket 套接字,并保存对应的文件描述符</span></span><br><span class="line">  <span class="comment">// 注意，文件描述符是操作系统随机分配的一个非负整数</span></span><br><span class="line">  fds[i] = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存最大的文件描述符</span></span><br><span class="line">  <span class="keyword">if</span>(fds[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">      <span class="built_in">max</span> = fds[i];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select 实现多路复用</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="comment">// 1 调用  FD_ZERO 清理 rset 数组</span></span><br><span class="line">   FD_ZERO(&amp;rset);</span><br><span class="line">   <span class="comment">// 2 调用 FD_SET 设置监听的文件描述符到 rset 数组中</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">       FD_SET(fds[i],&amp;rset);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3 调用 slect 函数阻塞等待数据的到来，内核会判断 Socket 就绪情况</span></span><br><span class="line">   <span class="comment">// max+1 告知内核扫描 fd_set 数组范围</span></span><br><span class="line">   <span class="comment">// 这里只传入了 fd_set *readfds 参数，表示只监听读事件</span></span><br><span class="line">   select(<span class="built_in">max</span>+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4 监听的 Socket 有读就绪</span></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">       <span class="comment">// 调用 FD_ISSET 判断 rset 是否有置位</span></span><br><span class="line">       <span class="keyword">if</span> (FD_ISSET(fds[i], &amp;rset))&#123;</span><br><span class="line">           <span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line">           <span class="built_in">read</span>(fds[i], <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line">           <span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>单个进程能够监视的文件描述符的数量存在最大限制，通常是 1024 ，当然可以更改数量，但由于 select 采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差。</li><li>每次调用 select，都需要把 fd 数组在用户空间与内核空间来回拷贝，并且内核需要遍历传递进来的所有 fd 才能知道是否有 fd 准备就绪，这个开销随着 fd 变多而增大。</li><li>select 返回的是含有整个文件描述符的数组，并非明确指出哪些文件描述符就绪了，因此应用程序需要遍历整个数组才能发现哪些文件描述符号对应的 Socket 发生了事件。</li></ol><h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p>poll 的实现和 select 非常相似，只是描述 fd 集合的方式不同，它们的工作原理是一样的。select 是将文件描述符分为了 3 类，使用 fd_set 结构存储，针对每一类文件描述符可关联对应的事件。<strong>poll 对所有文件描述符一视同仁，针对每个文件描述关联事件即可。具体的做法是通过定义了一个结构体 pollfd，将文件描述符和感兴趣的事件绑定在一起。这就是 poll 和 select 的主要区别，也就是说 poll 使用 pollfd 数组解决了 select 使用 bitmap 存储文件描述符数量限制问题。需要注意的是，poll 仍然没有解决 select 中的其它问题</strong>。</p><h2 id="API-定义"><a href="#API-定义" class="headerlink" title="API 定义"></a>API 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// 文件描述符和关联的事件结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 感兴趣的事件</span></span><br><span class="line">    short events; <span class="comment">/* requested events to watch */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核检测到的实际事件</span></span><br><span class="line">    short revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">    </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p><strong>下面对 poll 函数的参数和返回值说明：</strong></p><p>参数：</p><blockquote><ul><li><strong>struct pollfd *fds:</strong> 该数组用于存放用户进程监听的 Socket 文件描述符事件信息，每一个元素都是 pollfd 结构。fd 属性用于存放关注的 Socket 文件描述符；events 属性用于存方关注的事件；revents 是内核检测到 fd 对应的 Socket 实际发生的事件。</li><li><strong>nfds_t nfds:</strong> 用于告诉内核 fds 数组的大小，内核会根据该参数去遍历 fds 数组。</li><li><strong>int timeout:</strong> 阻塞等待的超时时间</li></ul></blockquote><p>返回值：</p><blockquote><p>fds 集合中就绪的描述符数量，返回 0 表示超时，返回 -1 表示出错。</p></blockquote><h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">   addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">   <span class="comment">// 1 使用 pollfd 结构准备文件描述符</span></span><br><span class="line">   pollfds[i].fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">   <span class="comment">// 设置感兴趣的事件</span></span><br><span class="line">   pollfds[i].events = POLLIN;</span><br><span class="line">  &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 调用 poll 阻塞等待数据的到来，内核会判断 Socket 就绪情况</span></span><br><span class="line">    poll(pollfds, <span class="number">5</span>, <span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 用户进程自己判断哪个 Socket 发生了 POLLIN </span></span><br><span class="line">        <span class="keyword">if</span> (pollfds[i].revents &amp; POLLIN)&#123;</span><br><span class="line">            <span class="comment">// 重置 revents ，</span></span><br><span class="line">            pollfds[i].revents = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line">            <span class="built_in">read</span>(pollfds[i].fd, <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>poll 的改进主要是围绕着存储文件描述符事件的结构体 pollfd 来展开的</strong>，用户进程准备的各种文件描述符事件都是由该结构体存储的，此外内核检测到 Socket 就绪会设置对应的 pollfd 中的 revents 属性的值。虽然 poll 提供了更优质的编程接口，但是本质和 select 模型相同。因此千级并发以下的 I/O，可以考虑 select 和 poll 模型，但是如果出现更大的并发量，就需要用 epoll 模型。<strong>可以看到，当套接字 Socket 比较多的时候，不管哪个 Socket 是活跃的，对于使用 select 或 poll 模型都需要遍历一遍,这会浪费很多CPU资源。如果能给套接字 Socket 注册某个回调函数，当他们活跃时自动完成相关操作，那就避免了轮询，这正是 epoll 做的</strong>。</p><h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p><strong>epoll</strong> 是对 <strong>select</strong> 和 <strong>poll</strong> 的改进。它的核心思想是基于<strong>事件驱动</strong>来实现的，操作系统内核维护<strong>一颗红黑树</strong>来存储文件描述符相关信息和维护一个<strong>链表</strong>来存放准备就绪的文件描述符对应的 Socket 相关的事件信息。其实，这两个数据结构存储的元素都和 epitem 结构有关，不过为了方便描述，通常都会说存储的是文件描述符，后面我们会详细介绍 epitme 结构。</p><h2 id="API-定义-1"><a href="#API-定义-1" class="headerlink" title="API 定义"></a>API 定义</h2><p>下面列举 epoll 提供的API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 epoll 实例，返回 epoll 专用文件描述符（Linux 优化后废弃了参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于往 epoll 实例中增删改要检测的文件描述符事件</span></span><br><span class="line">    <span class="comment">// 根据具体操作调整调整红黑树和就绪链表</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于阻塞等待可以执行IO操作的文件描述符事件，直到超时</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>上面列举了Linux中提供的epoll相关API，下面我们依次介绍这些函数。</p><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><p>当某一进程成功调用<strong>epoll_create</strong>函数时，Linux 内核会创建一个 <strong>epoll</strong> 实例，并返回其文件描述符。下面是 epoll 实例对应的结构体，我们只关注核心属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_wait 使用的等待队列，和用户进程唤醒有关</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就绪队列，用于存放就绪的文件描述符事件信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的根节点，这颗树中存储着所有添加到 epoll 中的文件描述符信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般一个进程对应一个 <strong>epoll</strong> 实例，每个 <strong>epoll</strong> 实例都有一个独立的 <strong>eventpoll</strong> 结构体。更详细的结构如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/io-multi-epoll-1.jpg" alt></p><p>值得注意的是，进程在调用以上函数创建 <strong>epoll</strong> 对象的同时，会初始化以上三个核心数据结构：</p><ul><li><strong>wq:</strong> 等待队列链表。中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程（调用 epoll_wait 函数的进程）。</li><li><strong>rdllist:</strong> 就绪链表。当有文件描述符对应的 Socket 就绪时，内核会将该 Scocket 对应动作的 epitem 的 rdllink 成员（包含事件和描述符信息）添加到该就绪链表中。</li><li><strong>rbr:</strong> 一颗红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用了一颗红黑树。通过这颗树来管理用户进程下添加进来的文件描述符。注意，红黑树节点并不是文件描述符，而是内核对文件描述符和事件信息封装的 epitem 的 rbn 成员。</li></ul><p>至此，这些成员其实还只是刚被定义或初始化，都还没有用到，它们会在下面被用到。</p><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><p>某一进程通过调用 <strong>epoll_ctl</strong> 函数向 epoll 对象中添加、删除、修改感兴趣的<strong>文件描述符事件信息</strong>，返回0标识成功，返回-1表示失败。该方法的参数很重要，下面我们详细分析各个参数的作用。</p><p><strong>int epfd</strong><br>表示 epoll 实例的文件描述符，也就是 <strong>epoll_create</strong> 函数调用成功返回的值。顺便说一句，文件描述符是一个非负整数。</p><p><strong>int op</strong><br>表示对文件描述符 fd 的监听事件的操作，操作类型如下：</p><blockquote><ul><li>EPOLL_CTL_ADD：注册新的 fd 的监听事件</li><li>EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件</li><li>EPOLL_CTL_DEL：删除 fd 的监听事件</li></ul></blockquote><p><strong>int fd</strong><br>表示要监听的文件描述符，该文件描述符对应的 Socket 可能发生不同的操作，进而产生不同的事件。</p><p><strong>struct epoll_event *event</strong><br>表示要监听的文件描述符 fd 对应的 Socket 发生的事件，该事件的结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户附加数据定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span>        *ptr; <span class="comment">/*指向用户自定义数据*/</span></span><br><span class="line">    <span class="keyword">int</span>          fd;  <span class="comment">/*注册的文件描述符*/</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     u32; </span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll 监听事件定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="comment">// 描述 epoll 事件</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 专门给用户使用的，具体见上面的结构体</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>epoll_event</strong> 包括两部分信息，一个是文件描述符的事件信息，另一个是为使用方提供的属性。这个结构非常重要，使用方向 epoll 实例注册监听事件信息时，需要在 <strong>data</strong> 域写入文件描述符相关信息，当有文件描述符对应的 Socket 准备就绪时，会间接将对应的 epoll_event 拷贝会用户空间，用户进程就可以根据 epoll_event 中的 events 事件信息和 data 中用户指定的文件描述符 fd，进而可以根据事件信息去操作文件描述符对应 Socket 。</p><p>常用的 epoll 事件描述如下：</p><ul><li>EPOLLIN：描述符处于可读状态</li><li>EPOLLOUT：描述符处于可写状态</li><li>EPOLLET：将epoll event通知模式设置成 edge triggered</li><li>EPOLLONESHOT：第一次进行通知，之后不再监测</li><li>EPOLLHUP：本端描述符产生一个挂断事件，默认监测事件</li><li>EPOLLRDHUP：对端描述符产生一个挂断事件</li><li>EPOLLPRI：描述符有紧急的数据可读</li><li>EPOLLERR：描述符产生错误时触发，默认检测事件</li></ul><p>下面我们只考虑注册新的文件描述符的监听事件。在调用 epoll_clt 函数注册文件描述符事件时，Linux 内核会做以下工作：</p><ol><li>根据传入的参数初始化一个 epitem 对象，该对象是内核管理文件描述符的基础，后续红黑树和就绪链表中的数据都要用到它。</li><li>为传入的文件描述符对应的 Socket 新建一个等待队列项，其中的回调函数为 ep_poll_callback（该回调函数会在 Socket 准备就绪后触发），base 指针指向步骤 1 初始化的 epitem，它将来会作为添加到就绪链表的数据源。然后将该等待队列项加入到 Socket 的等待队列中。</li><li>将 epitem 的 rbn 成员插入到红黑树中。红黑树主要用来维护进程添加的文件描述符，这样就可以避免每次获取就绪 Socket 信息时都要重新拷贝一遍所有的文件描述符到内核态，并能在插入，查找和删除的操作发生高效执行。</li></ol><p>在 epoll 中，内核会根据传入的文件描述符和事件，将相关信息封装成 <strong>epitem</strong> 对象，epitem 结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>&#123;</span></span><br><span class="line">    <span class="comment">// 红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 就绪链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件描述符具体信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向其所属的 eventpoll 对象  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听的事件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>&#123;</span></span><br><span class="line">    <span class="comment">// Socket 文件地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单说明下，epoll 为啥要使用红黑树呢？使用红黑树是基于 epoll 在查询效率、插入效率、删除效率以及内存开销等多方面均衡的结果。</p><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><p>某一进程通过调用 <strong>epoll_wait</strong> 函数阻塞等待就绪文件描述符，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>int epfd</strong><br>表示 epoll 实例的文件描述符，也就是 <strong>epoll_create</strong> 函数调用成功返回的值。</p><p><strong>struct epoll_event *events</strong><br>关注的文件描述符对应的 Socket 有事件触发时，内核会将对应的事件信息写入 events 数组中并拷贝回用户空间。</p><p><strong>int maxevents</strong><br>通知内核 events 的大小，内核会根据该值从就绪链表中写数据到 events 数组中。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>epoll_wait 做的事情相对比较简单，当用户进程调用它时会直接观察<strong>就绪链表</strong>中有没有数据即可。</p><p><strong>有数据</strong><br>内核会将就绪链表中元素对应的事件信息写入到 events 并拷贝回用户空间就结束了。</p><p><strong>等待文件描述符就绪</strong><br>没有数据，则创建一个等待队列项，将用户进程设置到等待队列项，并且设置一个 default_wake_function 回调函数（将来用来唤醒当前进程），然后添加到 eventpoll 的等待队列上，阻塞当前用户进程。<strong>需要注意的是，epoll_ctl 过程中是为文件描述符对应的 Socket 创建等待队列项，这里是为 epoll 创建等待队列项。从这个过程也可以看出，epoll 也是会阻塞当前进程的，这个是合理的，因为当前进程没有事情可做了占着 CPU 也没啥意义</strong>。</p><p><strong>文件描述符就绪</strong></p><p>当 Socket 就绪时，内核会找到 Socket 等待队列中设置的回调函数 ep_poll_callback 并执行该函数，该函数会根据等待队列项的 base 属性找到 epitem 对象，进而也可以找到 eventpoll 对象。接着将找到的 epitem 的 rdllink 添加到 epoll 的就绪链表中(内核知道 Socket 发生的事件)，最后会查看 eventpoll 的等待队列中是否有等待项，也就是查看是否有用户进程在等待，如果没有则执行中断的事情就做完了。如果有就查找到等待项里设置的回调函数 default_wake_function 并执行，唤醒阻塞的用户进程。</p><p><strong>处理网络请求</strong></p><p>当进程醒来之后，继续从 epoll_await 时暂停的代码继续执行，同时内核向用户空间拷贝就绪事件信息到 events 参数中，用户进程可以根据返回的具体信息处理网络请求。</p><h2 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[5];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 创建一个 epoll 实例</span></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">10</span>);</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 2 epoll 监听事件定义</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">  addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.1 设置 fd </span></span><br><span class="line">  ev.data.fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">  <span class="comment">// 2.2 设置监听事件</span></span><br><span class="line">  ev.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3 向 epoll 注册 文件描述符事件</span></span><br><span class="line">  epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4 调用 epoll_wait 阻塞等待数据的到来，内核会判断 Socket 就绪情况，并把就绪的 Socket 相关的 epoll_event 拷贝出用户空间</span></span><br><span class="line">   <span class="comment">// 返回的就绪 Socket 的个数</span></span><br><span class="line">   nfds = epoll_wait(epfd, events, <span class="number">5</span>, <span class="number">10000</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 只需要遍历 nfds 个数即可</span></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;i++) &#123;</span><br><span class="line">           <span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line">           <span class="built_in">read</span>(events[i].data.fd, <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line">           <span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol><li>epoll 为了减少文件描述符频繁的拷贝开销，在内核中维护了一颗红黑树用来存储文件描述符信息。并不是说 epoll 完全避免了文件描述符的拷贝，epoll 只会在新增/修改/删除的时候进行拷贝工作，避免了每次获取就绪数据信息时的重复拷贝。</li><li>epoll 使用了一个就绪链表来解决准确通知问题，也就是只会将就绪的 Socket 信息返回给用户空间，即可以直接从 events 参数中获取就绪的文件描述符的信息，无需遍历整个所有文件描述符集合。</li><li>epoll 阻塞用户进程时只会将其添加到 epoll 实例的等待队列中，而不需要将用户进程轮流加入到文件描述符对应的 Socket 的等待队列中。并且 epoll 模型为文件描述符对应的 Socket 设置一个回调函数，当 Socket 就绪时会触发该函数的调用，这就是基于事件驱动模型。基于事件驱动内核就可以避免遍历所有文件描述符的开销。</li></ol><h1 id="方案比较"><a href="#方案比较" class="headerlink" title="方案比较"></a>方案比较</h1><ol><li>select 和 poll 基本类似，都是使用内核定义的数据结构来进行文件描述符的存储，select 采用 bitmap ，poll 采用数组。select 会受到最大连接数的限制，而 poll 在一定程度上解决了这个问题。而 epoll 则是内核专门维护了一颗红黑树来存储文件描述符信息。前两个文件描述符信息需要用户空间维护，而后者是在内核空间维护的。</li><li>select 和 poll 都需要将有关文件描述符的数据结构在用户空间和内核空间来回拷贝，而 epoll 只会在新增/修改/删除的时候进行拷贝工作。</li><li>select 和 poll 采用轮询的方式来检查文件描述符是否处于就绪状态，而 epoll 采用回调机制。造成的结果是，随着文件描述符的增加，select 和 poll 的效率会线性降低，而 epoll 受到的影响较小，除非活跃的 Socket 较多。 </li><li>select 、poll 以及 epoll 虽然都会返回就绪的文件描述符数量。但是 select 和 poll 并不会明确指出是哪些文件描述符就绪，而 epoll 可以做到。用户进程返回后，调用 select 和 poll 的程序需要遍历监听整个文件描述符，而 epoll 得益于内核就绪链表则可以直接处理。</li></ol><p>注意，虽然 epoll 的性能最好，但是在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，毕竟 epoll 的通知机制需要很多函数回调，这也是需要有开销的。</p><h1 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h1><h2 id="水平触发"><a href="#水平触发" class="headerlink" title="水平触发"></a>水平触发</h2><p>当内核有事件到达，会拷贝给用户空间，如果应用程序没有处理完或者压根都没有处理，那么会在下一次再次返回没有处理的事件。这样，如果应用程序永远不处理这个事件，就导致每次都会有该事件从内核空间到用户空间的拷贝，消耗性能。但是水平触发相对安全，最起码事件不会丢掉，除非用户处理完毕。</p><h2 id="边缘触发"><a href="#边缘触发" class="headerlink" title="边缘触发"></a>边缘触发</h2><p>边缘触发，相对跟水平触发相反，当内核有事件到达，只会通知应用程序一次，至于应用程序处理还是不处理，以后将不会再通知。这样减少了拷贝过程，增加了性能，但是会产生事件丢失的情况。</p><p>对于 select 和 poll 来说，其触发都是水平触发。而 epoll 既支持水平触发也支持边缘触发。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对IO多路复用的实现方案进行了介绍，主要以 Linux 系统的 slect、poll 和 epoll 为主线进行说明。下面给出总结表：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/io-multi-2.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;IO多路复用简单来说就是，单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力，IO多路复用解决的本质问题是用更少的资源完成更多
      
    
    </summary>
    
    
      <category term="网络通信" scheme="https://gentryhuang.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="I/O" scheme="https://gentryhuang.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>网络通信 - IO模型</title>
    <link href="https://gentryhuang.com/posts/51fff883/"/>
    <id>https://gentryhuang.com/posts/51fff883/</id>
    <published>2021-06-05T07:36:47.000Z</published>
    <updated>2021-09-11T09:09:17.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><p>输入输出(input/output)的对象可以是文件(file)、网络(socket)、进程之间的管道。在Linux系统中，都用文件描述符(fd)来表示。</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>没有数据传过来时，读会阻塞直到有数据；缓冲区满了，写操作也会阻塞。非阻塞都是直接返回。阻塞和非阻塞强调的是调用者是否等待。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>数据就绪后需要应用程序自己去读是同步。数据就绪后通过回调给到应用程序是异步。同步与异步强调的是获取数据的操作是由调用者还是被调用者完成。</p><h2 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h2><p>在 Linux 中，应用程序的稳定性远远比不上操作系统程序，为了保证操作系统的稳定性，分出了<strong>内核空间</strong>和<strong>用户空间</strong>。内核空间运行操作系统程序和驱动程序，用户空间运行应用程序。所有的系统资源操作都在内核空间进行，比如读写磁盘文件、内存分配和回收以及网络接口调用等。不难看出，一次网络IO读取过程中，数据并不是直接从网卡读取到用户空间中的应用程序缓冲区，而是先从网卡拷贝到内核空间缓冲区，然后再从内核拷贝到用户空间中的应用程序缓冲区。对于网络IO写入过程则相反，先将数据从用户空间中的应用程序缓冲区拷贝到内核缓冲区，再从内核缓冲区把数据通过网卡发送出去。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝是一种避免多次内存复制的技术，用来优化读写IO操作。</p><p>Linux 内核中的 mmap 函数可以将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理内存地址。<strong>这种方式实现用户空间和内核空间共享一个缓存数据，避免了内核空间与用户空间的数据交换</strong>。I/O 复用中的 epoll 函数中就是使用了 mmap 减少了内存拷贝。</p><p>Java 中，在用户空间中又存在一个拷贝，即从 Java 堆内存中拷贝到临时的直接内存中，通过临时的直接内存拷贝到内核空间中去。此时的直接内存和堆内存都是属于用户空间。<code>DirectBuffer</code> 是直接分配物理内存（非堆内存）的，它直接将过程简化为数据直接保存到非堆内存，这样就减少了一次拷贝。注意，<code>DirectBuffer</code> 只优化了用户空间内部的拷贝。而在 NIO 中，<code>MappedByteBuffer</code> 是通过本地类调用 mmap 进行文件内存映射的，可以直接将文件从网卡拷贝到用户空间，只进行一次数据拷贝，从而减少了传统的 read() 方法从网卡拷贝到内核空间这一步。</p><h1 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h1><p>Linux 网络IO模型包括：<strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong> 。需要说明的是，操作系统层面的IO模型和Java中的IO模型是一一对应的，Java只是对操作系统API进行了封装。</p><p>对于一个网络IO通信过程会涉及两个对象，一个是执行IO操作的用户线程，另一个是操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间。</p><h2 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h2><p>用户线程发起read 请求后就阻塞了，此时会让出 CPU ，不能再干其它事情 。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程唤醒。<strong>这样情况下，需要为每个连接都分配一个线程，在大量连接的场景下就需要大量的线程，会造成巨大的性能损耗，这也是传统阻塞IO的最大缺陷</strong>。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/net-io-base-1.png" alt></p><h2 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h2><p>用户线程在发起 read 请求后立即返回，如果没读取到数据，用户线程会不断轮询发起 read 请求，直到数据到达（内核准备好数据）后才停止轮询，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程唤醒。非阻塞IO模型虽然避免了由于线程阻塞问题带来的大量线程消耗，但是频繁地重复轮询大大增加了请求次数，对CPU消耗也比较明显。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/net-io-base-2.png" alt></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>用户线程的读取操作分成两步了，线程先发起 select 调用，目的是问内核数据准备好了吗？等内核把数据准备好了，用户线程再发起 read 调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。注意，等待 select 返回过程也是阻塞的，所以说IO多路复用并非完全非阻塞。那为什么叫 I/O 多路复用呢？因为一次 select 调用可以向内核查多个数据通道（Channel）的状态，所以叫多路复用。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/net-io-base-3.png" alt></p><h2 id="信号驱动式IO"><a href="#信号驱动式IO" class="headerlink" title="信号驱动式IO"></a>信号驱动式IO</h2><p>用户线程发起 read 请求，会通过系统调用 sigaction 函数，给对应的套接字注册一个信号回调，此时不阻塞用户进程，进程会继续工作。当内核数据就绪时，内核就为该进程生成一个 SIGIO 信号，通过信号回调通知进程进行相关 IO 操作。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>用户线程发起 read 请求的同时注册一个回调函数，read 立即返回，等内核已经读取完数据并把数据放到了应用进程的缓冲区中，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/net-io-base-4.png" alt></p><p>介绍完常见的网络IO模型后，下面我们对 Socket(套接字) 进行说明。</p><h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><p>所谓套接字(Socket)，可以抽象成两个程序进行通讯连接中的一个端点，提供了应用层进程利用网络协议交换数据的机制。<strong>要通过互联网进行通信，至少需要一对套接字，一个运行于客户机端，另一个运行于服务器端</strong>。不同编程语言对套接字（Socket）都有对应的封装，如 Java 中的 <strong>ServerSocket/Socket</strong>，Python 中引用套接字的模式是 socket 。本质上来说，套接字是操作系统层面的产物，它既是一种编程模型，同时又是一个文件（操作系统提供支持网络通信的一种文件格式）。</p><h2 id="Socket-编程模型"><a href="#Socket-编程模型" class="headerlink" title="Socket 编程模型"></a>Socket 编程模型</h2><p>套接字（Socket）通信过程如下图所示，这里以流式套接字（TCP）为例：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/socket-process-1.jpg" alt></p><p>下面对上图的流程简单说明：</p><ol><li>应用程序通过系统调用 <strong>socket</strong> 创建一个套接字，它是操作系统分配给应用程序的一个文件描述符（用来标识套接字（Socket）的）。</li><li>应用程序会通过系统调用 <strong>bind</strong>，绑定地址和端口，给套接字命名一个名称。</li><li>系统会调用 <strong>listen</strong> 创建一个<strong>队列</strong>用于存放客户端进来的连接。</li><li>应用服务会通过系统调用 accept 来监听客户端的连接请求。</li></ol><h2 id="双向管道文件"><a href="#双向管道文件" class="headerlink" title="双向管道文件"></a>双向管道文件</h2><p>套接字（Socket）是一个支持网络通信的文件，存储的是数据。服务端 Socket 文件存储的是客户端 Socket 文件描述符；客户端 Socket 文件存储的是传输数据。</p><p>当一个客户端连接到服务端的时候，操作系统就会创建一个客户端 Socket 的文件。然后操作系统将这个文件的文件描述符写入服务端程序创建的服务端 Socket 文件中。进程可以通过 accept() 方法，从服务端 Socket 文件中读出客户端的 Socket 文件描述符，从而拿到客户端的 Socket 文件。<strong>Socket 是一个双向的管道文件，当线程想要读取客户端传输来的数据时，就从客户端 Socket 文件中读取数据；当线程想要发送数据到客户端时，就向客户端 Socket 文件中写入数据</strong>。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/socket-process-2.jpg" alt></p><p><strong>注意：</strong></p><blockquote><p>1 服务端维护的 Socket 数量是 N+1，包括 N 个与客户端对应的 Socket 和一个监听 Socket 。<br>2 操作系统创建的 Socket 是由文件系统管理的，内核中有一个文件列表(fd)管理这些 Socket。</p></blockquote><h2 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h2><p>如何同时监视多个 Socket 呢？答案就是多路复用。</p><p>在 IO 多路复用技术中，应用进程（或线程）需要维护一个 Socket 集合（可以是数组、链表等），然后定期遍历这个集合，判断每个 Socket 文件的状态。这些 Socket 文件的状态如：服务端 Socket 文件写入客户端 Socket 文件描述符，客户端 Socket 文件的读、写等操作。这样的做法在客户端 Socket 较少的情况下没有问题，但是如果接入的客户端 Socket 较多，比如达到上万，那么每次轮询的开销都会很大。</p><p>为了解决这个问题，就需要一个观察者角色，观察者需要知道每个 Socket 文件的状态，这样就可以在 Socket 文件状态发生改变时，把相关信息推送应用进程了。这种方式就不需要应用进程主动轮询。<strong>不难发现，最合适的观察者其实就是操作系统本身，因为操作系统非常清楚每一个 Socket 文件的状态（包括服务端和客户端的 Socket），毕竟对 Socket 文件的读写都要经过操作系统</strong>。具体来说，每个 Socket 对应着一个端口号，而网络数据包中包含了 ip 和端口的信息，内核可以通过端口号找到对应的 Socket 。</p><p><strong>总结起来就是：</strong>单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力，IO多路复用解决的本质问题是用更少的资源完成更多的事。注意，处理IO多路复用的问题，需要操作系统提供内核级别的支持。如 Linux 下有三种提供IO多路复用的 API，分别是 <code>select</code>、<code>poll</code> 以及<code>epoll</code>。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对网络通信相关的基本概念进行了说明，并重点对常见的 I/O 模型进行介绍，接着介绍套接字并引出 I/O 多路复用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;I-O&quot;&gt;&lt;a href=&quot;#I-O&quot; class=&quot;headerlink&quot; title=&quot;I/O&quot;&gt;&lt;/a&gt;I/
      
    
    </summary>
    
    
      <category term="网络通信" scheme="https://gentryhuang.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="I/O" scheme="https://gentryhuang.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 事务</title>
    <link href="https://gentryhuang.com/posts/a26fab1/"/>
    <id>https://gentryhuang.com/posts/a26fab1/</id>
    <published>2021-05-27T12:08:59.000Z</published>
    <updated>2021-12-07T03:17:27.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Redis 通过 <strong>MULTI</strong>、<strong>EXEC</strong>、<strong>DISCARD</strong> 以及 <strong>WATCH</strong> 命令来实现事务功能。与我们所熟知的事务最大的不同是，Redis 实现的事务不支持回滚特性。此外，Redis 事务的 ACID 特性也并不完整，不同的情况下表现会有不同。Redis 事务也被称为 <strong>半事务</strong>，它是简单地使用队列存放一组 Redis 命令。</p><h1 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h1><p>Redis 事务的执行过程包含三个阶段，如下：</p><blockquote><ol><li>开启事务</li><li>命令入队</li><li>事务执行/取消</li></ol></blockquote><p>下面我们分别对以上三个阶段进行说明，并介绍核心的实现逻辑。</p><h2 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h2><p>Redis 客户端执行 <strong>MULTI</strong> 命令标志着事务的开启:</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt;</span><br></pre></td></tr></table></figure><p><strong>MULTI</strong> 命令可以将执行该命令的客户端从<strong>非事务状态</strong>切换到<strong>事务状态</strong>，这一切换是将客户端的 <code>flags</code> 属性设置为 <code>CLIENT_MULTI</code> 标识来完成的。</p><p><strong>MULTI 命令的实现逻辑如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * multi 命令对应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 检测客户端状态，不支持在事务中嵌套事务</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"MULTI calls can not be nested"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 开启事务，即设置客户端的状态标志为 CLIENT_MULTI</span></span><br><span class="line">    c-&gt;flags |= CLIENT_MULTI;</span><br><span class="line"></span><br><span class="line">    addReply(c, shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，Redis 开启事务主要是将当前客户端的状态标志属性 <code>flags</code> 设置为 <code>CLIENT_MULTI</code>。Redis 事务的生命周期是和该状态标志紧密相关的，除此状态外，命令入队出错需要将客户端的状态设置为 <code>REDIS_DIRTY_EXEC</code>，客户端监视的键被改动需要将客户端的状态设置为 <code>REDIS_DIRTY_CAS</code>，这两种情况将在下文进行介绍。</p><h2 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h2><p>Redis 在没有开启事务时，即一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行，这个也是我们日常多使用的方式。与此不同的是，当一个客户端开启事务，即一个客户端处于事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：</p><ul><li>如果客户端发送的命令为 <code>EXEC</code> 或 <code>DISCARD</code> ，那么服务器会立即执行这个命令，进行事务的提交或取消。</li><li>如果客户端发送的命令是操作数据命令，那么服务器并不会立即执行这个命令，而是将这个命令加入到<strong>事务队列</strong>中，然后向客户端返回 <code>QUEUED</code> 回复，标识加入事务队列完成。</li></ul><p><strong>将命令入队的实现逻辑如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a new command into the MULTI commands queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将一个新命令添加到事务队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    multiCmd *mc;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 检测客户端状态，如果要入队的命令出现类似语法错误，则不允许入队</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_DIRTY_EXEC)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 为命令分配对应的空间，如存储命令结构的队列、封装命令的命令结构 multiCmd</span></span><br><span class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(multiCmd) * (c-&gt;mstate.count + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 指向新元素</span></span><br><span class="line">    mc = c-&gt;mstate.commands + c-&gt;mstate.count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 设置命令、命令参数数量、以及命令的参数</span></span><br><span class="line">    mc-&gt;cmd = c-&gt;cmd;</span><br><span class="line">    mc-&gt;argc = c-&gt;argc;</span><br><span class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj *) * c-&gt;argc);</span><br><span class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv, c-&gt;argv, <span class="keyword">sizeof</span>(robj *) * c-&gt;argc);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        incrRefCount(mc-&gt;argv[j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 事务队列长度增一</span></span><br><span class="line">    c-&gt;mstate.count++;</span><br><span class="line"></span><br><span class="line">    c-&gt;mstate.cmd_flags |= c-&gt;cmd-&gt;flags;</span><br><span class="line">    c-&gt;mstate.cmd_inv_flags |= ~c-&gt;cmd-&gt;flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 每次在入队的命令出现类似语法错误时调用，将客户端的状态设置为 DIRTY_EXEC，让之后的 EXEC 命令失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flagTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前客户端的状态处于事务状态</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI)</span><br><span class="line">        <span class="comment">// 将客户端的状态设置为 CLIENT_DIRTY_EXEC，表示该客户端的事务安全性已经被破坏</span></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_EXEC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，以上函数只是命令入队逻辑，在该方法上层会对当前客户端的状态标志进行判断，并结合当前命令选择对应处理方式，因为涉及的内容相对较多且不是本文的重点，暂不展开说明。</p><h2 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h2><p>前文介绍了 Redis 事务中的命令入队逻辑，但是并没有详细说明事务队列的结构以及命令封装结构，本小节就来对 Redis 事务中涉及的相关数据结构进行介绍。</p><p>每个 Redis 客户端都有自己的状态，其它状态我们暂不介绍，这里我们围绕着事务相关状态进行说明。下面只列举客户端结构体中涉及事务相关的属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前正在使用的数据库</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数对象数组</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录被客户端执行的命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端的状态标志</span></span><br><span class="line">    <span class="keyword">uint64_t</span> flags;         <span class="comment">/* Client flags: CLIENT_* macros. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务状态（本质上是事务队列的封装）</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被监视的键，用于存放当前客户端使用 WATCH 命令监视键的链表</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure><p>客户端的状态标志是通过 <code>flags</code> 属性记录的。如果客户端开启事务，那么客户端的 <code>mstate</code> 属性封装了事务队列信息，用来管理事务中的命令；客户端的 <code>watched_keys</code> 链表结构用来管理客户端使用 <strong>WATCH</strong> 命令监视的键信息。下文我们会分别详细介绍这些关键属性。</p><p>客户端的 <code>mstate</code> 属性主要包含一个<strong>事务队列</strong>和一个<strong>记录事务队列长度的属性</strong>，具体结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 主要包含一个事务队列，以及一个已入队命令的计数器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 事务队列，是一个 multiCmd 类型的数组</span></span><br><span class="line">    multiCmd *commands;     <span class="comment">/* Array of MULTI commands */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已入队命令计数（事务队列的长度）</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">/* Total number of MULTI commands */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cmd_flags;          <span class="comment">/* The accumulated command flags OR-ed together.</span></span><br><span class="line"><span class="comment">                               So if at least a command has a given flag, it</span></span><br><span class="line"><span class="comment">                               will be set in this field. */</span></span><br><span class="line">    <span class="keyword">int</span> cmd_inv_flags;      <span class="comment">/* Same as cmd_flags, OR-ing the ~flags. so that it</span></span><br><span class="line"><span class="comment">                               is possible to know if all the commands have a</span></span><br><span class="line"><span class="comment">                               certain flag. */</span></span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure><p>从 <strong>multiState</strong> 结构中可以看出，事务队列本质上是一个 <strong>multiCmd</strong> 类型的数组。<strong>multiCmd</strong> 结构用于封装了一个已入队命令的信息，具体结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存了一个已入队命令的相关信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    <span class="comment">// 参数数组</span></span><br><span class="line">    robj **argv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令指针，指向具体的命令（命令结构中封装了对应的命令函数）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure><p>事务队列以先进先出（FIFO）的方式保存入队的命令信息，较先入队的命令会被放到数组的前面，而较后入队的命令则会放到数组的后面。下面结合示例，对事务队列结构进行说明。</p><p><strong>事务中的命令入队过程：</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; SET name "Practical Common Lisp"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; GET "name"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; SET author "Peter Seibel"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; GET author</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt;</span><br></pre></td></tr></table></figure><p><strong>事务队列结构如下图所示：</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/themory/redis-tx-multistate.jpg" alt></p><p>上图很直观地展示了客户端中的 <code>multiState</code> 属性的平铺结构。</p><p>了解了 Redis 事务的开启以及事务相关的数据结构后，下面我们看看 Redis 提交事务的逻辑。</p><h2 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h2><p>当一个处于事务状态的客户端向服务器发送 <code>EXEC</code> 命令时，该命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，依次执行队列中保存的命令，最后将执行命令得到的结果全部返回给客户端。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) "Practical Common Lisp"</span><br><span class="line">3) OK</span><br><span class="line">4) "Peter Seibel"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>执行事务逻辑如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * exec 命令对应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj **orig_argv;</span><br><span class="line">    <span class="keyword">int</span> orig_argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">orig_cmd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> was_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 检测当前客户端状态，非事务状态直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"EXEC without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 2 检查是否需要阻止事务执行，因为：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) Some WATCHed key was touched.</span></span><br><span class="line"><span class="comment">     *    存在被客户端监视的键被修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2) There was a previous error while queueing commands.</span></span><br><span class="line"><span class="comment">     *    命令在入队时发生错误</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A failed EXEC in the first case returns a multi bulk nil object</span></span><br><span class="line"><span class="comment">     * (technically it is not an error but a special behavior), while</span></span><br><span class="line"><span class="comment">     * in the second an EXECABORT error is returned. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_DIRTY_CAS | CLIENT_DIRTY_EXEC)) &#123;</span><br><span class="line">        addReply(c, c-&gt;flags &amp; CLIENT_DIRTY_EXEC ? shared.execaborterr :</span><br><span class="line">                    shared.nullarray[c-&gt;resp]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 discard 逻辑，即取消事务</span></span><br><span class="line">        discardTransaction(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前客户端的状态标记</span></span><br><span class="line">    <span class="keyword">uint64_t</span> old_flags = c-&gt;flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we do not want to allow blocking commands inside multi */</span></span><br><span class="line">    <span class="comment">// 我们不希望在multi中允许阻塞命令</span></span><br><span class="line">    c-&gt;flags |= CLIENT_DENY_BLOCKING;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 已经可以保证安全性了，取消客户端对所有键的监视</span></span><br><span class="line">    <span class="comment">// 将当前客户端的 watched_keys 链表回收</span></span><br><span class="line">    <span class="comment">// 从当前客户端操作的数据库的 watched_keys 字典中移除当前客户端</span></span><br><span class="line">    unwatchAllKeys(c); <span class="comment">/* Unwatch ASAP otherwise we'll waste CPU cycles */</span></span><br><span class="line"></span><br><span class="line">    server.in_exec = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 因为事务中的命令在执行时可能会修改命令和命令的参数，所以为了正确地传播命令，需要现备份这些命令和参数</span></span><br><span class="line">    orig_argv = c-&gt;argv;</span><br><span class="line">    orig_argc = c-&gt;argc;</span><br><span class="line">    orig_cmd = c-&gt;cmd;</span><br><span class="line"></span><br><span class="line">    addReplyArrayLen(c, c-&gt;mstate.count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 执行事务队列中的命令</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 因为 Redis 的命令必须在客户端的上下文中执行，所以需要将事务队列中的命令、命令参数等设置到客户端</span></span><br><span class="line">        c-&gt;argc = c-&gt;mstate.commands[j].argc;</span><br><span class="line">        c-&gt;argv = c-&gt;mstate.commands[j].argv;</span><br><span class="line">        c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/* 省略 ACL权限检查逻辑 */</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 5.2 执行命令</span></span><br><span class="line">        call(c, server.loading ? CMD_CALL_NONE : CMD_CALL_FULL);</span><br><span class="line">        serverAssert((c-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Commands may alter argc/argv, restore mstate. */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 因为命令执行后命令、命令参数可能会被改变，比如 SPOP 会被改写为 SREM</span></span><br><span class="line"><span class="comment">         * 所以这里需要更新事务队列中的命令和参数，确保附属节点和 AOF 的数据一致性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c-&gt;mstate.commands[j].argc = c-&gt;argc;</span><br><span class="line">        c-&gt;mstate.commands[j].argv = c-&gt;argv;</span><br><span class="line">        c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore old DENY_BLOCKING value</span></span><br><span class="line">    <span class="keyword">if</span> (!(old_flags &amp; CLIENT_DENY_BLOCKING))</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_DENY_BLOCKING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原命令</span></span><br><span class="line">    c-&gt;argv = orig_argv;</span><br><span class="line">    c-&gt;argc = orig_argc;</span><br><span class="line">    c-&gt;cmd = orig_cmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 清理事务状态</span></span><br><span class="line">    <span class="comment">// 释放事务队列相关的资源 &amp; 重置客户端的状态</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure the EXEC command will be propagated as well if MULTI</span></span><br><span class="line"><span class="comment">     * was already propagated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果已经传播了 MULTI，也要确保传播 EXEC 命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (server.propagate_in_transaction) &#123;</span><br><span class="line">        <span class="keyword">int</span> is_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="comment">/* If inside the MULTI/EXEC block this instance was suddenly</span></span><br><span class="line"><span class="comment">         * switched from master to slave (using the SLAVEOF command), the</span></span><br><span class="line"><span class="comment">         * initial MULTI was propagated into the replication backlog, but the</span></span><br><span class="line"><span class="comment">         * rest was not. We need to make sure to at least terminate the</span></span><br><span class="line"><span class="comment">         * backlog with the final EXEC. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog &amp;&amp; was_master &amp;&amp; !is_master) &#123;</span><br><span class="line">            <span class="keyword">char</span> *execcmd = <span class="string">"*1\r\n$4\r\nEXEC\r\n"</span>;</span><br><span class="line">            feedReplicationBacklog(execcmd, <span class="built_in">strlen</span>(execcmd));</span><br><span class="line">        &#125;</span><br><span class="line">        afterPropagateExec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.in_exec = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>事务执行逻辑比较复杂，下面进行概要总结：</strong></p><ol><li>在事务执行时会判断客户端的状态，如果没有开启事务直接返回。</li><li>对阻止事务执行的情况进行检查，检测到任何一种非法的情况，需要取消事务。</li><li>取消客户端对所有键的监视</li><li>依次执行事务队列中的任务</li><li>清理事务列表并重置客户端状态</li><li>传播 EXEC 命令</li></ol><p>事务执行时涉及的监视机制会在下文进行介绍，这里暂不展开。</p><h2 id="取消事务"><a href="#取消事务" class="headerlink" title="取消事务"></a>取消事务</h2><p>当一个处于事务状态的客户端向服务器发送 <code>DISCARD</code> 命令时，该命令将立即被服务器执行。服务器会释放事务状态资源并重置客户端的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * discard 命令对应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测当前客户端状态，非事务状态直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"DISCARD without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// discard 逻辑</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line"></span><br><span class="line">    addReply(c, shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * discard 操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重置事务状态</span></span><br><span class="line">    <span class="comment">// 释放所有事务状态相关的资源</span></span><br><span class="line">    freeClientMultiState(c);</span><br><span class="line">    <span class="comment">// 初始化客户端的事务状态</span></span><br><span class="line">    initClientMultiState(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置客户端状态标志</span></span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_MULTI | CLIENT_DIRTY_CAS | CLIENT_DIRTY_EXEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消对所有键的监视</span></span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WATCH-机制"><a href="#WATCH-机制" class="headerlink" title="WATCH 机制"></a>WATCH 机制</h2><p><strong>WATCH</strong> 命令可以在 <strong>EXEC</strong> 命令执行之前，监视任意数量的数据库键，并在 <strong>EXEC</strong> 命令执行时检查是否存在被监视的键被修改的情况，如果存在服务器会拒绝执行事务。前文介绍事务执行和取消时，都有 <strong>WATCH</strong> 机制逻辑，它是 Redis 事务实现的一部分，本小节我们就来详细说明该机制。</p><h3 id="监视键信息"><a href="#监视键信息" class="headerlink" title="监视键信息"></a>监视键信息</h3><p>客户端监视键的时候，被监视的键信息会分别保存在客户端的监视键链表中和当前数据库的监视键字典中，下面我们分别介绍。</p><p><strong>客户端的监视键链表</strong></p><p>每个客户端创建的时候都会初始化一个用于存放监视键的链表。前文在介绍客户端的结构有列举对应的属性，这里直接拿过来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存放被监视的键的链表</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure><p>客户端结构中的这个链表的节点的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 在监视一个键时：</span></span><br><span class="line"><span class="comment"> * 我们既需要保存被监视的键，还需要保存该键所在的数据库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchedKey</span> &#123;</span></span><br><span class="line">    <span class="comment">// 被监视的键对象</span></span><br><span class="line">    robj *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键所在的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125; watchedKey;</span><br></pre></td></tr></table></figure><p>watched_keys 链表数据举例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># before:</span><br><span class="line"> [</span><br><span class="line">  &#123;</span><br><span class="line">    'key': 'key1',  # 被监视的键</span><br><span class="line">    'db': 0  # 客户端操作的数据库</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br><span class="line">#  after client watch key-2 in db 0:</span><br><span class="line"> [</span><br><span class="line">  &#123;</span><br><span class="line">   'key': 'key1',</span><br><span class="line">   'db': 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   'key': 'key2',</span><br><span class="line">   'db': 0</span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p><strong>数据库的监视键字典</strong></p><p>每个 Redis 数据库都有一个 <code>watched_keys</code> 字典，这个字典的<code>键</code>就是被 <code>WATCH</code> 命令监视的键，而字典的<code>值</code>则是一个链表，该链表中记录了监视当前键的客户端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>watched_keys 字典数据举例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> # before :</span><br><span class="line"> &#123;</span><br><span class="line">   'key1' : [c1, c2]</span><br><span class="line"> &#125;</span><br><span class="line"> # after c3 WATCH key1 and key2:</span><br><span class="line">&#123;</span><br><span class="line">   'key1' : [c1, c2, c3],</span><br><span class="line">   'key2' : [c3]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="监视键"><a href="#监视键" class="headerlink" title="监视键"></a>监视键</h3><p><strong>监视键命令操作如下：</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; WATCH name</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>客户端监视给定键的逻辑如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Watch for the specified key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 客户端监视给定的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchForKey</span><span class="params">(client *c, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    watchedKey *wk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key */</span></span><br><span class="line">    <span class="comment">// 1 检查 key 是否已经保存在 watched_keys 链表中，如果已经存在，则直接返回</span></span><br><span class="line">    listRewind(c-&gt;watched_keys, &amp;li);</span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        wk = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">if</span> (wk-&gt;db == c-&gt;db &amp;&amp; equalStringObjects(key, wk-&gt;key))</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* Key already watched */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This key is not already watched in this DB. Let's add it */</span></span><br><span class="line">    <span class="comment">// 2 检查 key 是否存在于数据库的 watched_keys 字典中</span></span><br><span class="line">    clients = dictFetchValue(c-&gt;db-&gt;watched_keys, key);</span><br><span class="line">    <span class="comment">// 2.1 如果不存在则，添加它</span></span><br><span class="line">    <span class="keyword">if</span> (!clients) &#123;</span><br><span class="line">        <span class="comment">// 值是一个链表</span></span><br><span class="line">        clients = listCreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联键值对到字典</span></span><br><span class="line">        dictAdd(c-&gt;db-&gt;watched_keys, key, clients);</span><br><span class="line">        incrRefCount(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将客户端添加到链表的末尾</span></span><br><span class="line">    listAddNodeTail(clients, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the new key to the list of keys watched by this client */</span></span><br><span class="line">    <span class="comment">// 3 构建 watchedKey 结构并添加到客户端的 watched_key 链表的末尾</span></span><br><span class="line">    wk = zmalloc(<span class="keyword">sizeof</span>(*wk));</span><br><span class="line">    wk-&gt;key = key;</span><br><span class="line">    wk-&gt;db = c-&gt;db;</span><br><span class="line">    incrRefCount(key);</span><br><span class="line">    listAddNodeTail(c-&gt;watched_keys, wk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法是监视给定的键，本质上就是将指定的键关联上当前客户端，然后分别添加到客户端的监视键链表中和数据库监视字典中。关于取消监视的键逻辑就不再介绍。</p><h3 id="监视机制的触发"><a href="#监视机制的触发" class="headerlink" title="监视机制的触发"></a>监视机制的触发</h3><p>所有对数据库进行写操作的命令，在执行后都会尝试触发监视机制，试图将正在监视当前键的客户端的状态设置为 <code>CLIENT_DIRTY_CAS</code>，表示该客户端的事务安全性已经被破坏了(客户端开启事务的前提下，没开启则没影响)。监视机制的触发逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "Touch" a key, so that if this key is being WATCHed by some client the</span></span><br><span class="line"><span class="comment"> * next EXEC will fail.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * "触碰" key，如果该 key 正在被某个/某些客户端监视着，那么这个/这些客户端在执行 EXEC 时，事件将失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touchWatchedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 当前数据库的 watched_leys 字典为空，没有任何键被监视</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 从监视键字典中获取所有监视这个键的客户端</span></span><br><span class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark all the clients watching this key as CLIENT_DIRTY_CAS */</span></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3 遍历所有客户端，打开它们的 CLIENT_DIRTY_CAS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    listRewind(clients, &amp;li);</span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将客户端的状态设置为 CLIENT_DIRTY_CAS，表示该客户端的事务安全性已经被破坏</span></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_CAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当服务器执行客户端的 <strong>EXEC</strong> 命令时，服务器会校验客户端的状态来决定是否执行事务。如果客户端的状态是 <code>CLIENT_DIRTY_EXEC</code> 或者 <code>CLIENT_DIRTY_CAS</code> 时，服务器会拒绝执行客户端提交的事务。</p><p>至此，Redis 的事务原理已经全部介绍完毕了。下面我们从事务的 ACID 特性角度对 Redis 的事务进行说明。</p><h1 id="事务的-ACID-性质"><a href="#事务的-ACID-性质" class="headerlink" title="事务的 ACID 性质"></a>事务的 ACID 性质</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>对于 Redis 的事务功能来说，事务队列中的命令要么全部执行，要么一个都不执行。Redis 事务的原子性需要分以下三种情况来考虑。</p><p><strong>命令入队时出错</strong></p><p>在执行 EXEC 命令前，客户端发送的操作命令本身就有错误，比如语法错误或者使用了不存的命令，在命令入队过程就被 Redis 实例检测出来了，进而导致事务失败。</p><p>命令操作如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行一个 Redis 不支持的命令，返回报错信息</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SETT num 1</span><br><span class="line">(error) ERR unknown command `SETT`, with args beginning with: `num`, `1`, </span><br><span class="line">(51.33s)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 继续执行命令</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SET num 1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交事务，但由于存在命令入队失败的情况，因此 Redis 拒绝执行事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure><p>对于这种情况，Redis 实例检测出错误后会记录错误信息并调用 <strong>flagTransaction</strong> 函数将客户端的状态设置为 <code>CLIENT_DIRTY_EXEC</code>，然后执行入队逻辑时，命令入队就会失败。此时，虽然还能继续提交命令操作，但是等到执行 <strong>EXEC</strong> 命令时，Redis 服务器就会拒绝执行提交的事务，返回事务失败的结果，因为此时客户端的状态为 <code>CLIENT_DIRTY_EXEC</code>。关于命令入队和事务执行逻辑，上文已经详细说明。</p><p><strong>结论：</strong>命令入队时出现错误，会放弃事务的执行，能够保证原子性。</p><p><strong>命令执行时出错</strong></p><p>客户端发送的操作命令和操作的数据类型不匹配，在命令入队过程 Redis 实例无法检测出错误。但是在执行 <strong>EXEC</strong> 命令时，当 Redis 从事务队列中取出异常操作命令并执行时就会报错。需要注意的是，虽然 Redis 会对异常操作命令报错，但还是会继续将事务队列中的命令执行完。在这种情况下，事务的原子性就无法得到保证了，根本原因在于 Redis 并没有提供回滚机制。</p><p>命令操作如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开始事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行 SADD 命令</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SADD st gentryhuang</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行 GET 命令，GET 命令操作的数据类型不匹配，此时不会影响入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; GET st</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交事务，事务中的第二个命令会报错</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong>命令入队时没有出错，实际执行时报错，不能保证原子性。</p><p><strong>实例故障</strong></p><p>在执行 <strong>EXEC</strong> 命令时，Redis 实例发生了故障，导致事务执行失败。由于 Redis 的持久化机制，实例重启后会加载 AOF 日志文件或 RDB 快照，如果只有部分的事务操作被记录，那么就无法保证原子性。但是事实是，RDB 快照不会在事务执行时执行，所以事务命令操作的结果不会被保存到 RDB 快照中。即使开启了 AOF 日志，我们可以使用 <strong>redis-check-aof</strong> 工具检查 AOF 日志文件，这个工具可以把未完成的事务操作从 AOF 文件中去除。这样一来，不管 AOF 日志文件中是否保存完整的事务操作，还是根本就没有保存事务操作，AOF 文件不再是导致原子性问题的因素。</p><p><strong>结论：</strong>实例故障可以保证原子性。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>事务的一致性指的是数据符合数据库本身的定义和要求，事务执行过程不会产生非法或者无效的错误数据。Redis 通过语法错误检查机制和简单的设计来保证事务的一致性。Redis 事务的一致性依然需要分以下三种情况来考虑。</p><p><strong>命令入队时出错</strong></p><p>命令入队时出错，事务本身就会被放弃，所以可以保证事务的一致性。</p><p><strong>命令执行时出错</strong></p><p>在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，这些出错的命令不会对数据库做任何改动。也就不会对事务的一致性产生任何影响。如果硬从无效的错误数据角度来看，这种情况是破坏了事务的一致性，毕竟出错的命令虽然没有执行，但没有达到预期的目的。</p><p><strong>实例故障</strong></p><p>Redis 实例发生了故障，无论 Redis 使用哪种持久化模式，都不会影响数据库的一致性。这种情况和前文介绍的实例故障是否影响原子性的因素是一致的。</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。</p><p>由于 Redis 使用单线程的方式来执行事务，并且在执行事务期间不会对事务进行中断，也就是说 Redis 的事务总是以串行的方式运行的，事务具有隔离性。</p><p>需要特别说明的是，一个客户端在开启事务之前可以利用 <strong>WATCH</strong> 机制来监视要操作的键，通过这种方式可以自定义隔离规则，规定如果在事务执行时发现要操作的键发生了改变(也就是被其它客户端修改了)，那么就认为破坏了事务的隔离性，就需要放弃事务的执行。</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>事务的持久性指的是，当一个事务执行完毕时，执行这个事务的结果会永久性存储起来，即使服务器在事务执行完毕后宕机了，执行事务所得到的结果也不会丢失。</p><p>Redis 并没有为事务提供任何额外的持久化功能，Redis 事务的持久性由 Redis 的持久化配置模式决定。由事务的持久性特点不难看出，Redis 要实现事务的持久性必须满足以下条件：</p><ul><li>使用 AOF 模式，并且刷盘机制 <strong>appendfsync</strong> 必须设置为 <strong>always</strong>，这样数据才能尽量不丢失。</li><li>Redis 为了提高性能尽可能不阻塞主线程，允许打开 <strong>no-appendfsync-on-rewrite</strong> 配置项（默认是关闭的），控制在执行快照或重写 AOF 日志文件时停止对 AOF 文件进行刷盘。那么这种情况下即使 Redis 实例运行在 <strong>always</strong> 模式的 AOF 持久化之下，事务也不具有持久性。因此，要保证事务的持久性就不能打开 <strong>no-appendfsync-on-rewrite</strong> 配置项.</li></ul><p>注意，Redis 本身是内存数据库，持久性并不是一个必须的属性，具体可以根据使用场景进行取舍。</p><h2 id="回滚实现"><a href="#回滚实现" class="headerlink" title="回滚实现"></a>回滚实现</h2><p>Redis 的事务和传统的关系型数据库事务最大的区别在于，Redis 不支持事务回滚机制，即使事务队列中的某个命令在执行时出错，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。需要说明的是 Redis 提供的 <code>DISCARD</code> 命令，并没有回滚事务的能力，它只是用来放弃事务，把事务队列清空并重置客户端的事务状态。只要开启一个事务，就能通过 <code>DISCARD</code> 命令放弃事务。<code>DISCARD</code> 命令具体使用如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; SADD num </span><br><span class="line">(error) ERR wrong number of arguments for 'sadd' command</span><br><span class="line">(5.99s)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 放弃事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; discard</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><strong>Redis 不支持事务回滚的原因有两点：</strong>其一，较为复杂的事务回滚功能和 Redis 追求简单高效的设计主旨不相符；其二，Redis 事务执行时的错误通常都是编程错误产生的，需要使用方去避免。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Redis 的事务进行了详细介绍，并结合源码层面对整个事务的执行流程进行了梳理。可以对比 MySQL 的事务机制，对比学习 Redis 的事务机制，两者使用的场景不同，对应的实现机制也有很大差别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Redis 通过 &lt;strong&gt;MULTI&lt;/strong&gt;、&lt;strong&gt;EXEC&lt;/strong&gt;、&lt;strong&gt;DISCARD&lt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL - 事务与隔离级别</title>
    <link href="https://gentryhuang.com/posts/d80e61c2/"/>
    <id>https://gentryhuang.com/posts/d80e61c2/</id>
    <published>2021-05-21T10:49:59.000Z</published>
    <updated>2021-07-01T02:32:51.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章将以<strong>事务</strong>为主线，分别介绍事务的基本特性、事务并发问题、封锁协议、隔离级别及基本实现，最后简单介绍下 MySQL 对标准的隔离级别规范的实现。</p><h1 id="事务基本特性"><a href="#事务基本特性" class="headerlink" title="事务基本特性"></a>事务基本特性</h1><ul><li><strong>原子性(Atomicity)</strong><blockquote><p>要么全部完成，要么全部不完成。</p></blockquote></li><li><strong>一致性(Consistency)</strong><blockquote><p>一个事务单元需要提交之后才会被其它事务可见。</p></blockquote></li><li><strong>隔离性(Isolation)</strong><blockquote><p>并发事务之间不会相互影响。</p></blockquote></li><li><strong>持久性(Durability)</strong><blockquote><p>事务提交后即持久化到存储设备上。</p></blockquote></li></ul><p>注意，隔离性和一致性是有冲突的，有时候为了提高性能，会适度的破坏一致性，而这个权衡的结果会造成事务并发问题。</p><h1 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h1><ul><li><p><strong>丢失修改</strong></p><blockquote><p>回滚覆盖：回滚一个事务时，在该事务内的写操作要回滚，把其它已提交的事务写入的数据覆盖了。<br>提交覆盖：提交一个事务时，把其它已提交的事务写入的数据覆盖了。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-transaction-concurrent-problem-1.jpg" alt><br>上图描述的是回滚覆盖问题。</p></blockquote></li><li><p><strong>脏读</strong></p><blockquote><p>一个事务读取到另一个未提交事务修改过的数据。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-transaction-concurrent-problem-2.jpg" alt></p></blockquote></li><li><p><strong>不可重复读</strong></p><blockquote><p>一个事务中先后根据相同条件读取到的数据不一致。强调更新和删除操作。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-transaction-concurrent-problem-3.jpg" alt></p></blockquote></li><li><p><strong>幻读</strong></p><blockquote><p>一个事务中先后根据相同条件读取的数据记录数不一致。强调新增操作。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-transaction-concurrent-problem-4.jpg" alt></p></blockquote></li></ul><h1 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h1><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><p>为了解决并发问题，数据库系统引入了锁锁机制。在事务T对某个数据对象操作之前，先向系统发出请求对其加锁。基本的封锁类型有两种，<strong>排它锁(Exclusive locks 简记为X锁)</strong> 和 <strong>共享锁(Share locks 简记为S锁)</strong>，其中前者又称写锁，后者又称读锁。</p><ul><li>排它锁（X锁）：若事务T对数据对象A加上X锁，其它任何事务都不能在对A加任何类型的锁，直到事务T释放A上的锁为止。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</li><li>共享锁（S锁）：若事务T对数据对象A加上S锁，其它事务只能再对A加S锁而不能加X锁，直到事务T释放A上的S锁为止。</li></ul><h2 id="封锁协议-1"><a href="#封锁协议-1" class="headerlink" title="封锁协议"></a>封锁协议</h2><p>在运用X锁和S锁对数据对象加锁时，还需要约定一些规则，例如何时申请X锁或S锁、持锁时间、何时释放等，称这些加锁规则为封锁协议（Locking Protocol）。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p><ul><li><p><strong>一级封锁协议</strong></p><blockquote><p><strong>定义</strong>：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。<br><strong>说明</strong>：一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。</p></blockquote></li><li><p><strong>二级封锁协议</strong></p><blockquote><p><strong>定义</strong>：一级封锁协议基础上加事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。<br><strong>说明</strong>：二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。</p></blockquote></li><li><p><strong>三级封锁协议</strong></p><blockquote><p><strong>定义</strong>：一级封锁协议基础上加事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。<br><strong>说明</strong>：三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。</p></blockquote></li></ul><p>上述三级协议的主要区别在于什么操作需要申请封锁，以及何时释放。</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>为了解决事务并发问题，进行并发控制，数据库系统提供了四种事务隔离级别。本质上三级封锁协议反映在实际的数据库系统上，就是四种事务隔离机制。总的来说，四种事务隔离机制就是在逐渐的限制事务的自由度，以满足对不同并发控制程度的要求。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li><strong>读未提交(Read Uncommitted)</strong><blockquote><p>可以读取未提交的记录，会出现脏读，幻读，不可重复读，所有并发问题都可能遇到。</p></blockquote></li><li><strong>读已提交(Read Committed)</strong><blockquote><p>只能读取到已经提交的数据。不会出现脏读现象，但是会出现幻读，不可重复读；（大多数数据库的默认隔离级别都是 RC，但是 MySQL InnoDb 默认是 RR）。</p></blockquote></li><li><strong>可重复读(Repeated Read)</strong><blockquote><p>在同一个事务内的查询都是事务开始时刻一致的，MySQL InnoDb 默认的隔离级别，解决了不可重复读问题，但是仍然存在幻读问题。</p></blockquote></li><li><strong>串行化(Serializable)</strong><blockquote><p>所有的增删改查串行执行，啥并发问题都没有。</p></blockquote></li></ul><p>需要明确的是，以上的隔离级别是在SQL规范层面的定义，不同数据库的实现方式和使用方式并不相同，类似于JVM规范和JVM厂商的关系。</p><h2 id="传统的隔离级别实现"><a href="#传统的隔离级别实现" class="headerlink" title="传统的隔离级别实现"></a>传统的隔离级别实现</h2><p>SQL 规范中定义的四种隔离级别，分别是为了解决事务并发时可能遇到的四种问题，至于如何解决，实现方式是什么，规则中并没有严格定义。锁作为最简单最显而易见的实现方式被广为人知，因此我们在讨论某个隔离级别的时候，通常会说这个隔离级别的加锁方式是什么样的。其实，锁只是实现隔离级别的方式之一，除了锁，实现并发问题的方式还有时间戳，多版本控制等等，这些也可以称为无锁的并发控制。</p><p>采用基于锁的并发控制实现，通过对读写操作加不同的锁，以及对释放锁的时机进行不同的控制，就可以实现四种隔离级别。</p><h1 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h1><p>虽然数据库的四种隔离级别通过基于锁的并发控制（Lock-Based Concurrent Control，简写 LBCC） 技术都可以实现，但是它最大的问题是只实现了并发的读读，对于并发的读写还是冲突的，写时不能读，读时不能写，当读写操作都很频繁时，数据库的并发性将大大降低。针对这种场景，MVCC 技术应运而生，全称叫做 Multi-Version Concurrent Control（多版本并发控制），为了兼容落后的规范，数据库引擎厂商都想办法贴近四大隔离级别，但是和标准可能会有差别。</p><p>InnoDB 对事务隔离级别的实现依赖两个重要手段：LBCC、MVCC(多版本并发控制)。MVCC 可以认为是对锁机制的优化，让普通 SELECT 避免加锁，同时保证事务隔离级别的语义。</p><p>InnoDB 默认的事务隔离级别是 RR 隔离级别，它采用通过 <code>MVCC</code> 和 <code>间隙锁</code> 解决了标准的 RR 级别下存在的幻读问题。因为 <code>幻读</code> 的这个<code>读</code>字在 MySQL 里本身就存在歧义，这个<code>读</code>指的是<strong>快照读</strong>还是<strong>当前读</strong>呢？如果是快照读，MySQL 通过版本链来保证同一个事务里每次查询得到的结果集都是一致的；如果是当前读，MySQL 通过<code>间隙锁</code>保证其他事务无法插入新的数据，从而避免幻读问题。当然，如果场景中一会是快照读，一会是当前读，导致幻读现象，那就太为难 MySQL 了。</p><p>InnoDB 对串行化隔离级别是通过 <code>临键锁</code> 实现的，普通 SELECT 语句使用 <code>S临键锁</code>，当前读语句使用 <code>X临键锁</code>，加锁规则和 RR 隔离级别一致。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章主要对事务隔离级别的规范以及传统实现原理进行了介绍，并对 MySQL 的事务隔离级别的实现进行了简单说明。有了对事务整体的深入了解，对于理解 MySQL 中的锁机制、MVCC 原理会有很大的帮助。如果不知道事务隔离级别的基本实现，或者不清楚事务隔离级别和锁的关系，那么对于 MySQL 只能是管中窥豹。关于锁机制、MVCC原理会在后面的文章详细说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章将以&lt;strong&gt;事务&lt;/strong&gt;为主线，分别介绍事务的基本特性、事务并发问题、封锁协议、隔离级别及基本实现，最后简单介绍下
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://gentryhuang.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL - 慢查询日志</title>
    <link href="https://gentryhuang.com/posts/4132ef9f/"/>
    <id>https://gentryhuang.com/posts/4132ef9f/</id>
    <published>2021-05-14T11:17:14.000Z</published>
    <updated>2021-05-25T03:06:04.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MySQL 慢查询日志是排查问题 SQL 语句，以及检查当前 MySQL 性能的一个重要手段。默认情况下，MySQL 并不启动慢查询日志，需要我们手动来开启。如果不是调优需要的话，一般不建议开启慢查询，毕竟开启慢查询或多或少会带来一定的性能影响。</p><h1 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h1><ul><li><strong>slow_query_log:</strong>  是否开启慢查询日志，默认 OFF，开启则设置为 ON。</li><li><strong>slow_query_log_file:</strong>  慢查询日志文件存储位置。</li><li><strong>long_query_time:</strong>  超过多少秒的查询才会记录到日志中。单位是秒。</li><li><strong>log_queries_not_using_indexes:</strong>  是否把没有使用到索引的 SQL 记录到日志中，默认 OFF,开启则设置为 ON。</li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>默认情况下是没有开启慢查询日志，下面通过两种配置方式进行设置。</p><h2 id="临时配置"><a href="#临时配置" class="headerlink" title="临时配置"></a>临时配置</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log='ON';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; set global slow_query_log_file='/var/lib/mysql/instance-1-slow.log';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; set global long_query_time=2; # 下次会话才会生效</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="永久配置"><a href="#永久配置" class="headerlink" title="永久配置"></a>永久配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;mysql.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log &#x3D; ON</span><br><span class="line">slow_query_log_file &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;instance-1-slow.log</span><br><span class="line">long_query_time &#x3D; 2</span><br></pre></td></tr></table></figure><p>配置好慢 SQL 相关参数后，重启 MySQL 即可。</p><h1 id="查看慢查询功能"><a href="#查看慢查询功能" class="headerlink" title="查看慢查询功能"></a>查看慢查询功能</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'slow_query%';</span><br><span class="line">+<span class="comment">---------------------+----------------------------------+</span></span><br><span class="line">| Variable_name       | Value                            |</span><br><span class="line">+<span class="comment">---------------------+----------------------------------+</span></span><br><span class="line">| slow_query_log      | ON                               |</span><br><span class="line">| slow_query_log_file | /var/lib/mysql/mysql001-slow.log |</span><br><span class="line">+<span class="comment">---------------------+----------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.05</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'long_query_time';</span><br><span class="line">+<span class="comment">-----------------+----------+</span></span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+<span class="comment">-----------------+----------+</span></span><br><span class="line">| long_query_time | 1.000000 |</span><br><span class="line">+<span class="comment">-----------------+----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'log_queries_not_using_indexes';</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| log_queries_not_using_indexes | OFF   |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h1 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h1><p><strong>mysqldumpslow</strong> 是 MySQL 官方提供的慢查询日志分析工具，使用 <strong>mysqldumpslow</strong> 命令可以非常明确的得到各种我们需要的查询语句。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>慢查询日志是排查SQL问题以及优化的重要手段，在生产环境中一般都会实时采集慢查询日志，对 MySQL 查询语句监控、分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;MySQL 慢查询日志是排查问题 SQL 语句，以及检查当前 MySQL 性能的一个重要手段。默认情况下，MySQL 并不启动慢查询日志，需
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://gentryhuang.com/categories/MySQL/"/>
    
    
      <category term="慢查询日志" scheme="https://gentryhuang.com/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>缓存一致性问题</title>
    <link href="https://gentryhuang.com/posts/fa9a5340/"/>
    <id>https://gentryhuang.com/posts/fa9a5340/</id>
    <published>2021-05-04T04:44:15.000Z</published>
    <updated>2021-06-24T09:59:07.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>使用 DB + Cache 的架构时，会带来缓存和数据库一致性问题。理论上来说，给缓存设置过期时间是保证最终一致性的解决方案。基于此，所有的写操作以 DB 为准，对 Cache 操作尽最大努力即可，也就是说如果 DB 写成功，缓存更新失败，那么只要到达过期时间缓存就会失效，后续的读请求获取的自然就是最新的数据并回填 Cache。</p><p>对于缓存和数据库一致性问题有很多的解决方案，没有最完美的方案，只有适合业务场景的方案。注意，本文讨论的相关更新策略是不考虑缓存过期时间问题。</p><h1 id="Cache-操作方式"><a href="#Cache-操作方式" class="headerlink" title="Cache 操作方式"></a>Cache 操作方式</h1><p>当数据 data 发生改变时，对 Cache 的操作有两种方式：<strong>更新 Cache 中的数据</strong>和<strong>淘汰 Cache 中的数据</strong> 。</p><p><strong>更新 Cache</strong></p><blockquote><p>更新 Cache 是指数据 data 不仅会写入 DB，还会写入 Cache 。更新 Cache 的优点：缓存不会增加一次 miss，命中率高。</p></blockquote><p><strong>淘汰 Cache</strong></p><blockquote><p>淘汰 Cache 是指数据 data 只会写入 DB，不会写入 Cache，并且把 Cache 清除。</p></blockquote><p>使用<strong>更新 Cache</strong> 还是<strong>淘汰 Cache</strong> 取决于设置 Cache 的复杂度。Cache 可能是单一的值，也可能是通过复杂的计算得到的值，前者适合使用更新 Cache，后者适合使用淘汰 Cache。但从总体上考虑，淘汰 Cache 操作简单，并且带来的副作用只是增加了一次 Cache miss，因此推荐使用淘汰 Cache 的处理方式。</p><h1 id="Cache-和-DB-操作序列"><a href="#Cache-和-DB-操作序列" class="headerlink" title="Cache 和 DB 操作序列"></a>Cache 和 DB 操作序列</h1><p>当数据 data 发生改变时，除了需要对 Cache 的操作进行选择（推荐使用淘汰 Cache），还需要对 Cache 和 DB 的操作序列进行选择：</p><ul><li>先更新 DB，后淘汰 Cache</li><li>先淘汰 Cache，后更新 DB</li></ul><p>对于不能保证事务性的操作，选择标准是：<strong>当出现不一致，哪个操作影响较小，就选择该操作先执行</strong>。由于更新 DB 和淘汰 Cache 不能保证原子性，因此需要判断哪一个先执行影响更小。</p><p><strong>先更新 DB，后淘汰 Cache</strong></p><blockquote><p>操作 DB 失败没有影响，重试即可。一旦更新 DB 成功，淘汰 Cache 失败，则会出现 DB 中是新数据，Cache 中是旧数据，导致<strong>数据不一致</strong>。</p></blockquote><p><strong>先淘汰 Cache，后更新 DB</strong></p><blockquote><p>淘汰 Cache 失败没有影响，重试即可。一旦淘汰 Cache 成功，更新 DB 失败，<strong>只会引发一次 Cache miss</strong>。</p></blockquote><p>结论：<strong>先淘汰 Cache，再更新 DB</strong> 。</p><p><strong>特别说明：</strong>这里给出的先淘汰 Cache ，再更新 DB 是针对没有额外处理手段的情况下，这种操作序列即使出现问题影响是最小的。如果使用类似重试机制保证操作序列的完整性，那么这两种序列就没有多大差异了，下文会着重分析。</p><h1 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h1><p><strong>淘汰 Cache</strong> 是一种推荐的处理方式，<strong>先淘汰 Cache 后更新 DB</strong> 的时序产生问题相对更小。下面我们对常见方案进行分析：</p><ul><li><strong>先更新 DB，再更新 Cache</strong></li><li><strong>先淘汰 Cache，再更新 DB</strong></li><li><strong>先更新 DB，再淘汰 Cache</strong></li></ul><p>需要说明的是，先更新 Cache，再更新 DB 的策略问题较大，一旦出现不一致就存在超前的脏数据，这样的不一致是要不得的。根据上文我们分析的，先更新 DB，再更新 Cache 也是不推荐的。</p><h2 id="先更新-DB-后更新-Cache"><a href="#先更新-DB-后更新-Cache" class="headerlink" title="先更新 DB 后更新 Cache"></a>先更新 DB 后更新 Cache</h2><p>该策略也是不推荐使用的，主要原因如下：</p><ol><li>并发更新导致缓存更新顺序问题<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-1.jpg" alt><br>如上图，线程 A、B 同时进行更新操作，那么会出现：<blockquote><ol><li>线程 A 更新了 DB</li><li>线程 B 更新了 DB</li><li>线程 B 更新了 Cache</li><li>线程 A 更新了 Cache</li></ol></blockquote></li></ol><p>线程 A 先进行了 DB 更新操作，理论上也应该是线程 A 先更新 Cache，但因为线程 A 处理的较慢，缓存最后是线程 A 更新后的值。这就导致了脏数据。可以使用串行化解决，但是会导致效率变低。<br>2. 更新 DB 成功，但更新 Cache 失败时会导致 Cache 中的脏数据。</p><p>这里为了完整性，把该策略列举出来，了解即可。我们重点关注另外两种方式。</p><h2 id="先淘汰-Cache-后更新-DB"><a href="#先淘汰-Cache-后更新-DB" class="headerlink" title="先淘汰 Cache 后更新 DB"></a>先淘汰 Cache 后更新 DB</h2><p>针对以上更新 Cache 出现的问题，有人就提出淘汰 Cache 的策略。先淘汰 Cache ，如果成功，则更新 DB；如果失败则不更新 DB，后续可以通过重试来解决失败的问题，但是增加了一次 Cache 的 miss。该策略导致不一致的原因不在于后更新 DB 失败了，而是汰 Cache 成功，但更新 DB 完成前存在读请求将旧数据设置到 Cache 中造成脏数据（并发问题），具体场景如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-2.jpg" alt><br>如上图，同时有一个线程 A 进行更新操作，另一个线程 B 进行查询操作，那么就会出现：</p><blockquote><ol><li>线程 A 淘汰 Cache</li><li>线程 B 没有命中 Cache</li><li>线程 B 查询 DB</li><li>线程 B 将查询结果写入 Cache ，对<strong>后续读</strong>就是脏数据</li><li>线程 A 更新 DB</li></ol></blockquote><p>上述情况会导致不一致的问题，而且，如果不采用给 Cache 设置过期时间策略，该脏数据会一直保留到下次更新操作。</p><p>针对以上问题可以采用 <strong>延时双删策略</strong> 将 Cache 脏数据删除，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 数据 key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String key, Object data)</span> </span>&#123;</span><br><span class="line">    cache.delKey(key);<span class="comment">// 1 淘汰 Cache</span></span><br><span class="line">    db.updateData(data); <span class="comment">// 2 更新 DB</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 3 延时 delay</span></span><br><span class="line">    cache.delKey(key);<span class="comment">// 4 再次淘汰 Cache</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在更新 DB 完成后，评估一定的延时时间再次淘汰 Cache 。这里的延时时间不好确定，一般需要评估项目读数据业务逻辑的耗时，在此基础上加一定的毫秒值即可。值得一说的是，延时一定的时间才会再次淘汰 Cache 是为了确保读请求结束，写请求可以删除读请求造成的缓存脏数据。这里也可以看出，并不是更新 DB 后立刻再次淘汰 Cache ，因为可能有线程读取到了更新前的旧数据还没来得及写入缓存，因此需要等待它写入缓存。</p><p>如果 DB 采用读写分离架构，可能产生以下问题：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-3.jpg" alt><br>如上图，过程如下：</p><blockquote><ol><li>线程 A 淘汰 Cache</li><li>线程 A 更新 DB</li><li>线程 B 没有命中缓存</li><li>线程 B 查询从库 DB，此时并没有完成主从同步，因此查询的是旧值</li><li>线程 B 将旧值放入 Cache</li><li>主从同步完成</li></ol></blockquote><p>上述解决方案还是使用 <strong>延时双删策略</strong>，只需要延时时间确保完成主从同步，即主从同步完成再删一次 Cache 即可。</p><p><strong>存在问题</strong></p><p>第二次淘汰 Cache 是为了防止 Cache 中的脏数据（旧的数据）而做的操作，而非业务要求。因此，<strong>延时双删策略</strong>虽然在<strong>一定程度上</strong>能保证 Cache 中不会有脏数据，但对业务是有损的，具体表现为：</p><ul><li>吞吐量降低<blockquote><p>问题描述：因为要实现延时淘汰 Cache，写的请求需要休眠等待一段时间。<br>解决方案：将第二次淘汰 Cache 以异步处理，这样写请求完成后就能立即返回，提高吞吐量。</p></blockquote></li><li>第二次淘汰 Cache 失败<blockquote><p>问题描述：写请求完成了 DB 更新，再次淘汰 Cache 失败了，导致 Cache 和 DB 一致性问题<br>解决方案：理论上可以依赖 Cache 的失效时间，但是可能不及时，因此最好采用重试机制，具体实现下文详细分析。</p></blockquote></li></ul><p>此外，<strong>延时双删策略</strong>只能在<strong>一定程度上</strong>能保证 Cache 中不会有脏数据，具体哪种程度要看<strong>延时时间</strong>的准确性。</p><h2 id="先更新-DB-后淘汰-Cache"><a href="#先更新-DB-后淘汰-Cache" class="headerlink" title="先更新 DB 后淘汰 Cache"></a>先更新 DB 后淘汰 Cache</h2><p>基于同样套路，我们先分别从并发和操作完整性出发，分析该策略存在的问题。</p><p><strong>并发问题</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-4-fix.jpg" alt><br>如上图，线程 A 执行查询，线程 B 执行更新，那么会有如下情况：</p><blockquote><ol><li>线程 A 没有命中 Cache</li><li>线程 A 查询 DB</li><li>线程 B 更新 DB</li><li>线程 B 淘汰 Cache</li><li>线程 A 将查询到的旧值放入 Cache</li></ol></blockquote><p>由于 DB 读操作速度远快于写操作，因此这样的并发问题（放入值到缓存还没有一次磁盘IO快）导致的脏数据概率非常非常低。如果非要解决，依然可以采用<strong>延时双删策略</strong>，即保证读请求完成后再一次淘汰 Cache。</p><p><strong>淘汰 Cache 时延问题</strong><br>在更新 DB 后还没来得及淘汰 Cache，其它请求就开始读取数据了，那么此时由于能命中缓存，就会直接从缓存中取旧数据，因此会有不一致数据短暂存在。不过，在这种情况下如果并发读缓存的请求不多，对业务影响还是小的，毕竟缓存很快就会被淘汰，后续请求就不会读取到旧的值了。再严格就需要使用分布式事务了。</p><h3 id="淘汰-Cache-失败"><a href="#淘汰-Cache-失败" class="headerlink" title="淘汰 Cache 失败"></a>淘汰 Cache 失败</h3><p>淘汰 Cache 失败也是<strong>延时双删策略</strong>中存在的问题，也同样会产生脏数据问题，<strong>根本策略就是重试，保证淘汰 Cache 成功</strong>。</p><p><strong>如果对一致性要求不是很高，可以使用以下两种方案：</strong></p><blockquote><ol><li>等待 Cache 过期失效</li><li>直接在程序中另起一个线程，定时重试</li></ol></blockquote><p>如果对一致性要求相对较高，就需要采用其它手段来保证及时淘汰掉 Cache 。下面就先更新 DB 后淘汰 Cache 给出两个具体方案，其中淘汰 Cache 的流程是通用的。</p><h3 id="消息队列重试"><a href="#消息队列重试" class="headerlink" title="消息队列重试"></a>消息队列重试</h3><p>通过消息 MQ 来实现重试，即将淘汰 Cache 失败的数据 key 发送到 MQ 中，然后消费MQ，执行淘汰 Cache 操作，直到淘汰成功。流程图如下：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-5.jpg" alt></p><p><strong>上图流程描述如下：</strong></p><blockquote><ol><li>更新 DB</li><li>淘汰 Cache 失败</li><li>将数据 key 发送到消息队列</li><li>消费消息，获得数据 key</li><li>继续重试淘汰 Cache 操作，直到成功</li></ol></blockquote><p>使用该方案有一个缺点，会对业务代码造成一定侵入，因为业务方需要关心将数据 key 写入到 MQ 中。采用订阅 binlog 的方式就可以做到对业务代码无侵入，下面我们就来看这种方式。</p><h3 id="订阅-binlog-重试"><a href="#订阅-binlog-重试" class="headerlink" title="订阅 binlog 重试"></a>订阅 binlog 重试</h3><p>启动一个订阅程序去订阅 DB 的 binlog，获取 binlog 中的数据的key，然后执行淘汰 Cache 操作，如果失败，则发送数据 key 到 MQ，后续同方案一。流程图如下：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-6.jpg" alt></p><p><strong>上图流程描述如下：</strong></p><blockquote><ol><li>更新 DB</li><li>DB 将操作信息写入 binlog 日志中</li><li>binlog 订阅程序提取出所需的数据 key</li><li>非业务代码获取数据 key</li><li>尝试根据数据 key 淘汰 Cache</li><li>如果淘汰 Cache 失败，则将数据 key 发送到消息队列</li><li>重新从消息队列中获得数据 key</li><li>继续重试淘汰 Cache，直到成功</li></ol></blockquote><p>其中订阅程序在 Mysql 中有 Canal 中间件，可以直接使用它完成订阅 binlog 日志的功能。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>本文介绍的缓存一致性解决方案都不能保证操作的原子性。如果需要严格保证缓存和数据库的一致性，也就是保证两者操作的原子性，就需要用到分布式事务来解决。常见的解决方案：两阶段提交（2PC）、三阶段提交（3PC）、TCC、消息队列等，这些方案相对比较复杂，一般用在对于一致性要求较高的业务场景中。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章着重点在于，DB 更新完成后，Cache 淘汰失败了，基于这种情况可以根据业务的特点选择对应的方式进行处理。如果对一致性要求不是很高，那么在淘汰 Cache 失败后可以选择等待缓存失效和异步定时重试；如果对一致性要求相对较高，那么可以使用消息队列和订阅 binlog 的方式重试淘汰 Cache 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;使用 DB + Cache 的架构时，会带来缓存和数据库一致性问题。理论上来说，给缓存设置过期时间是保证最终一致性的解决方案。基于此，所有的
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="缓存" scheme="https://gentryhuang.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
